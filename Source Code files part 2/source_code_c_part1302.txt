est(
                AuthenticationPackage,
                SP_ORDINAL_CALLPACKAGE
                );

    if (Package == NULL)
    {
        DebugLog((DEB_WARN,"LsapCallPackage failed: package %wZ not found\n",
            AuthenticationPackage ));
        Status = STATUS_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Set the session to be the LSA's so calls to allocate memory
    // will allocate in the correct process
    //

    OldSession = GetCurrentSession();
    SetCurrentSession( pDefaultSession );

    Status = Package->FunctionTable.CallPackage(
                NULL,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                );

    //
    // Restore our original session
    //

    SetCurrentSession( OldSession );


Cleanup:

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   LsaICallPackagePassthrough
//
//  Synopsis:   Function to call another security package for pass-through request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LsaICallPackagePassthrough(
    IN PUNICODE_STRING AuthenticationPackage,
    IN PVOID ClientBufferBase,
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_SECURITY_PACKAGE Package;
    PSession OldSession;

    Package = SpmpLookupPackageAndRequest(
                AuthenticationPackage,
                SP_ORDINAL_CALLPACKAGE
                );

    if (Package == NULL)
    {
        DebugLog((DEB_WARN,"LsapCallPackage failed: package %wZ not found\n",
            AuthenticationPackage ));
        Status = STATUS_NO_SUCH_PACKAGE;
        goto Cleanup;
    }

    //
    // Set the session to be the LSA's so calls to allocate memory
    // will allocate in the correct process
    //

    OldSession = GetCurrentSession();
    SetCurrentSession( pDefaultSession );

    Status = Package->FunctionTable.CallPackagePassthrough(
                NULL,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus
                );

    //
    // Restore our original session
    //

    SetCurrentSession( OldSession );


Cleanup:

    return(Status);

}

extern "C"
VOID
LsaIFreeReturnBuffer(
    IN PVOID Buffer
    )
/*++

Routine Description:

    Some of the LSA authentication services allocate memory buffers to
    hold returned information.  This service is used to free those buffers
    when no longer needed.

Arguments:

    Buffer - Supplies a pointer to the return buffer to be freed.

Return Status:

    STATUS_SUCCESS - Indicates the service completed successfully.

    Others - returned by NtFreeVirtualMemory().

--*/

{

    SIZE_T Length;

    Length = 0;

    DebugLog(( DEB_TRACE_HELPERS, "LsaIFreeReturnBuffer - freeing VM at %x\n", Buffer ));
    if (((ULONG_PTR) Buffer & 0xfff) != 0)
    {
        DbgPrint("Freeing non-page address: %p\n",Buffer);
        DbgBreakPoint();
    }

    NtFreeVirtualMemory(
        NtCurrentProcess(),
        &Buffer,
        &Length,
        MEM_RELEASE
        );

}

NTSTATUS
LsaClientCallback(
    PCHAR   Callback,
    ULONG_PTR Argument1,
    ULONG_PTR Argument2,
    PSecBuffer Input,
    PSecBuffer Output
    )
{
    PSession Session ;
    ULONG Type ;

    Session = GetCurrentSession();

    if ( !Session )
    {
        Session = pDefaultSession ;
    }
    if ( !Session->hPort &&
         ((Session->fSession & SESFLAG_DEFAULT) == 0) )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    if ( (ULONG_PTR) Callback < 0x00010000 )
    {
        Type = SPM_CALLBACK_PACKAGE ;
    }
    else
    {
        Type = SPM_CALLBACK_EXPORT ;
    }

    return LsapClientCallback(  Session,
                                Type,
                                Callback,
                                (PVOID) Argument1,
                                (PVOID) Argument2,
                                Input,
                                Output );
}


#if 0
BOOL
LsapCaptureAuthData(
    PVOID   pvAuthData,
    BOOLEAN DesiredAnsi,
    PSEC_WINNT_AUTH_IDENTITY * AuthData
    )
{
    SEC_WINNT_AUTH_IDENTITY Auth ;
    PSEC_WINNT_AUTH_IDENTITY pAuth ;
    SECURITY_STATUS Status ;
    ULONG   TotalSize ;

    PWSTR   CurrentW ;
    PSTR    CurrentA ;
    PVOID   Current ;

    PWSTR   ConvertBufferW ;
    PSTR    ConvertBufferA ;
    PVOID   Convert;

    ULONG   Longest ;


    ZeroMemory( &Auth, sizeof( Auth ) );

    Status = LsapCopyFromClientBuffer(
                            NULL,
                            sizeof( SEC_WINNT_AUTH_IDENTITY ),
                            & Auth,
                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    Longest = Auth.UserLength ;
    Longest = max( Longest, Auth.DomainLength );
    Longest = max( Longest, Auth.PasswordLength );

    Longest = (Longest + 1) * sizeof(WCHAR);

    //
    // Always go with the extra, so we can handle DBCS
    //

    TotalSize = sizeof( SEC_WINNT_AUTH_IDENTITY ) +
                ( Auth.UserLength + 1 +
                  Auth.DomainLength + 1 +
                  Auth.PasswordLength + 1 ) * sizeof( WCHAR );


    pAuth = (PSEC_WINNT_AUTH_IDENTITY) LsapAllocateLsaHeap( TotalSize );

    if ( !pAuth )
    {
        return FALSE ;
    }

    ConvertBufferW = NULL ;
    ConvertBufferA = NULL ;
    Convert = NULL ;
    CurrentA = NULL ;
    CurrentW = NULL ;

    if ( Auth.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
    {
        if ( !DesiredAnsi )
        {
            ConvertBufferA = (PSTR) LocalAlloc( LMEM_FIXED, Longest );
            Convert = ConvertBufferA ;
            CurrentW = (PWSTR) (pAuth + 1);
        }
        else
        {
            CurrentA = (PSTR) (pAuth + 1);
        }
    }
    else
    {
        if ( DesiredAnsi )
        {
            ConvertBufferW = (PWSTR) LocalAlloc( LMEM_FIXED, Longest );
            CurrentA = (PSTR) (pAuth + 1);
        }
        else
        {
            CurrentW = (PWSTR) pAuth + 1);
        }
    }

    pAuth->Flags = Auth.Flags ;

    CurrentW = (PWSTR) (pAuth + 1);
    CurrentA = (PSTR) (pAuth + 1);
    Current = CurrentW ;

    if ( Auth.User )
    {
        pAuth->User = Current ;

        Status = LsapCopyFromClientBuffer(
                            NULL,
                            (Auth.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI ?
                                ( Auth.UserLength + 1 ) :
                                ( (Auth.UserLength + 1 ) * sizeof( WCHAR ) ) ),
                            (Convert ? Convert : Current ),
                            Auth.User );

        if ( Convert )
        {
            if ( ConvertBufferA )
            {

            }

        }
        else
        {
            pAuth->UserLength = Auth.UserLength ;
        }

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.UserLength + 1) * sizeof(WCHAR) ,
                            pAuth->User,
                            Auth.User );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.UserLength + 1;
    }

    if ( Auth.Domain )
    {
        pAuth->Domain = Current ;
        pAuth->DomainLength = Auth.DomainLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.DomainLength + 1) * sizeof( WCHAR ),
                            pAuth->Domain,
                            Auth.Domain );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.DomainLength + 1;

    }

    if ( Auth.Password )
    {
        pAuth->Password = Current ;
        pAuth->PasswordLength = Auth.PasswordLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.PasswordLength + 1) * sizeof( WCHAR ),
                            pAuth->Password,
                            Auth.Password );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.PasswordLength + 1;

    }

    *AuthData = pAuth ;

    return TRUE ;

Error_Cleanup:

    LocalFree( pAuth );

    return FALSE ;

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   LsapUpdateCredentials
//
//  Synopsis:   This function provides a mechanism for one package to notify
//              another package that the credentials for a logon session
//              have changed.
//
//  Effects:
//
//  Arguments:  PrimaryCredentials - Primary information about the user.
//                      All fields may be NULL but the LogonId
//              Credentials - Array of credentials for different packages
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
LsapUpdateCredentials(
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    return(LsapUpdateCredentialsWorker(
                (SECURITY_LOGON_TYPE) 0,              // no logon type
                NULL,           // no account name
                PrimaryCredentials,
                Credentials ));
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapUpdateCredentialsWorker
//
//  Synopsis:   Worker function for updated credentials - calls all package
//              with specified credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapUpdateCredentialsWorker(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    NTSTATUS Status;
    ULONG_PTR CurrentPackageId;
    PLSAP_SECURITY_PACKAGE SupplementalPackage;
    SupplementalPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_ACCEPTCREDS );

    CurrentPackageId = GetCurrentPackageId();
    while (SupplementalPackage)
    {

        if (SupplementalPackage->dwPackageID != CurrentPackageId)
        {
            ULONG Index;
            PSECPKG_SUPPLEMENTAL_CRED SuppCreds;

            //
            // For all packages,  do the accept call so the
            // package can associate the credentials with
            // the logon session.
            //

            DebugLog((DEB_TRACE_WAPI, "Whacking package %ws with %x:%x = %wZ\n",
                        SupplementalPackage->Name.Buffer,
                        PrimaryCredentials->LogonId.HighPart, PrimaryCredentials->LogonId.LowPart,
                        AccountName));


            SetCurrentPackageId( SupplementalPackage->dwPackageID );

            //
            // Find any supplmental credentials
            //

            SuppCreds = NULL;
            if (Credentials != NULL)
            {
                for (Index = 0; Index < Credentials->CredentialCount ; Index++ ) {
                    if (RtlEqualUnicodeString(
                            &Credentials->Credentials[Index].PackageName,
                            &SupplementalPackage->Name,
                            TRUE))
                    {
                        SuppCreds = &Credentials->Credentials[Index];
                        break;
                    }

                }
            }

            __try
            {
                Status = SupplementalPackage->FunctionTable.AcceptCredentials(
                                LogonType,
                                AccountName,
                                PrimaryCredentials,
                                SuppCreds
                                );
            }
            __except (SP_EXCEPTION)
            {
                Status = GetExceptionCode();
                Status = SPException(Status, SupplementalPackage->dwPackageID);
            }


            // Note:  if an exception occurs, we don't fail the logon, we just
            // do the magic on the package that blew.  If the package blows,
            // the other packages may succeed, and so the user may not be able
            // to use that provider.

        }

        SupplementalPackage = SpmpIteratePackagesByRequest(
                                SupplementalPackage,
                                SP_ORDINAL_ACCEPTCREDS
                                );

    }
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spmsgs.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spmsgs.h

Abstract:

    Definitions for SPMgr Event-log worthy events

Author:

    RichardW,  3 Mar 95

Revision History:

Notes:

    This file is generated by the MC tool from the spmsgs.mc file.

--*/


#ifndef __SPMSGS_H__
#define __SPMSGS_H__

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: CATEGORY_SPM
//
// MessageText:
//
//  Security Package Manager
//
#define CATEGORY_SPM                     0x00000001L

//
// MessageId: CATEGORY_LOCATOR
//
// MessageText:
//
//  Locator
//
#define CATEGORY_LOCATOR                 0x00000002L

//
// MessageId: CATEGORY_MAX_CATEGORY
//
// MessageText:
//
//  Max
//
#define CATEGORY_MAX_CATEGORY            0x00000003L

//
// MessageId: SPMEVENT_SUPPCRED_FAILED
//
// MessageText:
//
//  The supplemental credentials for security package %1 for user %2%3 could not
//  updated.  The return code is the data.
//
#define SPMEVENT_SUPPCRED_FAILED         0x80000FA0L

//
// MessageId: SPMEVENT_PACKAGE_FAULT
//
// MessageText:
//
//  The security package %1 generated an exception.  The package is now disabled.
//  The exception information is the data.
//
#define SPMEVENT_PACKAGE_FAULT           0xC0001388L


#endif // __SPMSGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        spmgr.c
//
// Contents:    Main file of the SPMgr component
//
// Functions:   SetKsecEvent                -- Sets the event exported by DD
//              ServerMain                  -- Main startup
//
//
// History:     27 May 92,  RichardW    Commented
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "spinit.h"
}



///////////////////////////////////////////////////////////////////////////
//
//
//    Global "Variables"
//
//
//    Most of these variables are set during initialization, and are used
//    in a read-only fashion afterwards.
//
//
///////////////////////////////////////////////////////////////////////////

PWSTR   pszPackageList;                 // Not really needed

LUID    SystemLogonId = SYSTEM_LUID;    // Logon Session for the system (should be 999:0)


DWORD   dwSession;          // TLS: Thread Session ptr
DWORD   dwLastError;        // TLS: Thread last error
DWORD   dwExceptionInfo;    // TLS: Thread exception info
DWORD   dwCallInfo;         // TLS: Thread LPC message ptr
DWORD   dwThreadPackage;    // TLS: Thread Package ID
DWORD   dwThreadHeap;       // TLS: Thread Heap

BOOLEAN SetupPhase;

HANDLE  hShutdownEvent;     // Shutdown synch event
HANDLE  hStateChangeEvent;  // State change event

SECURITY_STRING MachineName;

PWSTR * ppszPackages;       // Contains a null terminated array of dll names
PWSTR * ppszOldPkgs;        // Contains a null terminated array of old pkgs

LsaState    lsState;        // State of the process, for relay to the dll

LSA_TUNING_PARAMETERS   LsaTuningParameters ;
BOOL ShutdownBegun ;

//
// Name of event which says that the LSA RPC server is ready
//

#define LSA_RPC_SERVER_ACTIVE           L"\\BaseNamedObjects\\LSA_RPC_SERVER_ACTIVE"



#if TRACK_MEM
extern FILE * pMemoryFile;
extern DWORD dwTotalHeap;
extern DWORD dwHeapHW;
#endif

HANDLE hPrelimShutdownEvent;

DWORD
ShutdownWorker(
    PVOID Ignored
    )
{
    NTSTATUS Status ;
    PLSAP_SECURITY_PACKAGE     pAuxPackage;
    ULONG_PTR iPackage ;
    DWORD Tick ;
    DWORD TickMax ;

    //
    // Stop any new calls from getting through
    //

    ShutdownBegun = TRUE ;

    LsapShutdownInprocDll();

    if ( LsaTuningParameters.Options & TUNE_SRV_HIGH_PRIORITY )
    {
        TickMax = 100 ;
    }
    else 
    {
        TickMax = 10 ;
    }

    pAuxPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_SHUTDOWN );

    while (pAuxPackage)
    {
        iPackage = pAuxPackage->dwPackageID;
        pAuxPackage->fPackage |= SP_SHUTDOWN_PENDING | SP_SHUTDOWN ;

        DebugLog((DEB_TRACE, "Shutting down package %ws\n",
            pAuxPackage->Name.Buffer ));

        //
        // Spin wait for the calls in progress to complete
        //

        Tick = 0 ;

        while ( (pAuxPackage->CallsInProgress > 0) &&
                ( Tick < TickMax ) )
        {
            Sleep( 100 );

            Tick++ ;
        }

        if ( Tick == TickMax )
        {
            DebugLog(( DEB_ERROR, "Package %ws did not respond in %d seconds for shutdown\n",
                       pAuxPackage->Name.Buffer,
                       Tick / 10 ));

            pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                        SP_ORDINAL_SHUTDOWN );

            continue;
        }

        SetCurrentPackageId( iPackage );

        __try
        {
            Status = pAuxPackage->FunctionTable.Shutdown();
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = (NTSTATUS) GetExceptionCode();
        }

        pAuxPackage->fPackage &= ~SP_SHUTDOWN_PENDING ;

        pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                    SP_ORDINAL_SHUTDOWN );

    }

    SetCurrentPackageId( SPMGR_ID );

    SetEvent( hShutdownEvent );

    return 0;


}

//+-------------------------------------------------------------------------
//
//  Function:   ServerStop
//
//  Synopsis:   Stop the SPM.  Clean shutdown
//
//--------------------------------------------------------------------------
HRESULT
ServerStop(void)
{
    // First, see if we are already in the middle of a shutdown.  The
    // hShutdownEvent handle will be non-null.

    if (hShutdownEvent)
    {
        return(0);
    }

    DebugLog((DEB_TRACE, "LSA shutdown:\n"));

    hShutdownEvent = SpmCreateEvent(NULL, TRUE, FALSE, L"\\SpmShutdownEvent");

    if (hPrelimShutdownEvent)
    {
        SetEvent(hPrelimShutdownEvent);
    }

    QueueUserWorkItem( ShutdownWorker, NULL, FALSE );


    return(S_OK);
}

#if DBG
void
SpmpThreadStartupEx(void)
{
    PSpmExceptDbg pExcept;

    pExcept = (PSpmExceptDbg) LsapAllocateLsaHeap(sizeof(SpmExceptDbg));
    MarkPermanent(pExcept);
    TlsSetValue(dwExceptionInfo, pExcept);

}

void
SpmpThreadExitEx(void)
{
    PSpmExceptDbg   pExcept;

    pExcept = (PSpmExceptDbg) TlsGetValue(dwExceptionInfo);
    if (pExcept)
    {
        UnmarkPermanent(pExcept);
        LsapFreeLsaHeap(pExcept);
    }
}
#endif // DBG

//+-------------------------------------------------------------------------
//
//  Function:   SpControlHandler
//
//  Synopsis:   Console Control Function handler
//
//  Effects:    Handles system shutdown
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOL
SpConsoleHandler(DWORD  dwCtrlType)
{
    SpmpThreadStartup();

    DebugLog((DEB_TRACE, "Entered SpConsoleHandler(%d)\n", dwCtrlType));
    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
        case CTRL_BREAK_EVENT:
            SpmpThreadExit();
            return(FALSE);
            break;

        case CTRL_CLOSE_EVENT:
        case CTRL_SHUTDOWN_EVENT:
            DebugLog((DEB_TRACE, "Shutdown event received\n"));

            LsapState.SystemShutdownPending = TRUE;
            (void) ServerStop();
            (void) WaitForSingleObject(hShutdownEvent, 10000L);

            DebugLog((DEB_TRACE, "Shutdown complete\n"));

            // Fall through to:

        default:
            SpmpThreadExit();
            return(FALSE);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spinit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPInit.cxx
//
// Contents:    Initialization code for SPMgr/LSA
//
// Functions:   LoadPackages                -- Loads all the packages
//              InitThreadData              -- Creates TLS values
//              InitSystemLogon             -- Initializes the System logon
//              LsapEnableCreateTokenPrivilege  -- Enables the privilege
//              InitLocatorAndOle           -- Initializes Locator cache, Ole
//              InitKDCData                 -- Initializes knowledge about KDC
//
//
// History:     08 Sep 92,  RichardW    Created from spmgr.c, etc.
//              26 Mar 93,  MikeSw      Converted from C->C++
//
//------------------------------------------------------------------------

//
// precompiled headers
//

#include <lsapch.hxx>
extern "C"
{
#include "spinit.h"
#include <lmcons.h>
#include <crypt.h>
#include <logonmsv.h>
#include <ssi.h>
#include <lsads.h>
}

// #include <crypto.h>










//+-------------------------------------------------------------------------
//
//  Function:   LoadPackages
//
//  Synopsis:   Loads all the specified security packages
//
//  Effects:    Packages loaded, global structures updated
//
//  Arguments:  comma-separated list of package names (DLL names)
//
//  Requires:
//
//  Returns:    SUCCESS, or some failures
//
//  Notes:      This is run during SPM Init, while the process is still
//              single threaded, and not handling any calls.
//
//--------------------------------------------------------------------------

extern "C"
NTSTATUS
LoadPackages(   PWSTR * ppszPackages,
                PWSTR * ppszOldPkgs,
                PWSTR   pszPreferred)
{
    PWSTR           pszPackage;
    NTSTATUS scRet;
    SECURITY_STRING sStr;
    SECPKG_PARAMETERS Parameters;
    ULONG           iPackage = 0;
    ULONG           iOldPkg = 0;
    ULONG           LoadCount = 0;
    ULONG           NewCount = 0;
    ULONG           PreferredPackage = 0;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAP_SECURITY_PACKAGE Package;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    NT_PRODUCT_TYPE ProductType ;


    //
    // Get our global state.
    //

    if (LsapIsEncryptionPermitted())
    {
        lsState.fState |= SPMSTATE_PRIVACY_OK;
    }


    if (!SpmpInitializePackageControl())
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    //
    // Build up the initialization message, to give the packages a better idea
    // of what is going on, and reduce their later calls for the same info.
    //

    Parameters.MachineState = ((lsState.fState & SPMSTATE_PRIVACY_OK) != 0) ? SECPKG_STATE_ENCRYPTION_PERMITTED : 0;

#ifndef LSASRV_EXPORT
    Parameters.MachineState |= SECPKG_STATE_STRONG_ENCRYPTION_PERMITTED;
#endif
    Parameters.SetupMode = SetupPhase;


    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo
                );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get primary domain info: 0x%x\n",scRet));
        return(scRet);
    }

    Parameters.DomainName = * (PUNICODE_STRING) &DnsDomainInfo->Name;
    Parameters.DnsDomainName = * (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName;
    Parameters.DomainSid = (PSID) DnsDomainInfo->Sid;
    Parameters.DomainGuid = (GUID) DnsDomainInfo->DomainGuid;


    if ( RtlGetNtProductType( &ProductType ) )
    {
        if ( ProductType == NtProductLanManNt )
        {
            Parameters.MachineState |= SECPKG_STATE_DOMAIN_CONTROLLER ;
        }
        else
        {
            if (Parameters.DomainSid != NULL)
            {
                Parameters.MachineState |= SECPKG_STATE_WORKSTATION;
            }
            else
            {
                Parameters.MachineState |= SECPKG_STATE_STANDALONE;
            }
        }
    }
    else
    {
        Parameters.MachineState |= SECPKG_STATE_STANDALONE;
    }

    LoadCount = 0;
    NewCount = 0;

    DebugLog((DEB_TRACE_INIT, "Init Parameters = %d, %s\n",
                Parameters.MachineState,
                (Parameters.SetupMode ? "Setup" : "Normal") ));

    //
    // Add the built in Negotiate package first.  It will hook all subsequent
    // package loads and unloads, so that it can keep a table running of all
    // the packages and their negotiate options.
    //

    if ( SpmpLoadBuiltin( 0, &NegTable, &Parameters ) )
    {
        LoadCount ++ ;
    }
    //
    // Set the preferred package to be the first non-negotiate package
    //

    PreferredPackage = LoadCount;


    //
    // Now load the new DLLs:
    //

    while (pszPackage = ppszPackages[iPackage])
    {
        if (SpmpLoadDll( pszPackage, &Parameters ))
        {
            LoadCount++;
            NewCount++;
        }

        iPackage++;

    }

    //
    // Now, load old style packages, or just the MSV package for now.
    //

    while (pszPackage = ppszOldPkgs[iOldPkg])
    {
        if (SpmpLoadAuthPkgDll( pszPackage ))
        {
            LoadCount++;
        }

        iOldPkg++;

    }


    //
    // Select the preferred package.
    //

    if ( pszPreferred == NULL )
    {
        Package = SpmpLocatePackage( PreferredPackage );
    }
    else
    {
        RtlInitUnicodeString( &sStr, pszPreferred );

        Package = SpmpLookupPackage( &sStr );
    }

    //
    // If there are no new packages, do not enabled a preferred
    // package.  It will mess up the negotiate package
    //

    if ( NewCount == 0 )
    {
        Package = NULL ;
    }

    if ( Package )
    {
        Package->fPackage |= SP_PREFERRED ;

        Event.PackageId = Package->dwPackageID;
        Event.PackageName = Package->Name;
        Event.ChangeType = SECPKG_PACKAGE_CHANGE_SELECT ;

        LsapEventNotify(
                    NOTIFY_CLASS_PACKAGE_CHANGE,
                    0,
                    sizeof( Event ),
                    &Event );


    }





    //
    // All the strings are actually offsets from the zeroth string
    //


    if (ppszPackages[0] != NULL)
    {
        LsapFreeLsaHeap(ppszPackages[0]);
    }


    //
    // Finally, free the array:
    //

    LsapFreeLsaHeap(ppszPackages);

    //
    // Get rid of the old package array, as well:
    //

    if (ppszOldPkgs[0] != NULL)
    {
        LsapFreeLsaHeap(ppszOldPkgs[0]);
    }

    LsapFreeLsaHeap(ppszOldPkgs);


#if DBG
    SpmpLoadBuiltinAuthPkg( &DbgTable );
#endif 

    //
    // Free the primary domain info
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        (PLSAPR_POLICY_INFORMATION) DnsDomainInfo
        );

    //
    // If at least the primary loaded, then return OK.  If not that,
    // then return an error:
    //

    if ( LoadCount )
    {
        return(S_OK);
    }
    else
    {
        return(SEC_E_CANNOT_INSTALL);
    }

}



//+-------------------------------------------------------------------------
//
//  Function:   InitThreadData
//
//  Synopsis:   Initializes Tls* data slots
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C"
void
InitThreadData(void)
{
    dwSession = TlsAlloc();
    dwLastError = TlsAlloc();
    dwExceptionInfo = TlsAlloc();
    dwCallInfo = TlsAlloc();
    dwThreadPackage = TlsAlloc();
    LsapDsThreadState = TlsAlloc();
    dwThreadHeap = TlsAlloc();

#ifdef DBG
    SafeLockInit();
#endif
}

#ifdef LSAP_VERIFY_PACKAGE_ID
BOOL RefSetCurrentPackageId(ULONG_PTR dwPackageId)
{
    ULONG_PTR dwCurId;
    char szTmp[32];
    WCHAR szw[64];
    
    dwCurId = (ULONG_PTR) TlsGetValue(dwThreadPackage);
    
    sprintf(szTmp, "%ld (%ld)", dwPackageId, dwCurId);

//     wsprintf(szw, L"*** %x ==> %d\n", GetCurrentThreadId(), dwPackageId);
//     OutputDebugString(szw);
    
    if (dwCurId == SPMGR_ID)
    {
        DsysAssertMsg(dwPackageId != SPMGR_ID, szTmp);
    }

    return TlsSetValue(dwThreadPackage, (PVOID)dwPackageId);
}
#endif // LSAP_VERIFY_PACKAGE_ID

//+-------------------------------------------------------------------------
//
//  Function:   InitSystemLogon
//
//  Synopsis:   Creates system logon credentials
//
//  Effects:    Creates credentials for NTLM and Kerberos for the Machine
//              in the system logon.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

extern "C"
void
InitSystemLogon(void)
{
    UNICODE_STRING ComputerPrincipalName;
    PLSAP_SECURITY_PACKAGE     pAuxPackage;
    PSession        pSession = GetCurrentSession();
    UNICODE_STRING  SecretName;
    ULONG_PTR       iPackage;
    NTSTATUS        scRet;
    SECPKG_PRIMARY_CRED PrimaryCred;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    PLSAPR_POLICY_INFORMATION DnsPolicyInfo = NULL;
    PLSAPR_CR_CIPHER_VALUE CrWkstaPassword = NULL;
    PLSAPR_CR_CIPHER_VALUE CrWkstaOldPassword = NULL;
    SID             SystemSid = {SID_REVISION, 1,
                                 SECURITY_NT_AUTHORITY,
                                 SECURITY_LOCAL_SYSTEM_RID};
    LSAPR_HANDLE SecretHandle = NULL;
    UNICODE_STRING DomainCopy ;
    UNICODE_STRING MachineCopy ;
    PSID SidCopy ;



    RtlZeroMemory(
        &PrimaryCred,
        sizeof(PrimaryCred)
        );


    ComputerPrincipalName.Buffer = NULL;

    //
    // Build the computer principal name, which is the computer name followed
    // by a '$'
    //

    ComputerPrincipalName.Length = MachineName.Length + sizeof(WCHAR);
    ComputerPrincipalName.MaximumLength = MachineName.Length + 2 * sizeof(WCHAR);

    ComputerPrincipalName.Buffer = (LPWSTR) LsapAllocateLsaHeap(ComputerPrincipalName.MaximumLength);
    if (ComputerPrincipalName.Buffer == NULL)
    {
        goto Cleanup;
    }

    RtlCopyMemory(
        ComputerPrincipalName.Buffer,
        MachineName.Buffer,
        MachineName.Length
        );
    ComputerPrincipalName.Buffer[MachineName.Length/sizeof(WCHAR)] =
        SSI_ACCOUNT_NAME_POSTFIX_CHAR;
    ComputerPrincipalName.Buffer[1+MachineName.Length/sizeof(WCHAR)] =
        L'\0';



    PrimaryCred.LogonId = SystemLogonId;
    PrimaryCred.UserSid = &SystemSid;
    PrimaryCred.DownlevelName.Buffer = wcsrchr(ComputerPrincipalName.Buffer,L'\\');
    if (PrimaryCred.DownlevelName.Buffer == NULL)
    {
        PrimaryCred.DownlevelName = ComputerPrincipalName;
    }
    else
    {
        PrimaryCred.DownlevelName.Buffer++;
        RtlInitUnicodeString(
            &PrimaryCred.DownlevelName,
            PrimaryCred.DownlevelName.Buffer
            );

    }


    //
    // Get the machine account password, if there is one
    //

    RtlInitUnicodeString(
        &SecretName,
        SSI_SECRET_NAME
        );

    scRet = LsarOpenSecret(
                LsapPolicyHandle,
                (PLSAPR_UNICODE_STRING) &SecretName,
                SECRET_ALL_ACCESS,
                &SecretHandle
                );
    if (NT_SUCCESS(scRet))
    {
        scRet = LsarQuerySecret(
                    SecretHandle,
                    &CrWkstaPassword,
                    NULL,               // we don't want current val set time
                    &CrWkstaOldPassword,
                    NULL                // ditto for old val
                    );
    }

    //
    // We don't want to fail to boot if we don't have a password, so continue
    // after an error
    //

    if (NT_SUCCESS(scRet) && (CrWkstaPassword != NULL))
    {
        PrimaryCred.Password.Buffer = (LPWSTR) CrWkstaPassword->Buffer;
        PrimaryCred.Password.Length = (USHORT) CrWkstaPassword->Length;
        PrimaryCred.Password.MaximumLength = (USHORT) CrWkstaPassword->MaximumLength;
        PrimaryCred.Flags = PRIMARY_CRED_CLEAR_PASSWORD;

        if (CrWkstaOldPassword != NULL)
        {
            PrimaryCred.OldPassword.Buffer = (LPWSTR) CrWkstaOldPassword->Buffer;
            PrimaryCred.OldPassword.Length = (USHORT) CrWkstaOldPassword->Length;
            PrimaryCred.OldPassword.MaximumLength = (USHORT) CrWkstaOldPassword->MaximumLength;
        }
    }


    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &DnsPolicyInfo
                );
    if(!NT_SUCCESS(scRet))
    {
        scRet = LsaIQueryInformationPolicyTrusted(
                    PolicyPrimaryDomainInformation,
                    &PolicyInfo
                    );
        if (NT_SUCCESS(scRet))
        {
            PrimaryCred.DomainName = *(PUNICODE_STRING) &PolicyInfo->PolicyPrimaryDomainInfo.Name;
        }
    } else {
        PrimaryCred.DomainName = *(PUNICODE_STRING) &DnsPolicyInfo->PolicyDnsDomainInfo.Name;
        PrimaryCred.DnsDomainName = *(PUNICODE_STRING) &DnsPolicyInfo->PolicyDnsDomainInfo.DnsDomainName;
    }

    //
    // Update the logon session with the "real" name:
    //

    scRet = LsapDuplicateString(
                    &DomainCopy,
                    &PrimaryCred.DomainName );

    if ( NT_SUCCESS( scRet ) )
    {
        scRet = LsapDuplicateString(
                    &MachineCopy,
                    &PrimaryCred.DownlevelName );

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = LsapDuplicateSid(
                        &SidCopy,
                        PrimaryCred.UserSid );

            if ( NT_SUCCESS( scRet ) )
            {
                LsapSetLogonSessionAccountInfo(
                        &SystemLogonId,
                        &MachineCopy,
                        &DomainCopy,
                        NULL,
                        &SidCopy,
                        (SECURITY_LOGON_TYPE) 0,
                        &PrimaryCred
                        );

                //
                // If successful, LsapSetLogonSessionAccountInfo will have taken
                // ownership of UserSid
                //

                if ( SidCopy != NULL ) {
                    LsapFreeLsaHeap( SidCopy );
                }
            }
        }
    }


    DebugLog((DEB_TRACE_INIT, "Establishing credentials for machine %ws\n", MachineName.Buffer));


    pAuxPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_ACCEPTCREDS );

    while (pAuxPackage)
    {
        iPackage = pAuxPackage->dwPackageID;

        DebugLog((DEB_TRACE_INIT, "Whacking package %ws with %x:%x = %ws\n",
            pAuxPackage->Name.Buffer,
            SystemLogonId.HighPart, SystemLogonId.LowPart,
            MachineName.Buffer));

        SetCurrentPackageId(iPackage);

        __try
        {

            scRet = pAuxPackage->FunctionTable.AcceptCredentials(
                        Interactive,
                        &ComputerPrincipalName,
                        &PrimaryCred,
                        NULL            // no supplemental credentials
                        );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            scRet = (NTSTATUS) GetExceptionCode();
            scRet = SPException(scRet, iPackage);
        }

        // Note:  if an exception occurs, we don't fail the logon, we just
        // do the magic on the package that blew.  If the package blows,
        // the other packages may succeed, and so the user may not be able
        // to use that provider.

        pAuxPackage = SpmpIteratePackagesByRequest( pAuxPackage,
                                                    SP_ORDINAL_ACCEPTCREDS );

    }



Cleanup:

    //
    // Finally, set this thread back to being a SPM thread:
    //

    SetCurrentPackageId( SPMGR_ID );

    if (CrWkstaPassword != NULL)
    {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(
            CrWkstaPassword
            );
    }
    if (CrWkstaOldPassword != NULL)
    {
        LsaIFree_LSAPR_CR_CIPHER_VALUE(
            CrWkstaOldPassword
            );
    }
    if (SecretHandle != NULL)
    {
        LsarClose(&SecretHandle);
    }

    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyPrimaryDomainInformation,
            PolicyInfo
            );
    }
    if (DnsPolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            DnsPolicyInfo
            );
    }
    if (ComputerPrincipalName.Buffer == NULL)
    {
        LsapFreeLsaHeap(ComputerPrincipalName.Buffer);
    }
}


HANDLE
SpmpOpenEvent( IN PWSTR EventName )
{
    NTSTATUS NtStatus;
    HANDLE InstallationEvent;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING UnicodeEventName;


    //
    // If the following event exists, it is an indication that
    // installation is in progress and that further security
    // initialization should be delayed until the event is
    // signalled.  This is expected to be a NOTIFICATION event.
    //

    RtlInitUnicodeString( &UnicodeEventName, EventName);
    InitializeObjectAttributes( &EventAttributes, &UnicodeEventName, 0, 0, NULL );

    NtStatus = NtOpenEvent(
                   &InstallationEvent,
                   SYNCHRONIZE,
                   &EventAttributes
                   );

    if (NT_SUCCESS(NtStatus))
    {
        return(InstallationEvent);
    }
    else
        return(NULL);

}

HANDLE
SpmpOpenSetupEvent( VOID )
{
    return( SpmpOpenEvent(L"\\INSTALLATION_SECURITY_HOLD"));
}

extern "C"
BOOLEAN
SpmpIsSetupPass( VOID )
{

    HANDLE  hEvent;

    if (hEvent = SpmpOpenSetupEvent())
    {
        NtClose(hEvent);
        return(TRUE);
    }
    return(FALSE);
}

extern "C"
BOOLEAN
SpmpIsMiniSetupPass( VOID )
{
    DWORD       rc;
    DWORD       d = 0;
    DWORD       Type;
    HKEY        hKey;

    //
    // See if this is a "mini" setup, in which case we
    // don't need to generate the domain SID.
    //
    rc = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                       L"System\\Setup",
                       0,
                       KEY_READ,
                       &hKey );
    if( rc == ERROR_SUCCESS ) {

        //
        // Just get the size (ALPHA workaround).  All
        // we care about is if the key exists...
        //
        rc = RegQueryValueExW( hKey,
                              L"MiniSetupInProgress",
                              NULL,
                              &Type,
                              (LPBYTE)NULL,
                              &d );

        RegCloseKey( hKey );

        if( rc == ERROR_SUCCESS ) {
            return( TRUE );
        }
    }
    return( FALSE );
}


NTSTATUS
LsapInstallationPause( VOID )


/*++

Routine Description:

    This function checks to see if the system is in an
    installation state.  If so, it suspends further initialization
    until the installation state is complete.

    Installation state is signified by the existance of a well known
    event.


Arguments:

    None.

Return Value:


        STATUS_SUCCESS - Proceed with initialization.

        Other status values are unexpected.

--*/

{
    HANDLE      InstallationEvent;
    NTSTATUS    NtStatus;
    NTSTATUS    TmpStatus;

    InstallationEvent = SpmpOpenSetupEvent();

    if ( InstallationEvent ) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        // Installation code is responsible for deleting the event after
        // signalling it.
        //

        NtStatus = NtWaitForSingleObject( InstallationEvent, TRUE, 0 );
        TmpStatus = NtClose( InstallationEvent );
        ASSERT(NT_SUCCESS(TmpStatus));

        //
        // Now, strobe the state changed event, to indicate to the
        // rest of the threads that life has changed
        //

        SpmSetEvent(hStateChangeEvent);

    } else {
        NtStatus = STATUS_SUCCESS; // Indicate everything is as expected
    }

    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spnego.c ===
#include <windows.h>
#include "spnego.h"

ASN1module_t SPNEGO_Module = NULL;

static int ASN1CALL ASN1Enc_SavedMechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, SavedMechTypeList *val);
static int ASN1CALL ASN1Enc_MechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList *val);
static int ASN1CALL ASN1Enc_NegHints(ASN1encoding_t enc, ASN1uint32_t tag, NegHints *val);
static int ASN1CALL ASN1Enc_NegTokenInit(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit *val);
static int ASN1CALL ASN1Enc_NegTokenInit2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit2 *val);
static int ASN1CALL ASN1Enc_NegTokenTarg(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenTarg *val);
static int ASN1CALL ASN1Enc_NegotiationToken(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken *val);
static int ASN1CALL ASN1Enc_InitialNegToken(ASN1encoding_t enc, ASN1uint32_t tag, InitialNegToken *val);
static int ASN1CALL ASN1Dec_SavedMechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, SavedMechTypeList *val);
static int ASN1CALL ASN1Dec_MechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList *val);
static int ASN1CALL ASN1Dec_NegHints(ASN1decoding_t dec, ASN1uint32_t tag, NegHints *val);
static int ASN1CALL ASN1Dec_NegTokenInit(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit *val);
static int ASN1CALL ASN1Dec_NegTokenInit2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit2 *val);
static int ASN1CALL ASN1Dec_NegTokenTarg(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenTarg *val);
static int ASN1CALL ASN1Dec_NegotiationToken(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken *val);
static int ASN1CALL ASN1Dec_InitialNegToken(ASN1decoding_t dec, ASN1uint32_t tag, InitialNegToken *val);
static void ASN1CALL ASN1Free_SavedMechTypeList(SavedMechTypeList *val);
static void ASN1CALL ASN1Free_MechTypeList(PMechTypeList *val);
static void ASN1CALL ASN1Free_NegHints(NegHints *val);
static void ASN1CALL ASN1Free_NegTokenInit(NegTokenInit *val);
static void ASN1CALL ASN1Free_NegTokenInit2(NegTokenInit2 *val);
static void ASN1CALL ASN1Free_NegTokenTarg(NegTokenTarg *val);
static void ASN1CALL ASN1Free_NegotiationToken(NegotiationToken *val);
static void ASN1CALL ASN1Free_InitialNegToken(InitialNegToken *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[3] = {
    (ASN1EncFun_t) ASN1Enc_SavedMechTypeList,
    (ASN1EncFun_t) ASN1Enc_NegotiationToken,
    (ASN1EncFun_t) ASN1Enc_InitialNegToken,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[3] = {
    (ASN1DecFun_t) ASN1Dec_SavedMechTypeList,
    (ASN1DecFun_t) ASN1Dec_NegotiationToken,
    (ASN1DecFun_t) ASN1Dec_InitialNegToken,
};
static const ASN1FreeFun_t freefntab[3] = {
    (ASN1FreeFun_t) ASN1Free_SavedMechTypeList,
    (ASN1FreeFun_t) ASN1Free_NegotiationToken,
    (ASN1FreeFun_t) ASN1Free_InitialNegToken,
};
static const ULONG sizetab[3] = {
    SIZE_SPNEGO_Module_PDU_0,
    SIZE_SPNEGO_Module_PDU_1,
    SIZE_SPNEGO_Module_PDU_2,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL SPNEGO_Module_Startup(void)
{
    SPNEGO_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NONE, 3, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x656e7073);
}

void ASN1CALL SPNEGO_Module_Cleanup(void)
{
    ASN1_CloseModule(SPNEGO_Module);
    SPNEGO_Module = NULL;
}

static int ASN1CALL ASN1Enc_SavedMechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, SavedMechTypeList *val)
{
    if (!ASN1Enc_MechTypeList(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SavedMechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, SavedMechTypeList *val)
{
    if (!ASN1Dec_MechTypeList(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SavedMechTypeList(SavedMechTypeList *val)
{
    if (val) {
	ASN1Free_MechTypeList(val);
    }
}

static int ASN1CALL ASN1Enc_MechTypeList(ASN1encoding_t enc, ASN1uint32_t tag, PMechTypeList *val)
{
    PMechTypeList f;
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (f = *val; f; f = f->next) {
	if (!ASN1BEREncObjectIdentifier(enc, 0x6, &f->value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MechTypeList(ASN1decoding_t dec, ASN1uint32_t tag, PMechTypeList *val)
{
    PMechTypeList *f;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    f = val;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if (!(*f = (PMechTypeList)ASN1DecAlloc(dd, sizeof(**f))))
	    return 0;
	if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(*f)->value))
	    return 0;
	f = &(*f)->next;
    }
    *f = NULL;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MechTypeList(PMechTypeList *val)
{
    PMechTypeList f, ff;
    if (val) {
	for (f = *val; f; f = ff) {
	    ASN1objectidentifier_free(&f->value);
	    ff = f->next;
	    ASN1Free(f);
	}
    }
}

static int ASN1CALL ASN1Enc_NegHints(ASN1encoding_t enc, ASN1uint32_t tag, NegHints *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t t;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	t = lstrlenA((val)->hintName);
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1DEREncCharString(enc, 0x1b, t, (val)->hintName))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->hintAddress).length, ((val)->hintAddress).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegHints(ASN1decoding_t dec, ASN1uint32_t tag, NegHints *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecZeroCharString(dd0, 0x1b, &(val)->hintName))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->hintAddress))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegHints(NegHints *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1ztcharstring_free((val)->hintName);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1octetstring_free(&(val)->hintAddress);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenInit(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t r;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_MechTypeList(enc, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	r = ((val)->reqFlags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->reqFlags).value);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->reqFlags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechToken).length, ((val)->mechToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegHints(enc, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenInit(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_MechTypeList(dd0, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->reqFlags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegHints(dd0, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenInit(NegTokenInit *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MechTypeList(&(val)->mechTypes);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1bitstring_free(&(val)->reqFlags);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->mechToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_NegHints(&(val)->negHints);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenInit2(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenInit2 *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    ASN1uint32_t r;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_MechTypeList(enc, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	r = ((val)->reqFlags).length;
	ASN1BEREncRemoveZeroBits(&r, ((val)->reqFlags).value);
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncBitString(enc, 0x3, r, ((val)->reqFlags).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechToken).length, ((val)->mechToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000004, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegHints(enc, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenInit2(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenInit2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_MechTypeList(dd0, 0, &(val)->mechTypes))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecBitString(dd0, 0x3, &(val)->reqFlags))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000004) {
	(val)->o[0] |= 0x8;
	if (!ASN1BERDecExplicitTag(dd, 0x80000004, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegHints(dd0, 0, &(val)->negHints))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenInit2(NegTokenInit2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MechTypeList(&(val)->mechTypes);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1bitstring_free(&(val)->reqFlags);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->mechToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_NegHints(&(val)->negHints);
	}
    }
}

static int ASN1CALL ASN1Enc_NegTokenTarg(ASN1encoding_t enc, ASN1uint32_t tag, NegTokenTarg *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncU32(enc, 0xa, (val)->negResult))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->supportedMech))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->responseToken).length, ((val)->responseToken).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->mechListMIC).length, ((val)->mechListMIC).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_NegTokenTarg(ASN1decoding_t dec, ASN1uint32_t tag, NegTokenTarg *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecU32Val(dd0, 0xa, (ASN1uint32_t *) &(val)->negResult))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecObjectIdentifier(dd0, 0x6, &(val)->supportedMech))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000002) {
	(val)->o[0] |= 0x20;
	if (!ASN1BERDecExplicitTag(dd, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->responseToken))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000003) {
	(val)->o[0] |= 0x10;
	if (!ASN1BERDecExplicitTag(dd, 0x80000003, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->mechListMIC))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_NegTokenTarg(NegTokenTarg *val)
{
    if (val) {
	if ((val)->o[0] & 0x40) {
	    ASN1objectidentifier_free(&(val)->supportedMech);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1octetstring_free(&(val)->responseToken);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1octetstring_free(&(val)->mechListMIC);
	}
    }
}

static int ASN1CALL ASN1Enc_NegotiationToken(ASN1encoding_t enc, ASN1uint32_t tag, NegotiationToken *val)
{
    ASN1uint32_t nLenOff0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenInit(enc, 0, &(val)->u.negTokenInit))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 2:
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenTarg(enc, 0, &(val)->u.negTokenTarg))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    case 3:
	if (!ASN1BEREncExplicitTag(enc, 0x80000002, &nLenOff0))
	    return 0;
	if (!ASN1Enc_NegTokenInit2(enc, 0, &(val)->u.negTokenInit2))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NegotiationToken(ASN1decoding_t dec, ASN1uint32_t tag, NegotiationToken *val)
{
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x80000000:
	(val)->choice = 1;
	if (!ASN1BERDecExplicitTag(dec, 0x80000000, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenInit(dd0, 0, &(val)->u.negTokenInit))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1BERDecExplicitTag(dec, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenTarg(dd0, 0, &(val)->u.negTokenTarg))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1BERDecExplicitTag(dec, 0x80000002, &dd0, &di0))
	    return 0;
	if (!ASN1Dec_NegTokenInit2(dd0, 0, &(val)->u.negTokenInit2))
	    return 0;
	if (!ASN1BERDecEndOfContents(dec, dd0, di0))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NegotiationToken(NegotiationToken *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_NegTokenInit(&(val)->u.negTokenInit);
	    break;
	case 2:
	    ASN1Free_NegTokenTarg(&(val)->u.negTokenTarg);
	    break;
	case 3:
	    ASN1Free_NegTokenInit2(&(val)->u.negTokenInit2);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_InitialNegToken(ASN1encoding_t enc, ASN1uint32_t tag, InitialNegToken *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x40000000, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier(enc, 0x6, &(val)->spnegoMech))
	return 0;
    if (!ASN1Enc_NegotiationToken(enc, 0, &(val)->negToken))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_InitialNegToken(ASN1decoding_t dec, ASN1uint32_t tag, InitialNegToken *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x40000000, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier(dd, 0x6, &(val)->spnegoMech))
	return 0;
    if (!ASN1Dec_NegotiationToken(dd, 0, &(val)->negToken))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_InitialNegToken(InitialNegToken *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->spnegoMech);
	ASN1Free_NegotiationToken(&(val)->negToken);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        SPMGR.H
//
// Contents:    Common structures and functions for the SPMgr
//
//
// History:     20 May 92   RichardW    Documented existing stuff
//              22 Jul 93   RichardW    Revised to be the one include file
//                                      for the spm directory
//
//------------------------------------------------------------------------

#ifndef __SPMGR_H__
#define __SPMGR_H__
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <spmlpc.h>
#include <lsaperf.h>
#include <lsapmsgs.h>   // event log events

// SPM-wide structure definitions:

// This is the function table for a security package.  All functions are
// dispatched through this table.


struct _DLL_BINDING;


// This is the Security Package Control structure.  All control information
// relating to packages is stored here.


typedef struct _LSAP_SECURITY_PACKAGE {
    ULONG_PTR       dwPackageID;        // Assigned package ID
    DWORD           PackageIndex;       // Package Index in DLL
    DWORD           fPackage;           // Flags about the package
    DWORD           fCapabilities;      // Capabilities that the package reported
    DWORD           dwRPCID;            // RPC ID
    DWORD           Version;
    DWORD           TokenSize;
    DWORD           ContextHandles ;    // Number of outstanding contexts
    DWORD           CredentialHandles ; //  ditto for credentials
    LONG            CallsInProgress ;   // Number of calls to this package
    SECURITY_STRING Name;               // Name of the package
    SECURITY_STRING Comment;
    struct _DLL_BINDING *   pBinding;   // Binding of DLL
    PSECPKG_EXTENDED_INFORMATION Thunks ;   // Thunked Context levels
    LIST_ENTRY      ScavengerList ;
    SECURITY_STRING WowClientDll ;
    SECPKG_FUNCTION_TABLE FunctionTable;    // Dispatch table

#ifdef TRACK_MEM
    PVOID           pvMemStats;         // Memory statistics
#endif

} LSAP_SECURITY_PACKAGE, * PLSAP_SECURITY_PACKAGE;

#define SP_INVALID          0x00000001  // Package is now invalid for use
#define SP_UNLOAD           0x00000002  // Package is being unloaded
#define SP_INTERNAL         0x00000008  // Package is internal, do not unload
#define SP_PREFERRED        0x00000020  // The preferred package
#define SP_DELETE_PEND      0x00000040  // Package Delete pending
#define SP_INFO             0x00000080  // Supports Extended Info
#define SP_CONTEXT_INFO     0x00000100  // Wants some info levels thunked
#define SP_SHUTDOWN_PENDING 0x00000200  // Shutdown has been called
#define SP_SHUTDOWN         0x00000400  // Shutdown has completed
#define SP_WOW_SUPPORT      0x00000800  // Package can support WOW6432 clients


#define StartCallToPackage( p ) \
    InterlockedIncrement( &((PLSAP_SECURITY_PACKAGE) p)->CallsInProgress )

#define EndCallToPackage( p ) \
    InterlockedDecrement( &((PLSAP_SECURITY_PACKAGE) p)->CallsInProgress )

typedef struct _DLL_BINDING {
    DWORD           Flags;              // Flags about the DLL
    HANDLE          hInstance;          // Instance Handle
    SECURITY_STRING Filename;           // Full path name
    DWORD           RefCount;           // Reference Count
    DWORD           PackageCount;       // Number of Packages in DLL

    LSAP_SECURITY_PACKAGE      Packages[1];
} DLL_BINDING, * PDLL_BINDING;

#define DLL_DEFAULT_MEM 0x00000001      // pPackages is self allocated
#define DLL_BUILTIN     0x00000002      // DLL is really built-in code
#define DLL_AUTHPKG     0x00000004      // DLL is an old auth package
#define DLL_SIGNED      0x00000008      // DLL is signed

//
// Ordinals to the function pointers, for validating calls
//

#define SP_ORDINAL_LSA_INIT                     0
#define SP_ORDINAL_LOGONUSER                    1
#define SP_ORDINAL_CALLPACKAGE                  2
#define SP_ORDINAL_LOGONTERMINATED              3
#define SP_ORDINAL_CALLPACKAGEUNTRUSTED         4
#define SP_ORDINAL_CALLPACKAGEPASSTHROUGH       5
#define SP_ORDINAL_LOGONUSEREX                  6
#define SP_ORDINAL_LOGONUSEREX2                 7
#define SP_ORDINAL_INITIALIZE                   8
#define SP_ORDINAL_SHUTDOWN                     9
#define SP_ORDINAL_GETINFO                      10
#define SP_ORDINAL_ACCEPTCREDS                  11
#define SP_ORDINAL_ACQUIRECREDHANDLE            12
#define SP_ORDINAL_QUERYCREDATTR                13
#define SP_ORDINAL_FREECREDHANDLE               14
#define SP_ORDINAL_SAVECRED                     15
#define SP_ORDINAL_GETCRED                      16
#define SP_ORDINAL_DELETECRED                   17
#define SP_ORDINAL_INITLSAMODECTXT              18
#define SP_ORDINAL_ACCEPTLSAMODECTXT            19
#define SP_ORDINAL_DELETECTXT                   20
#define SP_ORDINAL_APPLYCONTROLTOKEN            21
#define SP_ORDINAL_GETUSERINFO                  22
#define SP_ORDINAL_GETEXTENDEDINFORMATION       23
#define SP_ORDINAL_QUERYCONTEXTATTRIBUTES       24
#define SP_ORDINAL_ADDCREDENTIALS               25
#define SP_ORDINAL_SETEXTENDEDINFORMATION       26
#define SP_ORDINAL_SETCONTEXTATTRIBUTES         27


#define SP_MAX_TABLE_ORDINAL            (SP_ORDINAL_SETCONTEXTATTRIBUTES + 1)
#define SP_MAX_AUTHPKG_ORDINAL          (SP_ORDINAL_LOGONUSEREX)

#define SP_ORDINAL_MASK                 0x0000FFFF
#define SP_ITERATE_FILTER_WOW           0x00010000

#define SP_ORDINAL_INSTANCEINIT         32

typedef struct _LsaState {
    DWORD   fState ;
    DWORD   cPackages ;
    DWORD   cNewPackages ;
} LsaState ;

typedef enum _SECHANDLE_OPS {
    HandleSet,                          // Just set the new handle
    HandleReplace,                      // Replace the existing one
    HandleRemoveReplace                 // Remove provided, replace with provided
} SECHANDLE_OPS ;

typedef struct _LSA_TUNING_PARAMETERS {
    ULONG   ThreadLifespan ;                // lifespan for threads in gen. pool
    ULONG   SubQueueLifespan ;              // lifespan for dedicated threads
    ULONG   Options ;                       // Option flags
    BOOL    ShrinkOn ;                      // Thread pool is idle
    ULONG   ShrinkCount ;
    ULONG   ShrinkSkip ;
} LSA_TUNING_PARAMETERS, * PLSA_TUNING_PARAMETERS ;

#define TUNE_SRV_HIGH_PRIORITY  0x00000001
#define TUNE_TRIM_WORKING_SET   0x00000002
#define TUNE_ALLOW_PERFMON      0x00000004
#define TUNE_RM_THREAD          0x00000008
#define TUNE_PRIVATE_HEAP       0x00000010



//
// Redefine IsOkayToExec
//

#define IsOkayToExec(x)


#ifdef TRACK_MEM
#define TRACK_MEM_LEAK

#define MEMHOOK_PACKAGE_LOAD    1
void    MemTrackHook(DWORD  Type, DWORD Package);
#else
#define MemTrackHook(x,y)
#endif

// For some tracking purposes, the package ID for the SPMgr is a well known
// constant:

#define SPMGR_ID        ((LSA_SEC_HANDLE) INVALID_HANDLE_VALUE)
#define SPMGR_PKG_ID    ((LSA_SEC_HANDLE) INVALID_HANDLE_VALUE)

//
// Value to pass to shutdown handler
//

#define SPM_SHUTDOWN_VALUE  0xD0

//
// Creating process name for LSA sessions
//

#define LSA_PROCESS_NAME L"LSA Server"
//
// ID of the primary package
//

#define PRIMARY_ID      0

typedef struct _SpmExceptDbg {
    DWORD       ThreadId;
    PVOID       pInstruction;
    PVOID       pMemory;
    ULONG_PTR   Access;
} SpmExceptDbg, * PSpmExceptDbg;



// Internal Exception Handling:
//
// If we hit an exception in a debug build, we store away some useful stuff
// otherwise, we go to the default case:



LONG    SpExceptionFilter(PVOID, EXCEPTION_POINTERS *);

#define SP_EXCEPTION    SpExceptionFilter(GetCurrentSession(), GetExceptionInformation())


//
// Include other component header files
//

#ifdef __cplusplus
extern "C" {
#endif

#include "sesmgr.h"     // Session manager support
#include "sphelp.h"     // Internal helper functions
#include "protos.h"     // Internal Prototypes
#include "debug.h"      // Debugging Support:

#ifdef __cplusplus
}
#endif

typedef struct _LSAP_DBG_LOG_CONTEXT {
    PSession    Session ;               // Session used
    SecHandle   Handle ;                // Handle used
} LSAP_DBG_LOG_CONTEXT, *PLSAP_DBG_LOG_CONTEXT ;


typedef struct _LSAP_API_LOG_ENTRY {
    ULONG           MessageId ;         // LPC Message ID
    ULONG           ThreadId ;          // Thread ID handling call
    PVOID           pvMessage ;         // LPC Message
    PVOID           WorkItem ;          // Work item for API
    LARGE_INTEGER   QueueTime ;         // Time Queued
    LARGE_INTEGER   WorkTime ;          // Work Time
    PVOID           Reserved ;          // Alignment
    LSAP_DBG_LOG_CONTEXT Context ;      // Context
} LSAP_API_LOG_ENTRY, * PLSAP_API_LOG_ENTRY ;

typedef struct _LSAP_API_LOG {
    ULONG               TotalSize ;
    ULONG               Current ;
    ULONG               ModSize ;
    ULONG               Align ;
    LSAP_API_LOG_ENTRY  Entries[ 1 ];
} LSAP_API_LOG, * PLSAP_API_LOG ;


PLSAP_API_LOG
ApiLogCreate(
    ULONG Entries
    );

PLSAP_API_LOG_ENTRY
ApiLogAlloc(
    PLSAP_API_LOG Log
    );

PLSAP_API_LOG_ENTRY
ApiLogLocate(
    PLSAP_API_LOG Log,
    ULONG MessageId
    );

#define DEFAULT_LOG_SIZE    32

//#if DBG
#define DBG_TRACK_API 1
//#endif

#if DBG_TRACK_API

#define DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo ) \
    if ( Entry )                                                                \
    {                                                                           \
        Entry->ThreadId = GetCurrentThreadId() ;                                \
        CallInfo.LogContext = & Entry->Context ;                                \
        GetSystemTimeAsFileTime( (LPFILETIME) &Entry->WorkTime ) ;              \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        CallInfo.LogContext = NULL ;                                            \
    }



#define DBG_DISPATCH_PROLOGUE( Table, pMessage, CallInfo ) \
    PLSAP_API_LOG_ENTRY Entry ;                                                 \
                                                                                \
    Entry = ApiLogLocate( Table, ((PPORT_MESSAGE) pMessage)->MessageId );       \
    DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo )                                                                            \


#define DBG_DISPATCH_POSTLOGUE( Status, ApiCode ) \
    if ( Entry )                                                                \
    {                                                                           \
        LARGE_INTEGER EndTime ;                                                 \
        GetSystemTimeAsFileTime( (LPFILETIME) & EndTime );                      \
        Entry->Reserved = ULongToPtr(Entry->ThreadId);                          \
        Entry->ThreadId = (DWORD) 0xFFFFFFFF ;                                  \
        Entry->WorkItem = (PVOID) Status ;                                      \
        Entry->pvMessage = (PVOID) ApiCode ;                                    \
        Entry->QueueTime.QuadPart = EndTime.QuadPart ;                          \
        Entry->WorkTime.QuadPart = EndTime.QuadPart - Entry->WorkTime.QuadPart ; \
    }



#else
#define DBG_DISPATCH_PROLOGUE_EX( Entry, pMessage, CallInfo ) CallInfo.LogContext = NULL
#define DBG_DISPATCH_PROLOGUE( Table, pApi, CallInfo ) CallInfo.LogContext = NULL
#define DBG_DISPATCH_POSTLOGUE( Status, ApiCode )
#endif






#define MAX_BUFFERS_IN_CALL 8

typedef struct _LSA_CALL_INFO {
    PSPM_LPC_MESSAGE        Message ;
    struct _LSA_CALL_INFO * PreviousCall ;
    PSession Session ;
    PLSAP_DBG_LOG_CONTEXT LogContext ;
    SECPKG_CALL_INFO    CallInfo ;

    //
    // LogonId, ImpersonationLevel, Impersonating, Restricted
    // are considered valid CachedTokenInfo is TRUE
    //

    LUID                            LogonId ;
    SECURITY_IMPERSONATION_LEVEL    ImpersonationLevel;
    BOOLEAN                         Impersonating;
    BOOLEAN                         Restricted;
    BOOLEAN                         CachedTokenInfo;

    HANDLE InProcToken ;
    BOOL InProcCall ;
    ULONG Flags ;
    ULONG Allocs ;
    PKSEC_LSA_MEMORY_HEADER KMap ;
    PVOID Buffers[ MAX_BUFFERS_IN_CALL ];
} LSA_CALL_INFO, * PLSA_CALL_INFO ;

#define LsapGetCurrentCall()    ((PLSA_CALL_INFO) TlsGetValue( dwCallInfo ))
#define LsapSetCurrentCall(x)   TlsSetValue( dwCallInfo, x )

#define CALL_FLAG_IMPERSONATING 0x00000001
#define CALL_FLAG_IN_PROC_CALL  0x00000002
#define CALL_FLAG_SUPRESS_AUDIT 0x00000004
#define CALL_FLAG_NO_HANDLE_CHK 0x00000008
#define CALL_FLAG_KERNEL_POOL   0x00000010  // Kernel mode call, using pool
#define CALL_FLAG_KMAP_USED     0x00000020  // KMap is valid


//
//BOOL
//LsapIsBlockInKMap( KMap, Block )
//
#define LsapIsBlockInKMap( KMap, Block ) \
    ( KMap ? (((ULONG_PTR) KMap ^ (ULONG_PTR) Block ) < (ULONG_PTR) KMap->Commit) : FALSE )

NTSTATUS
InitializeDirectDispatcher(
    VOID
    );

VOID
LsapInitializeCallInfo(
    PLSA_CALL_INFO CallInfo,
    BOOL InProcess
    );


NTSTATUS
LsapBuildCallInfo(
    PSPM_LPC_MESSAGE    pApiMessage,
    PLSA_CALL_INFO CallInfo,
    PHANDLE Impersonated,
    PSession * NewSession,
    PSession * OldSession
    );


VOID
LsapInternalBreak(
    VOID
    );

#define LsapLogCallInfo( CallInfo, pSession, cHandle ) \
    if ( CallInfo &&  ( CallInfo->LogContext ) )                 \
    {                                                            \
        CallInfo->LogContext->Session = pSession ;                \
        CallInfo->LogContext->Handle = cHandle;                   \
    }                                                            \

//
// Global variables
//

extern  HANDLE          hLsaInst;              // Instance handle of app

extern  LSA_SECPKG_FUNCTION_TABLE  LsapSecpkgFunctionTable;
                                            // Dispatch table of helper functions

extern  LUID            SystemLogonId;      // System LogonID for packages.
extern  SECURITY_STRING MachineName;        // Computer name
extern  HANDLE          hStateChangeEvent;  // Event set when the system state is changed
extern  HANDLE          hShutdownEvent;
extern  HANDLE          hPrelimShutdownEvent; // Event to tell Domain cache
                                            // manager that system is shutting
                                            // down
extern  HANDLE          hRMStartupEvent;
extern  HANDLE          hKSEvent;
extern LSA_CALL_INFO    LsapDefaultCallInfo ;

extern  ULONG           LsapPageSize ;      // Set to the page size during init
extern  ULONG_PTR       LsapUserModeLimit ; // Set the to max user mode address


// Thread Local Storage variables
//
// These are actually all indices into the tls area, accessed through the
// TlsXxx functions.  These are all initialized by the InitThreadData()
// function

extern  DWORD           dwThreadContext;    // CallerContext pointer
extern  DWORD           dwSession;          // Session pointer
extern  DWORD           dwLastError;        // Last error value
extern  DWORD           dwExceptionInfo;    // Gets a pointer to exception info
extern  DWORD           dwThreadPackage;    // Package ID for thread
extern  DWORD           dwCallInfo ;        // CallInfo pointer
extern  DWORD           dwThreadHeap;       // Heap assigned to current thread.

// Last known workstation status:

extern  int             LastWkstaStatus;
extern  PSession        pSpmgrSession;      // SPMgr's session
extern  BOOLEAN         DomainDsExists;     // Has state been set to DS_DC?

extern  WCHAR           szDsRegPath[];
extern  BOOLEAN         SetupPhase;         // If true, setup is running
extern  BOOL            fShrinkMemory;
extern  BOOL            ShutdownBegun ;     // when true, shutdown is running

extern  LSA_TUNING_PARAMETERS   LsaTuningParameters ;
extern  LsaState    lsState ;

extern PWSTR * ppszPackages;       // Contains a null terminated array of dll names
extern PWSTR * ppszOldPkgs;        // Contains a null terminated array of old pkgs


#endif // __SPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\sputil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        sputil.c
//
// Contents:    Security package utility functions.  Functions for maintaining
//              the list of available packages are kept here.
//
//
//
// History:      9 Dec 91,  richardw    Created
//              11 Mar 92,  RichardW    Recreated, reworked, etc.
//              21 Mar 94,  MikeSw      Removed RPC stubs
//
//------------------------------------------------------------------------

#include <lsapch.hxx>

extern "C"
{
#include "sesmgr.h"
#include <stddef.h>
}

//
// Global variables and structures:
//


//
// Debug stuff:
//
#if DBG
ULONG       NoUnload = 0;
#endif


extern WCHAR szLsaPath[] ;

RTL_RESOURCE    PackageListLock;

PDLL_BINDING *  pPackageDllList;
ULONG           PackageDllCount;
ULONG           PackageDllTotal;
PLSAP_SECURITY_PACKAGE *   pPackageControlList;
ULONG           PackageControlCount;
ULONG           PackageControlTotal;

#define INITIAL_PACKAGE_DLL_SIZE        8
#define INITIAL_PACKAGE_CONTROL_SIZE    8

#define ReadLockPackageList()   RtlAcquireResourceShared(&PackageListLock, TRUE)
#define WriteLockPackageList()  RtlAcquireResourceExclusive(&PackageListLock, TRUE)
#define UnlockPackageList()     RtlReleaseResource(&PackageListLock)

PDLL_BINDING
SpmpFindDll(
    PWSTR   DllName);



//+---------------------------------------------------------------------------
//
//  Function:   BindOldPackage
//
//  Synopsis:   Loads an old style authentication package DLL
//
//  Arguments:  [hDll]   --
//              [pTable] --
//
//  History:    11-17-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
BindOldPackage( HANDLE          hDll,
                PSECPKG_FUNCTION_TABLE  pTable)
{

    pTable->InitializePackage = (PLSA_AP_INITIALIZE_PACKAGE)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_INITIALIZE_PACKAGE);

    if (pTable->InitializePackage == NULL)
    {
        return(FALSE);
    }

    //
    // The package needs to support one of LogonUser, LogonUserEx, or LogonUserEx2
    pTable->LogonUserEx2 = (PLSA_AP_LOGON_USER_EX2)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER_EX2);

    //
    // If this is NULL, then the package should have exported a LsaApLogonUser or Ex
    //

    if (pTable->LogonUserEx2 == NULL)
    {
        pTable->LogonUserEx = (PLSA_AP_LOGON_USER_EX)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER_EX);
        if (pTable->LogonUserEx == NULL)
        {
            pTable->LogonUser = (PLSA_AP_LOGON_USER)
                            GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_USER);
            if (pTable->LogonUser == NULL)
            {
                return(FALSE);
            }
        }
        }

    pTable->CallPackage = (PLSA_AP_CALL_PACKAGE)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE);
    if (pTable->CallPackage == NULL)
    {
        return(FALSE);
    }

    //
    // CallPackageUntrusted is optional
    //

    pTable->CallPackageUntrusted = (PLSA_AP_CALL_PACKAGE_UNTRUSTED)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE_UNTRUSTED);

    pTable->CallPackagePassthrough = (PLSA_AP_CALL_PACKAGE_PASSTHROUGH)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_CALL_PACKAGE_PASSTHROUGH);

    pTable->LogonTerminated = (PLSA_AP_LOGON_TERMINATED)
                        GetProcAddress((HMODULE)hDll, LSA_AP_NAME_LOGON_TERMINATED);
    if (pTable->LogonTerminated == NULL)
    {
        return(FALSE);
    }

    //
    // If the package supports accept credentials, great. Otherwise
    // just leave this blank.
    //

    pTable->AcceptCredentials = (SpAcceptCredentialsFn *)
                        GetProcAddress((HMODULE) hDll,  SP_ACCEPT_CREDENTIALS_NAME);

    return(TRUE);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaEnumeratePackages()
//
//  Synopsis:   Worker function for LsaEnumeratePackages
//
//  Effects:    Fills in an array of SecPkgInfo structures
//
//  Arguments:  pcEntries - receives the number of packages
//
//              pPackages - receives all the SecPkgInfo structures
//
//  Requires:
//
//  Returns:    success
//
//  Notes:
//
//--------------------------------------------------------------------------

static LPWSTR szInvalidPackage = L"Invalid Package";

NTSTATUS
WLsaEnumeratePackages(  PULONG              pcEntries,
                        PSecPkgInfo *       pPackages)
{
    unsigned int    i;
    PSession        pSession = GetCurrentSession();
    ULONG           cbSize;
    PSecPkgInfo     pInfo;
    PSecPkgInfo     pLocalInfo = NULL, pClientInfo = NULL;
    LONG            cbMark, cbLength;
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PLSA_CALL_INFO CallInfo ;
    ULONG Filter ;

    Filter = SP_ORDINAL_GETINFO ;

    CallInfo = LsapGetCurrentCall();

    if ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Filter |= SP_ITERATE_FILTER_WOW ;
    }

    cbSize = sizeof(SecPkgInfo) * lsState.cPackages;
    pInfo = (PSecPkgInfo) LsapAllocateLsaHeap(cbSize);

    if (!pInfo)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    pPackage = SpmpIteratePackagesByRequest( NULL, Filter );

    i = 0;

    while (pPackage)
    {
        SetCurrentPackageId( pPackage->dwPackageID );

        __try
        {
            (VOID) pPackage->FunctionTable.GetInfo( &pInfo[i] );
            cbSize += (wcslen(pInfo[i].Name) + 1) * sizeof(WCHAR);
            cbSize += (wcslen(pInfo[i].Comment) + 1) * sizeof(WCHAR);
        }
        __except (SP_EXCEPTION)
        {
            SPException( GetExceptionCode(), pPackage->dwPackageID );

            //
            // Catch it, kill the package, proceed...
            //
        }

        pPackage = SpmpIteratePackagesByRequest( pPackage,
                                                 Filter );
        i ++;

    }

    *pcEntries = i;

    pLocalInfo = (PSecPkgInfo) LsapAllocateLsaHeap(cbSize);
    if (!pLocalInfo)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }
    pClientInfo = (PSecPkgInfo) LsapClientAllocate(cbSize);
    if (!pClientInfo)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    //
    // Compute the offset to adjust the pointers by
    //

    cbMark = *pcEntries * sizeof(SecPkgInfo);

    RtlCopyMemory(pLocalInfo,pInfo,cbMark);

    for (i = 0; i < *pcEntries ; i++ )
    {

        cbLength = (wcslen(pInfo[i].Name)+1)*sizeof(WCHAR);
        RtlCopyMemory(
            (PBYTE) pLocalInfo + cbMark,
            pInfo[i].Name,
            cbLength);

        pLocalInfo[i].Name = (LPWSTR) ((PBYTE) pClientInfo + cbMark);
        cbMark += cbLength;

        cbLength = (wcslen(pInfo[i].Comment)+1)*sizeof(WCHAR);
        RtlCopyMemory(
            (PBYTE) pLocalInfo + cbMark,
            pInfo[i].Comment,
            cbLength);

        pLocalInfo[i].Comment = (LPWSTR) ((PBYTE) pClientInfo + cbMark);
        cbMark += cbLength;

    }

    SetCurrentPackageId( SPMGR_ID );

    scRet = LsapCopyToClient(pLocalInfo,pClientInfo,cbSize);

    if (SUCCEEDED(scRet))
    {
        *pPackages = pClientInfo;
    }


Cleanup:
    if (pLocalInfo != NULL)
    {
        LsapFreeLsaHeap(pLocalInfo);
    }
    if (FAILED(scRet) && (pClientInfo != NULL))
    {
        LsapClientFree(pClientInfo);
    }
    if (pInfo != NULL)
    {
        LsapFreeLsaHeap(pInfo);
    }

    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaGetBinding()
//
//  Synopsis:   Gets the full path/DLL name for a package, based on ID
//
//  Effects:
//
//  Arguments:  dwPackageID - ID of the package the caller needs the path for
//              pssPackageName - returns the name of package caller
//
//              pszModuleName - Receives the name of the package.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaGetBinding( ULONG_PTR           dwPackageID,
                PSEC_PACKAGE_BINDING_INFO   BindingInfo,
                PULONG              TotalSize,
                PWSTR *             Base)
{
    PLSAP_SECURITY_PACKAGE pPackage;
    PWSTR   Buffer;
    PLSA_CALL_INFO CallInfo ;
    PSECURITY_STRING DllPath ;
    SECURITY_STRING NullString = { 0 };

    ZeroMemory( BindingInfo, sizeof( SEC_PACKAGE_BINDING_INFO ) );

    pPackage = SpmpValidateHandle(dwPackageID);

    CallInfo = LsapGetCurrentCall();

    if ( (pPackage != NULL ) &&
         ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 )
    {
        //
        // If this is a WOW client, only return bindings for the packages
        // that support WOW clients.
        //

        if ( ( pPackage->fPackage & SP_WOW_SUPPORT ) == 0 )
        {
            pPackage = NULL ;
        }
    }

    if (pPackage)
    {
        //
        // Easy stuff:
        //

        BindingInfo->fCapabilities = pPackage->fCapabilities;
        BindingInfo->PackageIndex = pPackage->PackageIndex ;
        BindingInfo->Version = pPackage->Version ;
        BindingInfo->RpcId = pPackage->dwRPCID ;
        BindingInfo->TokenSize = pPackage->TokenSize ;

        if (pPackage->fPackage & SPM_AUTH_PKG_FLAG)
        {
            BindingInfo->Flags = PACKAGEINFO_AUTHPKG;
            //
            // Old style package:  no remote binding
            //

            return( SEC_E_INVALID_HANDLE );
        }

        DllPath = &pPackage->pBinding->Filename ;

        if ( pPackage->pBinding->Flags & DLL_BUILTIN )
        {
            BindingInfo->Flags = PACKAGEINFO_BUILTIN ;
            DllPath = &NullString ;
        }

        if ( pPackage->pBinding->Flags & DLL_SIGNED )
        {
            BindingInfo->Flags |= PACKAGEINFO_SIGNED ;
        }

        if ( ( pPackage->fPackage & SP_WOW_SUPPORT ) &&
             ( CallInfo->CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) )
        {
            DllPath = &pPackage->WowClientDll ;
        }


        //
        // If context thunks are present, copy them in:
        //

        if ( pPackage->Thunks )
        {
            BindingInfo->ContextThunksCount =
                            pPackage->Thunks->Info.ContextThunks.InfoLevelCount ;

            if ( pPackage->Thunks->Info.ContextThunks.InfoLevelCount <
                            PACKAGEINFO_THUNKS )
            {

                CopyMemory( BindingInfo->ContextThunks,
                            pPackage->Thunks->Info.ContextThunks.Levels,
                            BindingInfo->ContextThunksCount * sizeof(DWORD) );
            }
            else
            {
                CopyMemory( BindingInfo->ContextThunks,
                            pPackage->Thunks->Info.ContextThunks.Levels,
                            PACKAGEINFO_THUNKS * sizeof( DWORD ) );

            }
        }
        else
        {
            BindingInfo->ContextThunksCount = 0 ;
        }

        //
        // Compute Sizes:
        //

        *TotalSize = pPackage->Name.Length + 2 +
                     pPackage->Comment.Length + 2 +
                     DllPath->Length + 2 ;

        Buffer = (PWSTR) LsapAllocateLsaHeap( *TotalSize );

        if ( !Buffer )
        {
            return( SEC_E_INSUFFICIENT_MEMORY );
        }

        BindingInfo->PackageName.Buffer = Buffer ;
        BindingInfo->PackageName.Length = pPackage->Name.Length ;
        BindingInfo->PackageName.MaximumLength = pPackage->Name.Length + 2;

        CopyMemory( BindingInfo->PackageName.Buffer,
                    pPackage->Name.Buffer,
                    BindingInfo->PackageName.MaximumLength );

        BindingInfo->Comment.Buffer = BindingInfo->PackageName.Buffer +
                            BindingInfo->PackageName.MaximumLength / 2 ;

        BindingInfo->Comment.Length = pPackage->Comment.Length;
        BindingInfo->Comment.MaximumLength = BindingInfo->Comment.Length + 2;

        CopyMemory( BindingInfo->Comment.Buffer,
                    pPackage->Comment.Buffer,
                    BindingInfo->Comment.MaximumLength );


        if ( DllPath->Buffer )
        {
            BindingInfo->ModuleName.Buffer = BindingInfo->Comment.Buffer +
                                        BindingInfo->Comment.MaximumLength / 2;

            BindingInfo->ModuleName.Length = DllPath->Length;
            BindingInfo->ModuleName.MaximumLength = BindingInfo->ModuleName.Length + 2;

            CopyMemory( BindingInfo->ModuleName.Buffer,
                        DllPath->Buffer,
                        BindingInfo->ModuleName.MaximumLength );

        }


        *Base = Buffer ;

        return( SEC_E_OK );
    }

    return( SEC_E_INVALID_HANDLE );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapFindPackage
//
//  Synopsis:   Internal function for the security DLL to reference packages
//              by ID
//
//  Arguments:  [pPackage]     -- name of package
//              [pdwPackageId] -- returned id
//
//  Returns:    STATUS_SUCCESS          -- Package found
//              SEC_E_SECPKG_NOT_FOUND  -- Package not found
//
//  History:    5-26-93   RichardW   Created
//
//----------------------------------------------------------------------------

NTSTATUS
WLsaFindPackage(PUNICODE_STRING    pPackageName,
                ULONG_PTR *        pdwPackageId)
{
    PLSAP_SECURITY_PACKAGE pPackage;

    pPackage = SpmpLookupPackage(pPackageName);
    if (!pPackage)
    {
        *pdwPackageId = SPMGR_ID;
        return(SEC_E_SECPKG_NOT_FOUND);
    }
    else
    {
        *pdwPackageId = pPackage->dwPackageID;
        return(S_OK);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   WLsaAddPackage
//
//  Synopsis:   Adds a security package to the system
//
//  Arguments:  [PackageName] -- Package Name
//              [Options]     -- Options
//
//  History:    9-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaAddPackage(
    PSECURITY_STRING PackageName,
    PSECURITY_PACKAGE_OPTIONS Options)
{

    SECPKG_PARAMETERS Parameters;
    PLSAP_SECURITY_PACKAGE Package;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    BOOL Success;
    SECURITY_STATUS scRet;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    HKEY hKey ;


    DebugLog(( DEB_TRACE, "Adding Package %ws\n", PackageName->Buffer ));

    //
    // Make sure the caller has the rights to do this by impersonating them,
    // then opening the registry key.
    //

    scRet = LsapImpersonateClient();

    if ( NT_SUCCESS( scRet ) )
    {
        int err ;

        err = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    szLsaPath,
                    0,
                    KEY_READ | KEY_WRITE,
                    &hKey );

        if ( err != 0 )
        {
            scRet = NtCurrentTeb()->LastStatusValue ;
        }
        else
        {
            RegCloseKey( hKey );
        }

        RevertToSelf();
    }

    if ( !NT_SUCCESS( scRet ) )
    {
        return scRet ;
    }

    //
    // Build up the initialization message, to give the packages a better idea
    // of what is going on, and reduce their later calls for the same info.
    //

    Parameters.MachineState = (ULONG) 0;
    Parameters.SetupMode = SetupPhase;

    //
    // Make sure we haven't been through this already:
    //

    if ( SpmpFindDll( PackageName->Buffer ) )
    {
        DebugLog(( DEB_TRACE, "AddPackage:  DLL %ws already loaded\n", PackageName->Buffer ));
        return STATUS_SUCCESS ;
    }

    scRet = LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                (PLSAPR_POLICY_INFORMATION *) &DnsDomainInfo
                );

    if (!NT_SUCCESS(scRet))
    {
        DebugLog((DEB_ERROR,"Failed to get primary domain info: 0x%x\n",scRet));
        return(scRet);
    }

    Parameters.DomainName = * (PUNICODE_STRING) &DnsDomainInfo->Name;
    Parameters.DnsDomainName = * (PUNICODE_STRING) &DnsDomainInfo->DnsDomainName;
    Parameters.DomainSid = (PSID) DnsDomainInfo->Sid;


    DebugLog((DEB_TRACE_INIT, "Init Parameters = %d, %s\n",
                Parameters.MachineState,
                (Parameters.SetupMode ? "Setup" : "Normal") ));

    if (SpmpLoadDll( PackageName->Buffer, &Parameters ))
    {
        //
        // Successful Load!  Update the registry!
        //

        if ( Options->Flags & SECPKG_OPTIONS_PERMANENT )
        {
            Success = AddPackageToRegistry( PackageName );
        }
        else
        {
            Success = TRUE ;
        }

        if ( !Success )
        {
            //
            // Unload it!
            //
        }
    }
    else
    {
        Success = FALSE ;
    }

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyDnsDomainInformation,
        (PLSAPR_POLICY_INFORMATION) DnsDomainInfo
        );


    if ( Success )
    {
        return( SEC_E_OK );
    }

    return( SEC_E_SECPKG_NOT_FOUND );

}

//+---------------------------------------------------------------------------
//
//  Function:   WLsaDeletePackage
//
//  Synopsis:   Delete a security package
//
//  Arguments:  [PackageName] --
//
//  History:    9-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
WLsaDeletePackage(
    PSECURITY_STRING PackageName)
{
    return( SEC_E_NOT_SUPPORTED );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpmCreateEvent
//
//  Synopsis:   Just like the Win32 function, except that it allows
//              for names at the root of the namespace.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
HANDLE
SpmCreateEvent( LPSECURITY_ATTRIBUTES   lpsa,
                BOOL                    fManualReset,
                BOOL                    fInitialState,
                LPTSTR                  pszEventName)
{
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   EventAttr;
    UNICODE_STRING      usName;
    NTSTATUS            Status;
    ULONG               ulWin32Error;

    RtlInitUnicodeString(&usName, pszEventName);

    if (lpsa)
    {
        InitializeObjectAttributes(&EventAttr, &usName,
                                   (lpsa->bInheritHandle ? OBJ_INHERIT : 0),
                                   NULL,
                                   lpsa->lpSecurityDescriptor);
    }
    else
    {
        InitializeObjectAttributes(&EventAttr, &usName, 0, NULL, NULL);
    }

    Status = NtCreateEvent( &hEvent,
                            EVENT_ALL_ACCESS,
                            &EventAttr,
                            (fManualReset ? NotificationEvent : SynchronizationEvent),
                            (BOOLEAN) fInitialState);

    if (!NT_SUCCESS(Status))
    {
        ulWin32Error = RtlNtStatusToDosError( Status );
        SetLastError(ulWin32Error);
        return(NULL);
    }
    return(hEvent);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpmOpenEvent
//
//  Synopsis:   Just like Win32 OpenEvent, except that this supports \ in name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
HANDLE
SpmOpenEvent(   ULONG       fdwAccess,
                BOOL        fInherit,
                LPTSTR      pszEventName)
{
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   EventAttr;
    UNICODE_STRING      usName;
    NTSTATUS            Status;
    ULONG               ulWin32Error;

    RtlInitUnicodeString(&usName, pszEventName);

    InitializeObjectAttributes(&EventAttr, &usName, OBJ_CASE_INSENSITIVE |
                               (fInherit ? OBJ_INHERIT : 0), NULL, NULL);

    Status = NtOpenEvent(   &hEvent,
                            fdwAccess,
                            &EventAttr);

    if (!NT_SUCCESS(Status))
    {
        ulWin32Error = RtlNtStatusToDosError( Status );
        SetLastError(ulWin32Error);
        return(NULL);
    }
    return(hEvent);

}



////////////////////////////////////////////////////////////////////////////
//
//
//  Package List Manipulation:
//
//
////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   SpmpAddPackage
//
//  Synopsis:   Adds a package to the list.
//
//  Arguments:  [pPackage] -- Package to add
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
SpmpAddPackage(
    PLSAP_SECURITY_PACKAGE pPackage)
{
    PLSAP_SECURITY_PACKAGE *   pList;
    ULONG           PackageId;

    //
    // Grab excluse access to the list:
    //

    WriteLockPackageList();


    //
    // If we don't have any left over space in the array, realloc it
    //

    if ( PackageControlCount == PackageControlTotal )
    {
        pList = (PLSAP_SECURITY_PACKAGE *) LsapAllocateLsaHeap( sizeof(PLSAP_SECURITY_PACKAGE) *
                                (PackageControlTotal + INITIAL_PACKAGE_CONTROL_SIZE));
        if (!pList)
        {
            UnlockPackageList();
            return( 0xFFFFFFFF );
        }

        CopyMemory( pList,
                    pPackageControlList,
                    sizeof( PLSAP_SECURITY_PACKAGE ) * PackageControlTotal );

        PackageControlTotal += INITIAL_PACKAGE_CONTROL_SIZE;

        LsapFreeLsaHeap( pPackageControlList );

        pPackageControlList = pList;
    }

    //
    // Obtain a new package id (and slot)
    //

    PackageId = PackageControlCount++;

    pPackageControlList[ PackageId ] = pPackage;

    pPackage->pBinding->RefCount++;

    pPackage->dwPackageID = PackageId;

    UnlockPackageList();

    return( PackageId );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpRemovePackage
//
//  Synopsis:   Removes a package from the list
//
//  Arguments:  [PackageId] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpRemovePackage(
    ULONG PackageId)
{
    WriteLockPackageList();

    pPackageControlList[ PackageId ] = NULL;

    //
    // If the counter hasn't moved on, reclaim the index
    //

    if (PackageId == PackageControlCount - 1)
    {
        PackageControlCount--;
    }

    UnlockPackageList();

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpAddDll
//
//  Synopsis:   Add a DLL binding
//
//  Arguments:  [pBinding] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpAddDll(
    PDLL_BINDING    pBinding)
{
    PDLL_BINDING *  pList;
    ULONG           DllId;

    WriteLockPackageList();

    if ( PackageDllCount == PackageDllTotal )
    {
        pList = (PDLL_BINDING *) LsapAllocateLsaHeap( sizeof(PDLL_BINDING) *
                                (PackageDllTotal + INITIAL_PACKAGE_DLL_SIZE));
        if (!pList)
        {
            UnlockPackageList();
            return( FALSE );
        }

        CopyMemory( pList,
                    pPackageDllList,
                    sizeof( PDLL_BINDING ) * PackageDllTotal );

        PackageDllTotal += INITIAL_PACKAGE_DLL_SIZE;

        LsapFreeLsaHeap( pPackageDllList );

        pPackageDllList = pList;
    }

    pPackageDllList[ PackageDllCount++ ] = pBinding;

    UnlockPackageList();

    return( TRUE );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpRemoveDll
//
//  Synopsis:   Removes a DLL binding
//
//  Arguments:  [pBinding] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SpmpRemoveDll(
    PDLL_BINDING    pBinding)
{
    ULONG i;

    WriteLockPackageList();

    if (pPackageDllList[PackageDllCount - 1] == pBinding )
    {
        PackageDllCount --;

        pPackageDllList[ PackageDllCount ] = NULL;
    }
    else
    {

        for (i = 0; i < PackageDllCount ; i++ )
        {
            if (pPackageDllList[ i ] == pBinding)
            {
                pPackageDllList[ i ] = NULL;
                break;
            }
        }
    }

    UnlockPackageList();

}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpFindDll
//
//  Synopsis:   Searches set of DLLs already loaded for a DLL name
//
//  Arguments:  [DllName] -- absolute or relative path name
//
//  History:    9-20-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PDLL_BINDING
SpmpFindDll(
    PWSTR   DllName)
{
    WCHAR   DllPath[ MAX_PATH ];
    PWSTR   FilePart;
    DWORD   Length;
    UNICODE_STRING  Search;
    PDLL_BINDING pBinding;
    DWORD   i;

    pBinding = NULL ;

    Length = SearchPath(NULL,
                        DllName,
                        TEXT(".DLL"),
                        MAX_PATH,
                        DllPath,
                        &FilePart );

    if ( Length )
    {
        //
        // Name hit, see if we've loaded it already:
        //

        Search.Buffer = DllPath;
        Search.Length = (USHORT) (Length * sizeof( WCHAR ));
        Search.MaximumLength = Search.Length + sizeof( WCHAR ) ;


        ReadLockPackageList();

        for ( i = 0 ; i < PackageDllCount ; i++ )
        {
            if ( RtlEqualUnicodeString( &Search,
                                        &(pPackageDllList[i]->Filename),
                                        TRUE) )
            {
                pBinding = pPackageDllList[ i ];
                break;
            }
        }

        UnlockPackageList();

    }

    return( pBinding );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapGetExtendedPackageInfo
//
//  Synopsis:   Wrapper to get extended information from a package
//
//  Arguments:  [Package] -- Package to query
//              [Class]   -- Information class
//              [Info]    -- returned data
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
LsapGetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION * Info
    )
{
    NTSTATUS Status ;

    if ( (Package->fPackage & SP_INFO) == 0 )
    {
        return SEC_E_NOT_SUPPORTED ;
    }

    DebugLog(( DEB_TRACE, "Getting extended information (%d) from %ws\n",
                Class, Package->Name.Buffer ));
    __try
    {
        Status = Package->FunctionTable.GetExtendedInformation( Class, Info );
    }
    __except (SP_EXCEPTION)
    {
        Status = SPException(GetExceptionCode(), Package->dwPackageID);
    }

    return Status ;
}

NTSTATUS
LsapSetExtendedPackageInfo(
    PLSAP_SECURITY_PACKAGE  Package,
    SECPKG_EXTENDED_INFORMATION_CLASS Class,
    PSECPKG_EXTENDED_INFORMATION Info
    )
{
    NTSTATUS Status ;

    if ( ((Package->fPackage & SP_INFO) == 0 ) ||
         ( Package->FunctionTable.SetExtendedInformation == NULL ) )
    {
        return SEC_E_NOT_SUPPORTED ;
    }

    DebugLog(( DEB_TRACE, "Setting extended information (%d) from %ws\n",
                Class, Package->Name.Buffer ));
    __try
    {
        Status = Package->FunctionTable.SetExtendedInformation( Class, Info );
    }
    __except (SP_EXCEPTION)
    {
        Status = SPException(GetExceptionCode(), Package->dwPackageID);
    }

    return Status ;
}


//+---------------------------------------------------------------------------
//
//  Function:   LsapAuditPackageBoot
//
//  Synopsis:   Audit a package boot (load)
//
//  Arguments:  [pPackage] --
//
//  History:    5-06-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapAuditPackageBoot(
    IN PLSAP_SECURITY_PACKAGE pPackage
    )
{
    WCHAR   PackageAndDll[ MAX_PATH ];
    UNICODE_STRING AuditName;

    wcsncpy( PackageAndDll, pPackage->pBinding->Filename.Buffer, MAX_PATH );

    wcsncat( PackageAndDll, L" : ", 
             MAX_PATH - (pPackage->pBinding->Filename.Length / sizeof(WCHAR)) );

    wcsncat( PackageAndDll, pPackage->Name.Buffer, 
             MAX_PATH - ( pPackage->pBinding->Filename.Length / sizeof(WCHAR) + 4) );

    RtlInitUnicodeString( &AuditName, PackageAndDll );

    LsapAdtAuditPackageLoad( &AuditName );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpBootPackage
//
//  Synopsis:   Initializes a package by calling it's entry points
//
//  Arguments:  [pPackage]    -- Package to initialize
//              [pParameters] -- Initialization parameters
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpBootPackage(
    IN PLSAP_SECURITY_PACKAGE pPackage,
    IN PSECPKG_PARAMETERS pParameters
    )
{
    SECURITY_STATUS scRetCode;
    SecPkgInfo spiPackage = { 0 };
    UNICODE_STRING TempString;
    PSECPKG_EXTENDED_INFORMATION WowClient ;

    //
    // Break now so debugging people can set breakpoints in the newly loaded
    // DLL.
    //

    BreakOnError(BREAK_ON_LOAD);


    // Call the packages initialize function.  This gives the package a chance
    // to do whatever initialization it needs to do.  E.g. the kerberos package
    // runs out and finds the KDC.


    //
    // Set the session ID for tracking and so forth.
    //

    SetCurrentPackageId(pPackage->dwPackageID);

    __try
    {
        scRetCode = pPackage->FunctionTable.Initialize(
                        pPackage->dwPackageID,
                        pParameters,
                        &LsapSecpkgFunctionTable
                        );


    }
    __except (SP_EXCEPTION)
    {
        //
        // Well, this is odd.  The initialization function blew chunks.  That
        // means that the package itself can't be trusted.  So, let's change
        // this to an error return, and let the error logic blow away the
        // package.
        //

        scRetCode = SEC_E_CANNOT_INSTALL;

    }


    //
    // Let's see if the package loaded.  Hmm.
    //

    if (FAILED(scRetCode))
    {
        goto Cleanup;
    }

    //
    // Hey, a good one.  Now, determine the capabilities of the package by
    // calling it's getinfo function.
    //

    __try
    {
        scRetCode = pPackage->FunctionTable.GetInfo( &spiPackage );
    }
    __except (SP_EXCEPTION)
    {
        //
        // If it blows, catch it, and kill the package.
        //

        scRetCode = SPException(GetExceptionCode(), pPackage->dwPackageID);
    }

    //
    // Reset the session ID.
    //

    SetCurrentPackageId( SPMGR_ID );

    //
    // If it failed, note that and return.  Note, if there was an exception
    // then SPException() will have tagged the package appropriately.
    //

    if (FAILED(scRetCode))
    {
        goto Cleanup;
    }

    pPackage->fCapabilities = spiPackage.fCapabilities;
    pPackage->dwRPCID = spiPackage.wRPCID;
    pPackage->Version = spiPackage.wVersion ;
    pPackage->TokenSize = spiPackage.cbMaxToken ;

    RtlInitUnicodeString(
        &TempString,
        spiPackage.Name
        );

    scRetCode = LsapDuplicateString(
                    &pPackage->Name,
                    &TempString
                    );

    if (!NT_SUCCESS(scRetCode))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString( &TempString, spiPackage.Comment );

    scRetCode = LsapDuplicateString(
                    &pPackage->Comment,
                    &TempString );

    if ( !NT_SUCCESS( scRetCode ) )
    {
        goto Cleanup;
    }

    //
    // Find out if the package supports extended information.  If so,
    // find out what context attrs it wants thunked to LSA mode.
    //

    if ( pPackage->FunctionTable.GetExtendedInformation )
    {
        pPackage->fPackage |= SP_INFO ;

        scRetCode = LsapGetExtendedPackageInfo(
                                        pPackage,
                                        SecpkgContextThunks,
                                        &pPackage->Thunks );

        if ( scRetCode != STATUS_SUCCESS )
        {
            pPackage->Thunks = NULL ;

            scRetCode = 0 ;
        }

        if ( pPackage->Thunks )
        {
            pPackage->fPackage |= SP_CONTEXT_INFO ;
        }

        scRetCode = LsapGetExtendedPackageInfo(
                                        pPackage,
                                        SecpkgWowClientDll,
                                        &WowClient );

        if ( scRetCode == STATUS_SUCCESS )
        {
            scRetCode = LsapDuplicateString(
                            &pPackage->WowClientDll,
                            &WowClient->Info.WowClientDll.WowClientDllPath);

            if ( NT_SUCCESS( scRetCode ) )
            {
                pPackage->fPackage |= SP_WOW_SUPPORT ;
            }

        }
    }


    DebugLog((DEB_TRACE_INIT | DEB_TRACE, "Loaded %ws, assigned ID %d, flags %#x\n",
                spiPackage.Name,
                pPackage->dwPackageID,
                pPackage->fPackage ));

    lsState.cPackages++;
    if ((pPackage->fPackage & SPM_AUTH_PKG_FLAG) == 0)
    {
        lsState.cNewPackages ++;
    }

    //
    // And write the audit
    //

    LsapAuditPackageBoot( pPackage );


    return( TRUE );

Cleanup:

    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpBootAuthPackage
//
//  Synopsis:   Initializes an old-style authentication package.
//
//  Arguments:  [pPackage] --
//
//  History:    5-06-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SpmpBootAuthPackage(
    PLSAP_SECURITY_PACKAGE     pPackage)
{
    NTSTATUS scRet;
    PSTRING         pNlsName;
    char *          pszTemp;

    DebugLog((DEB_TRACE_LSA_AU, "Initializing package %d\n",
                    pPackage->dwPackageID));


    __try
    {
        scRet = pPackage->FunctionTable.InitializePackage(
                        (ULONG) pPackage->dwPackageID,
                        (PLSA_DISPATCH_TABLE) &LsapSecpkgFunctionTable,
                        NULL,
                        NULL,
                        &pNlsName);

        if (NT_SUCCESS(scRet))
        {

            // TODO: why is this alloc+copy here?
            pszTemp = (char *)LsapAllocateLsaHeap(pNlsName->Length + 1);
            if (pszTemp != NULL)
            {
                strncpy(pszTemp, pNlsName->Buffer, pNlsName->Length);

                scRet = RtlAnsiStringToUnicodeString(
                            &pPackage->Name,
                            pNlsName,
                            TRUE        // allocate destination
                            );

                LsapFreeLsaHeap(pszTemp);
            }
            else
            {
                scRet = STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // NTBUG 395189
            // Do not free the returned name.  There is no correct way to do
            // this, and some vendors do not separately allocate the string
            // and structure, and some might use some other part of memory.
            // So allow this potential leak, but since they are loaded only once
            // and at boot time, that's ok.
            //


#if 0
            //
            // Free the returned name
            //

            LsapFreeLsaHeap(pNlsName->Buffer);
            LsapFreeLsaHeap(pNlsName);
#endif
        }

    }
    __except (SP_EXCEPTION)
    {
        scRet = SPException(GetExceptionCode(), pPackage->dwPackageID);
    }

    if (SUCCEEDED(scRet))
    {
        lsState.cPackages ++;

        LsapAuditPackageBoot( pPackage );
    }


    return(scRet);
}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadPackage
//
//  Synopsis:   Loads a specific package from a DLL binding
//
//  Arguments:  [pBinding]    -- Binding to work from
//              [Package]     -- Package index to load
//              [pParameters] -- Parameters to pass for initialization
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadPackage(
    PDLL_BINDING pBinding,
    ULONG Package,
    PSECPKG_PARAMETERS pParameters)
{
    ULONG           PackageId;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECPKG_EVENT_PACKAGE_CHANGE Event;

    //
    // Get the package dispatch table:
    //

    pPackage = &pBinding->Packages[Package];

    //
    // Update its binding entry
    //

    pPackage->pBinding = pBinding;

    pPackage->PackageIndex = Package ;

    //
    // Add it as a package to run
    //

    PackageId = SpmpAddPackage( pPackage );

    if ( PackageId != 0xFFFFFFFF )
    {
        //
        // Boot it, so it is initialized
        //

        if ( SpmpBootPackage(pPackage, pParameters) )
        {
            //
            // Notify any listeners:
            //

            Event.ChangeType = SECPKG_PACKAGE_CHANGE_LOAD ;
            Event.PackageName = pPackage->Name ;
            Event.PackageId = PackageId ;

            LsapEventNotify(
                        NOTIFY_CLASS_PACKAGE_CHANGE,
                        0,
                        sizeof( Event ),
                        &Event );


            return( TRUE );
        }

        SpmpRemovePackage( PackageId );
    }


    return( FALSE );

}




//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadDll
//
//  Synopsis:   Loads a new DLL, determines the packages, and loads them
//
//  Arguments:  [pszDll]      -- DLL name
//              [pParameters] -- Parameters for initialization
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadDll(
    PWSTR               pszDll,
    PSECPKG_PARAMETERS  pParameters)
{
    HANDLE hDll;
    DLL_BINDING *   pBinding = NULL ;
    PDLL_BINDING *  pList;
    SpLsaModeInitializeFn   Init;
    ULONG PackageVersion;
    SECURITY_STATUS scRet;
    PSECPKG_FUNCTION_TABLE  pTables;
    HINSTANCE   hInstance = NULL ;
    ULONG PackageCount;
    PWSTR   pszPath;
    ULONG cchPath;
    ULONG i;
    ULONG SuccessCount;
    BOOL IsSigned ;


    hInstance = LoadLibrary( pszDll );
    if (hInstance)
    {

        Init = (SpLsaModeInitializeFn) GetProcAddress(
                                                hInstance,
                                                SECPKG_LSAMODEINIT_NAME);

        if (Init)
        {
            scRet = Init(   SECPKG_INTERFACE_VERSION,
                            &PackageVersion,
                            &pTables,
                            &PackageCount );

            if (SUCCEEDED(scRet))
            {
                pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) +
                                                (PackageCount - 1) *
                                                    sizeof( LSAP_SECURITY_PACKAGE ) );

                if (pBinding)
                {
                    pBinding->hInstance = hInstance;

                    pszPath = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * 2 * 2 );
                    if (pszPath)
                    {
                        UNICODE_STRING TempString;
                        cchPath = GetModuleFileName(  hInstance,
                                                      pszPath,
                                                      MAX_PATH * 2 );

                        RtlInitUnicodeString(
                            &TempString,
                            pszPath
                            );
                        scRet = LsapDuplicateString(
                                    &pBinding->Filename,
                                    &TempString
                                    );

                        LsapFreeLsaHeap( pszPath );


                        if (!NT_SUCCESS(scRet))
                        {
                            //
                            // Bail out:
                            //

                            goto LoadDll_Error;
                        }

#ifdef LSA_IGNORE_SIGNATURE
                        IsSigned = TRUE;
#else
                        IsSigned = FALSE;

                        {
                            const LPWSTR ExclusionList[] = {
                                    L"msv1_0",
                                    L"kerberos",
                                    L"schannel",
                                    L"wdigest",
                                    NULL
                                    };
                            ULONG ExclusionIndex = 0;

                            while( ExclusionList[ExclusionIndex] != NULL )
                            {
                                if( lstrcmpiW( pszDll, ExclusionList[ExclusionIndex] ) == 0 )
                                {
                                    IsSigned = TRUE;
                                    break;
                                }
                                ExclusionIndex++;
                            }
                        }

                        if( !IsSigned )
                        {
                            IsSigned = RtlCheckSignatureInFile( pBinding->Filename.Buffer );
                        }
#endif
                        if ( IsSigned )
                        {
                            pBinding->Flags |= DLL_SIGNED ;
                        }
                    }

                    pBinding->PackageCount = PackageCount;

                    SuccessCount = 0;

                    for (i = 0 ; i < PackageCount ; i++ )
                    {

                        //
                        // Old auth packages contain all functions up to but not including
                        //  SetContextAttributes.
                        //
                        if ( PackageVersion == SECPKG_INTERFACE_VERSION ) {

                            //
                            // Copy the exported table and zero the rest.
                            //

                            CopyMemory( &pBinding->Packages[i].FunctionTable,
                                        &pTables[i],
                                        offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes ) );

                            ZeroMemory( ((LPBYTE)(&pBinding->Packages[i].FunctionTable)) +
                                            offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes),
                                        sizeof(SECPKG_FUNCTION_TABLE) -
                                            offsetof(SECPKG_FUNCTION_TABLE, SetContextAttributes) );

                        } else {

                            CopyMemory( &pBinding->Packages[i].FunctionTable,
                                        &pTables[i],
                                        sizeof(SECPKG_FUNCTION_TABLE) );
                        }

                        if (SpmpLoadPackage( pBinding, i, pParameters ))
                        {
                            SuccessCount ++;
                        }
                    }

                    if (SuccessCount)
                    {
                        SpmpAddDll( pBinding );

                        return( TRUE );

                    }


                }

            }

        }

    }

LoadDll_Error :

    if ( pBinding != NULL )
    {
        LsapFreeLsaHeap( pBinding );
    }

    if ( hInstance != NULL )
    {
        FreeLibrary( hInstance );
    }

    return( FALSE );

}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadAuthPkgDll
//
//  Synopsis:   Loads an old (msv1_0 style) DLL
//
//  Arguments:  [pszDll] --
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadAuthPkgDll(
    PWSTR   pszDll)
{
    SECURITY_STATUS scRet;
    HINSTANCE       hInstance;
    PDLL_BINDING    pBinding = NULL ;
    PLSAP_SECURITY_PACKAGE     pPackage;
    ULONG           PackageId;
    UNICODE_STRING  PackageDll ;
    PWSTR           pszPath ;

    DebugLog((DEB_TRACE_INIT, "Loading Old package %ws\n", pszDll));


    hInstance = LoadLibrary( pszDll );

    if ( hInstance )
    {
        pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );
        if (pBinding)
        {

            pszPath = (PWSTR) LsapAllocateLsaHeap( MAX_PATH * 2 * 2 );

            if (pszPath)
            {
                UNICODE_STRING TempString;
                DWORD cchPath ;

                cchPath = GetModuleFileName(  hInstance,
                                              pszPath,
                                              MAX_PATH * 2 );

                RtlInitUnicodeString(
                    &TempString,
                    pszPath
                    );
                scRet = LsapDuplicateString(
                            &pBinding->Filename,
                            &TempString
                            );

                LsapFreeLsaHeap( pszPath );

                if (!NT_SUCCESS(scRet))
                {
                    goto LoadAuthDll_Error ;
                }

            }


            pBinding->Flags = DLL_AUTHPKG;
            pBinding->hInstance = hInstance;
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;
            pBinding->PackageCount = 1;

            if (BindOldPackage( hInstance, &pPackage->FunctionTable))
            {
                pPackage->fPackage = SPM_AUTH_PKG_FLAG;
                pPackage->fCapabilities = SPM_AUTH_PKG_FLAG;
                pPackage->dwRPCID = SECPKG_ID_NONE;

                PackageId = SpmpAddPackage( pPackage );
                if (PackageId != (ULONG) 0xFFFFFFFF)
                {
                    if ( SpmpAddDll( pBinding ) )
                    {
                        BreakOnError(BREAK_ON_LOAD);

                        scRet = SpmpBootAuthPackage( pPackage );

                        if (SUCCEEDED(scRet))
                        {
                            return( TRUE );
                        }

                        SpmpRemoveDll( pBinding );

                    }


                    LsapFreeString( &pBinding->Filename );

                    pBinding->Filename.Buffer = NULL ;

                    SpmpRemovePackage( PackageId );
                }

            }

        }

    }

LoadAuthDll_Error:

    if ( pBinding )
    {
        if ( pBinding->Filename.Buffer )
        {
            LsapFreeString( &pBinding->Filename );

        }

        LsapFreeLsaHeap( pBinding );
    }

    if ( hInstance )
    {
        FreeLibrary( hInstance );
    }

    return( FALSE );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpLoadBuiltin
//
//  Synopsis:   Loads a builtin package
//
//  Arguments:  [Flags]       -- Flags for the package
//              [pTable]      -- Dispatch table
//              [pParameters] -- init parameters
//
//  History:    7-26-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpLoadBuiltin(
    ULONG Flags,
    PSECPKG_FUNCTION_TABLE  pTable,
    PSECPKG_PARAMETERS  pParameters)
{
    PDLL_BINDING    pBinding;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRetCode;
    SecPkgInfo      spiPackage;
    ULONG           PackageId;
    SECPKG_EVENT_PACKAGE_CHANGE Event;
    WCHAR           Path[ MAX_PATH ];
    SECURITY_STRING TempString ;

    pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );

    if (pBinding)
    {
        ZeroMemory( pBinding, sizeof( DLL_BINDING ) );

        pBinding->Flags = DLL_BUILTIN;
        pBinding->PackageCount = 1;
        pBinding->hInstance = GetModuleHandle( L"lsasrv.dll" );
        GetModuleFileName( (HINSTANCE) pBinding->hInstance,
                            Path, MAX_PATH );

        RtlInitUnicodeString( &TempString, Path );
        scRetCode = LsapDuplicateString( &pBinding->Filename, &TempString );

        if ( NT_SUCCESS( scRetCode ) )
        {
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;
            pPackage->fPackage = Flags | SP_WOW_SUPPORT ;

            CopyMemory( &pPackage->FunctionTable,
                        pTable,
                        sizeof(SECPKG_FUNCTION_TABLE) );

            //
            // Fake up the DLL binding:
            //

            if ( SpmpAddDll( pBinding ) )
            {
                //
                // Add the package to the table:
                //

                PackageId = SpmpAddPackage( pPackage );

                if ( PackageId != 0xFFFFFFFF )
                {
                    //
                    // Initialize the package
                    //

                    if (SpmpBootPackage(pPackage, pParameters))
                    {

                        //
                        // Notify any listeners:
                        //

                        Event.PackageName = pPackage->Name ;
                        Event.PackageId = PackageId ;
                        Event.ChangeType = SECPKG_PACKAGE_CHANGE_LOAD ;

                        LsapEventNotify(
                                    NOTIFY_CLASS_PACKAGE_CHANGE,
                                    0,
                                    sizeof( Event ),
                                    &Event );

                        return( TRUE );
                    }

                    SpmpRemovePackage( PackageId );
                }

                SpmpRemoveDll( pBinding );

            }

        }

        LsapFreeLsaHeap( pBinding->Filename.Buffer );

        LsapFreeLsaHeap( pBinding );

    }

    return( FALSE );
}



BOOL
SpmpLoadBuiltinAuthPkg(
    PSECPKG_FUNCTION_TABLE  pTable)
{
    PDLL_BINDING    pBinding;
    ULONG           PackageId;
    PLSAP_SECURITY_PACKAGE     pPackage;
    SECURITY_STATUS scRet;
    WCHAR           Path[ MAX_PATH ];
    SECURITY_STRING TempString ;

    pBinding = (PDLL_BINDING) LsapAllocateLsaHeap( sizeof( DLL_BINDING ) );
    if (pBinding)
    {
        pBinding->Flags = DLL_AUTHPKG | DLL_BUILTIN;
        pBinding->PackageCount = 1;
        pBinding->hInstance = GetModuleHandle( L"lsasrv.dll" );
        GetModuleFileName( (HINSTANCE) pBinding->hInstance,
                            Path, MAX_PATH );

        RtlInitUnicodeString( &TempString, Path );
        scRet = LsapDuplicateString( &pBinding->Filename, &TempString );

        if ( NT_SUCCESS( scRet ) )
        {
            pPackage = pBinding->Packages;
            pPackage->pBinding = pBinding;

            CopyMemory( &pPackage->FunctionTable,
                        pTable,
                        sizeof( SECPKG_FUNCTION_TABLE ) );


            pPackage->fPackage = SPM_AUTH_PKG_FLAG;
            pPackage->fCapabilities = SPM_AUTH_PKG_FLAG;
            pPackage->dwRPCID = SECPKG_ID_NONE;

            PackageId = SpmpAddPackage( pPackage );
            if (PackageId != (ULONG) 0xFFFFFFFF)
            {
                if ( SpmpAddDll( pBinding ) )
                {
                    BreakOnError(BREAK_ON_LOAD);

                    scRet = SpmpBootAuthPackage( pPackage );

                    if (SUCCEEDED(scRet))
                    {
                        return( TRUE );
                    }

                    SpmpRemoveDll( pBinding );

                }

                SpmpRemovePackage( PackageId );

            }

            LsapFreeLsaHeap( pBinding );
        }
    }

    return( FALSE );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmpLocatePackage
//
//  Synopsis:   Locates the package
//
//  Arguments:  [PackageId] --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLocatePackage(
    ULONG_PTR PackageId)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;

    ReadLockPackageList();

    if( (ULONG)PackageId < PackageControlCount )
    {
        pControl = pPackageControlList[PackageId];
    }

    UnlockPackageList();

    return( pControl );

}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpValidateHandle
//
//  Synopsis:   Validates a package handle
//
//  Arguments:  [PackageHandle] --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpValidateHandle(
    ULONG_PTR PackageHandle)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;

    ReadLockPackageList();

    if ( PackageHandle < PackageControlCount )
    {
        pControl = pPackageControlList[ PackageHandle ];
    }

    UnlockPackageList();

    return( pControl );
}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpValidRequest
//
//  Synopsis:   Validates package handle, requested API code.
//
//  Arguments:  [PackageHandle] --
//              [ApiCode]       --
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpValidRequest(
    ULONG_PTR PackageHandle,
    ULONG   ApiCode)
{
    PLSAP_SECURITY_PACKAGE pControl = NULL;
    PVOID *     pTable;

    ReadLockPackageList();

    if ( PackageHandle < PackageControlCount )
    {
        pControl = pPackageControlList[ PackageHandle ];
    }

    UnlockPackageList();

    if (pControl)
    {
        if (pControl->fPackage & (SP_INVALID | SP_SHUTDOWN) )
        {
            pControl = NULL;
        }
    }

    if (pControl)
    {
        pTable = (PVOID *) &pControl->FunctionTable;
        if (pTable[ApiCode])
        {
            return( pControl );
        }

        pControl = NULL;
    }

    return( pControl );


}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackage
//
//  Synopsis:   Looks up a package based on name
//
//  Arguments:  [pssPackageName] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackage(
    PUNICODE_STRING    pssPackageName)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {

            if (RtlEqualUnicodeString(
                    pssPackageName,
                    &pPackageControlList[ iPack ]->Name,
                    TRUE))      // case insensitive
            {
                UnlockPackageList();

                return( pPackage );
            }
        }
    }

    UnlockPackageList();
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackageByRpcId
//
//  Synopsis:   Looks up a package based on RPC ID
//
//  Arguments:  [RpcId] --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackageByRpcId(
    ULONG RpcId)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {
            if (RpcId == pPackageControlList[iPack]->dwRPCID)
            {
                UnlockPackageList();

                return( pPackage );
            }
        }
    }

    UnlockPackageList();
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpLookupPackageAndRequest
//
//  Synopsis:   Returns a package pointer based on a name and the API code
//
//  Arguments:  [pssPackageName] -- Package name
//              [ApiCode]        -- Code
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpLookupPackageAndRequest(
    PUNICODE_STRING    pssPackageName,
    ULONG               ApiCode)
{
    ULONG           iPack;
    PLSAP_SECURITY_PACKAGE     pPackage;
    PVOID *         pTable;

    ReadLockPackageList();

    for (iPack = 0; iPack < PackageControlCount ; iPack++ )
    {
        pPackage = pPackageControlList[ iPack ];

        if ( pPackage )
        {

            if (RtlEqualUnicodeString(
                    pssPackageName,
                    &pPackageControlList[ iPack ]->Name,
                    TRUE))      // case insensitive
            {
                UnlockPackageList();
                if ((pPackage->fPackage & ( SP_INVALID | SP_SHUTDOWN )) == 0)
                {
                    pTable = (PVOID *) &pPackage->FunctionTable;

                    if (pTable[ApiCode])
                    {
                        return( pPackage );
                    }
                }
                return( NULL );
            }
        }
    }

    UnlockPackageList();
    return(NULL);
}




//+---------------------------------------------------------------------------
//
//  Function:   SpmpIteratePackagesByRequest
//
//  Synopsis:   Cycle through packages by request code, returning packages
//              that support supplied API
//
//  Arguments:  [pInitialPackage] --
//              [ApiCode]         --
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpIteratePackagesByRequest(
    PLSAP_SECURITY_PACKAGE pInitialPackage,
    ULONG       ApiCode)
{
    ULONG_PTR       NextPackage;
    PLSAP_SECURITY_PACKAGE     pPackage = NULL;
    PVOID *         pTable;
    ULONG           Ordinal ;
    ULONG           FlagMaskOn = 0 ;
    ULONG           FlagMaskOff = SP_INVALID | SP_SHUTDOWN ;

    Ordinal = ApiCode & SP_ORDINAL_MASK ;

    if ( ApiCode & SP_ITERATE_FILTER_WOW )
    {
        FlagMaskOn |= SP_WOW_SUPPORT ;
    }

    ReadLockPackageList();

    if (pInitialPackage)
    {
        NextPackage = pInitialPackage->dwPackageID + 1;
    }
    else
    {
        NextPackage = 0;
    }

    //
    // Walk through the list of packages, filtering on package flags
    // and whether the package supported the requested function
    //

    while (NextPackage < PackageControlCount)
    {
        pPackage = pPackageControlList[ NextPackage ];

        if ( pPackage )
        {
            if ( ( pPackage->fPackage & FlagMaskOff ) == 0 )
            {
                if ( ( pPackage->fPackage & FlagMaskOn ) == FlagMaskOn )
                {
                    pTable = (PVOID *) &pPackage->FunctionTable;

                    if ( pTable[ Ordinal ] )
                    {
                        //
                        // Found one!
                        //

                        break;
                    }
                }
            }

            pPackage = NULL;

        }

        NextPackage++;

    }

    UnlockPackageList();

    return( pPackage );


}




//+---------------------------------------------------------------------------
//
//  Function:   SpmpIteratePackages
//
//  Synopsis:   Safe iteration of the packages
//
//  Arguments:  [pInitialPackage] -- Prior package
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_SECURITY_PACKAGE
SpmpIteratePackages(
    PLSAP_SECURITY_PACKAGE pInitialPackage)
{
    ULONG_PTR NextPackage;
    PLSAP_SECURITY_PACKAGE pPackage = NULL;

    ReadLockPackageList();

    if (pInitialPackage)
    {
        NextPackage = pInitialPackage->dwPackageID + 1;
    }
    else
    {
        NextPackage = 0;
    }

    while (NextPackage < PackageControlCount)
    {
        pPackage = pPackageControlList[ NextPackage ];

        if ( pPackage )
        {
            break;
        }

        NextPackage++;

    }

    UnlockPackageList();

    return( pPackage );
}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpCurrentPackageCount
//
//  Synopsis:   Returns the current package count
//
//  Arguments:  (none)
//
//  History:    7-30-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
SpmpCurrentPackageCount(
    VOID)
{
    ULONG   Count;

    ReadLockPackageList();

    Count = PackageControlCount;

    UnlockPackageList();

    return( Count );

}

//+---------------------------------------------------------------------------
//
//  Function:   LsapAddPackageHandle
//
//  Synopsis:   Increases the package handle count
//
//  Arguments:  [PackageId] --
//
//  History:    10-08-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapAddPackageHandle(
    ULONG_PTR PackageId,
    BOOL IsContext
    )
{
#if DBG

    PLSAP_SECURITY_PACKAGE Package ;

    Package = pPackageControlList[ PackageId ];

    if ( IsContext )
    {
        InterlockedIncrement( (PLONG)&Package->ContextHandles );
    }
    else
    {
        InterlockedIncrement( (PLONG)&Package->CredentialHandles );
    }

#else
    UNREFERENCED_PARAMETER( PackageId );
    UNREFERENCED_PARAMETER( IsContext );
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   LsapDelPackageHandle
//
//  Synopsis:   Decrements the package handle count
//
//  Arguments:  [PackageId] --
//
//  History:    10-08-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
LsapDelPackageHandle(
    PLSAP_SECURITY_PACKAGE Package,
    BOOL IsContext
    )
{
#ifdef DBG

    if ( IsContext )
    {
        InterlockedDecrement( (PLONG)&Package->ContextHandles );
    }
    else
    {
        InterlockedDecrement( (PLONG)&Package->CredentialHandles );
    }

#else
    UNREFERENCED_PARAMETER( Package );
    UNREFERENCED_PARAMETER( IsContext );
#endif


}



//+---------------------------------------------------------------------------
//
//  Function:   SpmpInitializePackageControl
//
//  Synopsis:   Initialize the package controls
//
//  Arguments:  (none)
//
//  History:    11-15-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpInitializePackageControl(
    VOID)
{
    RtlInitializeResource( &PackageListLock );

    WriteLockPackageList();

    pPackageDllList = (PDLL_BINDING *) LsapAllocateLsaHeap( sizeof(PDLL_BINDING) *
                            INITIAL_PACKAGE_DLL_SIZE );

    if (pPackageDllList)
    {
        PackageDllCount = 0;
        PackageDllTotal = INITIAL_PACKAGE_DLL_SIZE;

        pPackageControlList = (PLSAP_SECURITY_PACKAGE *) LsapAllocateLsaHeap( sizeof(PLSAP_SECURITY_PACKAGE) *
                                INITIAL_PACKAGE_CONTROL_SIZE );

        if (pPackageControlList)
        {
            PackageControlCount = 0;
            PackageControlTotal = INITIAL_PACKAGE_CONTROL_SIZE;

            UnlockPackageList();

            return( TRUE );
        }

        LsapFreeLsaHeap( pPackageDllList );

    }

    //
    // KEEP the lock, so that nothing else tries to use the package list
    //

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\spnego.h ===
#ifndef _SPNEGO_Module_H_
#define _SPNEGO_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct MechTypeList * PMechTypeList;

typedef ASN1objectidentifier_t MechType;

typedef PMechTypeList SavedMechTypeList;
#define SavedMechTypeList_PDU 0
#define SIZE_SPNEGO_Module_PDU_0 sizeof(SavedMechTypeList)

typedef ASN1bitstring_t ContextFlags;
#define delegFlag 0x80
#define mutualFlag 0x40
#define replayFlag 0x20
#define sequenceFlag 0x10
#define anonFlag 0x8
#define confFlag 0x4
#define integFlag 0x2

typedef ASN1octetstring_t MechSpecInfo;

typedef enum NegResult {
    accept_completed = 0,
    accept_incomplete = 1,
    reject = 2,
} NegResult;

typedef struct MechTypeList {
    PMechTypeList next;
    MechType value;
} MechTypeList_Element;

typedef struct NegHints {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define hintName_present 0x80
    ASN1ztcharstring_t hintName;
#   define hintAddress_present 0x40
    ASN1octetstring_t hintAddress;
} NegHints;

typedef struct NegTokenInit {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NegTokenInit_mechTypes_present 0x80
    PMechTypeList mechTypes;
#   define NegTokenInit_reqFlags_present 0x40
    ContextFlags reqFlags;
#   define NegTokenInit_mechToken_present 0x20
    ASN1octetstring_t mechToken;
#   define NegTokenInit_negHints_present 0x10
    NegHints negHints;
#   define NegTokenInit_mechListMIC_present 0x8
    ASN1octetstring_t mechListMIC;
} NegTokenInit;

typedef struct NegTokenInit2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define NegTokenInit2_mechTypes_present 0x80
    PMechTypeList mechTypes;
#   define NegTokenInit2_reqFlags_present 0x40
    ContextFlags reqFlags;
#   define NegTokenInit2_mechToken_present 0x20
    ASN1octetstring_t mechToken;
#   define NegTokenInit2_mechListMIC_present 0x10
    ASN1octetstring_t mechListMIC;
#   define NegTokenInit2_negHints_present 0x8
    NegHints negHints;
} NegTokenInit2;

typedef struct NegTokenTarg {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define negResult_present 0x80
    NegResult negResult;
#   define supportedMech_present 0x40
    MechType supportedMech;
#   define responseToken_present 0x20
    ASN1octetstring_t responseToken;
#   define NegTokenTarg_mechListMIC_present 0x10
    ASN1octetstring_t mechListMIC;
} NegTokenTarg;

typedef struct NegotiationToken {
    ASN1choice_t choice;
    union {
#	define negTokenInit_chosen 1
	NegTokenInit negTokenInit;
#	define negTokenTarg_chosen 2
	NegTokenTarg negTokenTarg;
#	define negTokenInit2_chosen 3
	NegTokenInit2 negTokenInit2;
    } u;
} NegotiationToken;
#define NegotiationToken_PDU 1
#define SIZE_SPNEGO_Module_PDU_1 sizeof(NegotiationToken)

typedef struct InitialNegToken {
    MechType spnegoMech;
    NegotiationToken negToken;
} InitialNegToken;
#define InitialNegToken_PDU 2
#define SIZE_SPNEGO_Module_PDU_2 sizeof(InitialNegToken)


extern ASN1module_t SPNEGO_Module;
extern void ASN1CALL SPNEGO_Module_Startup(void);
extern void ASN1CALL SPNEGO_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _SPNEGO_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\suppcred.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        suppcred.cxx
//
// Contents:    Code to retrieve/store supplemental credentials
//
//
// History:     9/23/93         Created         MikeSw
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "sesmgr.h"     // PSession
#include "suppcred.h"   // supp. cred. apis
}


typedef struct _DomainSuppCreds {
    UNICODE_STRING ssUserName;
    UNICODE_STRING ssDomainName;
    HANDLE hClientToken;
    SECPKG_SUPPLEMENTAL_CRED SupplementalCredential;
} DomainSuppCreds, *PDomainSuppCreds;


//+-------------------------------------------------------------------------
//
//  Function:   LsapSaveSupplementalCredentials
//
//  Synopsis:   Saves supplemental credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS SEC_ENTRY
LsapSaveSupplementalCredentials(
    IN PLUID LogonId,
    IN ULONG SupplementalCredSize,
    IN PVOID SupplementalCreds,
    IN BOOLEAN Synchronous
    )
{
    //
    // obsolete by credmgr
    //

    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaSaveSupplementalCredentials
//
//  Synopsis:   worker function to call package to set supp. creds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C"
NTSTATUS
WLsaSaveSupplementalCredentials(
    IN PCredHandle pCredHandle,
    IN PSecBuffer pCredentials
    )
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PSession        pSession = GetCurrentSession();


    //
    // Make sure we can exec.
    //

    IsOkayToExec(0);

    pspPackage = SpmpValidRequest( pCredHandle->dwLower, SP_ORDINAL_SAVECRED);
    if (!pspPackage)
    {
        return( STATUS_INVALID_HANDLE );
    }

    SetCurrentPackageId(pCredHandle->dwLower);

    DebugLog((DEB_TRACE,"WLsaSaveSupplementalCredentials %x,%x\n",
                    pCredHandle->dwUpper,pCredHandle->dwLower));
    DebugLog((DEB_TRACE_VERB, "\tPackage = %ws\n", pspPackage->Name.Buffer));

    __try
    {

        scRet = pspPackage->FunctionTable.SaveCredentials(
                                                pCredHandle->dwUpper,
                                                pCredentials);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }


    DebugLog((DEB_TRACE_VERB,"WLsaSaveSupplementalCredentials returning %x\n",scRet));
    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   WLsaGetSupplementalCredentials
//
//  Synopsis:   worker function to call package to get supp. credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      allocates virtual memory in client process
//
//
//--------------------------------------------------------------------------
extern "C"
NTSTATUS
WLsaGetSupplementalCredentials(
            PCredHandle         pCredHandle,
            PSecBuffer          pCreds)
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PSession        pSession = GetCurrentSession();


    //
    // Make sure we can exec.
    //

    IsOkayToExec(0);

    pspPackage = SpmpValidRequest( pCredHandle->dwLower, SP_ORDINAL_GETCRED);
    if (!pspPackage)
    {
        return( STATUS_INVALID_HANDLE );
    }


    SetCurrentPackageId(pCredHandle->dwLower);

    DebugLog((DEB_TRACE,"WLsaGetSupplementalCredentials %x,%x\n",
                    pCredHandle->dwUpper,pCredHandle->dwLower));
    DebugLog((DEB_TRACE_VERB, "\tPackage = %ws\n", pspPackage->Name.Buffer));

    __try
    {

        scRet = pspPackage->FunctionTable.GetCredentials(
                                                pCredHandle->dwUpper,
                                                pCreds);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }


    DebugLog((DEB_TRACE_VERB,"WLsaGetSupplementalCredentials returning %x\n",scRet));
    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   WLsaDeleteSupplementalCredentials
//
//  Synopsis:   worker function to call package to delete credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
extern "C"
NTSTATUS
WLsaDeleteSupplementalCredentials(
            PCredHandle         pCredHandle,
            PSecBuffer          pKey)
{
    NTSTATUS         scRet;
    PLSAP_SECURITY_PACKAGE     pspPackage;
    PSession        pSession = GetCurrentSession();


    //
    // Make sure we can exec.
    //

    IsOkayToExec(0);

    pspPackage = SpmpValidRequest( pCredHandle->dwLower, SP_ORDINAL_DELETECRED);
    if (!pspPackage)
    {
        return( STATUS_INVALID_HANDLE );
    }

    SetCurrentPackageId(pCredHandle->dwLower);

    DebugLog((DEB_TRACE,"WLsaDeleteSupplementalCredentials %x,%x\n",
                    pCredHandle->dwUpper,pCredHandle->dwLower));
    DebugLog((DEB_TRACE_VERB, "\tPackage = %ws\n", pspPackage->Name.Buffer));

    __try
    {

        scRet = pspPackage->FunctionTable.DeleteCredentials(
                                                pCredHandle->dwUpper,
                                                pKey);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pspPackage->dwPackageID);
    }


    DebugLog((DEB_TRACE_VERB,"WLsaDeleteSupplementalCredentials returning %x\n",scRet));
    return(scRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   FreeSupplementalCredentials
//
//  Synopsis:   frees supplemental credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
void
LsapFreeSupplementalCredentials(
    IN ULONG CredentialCount,
    IN PSECPKG_SUPPLEMENTAL_CRED pCredArray
    )
{
    ULONG cIndex;

    if ((pCredArray == NULL) || (CredentialCount == 0))
    {
        return;
    }
    for (cIndex = 0; cIndex < CredentialCount ; cIndex++)
    {
        if (pCredArray[cIndex].PackageName.Buffer != NULL)
        {
            LsapFreeLsaHeap(pCredArray[cIndex].PackageName.Buffer);
        }
        if (pCredArray[cIndex].Credentials != NULL)
        {
            LsapFreeLsaHeap(pCredArray[cIndex].Credentials);
        }
    }
    LsapFreeLsaHeap(pCredArray);
}





//+-------------------------------------------------------------------------
//
//  Function:   ReformatSupplementalCredentials
//
//  Synopsis:   Takes a an array of SupplementalCred structures and
//              converts it to the CREDENTIAL** used by WLsaLogonUser.
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapReformatSupplementalCredentials(
    IN ULONG cSupplementalCreds,
    IN PSECPKG_SUPPLEMENTAL_CRED pSupplementalCreds,
    OUT PULONG CredentialCount,
    OUT PSECPKG_SUPPLEMENTAL_CRED * Credentials
    )
{


    NTSTATUS     scRet;
    ULONG       cIndex;
    ULONG       cCredIndex;
    PLSAP_SECURITY_PACKAGE pPackage;
    PSECPKG_SUPPLEMENTAL_CRED TempSuppCreds = NULL;

    TempSuppCreds = (PSECPKG_SUPPLEMENTAL_CRED) LsapAllocateLsaHeap(
                        sizeof(SECPKG_SUPPLEMENTAL_CRED) * lsState.cPackages);
    if (TempSuppCreds == NULL)
    {
        scRet = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory(
        TempSuppCreds,
        sizeof(SECPKG_SUPPLEMENTAL_CRED) * lsState.cPackages
        );


    //
    // Scan through the packages looking for matching credentials
    //

    pPackage = SpmpIteratePackages( NULL );

    while (pPackage)
    {
        cIndex = pPackage->dwPackageID;



        //
        // Scan through the credentials looking for the one matching
        // the package name
        //

        for (cCredIndex = 0; cCredIndex < cSupplementalCreds ; cCredIndex++ )
        {
            if ( RtlCompareUnicodeString(
                    &pPackage->Name,
                    &pSupplementalCreds[cCredIndex].PackageName,
                    TRUE // CaseInsensitive
                    )  == 0 )
            {
                DebugLog((DEB_TRACE_CRED, "Read credentials for packages %wZ\n",
                            &pPackage->Name));
                TempSuppCreds[cIndex] = pSupplementalCreds[cCredIndex];
            }

        }

        pPackage = SpmpIteratePackages( pPackage );

    }

    *Credentials = TempSuppCreds;
    *CredentialCount = lsState.cPackages;

    scRet = STATUS_SUCCESS;

Cleanup:


    return(scRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\userkey.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    efssrv.hxx

Abstract:

    EFS (Encrypting File System) function prototypes.

Author:

    Robert Reichel      (RobertRe)
    Robert Gu           (RobertG)

Environment:

Revision History:

--*/

#ifndef _USERKEY_
#define _USERKEY_

#ifdef __cplusplus
extern "C" {
#endif


//
// Exported functions
//


LONG
GetCurrentKey(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey           OPTIONAL,
	OUT HCRYPTPROV * hProv          OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    );

BOOL
CreateCertFromKey(
    IN LPWSTR       ContainerName,
    IN LPWSTR       ProviderName,
    IN BOOLEAN      RecoveryKey,
    OUT PBYTE     * pbHash          OPTIONAL,
    OUT PDWORD      cbHash          OPTIONAL,
    OUT PBYTE     * pbReturnCert    OPTIONAL,
    OUT PDWORD      cbReturnCert    OPTIONAL,
    OUT LPWSTR    * DisplayInfo     OPTIONAL
    );

DWORD
GetKeyInfoFromCertHash(
    IN OUT PEFS_USER_INFO pEfsUserInfo,
    IN PBYTE         pbHash,
    IN DWORD         cbHash,
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBOOLEAN     pbIsValid OPTIONAL
    );

BOOLEAN
CurrentHashOK(
    IN PEFS_USER_INFO pEfsUserInfo, 
    IN PBYTE         pbHash, 
    IN DWORD         cbHash,
    OUT DWORD        *dFlag
    );

DWORD
GetCurrentHash(
     IN  PEFS_USER_INFO pEfsUserInfo, 
     OUT PBYTE          *pbHash, 
     OUT DWORD          *cbHash
     );

#ifdef __cplusplus
} // extern C
#endif

#endif // _USERKEY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\userkey.cxx ===
/*++

Copyright (c) 1997 - 1999  Microsoft Corporation

Module Name:

    userkey.cxx

Abstract:

    EFS (Encrypting File System) Server

Author:

    Robert Reichel      (RobertRe)     July 4, 1997
    Robert Gu           (RobertG)      January 23, 1998

Environment:

Revision History:

--*/

#include <lsapch.hxx>

extern "C" {
#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wincrypt.h>
#include <cryptui.h>
#include <stdio.h>
#include <malloc.h>
#include <certca.h>
#include "lsasrvp.h"
#include "efssrv.hxx"
#include "userkey.h"
}

#define PROVIDER       TEXT("Provider")
#define CONTAINER      TEXT("Container")
#define PROVIDER_TYPE  TEXT("Type")
#define CERT_HASH      TEXT("CertificateHash")
#define CERT_FLAG      TEXT("Flag")

#define KEYPATH  TEXT("%ws\\Software\\Microsoft\\Windows NT\\CurrentVersion\\EFS\\CurrentKeys")
#define KEYPATHROOT HKEY_USERS

#define YEARCOUNT (LONGLONG) 10000000*3600*24*365 // One Year's tick count


#ifndef wszCERTTYPE_EFS
#define wszCERTTYPE_EFS             L"EFS"
#endif

#ifndef wszCERTTYPE_EFS_RECOVERY
#define wszCERTTYPE_EFS_RECOVERY  L"EFSRecovery"
#endif

LONG UserCertIsValidating = 0;

//
// Forward references
//

BOOL
EfspCreateSelfSignedCert(
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo,
    OUT PCCERT_CONTEXT *pCertContext
    );

DWORD
GenerateUserKey (
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey   OPTIONAL,
    OUT HCRYPTPROV * hProv  OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    );

PWCHAR
ConstructKeyPath(
    PWCHAR      SidString
    )

/*++

Routine Description:

    This routine constructs the path to the current user key, in the form

    <user-sid>\Software\Microsoft\Windows NT\CurrentVersion\EFS\CurrentKeys

Arguments:

    None.

Return Value:

    Returns the path the the current user keyset

--*/

{
    PWCHAR      KeyPath = NULL;

    if (SidString) {

        DWORD KeyPathLength = wcslen( KEYPATH );

        //
        // Subtract 3 for %ws and add 1 for NULL
        //

        DWORD StringLength = ( KeyPathLength - 3 + wcslen( SidString ) + 1) * sizeof( WCHAR );

        KeyPath = (PWCHAR)LsapAllocateLsaHeap( StringLength );

        if (KeyPath) {

            swprintf( KeyPath, KEYPATH, SidString );
            KeyPath[StringLength/sizeof( WCHAR ) - 1] = UNICODE_NULL;
        }

    }

    return( KeyPath );
}


NTSTATUS
EfspGetTokenUser(
    IN  OUT PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    This routine returns the TOKEN_USER structure for the
    current user, and optionally, the AuthenticationId from his
    token.

Arguments:

    pEfsUserInfo - User Info.

Return Value:

    NtStatus code
    
--*/

{
    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;
    PTOKEN_USER pTokenUser = NULL;
    BOOLEAN b = FALSE;
    BYTE  PefBuffer[1024];

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     TokenHandle,
                     TokenUser,
                     PefBuffer,
                     sizeof (PefBuffer),
                     &ReturnLength
                     );

        if ( NT_SUCCESS( Status ) || (Status == STATUS_BUFFER_TOO_SMALL)) {

            pEfsUserInfo->pTokenUser = (PTOKEN_USER)LsapAllocateLsaHeap( ReturnLength );

            if (pEfsUserInfo->pTokenUser) {

                if (NT_SUCCESS( Status )) {

                    RtlCopyMemory(pEfsUserInfo->pTokenUser, PefBuffer, ReturnLength);

                    //
                    // Fix the SID pointer
                    //

                    pEfsUserInfo->pTokenUser->User.Sid = (PSID)((PBYTE)(pEfsUserInfo->pTokenUser) + sizeof(SID_AND_ATTRIBUTES));

                    ASSERT(RtlValidSid(pEfsUserInfo->pTokenUser->User.Sid));

                } else {

                    //
                    // The stack performance buffer is not bigger enough
                    //

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenUser,
                                 pEfsUserInfo->pTokenUser,
                                 ReturnLength,
                                 &ReturnLength
                                 );

                }
    
                if ( NT_SUCCESS( Status )) {

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenStatistics,
                                 (PVOID)&TokenStats,
                                 sizeof( TOKEN_STATISTICS ),
                                 &ReturnLength
                                 );

                    if ( NT_SUCCESS( Status )) {

                        NTSTATUS Status1;

                        pEfsUserInfo->AuthId = TokenStats.AuthenticationId;
                        b = TRUE;

                        //
                        // If we failed to get the group info, we assume the user is not interactively logged on.
                        // The fail should not stop us, we could go without cache at the worst.
                        //

                        Status1 = NtQueryInformationToken (
                                     TokenHandle,
                                     TokenGroups,
                                     PefBuffer,
                                     sizeof (PefBuffer),
                                     &ReturnLength
                                     );

                        if (NT_SUCCESS( Status1 ) || (Status1 == STATUS_BUFFER_TOO_SMALL)) {

                            PTOKEN_GROUPS pGroups = NULL;
                            PTOKEN_GROUPS pAllocGroups = NULL;

                            if ( NT_SUCCESS( Status1 ) ) {

                                pGroups = (PTOKEN_GROUPS) PefBuffer;

                            } else {

                                pAllocGroups = (PTOKEN_GROUPS)LsapAllocateLsaHeap( ReturnLength );

                                Status1 = NtQueryInformationToken (
                                             TokenHandle,
                                             TokenGroups,
                                             pAllocGroups,
                                             ReturnLength,
                                             &ReturnLength
                                             );

                                if ( NT_SUCCESS( Status1 )) {

                                   pGroups = pAllocGroups;

                                }

                            }

                
                            if (pGroups) {
                
                                //
                                // Search the interactive SID. Looks like this SID tends to appear at the
                                // end of the list. We search from back to the first.
                                //

                                int SidIndex;

                                for ( SidIndex = (int)(pGroups->GroupCount - 1); SidIndex >= 0; SidIndex--) {
                                    if (RtlEqualSid(LsapInteractiveSid, pGroups->Groups[SidIndex].Sid)) {
                                        pEfsUserInfo->InterActiveUser = USER_INTERACTIVE;
                                        break;
                                    }
                                }
                                if (pEfsUserInfo->InterActiveUser != USER_INTERACTIVE) {
                                    pEfsUserInfo->InterActiveUser = USER_REMOTE;
                                }

                            }

                            if (pAllocGroups) {
                                LsapFreeLsaHeap( pAllocGroups );
                            }

                        }

                        // LsapInteractiveSid

                    }

                }

                if (!b) {

                    //
                    // Something failed, clean up what we were going to return
                    //

                    LsapFreeLsaHeap( pEfsUserInfo->pTokenUser );
                    pEfsUserInfo->pTokenUser = NULL;
                }

            } else {

               Status = STATUS_INSUFFICIENT_RESOURCES;
            }

        }

        NtClose( TokenHandle );

    }

    return( Status );
}



PWCHAR
ConvertSidToWideCharString(
    PSID Sid
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    UNICODE_STRING Result;

    if ( STATUS_SUCCESS != RtlConvertSidToUnicodeString( &Result, Sid, TRUE )) {

        return NULL;
    }

    return Result.Buffer;
}

BOOLEAN
EfspIsSystem(
    PEFS_USER_INFO pEfsUserInfo,
    OUT PBOOLEAN System
    )
/*++

Routine Description:

    Determines if the current user is running in system context or not.

Arguments:

    System - Receives whether or not the current user is system.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{

    *System = RtlEqualSid(LsapLocalSystemSid, pEfsUserInfo->pTokenUser->User.Sid);

    return( TRUE );
}

BOOL
EfspIsDomainUser(
    IN  LPWSTR   lpDomainName,
    OUT PBOOLEAN IsDomain
    )
/*++

Routine Description:

    Determines if the current user is logged on to a domain account
    or a local machine account.

Arguments:

    lpDomainName - Supplies the domain name.

    IsDomain - Returns TRUE if the current user is logged on to a domain
        account, FALSE otherwise.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{

    *IsDomain = (wcscmp( EfsComputerName, lpDomainName ) != 0);

    return( TRUE );
}


BOOL
EnrollKeyPair(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  DWORD        dwProviderType,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo
    )
/*++

Routine Description:

    This routine takes a keypair and attempts to enroll it.

Arguments:

    hKey - Optionally returns a handle to the user's key.

    hProv - Optionally returns a handle to the user's key's provider.

    lpContainerName - Returns the name of the user's key container.

    lpProviderName - Returns the name of the user's key provider.

    ProviderType - Returns the type of the provider.

    pbHash - Returns the hash of the user's certificate.

    cbHash - Returns the length in bytes of the certificate hash.

    DisplayInfo - Returns the display information associated with this
        certificate.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for details.

--*/
{
    BOOL b = FALSE;
    BOOL fResult = FALSE;
    NTSTATUS Status;
    DWORD rc = ERROR_SUCCESS;
    DWORD ImpersonationError;

    HCRYPTKEY   hLocalKey = NULL;
    HCRYPTPROV  hLocalProv = NULL;

    PCCERT_CONTEXT pCertContext = NULL ;
    //
    // Initialize OUT parameters
    //

    *pbHash          = NULL;
    *lpDisplayInfo   = NULL;
    *lpContainerName = NULL;
    *lpProviderName  = NULL;
    *cbHash          = 0;

    *hKey = NULL;
    *hProv = NULL;

    //
    // Initialize output parameters
    //

    if (pEfsUserInfo->bDomainAccount) {

        HRESULT AutoEnrollSuccess = S_OK;

        //
        // Attempt to create the auto-enroll object so that this cert re-enrolls.
        //
        // DLL is demand load.
        //

        __try {

            AutoEnrollSuccess = CACreateLocalAutoEnrollmentObject(
                                    wszCERTTYPE_EFS,
                                    NULL,
                                    NULL,
                                    CERT_SYSTEM_STORE_CURRENT_USER
                                    );

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            rc = GetExceptionCode();
            AutoEnrollSuccess = (HRESULT)rc;
        }

        if (S_OK == AutoEnrollSuccess) {

            HCERTTYPE       hCertType = 0;

            CRYPTUI_WIZ_CERT_REQUEST_INFO         CertRequest;
            CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW      NewKeyInfo;
            CRYPT_KEY_PROV_INFO                   KeyProvInfo;
            CRYPTUI_WIZ_CERT_TYPE                 CertType;

            memset( &CertRequest, 0, sizeof( CRYPTUI_WIZ_CERT_REQUEST_INFO ));

            KeyProvInfo.pwszContainerName = NULL;
            KeyProvInfo.pwszProvName      = NULL;
            KeyProvInfo.dwProvType        = dwProviderType;
            KeyProvInfo.dwFlags           = 0;
            KeyProvInfo.cProvParam        = 0;
            KeyProvInfo.rgProvParam       = NULL;
            KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;

            memset( &NewKeyInfo, 0, sizeof( CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW ));

            NewKeyInfo.dwSize        = sizeof( CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW );
            NewKeyInfo.pKeyProvInfo  = &KeyProvInfo;
            NewKeyInfo.dwGenKeyFlags = RSA1024BIT_KEY | CRYPT_EXPORTABLE;

            LPWSTR lpwstr          = wszCERTTYPE_EFS;
            CertType.dwSize        = sizeof( CRYPTUI_WIZ_CERT_TYPE );
            CertType.cCertType     = 1;
            CertType.rgwszCertType = &lpwstr;

            //
            // Fill in the fields of the CertRequest structure
            //

            CertRequest.dwSize                 = sizeof( CRYPTUI_WIZ_CERT_REQUEST_INFO );   // required
            CertRequest.dwPurpose              = CRYPTUI_WIZ_CERT_ENROLL;                   // enroll the certificate
            CertRequest.pwszMachineName        = NULL;
            CertRequest.pwszAccountName        = NULL;
            CertRequest.pAuthentication        = NULL;                                      // must be NULL
            CertRequest.pCertRequestString     = NULL;                                      // Reserved, must be NULL
            CertRequest.pwszDesStore           = NULL;                                      // defaults to MY store
            CertRequest.pszHashAlg             = NULL;
            CertRequest.pRenewCertContext      = NULL;                                      // We're enrolling, not renewing
            CertRequest.dwPvkChoice            = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;   // Create keyset
            CertRequest.pPvkNew                = &NewKeyInfo;
            CertRequest.pwszCALocation         = NULL;
            CertRequest.pwszCAName             = NULL;
            CertRequest.dwPostOption           = 0;
            CertRequest.pCertRequestExtensions = NULL;
            CertRequest.dwCertChoice           = CRYPTUI_WIZ_CERT_REQUEST_CERT_TYPE;
            CertRequest.pCertType              = &CertType;
            CertRequest.pwszCertDNName         = L"CN=EFS";
            CertRequest.pwszFriendlyName       = NULL;                                      // Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose
            CertRequest.pwszDescription        = NULL;                                      // Optional  if CRYPTUI_WIZ_CERT_ENROLL is set in dwPurpose

            DWORD CAdwStatus = 0 ;
            BOOL CryptUiResult ;

            __try {

                CryptUiResult = CryptUIWizCertRequest(
                                       CRYPTUI_WIZ_NO_UI,
                                       NULL,
                                       NULL,
                                       &CertRequest,
                                       &pCertContext,
                                       &CAdwStatus
                                       );
            }

            __except (EXCEPTION_EXECUTE_HANDLER) {

                CryptUiResult = FALSE ;
                SetLastError( GetExceptionCode() );
            }

            if (CryptUiResult)  {

                //
                // Got back success, see if we got a cert back
                //

                if (CAdwStatus == CRYPTUI_WIZ_CERT_REQUEST_STATUS_SUCCEEDED) {

                    //
                    // We got back a valid Cert Context.
                    // Get the hash out of it.
                    //

                    *pbHash = GetCertHashFromCertContext(
                                  pCertContext,
                                  cbHash
                                  );

                    *lpDisplayInfo = EfspGetCertDisplayInformation( pCertContext );

                    if (*pbHash && *lpDisplayInfo) {

                        PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );

                        if (pCryptKeyProvInfo) {

                           //
                           // According to Xiaohong, we always get back container name and provider name here.
                           // There is no need for us to check NULL here.
                           //


                            *lpContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));
                            *lpProviderName =  (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName)      * sizeof( WCHAR ) + sizeof( UNICODE_NULL ));

                            if (*lpContainerName && *lpProviderName) {

                                wcscpy( *lpContainerName, pCryptKeyProvInfo->pwszContainerName );
                                wcscpy( *lpProviderName,  pCryptKeyProvInfo->pwszProvName );

                                if (CryptAcquireContext( hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_SILENT )) {

                                    if (CryptGetUserKey(*hProv, AT_KEYEXCHANGE, hKey)) {

                                        fResult = TRUE;

                                    } else {

                                        rc = GetLastError();

                                    }

                                } else {

                                    rc = GetLastError();
                                }

                            } else {

                                rc = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            LsapFreeLsaHeap( pCryptKeyProvInfo );

                        } else {

                            rc = GetLastError();
                        }

                    } else {

                        rc = GetLastError();
                    }

                   // CertFreeCertificateContext( pCertContext );

                } else {

                    //
                    // We failed.  Get the error. This error will be overwritten in the following code.
                    // It only helps debug for now.
                    //

                    rc = GetLastError(); 
                }

            } else {

                rc = GetLastError();
            }

            if (!fResult) {

                //
                // We failed to get one from the CA.  Issue a self-signed cert.
                //

                //
                // Free the memory allocated above first
                //

                if (*pbHash) {
                    LsapFreeLsaHeap( *pbHash );
                    *pbHash = NULL;
                }
        
                if (*lpDisplayInfo) {
                    LsapFreeLsaHeap( *lpDisplayInfo );
                    *lpDisplayInfo = NULL;
                }
        
                if (*lpContainerName) {
                    LsapFreeLsaHeap( *lpContainerName );
                    *lpContainerName = NULL;
                }
        
                if (*lpProviderName) {
                    LsapFreeLsaHeap( *lpProviderName );
                    *lpProviderName = NULL;
                }

                if (pCertContext) {
                    CertFreeCertificateContext( pCertContext );
                }
        
                if ( *hKey) {
                    CryptDestroyKey( *hKey );
                    *hKey = NULL;
                }
        
                if ( *hProv) {
                    CryptReleaseContext( *hProv, 0 );
                    *hProv = NULL;
                }

                if (EfspCreateSelfSignedCert( hKey,
                                              hProv,
                                              lpContainerName,
                                              lpProviderName,
                                              pEfsUserInfo,
                                              pbHash,
                                              cbHash,
                                              lpDisplayInfo,
                                              &pCertContext
                                              )) {
                    fResult = TRUE;

                } else {

                    rc = GetLastError();
                }
            }

        } else {

            DebugLog((DEB_WARN, "Unable to create auto-enrollment object, error = %x\n" , AutoEnrollSuccess));
            rc = AutoEnrollSuccess;
        }

    } else {

        //
        // It's not a domain account, which means we can't get to the CA.
        // Issue a self-signed cert.
        //

        if (EfspCreateSelfSignedCert( hKey,
                                      hProv,
                                      lpContainerName,
                                      lpProviderName,
                                      pEfsUserInfo,
                                      pbHash,
                                      cbHash,
                                      lpDisplayInfo,
                                      &pCertContext
                                      )) {
            fResult = TRUE;

        } else {

            rc = GetLastError();
        }
    }

    //
    // Let's add this cert to the local store
    //

    if (fResult) {
        rc  = EfsAddCertToTrustStoreStore(
                    pCertContext,
                    &ImpersonationError
                    );

        if ( ERROR_SUCCESS != rc ) {

            DebugLog((DEB_ERROR, "Failed to add the cert to LM CA store, error = %x\n" , rc));
            if (ImpersonationError) {

                //
                // We got serious error. We reverted but could not impersonate back.
                // Quit the procedure. This should not happen.
                //

                DebugLog((DEB_ERROR, "Failed to impersonate after revert.\n"));
                fResult = FALSE;

            } else {

                //
                // Fail to add the cert to the store should not prevent us continue.
                //

                rc = ERROR_SUCCESS;
            }
        } else {

            //
            //  Let's update the registry. This is the best effort. No need to see if succeed or not.
            //

            EfsMarkCertAddedToStore(pEfsUserInfo);

        }
    }



    //
    //  Now check if we need create the cache
    //

    //
    // Create the cache node.
    // We could have a cache node which is not validated or no cache at all.
    // We could also have a valid cache but was not allowed to use since it
    // is being freed.
    //

    if (fResult && !pEfsUserInfo->UserCacheStop) {

        //
        // Cache is allowed now
        //

        if (!pEfsUserInfo->pUserCache || (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED)) {

            //
            // Let's create the cache
            //

            PUSER_CACHE pCacheNode;

            pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));

            if (pCacheNode) {

                memset( pCacheNode, 0, sizeof( USER_CACHE ));

                if (NT_SUCCESS( NtQuerySystemTime(&(pCacheNode->TimeStamp)))){

                    if (EfspInitUserCacheNode(
                                 pCacheNode,
                                 *pbHash,
                                 *cbHash,
                                 *lpContainerName,
                                 *lpProviderName,
                                 *lpDisplayInfo,
                                 pCertContext,
                                 *hKey,
                                 *hProv,
                                 &(pEfsUserInfo->AuthId),
                                 CERT_VALIDATED
                                 )){

                        //
                        //  Cache node created and ready for use. Do not delete or close the info
                        //  we just got.
                        //

                        *lpContainerName = NULL;
                        *lpProviderName = NULL;
                        *lpDisplayInfo = NULL;
                        *pbHash = NULL;
                        *cbHash = NULL;
                        *hProv = NULL;
                        *hKey = NULL;

                        if (pEfsUserInfo->pUserCache) {

                            //
                            // We had a not validated cache
                            //

                            EfspReleaseUserCache(pEfsUserInfo->pUserCache);

                        }

                        pEfsUserInfo->pUserCache = pCacheNode;

                        pCertContext = NULL; 

                    } else {

                        LsapFreeLsaHeap(pCacheNode);
                        pCacheNode = NULL;

                    }

                } else {

                    LsapFreeLsaHeap(pCacheNode);
                    pCacheNode = NULL;

                }

            }
        }

        //
        // Even if cache failed to create, but we can proceed without cache
        //

    }

    if (pCertContext) {
        CertFreeCertificateContext( pCertContext );
        pCertContext = NULL;
    }

    if (!fResult) {

        //
        // Something failed, free all the OUT parameters
        // that were allocated.
        //

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*lpDisplayInfo) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*lpContainerName) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*lpProviderName) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if ( *hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if ( *hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }
    }

    SetLastError( rc );

    return ( fResult );
}


BOOL
EfspCreateSelfSignedCert(
    OUT HCRYPTKEY  * hKey,
    OUT HCRYPTPROV * hProv,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash,
    OUT LPWSTR     * lpDisplayInfo,
    OUT PCCERT_CONTEXT *pCertContext
    )
/*++

Routine Description:

    This routine sets up and creates a self-signed certificate.

Arguments:

    lpContainerName - Returns the container name of the new certificate.

    lpProviderName - Returns the provider name of the new certificate.

    pbHash - Returns the hash of the new certificate.

    cbHash - Returns the length in bytes of the new certificate hash.

    lpDisplayInfo - Returns the display string for the new certificate.

Return Value:

    TRUE on success, FALSE on failure.  Call GetLastError() for more details.

--*/

{
    BOOL b = FALSE;
    DWORD rc = ERROR_SUCCESS;
    //
    // Initialize OUT parameters
    //

    *lpContainerName = NULL;
    *lpProviderName  = NULL;
    *pbHash          = NULL;
    *lpDisplayInfo   = NULL;
    *pCertContext    = NULL;

    *hKey            = NULL;
    *hProv           = NULL;

    //
    // Croft up a key pair
    //

    //
    // Container name
    //

    GUID    guidContainerName;

    UuidCreate(&guidContainerName);

    LPWSTR TmpContainerName;

    if (ERROR_SUCCESS == UuidToStringW(&guidContainerName, &TmpContainerName )) {

        //
        // Copy the container name into LSA heap memory
        //

        *lpContainerName = (LPWSTR)LsapAllocateLsaHeap( (wcslen( TmpContainerName ) + 1) * sizeof( WCHAR ) );

        if (*lpContainerName) {

            wcscpy( *lpContainerName, TmpContainerName );

            *lpProviderName = (PWCHAR)LsapAllocateLsaHeap( (wcslen( MS_DEF_PROV ) + 1) * sizeof( WCHAR ) );

            if (*lpProviderName == NULL) {

                rc = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                wcscpy( *lpProviderName, MS_DEF_PROV );

                //
                // Create the key container
                //

                if (CryptAcquireContext(hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_NEWKEYSET | CRYPT_SILENT )) {

                    if (CryptGenKey(*hProv, AT_KEYEXCHANGE, RSA1024BIT_KEY | CRYPT_EXPORTABLE, hKey)) {

                        //
                        // Construct the subject name information
                        //

                        LPWSTR UPNName = NULL;
                        LPWSTR SubName = NULL;

                        //*lpDisplayInfo = MakeDNName( FALSE, pEfsUserInfo);
                        rc = EfsMakeCertNames(
                                    pEfsUserInfo,
                                    lpDisplayInfo,
                                    &SubName,
                                    &UPNName
                                    );

                        if (ERROR_SUCCESS == rc) {

                            //
                            // Use this piece of code to create the PCERT_NAME_BLOB going into CertCreateSelfSignCertificate()
                            //

                            CERT_NAME_BLOB SubjectName;

                            SubjectName.cbData = 0;

                            if(CertStrToNameW(
                                   CRYPT_ASN_ENCODING,
                                   SubName,
                                   0,
                                   NULL,
                                   NULL,
                                   &SubjectName.cbData,
                                   NULL)) {

                                SubjectName.pbData = (BYTE *) LsapAllocateLsaHeap(SubjectName.cbData);

                                if (SubjectName.pbData) {

                                    if (CertStrToNameW(
                                            CRYPT_ASN_ENCODING,
                                            SubName,
                                            0,
                                            NULL,
                                            SubjectName.pbData,
                                            &SubjectName.cbData,
                                            NULL) ) {

                                        //
                                        //  Make the UPN Name
                                        //

                                        PCERT_EXTENSION altNameExt = NULL;


                                        if (EfsGetAltNameExt(&altNameExt, UPNName)) {

                                            //
                                            // Make the basic restrain extension
                                            //

                                            PCERT_EXTENSION basicRestraint = NULL;

                                            if (EfsGetBasicConstraintExt(&basicRestraint)) {

                                                //
                                                // Make the enhanced key usage
                                                //
        
                                                CERT_ENHKEY_USAGE certEnhKeyUsage;
                                                LPSTR lpstr;
                                                CERT_EXTENSION certExt[3];
        
                                                lpstr = szOID_EFS_CRYPTO;
                                                certEnhKeyUsage.cUsageIdentifier = 1;
                                                certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;
        
                                                // now call CryptEncodeObject to encode the enhanced key usage into the extension struct
        
                                                certExt[0].Value.cbData = 0;
                                                certExt[0].Value.pbData = NULL;
                                                certExt[0].fCritical = FALSE;
                                                certExt[0].pszObjId = szOID_ENHANCED_KEY_USAGE;
        
                                                //
                                                // Encode it
                                                //
        
                                                if (EncodeAndAlloc(
                                                        CRYPT_ASN_ENCODING,
                                                        X509_ENHANCED_KEY_USAGE,
                                                        &certEnhKeyUsage,
                                                        &certExt[0].Value.pbData,
                                                        &certExt[0].Value.cbData
                                                        )) {
        
                                                    //
                                                    // finally, set up the array of extensions in the certInfo struct
                                                    // any further extensions need to be added to this array.
                                                    //
        
                                                    CERT_EXTENSIONS certExts;
        
                                                    certExts.cExtension = sizeof(certExt) / sizeof(CERT_EXTENSION);
                                                    certExts.rgExtension = &certExt[0];
                                                    certExt[1] = *altNameExt;
                                                    certExt[2] = *basicRestraint;
        
                                                    CRYPT_KEY_PROV_INFO KeyProvInfo;
        
                                                    memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));
        
                                                    KeyProvInfo.pwszContainerName = *lpContainerName;
                                                    KeyProvInfo.pwszProvName      = *lpProviderName;
                                                    KeyProvInfo.dwProvType        = PROV_RSA_FULL;
                                                    KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;
        
                                                    //
                                                    // Make the expiration time very very long (100 years)
                                                    //
        
                                                    SYSTEMTIME  StartTime;
                                                    FILETIME    FileTime;
                                                    LARGE_INTEGER TimeData;
                                                    SYSTEMTIME  EndTime;
        
                                                    GetSystemTime(&StartTime);
                                                    SystemTimeToFileTime(&StartTime, &FileTime);
                                                    TimeData.LowPart = FileTime.dwLowDateTime; 
                                                    TimeData.HighPart = (LONG) FileTime.dwHighDateTime;
                
                                                    TimeData.QuadPart += YEARCOUNT * 100;
                                                    FileTime.dwLowDateTime = TimeData.LowPart;
                                                    FileTime.dwHighDateTime = (DWORD) TimeData.HighPart; 
                
                                                    FileTimeToSystemTime(&FileTime, &EndTime);
        
                                                    *pCertContext = CertCreateSelfSignCertificate(
                                                                       *hProv,
                                                                       &SubjectName,
                                                                       0,
                                                                       &KeyProvInfo,
                                                                       NULL,
                                                                       &StartTime,
                                                                       &EndTime,
                                                                       &certExts
                                                                       );
        
                                                    if (*pCertContext) {
        
                                                        *pbHash = GetCertHashFromCertContext(
                                                                      *pCertContext,
                                                                      cbHash
                                                                      );
        
                                                        if (*pbHash) {
        
                                                            HCERTSTORE hStore;
        
                                                            // hStore = CertOpenSystemStoreW( NULL, L"MY" );
                                                            hStore = CertOpenStore(
                                                                                CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                                                                                0,       // dwEncodingType
                                                                                0,       // hCryptProv,
                                                                                CERT_SYSTEM_STORE_CURRENT_USER,
                                                                                L"My"
                                                                                );
        
                                                            if (hStore) {
        
                                                                //
                                                                // save the temp cert
                                                                //
        
                                                                if(CertAddCertificateContextToStore(
                                                                       hStore,
                                                                       *pCertContext,
                                                                       CERT_STORE_ADD_NEW,
                                                                       NULL) ) {
        
                                                                    b = TRUE;
        
                                                                } else {
        
                                                                    rc = GetLastError();
                                                                }
        
                                                                CertCloseStore( hStore, 0 );
        
                                                            } else {
        
                                                                rc = GetLastError();
                                                            }
        
                                                        } else {
        
                                                            rc = GetLastError();
                                                        }
        
        
                                                    } else {
        
                                                        rc = GetLastError();
                                                    }
        
                                                    LsapFreeLsaHeap( certExt[0].Value.pbData );
        
                                                } else {
        
                                                    rc = GetLastError();
                                                }
    
                                                LsapFreeLsaHeap(basicRestraint->Value.pbData);
                                                LsapFreeLsaHeap(basicRestraint);

                                            } else {

                                                rc = GetLastError();

                                            }

                                            LsapFreeLsaHeap(altNameExt->Value.pbData);
                                            LsapFreeLsaHeap(altNameExt);
                                                
                                        } else {

                                            rc = GetLastError();

                                        }


                                    } else {

                                        rc = GetLastError();
                                    }

                                    LsapFreeLsaHeap( SubjectName.pbData );

                                } else {

                                    rc = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            } else {

                                rc = GetLastError();

                            }

                        }

                        LsapFreeLsaHeap(UPNName);
                        LsapFreeLsaHeap(SubName);

                    } else {

                        //
                        // We create the container but failed to get the keys. We need to
                        // clean up the useless container here.
                        //

                        rc = GetLastError();
                        CryptReleaseContext( *hProv, 0 );
                        CryptAcquireContext(hProv, *lpContainerName, *lpProviderName, PROV_RSA_FULL, CRYPT_DELETEKEYSET | CRYPT_SILENT );

                        //
                        // No need to call CryptReleaseContext any more.
                        //

                        *hProv = NULL;

                    }

                } else {

                    rc = GetLastError();
                }
            }

        } else {

            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

        RpcStringFree( &TmpContainerName );

    } else {

        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!b) {

        //
        // Something failed, clean up whatever we allocated
        //

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (*lpDisplayInfo) {
            LsapFreeLsaHeap( *lpDisplayInfo );
            *lpDisplayInfo = NULL;
        }

        if (*lpContainerName) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*lpProviderName) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if ( *pCertContext ) {

            CertFreeCertificateContext( *pCertContext );
            *pCertContext = NULL;

        }

        if (*hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if (*hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }
    }

    SetLastError( rc );

    return( b );
}

DWORD
GenerateUserKey (
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * lpContainerName,
    OUT LPWSTR     * lpProviderName,
    OUT PDWORD       ProviderType,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )
/*++

Routine Description:

    This routine will construct a default user key for the current user
    and install it in the registry.  The constructed key takes the form

    <UserName>_<MachineName>_EFS_<i>

    Where i is increased as necessary to construct a valid key name.

Arguments:

    hKey - Optionally returns a handle to the new key.  This key must
        be destroyed by the caller via CryptDestroyKey().

    hProv - Optionally returns a handle to the provider of the new key.
        This handle must be closed by the user via CryptReleaseContext().

    lpContainerName - Returns a pointer to the name of the new key.  This
        buffer must be freed via LsapFreeHeap().

    lpProviderName - Returns a pointer to the provider of the new key.  This
        buffer must be freed via LsapFreeHeap().

    ProviderType - Returns the type of the provider of the new key.

    pbHash - Returns a pointer to the certificate hash for this key.

    cbHash - Returns the size fo the pbHash buffer.

Return Value:

    ERROR_SUCCESS for succeed.
    
--*/

{
    BOOL       fSuccess      = FALSE;

    DWORD      Disposition   = 0;
    DWORD      dwDataLength  = 0;

    HCRYPTKEY  LocalhKey     = 0;
    HCRYPTPROV LocalhProv    = 0;

    HKEY       KeyHandle     = NULL;

    LONG       rc            = ERROR_SUCCESS;

    //
    // Initialize our output parameters
    //

    *ProviderType    = PROV_RSA_FULL;
    *lpProviderName  = NULL;
    *lpContainerName = NULL;
    *DisplayInfo     = NULL;
    *pbHash          = NULL;

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    //
    // Use the user name as a mutex name to synchronize access to the following
    // code.  This way we don't hang up every thread to come through here, only
    // ones from this user.
    //

    HANDLE hMutex = CreateMutex( NULL, TRUE, pEfsUserInfo->lpUserName );

    if (hMutex != NULL) {

        if (GetLastError() == ERROR_SUCCESS) {

            //
            // If we're here, we have the mutex, so we can proceed.
            //
            // Note that it is possible for some other thread to have
            // come through here and created keys for the user while
            // we were busy doing all of this.  We will attempt to create
            // the registry key where we will store the key information,
            // and if it's already there, we will assume that someone
            // came in and did all this while we were on our way.
            //

            //
            // Create the registry path, if it does not already exist.
            //

            rc = RegCreateKeyEx( KEYPATHROOT,
                                 pEfsUserInfo->lpKeyPath,
                                 0,
                                 TEXT("REG_SZ"),
                                 REG_OPTION_NON_VOLATILE,
                                 KEY_READ | KEY_WRITE,
                                 NULL,
                                 &KeyHandle,
                                 &Disposition
                                 );


            if (rc == ERROR_SUCCESS) {

                //
                // The key didn't exist.  Create a cert
                //

                if (EnrollKeyPair( pEfsUserInfo,
                                   &LocalhKey,
                                   &LocalhProv,
                                   lpContainerName,
                                   lpProviderName,
                                   PROV_RSA_FULL,
                                   pbHash,
                                   cbHash,
                                   DisplayInfo
                                   )) {

                    PBYTE      pbLocalHash;
                    DWORD      cbLocalHash;

                    //
                    // Write the hash value to the registry
                    //

                    if (*pbHash) {
                        pbLocalHash = *pbHash;
                        cbLocalHash = *cbHash;
                    } else {

                        ASSERT(pEfsUserInfo->pUserCache);

                        pbLocalHash = pEfsUserInfo->pUserCache->pbHash;
                        cbLocalHash = pEfsUserInfo->pUserCache->cbHash;

                    }

                    rc = RegSetValueEx(
                              KeyHandle,  // handle of key to set value for
                              CERT_HASH,
                              0,
                              REG_BINARY,
                              pbLocalHash,
                              cbLocalHash
                              );

                    if (rc == ERROR_SUCCESS) {

                        //
                        // Mark entire operation as successful
                        //

                        fSuccess = TRUE;
                    }

                } else {

                    rc = GetLastError();
                }

                RegCloseKey( KeyHandle );

            } else {

                KeyHandle = NULL; // paranoia

                //
                // We couldn't create the registry key for some reason,
                // fail the entire operation.
                //
            }

        } else {

            if (GetLastError() == ERROR_ALREADY_EXISTS) {

                DebugLog((DEB_TRACE_EFS, "KeyGen mutex %ws exists\n", pEfsUserInfo->lpUserName   ));

                //
                // Some other thread is in here trying to create the keys.
                // Wait on this mutex, and assume that once we come back,
                // the other thread is done and we can just leave and
                // try to get the keys again.
                //

                WaitForSingleObject( hMutex, INFINITE );

            } else {

                //
                // If we're here, then CreateMutex did not fail, but GetLastError is
                // set to something other than success or ERROR_ALREADY_EXISTS.  Is
                // this an error?
                //

                ASSERT(FALSE);
            }

            rc = ERROR_RETRY;
        }

        DebugLog((DEB_TRACE_EFS, "Closing mutex handle\n"   ));

        ReleaseMutex( hMutex );
        CloseHandle( hMutex );

    } else {

        DebugLog((DEB_ERROR, "CreateMutex failed, error = %x\n", GetLastError()    ));
        rc = GetLastError();
    }


    if (fSuccess) {

        //
        // Return these to the caller
        //

        if (ARGUMENT_PRESENT( hKey ) && ARGUMENT_PRESENT( hProv )) {

            //
            // If the caller passed this in, he wants
            // the key and provider passed back
            //

            *hKey = LocalhKey;
            *hProv = LocalhProv;

        } else {

            if ( LocalhKey ) {
                CryptDestroyKey( LocalhKey );
            }

            if ( LocalhProv ) {
                CryptReleaseContext( LocalhProv, 0 );
            }

        }

    } else {

        //
        // We failed somewhere, free what we were going
        // to return.
        //

        if (*lpProviderName != NULL) {
            LsapFreeLsaHeap( *lpProviderName );
            *lpProviderName = NULL;
        }

        if (*lpContainerName != NULL) {
            LsapFreeLsaHeap( *lpContainerName );
            *lpContainerName = NULL;
        }

        if (*DisplayInfo != NULL) {
            LsapFreeLsaHeap( *DisplayInfo );
            *DisplayInfo = NULL;
        }

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (LocalhKey != 0) {
            CryptDestroyKey( LocalhKey );
        }

        if (LocalhProv != 0) {
            CryptReleaseContext(LocalhProv, 0);
        }

    }

    return( rc );
}


BOOL
EqualCertPublicKeys(
    PCERT_PUBLIC_KEY_INFO pKey1,
    PCERT_PUBLIC_KEY_INFO pKey2
    )

/*++

Routine Description:

    Helper routine to compare the public key portions of two certificates.

Arguments:

    pKey1 - One of the public key info structures.

    pKey2 - The other one.


Return Value:

    TRUE on match, FALSE on failure.

--*/
{

    CRYPT_BIT_BLOB * PublicKey1 = &pKey1->PublicKey;
    CRYPT_BIT_BLOB * PublicKey2 = &pKey2->PublicKey;

    if (PublicKey1->cbData == PublicKey2->cbData) {

        if (memcmp(PublicKey1->pbData, PublicKey2->pbData, PublicKey2->cbData) == 0) {
            return( TRUE );
        }
    }

    return( FALSE );
}


LONG
SearchMyStoreForEFSCert(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD rc = ERROR_NO_USER_KEYS;
    HKEY hRegKey;
    DWORD Disposition = 0;
    HCRYPTPROV hLocalProv = NULL;
    NTSTATUS status;

    //
    // Initialize required return values.
    //

    *ProviderName = NULL;
    *ContainerName = NULL;
    *DisplayInfo = NULL;
    *pbHash = NULL;
    *cbHash = 0;

    //
    // Initialize optional return values
    //

    if (ARGUMENT_PRESENT(hKey)) {
        *hKey = NULL;
    }

    if (ARGUMENT_PRESENT(hProv)) {
        *hProv = NULL;
    }

    //
    // Assume that there's no current EFS information
    // for this guy.  Create the registry key.
    //

    rc = RegCreateKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             TEXT("REG_SZ"),
             REG_OPTION_NON_VOLATILE,
             KEY_ALL_ACCESS,
             NULL,
             &hRegKey,
             &Disposition    // address of disposition value buffer
             );

    //
    // Open up the user's MY store and see if there's an EFS
    // certificate floating around in there somewhere.
    //

    if (rc == ERROR_SUCCESS) {

        CERT_ENHKEY_USAGE certEnhKeyUsage;

        LPSTR lpstr = szOID_EFS_CRYPTO;
        certEnhKeyUsage.cUsageIdentifier = 1;
        certEnhKeyUsage.rgpszUsageIdentifier  = &lpstr;

        PCCERT_CONTEXT pCertContext = NULL;

        //
        // If this fails, there's no cert that matches.
        //

        HCERTSTORE hStore = CertOpenStore(
                            CERT_STORE_PROV_SYSTEM_REGISTRY_W,
                            0,       // dwEncodingType
                            0,       // hCryptProv,
                            CERT_SYSTEM_STORE_CURRENT_USER,
                            L"My"
                            );

        // hStore = CertOpenSystemStoreW( NULL, L"MY");

        if (hStore) {

            do {

                //
                // This will go to success if everything works...
                //

                rc = ERROR_NO_USER_KEYS;

                pCertContext = CertFindCertificateInStore(
                                   hStore,
                                   X509_ASN_ENCODING,
                                   0, //CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                   CERT_FIND_ENHKEY_USAGE,
                                   &certEnhKeyUsage,
                                   pCertContext
                                   );

                if (pCertContext) {

                    DebugLog((DEB_TRACE_EFS, "Found matching cert in MY store\n"   ));

                    //
                    // Do cert validity checking.
                    //


                    if ( CertVerifyTimeValidity(
                            NULL,
                            pCertContext->pCertInfo
                            )){

                        rc = CERT_E_EXPIRED;

                    } else {

                        //
                        // Test the cert usage here.
                        // CERT_E_WRONG_USAGE
                        //

                        BOOL OidFound;
                        

                        rc = EfsFindCertOid(
                                szOID_KP_EFS,
                                pCertContext,
                                &OidFound
                                );

                        if (ERROR_SUCCESS == rc) {

                            rc = ERROR_NO_USER_KEYS;

                            if (OidFound) {

                                *pbHash = GetCertHashFromCertContext(
                                              pCertContext,
                                              cbHash
                                              );
    
                                if (*pbHash) {
    
                                    //
                                    // See if we can get container and provider info.
                                    //
                                    // Once we've got them, make sure we can call CryptAcquireContext
                                    // and have it work.  That guarantees there's a private key available.
                                    //
    
                                    PCRYPT_KEY_PROV_INFO pCryptKeyProvInfo = GetKeyProvInfo( pCertContext );
    
                                    if (pCryptKeyProvInfo) {
    
                                        if (!wcscmp(pCryptKeyProvInfo->pwszProvName, MS_DEF_PROV_W) ||
                                            !wcscmp(pCryptKeyProvInfo->pwszProvName, MS_ENHANCED_PROV_W) ||
                                            !wcscmp(pCryptKeyProvInfo->pwszProvName, MS_STRONG_PROV_W)) {
    
                                            if (CryptAcquireContext(
                                                    &hLocalProv,
                                                    pCryptKeyProvInfo->pwszContainerName,
                                                    pCryptKeyProvInfo->pwszProvName,
                                                    pCryptKeyProvInfo->dwProvType,
                                                    pCryptKeyProvInfo->dwFlags | CRYPT_SILENT
                                                    )) {
        
                                                //
                                                // Make sure the public key in the cert matches the one
                                                // that's in this context.
                                                //
        
                                                DWORD cbPubKeyInfo = 0;
        
                                                PCERT_PUBLIC_KEY_INFO pPubKeyInfo = ExportPublicKeyInfo(
                                                                                        hLocalProv,
                                                                                        pCryptKeyProvInfo->dwKeySpec,
                                                                                        X509_ASN_ENCODING,
                                                                                        &cbPubKeyInfo
                                                                                        );
        
                                                if (pPubKeyInfo) {
        
                                                    //
                                                    // Get the public key from the cert context
                                                    //
        
                                                    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
                                                    PCERT_PUBLIC_KEY_INFO pSubjectPublicKeyInfo = &pCertInfo->SubjectPublicKeyInfo;
        
                                                    if (EqualCertPublicKeys( pPubKeyInfo, pSubjectPublicKeyInfo )) {
        
                                                        //
                                                        // They match.  We want to make sure not to return
                                                        // an error indicating that we didn't find a key.
                                                        // The next call will reset the value of rc
                                                        //
        
                                                        rc = RegSetValueEx(
                                                                hRegKey,  // handle of key to set value for
                                                                CERT_HASH,
                                                                0,
                                                                REG_BINARY,
                                                                *pbHash,
                                                                *cbHash
                                                                );
        
                                                        if (rc == ERROR_SUCCESS) {
        
                                                            if (pCryptKeyProvInfo->pwszProvName) {
                                                               *ProviderName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszProvName) * sizeof( WCHAR ) + sizeof(L'\0') );
                                                               if (*ProviderName) {
                                                                  wcscpy( *ProviderName, pCryptKeyProvInfo->pwszProvName );
                                                               } else {
                                                                  rc = ERROR_NOT_ENOUGH_MEMORY;
                                                               }
                                                            }
                                                            if (pCryptKeyProvInfo->pwszContainerName) {
                                                               *ContainerName = (LPWSTR)LsapAllocateLsaHeap( wcslen(pCryptKeyProvInfo->pwszContainerName) * sizeof( WCHAR ) + sizeof(L'\0') );
                                                               if (*ContainerName) {
                                                                  wcscpy( *ContainerName, pCryptKeyProvInfo->pwszContainerName );
                                                               } else {
                                                                  rc = ERROR_NOT_ENOUGH_MEMORY;
                                                               }
                                                            }
        
                                                            if (rc == ERROR_SUCCESS) {
           
                                                               if (!(*DisplayInfo = EfspGetCertDisplayInformation( pCertContext ))) {
           
                                                                   //
                                                                   // At least for now, we do not accept Cert without display name
                                                                   //
                                                                   rc = GetLastError();
           
                                                               }
                                                            }
    
                                                            //
                                                            // Create the cache node.
                                                            // We could have a cache node which is not validated or no cache at all.
                                                            // We could also have a valid cache but was not allowed to use since it
                                                            // is being freed.
                                                            //
    
                                                            if ((rc == ERROR_SUCCESS) && !pEfsUserInfo->UserCacheStop) {
    
                                                                //
                                                                // Cache is allowed now
                                                                //
    
                                                                if (!pEfsUserInfo->pUserCache || (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED)) {
    
                                                                    //
                                                                    // Let's create the cache
                                                                    //
    
                                                                    PUSER_CACHE pCacheNode;
                                            
                                                                    pCacheNode = (PUSER_CACHE) LsapAllocateLsaHeap(sizeof(USER_CACHE));
                                            
                                                                    if (pCacheNode) {
                                            
                                                                        memset( pCacheNode, 0, sizeof( USER_CACHE ));
                                                                                    
                                                                        if (NT_SUCCESS( status = NtQuerySystemTime(&(pCacheNode->TimeStamp)))){
    
                                                                            HCRYPTKEY  hLocalKey;
                                            
                                                                            if (CryptGetUserKey( hLocalProv, AT_KEYEXCHANGE, &hLocalKey )){
    
                                                                                if (EfspInitUserCacheNode(
                                                                                             pCacheNode,
                                                                                             *pbHash,
                                                                                             *cbHash,
                                                                                             *ContainerName,
                                                                                             *ProviderName,
                                                                                             *DisplayInfo,
                                                                                             pCertContext,
                                                                                             hLocalKey,
                                                                                             hLocalProv,
                                                                                             &(pEfsUserInfo->AuthId),
                                                                                             CERT_VALIDATED
                                                                                             )){
                                                
                                                                                    //
                                                                                    //  Cache node created and ready for use. Do not delete or close the info
                                                                                    //  we just got.
                                                                                    //
                                                
                                                                                    *ContainerName = NULL;
                                                                                    *ProviderName = NULL;
                                                                                    *DisplayInfo = NULL;
                                                                                    *pbHash = NULL;
                                                                                    *cbHash = NULL;
                                                                                    hLocalProv = NULL;
        
                                                                                    if (pEfsUserInfo->pUserCache) {
        
                                                                                        //
                                                                                        // We had a not validated cache
                                                                                        //
        
                                                                                        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
        
                                                                                    }
        
                                                                                    pEfsUserInfo->pUserCache = pCacheNode;
                                                
                                                                                    pCertContext = NULL; 
                                                
                                                                                } else {
        
                                                                                    if (hLocalKey) {
                                                                                        CryptDestroyKey( hLocalKey );
                                                                                    }
                                                
                                                                                    LsapFreeLsaHeap(pCacheNode);
                                                                                    pCacheNode = NULL;
                                                
                                                                                }
                                                                            } else {
    
                                                                                rc = GetLastError();
                                                                                LsapFreeLsaHeap(pCacheNode);
                                                                                pCacheNode = NULL;
    
                                                                            }
                                                
                                                                        } else {
                                            
                                                                            rc = RtlNtStatusToDosError( status );
                                                                            LsapFreeLsaHeap(pCacheNode);
                                                                            pCacheNode = NULL;
                                            
                                                                        }
                                                
                                                                    }                                                                
    
                                                                }
    
                                                            }
    
                                                        }
        
                                                    } else {
        
                                                        rc = ERROR_NO_USER_KEYS;
                                                    }
        
                                                    LsapFreeLsaHeap( pPubKeyInfo );
                                                }
                                            }
                                        }
    
                                        LsapFreeLsaHeap( pCryptKeyProvInfo );
                                    }
    
                                    if (rc != ERROR_SUCCESS) {
                                        LsapFreeLsaHeap( *pbHash );
                                        *pbHash = NULL;
                                    }
    
                                } else {
    
                                    //
                                    // If we failed for any reason other than running
                                    // out of memory, assume that there is no key of
                                    // use to us and return an appropriate error.
                                    //
    
                                    rc = GetLastError();
                                }
                            }

                        }                        
                    }

                }

                //
                // We want to keep trying until we're out of certificates or we get
                // an unexpected error (like out of memory).
                //

                if (rc != ERROR_SUCCESS) {

                    //
                    // Something failed, clean up anything we allocated that
                    // we were going to return.
                    //

                    if (*ProviderName) {
                        LsapFreeLsaHeap( *ProviderName );
                        *ProviderName = NULL;
                    }

                    if (*ContainerName) {
                        LsapFreeLsaHeap( *ContainerName );
                        *ContainerName = NULL;
                    }

                    if (*DisplayInfo) {
                        LsapFreeLsaHeap( *DisplayInfo );
                        *DisplayInfo = NULL;
                    }

                    if (*pbHash) {
                        LsapFreeLsaHeap( *pbHash );
                        *pbHash = NULL;
                    }

                    if (hLocalProv) {
                        CryptReleaseContext( hLocalProv, 0 );
                        hLocalProv = NULL;
                    }
                }

            } while ( pCertContext && rc != ERROR_SUCCESS );

            if (pCertContext) {
                CertFreeCertificateContext( pCertContext );
            }

            CertCloseStore( hStore, 0 );

            if (ARGUMENT_PRESENT(hKey) && ARGUMENT_PRESENT(hProv) && (rc == ERROR_SUCCESS) && (*pbHash)) {

                *hProv = hLocalProv;
                CryptGetUserKey( *hProv, AT_KEYEXCHANGE, hKey );

            } else {

                if (hLocalProv) {
                    CryptReleaseContext( hLocalProv, 0 );
                }
            }

        } else {

            //
            // If we couldn't open the store, return
            // no user keys and continue.
            //

            rc = ERROR_NO_USER_KEYS;

        }

        RegCloseKey( hRegKey );
    }

    return( rc );
}


LONG
GetInfoFromCertHash(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY  * hKey       OPTIONAL,
    OUT HCRYPTPROV * hProv      OPTIONAL,
    OUT LPWSTR     * ContainerName,
    OUT LPWSTR     * ProviderName,
    OUT LPWSTR     * DisplayInfo,
    OUT PBYTE      * pbHash,
    OUT PDWORD       cbHash
    )

/*++

Routine Description:

    This routine will query the cert hash from the registry for this user and
    return the useful information from the corresponding cert.

Arguments:

    KeyPath - Supplies the fully formed path to the user's EFS key.

    hKey - Optionally returns a handle to a key context.

    hProv - Optionally returns a handle to a provider context.

    ContainerName - Returns the name of the key container for this key.

    ProviderName - Returns the name of the provider for this key.

    DisplayInfo - Returns the display information from this certificate.

    pbHash - Returns the hash found in the registry.

    cbHash - Returns the size of the hash in bytes.

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    DWORD rc;
    HKEY hRegKey = NULL;
    BOOLEAN bIsValid = TRUE;

    //
    // Initialize non-optional parameters
    //

    *ProviderName = NULL;
    *ContainerName = NULL;
    *DisplayInfo = NULL;
    *pbHash = NULL;
    *cbHash = 0;

    //
    // Initialize optional parameters
    //

    if (hKey) {
        *hKey = NULL;
    }

    if (hProv) {
        *hProv = NULL;
    }

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ | KEY_SET_VALUE,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

    /* It is time to close this.
        (VOID) RegSetValueEx(
                   hRegKey,  // handle of key to set value for
                   TEXT("EfsInUse"),
                   0,
                   REG_BINARY,
                   NULL,
                   0
                   );
    */


        //
        // If there's a certificate thumbprint there, get it and use it.
        //

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                cbHash
                );

        if (rc == ERROR_SUCCESS) {

            //
            // Query out the thumbprint, find the cert, and return the key information.
            //

            if (*pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash )) {

                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        *pbHash,
                        cbHash
                        );

                if (rc == ERROR_SUCCESS) {

                    rc = GetKeyInfoFromCertHash(
                            pEfsUserInfo,
                            *pbHash,
                            *cbHash,
                            hKey,
                            hProv,
                            ContainerName,
                            ProviderName,
                            DisplayInfo,
                            &bIsValid
                            );

                    if (((*hKey == NULL) && (pEfsUserInfo->pUserCache) && (pEfsUserInfo->pUserCache->CertValidated != CERT_VALIDATED))
                        || !bIsValid) {

                        rc = ERROR_NO_USER_KEYS;
                    }
                    if ((rc == ERROR_SUCCESS) && (*hKey == NULL)) {

                        //
                        // The key in the cache is current. Free the pbHash
                        //

                        if (*pbHash) {
                            LsapFreeLsaHeap( *pbHash );
                            *pbHash = NULL;
                        }

                    }
                }

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        }

        RegCloseKey( hRegKey );
    }

    if (rc != ERROR_SUCCESS) {

        //
        // Something failed, clean up anything we allocated that
        // we were going to return.
        //

        if (*ProviderName) {
            LsapFreeLsaHeap( *ProviderName );
            *ProviderName = NULL;
        }

        if (*ContainerName) {
            LsapFreeLsaHeap( *ContainerName );
            *ContainerName = NULL;
        }

        if (*DisplayInfo) {
            LsapFreeLsaHeap( *DisplayInfo );
            *DisplayInfo = NULL;
        }

        if (*pbHash) {
            LsapFreeLsaHeap( *pbHash );
            *pbHash = NULL;
        }

        if (hKey && *hKey) {
            CryptDestroyKey( *hKey );
            *hKey = NULL;
        }

        if (hProv && *hProv) {
            CryptReleaseContext( *hProv, 0 );
            *hProv = NULL;
        }

        //
        // If anything other out out of memory failed, assume that there are no keys
        // for this user.
        //

        if (rc != ERROR_NOT_ENOUGH_MEMORY) {
            rc = ERROR_NO_USER_KEYS;
        }
    }

    return( rc );
}

LONG
GetCurrentKey(
    IN  PEFS_USER_INFO pEfsUserInfo,
    OUT HCRYPTKEY    * hKey           OPTIONAL,
    OUT HCRYPTPROV   * hProv          OPTIONAL,
    OUT LPWSTR       * ContainerName,
    OUT LPWSTR       * ProviderName,
    OUT PDWORD         ProviderType,
    OUT LPWSTR       * DisplayInfo,
    OUT PBYTE        * pbHash,
    OUT PDWORD         cbHash
    )

/*++

Routine Description:

    This is the top level routine to get the user's current EFS key.
    It will do the following, in order:

    1) Open the registry and attempt to find a certificate hash for
        the user.  If it finds one, it will attempt to find this hash
        in the user's MY store and obtain all the useful information
        with it.

    2) If that fails, it will check to see if there's old key data
        (beta 1 and before) in the registry, and if it finds it, it
        will convert that key data into a certificate and return
        all the needed information.

    3) If that doesn't work, it will search the user's MY store for
        an EFS certificate.  If it finds one, it will install this as
        the user's current EFS key.

    4) If that doesn't work, it will generate a new user key from scratch.

    If that doesn't work, the operation fails.

Arguments:

    hKey - Optionally returns a handle to the user's key.

    hProv - Optionally returns a handle to the user's key's provider.

    ContainerName - Returns the name of the user's key container.

    ProviderName - Returns the name of the user's key provider.

    ProviderType - Returns the type of the provider.

    DisplayInfo - Returns the display information associated with this
        certificate.

    pbHash - Returns the hash of the user's certificate.

    cbHash - Returns the length in bytes of the certificate hash.

Return Value:

    ERROR_SUCCESS or Win32 error.

--*/

{
    DWORD rc;

    //
    // There are four places we can get key information:
    //
    // 1) There's a hash in the registry.  This is the typical
    //    case and the one we're going to try first.
    //
    // 2) Previous stuff left over from the last release of the
    //    system.
    //
    // 3) There's a cert in the user's MY store.
    //
    // 4) There's nothing.
    //

    //
    // First, look for a hash.
    //

    rc = GetInfoFromCertHash(
                 pEfsUserInfo,
                 hKey,
                 hProv,
                 ContainerName,
                 ProviderName,
                 DisplayInfo,
                 pbHash,
                 cbHash
                 );

    if ((ERROR_SUCCESS == rc) && ( NULL == *pbHash)) {

        LARGE_INTEGER  TimeStamp;

        //
        // We are using the cache
        //

        ASSERT( pEfsUserInfo->pUserCache );
        ASSERT( pEfsUserInfo->pUserCache->pCertContext);

        //
        // Check if we need to validate the cert again
        //

        if (NT_SUCCESS( NtQuerySystemTime(&TimeStamp)) && 
            (TimeStamp.QuadPart - pEfsUserInfo->pUserCache->TimeStamp.QuadPart > CACHE_CERT_VALID_TIME )){

            //
            // It is due to check the certificate.
            // Do cert validity checking. 
            //

            LONG IsCertBeingValidated;
    
            IsCertBeingValidated = InterlockedExchange(&UserCertIsValidating, 1);

            if (IsCertBeingValidated != 1) {


                if ( CertVerifyTimeValidity(
                        NULL,
                        pEfsUserInfo->pUserCache->pCertContext->pCertInfo
                        )){

                    rc = ERROR_NO_USER_KEYS;
                    pEfsUserInfo->pUserCache->CertValidated = CERT_NOT_VALIDATED;
                    EfspReleaseUserCache(pEfsUserInfo->pUserCache);
                    pEfsUserInfo->pUserCache = NULL;

                } else {

                    //
                    // Test the cert usage here.
                    // CERT_E_WRONG_USAGE
                    //

                    BOOL OidFound;
                    
                    rc = EfsFindCertOid(
                            szOID_KP_EFS,
                            pEfsUserInfo->pUserCache->pCertContext,
                            &OidFound
                            );

                    if (ERROR_SUCCESS == rc) {
                        if (OidFound) {

                            //
                            //  Reset the time stamp.
                            //  Do I need the sync object to protect this?
                            //  Mixing the high word and low word is not a big problem here.
                            //
        
                            pEfsUserInfo->pUserCache->TimeStamp = TimeStamp;

                        }

                    } else {

                        rc = ERROR_NO_USER_KEYS;
                        pEfsUserInfo->pUserCache->CertValidated = CERT_NOT_VALIDATED;
                        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
                        pEfsUserInfo->pUserCache = NULL;

                    }

                    
                }

                if (IsCertBeingValidated != 1) {

                    InterlockedExchange(&UserCertIsValidating, IsCertBeingValidated);

                }

            }
    
        }


    }

    if (rc == ERROR_NO_USER_KEYS) {

        //
        // That didn't work.  Look for a cert in the
        // user's MY store and use it.
        //

        rc = SearchMyStoreForEFSCert(
                         pEfsUserInfo,
                         hKey,
                         hProv,
                         ContainerName,
                         ProviderName,
                         DisplayInfo,
                         pbHash,
                         cbHash
                         );

        if (rc == ERROR_NO_USER_KEYS) {

            //
            // That didn't work.  Last resort:
            // generate a new keyset for the user.
            //

            rc = GenerateUserKey(
                        pEfsUserInfo,
                        hKey,
                        hProv,
                        ContainerName,
                        ProviderName,
                        ProviderType,
                        DisplayInfo,
                        pbHash,
                        cbHash
                        );

            if (rc == ERROR_RETRY) {

                //
                // There was another thread creating keys.
                // Try one more time to get them.
                // If this fails, fail the entire attempt.
                //

                rc = GetInfoFromCertHash(
                             pEfsUserInfo,
                             hKey,
                             hProv,
                             ContainerName,
                             ProviderName,
                             DisplayInfo,
                             pbHash,
                             cbHash
                             );
            }
        }
    }

    return( rc );
}

NTSTATUS
EfspGetUserName(
    IN OUT PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    This routine is the LSA Server worker routine for the LsaGetUserName
    API.


    WARNING:  This routine allocates memory for its output.  The caller is
    responsible for freeing this memory after use.  See description of the
    Names parameter.

Arguments:

    UserName - Receives name of the current user.

    DomainName - Optionally receives domain name of the current user.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Sids have
            been translated to names.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthorityName = NULL;
    PUNICODE_STRING ProfilePath = NULL;
    PLSAP_LOGON_SESSION LogonSession;
    NTSTATUS Status;


    //
    // Let's see if we're trying to look up the currently logged on
    // user.
    //
    //
    // TokenUserInformation from this call must be freed by calling
    // LsapFreeLsaHeap().
    //

    Status = EfspGetTokenUser( pEfsUserInfo );

    if ( NT_SUCCESS( Status ) ) {

        pEfsUserInfo->lpUserSid = ConvertSidToWideCharString( pEfsUserInfo->pTokenUser->User.Sid );

        if (pEfsUserInfo->lpUserSid) {

            //
            // If the user ID is Anonymous then there is no name and domain in the
            // logon session
            //
    
            if (RtlEqualSid(
                    pEfsUserInfo->pTokenUser->User.Sid,
                    LsapAnonymousSid
                    )) {
    
                DebugLog((DEB_WARN, "Current user is Anonymous\n"   ));
                AccountName = &WellKnownSids[LsapAnonymousSidIndex].Name;
                AuthorityName = &WellKnownSids[LsapAnonymousSidIndex].DomainName;
                ProfilePath = NULL;
    
            } else {
    
                LogonSession = LsapLocateLogonSession ( &(pEfsUserInfo->AuthId) );
    
                //
                // During setup, we may get NULL returned for the logon session.
                //
    
                if (LogonSession != NULL) {
    
                    //
                    // Got a match.  Get the username and domain information
                    // from the LogonId
                    //
    
                    AccountName   = &LogonSession->AccountName;
                    AuthorityName = &LogonSession->AuthorityName;
                    ProfilePath   = &LogonSession->ProfilePath;
    
                    LsapReleaseLogonSession( LogonSession );
    
                } else {
    
                    Status = STATUS_NO_SUCH_LOGON_SESSION;
                }
            }
    
    
            if (Status == STATUS_SUCCESS) {
    
    
                pEfsUserInfo->lpUserName = (PWSTR)LsapAllocateLsaHeap(AccountName->Length + sizeof(UNICODE_NULL));
    
                if (pEfsUserInfo->lpUserName != NULL) {
    
                    memcpy( pEfsUserInfo->lpUserName, AccountName->Buffer, AccountName->Length );
                    (pEfsUserInfo->lpUserName)[AccountName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
    
                    pEfsUserInfo->lpDomainName = (PWSTR)LsapAllocateLsaHeap(AuthorityName->Length + sizeof(UNICODE_NULL));
    
                    if (pEfsUserInfo->lpDomainName != NULL) {
    
                        memcpy( pEfsUserInfo->lpDomainName, AuthorityName->Buffer, AuthorityName->Length );
                        (pEfsUserInfo->lpDomainName)[AuthorityName->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
                    } else {
    
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
    
                    if ((ProfilePath != NULL) && (ProfilePath->Length != 0)) {
    
                        pEfsUserInfo->lpProfilePath = (PWSTR)LsapAllocateLsaHeap(ProfilePath->Length + sizeof(UNICODE_NULL));
    
                        if (pEfsUserInfo->lpProfilePath != NULL) {
    
                            memcpy( pEfsUserInfo->lpProfilePath, ProfilePath->Buffer, ProfilePath->Length );
                            (pEfsUserInfo->lpProfilePath)[ProfilePath->Length/sizeof(WCHAR)] = UNICODE_NULL;
    
                        } else {
    
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                        }
                    }

                    pEfsUserInfo->lpKeyPath = ConstructKeyPath(pEfsUserInfo->lpUserSid);
                    if ( pEfsUserInfo->lpKeyPath == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;

                    }
    
                } else {
    
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        } else {

            Status = STATUS_INSUFFICIENT_RESOURCES;

        }
    } 

    if (!NT_SUCCESS( Status )) {

        //
        // Something failed, clean up what we were going to return
        //

        EfspFreeUserInfo( pEfsUserInfo );
        memset( pEfsUserInfo, 0, sizeof( EFS_USER_INFO ));

    }

    return(Status);
}

DWORD
EfspReplaceUserKeyInformation(
    PEFS_USER_INFO pEfsUserInfo
    )

/*++

Routine Description:

    Forces the regeneration of the user's EFS key.

Arguments:

    None.

Return Value:

    Win32 error or ERROR_SUCCESS

--*/

{
    LPWSTR ProviderName;
    LPWSTR ContainerName;
    LPWSTR DisplayInfo;
    DWORD ProviderType;
    DWORD cbHash;
    PBYTE pbHash;
    DWORD rc;

    if (pEfsUserInfo->pUserCache) {

        //
        // We are going to create a new key. The current cache is going away.
        // We will insert a new cache node in the header.
        //

        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
        pEfsUserInfo->pUserCache = NULL;

    }

    rc = RegDeleteKey(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath
             );

    if (rc == ERROR_SUCCESS) {

        rc = GenerateUserKey(
                    pEfsUserInfo,
                    NULL,
                    NULL,
                    &ContainerName,
                    &ProviderName,
                    &ProviderType,
                    &DisplayInfo,
                    &pbHash,
                    &cbHash
                    );

        if (rc == ERROR_SUCCESS) {

            if (ContainerName) {
                LsapFreeLsaHeap( ContainerName );
            }
            if (ProviderName) {
                LsapFreeLsaHeap( ProviderName );
            }
            if (DisplayInfo) {
                LsapFreeLsaHeap( DisplayInfo );
            }
            if (pbHash) {
                LsapFreeLsaHeap( pbHash );
            }
        }
    }

    return( rc );
}

DWORD
EfspInstallCertAsUserKey(
    PEFS_USER_INFO pEfsUserInfo,
    PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{
    //
    // Find the passed certificate in the user's MY store.
    // If it's not there, we don't use the cert.
    //

    DWORD rc = ERROR_SUCCESS;
    PCCERT_CONTEXT pCertContext;
    DWORD cbHash  = 0;
    PBYTE pbHash;
    BOOLEAN bIsValid;

    //
    // If this fails, there's no cert that matches.
    //


    pCertContext = CertCreateCertificateContext(
                      pEncryptionCertificate->pCertBlob->dwCertEncodingType,
                      pEncryptionCertificate->pCertBlob->pbData,
                      pEncryptionCertificate->pCertBlob->cbData
                      );

    if (pCertContext) {

        if (CertGetCertificateContextProperty(
                pCertContext,
                CERT_SHA1_HASH_PROP_ID,
                NULL,
                &cbHash
                )) {

            pbHash = (PBYTE)LsapAllocateLsaHeap( cbHash );

            if (pbHash) {

                if (CertGetCertificateContextProperty(
                            pCertContext,
                            CERT_SHA1_HASH_PROP_ID,
                            pbHash,
                            &cbHash
                            )) {

                    HCRYPTKEY hKey;
                    HCRYPTPROV hProv;
                    LPWSTR ContainerName;
                    LPWSTR ProviderName;
                    LPWSTR DisplayInfo;

                    if (pEfsUserInfo->pUserCache) {
                
                        //
                        // We are going to create a new key. The current cache is going away.
                        // We will insert a new cache node in the header.
                        //
                
                        EfspReleaseUserCache(pEfsUserInfo->pUserCache);
                        pEfsUserInfo->pUserCache = NULL;
                
                    }

                    rc = GetKeyInfoFromCertHash(
                             pEfsUserInfo,
                             pbHash,
                             cbHash,
                             &hKey,
                             &hProv,
                             &ContainerName,
                             &ProviderName,
                             &DisplayInfo,
                             &bIsValid
                             );

                    if (ERROR_SUCCESS == rc) {

                        //
                        // We don't care about any of the stuff that came back,
                        // all we care about is that it was all found, meaning
                        // that the key exists and can be used.  Now that we know
                        // that, we can jam the hash into the registry.
                        //

                        HKEY KeyHandle;
                        DWORD Disposition;

                        rc = RegCreateKeyEx(
                                   KEYPATHROOT,
                                   pEfsUserInfo->lpKeyPath,
                                   0,
                                   TEXT("REG_SZ"),
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_READ | KEY_WRITE,
                                   NULL,
                                   &KeyHandle,
                                   &Disposition    // address of disposition value buffer
                                   );

                        if (ERROR_SUCCESS == rc) {

                            rc = RegSetValueEx(
                                      KeyHandle,  // handle of key to set value for
                                      CERT_HASH,
                                      0,
                                      REG_BINARY,
                                      pbHash,
                                      cbHash
                                      );

                            RegCloseKey( KeyHandle );
                        }

                        if (hKey) {

                            //
                            //  hKey not NULL means we have not put the data in the cache.
                            //

                            CryptDestroyKey( hKey );
                            CryptReleaseContext( hProv, 0 );
                            LsapFreeLsaHeap( ContainerName );
                            LsapFreeLsaHeap( ProviderName );
                            LsapFreeLsaHeap( DisplayInfo );

                        }
                    }

                } else {

                    rc = GetLastError();
                }

                LsapFreeLsaHeap( pbHash );

            } else {

                rc = ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            rc = GetLastError();
        }

        CertFreeCertificateContext( pCertContext );

    } else {

        rc = GetLastError();
    }


    return( rc );
}

BOOLEAN
CurrentHashOK(
    IN PEFS_USER_INFO pEfsUserInfo, 
    IN PBYTE          pbHash, 
    IN DWORD          cbHash,
    OUT DWORD         *dFlag
    )

/*++

Routine Description:

    See if the value pbHash is already in the user's key. If not, try to see if we can add it back.
    
Arguments:

    pEfsUserInfo -- User Info
    
    pbHash -- Hash value
    
    cbHash -- Hash length
    
    dFlag  -- Cert Flag to indicate if the cert has been added to the LM intermediate store

Return Value:

    TRUE if the pbHash found or added successfully
    
--*/
{

    DWORD rc;
    BOOLEAN b = FALSE;
    HKEY hRegKey = NULL;
    PBYTE         pbLocalHash; 
    DWORD         cbLocalHash;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ,
             &hRegKey
             );

    *dFlag = 0;

    if (rc == ERROR_SUCCESS) {

        //
        // If there's a certificate thumbprint there, get it and use it.
        //

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                &cbLocalHash
                );

        if (rc == ERROR_SUCCESS) {

            if (cbLocalHash == cbHash) {
                //
                // Query out the thumbprint, find the cert, and return the key information.
                //
    
                if (pbLocalHash = (PBYTE)LsapAllocateLsaHeap( cbLocalHash )) {
    
                    rc = RegQueryValueEx(
                            hRegKey,
                            CERT_HASH,
                            NULL,
                            &Type,
                            pbLocalHash,
                            &cbLocalHash
                            );
    
                    if (rc == ERROR_SUCCESS) {

                        //
                        //  Check if the hash value matches
                        //

                        if (RtlEqualMemory( pbLocalHash, pbHash, cbHash)){

                            b = TRUE;
                            cbLocalHash = sizeof (DWORD);
                            if (RegQueryValueEx(
                                    hRegKey,
                                    CERT_FLAG,
                                    NULL,
                                    &Type,
                                    (LPBYTE) dFlag,
                                    &cbLocalHash
                                    )){
                                //
                                // Make sure dFlag set to 0 if error occurs. This may not be needed.
                                //

                                *dFlag = 0;
                            }


                        }

                    }

                    LsapFreeLsaHeap(pbLocalHash);
                }
            } 
        }

        RegCloseKey( hRegKey );

    } 
         
    if (rc != ERROR_SUCCESS) {

        //
        // Let's see if we can create one
        //

        DWORD Disposition = 0;
    
        //
        // Assume that there's no current EFS information
        // for this guy.  Create the registry key.
        //
    
        rc = RegCreateKeyEx(
                 KEYPATHROOT,
                 pEfsUserInfo->lpKeyPath,
                 0,
                 TEXT("REG_SZ"),
                 REG_OPTION_NON_VOLATILE,
                 KEY_ALL_ACCESS,
                 NULL,
                 &hRegKey,
                 &Disposition    // address of disposition value buffer
                 );
        
        if (rc == ERROR_SUCCESS) {

            rc = RegSetValueEx(
                    hRegKey,  // handle of key to set value for
                    CERT_HASH,
                    0,
                    REG_BINARY,
                    pbHash,
                    cbHash
                    );

            if (rc == ERROR_SUCCESS) {

                b = TRUE;

            }

            RegCloseKey( hRegKey );
        }
    }

    return b;
}

DWORD
GetCurrentHash(
     IN  PEFS_USER_INFO pEfsUserInfo, 
     OUT PBYTE          *pbHash, 
     OUT DWORD          *cbHash
     )
{
    HKEY hRegKey = NULL;
    DWORD rc;

    ASSERT(pbHash);
    ASSERT(cbHash);

    *pbHash = NULL;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        DWORD Type;

        rc = RegQueryValueEx(
                hRegKey,
                CERT_HASH,
                NULL,
                &Type,
                NULL,
                cbHash
                );

        if (rc == ERROR_SUCCESS) {
    
            if (*pbHash = (PBYTE)LsapAllocateLsaHeap( *cbHash )) {
            
                rc = RegQueryValueEx(
                        hRegKey,
                        CERT_HASH,
                        NULL,
                        &Type,
                        *pbHash,
                        cbHash
                        );
            
                if (rc != ERROR_SUCCESS) {

                    LsapFreeLsaHeap(*pbHash);
                    *pbHash = NULL;

                }
            } else {

                rc = GetLastError();

            }
        }

        RegCloseKey( hRegKey );

    }

    return rc;

}


BOOLEAN    
EfspInitUserCacheNode(
     IN OUT PUSER_CACHE pCacheNode,
     IN PBYTE pbHash,
     IN DWORD cbHash,
     IN LPWSTR ContainerName,
     IN LPWSTR ProviderName,
     IN LPWSTR DisplayInformation,
     IN PCCERT_CONTEXT pCertContext,
     IN HCRYPTKEY hKey,
     IN HCRYPTPROV hProv,
     IN LUID *AuthId,
     IN LONG CertValidated
     )
/*++

Routine Description:

    Initialize the cache node and insert it into the list.
        
Arguments:

     pCacheNode -- Node to be inserted

     pbHash     -- User Cert Hash

     cbHash     -- Length of the hash data

     ContainerName -- Container name

     ProviderName -- Provider name

     DisplayInformation -- Display information

     pCertContext -- Cert Context

     hKey       -- User Key

     hProv      -- Provider handle
     
     AuthId     -- Authentication ID

     CertValidated -- Cert validation info

Return Value:

    TRUE if successful
    
--*/
{
    if (!pCacheNode) {
        return FALSE;
    }
    pCacheNode->pbHash = pbHash;
    pCacheNode->cbHash = cbHash;
    pCacheNode->ContainerName = ContainerName;
    pCacheNode->ProviderName = ProviderName;
    pCacheNode->DisplayInformation = DisplayInformation;
    pCacheNode->pCertContext = pCertContext;
    pCacheNode->hUserKey = hKey;
    pCacheNode->hProv = hProv;
    pCacheNode->CertValidated = CertValidated; 
    pCacheNode->UseRefCount = 1; // The caller's hold on this node
    pCacheNode->StopUseCount = 0;
    pCacheNode->AuthId = *AuthId;
    
    return (EfspAddUserCache(pCacheNode));
}

BOOL
EfsGetBasicConstraintExt(
   IN OUT PCERT_EXTENSION *basicRestraint
   )
{

    BOOL bRet = TRUE;
    CERT_BASIC_CONSTRAINTS2_INFO CertConstraints2;
    DWORD rc = ERROR_SUCCESS;

    RtlZeroMemory( &CertConstraints2, sizeof(CERT_BASIC_CONSTRAINTS2_INFO) );

    *basicRestraint = (PCERT_EXTENSION) LsapAllocateLsaHeap(sizeof(CERT_EXTENSION));
    if (*basicRestraint) {

        bRet = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   X509_BASIC_CONSTRAINTS2,
                   &CertConstraints2,
                   NULL,
                   &((*basicRestraint)->Value.cbData)
                   );

        if (bRet) {

            (*basicRestraint)->Value.pbData = (PBYTE) LsapAllocateLsaHeap( (*basicRestraint)->Value.cbData );
            if ((*basicRestraint)->Value.pbData) {

                bRet = CryptEncodeObject(
                           X509_ASN_ENCODING,
                           X509_BASIC_CONSTRAINTS2,
                           &CertConstraints2,
                           (*basicRestraint)->Value.pbData,
                           &((*basicRestraint)->Value.cbData)
                           );

                if (bRet) {
                    (*basicRestraint)->pszObjId = szOID_BASIC_CONSTRAINTS2;
                    (*basicRestraint)->fCritical = FALSE;
                } else {
        
                    rc = GetLastError();
                    LsapFreeLsaHeap((*basicRestraint)->Value.pbData);
                    SetLastError(rc);
        
                }
            } else {
                bRet = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (!bRet) {

            rc = GetLastError();
            LsapFreeLsaHeap(*basicRestraint);
            SetLastError(rc);
            *basicRestraint = NULL;

        }

    } else {
        bRet = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return bRet;

}

BOOL
EfsGetAltNameExt(
    IN OUT PCERT_EXTENSION *altNameExt, 
    IN LPWSTR UPNName
    )
{
    BOOL bRet = TRUE;
    DWORD cbData = 0;
    DWORD rc = ERROR_SUCCESS;
    CERT_NAME_VALUE prnName;
    CERT_OTHER_NAME certOtherName;
    CERT_ALT_NAME_ENTRY altName;
    CERT_ALT_NAME_INFO nameInfo;

    *altNameExt = (PCERT_EXTENSION) LsapAllocateLsaHeap(sizeof(CERT_EXTENSION));
    if (*altNameExt) {
        prnName.dwValueType = CERT_RDN_UTF8_STRING;
        prnName.Value.cbData = (wcslen(UPNName) + 1) * sizeof(WCHAR);
        prnName.Value.pbData = (BYTE *)UPNName;
    
        bRet = CryptEncodeObject(
                   X509_ASN_ENCODING,
                   X509_UNICODE_ANY_STRING,
                   &prnName,
                   NULL,
                   &certOtherName.Value.cbData
                   );
        if (bRet) {
    
            certOtherName.Value.pbData = (PBYTE)LsapAllocateLsaHeap( certOtherName.Value.cbData );
            if (certOtherName.Value.pbData) {
    
                bRet = CryptEncodeObject(
                           X509_ASN_ENCODING,
                           X509_UNICODE_ANY_STRING,
                           &prnName,
                           certOtherName.Value.pbData,
                           &certOtherName.Value.cbData
                           );
    
                if (bRet) {
    
                    altName.dwAltNameChoice = CERT_ALT_NAME_OTHER_NAME;
                    certOtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
                    altName.pOtherName = &certOtherName;
                    nameInfo.cAltEntry = 1;
                    nameInfo.rgAltEntry = &altName;
    
                    bRet = CryptEncodeObject(
                               X509_ASN_ENCODING,
                               szOID_SUBJECT_ALT_NAME,
                               &nameInfo,
                               NULL,
                               &((*altNameExt)->Value.cbData)
                               );
                    if (bRet) {

                        (*altNameExt)->Value.pbData = (PBYTE) LsapAllocateLsaHeap( (*altNameExt)->Value.cbData );
                        if ((*altNameExt)->Value.pbData) {

                            bRet = CryptEncodeObject(
                                       X509_ASN_ENCODING,
                                       szOID_SUBJECT_ALT_NAME,
                                       &nameInfo,
                                       (*altNameExt)->Value.pbData,
                                       &((*altNameExt)->Value.cbData)
                                       );
                            if (bRet) {
                                (*altNameExt)->pszObjId = szOID_SUBJECT_ALT_NAME2;
                                (*altNameExt)->fCritical = FALSE;
                            } else {

                                DWORD rc = GetLastError();
                                LsapFreeLsaHeap((*altNameExt)->Value.pbData);
                                SetLastError(rc);

                            }

                        } else {

                            bRet = FALSE;
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);

                        }
                    }
                    
                }

                rc = GetLastError();
                LsapFreeLsaHeap(certOtherName.Value.pbData);
                SetLastError(rc);
                
            } else {
                bRet = FALSE;
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

        if (!bRet) {

            GetLastError();
            LsapFreeLsaHeap(*altNameExt);
            SetLastError(rc);
            *altNameExt = NULL;

        }

    } else {
        bRet = FALSE;
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return bRet;

}

VOID
EfsMarkCertAddedToStore(
    IN PEFS_USER_INFO pEfsUserInfo
    )
/*++

Routine Description:

    Mark in the registry that we have add the cert to the LM store.
        
Arguments:

    pEfsUserInfo -- User Info
    
Return Value:

    None.
    
--*/
{
    HKEY hRegKey = NULL;
    DWORD rc;

    rc = RegOpenKeyEx(
             KEYPATHROOT,
             pEfsUserInfo->lpKeyPath,
             0,
             GENERIC_READ | GENERIC_WRITE,
             &hRegKey
             );

    if (rc == ERROR_SUCCESS) {

        rc = CERTINLMTRUSTEDSTORE;

        RegSetValueEx(
                hRegKey,  // handle of key to set value for
                CERT_FLAG,
                0,
                REG_DWORD,
                (LPBYTE)&rc,
                sizeof (DWORD)
                );

        RegCloseKey( hRegKey );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\thdpool.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       thdpool.c
//
//  Contents:   Home of the SPM thread pool
//
//  Classes:
//
//  Functions:
//
//  History:    6-08-93   RichardW   Created
//
//----------------------------------------------------------------------------

#include <lsapch.hxx>



#define POOL_SEM_LIMIT              0x7FFFFFFF
#define MAX_POOL_THREADS_HARD       256

#define MAX_SUBQUEUE_THREADS        (4 * MAX_POOL_THREADS_HARD)

LSAP_TASK_QUEUE   GlobalQueue;


//
// Local Prototypes:
//

typedef enum _LSAP_TASK_STATUS {
    TaskNotQueued,
    TaskQueued,
    TaskUnknown
} LSAP_TASK_STATUS ;

LSAP_TASK_STATUS 
EnqueueThreadTask(
    PLSAP_TASK_QUEUE  pQueue,
    PLSAP_THREAD_TASK pTask,
    BOOLEAN     fUrgent);


#define LockQueue(q)    EnterCriticalSection(&((q)->Lock))
#define UnlockQueue(q)  LeaveCriticalSection(&((q)->Lock))



//+---------------------------------------------------------------------------
//
//  Function:   InitializeTaskQueue
//
//  Synopsis:   Initialize a Queue Structure
//
//  Arguments:  [pQueue] --
//              [Type]   --
//
//  History:    11-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeTaskQueue(
    PLSAP_TASK_QUEUE      pQueue,
    LSAP_TASK_QUEUE_TYPE   Type)
{
    OBJECT_HANDLE_FLAG_INFORMATION FlagInfo ;

    RtlZeroMemory( pQueue, sizeof(LSAP_TASK_QUEUE) );

    InitializeListHead(
        &pQueue->pTasks
        );

    pQueue->Type = Type;

    pQueue->hSemaphore = CreateSemaphore(NULL, 0, POOL_SEM_LIMIT, NULL);

    __try 
    {
        InitializeCriticalSectionAndSpinCount( &pQueue->Lock, 5000 );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        if ( pQueue->hSemaphore )
        {
            NtClose( pQueue->hSemaphore );
            pQueue->hSemaphore = NULL ;
        }
    }


    if (!pQueue->hSemaphore)
    {
        DebugLog((DEB_ERROR, "Could not create semaphore, %d\n",
                        GetLastError() ));
        return( FALSE );
    }

    
    FlagInfo.Inherit = FALSE ;
    FlagInfo.ProtectFromClose = TRUE ;

    NtSetInformationObject(
        pQueue->hSemaphore,
        ObjectHandleFlagInformation,
        &FlagInfo,
        sizeof( FlagInfo ) );

    pQueue->StartSync = CreateEvent( NULL, TRUE, FALSE, NULL );

    if ( pQueue->StartSync == NULL )
    {
        DebugLog(( DEB_ERROR, "Could not create start sync event\n" ));

        CloseHandle( pQueue->hSemaphore );

        return FALSE ;
    }

    return( TRUE );

}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeThreadPool
//
//  Synopsis:   Initializes necessary data for the thread pool
//
//  Arguments:  (none)
//
//  History:    7-13-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
InitializeThreadPool(void)
{
    if (!InitializeTaskQueue(&GlobalQueue, QueueShared))
    {
        return( FALSE );
    }

    LsaIAddTouchAddress( &GlobalQueue, sizeof( GlobalQueue ) );

    return(TRUE);

}

//+---------------------------------------------------------------------------
//
//  Function:   QueueAssociateThread
//
//  Synopsis:   Associates the thread with the queue
//
//  Arguments:  [pQueue] --
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
QueueAssociateThread(
    PLSAP_TASK_QUEUE  pQueue)
{
    PSession    pSession;

    LockQueue( pQueue );

    pQueue->TotalThreads++  ;

#if 0
    //
    // We were already idle, so decrement this so the later call
    // to wait for thread task will leave the count correct.
    //

    DsysAssert(pQueue->IdleThreads > 0);
    pQueue->IdleThreads--;
#endif 

    //
    // Update the statistics:
    //

    if ( pQueue->MaxThreads < pQueue->TotalThreads )
    {
        pQueue->MaxThreads = pQueue->TotalThreads ;
    }

    UnlockQueue( pQueue );
}


//+---------------------------------------------------------------------------
//
//  Function:   QueueDisassociateThread
//
//  Synopsis:   Disconnects a thread and a queue
//
//  Arguments:  [pQueue]      --
//              [pLastThread] -- OPTIONAL flag indicating last thread of queue
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
QueueDisassociateThread(
    PLSAP_TASK_QUEUE  pQueue,
    BOOLEAN *   pLastThread)
{
    PSession    pSession;

    LockQueue( pQueue );

    DsysAssert(pQueue->TotalThreads > 0);

    if ( pQueue->TotalThreads == 1 )
    {
        if ( pLastThread )
        {
            *pLastThread = TRUE ;

            //
            // If the queue is being run down, set the 
            // event since we are the last thread
            //

            if ( pQueue->Type == QueueZombie )
            {
                SetEvent( pQueue->StartSync );
            }
        }


        if ( pQueue->Tasks )
        {
            //
            // Make sure that we never have more tasks queued
            // to a zombie
            //

            DsysAssert( pQueue->Type != QueueZombie );

            UnlockQueue( pQueue );

            return FALSE ;
        }
    }

    pQueue->TotalThreads--;

    UnlockQueue( pQueue );

    return TRUE ;
}



//+---------------------------------------------------------------------------
//
//  Function:   DequeueAnyTask
//
//  Synopsis:   Returns a task from this queue or any shared, if available
//
//  Arguments:  [pQueue] --
//
//  Requires:   pQueue must be locked!
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_THREAD_TASK
DequeueAnyTask(
    PLSAP_TASK_QUEUE      pQueue)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pShared;
    PLSAP_TASK_QUEUE  pPrev;


    if ( !IsListEmpty(&pQueue->pTasks) )
    {
        pTask = (PLSAP_THREAD_TASK) RemoveHeadList(&pQueue->pTasks);

        pQueue->Tasks --;

        pQueue->TaskCounter++;

        //
        // Reset the pointers.  This is required by the recovery logic
        // in the Enqueue function below.
        //

        pTask->Next.Flink = NULL ;
        pTask->Next.Blink = NULL ;


        return( pTask );
    }


    //
    // No pending on primary queue.  Check secondaries:
    //

    if (pQueue->Type == QueueShared)
    {

        pShared = pQueue->pShared;

        while ( pShared )
        {
            DWORD WaitStatus;
            //
            // We need to wait now to change the semaphore count
            //

            WaitStatus = WaitForSingleObject(pShared->hSemaphore, 0);

            LockQueue( pShared );

            if ((WaitStatus == WAIT_OBJECT_0) && !IsListEmpty(&pShared->pTasks) )
            {

                pTask = (PLSAP_THREAD_TASK) RemoveHeadList(&pShared->pTasks);

                pShared->Tasks--;

                pShared->TaskCounter++;

                UnlockQueue( pShared );     // Unlock shared queue


                return( pTask );

            }

            pPrev = pShared;

            pShared = pShared->pNext;

            UnlockQueue( pPrev );


        }
    }

    return( NULL );
}



//+---------------------------------------------------------------------------
//
//  Function:   WaitForThreadTask
//
//  Synopsis:   Function called by queue waiters
//
//  Arguments:  [pQueue]  -- Queue to wait on
//              [TimeOut] -- timeout in seconds
//
//  History:    11-10-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PLSAP_THREAD_TASK
WaitForThreadTask(
    PLSAP_TASK_QUEUE      pQueue,
    DWORD           TimeOut)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pShared;
    PLSAP_TASK_QUEUE  pPrev;
    int         WaitResult;

    LockQueue( pQueue );

    pTask = DequeueAnyTask( pQueue );

    if (pTask)
    {
        UnlockQueue( pQueue );

        return( pTask );
    }


    //
    // No pending anywhere.
    //

    if (TimeOut == 0)
    {
        UnlockQueue( pQueue );

        return( NULL );
    }

    //
    // Principal of the loop:  We do this loop so long as we were awakened
    // by the semaphore being released.  If there was no task to pick up, then
    // we go back and wait again.  We return NULL only after a timeout, or an
    // error.
    //

    do
    {

        pQueue->IdleThreads++;

        UnlockQueue( pQueue );

        WaitResult = WaitForSingleObject( pQueue->hSemaphore, TimeOut );

        LockQueue( pQueue );

        //
        // In between the wait returning and the lock succeeding, another
        // thread might have queued up a request.

        DsysAssert(pQueue->IdleThreads > 0);
        pQueue->IdleThreads--;

        //
        // In between the wait returning and the lock succeeding, another
        // thread might have queued up a request, so don't blindly 
        // bail out.  Check the pending count, and skip over this
        // exit path if something is there
        //

        if ( pQueue->Tasks == 0 )
        {
            if (WaitResult != WAIT_OBJECT_0)
            {
                UnlockQueue( pQueue );
                if ( WaitResult == -1 )
                {
                    DebugLog((DEB_ERROR, "Error on waiting for semaphore, %d\n", GetLastError()));
                }
                return( NULL );
            }
        }

        //
        // If the queue type is reset to Zombie, then this queue is
        // being killed.  Return NULL immediately.  If we're the last
        // thread, set the event so the thread deleting the queue will
        // wake up in a timely fashion.
        //

        if ( pQueue->Type == QueueZombie )
        {
            return NULL ;

        }


        pTask = DequeueAnyTask( pQueue );

        if (pTask)
        {

            UnlockQueue( pQueue );

            return( pTask );
        }

        //
        // Track number of times we woke up but didn't have anything to do
        //

        pQueue->MissedTasks ++ ;

    } while ( WaitResult != WAIT_TIMEOUT );

    UnlockQueue( pQueue );

    return( NULL );

}


//+---------------------------------------------------------------------------
//
//  Function:   SpmPoolThreadBase
//
//  Synopsis:   New Pool Thread Base
//
//  Arguments:  [pvQueue] -- OPTIONAL queue to use
//
//  History:    11-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SpmPoolThreadBase(
    PVOID   pvSession)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pQueue;
    PSession    pSession;
    BOOLEAN     ShrinkWS = FALSE;
    DWORD       dwResult;
    DWORD       Timeout;
    PSession    ThreadSession ;
    PSession    OriginalSession ;

    OriginalSession = GetCurrentSession();

    if ( pvSession )
    {
        ThreadSession = (PSession) pvSession ;

        SpmpReferenceSession( ThreadSession );

        SetCurrentSession( ThreadSession );

    }
    else
    {
        ThreadSession = OriginalSession ;

        SpmpReferenceSession( ThreadSession );
    }

    pQueue = ThreadSession->SharedData->pQueue ;

    if (!pQueue)
    {
        pQueue = &GlobalQueue;
    }

    QueueAssociateThread( pQueue );

    //
    // Share pool threads have short lifespans.  Dedicated single, or
    // single read threads have infinite life span.
    //

    if (pQueue->Type == QueueShared)
    {
        Timeout = LsaTuningParameters.ThreadLifespan * 1000;
    }
    else
    {
        //
        // If we are the dedicated thread for this queue, the timeout
        // is infinite.  If we are a temporary thread, the timeout is
        // the subqueue
        //

        if ( ThreadSession->ThreadId != GetCurrentThreadId() )
        {
            Timeout = LsaTuningParameters.SubQueueLifespan ;
        }
        else
        {
            Timeout = INFINITE ;
        }
    }

    if ( pQueue->StartSync )
    {
        DebugLog(( DEB_TRACE, "ThreadPool:  Signaling start event\n" ));
        //
        // If a queue was passed in, the caller of CreateXxxQueue is blocked
        // waiting for us to strobe the start sync event.
        //

        SetEvent( pQueue->StartSync );

    }

    while ( TRUE )
    {
        pTask = WaitForThreadTask( pQueue, Timeout );

        if ( pTask )
        {
            SetCurrentSession( pTask->pSession );

            dwResult = pTask->pFunction(pTask->pvParameter);

#if DBG
            RtlCheckForOrphanedCriticalSections( NtCurrentThread() );
#endif 

            SetCurrentSession( ThreadSession );

            //
            // The session in this task was referenced during the AssignThread call.
            // This dereference cleans that up.
            //

            SpmpDereferenceSession(pTask->pSession);

            LsapFreePrivateHeap( pTask );
        }
        else
        {

            //
            // We can never leave the queue empty of threads if
            // there are still tasks pending.  QueueDisassociateThread
            // will fail if there are tasks pending.  In that case,
            // skip up to the top of the loop again.
            //

            if ( !QueueDisassociateThread( pQueue, &ShrinkWS ) )
            {
                continue;
            }
            
            //
            // Now that we are not part of that queue, reset our thread session
            //

            SpmpDereferenceSession( ThreadSession );

            SetCurrentSession( OriginalSession );

            if ( LsaTuningParameters.Options & TUNE_TRIM_WORKING_SET )
            {

                if (ShrinkWS)
                {
                    LsaTuningParameters.ShrinkOn = TRUE ;
                    LsaTuningParameters.ShrinkCount++;

                    SetProcessWorkingSetSize(   GetCurrentProcess(),
                                                (SIZE_T)(-1),
                                                (SIZE_T)(-1) );

                }
                else
                {
                    LsaTuningParameters.ShrinkSkip++;
                }
            }


            DebugLog(( DEB_TRACE,
                        "No tasks pending on queue %x, thread exiting\n",
                        pQueue ));

            return( 0 );

        }
    }

    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Function:   EnqueueThreadTask
//
//  Synopsis:   Enqueue a task, update counts, etc.
//
//  Arguments:  [pTask] -- Task to add
//
//  History:    7-13-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LSAP_TASK_STATUS
EnqueueThreadTask(
    PLSAP_TASK_QUEUE  pQueue,
    PLSAP_THREAD_TASK pTask,
    BOOLEAN     fUrgent)
{
    BOOLEAN NeedMoreThreads = FALSE;
    HANDLE hQueueSem ;
    HANDLE hParentSem = NULL ;
    PLSAP_TASK_QUEUE pThreadQueue = NULL;
    PSession pSession = NULL;


    LockQueue(pQueue);

    if ( pQueue->Type == QueueZombie )
    {
        UnlockQueue( pQueue );

        return TaskNotQueued ;
    }


    if (fUrgent)
    {
        InsertHeadList(
            &pQueue->pTasks,
            &pTask->Next
            );
    }
    else
    {
        InsertTailList(
            &pQueue->pTasks,
            &pTask->Next
            );

    }


    pQueue->Tasks++;
    pQueue->QueuedCounter++;

    if ( pQueue->Tasks > pQueue->TaskHighWater )
    {
        pQueue->TaskHighWater = pQueue->Tasks ;
    }

    if (pQueue->Type == QueueShared)
    {
        if ((pQueue->Tasks > pQueue->IdleThreads) &&
            (pQueue->TotalThreads < MAX_POOL_THREADS_HARD))
        {
            NeedMoreThreads = TRUE;
            pThreadQueue = pQueue;
        }

        hParentSem = NULL ;
    }
    else if (pQueue->Type == QueueShareRead )
    {
        DsysAssert( pQueue->pOriginal );

        //
        // Here's the race potential.  If the queue we have has no idle thread,
        // then make sure there is an idle thread at the parent queue, otherwise
        // we can deadlock (e.g. this call is in response to the job being executed
        // by the dedicated thread.  Of course, this can also be a problem correctly
        // determining the parent queue's status, since locks should always flow down,
        // not up.  So, if the number of jobs that we have pending exceeds the number
        // of idle threads, *always*, regardless of the other queue's real state or
        // total threads, queue up another thread.
        //

        if ( pQueue->Tasks > pQueue->IdleThreads )
        {
            NeedMoreThreads = TRUE ;

            pSession = pTask->pSession ;

            if ( pQueue->TotalThreads < MAX_SUBQUEUE_THREADS )
            {
                pThreadQueue = pQueue ;
            }
            else
            {
                pThreadQueue = pQueue->pOriginal;
            }
        }

        //
        // This is a safe read.  The semaphore is not subject to change after creation,
        // and the worst that can happen is a bad handle.
        //

        hParentSem = pQueue->pOriginal->hSemaphore ;

    }

    hQueueSem = pQueue->hSemaphore ;


    UnlockQueue( pQueue );

    //
    // Kick our semaphore.
    //
    ReleaseSemaphore( hQueueSem, 1, NULL );

    //
    // Kick the parent semaphore
    //

    if ( hParentSem )
    {
        ReleaseSemaphore( hParentSem, 1, NULL );
    }

    if (NeedMoreThreads)
    {
        HANDLE hThread;
        DWORD tid;

        DebugLog((DEB_TRACE_QUEUE, "Queue %x needs more threads\n", pQueue));

        //
        // Increment the number of threads now so we don't create more threads
        // while we wait for the first one to be created.
        //

////        LockQueue(pThreadQueue);
#if 0
        pThreadQueue->TotalThreads++;
        pThreadQueue->IdleThreads++;

        //
        // Update the statistics:
        //

        if ( pThreadQueue->MaxThreads < (LONG) pThreadQueue->TotalThreads )
        {
            pThreadQueue->MaxThreads = (LONG) pThreadQueue->TotalThreads ;
        }
#endif 
////        pThreadQueue->ReqThread++;

////        UnlockQueue(pThreadQueue);
        InterlockedIncrement( &pThreadQueue->ReqThread );

        //
        // If the queue is a dedicated queue, supply the session from the task.
        // if the queue is a shared (global) queue, pass in NULL:
        //

        hThread = LsapCreateThread(  NULL, 0,
                                    SpmPoolThreadBase,

                                    (pThreadQueue->Type == QueueShareRead ?
                                        pThreadQueue->OwnerSession : NULL ),

                                    0, &tid);

        //
        // Check for failure
        //

        if (hThread == NULL)
        {
#if 0
            LockQueue(pThreadQueue);
            DsysAssert(pThreadQueue->TotalThreads > 0);
            DsysAssert(pThreadQueue->IdleThreads > 0);
            pThreadQueue->TotalThreads--;
            pThreadQueue->IdleThreads--;
            UnlockQueue(pThreadQueue);
#endif 

            //
            // This is extremely painful.  The thread creation attempt
            // failed, but because of the nature of the queue, we don't
            // know if it was picked up and executed, or it was dropped,
            // or anything about it.
            //

            return TaskUnknown ;


        }
        else
        {
            NtClose(hThread);
        }

    }

    return TaskQueued ;

}







//+---------------------------------------------------------------------------
//
//  Function:   SpmAssignThread
//
//  Synopsis:   Assigns a task to a thread pool thread.
//
//  Arguments:  [pFunction]   -- Function to execute
//              [pvParameter] -- Parameter to function
//              [pSession]    -- Session to execute as
//
//  History:    11-24-93   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PVOID
LsapAssignThread(
    LPTHREAD_START_ROUTINE pFunction,
    PVOID                   pvParameter,
    PSession                pSession,
    BOOLEAN                 fUrgent)
{
    PLSAP_THREAD_TASK pTask;
    PLSAP_TASK_QUEUE  pQueue;
    LSAP_TASK_STATUS TaskStatus ;


    pTask = (PLSAP_THREAD_TASK) LsapAllocatePrivateHeap( sizeof( LSAP_THREAD_TASK ) );

    if (!pTask)
    {
        return( NULL );
    }


    pTask->pFunction = pFunction;
    pTask->pvParameter = pvParameter;
    pTask->pSession = pSession;

    if ( pSession->SharedData->pQueue )
    {
        LockSession(pSession);
        if( pSession->SharedData->pQueue )
        {
            pQueue = pSession->SharedData->pQueue;
        } else
        {
            pQueue = &GlobalQueue;
        }
        UnlockSession(pSession);
    }
    else
    {
        pQueue = &GlobalQueue;
    }

    LsaTuningParameters.ShrinkOn = FALSE;

    //
    // Reference the session so that it will never go away while a thread
    // is working on this task.  The worker function will deref the session.
    //

    SpmpReferenceSession( pSession );

    TaskStatus = EnqueueThreadTask( pQueue,
                                    pTask,
                                    fUrgent );

    if ( ( TaskStatus == TaskQueued ) ||
         ( TaskStatus == TaskUnknown ) )
    {
        return pTask ;
    }

    if ( TaskStatus == TaskNotQueued )
    {
        //
        // Failed, therefore deref this session.
        //
        SpmpDereferenceSession( pSession );
        LsapFreePrivateHeap( pTask );
    }

    return NULL ;


}






//+---------------------------------------------------------------------------
//
//  Function:   CreateSubordinateQueue
//
//  Synopsis:   Create a Queue hanging off an original queue.
//
//  Arguments:  [pQueue]         --
//              [pOriginalQueue] --
//
//  History:    11-17-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CreateSubordinateQueue(
    PSession    pSession,
    PLSAP_TASK_QUEUE  pOriginalQueue)
{
    HANDLE  hThread;
    DWORD   tid;
    PLSAP_TASK_QUEUE pQueue ;

    pQueue = (LSAP_TASK_QUEUE *) LsapAllocatePrivateHeap( sizeof( LSAP_TASK_QUEUE ) );

    if ( !pQueue )
    {
        return FALSE ;
    }

    DebugLog(( DEB_TRACE_QUEUE, "Creating sub queue %x\n", pQueue ));

    if (InitializeTaskQueue( pQueue, QueueShareRead ))
    {
        LockQueue( pQueue );
        LockQueue( pOriginalQueue );

        pQueue->pNext = pOriginalQueue->pShared;

        pOriginalQueue->pShared = pQueue;

        pQueue->pOriginal = pOriginalQueue;
        pQueue->OwnerSession = pSession ;

#if 0
        pQueue->TotalThreads++;
        pQueue->IdleThreads++;
#endif 

        UnlockQueue( pOriginalQueue );

        UnlockQueue( pQueue );

        pSession->SharedData->pQueue = pQueue ;


        hThread = LsapCreateThread(  NULL, 0,
                                    SpmPoolThreadBase, pSession,
                                    0, &pSession->ThreadId );


        if (hThread != NULL)
        {
            NtClose( hThread );


            //
            // Wait for the thread to signal the event, so that
            // we know it's ready
            //

            WaitForSingleObject( pQueue->StartSync, INFINITE );

            NtClose( pQueue->StartSync );

            pQueue->StartSync = NULL ;

            return( TRUE );
        }
        else
        {
            RtlDeleteCriticalSection( &pQueue->Lock );

            LsapFreePrivateHeap( pQueue );

            pQueue = NULL ;

        }

    }

    if ( pQueue )
    {
        LsapFreePrivateHeap( pQueue );
    }

    return( FALSE );

}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSubordinateQueue
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pQueue] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
DeleteSubordinateQueue(
    PLSAP_TASK_QUEUE  pQueue,
    ULONG Flags)
{
    PLSAP_TASK_QUEUE  pOriginal;
    PLSAP_TASK_QUEUE  pScan;
    PLSAP_TASK_QUEUE  pPrev ;
    PLSAP_THREAD_TASK pTask ;
    DWORD dwResult ;
    PLIST_ENTRY List ;
    PSession ThreadSession = GetCurrentSession();
    OBJECT_HANDLE_FLAG_INFORMATION FlagInfo ;
    //
    // Lock it
    //

    DebugLog(( DEB_TRACE, "Deleting queue %x\n", pQueue ));

    LockQueue( pQueue );

    if ( pQueue->pShared )
    {
        pOriginal = pQueue->pOriginal ;

        LockQueue( pOriginal );

        //
        // Unlink Queue from parent:
        //

        if ( pOriginal->pShared != pQueue )
        {

            pScan = pOriginal->pShared;

            LockQueue( pScan );

            while ( pScan->pNext && (pScan->pNext != pQueue) )
            {
                pPrev = pScan ;

                pScan = pScan->pNext;

                UnlockQueue( pPrev );
            }

            if ( pScan->pNext )
            {
                pScan->pNext = pQueue->pNext ;
            }

            UnlockQueue( pScan );

        }
        else
        {
            pOriginal->pShared = pQueue->pNext;
        }

        pQueue->pNext = NULL ;

        //
        // Done with parent
        //

        UnlockQueue( pOriginal );

    }
    //
    // Drain queue by removing all the tasks.
    //

    while ( !IsListEmpty( &pQueue->pTasks ) )
    {
        List = RemoveHeadList( &pQueue->pTasks );

        pQueue->Tasks-- ;

        pTask = CONTAINING_RECORD( List, LSAP_THREAD_TASK, Next );

        //
        // A synchronous drain will have this thread execute
        // all remaining tasks.
        //

        if ( Flags & DELETEQ_SYNC_DRAIN )
        {
            SpmpReferenceSession(pTask->pSession);

            SetCurrentSession( pTask->pSession );

            dwResult = pTask->pFunction(pTask->pvParameter);

            SetCurrentSession( ThreadSession );

            SpmpDereferenceSession(pTask->pSession);

            LsapFreePrivateHeap( pTask );

        }
        else 
        {
            //
            // Otherwise, send them to the global queue to be 
            // executed by other threads
            //

            EnqueueThreadTask(
                &GlobalQueue,
                pTask,
                FALSE );
        }

    }

    //
    // Now, kill off all the threads
    //

    pQueue->Type = QueueZombie ;

    //
    // We might be executing on our own worker thread.  If there are
    // more than one thread associated with this queue, we also
    // need to do the sync.
    //

    if ( ( pQueue->OwnerSession != ThreadSession ) ||
         ( pQueue->TotalThreads > 1 ) )
         
    {
        //
        // We are not a worker thread.  Sync with the other
        // threads to clean up:
        //

        pQueue->StartSync = CreateEvent( NULL, FALSE, FALSE, NULL );

        //
        // Kick the semaphore for all the threads that need it 
        // (all of them if we aren't a worker thread, or n-1 if
        // we are:
        //

        ReleaseSemaphore( 
                pQueue->hSemaphore, 
                (pQueue->OwnerSession == ThreadSession ? 
                        pQueue->TotalThreads - 1 :
                        pQueue->TotalThreads), 
                NULL );

        UnlockQueue( pQueue );

        //
        // if we failed to create an event, then we may cause an invalid handle
        // problem in the client threads.  Sleep a little to let the other threads
        // go (hopefully), then close the semaphore and let the error handling
        // in the threads deal with it.
        //

        if ( pQueue->StartSync )
        {
            WaitForSingleObjectEx( pQueue->StartSync, INFINITE, FALSE );

            //
            // Synchronize with the last thread to own the queue:
            //

            LockQueue( pQueue );

            CloseHandle( pQueue->StartSync );
            pQueue->StartSync = NULL ;
        }
        else
        {
            //
            // kludge up a retry loop:
            //
            int i = 50 ;

            while ( i && pQueue->TotalThreads )
            {
                Sleep( 100 );
                i-- ;
            }

            //
            // If they're still there, forget it.  Return FALSE.  Leak.
            //
            if ( pQueue->TotalThreads )
            {
                return FALSE ;
            }

        }
    }



    //
    // At this point, we close the queue down:
    //

    FlagInfo.Inherit = FALSE ;
    FlagInfo.ProtectFromClose = FALSE ;

    NtSetInformationObject(
            pQueue->hSemaphore,
            ObjectHandleFlagInformation,
            &FlagInfo,
            sizeof( FlagInfo ) );

    CloseHandle( pQueue->hSemaphore );

    UnlockQueue( pQueue );

    RtlDeleteCriticalSection( &pQueue->Lock );

    LsapFreePrivateHeap( pQueue );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\util.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        util.c
//
// Contents:    General Purpose functions for the security interface
//
// Functions:   SPException         -- Handler for exceptions in packages
//              WLsaControlFunction -- Worker for SecurityPackageControl()
//              LsaControlFunction  -- User mode stub
//              LsaQueryPackage     -- User mode stub
//
//
// History:     14 Aug 92   RichardW    Created
//
//------------------------------------------------------------------------

#include <lsapch.hxx>
extern "C"
{
#include "sesmgr.h"
#include "spdebug.h"
#include "perf.hxx"
}



NTSTATUS GetMemStats(PUCHAR, DWORD *);

#if DBG
SpmExceptDbg    ExceptDebug;
DWORD           FaultingTid;
extern SpmDbg_MemoryFailure MemFail;
#endif // DBG


typedef SecurityUserData SECURITY_USER_DATA, *PSECURITY_USER_DATA;

//+---------------------------------------------------------------------------
//
//  Function:   SpExceptionFilter
//
//  Synopsis:   General Exception filter, invoked by the SP_EXCEPTION macro.
//
//  Arguments:  [pSession]   --
//              [pException] --
//
//
//  History:    8-09-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG
SpExceptionFilter(  PVOID                   pSession,
                    EXCEPTION_POINTERS *    pException)
{
    DWORD_PTR CurrentPackage;
    PLSAP_SECURITY_PACKAGE pPackage = NULL;
    UNICODE_STRING LsaString = { 3 * sizeof( WCHAR ), 4 * sizeof( WCHAR ), L"LSA" };

#if DBG

    DsysException(pException);

    PSpmExceptDbg   pExcept;

    pExcept = (PSpmExceptDbg) TlsGetValue(dwExceptionInfo);
    if (!pExcept)
    {
        pExcept = &ExceptDebug;
        TlsSetValue(dwExceptionInfo, pExcept);
    }

    FaultingTid = GetCurrentThreadId();
    pExcept->ThreadId = GetCurrentThreadId();
    pExcept->pInstruction = pException->ExceptionRecord->ExceptionAddress;
    pExcept->Access = pException->ExceptionRecord->ExceptionInformation[0];
    pExcept->pMemory = (void *) pException->ExceptionRecord->ExceptionInformation[1];

#endif

    CurrentPackage = GetCurrentPackageId();

    if (CurrentPackage != SPMGR_ID)
    {
        pPackage = SpmpLocatePackage( CurrentPackage );
    }

    SpmpReportEventU(
        EVENTLOG_ERROR_TYPE,
        SPMEVENT_PACKAGE_FAULT,
        CATEGORY_SPM,
        sizeof(EXCEPTION_RECORD),
        pException->ExceptionRecord,
        1,
        ((CurrentPackage == SPMGR_ID || pPackage == NULL) ? 
           &LsaString :
           &pPackage->Name )
        );

    return(EXCEPTION_EXECUTE_HANDLER);
}



//+-------------------------------------------------------------------------
//
//  Function:   SPException
//
//  Synopsis:   Handles an exception in a security package
//
//  Effects:    Varies, but may force an unload of a package.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
SPException(NTSTATUS  scRet,
            ULONG_PTR dwPackageID)
{
    PSession                pSession;
    PLSAP_SECURITY_PACKAGE             pPackage;
#if DBG
    PSpmExceptDbg           pException = (PSpmExceptDbg) TlsGetValue(dwExceptionInfo);
#endif

    pSession = GetCurrentSession();

    DebugLog((DEB_ERROR, "[%x] Exception in a package, code %x\n", pSession->dwProcessID, scRet));

    DebugLog((DEB_ERROR, "[%x] Address was @%x, %s address %x\n",
            pSession->dwProcessID,
            pException->pInstruction,
            (pException->Access ? "write" : "read"),
            pException->pMemory));



    if (dwPackageID == SPMGR_ID)
    {
        DebugLog((DEB_ERROR, "  LSA itself hit a fault, thread %d\n", GetCurrentThreadId()));
        DebugLog((DEB_ERROR, "  (ExceptionInfo @%x)\n", TlsGetValue(dwExceptionInfo)));
#if DBG
        DsysAssertMsg( 0, "exception in LSA" );
#endif
        return(scRet);
    }

    pPackage = SpmpLocatePackage( dwPackageID );

    if (!pPackage)
    {
        DebugLog((DEB_ERROR, "  Invalid package ID passed\n"));
        return(scRet);
    }

    if ((scRet == STATUS_ACCESS_VIOLATION) ||
        (scRet == E_POINTER))
    {
        DebugLog((DEB_ERROR, "  Package %ws created an access violation\n",
                        pPackage->Name.Buffer));


        // Flag package as invalid

        pPackage->fPackage |= SP_INVALID;
    }

    if ((scRet == STATUS_NO_MEMORY) ||
        (scRet == STATUS_INSUFFICIENT_RESOURCES))
    {
        DebugLog((DEB_ERROR, "  Out of memory situation exists\n"));
        DebugLog((DEB_ERROR, "  Further requests may fail unless memory is freed\n"));
    }

    //
    // if the code is a success code, it is probably a WIN32 error so we
    // map it as such


    return(scRet);
}





//+-------------------------------------------------------------------------
//
//  Function:   WLsaQueryPackage
//
//  Synopsis:   Get info on a package (short enum), copy to client's address
//              space
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaQueryPackageInfo(
    PSECURITY_STRING    pPackageName,
    PSecPkgInfo *       ppInfo
    )
{
    NTSTATUS                scRet;
    PLSAP_SECURITY_PACKAGE  pPackage;
    WCHAR *                 pszString;
    PSession                pSession = GetCurrentSession();
    ULONG                   cbData;
    PSecPkgInfo             pClientInfo = NULL;
    PBYTE                   Where;
    UNICODE_STRING          CommentString;
    UNICODE_STRING          NameString;
    PSecPkgInfo             pLocalInfo = NULL;
    SecPkgInfo              PackageInfo = { 0 };
    LONG_PTR                ClientOffset;
    ULONG                   ulStructureSize = sizeof(SecPkgInfo);

    DebugLog((DEB_TRACE, "QueryPackage\n"));
    *ppInfo = NULL;

    pPackage = SpmpLookupPackage(pPackageName);

    if (!pPackage)
    {
        return(STATUS_NO_SUCH_PACKAGE);
    }

    SetCurrentPackageId(pPackage->dwPackageID);

    StartCallToPackage( pPackage );

    __try
    {
        scRet = pPackage->FunctionTable.GetInfo(&PackageInfo);
    }
    __except (SP_EXCEPTION)
    {
        scRet = GetExceptionCode();
        scRet = SPException(scRet, pPackage->dwPackageID);
    }

    EndCallToPackage( pPackage );

    if (FAILED(scRet))
    {
        return(scRet);
    }

    //
    // Marshall the data to copy to the client
    //

    RtlInitUnicodeString(
        &NameString,
        PackageInfo.Name
        );

    RtlInitUnicodeString(
        &CommentString,
        PackageInfo.Comment
        );


    cbData = ulStructureSize +
            NameString.MaximumLength +
            CommentString.MaximumLength;

    pLocalInfo = (PSecPkgInfo) LsapAllocatePrivateHeap(cbData);
    if (pLocalInfo == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    pClientInfo = (PSecPkgInfo) LsapClientAllocate(cbData);
    if (pClientInfo == NULL)
    {
        LsapFreePrivateHeap(pLocalInfo);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    ClientOffset = (LONG_PTR) ((PBYTE) pClientInfo - (PBYTE) pLocalInfo);

    Where = (PBYTE) (pLocalInfo + 1);

    *pLocalInfo = PackageInfo;
    pLocalInfo->Name = (LPWSTR) (Where + ClientOffset);
    RtlCopyMemory(
        Where,
        NameString.Buffer,
        NameString.MaximumLength
        );
    Where += NameString.MaximumLength;

    pLocalInfo->Comment = (LPWSTR) (Where + ClientOffset);
    RtlCopyMemory(
        Where,
        CommentString.Buffer,
        CommentString.MaximumLength
        );
    Where += CommentString.MaximumLength;

    DsysAssert(Where - (PBYTE) pLocalInfo == (LONG) cbData);

    scRet = LsapCopyToClient(
                pLocalInfo,
                pClientInfo,
                cbData);
    LsapFreePrivateHeap(pLocalInfo);

    if (FAILED(scRet))
    {
        LsapClientFree(pClientInfo);
    }

    *ppInfo = pClientInfo;

    return(scRet);
}


//+-------------------------------------------------------------------------
//
//  Function:   WLsaGetSecurityUserInfo
//
//  Synopsis:   worker function to get info about a logon session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
WLsaGetSecurityUserInfo(
    IN PLUID pLogonId,
    IN ULONG fFlags,
    OUT PSECURITY_USER_DATA * pUserInfo
    )
{
    PLSAP_LOGON_SESSION  pSession;
    NTSTATUS             Status;
    PSECURITY_USER_DATA  LocalUserData = NULL;
    PSECURITY_USER_DATA  ClientBuffer = NULL;
    SECPKG_CLIENT_INFO   ClientInfo;
    ULONG BufferSize;
    PUCHAR Where;
    LONG_PTR Offset;
    ULONG                ulStructureSize = sizeof(SECURITY_USER_DATA);

    DebugLog((DEB_TRACE_WAPI,"WLsaGetSecurityUserInfo called\n"));

    //
    // if the logon ID is null, it is for the caller
    // so we know to go to the primary package.
    //

    if (pLogonId == NULL)
    {
        Status = LsapGetClientInfo(&ClientInfo);

        if (!NT_SUCCESS(Status))
        {
            return(Status);
        }

        pLogonId = &ClientInfo.LogonId;
    }

    pSession = LsapLocateLogonSession( pLogonId );

    if (!pSession)
    {
        DebugLog((DEB_WARN,"WLsaGetSecurityUserInfo called for non-existent LUID 0x%x:0x%x\n",
                        pLogonId->LowPart,pLogonId->HighPart));

        Status = STATUS_NO_SUCH_LOGON_SESSION;

        goto Cleanup;
    }

    BufferSize = ulStructureSize +
                    pSession->AccountName.Length +
                    pSession->AuthorityName.Length +
                    pSession->LogonServer.Length +
                    RtlLengthSid(pSession->UserSid);

    LocalUserData = (PSECURITY_USER_DATA) LsapAllocatePrivateHeap(BufferSize);

    if (LocalUserData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ClientBuffer = (PSECURITY_USER_DATA) LsapClientAllocate(BufferSize);

    if (ClientBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Offset = (LONG_PTR) ((PUCHAR) ClientBuffer - (PUCHAR) LocalUserData);

    Where = (PUCHAR) (LocalUserData + 1);

    //
    // Copy in all the fields from the logon session.
    //

    LocalUserData->pSid = (PSID) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->UserSid,
        RtlLengthSid(pSession->UserSid)
        );
    Where += RtlLengthSid(pSession->UserSid);

    //
    // Copy in the user name
    //

    LocalUserData->UserName.Length =
    LocalUserData->UserName.MaximumLength = pSession->AccountName.Length;
    LocalUserData->UserName.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->AccountName.Buffer,
        pSession->AccountName.Length
        );
    Where += pSession->AccountName.Length;

    //
    // Copy in the domain name
    //

    LocalUserData->LogonDomainName.Length =
        LocalUserData->LogonDomainName.MaximumLength = pSession->AuthorityName.Length;

    LocalUserData->LogonDomainName.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->AuthorityName.Buffer,
        pSession->AuthorityName.Length
        );
    Where += pSession->AuthorityName.Length;

    //
    // Copy in the logon server
    //

    LocalUserData->LogonServer.Length =
        LocalUserData->LogonServer.MaximumLength = pSession->LogonServer.Length;

    LocalUserData->LogonServer.Buffer = (LPWSTR) (Where + Offset);

    RtlCopyMemory(
        Where,
        pSession->LogonServer.Buffer,
        pSession->LogonServer.Length
        );
    Where += pSession->LogonServer.Length;


    //
    // Copy this to the client
    //

    LsapReleaseLogonSession( pSession );

    Status = LsapCopyToClient(
                LocalUserData,
                ClientBuffer,
                BufferSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *pUserInfo = ClientBuffer;
    ClientBuffer = NULL;

Cleanup:

    if (LocalUserData != NULL)
    {
        LsapFreePrivateHeap(LocalUserData);
    }

    if (ClientBuffer != NULL)
    {
        LsapClientFree(ClientBuffer);
    }

    DebugLog((DEB_TRACE_WAPI,"GetUserInfo returned %x\n",Status));
    return(Status);
}


HANDLE  hEventLog = INVALID_HANDLE_VALUE;
DWORD   LoggingLevel = (1 << EVENTLOG_ERROR_TYPE) | (1 << EVENTLOG_WARNING_TYPE) |
                       (1 << EVENTLOG_INFORMATION_TYPE) ;
WCHAR   EventSourceName[] = TEXT("LsaSrv");

#define MAX_EVENT_STRINGS 8

//+---------------------------------------------------------------------------
//
//  Function:   SpmpInitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SpmpInitializeEvents(void)
{

    HKEY    hKey;
    int     err;
    DWORD   disp;

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\LsaSrv"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);
    if (err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\lsasrv.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\lsasrv.dll")) );

        RegSetValueEx(  hKey,
                        TEXT("CategoryMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\lsasrv.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\lsasrv.dll")) );

        disp = 7;
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );
        disp = CATEGORY_MAX_CATEGORY - 1;
        RegSetValueEx(  hKey,
                        TEXT("CategoryCount"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );


    }

    RegCloseKey(hKey);


    hEventLog = RegisterEventSource(NULL, EventSourceName);
    if (hEventLog)
    {
        return(TRUE);
    }

    hEventLog = INVALID_HANDLE_VALUE;

    DebugLog((DEB_ERROR, "Could not open event log, error %d\n", GetLastError()));
    return(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReportServiceEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SpmpReportEvent(
    IN BOOL Unicode,
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    PSTR StringsA[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (hEventLog == INVALID_HANDLE_VALUE)
    {
        if (!SpmpInitializeEvents())
        {
            return((DWORD) -1);
        }
    }

    //
    // We're not supposed to be logging this, so nuke it
    //
    if ((LoggingLevel & (1 << EventType)) == 0)
    {
        return(0);
    }

    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) {
        if (Unicode)
        {
            Strings[ i ] = va_arg( arglist, PWSTR );
        }
        else
        {
            StringsA[ i ] = va_arg( arglist, PSTR );
        }
    }


    //
    // Report the event to the eventlog service
    //

    if (Unicode)
    {
        if (!ReportEventW(  hEventLog,
                            EventType,
                            (WORD) Category,
                            EventId,
                            NULL,
                            (WORD)NumberOfStrings,
                            SizeOfRawData,
                            (const WCHAR * *) Strings,
                            RawData) )
        {
            rv = GetLastError();
            DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));

        }
        else
        {
            rv = ERROR_SUCCESS;
        }
    }
    else
    {
        if (!ReportEventA(  hEventLog,
                            EventType,
                            (WORD) Category,
                            EventId,
                            NULL,
                            (WORD)NumberOfStrings,
                            SizeOfRawData,
                            (const char * *) StringsA,
                            RawData) )
        {
            rv = GetLastError();
            DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, GetLastError() ));

        }
        else
        {
            rv = ERROR_SUCCESS;
        }

    }

    return rv;
}

//+---------------------------------------------------------------------------
//
//  Function:   SpmpReportEventU
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PUNICODE_STRINGs to string data
//
//  Notes:
//
//----------------------------------------------------------------------------

DWORD
SpmpReportEventU(
    IN WORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PUNICODE_STRING Strings[ MAX_EVENT_STRINGS ];
    DWORD rv;

    if (hEventLog == INVALID_HANDLE_VALUE) {

        if ( !SpmpInitializeEvents()) {

            return( -1 );
        }
    }

    //
    // We're not supposed to be logging this, so nuke it
    //

    if (( LoggingLevel & ( 1 << EventType )) == 0 ) {

        return( 0 );
    }

    //
    // Look at the strings, if they were provided
    //

    va_start( arglist, NumberOfStrings );

    if ( NumberOfStrings > MAX_EVENT_STRINGS ) {

        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for ( i = 0 ; i < NumberOfStrings ; i++ ) {

        Strings[ i ] = va_arg( arglist, PUNICODE_STRING );
    }

    //
    // Report the event to the eventlog service
    //

    rv = ElfReportEventW(
             hEventLog,
             EventType,
             ( USHORT )Category,
             EventId,
             NULL,
             ( USHORT )NumberOfStrings,
             SizeOfRawData,
             Strings,
             RawData,
             0,
             NULL,
             NULL
             );

    if ( !NT_SUCCESS( rv )) {

        DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, rv ));
        goto Cleanup;
    }

    rv = ERROR_SUCCESS;

Cleanup:

    return rv;
}

BOOL
SpmpShutdownEvents(void)
{
    return(DeregisterEventSource(hEventLog));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtbuild.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtbuild.c

Abstract:

    Local Security Authority - Audit Log Management

    Functions in this module build unicode strings for
    various parameter types.  Some parameter string build
    routines may also be found in other modules (such as
    LsapAdtBuildAccessesString() in adtobjs.c).

Author:

    Jim Kelly           (JimK)         29-Oct-1992


Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"

#ifndef LSAP_ADT_UMTEST
//
// pick up definitions of privately callable LSA services ONLY if we
// aren't building a user mode test.
//


#endif








////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Local Macro definitions and local function prototypes             //
//                                                                    //
////////////////////////////////////////////////////////////////////////



#ifdef LSAP_ADT_UMTEST

//
// Define all external routines that we won't pick up in a user mode test
//

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );



#endif



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtBuildUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a decimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 10 digits & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }




    Status = RtlIntegerToUnicodeString( Value, 10, ResultantString );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildHexUlongString(
    IN ULONG Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed value.

    The resultant string will be formatted as a hexidecimal value with not
    more than 10 digits.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;



    //
    // Maximum length is 10 wchar characters plus a null termination character.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 11 * sizeof(WCHAR); // 8 digits, a 0x, & null termination

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }


    ResultantString->Buffer[0] = L'0';
    ResultantString->Buffer[1] = L'x';
    ResultantString->Buffer += 2;


    Status = RtlIntegerToUnicodeString( Value, 16, ResultantString );
    ASSERT(NT_SUCCESS(Status));

    //
    // Subtract off the two
    //

    ResultantString->Buffer -= 2;
    ResultantString->Length += 2 * sizeof(WCHAR);

    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildPtrString(
    IN  PVOID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed pointer.

    The resultant string will be formatted as a decimal value.


Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT NumChars;
    
    ResultantString->Length        = 0;
    //
    // Maximum length: sign (+ / -) + 20 decimal digits + null + 2 bonus == 24 chars
    //
    ResultantString->MaximumLength = 24 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
    
        Status = STATUS_NO_MEMORY;

    } else {
    
        NumChars = (USHORT) wsprintf( ResultantString->Buffer, L"%Id", Value );

        ResultantString->Length = NumChars * sizeof(WCHAR);

        (*FreeWhenDone) = TRUE;
    }
    
    return Status;
}


NTSTATUS
LsapAdtBuildLuidString(
    IN PLUID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        (0x00005678,0x12340000)

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;
    UNICODE_STRING          IntegerString;
    WCHAR                   Buffer[16];


    IntegerString.Buffer = (PWCHAR)&Buffer[0];
    IntegerString.MaximumLength = sizeof(Buffer);


    //
    // Length (in WCHARS) is  3 for   (0x
    //                       10 for   1st hex number
    //                        3 for   ,0x
    //                       10 for   2nd hex number
    //                        1 for   )
    //                        1 for   null termination
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = 28 * sizeof(WCHAR);

    ResultantString->Buffer = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               ResultantString->MaximumLength);
    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }



    Status = RtlAppendUnicodeToString( ResultantString, L"(0x" );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlIntegerToUnicodeString( Value->HighPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));


    Status = RtlAppendUnicodeToString( ResultantString, L",0x" );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlIntegerToUnicodeString( Value->LowPart, 16, &IntegerString );
    ASSERT(NT_SUCCESS(Status));
    Status = RtlAppendUnicodeToString( ResultantString, IntegerString.Buffer );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAppendUnicodeToString( ResultantString, L")" );
    ASSERT(NT_SUCCESS(Status));


    (*FreeWhenDone) = TRUE;
    return(STATUS_SUCCESS);



}


NTSTATUS
LsapAdtBuildSidString(
    IN PSID Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed LUID.

    The resultant string will be formatted as follows:

        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status=STATUS_NO_MEMORY;
    LPWSTR   UniBuffer=NULL;
    USHORT   Len;
    USHORT   MaxLen;
    
    *FreeWhenDone = FALSE;
    //
    // Note: RtlConvertSidToUnicodeString also uses a hard-coded const 256
    //       to generate the string SID.
    //
    MaxLen    = (256+3) * sizeof(WCHAR);
    UniBuffer = LsapAllocateLsaHeap(MaxLen);

    if (UniBuffer)
    {
        ResultantString->Buffer        = UniBuffer+2;
        ResultantString->MaximumLength = MaxLen;
        Status = RtlConvertSidToUnicodeString( ResultantString, Value, FALSE );

        if (Status == STATUS_SUCCESS)
        {
            *FreeWhenDone = TRUE;
            UniBuffer[0] = L'%';
            UniBuffer[1] = L'{';
            Len = ResultantString->Length / sizeof(WCHAR);
            UniBuffer[Len+2] = L'}';
            UniBuffer[Len+3] = UNICODE_NULL;
            ResultantString->Buffer = UniBuffer;
            ResultantString->Length = (Len+3)*sizeof(WCHAR);
        }
        else
        {
            LsapFreeLsaHeap(UniBuffer);
        }
    }

    return(Status);
}



NTSTATUS
LsapAdtBuildDashString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function returns a string containing a dash ("-").
    This is commonly used to represent "No value" in audit records.


Arguments:


    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_SUCCESS only.

--*/

{
    RtlInitUnicodeString(ResultantString, L"-");

    (*FreeWhenDone) = FALSE;

    return STATUS_SUCCESS;
}




NTSTATUS
LsapAdtBuildFilePathString(
    IN PUNICODE_STRING Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed file
    path name.  If possible, the string will be generated using drive
    letters instead of object architecture namespace.


Arguments:

    Value - The original file path name.  This is expected (but does not
        have to be) a standard NT object architecture name-space pathname.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;



    //
    // For now, don't do the conversion.
    // Do this if we have time before we ship.
    //

    ResultantString->Length        = Value->Length;
    ResultantString->Buffer        = Value->Buffer;
    ResultantString->MaximumLength = Value->MaximumLength;


    (*FreeWhenDone) = FALSE;
    return(Status);
}




NTSTATUS
LsapAdtBuildLogonIdStrings(
    IN PLUID LogonId,
    OUT PUNICODE_STRING ResultantString1,
    OUT PBOOLEAN FreeWhenDone1,
    OUT PUNICODE_STRING ResultantString2,
    OUT PBOOLEAN FreeWhenDone2,
    OUT PUNICODE_STRING ResultantString3,
    OUT PBOOLEAN FreeWhenDone3
    )

/*++

Routine Description:

    This function builds a 3 unicode strings representing the specified
    logon ID.  These strings will contain the username, domain, and
    LUID string of the specified logon session (respectively).


Arguments:

    Value - The logon ID.

    ResultantString1 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone1 - If TRUE, indicates that the buffer of ResultantString1
        must be freed to process heap when no longer needed.

    ResultantString2 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone2 - If TRUE, indicates that the buffer of ResultantString2
        must be freed to process heap when no longer needed.

    ResultantString3 - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

        This parameter will contain the username.


    FreeWhenDone3 - If TRUE, indicates that the buffer of ResultantString3
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                Status;

    //
    // Try to convert the LUID first.
    //

    Status = LsapAdtBuildLuidString( LogonId, ResultantString3, FreeWhenDone3 );

    if (NT_SUCCESS(Status)) {


        //
        // Now get the username and domain names
        //

        Status = LsapGetLogonSessionAccountInfo( LogonId,
                                                 ResultantString1,
                                                 ResultantString2
                                                 );

        if (NT_SUCCESS(Status)) {

            (*FreeWhenDone1) = TRUE;
            (*FreeWhenDone2) = TRUE;

        } else {

            //
            // The LUID may be the system LUID
            //

            LUID SystemLuid = SYSTEM_LUID;

            if ( RtlEqualLuid( LogonId, &SystemLuid )) {

                RtlInitUnicodeString(ResultantString1, L"SYSTEM");
                RtlInitUnicodeString(ResultantString2, L"SYSTEM");

                (*FreeWhenDone1) = FALSE;
                (*FreeWhenDone2) = FALSE;

                Status = STATUS_SUCCESS;

            } else {

                //
                // We have no clue what this is, just free what we've
                // allocated.
                //

                if ((FreeWhenDone3)) {
                    LsapFreeLsaHeap( ResultantString3->Buffer );
                }
            }
        }
    }

    return(Status);

}



NTSTATUS
LsapAdtBuildTimeString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed time.

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_UNSUCCESSFUL;
    BOOL        b             = TRUE;
    SYSTEMTIME  SystemTime    = {0};
    FILETIME    LocalFileTime = {0};
    USHORT      Length        = 0;
    WCHAR       DataString[1024];

    //
    // First convert time to readable format.
    //

    b = FileTimeToLocalFileTime(
            (PFILETIME)Value,
            &LocalFileTime
            );

    if (!b) {
        return Status;
    }

    b = FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

    if (!b) {
        return Status;
    }

    if (0 == GetTimeFormat(
                LOCALE_USER_DEFAULT,
                0,
                &SystemTime,
                NULL,
                DataString,
                1024
                )) {
        
        return Status;
    }

    Length = (USHORT) wcslen( DataString );

    ResultantString->MaximumLength = sizeof(WCHAR) * Length;
    ResultantString->Length        = sizeof(WCHAR) * Length;
    ResultantString->Buffer        = RtlAllocateHeap(
                                         RtlProcessHeap(),
                                         0,
                                         sizeof(WCHAR) * Length
                                         );

    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        ResultantString->Buffer,
        DataString,
        sizeof(WCHAR) * Length
        );

    *FreeWhenDone = TRUE;
    
    return STATUS_SUCCESS;
}



NTSTATUS
LsapAdtBuildDateString(
    IN PLARGE_INTEGER Value,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed date.

Arguments:

    Value - The value to be transformed to printable format (Unicode string).

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS    Status        = STATUS_UNSUCCESSFUL;
    BOOL        b             = TRUE;
    SYSTEMTIME  SystemTime    = {0};
    FILETIME    LocalFileTime = {0};
    USHORT      Length        = 0;
    WCHAR       DataString[1024];

    //
    // First convert time to readable format.
    //

    b = FileTimeToLocalFileTime(
            (PFILETIME)Value,
            &LocalFileTime
            );

    if (!b) {
        return Status;
    }

    b = FileTimeToSystemTime(
            &LocalFileTime,
            &SystemTime
            );

    if (!b) {
        return Status;
    }

    if (0 == GetDateFormat(
                LOCALE_USER_DEFAULT,
                0,
                &SystemTime,
                NULL,
                DataString,
                1024
                )) {

        return Status;
    }

    Length = (USHORT) wcslen( DataString );
    
    ResultantString->MaximumLength = sizeof(WCHAR) * Length;
    ResultantString->Length        = sizeof(WCHAR) * Length;
    ResultantString->Buffer        = RtlAllocateHeap(
                                         RtlProcessHeap(),
                                         0,
                                         sizeof(WCHAR) * Length
                                         );

    if (ResultantString->Buffer == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        ResultantString->Buffer,
        DataString,
        sizeof(WCHAR) * Length
        );

    *FreeWhenDone = TRUE;
    
    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtBuildGuidString(
    IN  LPGUID pGuid,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string representing the passed GUID.

Arguments:

    pGuid - The GUID to be transformed to printable format.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.
        The string will be in this format:
        "{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}"

    FreeWhenDone - If TRUE, indicates that the buffer of the ResultantString
        must be freed to process heap when no longer needed.


Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        for the string body.
--*/

{
    //
    // num chars required to hold {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
    //

#define NUM_GUID_STRING_CHARS 38

    NTSTATUS Status        = STATUS_UNSUCCESSFUL;

    ResultantString->Length        = NUM_GUID_STRING_CHARS*sizeof(WCHAR);
    ResultantString->MaximumLength = (NUM_GUID_STRING_CHARS+1)*sizeof(WCHAR);

    ResultantString->Buffer =
        LsapAllocateLsaHeap(ResultantString->MaximumLength);
    
    if (!ResultantString->Buffer)
    {
        *FreeWhenDone = FALSE;
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    *FreeWhenDone = TRUE;
    Status = STATUS_SUCCESS;
    
#if DBG
    {
    ULONG   NumChars;
    NumChars =
#endif
    swprintf(ResultantString->Buffer,
             L"{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
             pGuid->Data1,
             pGuid->Data2,
             pGuid->Data3,
             pGuid->Data4[0],
             pGuid->Data4[1],
             pGuid->Data4[2],
             pGuid->Data4[3],
             pGuid->Data4[4],
             pGuid->Data4[5],
             pGuid->Data4[6],
             pGuid->Data4[7]);
#if DBG
    ASSERT( NumChars == NUM_GUID_STRING_CHARS );
    }
#endif

 Cleanup:
    
    return Status;
}




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services private to this module.                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////




#ifdef LSAP_ADT_UMTEST

//
// Define this routine only for user mode test
//

NTSTATUS
LsapGetLogonSessionAccountInfo(
    IN PLUID Value,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )

{

    NTSTATUS        Status = STATUS_NO_MEMORY;


    if (RtlCreateUnicodeString( AccountName, L"Bullwinkle" )) {
        if (RtlCreateUnicodeString( AuthorityName, L"The Rocky Show" )) {
            Status = STATUS_SUCCESS;
        } else {
            RtlFreeHeap( RtlProcessHeap(), Accountame->Buffer );
        }
    }

    return(Status);




}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\suppcred.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1993
//
// File:        suppcred.h
//
// Contents:    prototypes for supplemental credential functions
//
//
// History:     9/29/93         MikeSw          Created
//
//------------------------------------------------------------------------


void
LsapFreeSupplementalCredentials(
    IN ULONG CredentialCount,
    IN PSECPKG_SUPPLEMENTAL_CRED pCredArray
    );

NTSTATUS
LsapReformatSupplementalCredentials(
    IN ULONG cSupplementalCreds,
    IN PSECPKG_SUPPLEMENTAL_CRED pSupplementalCreds,
    OUT PULONG CredentialCount,
    OUT PSECPKG_SUPPLEMENTAL_CRED * Credentials
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtevent.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtevent.c

Abstract:

    Functions that implement audits generated by LSA itself.

Author:

    Scott Birrell       (ScottBi)      January 19, 1993

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"



// ----------------------------------------------------------------------


//
// Lsa Global flags to indicate if we are auditing logon events.
//

BOOLEAN LsapAuditSuccessfulLogons = FALSE;
BOOLEAN LsapAuditFailedLogons = FALSE;


//
// Forwards
//
NTSTATUS
LsapAdtGetDbAttributesChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount,
    OUT LPWSTR* AttributeChangeString
    );


NTSTATUS
LsapAdtGenerateObjectOperationAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN USHORT AuditEventType,
    IN OBJECT_OPERATION_TYPE OperationType
    )
/*++

Routine Description:

    Generates an audit entry when an operation on the object
    represented by ObjectHandle succeds/fails and if this type of
    auditing is enabled.

Arguments:

    ObjectHandle - Handle of the object being accessed

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    OperationType - Type of operation performed on the object
        represented by ObjectHandle.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    UNICODE_STRING OperationTypeName;
    LSAP_DB_HANDLE InternalHandle;
    UNICODE_STRING ObjectName;
    LUID SystemAuthId = SYSTEM_LUID;
    
    static LPCWSTR ObjectOperationNames[ObjectOperationDummyLast] = {
        L"None",
        L"Query"
    };

    LsapEnterFunc("LsapAdtGenerateObjectAcessAuditEvent");

    if (!LsapAdtIsAuditingEnabledForCategory( AuditCategoryObjectAccess,
                                              AuditEventType)) {
        goto FunctionReturn;
    }
    
    InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    
    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    if ( RtlEqualLuid( &ClientAuthenticationId, &SystemAuthId )) {

        //
        // do not audit secret queries by the system
        //

        goto Cleanup;
    }
    
    //
    // LsarQuerySecret sometimes passes us a secret whose name will
    // be rejected by ElfReportEventW because the length parameter
    // includes the terminating NULL.
    // 
    // For example,
    //   name.Buffer        = "foo\0"
    //   name.Length        = 8
    //   name.MaximumLength = 8
    //   
    // We cannot change the input param or change the LSA code to
    // not do this, therfore we make a local copy, fix it
    // and use that instead
    //

    ObjectName = InternalHandle->PhysicalNameU;
    ObjectName.Length = (USHORT) LsapSafeWcslen( ObjectName.Buffer,
                                                 ObjectName.MaximumLength );
    
    //
    // Build an audit parameters structure.
    //
    RtlInitUnicodeString( &OperationTypeName, ObjectOperationNames[OperationType] );
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_OBJECT_ACCESS,
        SE_AUDITID_OBJECT_OPERATION,
        AuditEventType,
        11,                     // there are 11 params to init

        //
        //    User Sid
        //
        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    Operation Type
        //
        SeAdtParmTypeString,     &OperationTypeName,

        //
        //    Object Type : index of this is 3, used later
        //
        SeAdtParmTypeString,     &LsapDbObjectTypeNames[InternalHandle->
                                                       ObjectTypeId],

        //
        //    Object Name
        //
        SeAdtParmTypeString,     &ObjectName,

        //
        //    Object Handle ID
        //
        SeAdtParmTypePtr,      ObjectHandle,

        //
        // Primary Authentication information
        //
        SeAdtParmTypeLogonId,    LsapSystemLogonId,

        //
        // Clients's Authentication information
        //
        SeAdtParmTypeLogonId,    ClientAuthenticationId,

        //
        // Requested access : 3 is the index of ObjectType parameter
        //
        SeAdtParmTypeAccessMask, InternalHandle->RequestedAccess, 3,

        //
        // there are no object properties (object-type list)
        //
        SeAdtParmTypeNone,

        //
        // no additional information
        //
        SeAdtParmTypeNone
        
        );
    

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

Cleanup:
    
    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed( Status );
    }

FunctionReturn:
    LsapExitFunc("LsapAdtGenerateObjectAcessAuditEvent", Status);

    return Status;
}


NTSTATUS
LsapAdtGenerateLsaAuditEvent(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    )

/*++

Routine Description:

    This function generates an Lsa-originated Audit Event.  Audit Events
    of this kind are generated as a result of Local Security Policy changes
    such as assigning/removing user rights to an account.

Arguments:

    ObjectHandle - Specifies the handle of an object in the Lsa Policy
        Database.  For global changes to policy, a handle to the
        Lsa Policy object is passed.

    AuditEventCategory - Specifies the Id of the Audit Event Category
        to which this Audit Event belongs.

    AuditEventId - Specifies the Id of the Audit Event being generated.

    LuidCount - Count of Locally Unique Ids being passed via the Luids
        parameter.  If no Locally Unique Ids are passed, this parameter must
        be set to 0.

    Luids - Pointer to array of LuidCount Locally Unique Ids and their attributes.
        The attributes are ignored.  If 0 is passed for the LuidCount
        parameter, this parameter is ignored and NULL may be specified.

    SidCount - Count of Sids being passed via the Sids parameter.  If no
        Sids are passed, this parameter must be set to 0.

    Sids - Pointer to array of SidCount Sids.  If 0 is passed for the
        SidCount parameter, this parameter is ignored and NULL may be
        specified.

    UnicodeStringCount - Count of Unicode Strings being passed via the
        UnicodeStrings parameter.  If no Unicode Strings are passed, this
        parameter must be set to 0.

    UnicodeStrings - Pointer to array of UnicodeStringCount strings.  If 0 is
        passed for the SidCount parameter, this parameter is ignored and NULL
        may be specified.

    PolicyAuditEventsInfo - Pointer to Auditing Events information structure
        containing the AuditingMode and the array of Policy Audit Event
        Information entries.  This parameter must be non-NULL if and only if
        the AuditEventCategory parameter is SE_AUDIT_POLICY_CHANGE.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation = NULL;
    PSID ClientSid;


    UNREFERENCED_PARAMETER( ObjectHandle );

    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    ClientSid = TokenUserInformation->User.Sid;

    Status = LsapAdtGenerateLsaAuditEventWithClientSid( AuditEventCategory,
                                                        AuditEventId,
                                                        ClientSid,
                                                        ClientAuthenticationId,
                                                        Privileges,
                                                        SidCount,
                                                        Sids,
                                                        UnicodeStringCount,
                                                        UnicodeStrings,
                                                        PolicyAuditEventsInfo );



Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if ( !NT_SUCCESS( Status )) {

        LsapAuditFailed( Status );
    }
    
    return(Status);
}


NTSTATUS
LsapAdtGenerateLsaAuditEventWithClientSid(
    IN ULONG AuditEventCategory,
    IN ULONG AuditEventId,
    IN PSID ClientSid,
    IN LUID ClientAuthenticationId,
    IN PPRIVILEGE_SET Privileges,
    IN ULONG SidCount,
    IN PSID *Sids OPTIONAL,
    IN ULONG UnicodeStringCount,
    IN PUNICODE_STRING UnicodeStrings OPTIONAL,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo OPTIONAL
    )

/*++

Routine Description:

    This function generates an Lsa-originated Audit Event.  Audit Events
    of this kind are generated as a result of Local Security Policy changes
    such as assigning/removing user rights to an account.

Arguments:

    ObjectHandle - Specifies the handle of an object in the Lsa Policy
        Database.  For global changes to policy, a handle to the
        Lsa Policy object is passed.

    AuditEventCategory - Specifies the Id of the Audit Event Category
        to which this Audit Event belongs.

    AuditEventId - Specifies the Id of the Audit Event being generated.

    LuidCount - Count of Locally Unique Ids being passed via the Luids
        parameter.  If no Locally Unique Ids are passed, this parameter must
        be set to 0.

    Luids - Pointer to array of LuidCount Locally Unique Ids and their attributes.
        The attributes are ignored.  If 0 is passed for the LuidCount
        parameter, this parameter is ignored and NULL may be specified.

    SidCount - Count of Sids being passed via the Sids parameter.  If no
        Sids are passed, this parameter must be set to 0.

    Sids - Pointer to array of SidCount Sids.  If 0 is passed for the
        SidCount parameter, this parameter is ignored and NULL may be
        specified.

    UnicodeStringCount - Count of Unicode Strings being passed via the
        UnicodeStrings parameter.  If no Unicode Strings are passed, this
        parameter must be set to 0.

    UnicodeStrings - Pointer to array of UnicodeStringCount strings.  If 0 is
        passed for the SidCount parameter, this parameter is ignored and NULL
        may be specified.

    PolicyAuditEventsInfo - Pointer to Auditing Events information structure
        containing the AuditingMode and the array of Policy Audit Event
        Information entries.  This parameter must be non-NULL if and only if
        the AuditEventCategory parameter is SE_AUDIT_POLICY_CHANGE.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING NullString = {0};

    if (NULL == UnicodeStrings)
    {
        UnicodeStrings = &NullString;
    }

    UNREFERENCED_PARAMETER( UnicodeStringCount );
    UNREFERENCED_PARAMETER( SidCount );
    
    switch ( AuditEventCategory ) {
        case SE_CATEGID_POLICY_CHANGE:
            {
                switch ( AuditEventId ) {

                    default:
                        DsysAssertMsg(FALSE, "LsapAdtGenerateLsaAuditEventWithClientSid: invalid AuditEventId");
                        break;
                        
                    case SE_AUDITID_POLICY_CHANGE:
                        {

                            LsapAdtPolicyChange(
                                (USHORT)AuditEventCategory,
                                AuditEventId,
                                EVENTLOG_AUDIT_SUCCESS,
                                ClientSid,
                                ClientAuthenticationId,
                                PolicyAuditEventsInfo
                                );
                            break;
                        }

                    case SE_AUDITID_USER_RIGHT_ASSIGNED:
                    case SE_AUDITID_USER_RIGHT_REMOVED:
                        {

                            DsysAssertMsg( SidCount == 1,
                                           "LsapAdtGenerateLsaAuditEventWithClientSid" );
                            LsapAdtUserRightAssigned(
                                (USHORT)AuditEventCategory,
                                AuditEventId,
                                EVENTLOG_AUDIT_SUCCESS,
                                ClientSid,
                                ClientAuthenticationId,
                                Sids[0],
                                Privileges
                                );
                            break;
                        }
                }


            break;

            }

        default:
            {
                DsysAssertMsg( FALSE, "LsapAdtGenerateLsaAuditEventWithClientSid: unsupported audit category" );
                return( STATUS_SUCCESS );
            }
    }


    return(Status);
}


VOID
LsapAdtUserRightAssigned(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PPRIVILEGE_SET Privileges
    )
/*++

Routine Description:

    Generates an audit for a user right being either assigned or removed.


Arguments:


Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );
    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    //
    // Rights
    //

    LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Privileges );
    AuditParameters.ParameterCount++;

    //
    // Target Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, TargetSid );
    AuditParameters.ParameterCount++;

    //
    // Caller's Authentication information
    //

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, CallerAuthenticationId );
    AuditParameters.ParameterCount++;


    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}


VOID
LsapAdtGenerateLsaAuditSystemAccessChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PSID TargetSid,
    IN PCWSTR szSystemAccess
    )

/*++

Routine Description:

    Generates an audit for System Security Access changes.


Arguments:

    EventCategory - The category of this event
    EventID - specific ID of event
    EventType - success or failure
    ClientSid - sid of client
    CallerAuthenticationID - Logon ID of caller
    TargetSid - receives access change
    szSystemAccess - string describing which access changed

Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING SystemAccessString;

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    RtlInitUnicodeString( &SystemAccessString, szSystemAccess );
    LsapAdtInitParametersArray( &AuditParameters, 
                                EventCategory, 
                                EventID, 
                                EventType, 
                                5, 
                                SeAdtParmTypeSid,         ClientSid,
                                SeAdtParmTypeString,      &LsapSubsystemName,
                                SeAdtParmTypeLogonId,     CallerAuthenticationId,
                                SeAdtParmTypeString,      &SystemAccessString,
                                SeAdtParmTypeSid,         TargetSid
                                );

    (VOID) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}




NTSTATUS
LsapAdtTrustedDomainAdd(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN ULONG           Type,
    IN ULONG           Direction,
    IN ULONG           Attributes
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is created.

Arguments:

    EventType    - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pName        - name of the domain

    pSid         - domain SID

    Type         - TDO type

    Direction    - TDO direction

    Attributes   - TDO attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };

    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EventType ) )
    {
        goto Cleanup;
    }

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // Build an audit parameters structure.
    //
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_TRUSTED_DOMAIN_ADD,
        EventType,
        8,                     // there are 8 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    domain name
        //

        SeAdtParmTypeString,      pName,

        //
        //    domain id 
        //

        SeAdtParmTypeSid,         pSid,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     ClientAuthenticationId,
        
        //
        //    TDO type
        //

        SeAdtParmTypeUlong,       Type,

        //
        //    TDO direction
        //

        SeAdtParmTypeUlong,       Direction,

        //
        //    TDO attributes
        //

        SeAdtParmTypeUlong,       Attributes

        );
    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedDomainRem(
    IN USHORT          EventType,
    IN PUNICODE_STRING pName,
    IN PSID            pSid,
    IN PSID            pClientSid,
    IN PLUID           pClientAuthId
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is deleted.

Arguments:

    EventType    - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pName        - name of the domain

    pSid         - domain SID

    pClientSid   - SID of the client who deleted the TDO
                   if NULL, it is determined from the thread token

    pClientAuthId- auth-id of the client who deleted the TDO
                   if NULL, it is determined from the thread token

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };


    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EventType ) )
    {
        goto Cleanup;
    }

    if ( pClientSid == NULL )
    {
        DsysAssertMsg( pClientAuthId == NULL, "LsapAdtTrustedDomainRem" );
        
        Status = LsapQueryClientInfo( &TokenUserInformation,
                                      &ClientAuthenticationId );

        if ( !NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        pClientSid    = TokenUserInformation->User.Sid;
        pClientAuthId = &ClientAuthenticationId;
    }
#if DBG
    else
    {
        DsysAssertMsg( pClientAuthId != NULL, "LsapAdtTrustedDomainRem" );
    }
#endif

    //
    // Build an audit parameters structure.
    //
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_TRUSTED_DOMAIN_REM,
        EventType,
        5,                     // there are 5 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        pClientSid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    domain name
        //

        SeAdtParmTypeString,      pName,

        //
        //    domain id (SID of the root domain)
        //

        SeAdtParmTypeSid,         pSid,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     *pClientAuthId
        
        );
    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}



NTSTATUS
LsapAdtTrustedDomainMod(
    IN USHORT          EventType,
    IN PSID            pDomainSid,

    IN PUNICODE_STRING pOldName,
    IN ULONG           OldType,
    IN ULONG           OldDirection,
    IN ULONG           OldAttributes,

    IN PUNICODE_STRING pNewName,
    IN ULONG           NewType,
    IN ULONG           NewDirection,
    IN ULONG           NewAttributes
    )
/*++

Routine Description:

    Generate an audit event when a trusted domain object (TDO) is modified.
    the unmodified fields are represented by a '-' in the audit log.

Arguments:

    EventType       - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pOldName        - old name of the domain

    pOldSid         - old domain SID

    OldType         - old TDO type

    OldDirection    - old TDO direction

    OldAttributes   - old TDO attributes

    pNewName        - new name of the domain

    pNewSid         - new domain SID

    NewType         - new TDO type

    NewDirection    - new TDO direction

    NewAttributes   - new TDO attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    UNICODE_STRING TempName;

    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EventType ) )
    {
        goto Cleanup;
    }

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    AuditParameters.CategoryId     = SE_CATEGID_POLICY_CHANGE;
    AuditParameters.AuditId        = SE_AUDITID_TRUSTED_DOMAIN_MOD;
    AuditParameters.Type           = EventType;
    AuditParameters.ParameterCount = 8;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, 0, TokenUserInformation->User.Sid );

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, 1, &LsapSubsystemName );


    //
    // for all subsequent fields (except the domain SID),
    // output a value only if it changed.
    //

    //
    //    domain name
    //

    if ( pOldName && pNewName &&
         !RtlEqualUnicodeString( pOldName, pNewName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 2, pNewName );
    }

    //
    //    domain id
    //

    LsapSetParmTypeSid( AuditParameters, 3, pDomainSid );

    //
    //    client auth-id
    //

    LsapSetParmTypeLogonId( AuditParameters, 4, ClientAuthenticationId );

    //
    //    TDO type
    //

    if ( OldType != NewType )
    {
        LsapSetParmTypeUlong( AuditParameters, 5, NewType );
    }
    
    //
    //    TDO direction
    //

    if ( OldDirection != NewDirection )
    {
        LsapSetParmTypeUlong( AuditParameters, 6, NewDirection );
    }
    
    //
    //    TDO attributes
    //

    if ( OldAttributes != NewAttributes )
    {
        LsapSetParmTypeUlong( AuditParameters, 7, NewAttributes );
    }
    

    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestNamespaceCollision(
    IN LSA_FOREST_TRUST_COLLISION_RECORD_TYPE CollisionTargetType,
    IN PUNICODE_STRING pCollisionTargetName,
    IN PUNICODE_STRING pForestRootDomainName,
    IN PUNICODE_STRING pTopLevelName,
    IN PUNICODE_STRING pDnsName,
    IN PUNICODE_STRING pNetbiosName,
    IN PSID            pSid,
    IN ULONG           NewFlags
    )
/*++

Routine Description:

    This function generates the audit event that represents
    a namespace element collision.


Arguments:

    CollisionTargetType  - type of the collision target
        CollisionTdo  : indicates a collision with a namespace element of
                        another forest
        CollisionXref : indicates a collision with a domain in our forest 

    pCollisionTargetName -
        name of the collision target (TDO name or Xref name)

    pForestRootDomainName - name of other forest

    pTopLevelName - top level name  (NULL == not in conflict)

    pDnsName      - DNS domain name (this is NULL is TLN is non-NULL)

    pNetbiosName  - NetBIOS name    (NULL == not in conflict)

    pSid          - SID of domain   (NULL == not in conflict)

    NewFlags      - the new value of flags

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
#if DBG
    HANDLE hToken;
#endif
    DsysAssert(( CollisionTargetType == CollisionTdo ) ||
               ( CollisionTargetType == CollisionXref));
    DsysAssert( pCollisionTargetName != NULL );
    DsysAssert( pForestRootDomainName != NULL );

#if DBG
    if ( pTopLevelName )
    {
        DsysAssert( pDnsName     == NULL );
        DsysAssert( pNetbiosName == NULL );
        DsysAssert( pSid         == NULL );
    }
    else
    {
        DsysAssert( pDnsName != NULL );

        if ( pNetbiosName != NULL )
        {
            DsysAssert( pSid == NULL );
        }

        if ( pSid != NULL )
        {
            DsysAssert( pNetbiosName == NULL );
        }
    }
#endif

    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EVENTLOG_AUDIT_SUCCESS ) )
    {
        goto Cleanup;
    }

#if DBG
    //
    // make sure that this is called in the system context
    //

    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    DsysAssertMsg( Status == STATUS_NO_TOKEN, "LsapAdtTrustedForestNamespaceCollision" );

    if ( NT_SUCCESS(Status) )
    {
        NtClose( hToken );
    }
    else
    {
        Status = STATUS_SUCCESS;
    }
    
#endif

    //
    // Build an audit parameters structure.
    //
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_NAMESPACE_COLLISION,
        EVENTLOG_AUDIT_SUCCESS,

        //
        // number of params to follow 
        //

        10,

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        LsapLocalSystemSid,

        //
        //    Subsystem name (if available)
        //
        
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    collision target type
        //    
        //    0 == CollisionTdo
        //    1 == CollisionXref
        //    

        SeAdtParmTypeUlong,      CollisionTargetType,

        //
        //    collision target name
        //
        //    name of a TDO or cross-ref
        //    

        SeAdtParmTypeString,     pCollisionTargetName,
        
        //
        //    Name of forest involved in the collision
        //

        SeAdtParmTypeString,     pForestRootDomainName,

        //
        //    top level name
        //

        SeAdtParmTypeString,     pTopLevelName,

        //
        //    DNS name
        //

        SeAdtParmTypeString,     pDnsName,

        //
        //    NetBIOS name
        //

        SeAdtParmTypeString,     pNetbiosName,

        //
        //    SID
        //

        SeAdtParmTypeSid,        pSid,

        //
        //    new flags value
        //

        SeAdtParmTypeUlong,      NewFlags
        
        );

    Status = LsapAdtWriteLog( &AuditParameters, 0 );

Cleanup:    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestInfoEntryAddRemHelper(
    IN ULONG           EventId,
    IN USHORT          EventType,
    IN PUNICODE_STRING ForestName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
/*++

Routine Description:

    Helper function for generating audit event when a namespace
    element has been added to / removed from forest trust info.
    If multiple entries get added, deleted or modified
    in a single update of the forest trust information, all the generated
    audit events will have a single unique identifier called OperationID.
    This allows one to determine that the multiple generated audits are
    the result of a single operation.

Arguments:

    EventId              - SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_ADD/REM

    EventType            - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ForestName           - name of the forest

    pForestRootDomainSid - SID of the forest

    pOperationId         - operation id (see description above)

    EntryType            - type of entry ( TLN | TLN excl. | domain info )

    Flags                - flags associated with the entry ( see ntlsa.h )

    TopLevelName         - TopLevel name
                   
    DnsName              - Dns name
                   
    NetbiosName          - Netbios name

    pSid                 - domain sid

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };

    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EventType ) )
    {
        goto Cleanup;
    }

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // Build an audit parameters structure.
    //
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        EventId,
        EventType,

        //
        // number of params to follow 
        //

        13,

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    Forest name
        //

        SeAdtParmTypeString,     ForestName,

        //
        //    Forest SID
        //

        SeAdtParmTypeSid,        pForestRootDomainSid,

        //
        //    Operation ID
        //

        SeAdtParmTypeUlong,      pOperationId->HighPart,
        SeAdtParmTypeUlong,      pOperationId->LowPart,

        //
        //    Entry Type
        //

        SeAdtParmTypeUlong,      EntryType,

        //
        //    Flags
        //

        SeAdtParmTypeUlong,      Flags,

        //
        //    top level name
        //

        SeAdtParmTypeString,     TopLevelName,

        //
        //    DNS domain name
        //

        SeAdtParmTypeString,     DnsName,

        //
        //    NetBIOS domain name
        //

        SeAdtParmTypeString,     NetbiosName,

        //
        //    domain SID
        //

        SeAdtParmTypeSid,        pSid,

        //
        //    user info
        //

        SeAdtParmTypeLogonId,    ClientAuthenticationId
        );
    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}


NTSTATUS
LsapAdtTrustedForestInfoEntryAdd(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
{
    return LsapAdtTrustedForestInfoEntryAddRemHelper(
        SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_ADD,
        EVENTLOG_AUDIT_SUCCESS,
        pForestRootDomainName,
        pForestRootDomainSid,
        pOperationId,
        EntryType,
        Flags,
        TopLevelName,
        DnsName,
        NetbiosName,
        pSid
        );
}
     

NTSTATUS
LsapAdtTrustedForestInfoEntryRem(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
    IN ULONG           Flags,
    IN PUNICODE_STRING TopLevelName,
    IN PUNICODE_STRING DnsName,
    IN PUNICODE_STRING NetbiosName,
    IN PSID            pSid
    )
{
    return LsapAdtTrustedForestInfoEntryAddRemHelper(
        SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_REM,
        EVENTLOG_AUDIT_SUCCESS,
        pForestRootDomainName,
        pForestRootDomainSid,
        pOperationId,
        EntryType,
        Flags,
        TopLevelName,
        DnsName,
        NetbiosName,
        pSid
        );
}
     

NTSTATUS
LsapAdtTrustedForestInfoEntryMod(
    IN PUNICODE_STRING pForestRootDomainName,
    IN PSID            pForestRootDomainSid,
    IN PLUID           pOperationId,
    IN LSA_FOREST_TRUST_RECORD_TYPE EntryType,
                                    
    IN ULONG           OldFlags,
    IN PUNICODE_STRING pOldTopLevelName,
    IN PUNICODE_STRING pOldDnsName,
    IN PUNICODE_STRING pOldNetbiosName,
    IN PSID            pOldSid,
                       
    IN ULONG           NewFlags,
    IN PUNICODE_STRING pNewTopLevelName,
    IN PUNICODE_STRING pNewDnsName,
    IN PUNICODE_STRING pNewNetbiosName,
    IN PSID            pNewSid
    )
/*++

Routine Description:

    Helper function for generating audit event when a namespace
    element in forest trust info has been modified.
    If multiple entries get added, deleted or modified
    in a single update of the forest trust information, all the generated
    audit events will have a single unique identifier called OperationID.
    This allows one to determine that the multiple generated audits are
    the result of a single operation.

Arguments:

    EventType            - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ForestName           - name of the forest

    pForestRootDomainSid - SID of the forest

    pOperationId         - operation id (see description above)

    EntryType            - type of entry ( TLN | TLN excl. | domain info )

    OldFlags             - old flags associated with the entry ( see ntlsa.h )

    pOldTopLevelName     - old TopLevel name
                   
    pOldDnsName          - old Dns name
                   
    pOldNetbiosName      - old Netbios name

    pOldSid              - old domain sid

    NewFlags             - new flags associated with the entry ( see ntlsa.h )

    pNewTopLevelName     - new TopLevel name
                   
    pNewDnsName          - new Dns name
                   
    pNewNetbiosName      - new Netbios name

    pNewSid              - new domain sid

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

    The unmodified fields are represented by a '-' in the audit log.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };

    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryPolicyChange,
                                               EVENTLOG_AUDIT_SUCCESS ) )
    {
        goto Cleanup;
    }

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    AuditParameters.CategoryId     = SE_CATEGID_POLICY_CHANGE;
    AuditParameters.AuditId        = SE_AUDITID_TRUSTED_FOREST_INFO_ENTRY_MOD;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 13;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, 0, TokenUserInformation->User.Sid );

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, 1, &LsapSubsystemName );


    //
    //    forest name
    //

    LsapSetParmTypeString( AuditParameters, 2, pForestRootDomainName );

    //
    //    forest id (SID of the root domain)
    //

    LsapSetParmTypeSid( AuditParameters, 3, pForestRootDomainSid );

    //
    //    Operation ID
    //

    LsapSetParmTypeUlong( AuditParameters, 4, pOperationId->HighPart );
    LsapSetParmTypeUlong( AuditParameters, 5, pOperationId->LowPart );

    //
    //    entry type
    //

    LsapSetParmTypeUlong( AuditParameters, 6, EntryType );

    //
    // for all subsequent types, output a value only if it changed.
    //

    //
    //    Flags
    //

    if ( OldFlags != NewFlags )
    {
        LsapSetParmTypeUlong( AuditParameters, 7, NewFlags );
    }

    //
    //    top level name
    //

    if ( pOldTopLevelName && pNewTopLevelName &&
         !RtlEqualUnicodeString( pOldTopLevelName, pNewTopLevelName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 8, pNewTopLevelName );
    }

    //
    //    DNS domain name
    //

    if ( pOldDnsName && pNewDnsName &&
         !RtlEqualUnicodeString( pOldDnsName, pNewDnsName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 9, pNewDnsName );
    }

    //
    //    NetBIOS domain name
    //

    if ( pOldNetbiosName && pNewNetbiosName &&
         !RtlEqualUnicodeString( pOldNetbiosName, pNewNetbiosName, TRUE ) )
    {
        LsapSetParmTypeString( AuditParameters, 10, pNewNetbiosName );
    }

    //
    //    domain SID
    //

    if ( pOldSid && pNewSid && !RtlEqualSid( pOldSid, pNewSid ) )
    {
        LsapSetParmTypeSid( AuditParameters, 11, pNewSid );
    }
    
    //
    //    client auth-id
    //

    LsapSetParmTypeLogonId( AuditParameters, 12, ClientAuthenticationId );

    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
    
}



VOID
LsapAdtPolicyChange(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PSID ClientSid,
    IN LUID CallerAuthenticationId,
    IN PLSARM_POLICY_AUDIT_EVENTS_INFO PolicyAuditEventsInfo
    )
/*++

Routine Description:

    Generates an audit for a policy change event.

Arguments:

    EventCategory - The category of this audit.

    EventID - The event we are auditing.

    EventType - Whether the audit is success or failure.

    ClientSid - The SID of the user performing the policy change.

    CallerAuthenticationId - The Authentication id of the user.

    PolicyAuditEventsInfo - The information to audit.


Return Value:

    None.

Note:
--*/
{
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING Enabled;
    UNICODE_STRING Disabled;
    ULONG i;

    RtlInitUnicodeString( &Enabled, L"+" );
    RtlInitUnicodeString( &Disabled, L"-" );
    EventAuditingOptions = PolicyAuditEventsInfo->EventAuditingOptions;

    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );
    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    //
    // If auditing is disabled, mark all options as disabled. Otherwise
    // mark them as the appropriate
    //

    if (PolicyAuditEventsInfo->AuditingMode) {
        for ( i=0; i<POLICY_AUDIT_EVENT_TYPE_COUNT; i++ ) {

            LsapSetParmTypeString(
                AuditParameters,
                AuditParameters.ParameterCount,
                (EventAuditingOptions[i] & POLICY_AUDIT_EVENT_SUCCESS ? &Enabled : &Disabled)
                );

            AuditParameters.ParameterCount++;

            LsapSetParmTypeString(
                AuditParameters,
                AuditParameters.ParameterCount,
                (EventAuditingOptions[i] & POLICY_AUDIT_EVENT_FAILURE ? &Enabled : &Disabled)
                );

            AuditParameters.ParameterCount++;
        }
    } else {
        //
        // Auditing is disabled - mark them all disabled.
        //

        for ( i=0; i<POLICY_AUDIT_EVENT_TYPE_COUNT; i++ ) {

            LsapSetParmTypeString(
                AuditParameters,
                AuditParameters.ParameterCount,
                &Disabled
                );

            AuditParameters.ParameterCount++;

            LsapSetParmTypeString(
                AuditParameters,
                AuditParameters.ParameterCount,
                &Disabled
                );

            AuditParameters.ParameterCount++;
        }

    }

    //
    // Caller's Authentication information
    //

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, CallerAuthenticationId );
    AuditParameters.ParameterCount++;


    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}



NTSTATUS
LsapAdtGenerateDomainPolicyChangeAuditEvent(
    IN POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    IN USHORT AuditEventType,
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount
    )
/*++

Routine Description:

    Generate an audit event when any of the following policies changes:
    - PolicyDomainEfsInformation
    - PolicyDomainKerberosTicketInformation

Arguments:

    InformationClass - type of policy that changed

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    OldAttributes - pointer to array of old attributes

    NewAttributes - pointer to array of new attributes

    AttributeCount - number of attributes

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    ULONG AuditId;
    LPWSTR AttributeChanges=NULL;
    UNICODE_STRING ChangesToAttributes;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;

    AuditId=0;                  // to get rid of uninit var warning

    Status = LsapQueryClientInfo(
                 &TokenUserInformation,
                 &ClientAuthenticationId
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    switch (InformationClass) {
        default:
            ASSERT(FALSE);
            goto Cleanup;
            break;
            
        case PolicyDomainEfsInformation:
            AuditId = SE_AUDITID_EFS_POLICY_CHANGE;
            break;
        
        case PolicyDomainKerberosTicketInformation:
            AuditId = SE_AUDITID_KERBEROS_POLICY_CHANGE;
            break;
    }

    Status = LsapAdtGetDbAttributesChangeString( OldAttributes,
                                                 NewAttributes,
                                                 AttributeCount,
                                                 &AttributeChanges );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    RtlInitUnicodeString(&ChangesToAttributes, AttributeChanges);
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_POLICY_CHANGE,
        AuditId,
        AuditEventType,
        4,
        //
        //    User Sid
        //
        SeAdtParmTypeSid,     TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,  &LsapSubsystemName,

        //
        //    Caller's Authentication information
        //
        SeAdtParmTypeLogonId, ClientAuthenticationId,

        //
        //    Changes to attributes
        //
        SeAdtParmTypeString,  &ChangesToAttributes);

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    
    LsapFreeLsaHeap( AttributeChanges );
    
    return Status;
}


void LsapAdtGetAttributeValueString(
    IN  LSAP_DB_ATTRIBUTE* Attribute,
    OUT LPWSTR ValueString)
/*++

Routine Description:

    Generate a string representation of the value of an attribute

Arguments:

    Attribute - pointer to attribute

    ValueString - receives a string representation of the value of Attribute

Return Value:

    None

Notes:

--*/
{
    if (Attribute->AttributeValue) {
        
        switch (Attribute->DbNameIndex) {

            default:
                lstrcpy(ValueString, L"unknown");
                break;

            // binary blob
            case PolEfDat:
                lstrcpy(ValueString, L"<binary data>");
                break;

                // ULONG
            case KerOpts:
                swprintf(ValueString, L"0x%x", *((ULONG*) Attribute->AttributeValue));
                break;

                // LARGE_INTEGER
            case KerMinT:
            case KerMaxT:
            case KerMaxR:
            case KerProxy:
            case KerLogoff:
                swprintf(ValueString, L"0x%I64x",
                         *((ULONGLONG*) Attribute->AttributeValue));
                break;
        }
    } else {
        lstrcpy(ValueString, L"none");
    }
}


void
LsapAdtGetDbAttributeChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttribute,
    IN LSAP_DB_ATTRIBUTE* NewAttribute,
    OUT LPWSTR AttributeChangeString,   OPTIONAL
    IN OUT PULONG RequiredLength
    )
/*++

Routine Description:

    Given an old attribute and a new attribute, return 
    a string representation of the difference between the two.

    If there are no changes, RequiredLength is returned as 0
    and AttributeChangeString is left unchanged;
    otherwise if AttributeChangeString is non-NULL, the change is
    written to it as:
    <ParameterName>: <new value> (<old value>)

Arguments:

    OldAttribute - pointer to old attribute

    NewAttribute - pointer to new attribute

    AttributeChangeString - if non-NULL, receives the string representation
        of the difference between OldAttribute and NewAttribute

    RequiredLength - pointer to length of AttributeChangeString

Return Value:

    None

Notes:

--*/
{
    WCHAR  ChangeString[256];
    LPWSTR TmpString;
    ULONG ChangeStringLength=0;

    //
    // do the processing only if there is a change in value
    //
    if ((OldAttribute->AttributeValue && NewAttribute->AttributeValue &&
         (0 != memcmp(OldAttribute->AttributeValue,
                      NewAttribute->AttributeValue,
                      OldAttribute->AttributeValueLength))) ||
        (OldAttribute->AttributeValue  && !NewAttribute->AttributeValue) ||
        (!OldAttribute->AttributeValue &&  NewAttribute->AttributeValue)) {

        //
        // Parameter Name
        //
        lstrcpy(ChangeString, OldAttribute->AttributeName->Buffer);
        ChangeStringLength = OldAttribute->AttributeName->Length/sizeof(WCHAR);
        TmpString = ChangeString + ChangeStringLength;

        lstrcpy(TmpString, L": ");
        ChangeStringLength += 2;
        TmpString = ChangeString + ChangeStringLength;

        //
        // Old value
        //
        LsapAdtGetAttributeValueString( NewAttribute, TmpString );
        ChangeStringLength += lstrlen(TmpString);
        TmpString = ChangeString + ChangeStringLength;
        
        //
        // New value
        //
        lstrcpy(TmpString, L" (");
        ChangeStringLength += 2;
        TmpString = ChangeString + ChangeStringLength;

        LsapAdtGetAttributeValueString( OldAttribute, TmpString );
        ChangeStringLength += lstrlen(TmpString);
        TmpString = ChangeString + ChangeStringLength;
        
        lstrcpy(TmpString, L");  ");
        ChangeStringLength += 4;

        if (AttributeChangeString && (ChangeStringLength <= *RequiredLength)) {
            lstrcpy(AttributeChangeString, ChangeString);
        } 
    }

    *RequiredLength = ChangeStringLength;
}

NTSTATUS
LsapAdtGetDbAttributesChangeString(
    IN LSAP_DB_ATTRIBUTE* OldAttributes,
    IN LSAP_DB_ATTRIBUTE* NewAttributes,
    IN ULONG AttributeCount,
    OUT LPWSTR* AttributeChangeString
    )
/*++

Routine Description:

    Given old attributes and new attributes, return a string representation
    of the difference between old and new attributes.

    If there are no changes, "--" is returned,
    otherwise each change is written to the string as:
    <ParameterName>: <new value> (<old value>)

    This function is used for writing information about
    changes to certain policies to the audit log.
    
Arguments:

    OldAttributes - pointer to array of old attributes

    NewAttributes - pointer to array of new attributes

    AttributeCount - Number of attributes. 

    AttributeChangeString - pointer to string that receives the diff.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

    Memory allocated for AttributeChangeString must be freed by the
    caller using LsapFreeLsaHeap.

--*/
{
    NTSTATUS Status=STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE* OldAttribute;
    LSAP_DB_ATTRIBUTE* NewAttribute;
    ULONG TmpStringLength;
    ULONG TotalRequiredLength;
    LPWSTR TmpString;
    UINT AttributeNumber;
    USHORT n=1;
        
    OldAttribute = OldAttributes;
    NewAttribute = NewAttributes;

    TotalRequiredLength = 0;

    //
    // first find out the size of the buffer required
    //
    for (AttributeNumber = 0; AttributeNumber < AttributeCount; AttributeNumber++) {

        LsapAdtGetDbAttributeChangeString( OldAttribute, NewAttribute,
                                           NULL, &TmpStringLength );
        OldAttribute++;
        NewAttribute++;
        TotalRequiredLength += TmpStringLength;
    }

    if (!TotalRequiredLength) {
        n += 2;
    }

    *AttributeChangeString = TmpString =
        LsapAllocateLsaHeap((TotalRequiredLength+n)*sizeof(WCHAR));
    
    if ( TmpString ) {

        if (TotalRequiredLength) {
            
            //
            // Now get the actual string
            //
            OldAttribute = OldAttributes;
            NewAttribute = NewAttributes;

            for (AttributeNumber = 0;
                 AttributeNumber < AttributeCount;
                 AttributeNumber++) {

                TmpStringLength = TotalRequiredLength;
                LsapAdtGetDbAttributeChangeString( OldAttribute, NewAttribute,
                                                   TmpString, &TmpStringLength );
                TmpString += TmpStringLength;
                OldAttribute++;
                NewAttribute++;
            }
        } else {
            lstrcpy(TmpString, L"--");
        }
    } else {
        Status = STATUS_NO_MEMORY;
    }

    return Status;
}


VOID
LsapAdtAuditDiscardedAudits(
    ULONG NumberOfEventsDiscarded
    )
/*++

Routine Description:

    Audits the fact that we discarded some audits.

Arguments:

    NumberOfEventsDiscarded - The number of events discarded.

Return Value:

    None.

--*/
{
    SID_IDENTIFIER_AUTHORITY  NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return;
    }

    if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategorySystem] &
          POLICY_AUDIT_EVENT_SUCCESS)) {
        return;
    }

    RtlZeroMemory ((PVOID) &AuditParameters, sizeof( AuditParameters ));

    AuditParameters.CategoryId     = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId        = SE_AUDITID_AUDITS_DISCARDED;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, NumberOfEventsDiscarded );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}


PLUID LsaFilterPrivileges[] =
    {
        &ChangeNotifyPrivilege,
        &AuditPrivilege,
        &CreateTokenPrivilege,
        &AssignPrimaryTokenPrivilege,
        &BackupPrivilege,
        &RestorePrivilege,
        &DebugPrivilege,
        NULL
    };


VOID
LsapAdtAuditSpecialPrivileges(
    PPRIVILEGE_SET Privileges,
    LUID LogonId,
    PSID UserSid
    )
/*++

Routine Description:

    Audits the assignment of special privileges at logon time.

Arguments:

    Privileges - List of privileges being assigned.

Return Value:

    None.

--*/
{
    PPRIVILEGE_SET Buffer;
    PLUID *FilterPrivilege = NULL;
    ULONG i;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return;
    }

    if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryPrivilegeUse] & POLICY_AUDIT_EVENT_SUCCESS)) {
        return;
    }

    if ( (Privileges == NULL) || (Privileges->PrivilegeCount == 0) ) {
        return;
    }

    //
    // We can't need any more space than what's being passed in.
    //

    Buffer = (PPRIVILEGE_SET)LsapAllocateLsaHeap( LsapPrivilegeSetSize( Privileges ) );

    if ( Buffer == NULL ) {
        //
        // ISSUE-2000/09/26-kumarp : call LsapAuditFailed
        //
        return;
    }

    Buffer->PrivilegeCount = 0;

    //
    // For each privilege in the privilege set, see if it's in the filter
    // list.
    //

    for ( i=0; i<Privileges->PrivilegeCount; i++) {

        FilterPrivilege = LsaFilterPrivileges;

        do {

            if ( RtlEqualLuid( &Privileges->Privilege[i].Luid, *FilterPrivilege )) {

                Buffer->Privilege[Buffer->PrivilegeCount].Luid = **FilterPrivilege;
                Buffer->PrivilegeCount++;
            }

        } while ( *++FilterPrivilege != NULL  );
    }

    if ( Buffer->PrivilegeCount == 0 ) {
        LsapFreeLsaHeap( Buffer );
        return;
    }

    //
    // We matched on at least one, generate an audit.
    //

    RtlZeroMemory ((PVOID) &AuditParameters, sizeof( AuditParameters ));

    AuditParameters.CategoryId     = SE_CATEGID_PRIVILEGE_USE;
    AuditParameters.AuditId        = SE_AUDITID_ASSIGN_SPECIAL_PRIV;
    AuditParameters.Type           = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );
    AuditParameters.ParameterCount++;

    LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Buffer );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    LsapFreeLsaHeap( Buffer );

    return;
}




VOID
LsapAdtAuditPackageLoad(
    PUNICODE_STRING PackageFileName
    )

/*++

Routine Description:

    Audits the loading of an authentication package.

Arguments:

    PackageFileName - The name of the package being loaded.

Return Value:

    None.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return;
    }

    if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategorySystem] & POLICY_AUDIT_EVENT_SUCCESS)) {
        return;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_AUTH_PACKAGE_LOAD;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageFileName );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}


VOID
LsapAdtAuditLogonProcessRegistration(
    IN PLSAP_AU_REGISTER_CONNECT_INFO_EX ConnectInfo
    )

/*++

Routine Description:

    Audits the registration of a logon process

Arguments:

    ConnectInfo - Supplies the connection information for the new
        logon process.


Return Value:

    None.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    ANSI_STRING AnsiString;
    UNICODE_STRING Unicode;
    PSZ LogonProcessNameBuffer;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return;
    }

    if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategorySystem] & POLICY_AUDIT_EVENT_SUCCESS)) {
        return;
    }

    //
    // Turn the name text in the ConnectInfo structure into
    // something we can work with.
    //

    LogonProcessNameBuffer = (PSZ)LsapAllocateLsaHeap( ConnectInfo->LogonProcessNameLength+1 );

    if ( LogonProcessNameBuffer == NULL ) {

        return;
    }

    RtlCopyMemory(
        LogonProcessNameBuffer,
        ConnectInfo->LogonProcessName,
        ConnectInfo->LogonProcessNameLength
        );

    LogonProcessNameBuffer[ConnectInfo->LogonProcessNameLength] = 0;
    RtlInitAnsiString( &AnsiString, LogonProcessNameBuffer );

    Status = RtlAnsiStringToUnicodeString( &Unicode, &AnsiString, TRUE );

    if ( !NT_SUCCESS( Status )) {

        //
        // Must be out of memory, not much we can do here
        //

        LsapFreeLsaHeap( LogonProcessNameBuffer );
        return;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_SYSTEM_LOGON_PROC_REGISTER;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &Unicode );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    LsapFreeLsaHeap( LogonProcessNameBuffer );
    RtlFreeUnicodeString( &Unicode );

    return;
}




VOID
LsapAdtSystemRestart(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    )

/*++

Routine Description:

    This function is called during LSA initialization to generate
    a system restart event.

Arguments:

    AuditEventsInfo - Auditing data.


Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;


    if(!AuditEventsInfo->AuditingMode) {

        return;
    }

    if (!((AuditEventsInfo->EventAuditingOptions)[AuditCategorySystem] & POLICY_AUDIT_EVENT_SUCCESS )) {

        return;
    }

    //
    // Construct an audit parameters array
    // for the restart event.
    //

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_SYSTEM_RESTART;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    //
    //    User Sid
    //

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );

    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}


VOID
LsapAdtAuditLogon(
    IN USHORT EventCategory,
    IN ULONG  EventID,
    IN USHORT EventType,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING Source,
    IN PUNICODE_STRING PackageName,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PSID UserSid,
    IN LUID AuthenticationId,
    IN PUNICODE_STRING WorkstationName,
    IN NTSTATUS LogonStatus,
    IN NTSTATUS SubStatus,
    IN LPGUID LogonGuid                 OPTIONAL
    )

/*++

Routine Description:

    Generates an audit of a logon event as appropriate.

Arguments:



Return Value:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING SpareString;
    UNICODE_STRING AuthenticationIdString = { 0 };
    BOOLEAN FreeWhenDone = FALSE;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    BOOLEAN AuditingSuccess;
    BOOLEAN AuditingFailure;
    PSID pSid;
    PLSAP_LOGON_SESSION pLogonSession = NULL;
    
        
    RtlInitUnicodeString( &SpareString, L"Security");

    AuditingFailure = (EventType == EVENTLOG_AUDIT_FAILURE) && LsapAuditFailedLogons;
    AuditingSuccess = (EventType == EVENTLOG_AUDIT_SUCCESS) && LsapAuditSuccessfulLogons;

    //
    // return quickly if auditing is not enabled
    //
    if ( !(AuditingFailure || AuditingSuccess) )
    {
        return;
    }
    
    //
    // Build an audit parameters structure.
    //

    RtlZeroMemory ( (PVOID) &AuditParameters, sizeof( AuditParameters ) );

    AuditParameters.CategoryId = EventCategory;
    AuditParameters.AuditId = EventID;
    AuditParameters.Type = EventType;
    AuditParameters.ParameterCount = 0;

    //
    // If this is a successful logon audit event and the caller did not
    // supply a logon GUID, extract it from the logon session.
    //
    if ( AuditingSuccess && !LogonGuid &&
         ( EventType == EVENTLOG_AUDIT_SUCCESS ) )
    {
        pLogonSession = LsapLocateLogonSession( &AuthenticationId );

        ASSERT( pLogonSession && L"LsapAdtAuditLogon: logon session not found" );
        
        if ( pLogonSession )
        {
            LogonGuid = &pLogonSession->LogonGuid;
        }
    }

#if DBG
    if ( AuditingSuccess )
    {
        DsysAssert( EventID != SE_AUDITID_DOMAIN_TRUST_INCONSISTENT );
    }
#endif
    //
    //    User Sid
    //

    pSid = AuditingSuccess ? UserSid : LsapLocalSystemSid;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, pSid );

    AuditParameters.ParameterCount++;

    //
    //    Subsystem name (if available)
    //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &SpareString );
    AuditParameters.ParameterCount++;

        //
        //    Account name
        //

    if ( ARGUMENT_PRESENT( AccountName ) ) {

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AccountName );
        
    } 

    AuditParameters.ParameterCount++;

        //
        //    Authenticating Authority (domain name)
        //

    if ( ARGUMENT_PRESENT( AuthenticatingAuthority ) ) {

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AuthenticatingAuthority );

    } 

    AuditParameters.ParameterCount++;

    if ( AuditingSuccess ) {

        //
        //    Logon Id (as a string)
        //

        Status = LsapAdtBuildLuidString(
                     &AuthenticationId,
                     &AuthenticationIdString,
                     &FreeWhenDone
                     );

        if ( NT_SUCCESS( Status )) {

            LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &AuthenticationIdString );

        } else {

            goto Finish;
        }

        AuditParameters.ParameterCount++;
    } 

    //
    //    Logon Type
    //

    LsapSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, LogonType );
    AuditParameters.ParameterCount++;

        //
        //    Source
        //

    if ( ARGUMENT_PRESENT( Source )) {

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, Source );

    } else {

        //
        // No need to do anything here, since an empty entry will turn
        // into a '-' in the output
        //

    }

    AuditParameters.ParameterCount++;

        //
        // Authentication Package
        //

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageName );
    AuditParameters.ParameterCount++;

        //
        // Workstation Name
        //

    if ( ARGUMENT_PRESENT( WorkstationName )) {

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, WorkstationName );
    }

    AuditParameters.ParameterCount++;

    if ( EventID == SE_AUDITID_UNSUCCESSFUL_LOGON ) {

        //
        // we need to supply the logon status for this event,
        // so that some information can be gleened from the log.
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, LogonStatus );
        AuditParameters.ParameterCount++;
        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, SubStatus );
        AuditParameters.ParameterCount++;
    }

    //
    // Logon GUID
    //

    if ( ARGUMENT_PRESENT( LogonGuid )) {

        LsapSetParmTypeGuid( AuditParameters, AuditParameters.ParameterCount, LogonGuid );
        AuditParameters.ParameterCount++;
    }


    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

 Finish:
    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }

    if ( FreeWhenDone ) {
        LsapFreeLsaHeap( AuthenticationIdString.Buffer );
    }

    if ( pLogonSession != NULL )
    {
        LsapReleaseLogonSession( pLogonSession );
    }
}




VOID
LsapAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    )
/*++

Routine Description/Arguments/Return value

    See header comment for LsapAuditLogonHelper

--*/
{
    LsapAuditLogonHelper(
        LogonStatus,
        LogonSubStatus,
        AccountName,
        AuthenticatingAuthority,
        WorkstationName,
        UserSid,
        LogonType,
        TokenSource,
        LogonId,
        NULL                    // no logon guid
        );
}




VOID
LsapAuditLogonHelper(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid                         OPTIONAL
    )
/*++

Routine Description:

    Helper routine for security packages to generate a logon audit

Arguments:
    LogonStatus - Status code for the logon.

    LogonSubStatus - more detailed Status code for the logon.

    AccountName - Name of principal attempting logon.

    AuthenticatingAuthority - Authority validating the logon.

    Workstation - Machine from which the logon was attempted. For a network
        logon, this should be the client machine.

    UserSid - Sid for the logged on account.

    LogonType - Type of logon, such as Network, Interactive, Service, etc.

    TokenSource - Source for the token.

    LogonId - If the logon was successful, the logon ID for the logon session.

    LogonGuid - globally unique ID for a logon. currently this is supported
                only by the kerberos package.

Return Value:

    None.

--*/
{
    ANSI_STRING AnsiSourceContext;
    CHAR AnsiBuffer[TOKEN_SOURCE_LENGTH + 2];
    UNICODE_STRING UnicodeSourceContext;
    WCHAR UnicodeBuffer[TOKEN_SOURCE_LENGTH + 2];
    NTSTATUS Status;
    USHORT EventType;
    USHORT EventCategory;
    ULONG  EventID;
    PLSAP_SECURITY_PACKAGE SecurityPackage;
    ULONG_PTR PackageId;
    
    PackageId = GetCurrentPackageId();
    DsysAssertMsg( PackageId != SPMGR_ID, "LsapAuditLogon" );
    
    SecurityPackage = SpmpLocatePackage( PackageId );
    DsysAssertMsg( SecurityPackage != NULL, "LsapAuditLogon" );


    //
    // Audit the logon attempt.  The event type and logged information
    // will depend to some extent on the whether we failed and why.
    //

    //
    // Turn the SourceContext into something we can
    // work with.
    //

    AnsiSourceContext.Buffer = AnsiBuffer;
    AnsiSourceContext.Length = TOKEN_SOURCE_LENGTH * sizeof( CHAR );
    AnsiSourceContext.MaximumLength = (TOKEN_SOURCE_LENGTH + 2) * sizeof( CHAR );

    UnicodeSourceContext.Buffer = UnicodeBuffer;
    UnicodeSourceContext.MaximumLength = (TOKEN_SOURCE_LENGTH + 2) * sizeof( WCHAR );

    RtlCopyMemory(
        AnsiBuffer,
        TokenSource->SourceName,
        TOKEN_SOURCE_LENGTH * sizeof( CHAR )
        );

    Status = RtlAnsiStringToUnicodeString(
                 &UnicodeSourceContext,
                 &AnsiSourceContext,
                 FALSE
                 );

    if ( NT_SUCCESS( Status )) {
        
        UnicodeSourceContext.Length =
            (USHORT) LsapSafeWcslen( UnicodeSourceContext.Buffer,
                                     UnicodeSourceContext.MaximumLength );
        
    } else {

        UnicodeSourceContext.Buffer = NULL;

        //
        // we cannot fail the audit because of this but catch the
        // internal clients who supply bad source contexts
        //
        DsysAssertMsg( FALSE, "LsapAuditLogon: could not convert AnsiSourceContext to unicode" );
    }

    //
    // Assume the logon failed, reset if necessary.
    //

    EventCategory = SE_CATEGID_LOGON;
    EventType     = EVENTLOG_AUDIT_FAILURE;


    switch ( LogonStatus )
    {
        case STATUS_SUCCESS:
            {
                //
                // Use a separate event for network logons
                //

                if (( LogonType == Network ) ||
                    ( LogonType == NetworkCleartext ))
                {
                    EventID = SE_AUDITID_NETWORK_LOGON;
                }
                else
                {
                    EventID = SE_AUDITID_SUCCESSFUL_LOGON;
                }

                EventType = EVENTLOG_AUDIT_SUCCESS;
                break;
            }

        case STATUS_BAD_VALIDATION_CLASS:
            EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
            break;

        case STATUS_ACCOUNT_EXPIRED:
            EventID = SE_AUDITID_ACCOUNT_EXPIRED;
            break;

        case STATUS_NETLOGON_NOT_STARTED:
            EventID = SE_AUDITID_NETLOGON_NOT_STARTED;
            break;

        case STATUS_ACCOUNT_LOCKED_OUT:
            EventID = SE_AUDITID_ACCOUNT_LOCKED;
            break;

        case STATUS_LOGON_TYPE_NOT_GRANTED:
            EventID = SE_AUDITID_LOGON_TYPE_RESTR;
            break;

        case STATUS_PASSWORD_MUST_CHANGE:
            EventID = SE_AUDITID_PASSWORD_EXPIRED;
            break;


        case STATUS_ACCOUNT_RESTRICTION:
            {

                switch ( LogonSubStatus )
                {
                    case STATUS_PASSWORD_EXPIRED:
                        EventID = SE_AUDITID_PASSWORD_EXPIRED;
                        break;

                    case STATUS_ACCOUNT_DISABLED:
                        EventID = SE_AUDITID_ACCOUNT_DISABLED;
                        break;

                    case STATUS_INVALID_LOGON_HOURS:
                        EventID = SE_AUDITID_ACCOUNT_TIME_RESTR;
                        break;

                    case STATUS_INVALID_WORKSTATION:
                        EventID = SE_AUDITID_WORKSTATION_RESTR;
                        break;

                    default:
                        EventID = SE_AUDITID_UNKNOWN_USER_OR_PWD;
                        break;
                }
                break;
            }

        case STATUS_LOGON_FAILURE:
            {
                if ( ( LogonSubStatus == STATUS_WRONG_PASSWORD ) ||
                     ( LogonSubStatus == STATUS_NO_SUCH_USER   ) )
                {
                    EventID = SE_AUDITID_UNKNOWN_USER_OR_PWD;

                }
                else if ( LogonSubStatus == STATUS_DOMAIN_TRUST_INCONSISTENT )
                {
                    EventID = SE_AUDITID_DOMAIN_TRUST_INCONSISTENT;
                }
                else
                {
                    EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
                }
                break;
            }

        default:
            EventID = SE_AUDITID_UNSUCCESSFUL_LOGON;
            break;
    }

    LsapAdtAuditLogon( EventCategory,
                       EventID,
                       EventType,
                       AccountName,
                       AuthenticatingAuthority,
                       &UnicodeSourceContext,
                       &SecurityPackage->Name,
                       LogonType,
                       UserSid,
                       *LogonId,
                       WorkstationName,
                       LogonStatus,
                       LogonSubStatus,
                       LogonGuid
                       );

}


VOID
LsapAdtAuditLogoff(
    PLSAP_LOGON_SESSION Session
    )
/*++

Routine Description:

    Generates a logoff audit.  The caller is responsible for determining
    if logoff auditing is enabled.

Arguments:

    Session - Points to the logon session being removed.

Return Value:

    None.

--*/
{
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    NTSTATUS Status;
    UNICODE_STRING usLogonId;
    BOOLEAN fFreeLogonId=FALSE;

    RtlZeroMemory ( &usLogonId, sizeof(UNICODE_STRING) );

    //
    // normally we would simply store the logon-id to be audited
    // as SeAdtParmTypeLogonId. But in this case, the logon session
    // will have gone away by the time we try to convert it
    // to a string representation in LsapAdtDemarshallAuditInfo.
    // using LsapGetLogonSessionAccountInfo.
    //
    // To avoid this, we pre-convert the logon-id here
    //

    Status = LsapAdtBuildLuidString( &Session->LogonId,
                                     &usLogonId, &fFreeLogonId );

    if ( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }


    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_LOGON,
        SE_AUDITID_LOGOFF,
        EVENTLOG_AUDIT_SUCCESS,
        6,                       // there are 6 params to init

        //
        //    User Sid
        //
        SeAdtParmTypeSid,        Session->UserSid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    User
        //
        SeAdtParmTypeString,     &Session->AccountName,

        //
        //    Domain
        //
        SeAdtParmTypeString,     &Session->AuthorityName,

        //
        //    LogonId
        //
        SeAdtParmTypeString,     &usLogonId,

        //
        //    Logon Type
        //
        SeAdtParmTypeUlong,      Session->LogonType );


    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

Cleanup:
    if (fFreeLogonId)
    {
        LsapFreeLsaHeap(usLogonId.Buffer);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtgenp.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N P . C
//
// Contents:    definitions of types/functions required for 
//              generating generic audits.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#include <lsapch2.h>
#pragma hdrstop

#include "adtp.h"
#include "adtgen.h"
#include "adtgenp.h"

// ----------------------------------------------------------------------
//
// globals
//

//
// critsec that guards access to 
// LsapAdtContextList and LsapAdtContextListCount
//

RTL_CRITICAL_SECTION LsapAdtContextListLock;

//
// linked list of audit contexts. see comment in fn LsapAdtAddAuditContext
//

LIST_ENTRY LsapAdtContextList;

//
// number of elements in the context list
//

ULONG LsapAdtContextListCount=0;


// ----------------------------------------------------------------------
//
// helper macros
//

#define LockAuditContextList()   RtlEnterCriticalSection(&LsapAdtContextListLock)


#define UnLockAuditContextList() RtlLeaveCriticalSection(&LsapAdtContextListLock)


//
// convert a context handle to a context pointer
//

#define AdtpContextPtrFromHandle(h) ((AUDIT_CONTEXT*) (h))
#define AdtpContextHandleFromptr(p) ((AUDIT_HANDLE) (p))


// ----------------------------------------------------------------------
//
// internal routines
//

NTSTATUS
LsapAdtIsValidAuditInfo(
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    );

NTSTATUS
LsapAdtIsValidAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapAdtIsContextInList(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapGetAuditEventParams(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PAUDIT_CONTEXT pAuditContext
    );

NTSTATUS
LsapAdtAddAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS LsapAdtDeleteAuditContext(
    IN AUDIT_HANDLE hAudit
    );

NTSTATUS
LsapAdtMapAuditParams(
    IN  PAUDIT_PARAMS pAuditParams,
    OUT PSE_ADT_PARAMETER_ARRAY pSeAuditParameters,
    OUT PUNICODE_STRING pString,
    OUT PSE_ADT_OBJECT_TYPE* pObjectTypeList
    );

NTSTATUS
LsapAdtFreeAuditContext(
    AUDIT_HANDLE hAudit
    );

NTSTATUS 
LsapAdtCheckAuditPrivilege( VOID );

// ----------------------------------------------------------------------


NTSTATUS
LsapAdtInitGenericAudits( VOID )
/*++

Routine Description:

    Initialize the generic audit functionality.
    

Arguments:
    None

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead( &LsapAdtContextList );
    LsapAdtContextListCount = 0;
    
    Status = RtlInitializeCriticalSection(&LsapAdtContextListLock);

    return Status;
}


NTSTATUS
LsapRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT AUDIT_HANDLE* phAudit
    )
/*++

Routine Description:
    Register the specified event;
    generate and return an audit context. 
    

Arguments:

    pAuditEventType - pointer to audit event info. This param describes
                      the type of event to be registered.

    phAudit         - pointer to audit context returned
                      this handle must be freed by calling
                      LsaUnregisterAuditEvent when no longer needed.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    Note that this function does NOT register the schema of an event. It is
    assumed that the schema has been registered *before* calling
    this function.

    The generated context is stored in LsapAdtContextList.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext=NULL;
    UINT RpcTransportType;
    RPC_STATUS RpcStatus;
    
    *phAudit = NULL;

    //
    // find out the transport over which we are receiving this call
    //

    RpcStatus = I_RpcBindingInqTransportType ( NULL, &RpcTransportType );

    if ( RpcStatus != RPC_S_OK )
    {
        Status = I_RpcMapWin32Status( RpcStatus );
        goto Cleanup;
    }

    //
    // if the transport is anything other than LPC, error out
    // we want to support only LPC for audit calls
    //

    if ( RpcTransportType != TRANSPORT_TYPE_LPC )
    {
        Status = RPC_NT_PROTSEQ_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // do a sanity check on the audit-info supplied
    //

    Status = LsapAdtIsValidAuditInfo( pAuditEventType );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    
    //
    // make sure that the caller has audit privilege
    // (LsapAdtCheckAuditPrivilege calls RpcImpersonateClient)
    //
#ifndef SE_ADT_NO_AUDIT_PRIVILEGE_CHECK
    Status = LsapAdtCheckAuditPrivilege();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif
    
    pAuditContext =
      (PAUDIT_CONTEXT) LsapAllocateLsaHeap( sizeof(AUDIT_CONTEXT) );

    if (pAuditContext)
    {
        //
        // store the parameters for this audit into the
        // generated context.
        //

        Status = LsapGetAuditEventParams(pAuditEventType, pAuditContext);

        if (NT_SUCCESS(Status))
        {
            //
            // add to context list
            //

            Status = LsapAdtAddAuditContext(
                AdtpContextHandleFromptr( pAuditContext ) );

            if (NT_SUCCESS(Status))
            {
                *phAudit = AdtpContextHandleFromptr( pAuditContext );
            }
        }
    }
    else
    {
        Status = STATUS_NO_MEMORY;
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        LsapFreeLsaHeap(pAuditContext);
    }
    
    return Status;
}


NTSTATUS
LsapGenAuditEvent(
    IN AUDIT_HANDLE  hAudit,
    IN DWORD         dwFlags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         pReserved
    )
/*++

Routine Description:
    Publish the specified audit event.
    

Arguments:

    hAudit        - handle of audit-context previously obtained
                    by calling LsaRegisterAuditEvent

    dwFlags       - TBD

    pAuditParams  - pointer to event parameters. This structure should
                    be initialized using AuthzInitAuditParams.
                    Please see detailed comment on that function
                    in adtutil.c on usage of this parameter.

    pReserved     - reserved

Return Value:

    STATUS_SUCCESS           -- on success
    STATUS_INVALID_PARAMETER -- if one or more params are invalid
    STATUS_AUDITING_DISABLED -- if the event being generated is not
                                being audited because the policy setting
                                is disabled.

Notes:

--*/
{
    NTSTATUS         Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT  pAuditContext;
    SE_ADT_PARAMETER_ARRAY SeAuditParameters = { 0 };
    UNICODE_STRING  Strings[SE_MAX_AUDIT_PARAM_STRINGS] = { 0 };

#define MAX_OBJECT_TYPES 32

    SE_ADT_OBJECT_TYPE ObjectTypes[MAX_OBJECT_TYPES];
    PSE_ADT_OBJECT_TYPE pObjectTypes = ObjectTypes;
    POLICY_AUDIT_EVENT_TYPE CategoryId;
    UINT AuditEventType;
    
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(pReserved);

    DsysAssertMsg( pAuditParams != NULL, "LsapGenAuditEvent" );

    //
    // make sure that the context is in our list
    //

    Status = LsapAdtIsContextInList( hAudit );
    
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // verify that the context is not invalid
    //

    Status = LsapAdtIsValidAuditContext( hAudit );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    //
    // return error if the context and the passed parameters
    // do not agree on the number of parameters
    //

    if ( pAuditContext->ParameterCount != pAuditParams->Count )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( pAuditParams->Flags & APF_AuditSuccess )
    {
        AuditEventType = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        AuditEventType = EVENTLOG_AUDIT_FAILURE;
    }

    //
    // do the ugly math since the corresponding values of
    // POLICY_AUDIT_EVENT_TYPE (ntlsa.h) and those defined
    // in msaudite.h differ by 1
    //

    CategoryId = (POLICY_AUDIT_EVENT_TYPE) (pAuditContext->CategoryId - 1);

    //
    // check if auditing is enabled for that category
    //

    if (!LsapAdtIsAuditingEnabledForCategory( CategoryId, AuditEventType ))
    {
        Status = STATUS_AUDITING_DISABLED;
        goto Cleanup;
    }

    SeAuditParameters.Type           = (USHORT) AuditEventType;
    SeAuditParameters.CategoryId     = pAuditContext->CategoryId;
    SeAuditParameters.AuditId        = pAuditContext->AuditId;
    SeAuditParameters.ParameterCount = pAuditParams->Count;
    

    //
    // Map AUDIT_PARAMS structure to SE_ADT_PARAMETER_ARRAY structure
    //

    Status = LsapAdtMapAuditParams( pAuditParams,
                                    &SeAuditParameters,
                                    (PUNICODE_STRING) Strings,
                                    &pObjectTypes );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // write the params to eventlog
    //
    Status = LsapAdtWriteLog( &SeAuditParameters, 0 );
    
    
Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // crash on failure if specified by the security policy
        //
        // But do not crash on documented errors
        //

        if ( ( Status != STATUS_INVALID_PARAMETER ) &&
             ( Status != STATUS_AUDITING_DISABLED ) &&
             ( Status != STATUS_NOT_FOUND ) )
        {
            LsapAuditFailed( Status );
        }
    }

    //
    // to save the cost of heap alloc/dealloc each time for
    // the object types. we use a fixed array of size MAX_OBJECT_TYPES
    // If this size is not enough, LsapAdtMapAuditParams will allocate
    // a bigger array, in this case the following condition
    // becomes true and we free the allocated array.
    //

    if ( pObjectTypes && ( pObjectTypes != ObjectTypes ))
    {
        LsapFreeLsaHeap( pObjectTypes );
    }

    return Status;
}


NTSTATUS
LsapUnregisterAuditEvent(
    IN OUT AUDIT_HANDLE* phAudit
    )
/*++

Routine Description:

    Unregister the specified context and free up any resources.

Arguments:

    hAudit - handle of audit context to unregister
             This is set to NULL when the call returns.

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    //
    // remove it from the list and free up resources
    //

    if ( phAudit )
    {
        Status = LsapAdtDeleteAuditContext( *phAudit );

        *phAudit = NULL;
    }
    
    return Status;
}


NTSTATUS
LsapGetAuditEventParams(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PAUDIT_CONTEXT pAuditContext
    )
/*++

Routine Description:

    Initialize the audit context using information in the
    passed pAuditEventType

Arguments:

    pAuditEventType - pointer to audit event info

    pAuditContext   - pointer to audit context to be initialzed

Return Value:

    STATUS_SUCCESS            if params are ok
    STATUS_INVALID_PARAMETER  otherwise

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    USHORT CategoryId;
    USHORT AuditId;
    USHORT ParameterCount;
    ULONG  ProcessId = 0xffffffff;
    LUID   LinkId;
    RPC_STATUS RpcStatus;
    UINT ClientIsLocal = 0;
    
    DsysAssertMsg( pAuditContext != NULL, "LsapGetAuditEventParams" );
    
    if (pAuditEventType &&
        (pAuditEventType->Version == AUDIT_TYPE_LEGACY))
    {
        CategoryId     = pAuditEventType->u.Legacy.CategoryId;
        AuditId        = pAuditEventType->u.Legacy.AuditId;
        ParameterCount = pAuditEventType->u.Legacy.ParameterCount;
        LinkId         = pAuditEventType->LinkId;

        RpcStatus = I_RpcBindingIsClientLocal( 0, &ClientIsLocal );

        if ( ( RpcStatus == RPC_S_OK ) && ClientIsLocal )
        {
            RpcStatus = I_RpcBindingInqLocalClientPID( NULL, &ProcessId );

#if DBG
            if ( RpcStatus != RPC_S_OK )
            {
                DbgPrint("LsapGetAuditEventParams: I_RpcBindingInqLocalClientPID: %lx\n", RpcStatus);
            }
#endif
        }
        
        //
        // for now, do not let events to be published under other categories
        //

        Status = STATUS_SUCCESS;
        
        //
        // currently we support only the legacy audits
        //

        pAuditContext->Flags          = ACF_LegacyAudit;
        pAuditContext->CategoryId     = CategoryId;
        pAuditContext->AuditId        = AuditId;
        pAuditContext->ParameterCount = ParameterCount;
        pAuditContext->LinkId         = LinkId;
        pAuditContext->ProcessId      = ProcessId;
    }
    
    return Status;
}
    


NTSTATUS 
LsapAdtIsContextInList(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Lookup the specified context in our list

Arguments:

    hAudit - handle of audit context to lookup

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS   if found
    STATUS_NOT_FOUND if not found

Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_FOUND;
    PAUDIT_CONTEXT pAuditContext, pContext;
    PLIST_ENTRY    Scan;
#if DBG
    LONG ContextCount = (LONG) LsapAdtContextListCount;
#endif
    
    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    Status = LockAuditContextList();

    if (NT_SUCCESS(Status))
    {
        Scan = LsapAdtContextList.Flink;

        while ( Scan != &LsapAdtContextList )
        {
#if DBG
            //
            // make sure that the ContextCount does not become <= 0
            // before the list runs out.
            //

            DsysAssertMsg( ContextCount > 0, "LsapAdtIsContextInList: list may be corrupt!" );
            ContextCount--;
#endif
            
            pContext = CONTAINING_RECORD( Scan, AUDIT_CONTEXT, Link );

            if ( pAuditContext == pContext )
            {
                Status = STATUS_SUCCESS;
                break;
            }
            Scan = Scan->Flink;
        }
#if DBG
        //
        // if we didnt find the item then we must have traversed
        // the whole list. in this case, make sure that the
        // LsapAdtContextListCount is in sync with the list
        //

        if ( Status == STATUS_NOT_FOUND )
        {
            DsysAssertMsg( ContextCount == 0, "LsapAdtIsContextInList: list may be corrupt!" );
        }
#endif
        UnLockAuditContextList();
    }
    
    return Status;
}


NTSTATUS 
LsapAdtAddAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Insert the specified context in our list

Arguments:

    hAudit - handle of audit context to insert

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:
    
    Currently we store the audit contexts in a linked list.
    This is ok since we do not expect more than 5 to 10 contexts
    in the list. Later on when the generic audit interface is
    to be published, we can change this to a more efficient storage.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;

    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                   "LsapAdtAddAuditContext" );

    pAuditContext = AdtpContextPtrFromHandle( hAudit );

    Status = LockAuditContextList();
    if (NT_SUCCESS(Status))
    {
        LsapAdtContextListCount++;
        InsertTailList(&LsapAdtContextList, &pAuditContext->Link);

        UnLockAuditContextList();
    }
    
    return Status;
}


NTSTATUS 
LsapAdtDeleteAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Remove a context from our list and free resources.

Arguments:

    hAudit - handle of audit context to remove

Return Value:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS   on success
    STATUS_NOT_FOUND if context is not found

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;
    
    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                   "LsapAdtDeleteAuditContext" );

    Status = LockAuditContextList();

    if (NT_SUCCESS(Status))
    {
        Status = LsapAdtIsContextInList( hAudit );

        DsysAssertMsg( Status != STATUS_NOT_FOUND,
                       "LsapAdtDeleteAuditContext: trying to del unknown context" );
        
        if (NT_SUCCESS(Status))
        {
            pAuditContext = AdtpContextPtrFromHandle( hAudit );
            
            RemoveEntryList( &pAuditContext->Link );
            LsapAdtContextListCount--;
            
            DsysAssertMsg(((LONG) LsapAdtContextListCount) >= 0,
                          "LsapAdtContextListCount should never be negative!");
        }

        UnLockAuditContextList();

        (VOID) LsapAdtFreeAuditContext( hAudit );
    }

    
    return Status;
}


NTSTATUS
LsapAdtIsValidAuditInfo(
    IN PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType
    )
/*++

Routine Description:

    Verify AUTHZ_AUDIT_EVENT_INFO structure members

Arguments:

    pAuditEventType - pointer to AUTHZ_AUDIT_EVENT_TYPE_OLD

Return Value:

    STATUS_SUCCESS           if info is within acceptable values
    STATUS_INVALID_PARAMETER if not

Notes:

    Currently the validity of the parameters is judged using
    the boundaries defined in msaudite.mc file.

    This function will need to be amended when we allow third party
    apps to supply audit events.

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    if ( ( pAuditEventType->Version == AUDIT_TYPE_LEGACY )                  &&
         IsValidCategoryId( pAuditEventType->u.Legacy.CategoryId )          &&
         IsValidAuditId( pAuditEventType->u.Legacy.AuditId )                &&
         IsValidParameterCount( pAuditEventType->u.Legacy.ParameterCount ) )
    {
        Status = STATUS_SUCCESS;
    }
    
    return Status;
}


NTSTATUS 
LsapAdtIsValidAuditContext(
    IN AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Verify that the specified context has valid info

Arguments:

    hAudit - handle of context to verify

Return Value:

    STATUS_SUCCESS           if info is within acceptable values
    STATUS_INVALID_PARAMETER if not

Notes:

--*/
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PAUDIT_CONTEXT pAuditContext;

    pAuditContext = AdtpContextPtrFromHandle( hAudit );
    
    if ( pAuditContext                                          &&
         ( pAuditContext->Flags & ACF_LegacyAudit )             &&
        !( pAuditContext->Flags & ~ACF_ValidFlags )             &&
         IsValidCategoryId( pAuditContext->CategoryId )         &&
         IsValidAuditId( pAuditContext->AuditId )               &&
         IsValidParameterCount( pAuditContext->ParameterCount ) )
    {
        Status = STATUS_SUCCESS;
    }

    return Status;
}


NTSTATUS
LsapAdtMapAuditParams(
    IN  PAUDIT_PARAMS pAuditParams,
    OUT PSE_ADT_PARAMETER_ARRAY pSeAuditParameters,
    OUT PUNICODE_STRING pString,
    OUT PSE_ADT_OBJECT_TYPE* ppObjectTypeList
    )
/*++

Routine Description:

    Map AUDIT_PARAMS structure to SE_ADT_PARAMETER_ARRAY structure.

Arguments:

    pAuditParams       - pointer to input audit params

    pSeAuditParameters - pointer to output audit params to be initialized.
                         The max allowed size of Parameters member of
                         this structure is determined by the value of
                         SE_MAX_AUDIT_PARAMETERS.
                         Caller needs to allocate memory for this param.
                         
    pString            - pointer to temp strings used in the mapping.
                         The max size of this structure is limited by
                         value of SE_MAX_AUDIT_PARAM_STRINGS.
                         Caller needs to allocate memory for this param.

    ppObjectTypeList   - pointer to object type list.
                         This function assumes that the size of this param
                         is MAX_OBJECT_TYPES upon entry. If more object types
                         are to be mapped, this function will alloc memory
                         using LsapAllocateLsaHeap. When this function
                         returns, the caller needs to check if the value of
                         this param is different from that when called.
                         If so, it should free this using LsapFreeLsaHeap.
                         

Return Value:

    STATUS_SUCCESS            on success
    STATUS_INVALID_PARAMETER  if one or more params are invalid
    STATUS_BUFFER_OVERFLOW    if the number of strings generated exceeds
                              SE_MAX_AUDIT_PARAM_STRINGS
    STATUS_NO_MEMORY          if out of memory

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT i=0;
    USHORT j=0;
    AUDIT_PARAM* pInParam;
    SE_ADT_PARAMETER_ARRAY_ENTRY* pOutParam;
    USHORT IndexMap[SE_MAX_AUDIT_PARAMETERS];
    USHORT ObjectTypeIndex;
    LUID LogonId;
    AUDIT_OBJECT_TYPES* pInObjectTypes;
    USHORT NumObjectTypes;
    USHORT NumStringsUsed=0;
    BOOL fObjectTypeListAllocated=FALSE;
    
    DsysAssertMsg(!(pAuditParams->Flags & (~APF_ValidFlags)),
                  "LsapAdtMapAuditParams");
    DsysAssertMsg(pAuditParams->Count <= SE_MAX_AUDIT_PARAMETERS,
                  "LsapAdtMapAuditParams");
    DsysAssertMsg(pAuditParams->Parameters != NULL, "LsapAdtMapAuditParams");
    DsysAssertMsg(pString != NULL, "LsapAdtMapAuditParams");
    DsysAssertMsg(ppObjectTypeList != NULL, "LsapAdtMapAuditParams");

    pInParam  = pAuditParams->Parameters;
    pOutParam = pSeAuditParameters->Parameters;


    for (i=0; i < pAuditParams->Count; i++, j++, pInParam++, pOutParam++ )
    {
        //
        // the index-map maps input parameters to the corresponding
        // output parameters. currently there is only 1-1 mapping
        // thus (i == j) is always true.
        //
        
        IndexMap[i] = j;
        
        switch(pInParam->Type)
        {
            default:
            case APT_None:
                Status = STATUS_INVALID_PARAMETER;
                break;

                //
                // the input params have null-terminated string
                // convert it to UNICODE_STRING. Use the passed
                // pString array to hold the converted strings.
                //

            case APT_String:
                DsysAssertMsg( pInParam->Data0, "APT_String" );

                RtlInitUnicodeString( pString, (PCWSTR) pInParam->Data0 );
                pOutParam->Type    = SeAdtParmTypeString;
                pOutParam->Length  = sizeof(UNICODE_STRING)+pString->Length;
                pOutParam->Address = pString++;
                NumStringsUsed++;

                //
                // the passed array has limited size
                //

                if ( NumStringsUsed >= SE_MAX_AUDIT_PARAM_STRINGS )
                {
                    Status = STATUS_BUFFER_OVERFLOW;
                }
                break;

                //
                // Convert a Ulong. It can be mapped to
                // any one of the following:
                // - access-mask
                // - decimal ulong
                // - hex ulong
                //

            case APT_Ulong:
                pOutParam->Data[0] = pInParam->Data0;
                pOutParam->Length  = sizeof(ULONG);
                if ( pInParam->Flags & AP_AccessMask )
                {
                    pOutParam->Type    = SeAdtParmTypeAccessMask;
                    ObjectTypeIndex = (USHORT) pInParam->Data1;

                    //
                    // the index cannot be greater than the current item
                    //

                    if (ObjectTypeIndex >= i)
                    {
                        Status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                    ObjectTypeIndex = IndexMap[ObjectTypeIndex];
                    pOutParam->Data[1] = ObjectTypeIndex;
                }
                else
                {
                    if ( pInParam->Flags & AP_FormatHex )
                    {
                        pOutParam->Type = SeAdtParmTypeHexUlong;
                    }
                    else
                    {
                        pOutParam->Type = SeAdtParmTypeUlong;
                    }
                }
                break;
                
            case APT_Sid:
                DsysAssertMsg( pInParam->Data0, "APT_Sid" );
                
                pOutParam->Type    = SeAdtParmTypeSid;
                pOutParam->Address = (PVOID) pInParam->Data0;
                pOutParam->Length  = RtlLengthSid( (PSID) pInParam->Data0 );
                break;

            case APT_LogonId:
                pOutParam->Type    = SeAdtParmTypeLogonId;
                LogonId.LowPart    = (ULONG) pInParam->Data0;
                LogonId.HighPart   = (LONG) pInParam->Data1;
                *((LUID*) pOutParam->Data) = LogonId;
                pOutParam->Length  = sizeof(LUID);
                break;
                
            case APT_Pointer:
                pOutParam->Type    = SeAdtParmTypePtr;
                pOutParam->Data[0] = pInParam->Data0;
                pOutParam->Length  = sizeof(PVOID);
                break;

            case APT_ObjectTypeList:
                pInObjectTypes     = (AUDIT_OBJECT_TYPES*) pInParam->Data0;
                NumObjectTypes     = pInObjectTypes->Count;

                DsysAssertMsg( pInObjectTypes, "APT_ObjectTypeList" );
                DsysAssertMsg( NumObjectTypes, "APT_ObjectTypeList" );
                

                //
                // get the type of the objects from Data1
                //

                ObjectTypeIndex    = (USHORT) pInParam->Data1;

                //
                // the index cannot be greater than the current item
                //

                if (ObjectTypeIndex >= i)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }
                ObjectTypeIndex = IndexMap[ObjectTypeIndex];

                pOutParam->Type    = SeAdtParmTypeObjectTypes;
                pOutParam->Length  = NumObjectTypes * sizeof(SE_ADT_OBJECT_TYPE);

                //
                // the caller passes us a fixed sized object-type array
                // if that is not big enough, allocate a new one
                //

                if ( NumObjectTypes > MAX_OBJECT_TYPES )
                {
                    *ppObjectTypeList = LsapAllocateLsaHeap( pOutParam->Length );
                    fObjectTypeListAllocated = TRUE;
                }

                if ( *ppObjectTypeList == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    break;
                }
                pOutParam->Address = *ppObjectTypeList;
                pOutParam->Data[1] = ObjectTypeIndex;

                //
                // the structure of each element is identical
                // therefore just copy them all in one shot
                //

                RtlCopyMemory( *ppObjectTypeList,
                               pInObjectTypes->pObjectTypes,
                               pOutParam->Length );
                (*ppObjectTypeList)[0].Flags = SE_ADT_OBJECT_ONLY;
                break;
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }

    }
    
//Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if ( fObjectTypeListAllocated )
        {
            LsapFreeLsaHeap( *ppObjectTypeList );
            *ppObjectTypeList = NULL;
        }
    }
    
    return Status;
}


NTSTATUS 
LsapAdtFreeAuditContext(
    AUDIT_HANDLE hAudit
    )
/*++

Routine Description:

    Free resources allocated for the specified audit context

Arguments:

    hAudit - handle to audit context to free

Return Value:

    STATUS_SUCCESS

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PAUDIT_CONTEXT pAuditContext;

    pAuditContext = AdtpContextPtrFromHandle( hAudit );
    
    DsysAssertMsg(pAuditContext, "LsapAdtFreeAuditContext" );
    
    DsysAssertMsg( LsapAdtIsValidAuditContext( hAudit ) == STATUS_SUCCESS,
                  "LsapAdtFreeAuditContext: audit context may be corrupt");
    
    LsapFreeLsaHeap( pAuditContext );
    
    return Status;
}


NTSTATUS 
LsapAdtCheckAuditPrivilege()
/*++

Routine Description:

    Check if the rpc client has SeAuditPrivilege.

Arguments:
    None

Return Value:

    STATUS_SUCCESS            if privilege held
    STATUS_PRIVILEGE_NOT_HELD if privilege not held
    error codes returned by NtOpenThreadToken, NtQueryInformationToken

Notes:
    

--*/
{
    NTSTATUS Status = STATUS_PRIVILEGE_NOT_HELD;
    HANDLE hToken = NULL;
    PRIVILEGE_SET PrivilegeSet = { 0 };
    BOOLEAN fHasAuditPrivilege = FALSE;
    BOOL fImpersonated = FALSE;

#if DBG
    //
    // make sure that we are not already impersonating
    //

    Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY, TRUE, &hToken );

    DsysAssertMsg( Status == STATUS_NO_TOKEN, "LsapAdtCheckAuditPrivilege" );
    
    if ( NT_SUCCESS(Status) )
    {
        NtClose( hToken );
    }
#endif
    //
    // impersonate rpc caller
    //

    Status = I_RpcMapWin32Status(RpcImpersonateClient( NULL ));

    if (NT_SUCCESS(Status))
    {
        fImpersonated = TRUE;
        Status = NtOpenThreadToken( NtCurrentThread(), TOKEN_QUERY,
                                    TRUE, &hToken );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    PrivilegeSet.PrivilegeCount          = 1;
    PrivilegeSet.Control                 = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid       = AuditPrivilege;
    PrivilegeSet.Privilege[0].Attributes = 0;

    Status = NtPrivilegeCheck( hToken, &PrivilegeSet, &fHasAuditPrivilege );

    if ( NT_SUCCESS(Status) && !fHasAuditPrivilege )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }
    
    
Cleanup:
    if ( hToken )
    {
        NtClose( hToken );
    }

    if ( fImpersonated )
    {
        Status = I_RpcMapWin32Status(RpcRevertToSelf());        
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtgens.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N S . C
//
// Contents:    RPC server stubs
//
//
// History:     
//   07-January-2000  kumarp        created
//
// Notes:
// - for help on Lsar* function/parameter usage, please see
//   the corresponding Lsap* function in file adtgenp.c
// 
//------------------------------------------------------------------------

#include <lsapch2.h>
#include "adtp.h"

#include "adtgen.h"
#include "adtgenp.h"

NTSTATUS
LsarRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PHANDLE phAuditContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    Status = LsapRegisterAuditEvent( pAuditEventType, phAuditContext );

    return Status;
}

NTSTATUS
LsarGenAuditEvent(
    IN  HANDLE        hAuditContext,
    IN  DWORD         Flags,
    OUT PAUDIT_PARAMS pAuditParams
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapGenAuditEvent( hAuditContext, Flags, pAuditParams, NULL );

    return Status;
}

NTSTATUS
LsarUnregisterAuditEvent(
    IN OUT PHANDLE phAuditContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    Status = LsapUnregisterAuditEvent( phAuditContext );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtifn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtifn.c

Abstract:

    This file has functions exported to other trusted modules in LSA.
    (LsaIAudit* functions)

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"
#include <md5.h>

NTSTATUS
LsaIGetLogonGuid(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain,
    IN PBYTE pBuffer,
    IN UINT BufferSize,
    OUT LPGUID pLogonGuid
    )
/*++

Routine Description:

    Concatenate pUserName->Buffer, pUserDomain->Buffer and pBuffer
    into a single binary buffer. Get a MD5 hash of this concatenated
    buffer and return it in the form of a GUID.

Arguments:

    pUserName   - name of user

    pUserDomain - name of user domain 

    pBuffer     - pointer to KERB_TIME structure. The caller casts this to 
                  PBYTE and passes this to us. This allows us to keep KERB_TIME
                  structure private to kerberos and offer future extensibility,
                  should we decide to use another field from the ticket.

    BufferSize  - size of buffer (currently sizeof(KERB_TIME))

    pLogonGuid  - pointer to returned logon GUID

Return Value:

    NTSTATUS    - Standard Nt Result Code

Notes:

    The generated GUID is recorded in the audit log in the form of
    'Logon GUID' field in the following events:
    * On client machine
      -- SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS

    * On KDC
      -- SE_AUDITID_TGS_TICKET_REQUEST

    * On target server
      -- SE_AUDITID_NETWORK_LOGON
      -- SE_AUDITID_SUCCESSFUL_LOGON

    This allows us to correlate these events to aid in intrusion detection.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UINT TempBufferLength=0;
    //
    // LSAI_TEMP_MD5_BUFFER_SIZE == UNLEN + DNS_MAX_NAME_LENGTH + sizeof(KERB_TIME) + padding
    //
#define LSAI_TEMP_MD5_BUFFER_SIZE    (256+256+16)
    BYTE TempBuffer[LSAI_TEMP_MD5_BUFFER_SIZE];
    DWORD dwError = NO_ERROR;
    MD5_CTX MD5Context = { 0 };
        
    ASSERT( LsapIsValidUnicodeString( pUserName ) );
    ASSERT( LsapIsValidUnicodeString( pUserDomain ) );
    ASSERT( pBuffer && BufferSize );
    
#if DBG
//      DbgPrint("LsaIGetLogonGuid: user: %wZ\\%wZ, buf: %I64x\n",
//               pUserDomain, pUserName, *((ULONGLONG *) pBuffer));
#endif

    TempBufferLength = pUserName->Length + pUserDomain->Length + BufferSize;

    if ( TempBufferLength < LSAI_TEMP_MD5_BUFFER_SIZE )
    {
        //
        // first concatenate user+domain+buffer and treat that as
        // a contiguous buffer.
        //
        RtlCopyMemory( TempBuffer, pUserName->Buffer, pUserName->Length );
        TempBufferLength = pUserName->Length;
        
        RtlCopyMemory( TempBuffer + TempBufferLength,
                       pUserDomain->Buffer, pUserDomain->Length );
        TempBufferLength += pUserDomain->Length;

        RtlCopyMemory( TempBuffer + TempBufferLength,
                       pBuffer, BufferSize );
        TempBufferLength += BufferSize;

        //
        // get MD5 hash of the concatenated buffer
        //
        MD5Init( &MD5Context );
        MD5Update( &MD5Context, TempBuffer, TempBufferLength );
        MD5Final( &MD5Context );

        //
        // return the hash as a GUID
        //
        RtlCopyMemory( pLogonGuid, MD5Context.digest, 16 );

        Status = STATUS_SUCCESS;
    }
    else
    {
        ASSERT( FALSE && "LsaIGetLogonGuid: TempBuffer overflow");
        Status = STATUS_BUFFER_OVERFLOW;
    }

    return Status;
}


VOID
LsaIAuditKerberosLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN PSID UserSid,                            OPTIONAL
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId,
    IN LPGUID LogonGuid
    )
/*++

Routine Description/Arguments/Return value

    See header comment for LsapAuditLogonHelper

Notes:
    A new field (logon GUID) was added to this audit event.
    In order to send this new field to LSA, we had two options:
      1) add new function (AuditLogonEx) to LSA dispatch table
      2) define a private (LsaI) function to do the job

    option#2 was chosen because the logon GUID is a Kerberos only feature.
    
--*/
{
    LsapAuditLogonHelper(
        LogonStatus,
        LogonSubStatus,
        AccountName,
        AuthenticatingAuthority,
        WorkstationName,
        UserSid,
        LogonType,
        TokenSource,
        LogonId,
        LogonGuid
        );
}


NTSTATUS
LsaIAuditLogonUsingExplicitCreds(
    IN USHORT          AuditEventType,
    IN PSID            pUser1Sid,
    IN PUNICODE_STRING pUser1Name,
    IN PUNICODE_STRING pUser1Domain,
    IN PLUID           pUser1LogonId,
    IN LPGUID          pUser1LogonGuid,  OPTIONAL
    IN PUNICODE_STRING pUser2Name,
    IN PUNICODE_STRING pUser2Domain,
    IN LPGUID          pUser2LogonGuid
    )
/*++

Routine Description:

    This event is generated by Kerberos package when a logged on user
    (pUser1*) supplies explicit credentials of another user (pUser2*) and
    creates a new logon session either locally or on a remote machine.

Parmeters:

    pUser1Sid        - SID of user1

    pUser1Name       - name of user1

    pUser1Domain     - domain of user1

    pUser1LogonId    - logon-id of user1

    pUser1LogonGuid  - logon GUID of user1
                       This is NULL if user1 logged on using NTLM.
                       (NTLM does not support logon GUID)

    pUser2Name       - name of user2

    pUser2Domain     - domain of user2

    pUser2LogonGuid  - logon-id of user2

Return Value:

    NTSTATUS    - Standard Nt Result Code

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

        
//      ASSERT( pUser1Name   && pUser1Name->Buffer   && pUser1Name->Length );
//      ASSERT( pUser1Domain && pUser1Domain->Buffer && pUser1Domain->Length );
    ASSERT( pUser1LogonId );
    ASSERT( pUser2Name   && pUser2Name->Buffer   && pUser2Name->Length );
    ASSERT( pUser2Domain && pUser2Domain->Buffer && pUser2Domain->Length );
    ASSERT( pUser2LogonGuid );

    UNREFERENCED_PARAMETER( pUser1Name );
    UNREFERENCED_PARAMETER( pUser1Domain );
    
    //
    // if policy is not enabled, returned quickly
    //
    if (!LsapAdtIsAuditingEnabledForCategory( AuditCategoryLogon, AuditEventType))
    {
        goto FunctionReturn;
    }
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_LOGON,
        SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS,
        AuditEventType,
        7,                     // there are 7 params to init

        //
        //    User Sid
        //    
        //    ISSUE-2001/04/26-kumarp : this should really use pUser1Sid
        //    currently this is not possible because
        //    KerbGenerateAuditForLogonUsingExplicitCreds does not pass
        //    us a correct pUser1Sid
        //
        SeAdtParmTypeSid,        LsapLocalSystemSid,

        //
        //    Subsystem name (if available)
        //
        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    current user logon id
        //
        SeAdtParmTypeLogonId,    *pUser1LogonId,

        //
        //    user1 logon GUID
        //
        SeAdtParmTypeGuid,       pUser1LogonGuid,

        //
        //    user2 name
        //
        SeAdtParmTypeString,     pUser2Name,

        //
        //    user2 domain name
        //
        SeAdtParmTypeString,     pUser2Domain,

        //
        //    user2 logon GUID
        //
        SeAdtParmTypeGuid,       pUser2LogonGuid

        );
    

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    
    if (!NT_SUCCESS(Status)) {

        LsapAuditFailed( Status );
    }

 FunctionReturn:
    return Status;
}


NTSTATUS
LsaIAuditKdcEvent(
    IN ULONG                AuditId,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      ClientDomain,
    IN PSID                 ClientSid,
    IN PUNICODE_STRING      ServiceName,
    IN PSID                 ServiceSid,
    IN PULONG               KdcOptions,
    IN PULONG               KerbStatus,
    IN PULONG               EncryptionType,
    IN PULONG               PreauthType,
    IN PBYTE                ClientAddress,
    IN LPGUID               LogonGuid       OPTIONAL
    )
/*++

Abstract:

    This routine produces an audit record representing a KDC
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.

    ClientName -

    ClientDomain -

    ClientSid -

    ServiceName -

    ServiceSid -

    KdcOptions -

    KerbStatus -

    EncryptionType -

    PreauthType -



--*/

{

    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING SubsystemName;
    UNICODE_STRING AddressString;
    WCHAR AddressBuffer[3*4+4];         // space for a dotted-quad IP address
    ULONG LengthRequired;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return(STATUS_SUCCESS);
    }


    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_LOGON;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = ((ARGUMENT_PRESENT(KerbStatus) &&
                            (*KerbStatus != 0)) ?
                                EVENTLOG_AUDIT_FAILURE :
                                EVENTLOG_AUDIT_SUCCESS );

    if (AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS) {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS)) {
            return(STATUS_SUCCESS);
        }
    } else {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE)) {
            return(STATUS_SUCCESS);
        }
    }

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    RtlInitUnicodeString( &SubsystemName, L"Security" );

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &SubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(ClientName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ClientName );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientDomain)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ClientDomain );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientSid)) {

        //
        // Add a SID to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ServiceName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ServiceName );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ServiceSid)) {

        //
        // Add a SID to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ServiceSid );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET || AuditId == SE_AUDITID_TGS_TICKET_REQUEST) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(KdcOptions)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KdcOptions );

        AuditParameters.ParameterCount++;

    }

    //
    // Failure code is the last parameter for SE_AUDITID_TGS_TICKET_REQUEST
    //

    if (AuditId != SE_AUDITID_TGS_TICKET_REQUEST)
    {
        if (ARGUMENT_PRESENT(KerbStatus)) {

            //
            // Add a ULONG to the audit message
            //

            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KerbStatus );

            AuditParameters.ParameterCount++;

        } else if (AuditId == SE_AUDITID_AS_TICKET) {

            AuditParameters.ParameterCount++;

        }
    }

    if (ARGUMENT_PRESENT(EncryptionType)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *EncryptionType );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET || AuditId == SE_AUDITID_TGS_TICKET_REQUEST) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(PreauthType)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeUlong( AuditParameters, AuditParameters.ParameterCount, *PreauthType );

        AuditParameters.ParameterCount++;

    } else if (AuditId == SE_AUDITID_AS_TICKET) {

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientAddress)) {

        AddressBuffer[0] = L'\0';
        swprintf(AddressBuffer,L"%d.%d.%d.%d",
            ClientAddress[0],
            (ULONG) ClientAddress[1],
            (ULONG) ClientAddress[2],
            (ULONG) ClientAddress[3]
            );
        RtlInitUnicodeString(
            &AddressString,
            AddressBuffer
            );

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &AddressString );

        AuditParameters.ParameterCount++;

    }

    //
    // Failure code is the last parameter for SE_AUDITID_TGS_TICKET_REQUEST
    //

    if (AuditId == SE_AUDITID_TGS_TICKET_REQUEST)
    {
        if (ARGUMENT_PRESENT(KerbStatus)) {

            //
            // Add a ULONG to the audit message
            //

            LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *KerbStatus );

            AuditParameters.ParameterCount++;

        } else {

            AuditParameters.ParameterCount++;

        }

        if (ARGUMENT_PRESENT(LogonGuid)) {

            //
            // Add the globally unique logon-id to the audit message
            //

            LsapSetParmTypeGuid( AuditParameters, AuditParameters.ParameterCount, LogonGuid );

            AuditParameters.ParameterCount++;

        }
        else {

            if (( AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS ) &&
                ( AuditId == SE_AUDITID_TGS_TICKET_REQUEST )) {
                
                ASSERT( FALSE && L"LsaIAuditKdcEvent: UniqueID not supplied to successful SE_AUDITID_TGS_TICKET_REQUEST  audit event" );
            }
            
            AuditParameters.ParameterCount++;

        }
    }


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );
    return(STATUS_SUCCESS);

}



NTSTATUS
LsaIAuditAccountLogon(
    IN ULONG                AuditId,
    IN BOOLEAN              Successful,
    IN PUNICODE_STRING      Source,
    IN PUNICODE_STRING      ClientName,
    IN PUNICODE_STRING      MappedName,
    IN NTSTATUS             Status OPTIONAL
    )
/*++

Abstract:

    This routine produces an audit record representing the mapping of a
    foreign principal name onto an NT account.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.

    Successful - Indicates the code should generate a success audit

    Source - Source module generating audit, such as SCHANNEL or KDC

    ClientName - Name being mapped.

    MappedName - Name of NT account to which the client name was mapped.

    Status - NT Status code for any failures.


--*/

{

    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING SubsystemName;
    ULONG LengthRequired;


    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return( STATUS_SUCCESS );
    }


    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_LOGON;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = Successful ?
                                EVENTLOG_AUDIT_SUCCESS :
                                EVENTLOG_AUDIT_FAILURE ;

    if (AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS) {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS)) {
            return( STATUS_SUCCESS );
        }
    } else {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE)) {
            return( STATUS_SUCCESS );
        }
    }

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    RtlInitUnicodeString( &SubsystemName, L"Security" );

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &SubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(Source)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, Source );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(ClientName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, ClientName );

        AuditParameters.ParameterCount++;

    }


    if (ARGUMENT_PRESENT(MappedName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, MappedName );

        AuditParameters.ParameterCount++;

    }

    //
    // Add a ULONG to the audit message
    //

    LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, Status );

    AuditParameters.ParameterCount++;


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );
    return(STATUS_SUCCESS);

}


NTSTATUS NTAPI
LsaIAuditDPAPIEvent(
    IN ULONG                AuditId,
    IN PSID                 UserSid,
    IN PUNICODE_STRING      MasterKeyID,
    IN PUNICODE_STRING      RecoveryServer,
    IN PULONG               Reason,
    IN PUNICODE_STRING      RecoverykeyID,
    IN PULONG               FailureReason
    )
/*++

Abstract:

    This routine produces an audit record representing a DPAPI
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.


    MasterKeyID -

    RecoveryServer -

    Reason -

    RecoverykeyID -

    FailureReason -


--*/

{

    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UNICODE_STRING SubsystemName;
    UNICODE_STRING AddressString;
    WCHAR AddressBuffer[3*4+4];         // space for a dotted-quad IP address
    ULONG LengthRequired;


    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return(STATUS_SUCCESS);
    }


    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_DETAILED_TRACKING;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = ((ARGUMENT_PRESENT(FailureReason) &&
                            (*FailureReason != 0)) ?
                                EVENTLOG_AUDIT_FAILURE :
                                EVENTLOG_AUDIT_SUCCESS );

    if (AuditParameters.Type == EVENTLOG_AUDIT_SUCCESS) {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_SUCCESS)) {
            return(STATUS_SUCCESS);
        }
    } else {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategoryAccountLogon] & POLICY_AUDIT_EVENT_FAILURE)) {
            return(STATUS_SUCCESS);
        }
    }

    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, UserSid ? UserSid : LsapLocalSystemSid );

    AuditParameters.ParameterCount++;

    RtlInitUnicodeString( &SubsystemName, L"Security" );

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &SubsystemName );

    AuditParameters.ParameterCount++;



    if (ARGUMENT_PRESENT(MasterKeyID)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, MasterKeyID );

        AuditParameters.ParameterCount++;

    }


    if (ARGUMENT_PRESENT(RecoveryServer)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, RecoveryServer );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(Reason)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *Reason );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(RecoverykeyID)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, RecoverykeyID );

        AuditParameters.ParameterCount++;

    }


    if (ARGUMENT_PRESENT(FailureReason)) {

        //
        // Add a ULONG to the audit message
        //

        LsapSetParmTypeHexUlong( AuditParameters, AuditParameters.ParameterCount, *FailureReason );

        AuditParameters.ParameterCount++;

    }


    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );
    return(STATUS_SUCCESS);

}



NTSTATUS
LsaIWriteAuditEvent(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    IN ULONG Options
    )
/*++

Abstract:

    This routine writes an audit record to the log. The only available
    option is LSA_AUDIT_PARAMETERS_ABSOULUTE, indicating that the pointers
    in the data structure have not been converted to offsets.


Parmeters:

    AuditParameters - The audit record
    Options - Options for loggin. May only be LSA_AUDIT_PARAMETERS_ABSOLUTE

--*/
{
    ULONG LogOptions = 0;
    ULONG CategoryId;
    
    if ( !ARGUMENT_PRESENT(AuditParameters) ||
         (Options != 0)                     ||
         !IsValidCategoryId( AuditParameters->CategoryId ) ||
         !IsValidAuditId( AuditParameters->AuditId )       ||
         !IsValidParameterCount( AuditParameters->ParameterCount ))
    {
        return STATUS_INVALID_PARAMETER;
    }
    

    //
    // Ensure auditting is enabled
    //
    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return STATUS_SUCCESS;
    }

    //
    // LsapAdtEventsInformation.EventAuditingOptions needs to be indexed
    // by one of enum POLICY_AUDIT_EVENT_TYPE values whereas the value
    // of SE_ADT_PARAMETER_ARRAY.CategoryId must be one of SE_CATEGID_*
    // values. The value of corresponding elements in the two types differ by 1. 
    // Subtract 1 from AuditParameters->CategoryId to get the right
    // AuditCategory* value.
    //

    CategoryId = AuditParameters->CategoryId - 1;
    
    if (AuditParameters->Type == EVENTLOG_AUDIT_SUCCESS) {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[CategoryId] & POLICY_AUDIT_EVENT_SUCCESS)) {
            return STATUS_SUCCESS;
        }
    } else {
        if (!(LsapAdtEventsInformation.EventAuditingOptions[CategoryId] & POLICY_AUDIT_EVENT_FAILURE)) {
            return STATUS_SUCCESS;
        }
    }

    //
    // Audit the event
    //
    return(LsapAdtWriteLog( AuditParameters, LogOptions ));
}



VOID
LsaIAuditNotifyPackageLoad(
    PUNICODE_STRING PackageFileName
    )

/*++

Routine Description:

    Audits the loading of an notification package.

Arguments:

    PackageFileName - The name of the package being loaded.

Return Value:

    None.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    NTSTATUS Status;
    SE_ADT_PARAMETER_ARRAY AuditParameters;

    if ( !LsapAdtEventsInformation.AuditingMode ) {
        return;
    }

    if (!(LsapAdtEventsInformation.EventAuditingOptions[AuditCategorySystem] & POLICY_AUDIT_EVENT_SUCCESS)) {
        return;
    }

    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_SYSTEM;
    AuditParameters.AuditId = SE_AUDITID_NOTIFY_PACKAGE_LOAD;
    AuditParameters.Type = EVENTLOG_AUDIT_SUCCESS;
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, LsapLocalSystemSid );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &LsapSubsystemName );
    AuditParameters.ParameterCount++;

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, PackageFileName );
    AuditParameters.ParameterCount++;

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    return;
}


NTSTATUS
LsaIAuditSamEvent(
    IN NTSTATUS             PassedStatus,
    IN ULONG                AuditId,
    IN PSID                 DomainSid,
    IN PUNICODE_STRING      AdditionalInfo    OPTIONAL,
    IN PULONG               MemberRid         OPTIONAL,
    IN PSID                 MemberSid         OPTIONAL,
    IN PUNICODE_STRING      AccountName       OPTIONAL,
    IN PUNICODE_STRING      DomainName,
    IN PULONG               AccountRid        OPTIONAL,
    IN PPRIVILEGE_SET       Privileges        OPTIONAL
    )
/*++

Abstract:

    This routine produces an audit record representing an account
    operation.

    This routine goes through the list of parameters and adds a string
    representation of each (in order) to an audit message.  Note that
    the full complement of account audit message formats is achieved by
    selecting which optional parameters to include in this call.

    In addition to any parameters passed below, this routine will ALWAYS
    add the impersonation client's user name, domain, and logon ID as
    the LAST parameters in the audit message.


Parmeters:

    AuditId - Specifies the message ID of the audit being generated.

    DomainSid - This parameter results in a SID string being generated
        ONLY if neither the MemberRid nor AccountRid parameters are
        passed.  If either of those parameters are passed, this parameter
        is used as a prefix of a SID.

    AdditionalInfo - This optional parameter, if present, is used to
        produce any additional inforamtion the caller wants to add.
        Used by SE_AUDITID_USER_CHANGE and SE_AUDITID_GROUP_TYPE_CHANGE.
        for user change, the additional info states the nature of the
        change, such as Account Disable, unlocked or account Name Changed.
        For Group type change, this parameter should state the group type
        has been change from AAA to BBB.

    MemberRid - This optional parameter, if present, is added to the end of
        the DomainSid parameter to produce a "Member" sid.  The resultant
        member SID is then used to build a sid-string which is added to the
        audit message following all preceeding parameters.
        This parameter supports global group membership change audits, where
        member IDs are always relative to a local domain.

    MemberSid - This optional parameter, if present, is converted to a
        SID string and added following preceeding parameters.  This parameter
        is generally used for describing local group (alias) members, where
        the member IDs are not relative to a local domain.

    AccountName - This optional parameter, if present, is added to the audit
        message without change following any preceeding parameters.
        This parameter is needed for almost all account audits and does not
        need localization.

    DomainName - This optional parameter, if present, is added to the audit
        message without change following any preceeding parameters.
        This parameter is needed for almost all account audits and does not
        need localization.


    AccountRid - This optional parameter, if present, is added to the end of
        the DomainSid parameter to produce an "Account" sid.  The resultant
        Account SID is then used to build a sid-string which is added to the
        audit message following all preceeding parameters.
        This parameter supports audits that include "New account ID" or
        "Target Account ID" fields.

    Privileges - The privileges passed via this optional parameter,
        if present, will be converted to string format and added to the
        audit message following any preceeding parameters.  NOTE: the
        caller is responsible for freeing the privilege_set (in fact,
        it may be on the stack).  ALSO NOTE: The privilege set will be
        destroyed by this call (due to use of the routine used to
        convert the privilege values to privilege names).


--*/

{

    NTSTATUS Status;
    LUID LogonId = SYSTEM_LUID;
    PSID NewAccountSid = NULL;
    PSID NewMemberSid = NULL;
    PSID SidPointer;
    PSID ClientSid = NULL;
    PTOKEN_USER TokenUserInformation = NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters;
    UCHAR AccountSidBuffer[256];
    UCHAR MemberSidBuffer[256];
    UCHAR SubAuthorityCount;
    UNICODE_STRING SubsystemName;
    ULONG LengthRequired;

    if ( AuditId == SE_AUDITID_ACCOUNT_AUTO_LOCKED )
    {
        
        //
        // In this case use LogonID as SYSTEM, SID is SYSTEM.
        //

        ClientSid = LsapLocalSystemSid;

    } else {

        Status = LsapQueryClientInfo(
                     &TokenUserInformation,
                     &LogonId
                     );

        if ( !NT_SUCCESS( Status )) {
            return( Status );
        }

        ClientSid = TokenUserInformation->User.Sid;
    }


    RtlZeroMemory (
       (PVOID) &AuditParameters,
       sizeof( AuditParameters )
       );

    AuditParameters.CategoryId = SE_CATEGID_ACCOUNT_MANAGEMENT;
    AuditParameters.AuditId = AuditId;
    AuditParameters.Type = (NT_SUCCESS(PassedStatus) ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE );
    AuditParameters.ParameterCount = 0;

    LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, ClientSid );

    AuditParameters.ParameterCount++;

    RtlInitUnicodeString( &SubsystemName, L"Security" );

    LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, &SubsystemName );

    AuditParameters.ParameterCount++;

    if (ARGUMENT_PRESENT(AdditionalInfo))
    {
        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AdditionalInfo );

        AuditParameters.ParameterCount++;
    }

    if (ARGUMENT_PRESENT(MemberRid)) {

        //
        // Add a member SID string to the audit message
        //
        //  Domain Sid + Member Rid = Final SID.

        SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid );

        if ( (LengthRequired = RtlLengthRequiredSid( SubAuthorityCount + 1 )) > 256 ) {

            NewMemberSid = LsapAllocateLsaHeap( LengthRequired );

            if ( NewMemberSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            SidPointer = NewMemberSid;

        } else {

            SidPointer = (PSID)MemberSidBuffer;
        }

        Status = RtlCopySid (
                     LengthRequired,
                     SidPointer,
                     DomainSid
                     );

        ASSERT( NT_SUCCESS( Status ));

        *(RtlSubAuthoritySid( SidPointer, SubAuthorityCount )) = *MemberRid;
        *RtlSubAuthorityCountSid( SidPointer ) = SubAuthorityCount + 1;

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, SidPointer );

        AuditParameters.ParameterCount++;
    }

    if (ARGUMENT_PRESENT(MemberSid)) {

        //
        // Add a member SID string to the audit message
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, MemberSid );

        AuditParameters.ParameterCount++;

    } else {

        if (SE_AUDITID_ADD_SID_HISTORY == AuditId) {
    
            //
            // Add dash ( - ) string to the audit message (SeAdtParmTypeNone)
            // by calling LsapSetParmTypeSid with NULL as third parameter
            //
    
            LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, NULL );
    
            AuditParameters.ParameterCount++;
        }
    }


    if (ARGUMENT_PRESENT(AccountName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, AccountName );

        AuditParameters.ParameterCount++;
    }


    if (ARGUMENT_PRESENT(DomainName)) {

        //
        // Add a UNICODE_STRING to the audit message
        //

        LsapSetParmTypeString( AuditParameters, AuditParameters.ParameterCount, DomainName );

        AuditParameters.ParameterCount++;
    }




    if (ARGUMENT_PRESENT(DomainSid) &&
        !(ARGUMENT_PRESENT(MemberRid) || ARGUMENT_PRESENT(AccountRid))
       ) {

        //
        // Add the domain SID as a SID string to the audit message
        //
        // Just the domain SID.
        //

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, DomainSid );

        AuditParameters.ParameterCount++;

    }

    if (ARGUMENT_PRESENT(AccountRid)) {

        //
        // Add a member SID string to the audit message
        // Domain Sid + account Rid = final sid
        //

        SubAuthorityCount = *RtlSubAuthorityCountSid( DomainSid );

        if ( (LengthRequired = RtlLengthRequiredSid( SubAuthorityCount + 1 )) > 256 ) {

            NewAccountSid = LsapAllocateLsaHeap( LengthRequired );

            if ( NewAccountSid == NULL ) {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            SidPointer = NewAccountSid;

        } else {

            SidPointer = (PSID)AccountSidBuffer;
        }


        Status = RtlCopySid (
                     LengthRequired,
                     SidPointer,
                     DomainSid
                     );

        ASSERT( NT_SUCCESS( Status ));

        *(RtlSubAuthoritySid( SidPointer, SubAuthorityCount )) = *AccountRid;
        *RtlSubAuthorityCountSid( SidPointer ) = SubAuthorityCount + 1;

        LsapSetParmTypeSid( AuditParameters, AuditParameters.ParameterCount, SidPointer );

        AuditParameters.ParameterCount++;
    }

    //
    // Now add the caller information
    //
    //      Caller name
    //      Caller domain
    //      Caller logon ID
    //


    LsapSetParmTypeLogonId( AuditParameters, AuditParameters.ParameterCount, LogonId );

    AuditParameters.ParameterCount++;

    //
    // Add any privileges
    //

    if (ARGUMENT_PRESENT(Privileges)) {

        LsapSetParmTypePrivileges( AuditParameters, AuditParameters.ParameterCount, Privileges );
    }

    AuditParameters.ParameterCount++;

    //
    // Now write out the audit record to the audit log
    //

    ( VOID ) LsapAdtWriteLog( &AuditParameters, 0 );

    //
    // And clean up any allocated memory
    //

    Status = STATUS_SUCCESS;
Cleanup:
    if ( NewMemberSid != NULL ) {
        LsapFreeLsaHeap( NewMemberSid );
    }

    if ( NewAccountSid != NULL ) {
        LsapFreeLsaHeap( NewAccountSid );
    }

    if ( TokenUserInformation != NULL ) {
        LsapFreeLsaHeap( TokenUserInformation );
    }
    return Status;
}

NTSTATUS
LsaIAuditPasswordAccessEvent(
    IN USHORT EventType,
    IN PCWSTR pszTargetUserName,
    IN PCWSTR pszTargetUserDomain
    )

/*++

Routine Description:

    Generate SE_AUDITID_PASSWORD_HASH_ACCESS event. This is generated when
    user password hash is retrieved by the ADMT password filter DLL.
    This typically happens during ADMT password migration.
        

Arguments:

    EventType - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    pszTargetUserName - name of user whose password is being retrieved

    pszTargetUserDomain - domain of user whose password is being retrieved

Return Value:

    NTSTATUS - Standard NT Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    UNICODE_STRING TargetUser;
    UNICODE_STRING TargetDomain;
    
    //
    //  if auditing is not enabled, return asap
    //

    if ( !LsapAdtIsAuditingEnabledForCategory( AuditCategoryAccountManagement,
                                               EventType ) )
    {
        goto Cleanup;
    }

    if ( !((EventType == EVENTLOG_AUDIT_SUCCESS) ||
           (EventType == EVENTLOG_AUDIT_FAILURE))   ||
         !pszTargetUserName  || !pszTargetUserDomain ||
         !*pszTargetUserName || !*pszTargetUserDomain )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // get caller info from the thread token
    //

    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString( &TargetUser,   pszTargetUserName );
    RtlInitUnicodeString( &TargetDomain, pszTargetUserDomain );
    
    LsapAdtInitParametersArray(
        &AuditParameters,
        SE_CATEGID_ACCOUNT_MANAGEMENT,
        SE_AUDITID_PASSWORD_HASH_ACCESS,
        EventType,
        5,                     // there are 5 params to init

        //
        //    User Sid
        //

        SeAdtParmTypeSid,        TokenUserInformation->User.Sid,

        //
        //    Subsystem name (if available)
        //

        SeAdtParmTypeString,     &LsapSubsystemName,

        //
        //    target user name
        //

        SeAdtParmTypeString,      &TargetUser,

        //
        //    target user domain name
        //

        SeAdtParmTypeString,      &TargetDomain,

        //
        //    client auth-id
        //

        SeAdtParmTypeLogonId,     ClientAuthenticationId
        );
    
    Status = LsapAdtWriteLog( &AuditParameters, 0 );
        
Cleanup:

    if (TokenUserInformation != NULL) 
    {
        LsapFreeLsaHeap( TokenUserInformation );
    }

    if (!NT_SUCCESS(Status))
    {
        LsapAuditFailed( Status );
    }
    
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtinit.c

Abstract:

    Local Security Authority - Auditing Initialization

Author:

    Scott Birrell       (ScottBi)      November 20, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "adtp.h"

NTSTATUS LsapAdtInitializeCrashOnFail( VOID );

//
// Array of drive letter to device mappings for generating path strings.
//

DRIVE_MAPPING DriveMappingArray[MAX_DRIVE_MAPPING];


//
// Name that will be used as the default subsystem name for LSA generated events
//

UNICODE_STRING LsapSubsystemName;


//
// Special privilege values which are not normally audited,
// but generate audits when assigned to a user.  See
// LsapAdtAuditSpecialPrivileges.
//

LUID ChangeNotifyPrivilege;
LUID AuditPrivilege;
LUID CreateTokenPrivilege;
LUID AssignPrimaryTokenPrivilege;
LUID BackupPrivilege;
LUID RestorePrivilege;
LUID DebugPrivilege;


//
// Global variable indicating whether or not we are supposed
// to crash when an audit fails.
//

BOOLEAN LsapCrashOnAuditFail = FALSE;
BOOLEAN LsapAllowAdminLogonsOnly = FALSE;



NTSTATUS
LsapAdtInitialize(
    )

/*++

Routine Description:

    This function performs initialization of auditing within the LSA, and
    it also issues commands to the Reference Monitor to enable it to
    complete any initialization of auditing variables that is dependent
    on the content of the LSA Database.  At time of call, the main
    System Init thread is in the Reference Monitor awaiting completion
    of all LSA initialization, and the Reference Monitor Command
    Server thread is waiting for commands.

    The following steps are performed:

    o Read the Audit Event and Audit Log information from the LSA
      Database.
    o Call the Event Logging function to open the Audit Log
    o Issue a Reference Monitor command to write the Audit Event Info
      to the Reference-Monitor's in-memory database.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG AuditLogInfoLength = sizeof (POLICY_AUDIT_LOG_INFO);
    ULONG AuditEventInfoLength = sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO);
    ULONG AuditFullQueryInfoLength = sizeof (POLICY_AUDIT_FULL_QUERY_INFO);
    UNICODE_STRING UnicodeString;
    PUNICODE_STRING Strings;
    PSID Sid = NULL;
    LSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo;

    Strings = &UnicodeString;

    RtlInitUnicodeString( Strings, L"System Restart");

    RtlInitUnicodeString( &LsapSubsystemName, L"Security" );

    //
    // init LsapCrashOnAuditFail global var so that we can crash
    // if any of the following initialization fails
    //

    (VOID) LsapAdtInitializeCrashOnFail();

    Status = LsapAdtInitGenericAudits();

    if (!NT_SUCCESS(Status)) {

        goto AuditInitError;
    }

    Status = LsapAdtInitializeLogQueue();

    if (!NT_SUCCESS(Status)) {

        goto AuditInitError;
    }

    //
    // Read the Audit Log Information from the PolAdtLg attribute of the Lsa
    // Database object.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolAdtLg],
                 &LsapAdtLogInformation,
                 &AuditLogInfoLength
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapAdtInitialize: Read Audit Log Info returned 0x%lx\n",
            Status
            );

        goto AuditInitError;
    }

    //
    // Query the Audit Log Full Information in the LSA Database.  Note
    // that it is too early to update a log full condition, so don't
    // try to write to the Audit Log.
    //

//     Status = LsapAdtQueryAuditLogFullInfo(
//                  LsapDbHandle,
//                  (ULONG) 0,
//                  &LsapAdtLogFullInformation
//                  );

//     if (!NT_SUCCESS(Status)) {

//         LsapLogError(
//             "LsapAdtInitialize: Update Audit Log Full Info returned 0x%lx\n",
//             Status
//             );

//         goto AuditInitError;
//     }

    //
    // Read the Audit Event Information from the AdtEvent attribute of the Lsa
    // Database object.  The information consists of the Auditing Mode and
    // the Auditing Options for each Audit Event Type.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolAdtEv],
                 &AuditEventsInfo,
                 &AuditEventInfoLength
                 );

    if (!NT_SUCCESS(Status)) {

        //
        // This section of code is temporary and allows an old
        // Policy Database to work with the new Audit Event Categories
        // without the need to re-install.  The Audit Event Information
        // is overwritten with the new format and all auditing is turned
        // off.
        //

        if (Status == STATUS_BUFFER_OVERFLOW) {

            KdPrint(("LsapAdtInitialize: Old Audit Event Info detected\n"
                    "Replacing with new format, all auditing disabled\n"));

            //
            // Initialize Default Event Auditing Options.  No auditing is specified
            // for any event type.
            //

            Status = LsapAdtInitializeDefaultAuditing(
                         LSAP_DB_UPDATE_POLICY_DATABASE,
                         &AuditEventsInfo
                         );

            if (!NT_SUCCESS(Status)) {

                goto AuditInitError;
            }

        } else {

            LsapLogError(
                "LsapAdtInitialize: Read Audit Event Info returned 0x%lx\n",
                Status
                );
            goto AuditInitError;
        }
    }

    //
    // Set global flags to tell us if we're supposed to be auditing
    // successful logons, failed logons, or both
    //
    //

    LsapAdtAuditingLogon( &AuditEventsInfo );

    //
    // During system initialization, we are effectively logged on as
    // system.
    //

    LsapAdtSystemRestart( &AuditEventsInfo );

    //
    // Send a command to the Reference Monitor to write the Auditing
    // State to its in-memory data.
    //

    Status = LsapCallRm(
                 RmAuditSetCommand,
                 &AuditEventsInfo,
                 sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
                 NULL,
                 0
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError("LsapAdtInitialize: LsapCallRm returned 0x%lx\n", Status);
        goto AuditInitError;
    }

    RtlCopyMemory(
        &LsapAdtEventsInformation,
        &AuditEventsInfo,
        sizeof(LSARM_POLICY_AUDIT_EVENTS_INFO)
        );
        
    Status = LsapAdtInitializeDriveLetters();

    if (!NT_SUCCESS(Status)) {

        LsapLogError("LsapAdtInitialize: LsapAdtInitializeDriveLetters() returned 0x%lx\n", 
            Status);
        goto AuditInitError;
    }


    //
    // Initialize privilege values we need
    //

    ChangeNotifyPrivilege       = RtlConvertLongToLuid( SE_CHANGE_NOTIFY_PRIVILEGE      );
    AuditPrivilege              = RtlConvertLongToLuid( SE_AUDIT_PRIVILEGE              );
    CreateTokenPrivilege        = RtlConvertLongToLuid( SE_CREATE_TOKEN_PRIVILEGE       );
    AssignPrimaryTokenPrivilege = RtlConvertLongToLuid( SE_ASSIGNPRIMARYTOKEN_PRIVILEGE );
    BackupPrivilege             = RtlConvertLongToLuid( SE_BACKUP_PRIVILEGE             );
    RestorePrivilege            = RtlConvertLongToLuid( SE_RESTORE_PRIVILEGE            );
    DebugPrivilege              = RtlConvertLongToLuid( SE_DEBUG_PRIVILEGE              );


AuditInitFinish:

    return(Status);

AuditInitError:

    //
    // raise harderror if LsapCrashOnAuditFail is TRUE
    //

    LsapAuditFailed( Status );

    goto AuditInitFinish;
}


NTSTATUS
LsapAdtInitializeDefaultAuditing(
    IN ULONG Options,
    OUT PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInformation
    )

/*++

Routine Description:

    This routine sets an initial default Auditing State in which auditing
    is turned off.  It is called only during initialization of the LSA
    or during the installation of its Policy Database.  The initial
    auditing state may also optionally be written to the Lsa Policy
    Database provided that the Policy Object has been created and its
    internal handle is available.

Arguments:

    Options - Specifies optional actions to be taken

        LSAP_DB_UPDATE_POLICY_DATABASE - Update the corresponding information
            in the Policy Database.  This option must only be specified
            where it is known that the Policy Object exists.

    AuditEventsInformation - Pointer to structure that will receive the Audit Event
        Information

Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE AuditEventsAttribute;
    BOOLEAN ObjectReferenced = FALSE;

    ULONG EventAuditingOptionsLength =
        (POLICY_AUDIT_EVENT_TYPE_COUNT * sizeof(POLICY_AUDIT_EVENT_OPTIONS));

    //
    // Turn off auditing and set the count of Audit Event Types (Categories)
    //

    AuditEventsInformation->AuditingMode = FALSE;
    AuditEventsInformation->MaximumAuditEventCount = POLICY_AUDIT_EVENT_TYPE_COUNT;

    //
    // Turn off auditing for all events.
    //

    RtlZeroMemory(AuditEventsInformation->EventAuditingOptions, EventAuditingOptionsLength);


    if (Options & LSAP_DB_UPDATE_POLICY_DATABASE) {

        ASSERT(LsapPolicyHandle != NULL);

        //
        // Start a transaction on the Policy Object
        //

        Status = LsapDbReferenceObject(
                     LsapPolicyHandle,
                     (ACCESS_MASK) 0,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                     );

        if (!NT_SUCCESS(Status)) {

            goto InitializeDefaultAuditingError;
        }

        ObjectReferenced = TRUE;

        LsapDbInitializeAttribute(
            &AuditEventsAttribute,
            &LsapDbNames[PolAdtEv],
            AuditEventsInformation,
            sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
            FALSE
            );

        Status = LsapDbWriteAttributesObject(
                     LsapPolicyHandle,
                     &AuditEventsAttribute,
                     (ULONG) 1
                     );

        if (!NT_SUCCESS(Status)) {

            goto InitializeDefaultAuditingError;
        }
    }

InitializeDefaultAuditingFinish:

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     LsapPolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ObjectReferenced = FALSE;
    }

    return(Status);

InitializeDefaultAuditingError:

    goto InitializeDefaultAuditingFinish;
}






VOID
LsapAdtAuditingLogon(
    PLSARM_POLICY_AUDIT_EVENTS_INFO AuditEventsInfo
    )

/*++

Routine Description:

    Examines auditing data and determines if we are auditing
    logon events.

Arguments:


    AuditEventsInfo - Auditing data.

Return Value:

    TRUE if auditing logon, FALSE otherwise.


--*/

{

    if ( !AuditEventsInfo->AuditingMode ) {

        LsapAuditSuccessfulLogons = FALSE;
        LsapAuditFailedLogons     = FALSE;

        return;
    }

    if ( (AuditEventsInfo->EventAuditingOptions)[AuditCategoryLogon] & POLICY_AUDIT_EVENT_SUCCESS ) {

        LsapAuditSuccessfulLogons = TRUE;

    } else {

        LsapAuditSuccessfulLogons = FALSE;
    }




    if ( (AuditEventsInfo->EventAuditingOptions)[AuditCategoryLogon] & POLICY_AUDIT_EVENT_FAILURE ) {

        LsapAuditFailedLogons = TRUE;

    } else {

        LsapAuditFailedLogons = FALSE;
    }
}



NTSTATUS
LsapAdtInitializeDriveLetters(
    VOID
    )
/*++

Routine Description:

    Initializes an array of symbolic link to drive letter mappings
    for use by auditing code.


Arguments:

    None.

Return Value:

    NTSTATUS - currently either STATUS_SUCCESS or STATUS_NO_MEMORY.

--*/
{
    UNICODE_STRING LinkName;
    PUNICODE_STRING DeviceName;
    OBJECT_ATTRIBUTES Obja;
    HANDLE LinkHandle;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;
    PWCHAR p;
    PWCHAR DeviceNameBuffer;
    ULONG MappingIndex = 0;

    WCHAR wszDosDevices[sizeof(L"\\DosDevices\\A:") + 1];

    wcscpy(wszDosDevices, L"\\DosDevices\\A:");

    RtlInitUnicodeString(&LinkName, wszDosDevices);


    p = (PWCHAR)LinkName.Buffer;

    //
    // Make p point to the drive letter in the LinkName string
    //

    p = p+12;



    for( i=0 ; i<26 ; i++ ){

        *p = (WCHAR)'A' + (WCHAR)i;

        InitializeObjectAttributes(
            &Obja,
            &LinkName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
        Status = NtOpenSymbolicLinkObject(
                    &LinkHandle,
                    SYMBOLIC_LINK_QUERY,
                    &Obja
                    );
        if (NT_SUCCESS( Status )) {

            //
            // Open succeeded, Now get the link value
            //

            DriveMappingArray[MappingIndex].DriveLetter = *p;
            DeviceName = &DriveMappingArray[MappingIndex].DeviceName;


            DeviceNameBuffer = LsapAllocateLsaHeap( MAXIMUM_FILENAME_LENGTH );

            //
            // if LsapAllocateLsaHeap can't get any memory then return
            //

            if (DeviceNameBuffer != NULL) {


                DeviceName->Length = 0;
                DeviceName->MaximumLength = MAXIMUM_FILENAME_LENGTH;
                DeviceName->Buffer = DeviceNameBuffer;

                Status = NtQuerySymbolicLinkObject(
                            LinkHandle,
                            DeviceName,
                            NULL
                            );

                NtClose(LinkHandle);
    
                if ( NT_SUCCESS(Status) ) {
    
                    MappingIndex++;
    
                } else {

                    LsapFreeLsaHeap( DeviceNameBuffer );
                    RtlInitUnicodeString( DeviceName, NULL );
                }

            } else {

                Status =  STATUS_NO_MEMORY;
                break; // since couldn't alloc mem, get out of the for loop and return

            }
        }
    }

    // 
    // one of two values should be return. STATUS_NO_MEMORY should be returned
    // if LsapAllocateLsaHeap() fails; STATUS_SUCCESS returns in all other
    // cases.  this test must be made because Status may contain a different
    // value after the return of NtOpenSymbolicLinkObject() or
    // NtQuerySymbolicLinkObject().  if either of those functions fail,
    // LsapAdtInitializeDriveLetters() should still return STATUS_SUCCESS.
    //

    if (Status == STATUS_NO_MEMORY) {

        return Status;

    }

    return STATUS_SUCCESS;
}


NTSTATUS
LsapAdtInitializeCrashOnFail(
    VOID
    )

/*++

Routine Description:

    Reads the registry to see if the user has told us to crash if an audit fails.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS

--*/

{
    HANDLE KeyHandle;
    NTSTATUS Status;
    NTSTATUS TmpStatus;
    OBJECT_ATTRIBUTES Obja;
    ULONG ResultLength;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    CHAR KeyInfo[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + sizeof(BOOLEAN)];
    PKEY_VALUE_PARTIAL_INFORMATION pKeyInfo;

    //
    // Check the value of the CrashOnAudit key.
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

    InitializeObjectAttributes( &Obja,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

    Status = NtOpenKey(
                 &KeyHandle,
                 KEY_QUERY_VALUE | KEY_SET_VALUE,
                 &Obja
                 );


    if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
        LsapCrashOnAuditFail = FALSE;
        return( STATUS_SUCCESS );
    }

    RtlInitUnicodeString( &ValueName, CRASH_ON_AUDIT_FAIL_VALUE );

    Status = NtQueryValueKey(
                 KeyHandle,
                 &ValueName,
                 KeyValuePartialInformation,
                 KeyInfo,
                 sizeof(KeyInfo),
                 &ResultLength
                 );

    TmpStatus = NtClose(KeyHandle);
    ASSERT(NT_SUCCESS(TmpStatus));

    //
    // If it's not found, don't enable CrashOnFail.
    //

    if (!NT_SUCCESS( Status )) {

        LsapCrashOnAuditFail = FALSE;

    } else {

        //
        // Check the value of the CrashOnFail value. If it is 1, we
        // crash on audit fail. If it is two, we only allow admins to
        // logon.
        //

        pKeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)KeyInfo;
        if (*(pKeyInfo->Data) == LSAP_CRASH_ON_AUDIT_FAIL) {
            LsapCrashOnAuditFail = TRUE;
        } else if (*(pKeyInfo->Data) == LSAP_ALLOW_ADIMIN_LOGONS_ONLY) {
            LsapAllowAdminLogonsOnly = TRUE;
        }

    }

    if ( LsapCrashOnAuditFail ) {

        BOOLEAN WasEnabled;

        Status = RtlAdjustPrivilege(
                     SE_SHUTDOWN_PRIVILEGE,
                     TRUE,
                     FALSE,
                     &WasEnabled
                     );

        //
        // This had better work.
        //

        ASSERT(NT_SUCCESS(Status));

        return( Status );

    }

    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtgenp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T G E N P . H
//
// Contents:    private definitions of types/functions required for 
//              generating generic audits.
//
//              These definitions are not exposed to the client side code.
//              Any change to these definitions must not affect client
//              side code.
//
//
// History:     
//   07-January-2000  kumarp        created
//
//------------------------------------------------------------------------


#ifndef _ADTGENP_H
#define _ADTGENP_H

#define ACF_LegacyAudit      0x00000001L
#define ACF_WmiAudit         0x00000002L

#define ACF_ValidFlags       (ACF_LegacyAudit)

//
// audit context for legacy audits
//
typedef struct _AUDIT_CONTEXT
{
    //
    // List management
    //
    LIST_ENTRY Link;

    //
    // Flags TBD
    //
    DWORD      Flags;

    //
    // PID of the process owning this context
    //
    DWORD      ProcessId;

    //
    // Client supplied unique ID
    // This allows us to link this context with the client side
    // audit event type handle
    //
    LUID       LinkId;

    //
    // for further enhancement
    //
    PVOID      Reserved;

    //
    // Audit category ID
    //
    USHORT     CategoryId;

    //
    // Audit event ID
    //
    USHORT     AuditId;

    //
    // Expected parameter count
    //
    USHORT     ParameterCount;

} AUDIT_CONTEXT, *PAUDIT_CONTEXT;

//
// audit context for WMI based audits
//
typedef struct _AUDIT_CONTEXT_WMI
{
    //
    // List management
    //
    LIST_ENTRY Link;

    //
    // Flags TBD
    //
    DWORD      Flags;

    //
    // PID of the process owning this context
    //
    DWORD      ProcessId;
    
    //
    // for further enhancement
    //
    PVOID      Reserved;

    //
    // handle to the event source
    //
    HANDLE     hAuditEventSource;

    //
    // handle to event buffer
    //
    HANDLE     hAuditEvent;

    //
    // handle to event property subset
    //
    HANDLE     hAuditEventPropSubset;

    //
    // Expected parameter count
    //
    USHORT     ParameterCount;

    
} AUDIT_CONTEXT_WMI, *PAUDIT_CONTEXT_WMI;


EXTERN_C
NTSTATUS
LsapAdtInitGenericAudits( VOID );

EXTERN_C
NTSTATUS
LsapRegisterAuditEvent(
    IN  PAUTHZ_AUDIT_EVENT_TYPE_OLD pAuditEventType,
    OUT PHANDLE phAuditContext
    );

EXTERN_C
NTSTATUS
LsapUnregisterAuditEvent(
    IN OUT PHANDLE phAuditContext
    );


EXTERN_C
NTSTATUS
LsapGenAuditEvent(
    IN HANDLE        hAuditContext,
    IN DWORD         Flags,
    IN PAUDIT_PARAMS pAuditParams,
    IN PVOID         Reserved
    );

#endif //_ADTGENP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtlq.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T L Q . C
//
// Contents:    definitions of types/functions required for 
//              managing audit queue
//
//
// History:     
//   23-May-2000  kumarp        created
//
//------------------------------------------------------------------------


#include <lsapch2.h>
#pragma hdrstop

#include "adtp.h"
#include "adtlq.h"

ULONG LsapAdtQueueLength;
LIST_ENTRY LsapAdtLogQueue;

//
// critsec to guard LsapAdtLogQueue and LsapAdtQueueLength
//

RTL_CRITICAL_SECTION LsapAdtQueueLock;

//
// critsec to  guard log full policy
//

RTL_CRITICAL_SECTION LsapAdtLogFullLock;


NTSTATUS
LsapAdtInitializeLogQueue(
    )

/*++

Routine Description:

    This function initializes the Audit Log Queue.

Arguments:

    None.

Return Values:

    NTSTATUS - Standard NT Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = RtlInitializeCriticalSection(&LsapAdtQueueLock);

    if (NT_SUCCESS(Status))
    {
        Status = RtlInitializeCriticalSection(&LsapAdtLogFullLock);
    }

    InitializeListHead( &LsapAdtLogQueue );
    LsapAdtQueueLength = 0;

    return(Status);
}




NTSTATUS 
LsapAdtAddToQueue(
    IN PLSAP_ADT_QUEUED_RECORD pAuditRecord,
    IN DWORD Options
    )
/*++

Routine Description:

    Insert the specified record in the audit queue

Arguments:

    pAuditRecord - record to insert

    Options      - insert options

                   LSAP_ADT_LOG_QUEUE_PREPEND : prepend the record


Return Value:

    NTSTATUS - Standard NT Result Code

Notes:
    
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapAdtAcquireLogQueueLock();

    if (NT_SUCCESS(Status))
    {
        LsapAdtQueueLength++;

        if ( Options & LSAP_ADT_LOG_QUEUE_PREPEND )
        {
            InsertHeadList(&LsapAdtLogQueue, &pAuditRecord->Link);
        }
        else
        {
            InsertTailList(&LsapAdtLogQueue, &pAuditRecord->Link);
        }

        LsapAdtReleaseLogQueueLock();
    }
    
    return Status;
}




NTSTATUS 
LsapAdtGetQueueHead(
    OUT PLSAP_ADT_QUEUED_RECORD *ppRecord
    )
/*++

Routine Description:

    Remove and return audit record at the head of the queue

Arguments:

    ppRecord - receives a pointer to the record removed

Return Value:

    STATUS_SUCCESS   on success
    STATUS_NOT_FOUND if the queue is empty

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_ADT_QUEUED_RECORD pRecordAtHead;
    
    *ppRecord = NULL;

    Status = LsapAdtAcquireLogQueueLock();

    if (NT_SUCCESS(Status))
    {
        if ( LsapAdtQueueLength > 0 )
        {
            pRecordAtHead = (PLSAP_ADT_QUEUED_RECORD) LsapAdtLogQueue.Flink;
            
            DsysAssertMsg( pRecordAtHead != NULL,
                          "LsapAdtGetQueueHead: LsapAdtQueueLength > 0 but pRecordAtHead is NULL" );

            RemoveHeadList( &LsapAdtLogQueue );
            
            LsapAdtQueueLength--;
            *ppRecord = pRecordAtHead;
        }
        else
        {
            Status = STATUS_NOT_FOUND;
        }

        LsapAdtReleaseLogQueueLock();
    }
    
    return Status;
}


BOOL
LsapAdtIsValidQueue( )
/*++

Routine Description:

    Check if the audit queue looks valid    

Arguments:
    None

Return Value:

    TRUE if queue is valid, FALSE otherwise

Notes:

--*/
{
    BOOL fIsValid;
    
    if ( LsapAdtQueueLength > 0 )
    {
        fIsValid =
            (LsapAdtLogQueue.Flink != NULL) &&
            (LsapAdtLogQueue.Blink != NULL);
    }
    else
    {
        fIsValid =
            (LsapAdtLogQueue.Flink == &LsapAdtLogQueue) &&
            (LsapAdtLogQueue.Blink == &LsapAdtLogQueue);
        
    }

    return fIsValid;

}


NTSTATUS
LsapAdtFlushQueue( )
/*++

Routine Description:

    Remove and free each record from the queue    

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_ADT_QUEUED_RECORD pAuditRecord;
    
    //
    // Flush out the queue, if there is one.
    //

    DsysAssertMsg( LsapAdtIsValidQueue(), "LsapAdtFlushQueue");

    Status = LsapAdtAcquireLogQueueLock();

    if (NT_SUCCESS(Status))
    {
        do
        {
            Status = LsapAdtGetQueueHead( &pAuditRecord );

            if ( NT_SUCCESS( Status ))
            {
                LsapFreeLsaHeap( pAuditRecord );
            }
        }
        while ( NT_SUCCESS(Status) );

        if ( Status == STATUS_NOT_FOUND )
        {
            Status = STATUS_SUCCESS;
        }

        LsapAdtReleaseLogQueueLock();
    }

    DsysAssertMsg(LsapAdtQueueLength == 0, "LsapAdtFlushQueue: LsapAuditQueueLength not 0 after queue flush");
        
    return Status;
}


NTSTATUS
LsapAdtAcquireLogQueueLock(
    )

/*++

Routine Description:

    This function acquires the LSA Audit Log Queue Lock.  This lock serializes
    all updates to the Audit Log Queue.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    return RtlEnterCriticalSection(&LsapAdtQueueLock);
}


VOID
LsapAdtReleaseLogQueueLock(
    VOID
    )

/*++

Routine Description:

    This function releases the LSA Audit Log Queue Lock.  This lock serializes
    updates to the Audit Log Queue.

Arguments:

    None.

Return Value:

    None.  Any error occurring within this routine is an internal error.

--*/

{
    RtlLeaveCriticalSection(&LsapAdtQueueLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtlog.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtlog.c

Abstract:

    Local Security Authority - Audit Log Management

    Functions in this module access the Audit Log via the Event Logging
    interface.

Author:

    Scott Birrell       (ScottBi)      November 20, 1991
    Robert Reichel      (RobertRe)     April 4, 1992

Environment:

Revision History:

--*/
#include <lsapch2.h>
#include "adtp.h"
#include "adtlq.h"
#include "adtutil.h"

///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Private data for Audit Logs and Events                                //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Audit Log Information.  This must be kept in sync with the information
// in the Lsa Database.
//

POLICY_AUDIT_LOG_INFO LsapAdtLogInformation;

//
// Audit Log Full Information.
//

POLICY_AUDIT_FULL_QUERY_INFO LsapAdtLogFullInformation;

//
// Audit Log Handle (returned by Event Logger).
//

HANDLE LsapAdtLogHandle = NULL;


BOOLEAN LsapAdtSignalFullInProgress;

ULONG LsapAuditQueueEventsDiscarded = 0;
PVOID LsapAdtScavengeItem = NULL;

#define MAX_AUDIT_QUEUE_LENGTH 500

//
// Private prototypes
//

VOID
LsapAdtAuditDiscardedAudits(
    ULONG NumberOfEventsDiscarded
    );

//////////////////////////////////////////////////////////

NTSTATUS
LsapAdtWriteLogWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function handles a command, received from the Reference Monitor via
    the LPC link, to write a record to the Audit Log.  It is a wrapper which
    deals with any LPC unmarshalling.

Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapWriteAuditMessageCommand).  This command
        contains an Audit Message Packet (TBS) as a parameter.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        Currently, all other errors from called routines are suppressed.
--*/

{
    NTSTATUS Status;

    PSE_ADT_PARAMETER_ARRAY AuditRecord = NULL;

    //
    // Strict check that command is correct.
    //

    ASSERT( CommandMessage->CommandNumber == LsapWriteAuditMessageCommand );

    //
    // Obtain a pointer to the Audit Record.  The Audit Record is
    // either stored as immediate data within the Command Message,
    // or it is stored as a buffer.  In the former case, the Audit Record
    // begins at CommandMessage->CommandParams and in the latter case,
    // it is stored at the address located at CommandMessage->CommandParams.
    //

    if (CommandMessage->CommandParamsMemoryType == SepRmImmediateMemory) {

        AuditRecord = (PSE_ADT_PARAMETER_ARRAY) CommandMessage->CommandParams;

    } else {

        AuditRecord = *((PSE_ADT_PARAMETER_ARRAY *) CommandMessage->CommandParams);
    }

    //
    // Call worker to queue Audit Record for writing to the log.
    //

    Status = LsapAdtWriteLog( AuditRecord, (ULONG) 0 );

    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced

    //
    // The status value returned from LsapAdtWriteLog() is intentionally
    // ignored, since there is no meaningful action that the client
    // (i.e. kernel) if this LPC call can take.  If an error occurs in
    // trying to append an Audit Record to the log, the LSA handles the
    // error.
    //

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapAdtImpersonateSelfWithPrivilege(
    OUT PHANDLE ClientToken
    )
/*++

Routine Description:

    This function copies away the current thread token and impersonates
    the LSAs process token, and then enables the security privilege. The
    current thread token is returned in the ClientToken parameter

Arguments:

    ClientToken - recevies the thread token if there was one, or NULL.

Return Value:

    None.  Any error occurring within this routine is an internal error.

--*/
{
    NTSTATUS Status;
    HANDLE CurrentToken = NULL;
    BOOLEAN ImpersonatingSelf = FALSE;
    BOOLEAN WasEnabled = FALSE;

    *ClientToken = NULL;

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_IMPERSONATE,
                FALSE,                  // not as self
                &CurrentToken
                );

    if (!NT_SUCCESS(Status) && (Status != STATUS_NO_TOKEN)) {

        return(Status);
    }

    Status = RtlImpersonateSelf( SecurityImpersonation );

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    ImpersonatingSelf = TRUE;

    //
    // Now enable the privilege
    //

    Status = RtlAdjustPrivilege(
                SE_SECURITY_PRIVILEGE,
                TRUE,                   // enable
                TRUE,                   // do it on the thread token
                &WasEnabled
                );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    *ClientToken = CurrentToken;
    CurrentToken = NULL;

Cleanup:

    if (!NT_SUCCESS(Status)) {

        if (ImpersonatingSelf) {

            NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                &CurrentToken,
                sizeof(HANDLE)
                );
        }
    }

    if (CurrentToken != NULL) {

        NtClose(CurrentToken);
    }

    return(Status);

}


NTSTATUS
LsapAdtOpenLog(
    OUT PHANDLE AuditLogHandle
    )

/*++

Routine Description:

    This function opens the Audit Log.

Arguments:

    AuditLogHandle - Receives the Handle to the Audit Log.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        All result codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    UNICODE_STRING ModuleName;
    HANDLE OldToken = NULL;

    RtlInitUnicodeString( &ModuleName, L"Security");

    Status = LsapAdtImpersonateSelfWithPrivilege( &OldToken );

    if (NT_SUCCESS(Status)) {

        Status = ElfRegisterEventSourceW (
                    NULL,
                    &ModuleName,
                    AuditLogHandle
                    );

        NtSetInformationThread(
            NtCurrentThread(),
            ThreadImpersonationToken,
            &OldToken,
            sizeof(HANDLE)
            );

        if (OldToken != NULL) {
            NtClose( OldToken );
        }
    }


    if (!NT_SUCCESS(Status)) {

        goto OpenLogError;
    }


OpenLogFinish:

    return(Status);

OpenLogError:

    //
    // Check for Log Full and signal the condition.
    //

    if (Status != STATUS_LOG_FILE_FULL) {

        goto OpenLogFinish;
    }

    goto OpenLogFinish;
}


NTSTATUS
LsapAdtQueueRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    IN ULONG Options
    )

/*++

Routine Description:

    Puts passed audit record on the queue to be logged.

    This routine will convert the passed AuditParameters structure
    into self-relative form if it is not already.  It will then
    allocate a buffer out of the local heap and copy the audit
    information into the buffer and put it on the audit queue.

    The buffer will be freed when the queue is cleared.

Arguments:

    AuditRecord - Contains the information to be audited.

    Options - Speciifies optional actions to be taken

        LSAP_ADT_LOG_QUEUE_PREPEND - Put record on front of queue.  If
            not specified, the record will be appended to the queue.
            This option is specified when a special audit record of the
            type AuditEventLogNoLongerFull is generated, so that the
            record will be written out before others in the queue.  The
            presence of a record of this type in the log indicates that
            one or more preceding Audit Records may have been lost
            tdue to the log filling up.

Return Value:

    NTSTATUS - Standard Nt Result Code.

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to allocate a buffer to contain the record.
--*/

{
    ULONG AuditRecordLength;
    PLSAP_ADT_QUEUED_RECORD QueuedAuditRecord;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AllocationSize;
    PSE_ADT_PARAMETER_ARRAY MarshalledAuditParameters;
    BOOLEAN FreeWhenDone = FALSE;

    //
    // Check to see if the list is above the maximum length.
    // If it gets this high, it is more than likely that the
    // eventlog service is not going to start at all, so
    // start tossing audits.
    //
    // Don't do this if crash on audit is set.
    //

    if ((LsapAdtQueueLength > MAX_AUDIT_QUEUE_LENGTH) && !LsapCrashOnAuditFail) {
        LsapAuditQueueEventsDiscarded++;
        return( STATUS_SUCCESS );
    }

    //
    // Gather up all of the passed information into a single
    // block that can be placed on the queue.
    //

    if ( AuditParameters->Flags & SE_ADT_PARAMETERS_SELF_RELATIVE ) {

        MarshalledAuditParameters = AuditParameters;

    } else {

        Status = LsapAdtMarshallAuditRecord(
                     AuditParameters,
                     &MarshalledAuditParameters
                     );

        if ( !NT_SUCCESS( Status )) {

            goto QueueAuditRecordError;

        } else {

            //
            // Indicate that we're to free this structure when we're
            // finished
            //

            FreeWhenDone = TRUE;
        }
    }

    //
    // Copy the now self-relative audit record into a buffer
    // that can be placed on the queue.
    //

    AuditRecordLength = MarshalledAuditParameters->Length;
    AllocationSize = AuditRecordLength + sizeof( LSAP_ADT_QUEUED_RECORD );

    QueuedAuditRecord = (PLSAP_ADT_QUEUED_RECORD)LsapAllocateLsaHeap( AllocationSize );

    if ( QueuedAuditRecord == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto QueueAuditRecordError;
    }

    Status = STATUS_SUCCESS;

    RtlCopyMemory( &QueuedAuditRecord->Buffer, MarshalledAuditParameters, AuditRecordLength );

    //
    // We are finished with the marshalled audit record, free it.
    //

    if ( FreeWhenDone ) {
        LsapFreeLsaHeap( MarshalledAuditParameters );
        FreeWhenDone = FALSE;
    }

    Status = LsapAdtAddToQueue( QueuedAuditRecord, Options );

    if (!NT_SUCCESS( Status )) {

        goto QueueAuditRecordError;
    }
    

QueueAuditRecordFinish:

    return(Status);

QueueAuditRecordError:

    if ( FreeWhenDone ) {
        LsapFreeLsaHeap( MarshalledAuditParameters );
    }

    goto QueueAuditRecordFinish;
}




ULONG
LsapAdtScavengeCallback(
    IN PVOID Parameter
    )
{
    NTSTATUS Status;

    UNREFERENCED_PARAMETER( Parameter );
    
    //
    // Reset the item so we can create it again.
    //

    LsapAdtAcquireLogQueueLock();

    LsapAdtScavengeItem = NULL;

    LsapAdtReleaseLogQueueLock();

    //
    // Force flush the queue
    //

    Status =  LsapAdtWriteLog(NULL, 0);

    return(Status);
}


NTSTATUS
LsapAdtWriteLog(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters OPTIONAL,
    IN ULONG Options
    )
/*++

Routine Description:

    This function appends an Audit Record and/or the content of the
    Audit Record Log Queue to the Audit Log, by calling the Event Logger.
    If the Audit Log becomes full, this function signals an Audit Log
    Full condition.  The Audit Log will be opened if necessary.

    NOTE:  This function may be called during initialization before
        the Event Logger service has started.  In that event, any Audit
        Record specified will simply be added to the queue.

Arguments:

    AuditRecord - Optional pointer to an Audit Record to be written to
        the Audit Log.  The record will first be added to the existing queue
        of records waiting to be written to the log.  An attempt will then
        be made to write all of the records in the queue to the log.  If
        NULL is specified, the existing queue will be written out.

    Options - Specifies optional actions to be taken.

        LSAP_ADT_LOG_QUEUE_PREPEND - Prepend record to the Audit Record
            queue prior to writing to the log.  If not specified, the
            record will be appended to the queue.

        LSAP_ADT_LOG_QUEUE_DISCARD - Discard the Audit Record Queue.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    BOOLEAN AcquiredLock = FALSE;
    BOOLEAN AuditRecordFreed = FALSE;
    BOOLEAN AuditRecordUnblocked = FALSE;
    BOOLEAN ShutdownSystem = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus;
    PLSAP_ADT_QUEUED_RECORD pAuditRecord;


    SecondaryStatus = STATUS_SUCCESS;


    if ( Options & LSAP_ADT_LOG_QUEUE_DISCARD ) {

        Status = LsapAdtFlushQueue();

        if (!NT_SUCCESS(Status)) {
            goto WriteLogError;
        }

        return( STATUS_SUCCESS );
    }

    //
    // If the Audit Log is not already open, attempt to open it.
    // If this open is unsuccessful because the EventLog service has not
    // started, queue the Audit Record if directed to do so
    // via the Options parameter.  If the open is unsuccessful for any
    // other reason, discard the Audit Record.
    //

    if ( LsapAdtLogHandle == NULL ) {

        Status = LsapAdtAcquireLogQueueLock();

        if (!NT_SUCCESS(Status)) {
            goto WriteLogError;
        }

        AcquiredLock = TRUE;

        if (ARGUMENT_PRESENT( AuditParameters )) {

            Status = LsapAdtQueueRecord( AuditParameters, 0 );

            if (!NT_SUCCESS( Status )) {
                goto WriteLogError;
            }
        }

        Status = LsapAdtOpenLog(&LsapAdtLogHandle);

        if (!NT_SUCCESS(Status)) {

            goto WriteLogFinish;

        }

        //
        // Prepare to write out all of the records in the Audit Log Queue.
        // First, we need to capture the existing queue.
        //

        do
        {
            Status = LsapAdtGetQueueHead( &pAuditRecord );

            if ( !NT_SUCCESS(Status) )
            {
                if ( Status == STATUS_NOT_FOUND )
                {
                    Status = STATUS_SUCCESS;
                }
                break;
            }

            AuditParameters = &pAuditRecord->Buffer;

            //
            // If the caller has marshalled the data, normalize it now
            //

            LsapAdtNormalizeAuditInfo( AuditParameters );

            //
            // Note that LsapAdtDemarshallAuditInfo in addition to
            // de-marshalling the data also writes it to the eventlog.
            //
            Status = LsapAdtDemarshallAuditInfo( AuditParameters );

            if ( !NT_SUCCESS( Status )) {
                break;
            }

            LsapFreeLsaHeap( pAuditRecord );

            //
            // Update the Audit Log Information in the Policy Object.  We
            // increment the Next Audit Record serial number.
            //

            if ( LsapAdtLogInformation.NextAuditRecordId ==
                 LSAP_ADT_MAXIMUM_RECORD_ID ) {

                LsapAdtLogInformation.NextAuditRecordId = 0;
            }

            LsapAdtLogInformation.NextAuditRecordId++;

        }
        while ( NT_SUCCESS( Status ) );


        if (LsapAuditQueueEventsDiscarded > 0) {

            //
            // We discarded some audits.  Generate an audit
            // so the user knows.
            //

            LsapAdtAuditDiscardedAudits( LsapAuditQueueEventsDiscarded );

            //
            // reset the count back to 0
            //

            LsapAuditQueueEventsDiscarded = 0;
        }

        if ( NT_SUCCESS(Status) )
        {
            DsysAssertMsg(LsapAdtQueueLength == 0, "LsapAdtWriteLog: LsapAuditQueueLength not 0 after writing all records in queue to log");
        }
        else
        {
            goto WriteLogError;
        }

    } else if ( AuditParameters != NULL ) {

        //
        // If multiple notifications are queued before the audit log handle is opened, we
        // may get called to on the scavenge notification and get invoked a second time to
        // process the queue, but the event handle has already been opened.  As such, we're
        // going to end up down here, which will cause problems since we are expecting valid
        // audit parameters.
        //

        //
        // Normal case, just perform the audit
        //

        LsapAdtNormalizeAuditInfo( AuditParameters );

        //
        // Note that LsapAdtDemarshallAuditInfo in addition to
        // de-marshalling the data also writes it to the eventlog.
        //
        Status = LsapAdtDemarshallAuditInfo(
                     AuditParameters
                     );

        if (!NT_SUCCESS(Status)) {
            goto WriteLogError;
        }

        //
        // Update the Audit Log Information in the Policy Object.  We
        // increment the Next Audit Record serial number.
        //

        if (LsapAdtLogInformation.NextAuditRecordId == LSAP_ADT_MAXIMUM_RECORD_ID ) {

            LsapAdtLogInformation.NextAuditRecordId = 0;
        }

        LsapAdtLogInformation.NextAuditRecordId++;

    }


WriteLogFinish:

    //
    // Register an event to come through and clean the log

    if ((LsapAdtLogHandle == NULL) && (LsapAdtScavengeItem == NULL)) {
        LsapAdtScavengeItem = LsaIRegisterNotification(
                                LsapAdtScavengeCallback,
                                NULL,           // no parameter
                                NOTIFIER_TYPE_INTERVAL,
                                0,
                                NOTIFIER_FLAG_NEW_THREAD | NOTIFIER_FLAG_ONE_SHOT,
                                5,              // delay
                                NULL            // no handle
                                );

    }
    //
    // If necessary, release the LSA Audit Log Queue Lock.
    //

    if (AcquiredLock) {

        LsapAdtReleaseLogQueueLock();
        AcquiredLock = FALSE;
    }

    return(Status);

WriteLogError:

    //
    // Take whatever action we're supposed to take when an audit attempt fails.
    //

    LsapAuditFailed( Status );

    //
    // If the error is other than Audit Log Full, just cleanup and return
    // the error.
    //

    if ((Status != STATUS_DISK_FULL) && (Status != STATUS_LOG_FILE_FULL)) {

        goto WriteLogFinish;
    }

    //
    // If there are Audit Records in the cache, discard them.
    //

    SecondaryStatus = LsapAdtWriteLog(NULL, LSAP_ADT_LOG_QUEUE_DISCARD);

    //
    // ??
    //
    if (NT_SUCCESS(Status)) {
        Status = SecondaryStatus;
    }

    goto WriteLogFinish;
}





NTSTATUS
LsarClearAuditLog(
    IN LSAPR_HANDLE PolicyHandle
    )

/*++

Routine Description:

    This function used to clear the Audit Log but has been superseded
    by the Event Viewer functionality provided for this purpose.  To
    preserve compatibility with existing RPC interfaces, this server
    stub is retained.

Arguments:

    PolicyHandle - Handle to an open Policy Object.

Return Values:

    NTSTATUS - Standard Nt Result Code.

        STATUS_NOT_IMPLEMENTED - This routine is not implemented.
--*/

{
    UNREFERENCED_PARAMETER( PolicyHandle );
    return(STATUS_NOT_IMPLEMENTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtobjs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtobjs.c

Abstract:

    Local Security Authority - Auditing object parameter file services.

Author:

    Jim Kelly   (JimK)      20-Oct-1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <msaudite.h>
#include <msobjs.h>
#include "adtp.h"



//
// This is the maximum length of standard access type names.
// This is used to build an array.
//

#define ADTP_MAX_ACC_NAME_LENGTH        (12)


//
//
// This module builds a list of event source module descriptors.
// The source modules are identified by name (kept in the descriptor).
//
//
// For each source module a list of objects exported by that module is
// linked to the source module's descriptor.  Each entry in this list
// is an object descriptor containing a name and a base event offset
// for specific access types.
//
//
// The chicken-wire data structure for source module and object descriptors
// looks like:
//
// LsapAdtSourceModules --+
//                        |
//     +------------------+
//     |
//     |
//     |    +-----------+                             +-----------+
//     +--->|  Next ----|---------------------------->|  Next ----|--->...
//          |           |                             |           |
//          |-----------|                             |-----------|
//          |  Name     |                             |  Name     |
//          |           |                             |           |
//          |-----------|                             |-----------|
//          |  Objects  |                             |  Objects  |
//          |    o      |                             |    o      |
//          +-----o-----+                             +-----o-----+
//                 o     +-------+  +-------+                o
//                  o    | Next--|->| Next--|->...            o
//                   ooo>|-------|  |-------|                  oooooo> ...
//                       | Name  |  | Name  |
//                       |-------|  |-------|
//                       | Base  |  | Base  |
//                       | Offset|  | Offset|
//                       +-------+  +-------+
//
// The specific access type names are expected to have contiguous message IDs
// starting at the base offset value.  For example, the access type name for
// specific access bit 0 for the framitz object might have message ID 2132
// (and bit 0 serves as the base offset).  So, specific access bit 4 would be
// message ID (2132+4).
//
// The valid mask defines the set of specific accesses defined by each object
// type.  If there are gaps in the valid mask, the arithmetic above must still
// be ensured.  That is, the message ID of the specific access related to
// bit n is message ID (BaseOffset + bit position).  So, for example, if
// bits 0, 1, 4 and 5 are valid (and 2 & 3 are not), be sure to leave unused
// message IDs where bits 2 and 3 would normally be.
//



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Data types used within this module                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////


#define LSAP_ADT_ACCESS_NAME_FORMATTING L"\r\n\t\t\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_TAB L"\t"
#define LSAP_ADT_ACCESS_NAME_FORMATTING_NL L"\r\n"


#define LsapAdtSourceModuleLock()    (RtlEnterCriticalSection(&LsapAdtSourceModuleLock))
#define LsapAdtSourceModuleUnlock()  (RtlLeaveCriticalSection(&LsapAdtSourceModuleLock))



//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_OBJECT {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_OBJECT *Next;

    //
    // Name of object
    //

    UNICODE_STRING Name;

    //
    // Base offset of specific access types
    //

    ULONG BaseOffset;

} LSAP_ADT_OBJECT, *PLSAP_ADT_OBJECT;




//
// Each event source is represented by a source module descriptor.
// These are kept on a linked list (LsapAdtSourceModules).
//

typedef struct _LSAP_ADT_SOURCE {

    //
    // Pointer to next source module descriptor
    // This is assumed to be the first field in the structure.
    //

    struct _LSAP_ADT_SOURCE *Next;

    //
    // Name of source module
    //

    UNICODE_STRING Name;

    //
    // list of objects
    //

    PLSAP_ADT_OBJECT Objects;

} LSAP_ADT_SOURCE, *PLSAP_ADT_SOURCE;



////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Variables global within this module                               //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Maximum number of strings used to represent an ObjectTypeList.
//

#define LSAP_ADT_OBJECT_TYPE_STRINGS 10

//
// List head for source modules, and lock protecting references
// or modifications of the links in that list.
//
// Once a module's or object's name and value are established, they
// are never changed.  So, this lock only needs to be held while
// links are being referenced or changed.  You don't need to retain
// it just so you can reference, for example, the name or BaseOffset
// of an object.
//

PLSAP_ADT_SOURCE LsapAdtSourceModules;
RTL_CRITICAL_SECTION LsapAdtSourceModuleLock;




//
// This is used to house well-known access ID strings.
// Each string name may be up to ADTP_MAX_ACC_NAME_LENGTH WCHARs long.
// There are 16 specific names, and 7 well known event ID strings.
//

WCHAR LsapAdtAccessIdsStringBuffer[ADTP_MAX_ACC_NAME_LENGTH * 23];   // max wchars in each of 23 strings




UNICODE_STRING          LsapAdtEventIdStringDelete,
                        LsapAdtEventIdStringReadControl,
                        LsapAdtEventIdStringWriteDac,
                        LsapAdtEventIdStringWriteOwner,
                        LsapAdtEventIdStringSynchronize,
                        LsapAdtEventIdStringAccessSysSec,
                        LsapAdtEventIdStringMaxAllowed,
                        LsapAdtEventIdStringSpecific[16];




////////////////////////////////////////////////////////////////////////
//                                                                    //
//  Services exported by this module.                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAdtObjsInitialize(
    )

/*++

Routine Description:

    This function reads the object parameter file information from the
    registry.

    This service should be called in pass 1.


Arguments:

    None.

Return Value:


    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS                        Status,
                                    IgnoreStatus;

    OBJECT_ATTRIBUTES               ObjectAttributes;

    HANDLE                          AuditKey,
                                    ModuleKey,
                                    ObjectNamesKey = NULL ;

    ULONG                           i,
                                    ModuleIndex,
                                    ObjectIndex,
                                    RequiredLength;

    UNICODE_STRING                  AuditKeyName,
                                    TmpString;

    PLSAP_ADT_SOURCE                NextModule = NULL;

    PKEY_BASIC_INFORMATION          KeyInformation;



    PLSAP_ADT_OBJECT                NextObject;

    PKEY_VALUE_FULL_INFORMATION     KeyValueInformation;

    PULONG                          ObjectData;

    BOOLEAN                         ModuleHasObjects = TRUE;





    //
    // Initialize module-global variables, including strings we will need
    //



    //
    // List of source modules and objects.  These lists are constantly
    // being adjusted to try to improve performance.  Access to these
    // lists is protected by a critical section.
    //

    LsapAdtSourceModules = NULL;

    Status = RtlInitializeCriticalSection(&LsapAdtSourceModuleLock);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }


    //
    // we need a number of strings.
    //

    i = 0;
    LsapAdtEventIdStringDelete.Length = 0;
    LsapAdtEventIdStringDelete.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringDelete.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_DELETE,
                                         10,        //Base
                                         &LsapAdtEventIdStringDelete
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringReadControl.Length = 0;
    LsapAdtEventIdStringReadControl.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringReadControl.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_READ_CONTROL,
                                         10,        //Base
                                         &LsapAdtEventIdStringReadControl
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringWriteDac.Length = 0;
    LsapAdtEventIdStringWriteDac.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringWriteDac.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_WRITE_DAC,
                                         10,        //Base
                                         &LsapAdtEventIdStringWriteDac
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringWriteOwner.Length = 0;
    LsapAdtEventIdStringWriteOwner.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringWriteOwner.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_WRITE_OWNER,
                                         10,        //Base
                                         &LsapAdtEventIdStringWriteOwner
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSynchronize.Length = 0;
    LsapAdtEventIdStringSynchronize.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSynchronize.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SYNCHRONIZE,
                                         10,        //Base
                                         &LsapAdtEventIdStringSynchronize
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i += ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringAccessSysSec.Length = 0;
    LsapAdtEventIdStringAccessSysSec.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringAccessSysSec.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_ACCESS_SYS_SEC,
                                         10,        //Base
                                         &LsapAdtEventIdStringAccessSysSec
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringMaxAllowed.Length = 0;
    LsapAdtEventIdStringMaxAllowed.MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringMaxAllowed.Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_MAXIMUM_ALLOWED,
                                         10,        //Base
                                         &LsapAdtEventIdStringMaxAllowed
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }




    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[0].Length = 0;
    LsapAdtEventIdStringSpecific[0].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[0].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_0,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[0]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[1].Length = 0;
    LsapAdtEventIdStringSpecific[1].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[1].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_1,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[1]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[2].Length = 0;
    LsapAdtEventIdStringSpecific[2].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[2].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_2,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[2]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[3].Length = 0;
    LsapAdtEventIdStringSpecific[3].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[3].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_3,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[3]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[4].Length = 0;
    LsapAdtEventIdStringSpecific[4].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[4].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_4,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[4]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[5].Length = 0;
    LsapAdtEventIdStringSpecific[5].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[5].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_5,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[5]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[6].Length = 0;
    LsapAdtEventIdStringSpecific[6].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[6].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_6,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[6]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[7].Length = 0;
    LsapAdtEventIdStringSpecific[7].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[7].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_7,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[7]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[8].Length = 0;
    LsapAdtEventIdStringSpecific[8].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[8].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_8,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[8]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[9].Length = 0;
    LsapAdtEventIdStringSpecific[9].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[9].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_9,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[9]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[10].Length = 0;
    LsapAdtEventIdStringSpecific[10].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[10].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_10,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[10]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[11].Length = 0;
    LsapAdtEventIdStringSpecific[11].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[11].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_11,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[11]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[12].Length = 0;
    LsapAdtEventIdStringSpecific[12].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[12].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_12,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[12]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[13].Length = 0;
    LsapAdtEventIdStringSpecific[13].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[13].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_13,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[13]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[14].Length = 0;
    LsapAdtEventIdStringSpecific[14].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[14].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_14,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[14]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    i+= ADTP_MAX_ACC_NAME_LENGTH;  //Skip to the beginning of the next string
    LsapAdtEventIdStringSpecific[15].Length = 0;
    LsapAdtEventIdStringSpecific[15].MaximumLength = (ADTP_MAX_ACC_NAME_LENGTH * sizeof(WCHAR));
    LsapAdtEventIdStringSpecific[15].Buffer = (PWSTR)&LsapAdtAccessIdsStringBuffer[i];
    Status = RtlIntegerToUnicodeString ( SE_ACCESS_NAME_SPECIFIC_15,
                                         10,        //Base
                                         &LsapAdtEventIdStringSpecific[15]
                                         );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // The modules and their objects are listed in the registry
    // under the key called LSAP_ADT_AUDIT_MODULES_KEY_NAME.
    // Open that key.
    //

    RtlInitUnicodeString( &AuditKeyName, LSAP_ADT_AUDIT_MODULES_KEY_NAME );
    InitializeObjectAttributes( &ObjectAttributes, &AuditKeyName, OBJ_CASE_INSENSITIVE, 0, NULL );

    Status = NtOpenKey( &AuditKey, KEY_READ, &ObjectAttributes ); // AuditKey is open handle to top of security modules registry

    for (ModuleIndex = 0; NT_SUCCESS(Status); ModuleIndex ++)
    {
        //
        // Enumerate the subkeys under AuditKey, storing their names in KeyInformation.  First calculate the buffer size needed to
        // store the key name.
        //

        KeyInformation = NULL;
        Status = NtEnumerateKey( AuditKey, ModuleIndex, KeyBasicInformation, (PVOID)KeyInformation, 0, &RequiredLength );
        if (Status == STATUS_BUFFER_TOO_SMALL) // must test this, in case the NtEnumerateKey fails for some other reason
        {
            KeyInformation = RtlAllocateHeap( RtlProcessHeap(), 0, RequiredLength );

            if (KeyInformation == NULL)
            {
               return(STATUS_NO_MEMORY);
            }

            Status = NtEnumerateKey( AuditKey, ModuleIndex, KeyBasicInformation, (PVOID) KeyInformation, RequiredLength, &RequiredLength );

            if (NT_SUCCESS(Status))
            {

                //
                // Build a source module descriptor (LSAP_ADT_SOURCE) for the subkey of AuditKey (aka KeyInformation)
                //

                NextModule = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LSAP_ADT_SOURCE) );
                if (NextModule == NULL) {
                    return(STATUS_NO_MEMORY);
                }

                NextModule->Next = LsapAdtSourceModules;
                LsapAdtSourceModules = NextModule;
                NextModule->Objects = NULL;
                NextModule->Name.Length = (USHORT)KeyInformation->NameLength;
                NextModule->Name.MaximumLength = NextModule->Name.Length + 2;
                NextModule->Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, NextModule->Name.MaximumLength );
                if (NextModule->Name.Buffer == NULL)
                {
                    return(STATUS_NO_MEMORY);
                }

                TmpString.Length = (USHORT)KeyInformation->NameLength;
                TmpString.MaximumLength = TmpString.Length;
                TmpString.Buffer = &KeyInformation->Name[0];
                RtlCopyUnicodeString( &NextModule->Name, &TmpString );
                RtlFreeHeap( RtlProcessHeap(), 0, KeyInformation );

                //
                // open the module subkey to which KeyInformation refers.  call it "ModuleKey".
                //

                InitializeObjectAttributes( &ObjectAttributes, &NextModule->Name, OBJ_CASE_INSENSITIVE, AuditKey, NULL );

                Status = NtOpenKey( &ModuleKey, KEY_READ, &ObjectAttributes );

                DebugLog((DEB_TRACE_AUDIT, "LsapAdtObjsInitialize() :: opening ModuleKey %S returned 0x%x\n", 
                          NextModule->Name.Buffer, Status));

                if (!NT_SUCCESS(Status))
                {
                    return(Status);
                }

                //
                // Open the source module's "\ObjectNames" subkey as the handle "ObjectNamesKey";
                //

                RtlInitUnicodeString( &TmpString, LSAP_ADT_OBJECT_NAMES_KEY_NAME );
                InitializeObjectAttributes( &ObjectAttributes, &TmpString, OBJ_CASE_INSENSITIVE, ModuleKey, NULL );

                Status = NtOpenKey( &ObjectNamesKey, KEY_READ, &ObjectAttributes );

                IgnoreStatus = NtClose( ModuleKey );
                ASSERT(NT_SUCCESS(IgnoreStatus));

                // DbgPrint("LsapAdtObjsInitialize() :: opening ObjectNamesKey returned 0x%x\n", Status);

                ModuleHasObjects = TRUE;
                if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
                {
                    ModuleHasObjects = FALSE;
                    Status = STATUS_SUCCESS;
                }

            }
        }

        //
        // At this point we have either:
        //
        //      1) Found a source module with objects under it
        //         that need to be retrieved.
        //         This is indicated by successful status value and
        //         (ModuleHasObjects == TRUE).
        //
        //      2) found a source module with no objects under it,
        //         This is indicated by (ModuleHasObjects == FALSE)
        //
        //      3) exhausted our source modules enumeration,
        //
        //      4) hit another type of error, or
        //
        // (3) and (4) are indicatd by non-successful status values.
        //
        // In the case of (1) or (2) , NextModule points to the module we
        // are working on.  For case (1), ObjectNamesKey is the handle to
        // the \ObjectNames registry key for the source module.
        //


        for (ObjectIndex = 0; (NT_SUCCESS(Status)) && (ModuleHasObjects == TRUE); ObjectIndex ++)
        {

            //
            // Now enumerate the objects (i.e. values under \...\ObjectNames\ ) of this
            // source module.
            //

            // first calculate size of the ObjectIndex'th key.  Store in KeyValueInformation.

            KeyValueInformation = NULL;
            Status = NtEnumerateValueKey( ObjectNamesKey, ObjectIndex, KeyValueFullInformation, KeyValueInformation, 0, &RequiredLength );

            if (Status == STATUS_BUFFER_TOO_SMALL)
            {

                KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0, RequiredLength );
                if (KeyValueInformation == NULL)
                {
                  return(STATUS_NO_MEMORY);
                }

                Status = NtEnumerateValueKey( ObjectNamesKey, ObjectIndex, KeyValueFullInformation, KeyValueInformation, RequiredLength, &RequiredLength );


                if (NT_SUCCESS(Status))
                {

                    //
                    // Build an object descriptor for the object represented
                    // by this object.
                    //

                    NextObject = RtlAllocateHeap( RtlProcessHeap(), 0, sizeof(LSAP_ADT_OBJECT) );
                    if (NextObject == NULL)
                    {
                        return(STATUS_NO_MEMORY);
                    }

                    NextObject->Next = NextModule->Objects;
                    NextModule->Objects = NextObject;
                    NextObject->Name.Length = (USHORT)KeyValueInformation->NameLength;
                    NextObject->Name.MaximumLength = NextObject->Name.Length + 2;
                    NextObject->Name.Buffer = RtlAllocateHeap( RtlProcessHeap(), 0, NextObject->Name.MaximumLength );
                    if (NextObject->Name.Buffer == NULL)
                    {
                        return(STATUS_NO_MEMORY);
                    }

                    TmpString.Length = (USHORT)KeyValueInformation->NameLength;
                    TmpString.MaximumLength = TmpString.Length;
                    TmpString.Buffer = &KeyValueInformation->Name[0];
                    RtlCopyUnicodeString( &NextObject->Name, &TmpString );

                    if (KeyValueInformation->DataLength < sizeof(ULONG))
                    {
                        NextObject->BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
                    }
                    else
                    {

                        ObjectData = (PVOID)(((PUCHAR)KeyValueInformation) + KeyValueInformation->DataOffset);
                        NextObject->BaseOffset = (*ObjectData);
                    }
                    // DbgPrint("LsapAdtObjsInitialize() :: opening key %S with BaseOffset %d\n", NextObject->Name.Buffer, NextObject->BaseOffset);

                } //end_if (NT_SUCCESS on enumeration)

                RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
            } // end if buffer_too_small

            //
            // if we run out of values in the enumeration of this module, then we want to break
            // into the enumeration of the next
            //

            if (Status == STATUS_NO_MORE_ENTRIES)
            {
                Status = STATUS_SUCCESS;
                ModuleHasObjects = FALSE;
            }

        } // end for (ObjectIndex ... ) {} (enumerating values)


        if ( (Status == STATUS_SUCCESS) && (ModuleHasObjects == FALSE) )
        {
            IgnoreStatus = NtClose( ObjectNamesKey );
        }


    } // end for (Module... ){} (enumerating modules)

    IgnoreStatus = NtClose( AuditKey );
    ASSERT(NT_SUCCESS(IgnoreStatus));


    //
    // If we were successful, then we will probably have a
    // current completion status of STATUS_NO_MORE_ENTRIES
    // (indicating our enumerations above were run).  Change
    // this to success.
    //

    if (Status == STATUS_NO_MORE_ENTRIES)
    {
        Status = STATUS_SUCCESS;
    }

    return(Status);

}


NTSTATUS
LsapGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to its text form.

Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_SUCCESS - Operation was successful.
    STATUS_NO_MEMORY - Not enough memory to allocate string.

--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringSize = (wcslen( GuidString ) + 1) * sizeof(WCHAR);

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( LocalGuidString, GuidString, GuidStringSize );
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapDsGuidToString(
    IN GUID *ObjectType,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine converts a GUID to a string.  The GUID is one of the following:

        Class Guid indicating the class of an object.
        Property Set Guid identifying a property set.
        Property Guid identifying a property.

    In each case, the routine returns a text string naming the object/property
    set or property.

    If the passed in GUID is cannot be found in the schema,
    the GUID will simply be converted to a text string.


Arguments:

    ObjectType - Specifies the GUID to translate.

    UnicodeString - Returns the text string.

Return Values:

    STATUS_NO_MEMORY - Not enough memory to allocate string.


--*/

{
    NTSTATUS Status;
    RPC_STATUS RpcStatus;
    LPWSTR GuidString = NULL;
    ULONG GuidStringSize;
    ULONG GuidStringLen;
    LPWSTR LocalGuidString;

    //
    // Convert the GUID to text
    //

    RpcStatus = UuidToStringW( ObjectType,
                               &GuidString );

    if ( RpcStatus != RPC_S_OK ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    GuidStringLen = wcslen( GuidString );
    GuidStringSize = (GuidStringLen + 4) * sizeof(WCHAR);

    LocalGuidString = LsapAllocateLsaHeap( GuidStringSize );

    if ( LocalGuidString == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    LocalGuidString[0] = L'%';
    LocalGuidString[1] = L'{';
    RtlCopyMemory( &LocalGuidString[2], GuidString, GuidStringLen*sizeof(WCHAR) );
    LocalGuidString[GuidStringLen+2] = L'}';
    LocalGuidString[GuidStringLen+3] = L'\0';
    RtlInitUnicodeString( UnicodeString, LocalGuidString );

    Status = STATUS_SUCCESS;

Cleanup:
    if ( GuidString != NULL ) {
        RpcStringFreeW( &GuidString );
    }
    return Status;
}


NTSTATUS
LsapAdtAppendString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN PUNICODE_STRING StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    This function appends a string to the next available of the LSAP_ADT_OBJECT_TYPE_STRINGS unicode
    output strings.


Arguments:

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.

    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    StringToAppend - String to be appended to ResultantString.

    StringIndex - Index to the current ResultantString to be used.
        Passes in an index to the resultant string to use.
        Passes out the index to the resultant string being used.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING SourceString;
    ULONG Index;
// Must be multiple of sizeof(WCHAR)
#define ADT_MAX_STRING 0xFFFE

    //
    // Initialization.
    //

    SourceString = *StringToAppend;
    Index = *StringIndex;

    //
    // If all of the strings are already full,
    //  early out.
    //

    if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
        return STATUS_SUCCESS;
    }

    //
    // Loop until the source string is completely appended.
    //

    while ( SourceString.Length ) {

        //
        // If the destination string has room,
        //  append to it.
        //

        if ( FreeWhenDone[Index] && ResultantString[Index].Length != ADT_MAX_STRING ){
            UNICODE_STRING SubString;
            USHORT RoomLeft;

            //
            // If the Source String is a replacement string,
            //  make sure we don't split it across a ResultantString boundary
            //

            RoomLeft = ResultantString[Index].MaximumLength -
                       ResultantString[Index].Length;

            if ( SourceString.Buffer[0] != L'%' ||
                 RoomLeft >= SourceString.Length ) {

                //
                // Compute the substring that fits.
                //

                SubString.Length = min( RoomLeft, SourceString.Length );
                SubString.Buffer = SourceString.Buffer;

                SourceString.Length -= SubString.Length;
                SourceString.Buffer = (LPWSTR)(((LPBYTE)SourceString.Buffer) + SubString.Length);


                //
                // Append the substring onto the destination.
                //

                Status = RtlAppendUnicodeStringToString(
                                    &ResultantString[Index],
                                    &SubString );

                ASSERT(NT_SUCCESS(Status));

            }



        }

        //
        // If there's more to copy,
        //  grow the buffer.
        //

        if ( SourceString.Length ) {
            ULONG NewSize;
            LPWSTR NewBuffer;

            //
            // If the current buffer is full,
            //  move to the next buffer.
            //

            if ( ResultantString[Index].Length == ADT_MAX_STRING ) {

                //
                // If ALL of the buffers are full,
                //  silently return to the caller.
                //
                Index ++;

                if ( Index >= LSAP_ADT_OBJECT_TYPE_STRINGS ) {
                    *StringIndex = Index;
                    return STATUS_SUCCESS;
                }
            }

            //
            // Allocate a buffer suitable for both the old string and the new one.
            //
            // Allocate the buffer at least large enough for the new string.
            // Always grow the buffer in 1Kb chunks.
            // Don't allocate larger than the maximum allowed size.
            //

            NewSize = max( ResultantString[Index].MaximumLength + 1024,
                           SourceString.Length );
            NewSize = min( NewSize, ADT_MAX_STRING );

            NewBuffer = LsapAllocateLsaHeap( NewSize );

            if ( NewBuffer == NULL ) {
                *StringIndex = Index;
                return STATUS_NO_MEMORY;
            }

            //
            // Copy the old buffer into the new buffer.
            //

            if ( ResultantString[Index].Buffer != NULL ) {
                RtlCopyMemory( NewBuffer,
                               ResultantString[Index].Buffer,
                               ResultantString[Index].Length );

                if ( FreeWhenDone[Index] ) {
                    LsapFreeLsaHeap( ResultantString[Index].Buffer );
                }
            }

            ResultantString[Index].Buffer = NewBuffer;
            ResultantString[Index].MaximumLength = (USHORT) NewSize;
            FreeWhenDone[Index] = TRUE;

        }
    }

    *StringIndex = Index;
    return STATUS_SUCCESS;

}


NTSTATUS
LsapAdtAppendZString(
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    IN LPWSTR StringToAppend,
    IN PULONG StringIndex
    )

/*++

Routine Description:

    Same as LsapAdpAppendString but takes a zero terminated string.

Arguments:

    Same as LsapAdpAppendString but takes a zero terminated string.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, StringToAppend );

    return LsapAdtAppendString( ResultantString,
                                FreeWhenDone,
                                &UnicodeString,
                                StringIndex );
}


ULONG
__cdecl
CompareObjectTypes(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting an object type array by access mask.

--*/
{
    const SE_ADT_OBJECT_TYPE *ObjectType1 = Param1;
    const SE_ADT_OBJECT_TYPE *ObjectType2 = Param2;

    return ObjectType1->AccessMask - ObjectType2->AccessMask;
}


NTSTATUS
LsapAdtBuildObjectTypeStrings(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN PSE_ADT_OBJECT_TYPE ObjectTypeList,
    IN ULONG ObjectTypeCount,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone,
    OUT PUNICODE_STRING NewObjectTypeName
    )

/*++

Routine Description:

    This function builds a LSAP_ADT_OBJECT_TYPE_STRINGS unicode strings containing parameter
    file replacement parameters (e.g. %%1043) and Object GUIDs separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffers returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    ObjectTypeList - List of objects being granted access.

    ObjectTypeCount - Number of objects in ObjectTypeList.

    ResultantString - Points to an array of LSAP_ADT_OBJECT_TYPE_STRINGS unicode string headers.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

    NewObjectTypeName - Returns a new name for the object type if one is
        available.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING LocalString;
    LPWSTR GuidString;
    UNICODE_STRING DsSourceName;
    UNICODE_STRING DsObjectTypeName;
    BOOLEAN LocalFreeWhenDone;
    ULONG ResultantStringIndex = 0;
    ULONG i;
    ACCESS_MASK PreviousAccessMask;
    ULONG Index;
    BOOLEAN IsDs;
    USHORT IndentLevel;

    static LPWSTR Tabs[] =
    {
        L"\t",
        L"\t\t",
        L"\t\t\t",
        L"\t\t\t\t"
    };
    USHORT cTabs = sizeof(Tabs) / sizeof(LPWSTR);

    //
    // Initialize all LSAP_ADT_OBJECT_TYPE_STRINGS buffers to empty strings
    //

    for ( i=0; i<LSAP_ADT_OBJECT_TYPE_STRINGS; i++ ) {
        RtlInitUnicodeString( &ResultantString[i], L"" );
        FreeWhenDone[i] = FALSE;
    }

    //
    // If there are no objects,
    //  we're done.
    //

    if ( ObjectTypeCount == 0 ) {
        return STATUS_SUCCESS;
    }

    //
    // Determine if this entry is for the DS.
    //

    RtlInitUnicodeString( &DsSourceName, ACCESS_DS_SOURCE_W );
    RtlInitUnicodeString( &DsObjectTypeName, ACCESS_DS_OBJECT_TYPE_NAME_W );

    IsDs = RtlEqualUnicodeString( SourceModule, &DsSourceName, TRUE) &&
           RtlEqualUnicodeString( ObjectTypeName, &DsObjectTypeName, TRUE);


    //
    // Group the objects with like access masks together.
    //  (Simply sort them).
    //

    qsort( ObjectTypeList,
           ObjectTypeCount,
           sizeof(SE_ADT_OBJECT_TYPE),
           CompareObjectTypes );

    //
    // Loop through the objects outputting a line for each one.
    //

    PreviousAccessMask = ObjectTypeList[0].AccessMask -1;
    for ( Index=0; Index<ObjectTypeCount; Index++ ) {

        if ( IsDs &&
             ObjectTypeList[Index].Level == ACCESS_OBJECT_GUID &&
             NewObjectTypeName->Length == 0 ) {

            (VOID) LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                      NewObjectTypeName );
        }

        //
        // If this entry simply represents the object itself,
        //  skip it.

        if ( ObjectTypeList[Index].Flags & SE_ADT_OBJECT_ONLY ) {
            continue;
        }

        //
        // If this access mask is different than the one for the previous
        //  object,
        //  output a new copy of the access mask.
        //

        if ( ObjectTypeList[Index].AccessMask != PreviousAccessMask ) {

            PreviousAccessMask = ObjectTypeList[Index].AccessMask;

            if ( ObjectTypeList[Index].AccessMask == 0 ) {
                RtlInitUnicodeString( &LocalString,
                                      L"---" LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                LocalFreeWhenDone = FALSE;
            } else {

                //
                // Build a string with the access mask in it.
                //

                Status = LsapAdtBuildAccessesString(
                                  SourceModule,
                                  ObjectTypeName,
                                  ObjectTypeList[Index].AccessMask,
                                  FALSE,
                                  &LocalString,
                                  &LocalFreeWhenDone );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // Append it to the output string.
            //

            Status = LsapAdtAppendString(
                        ResultantString,
                        FreeWhenDone,
                        &LocalString,
                        &ResultantStringIndex );

            if ( LocalFreeWhenDone ) {
                LsapFreeLsaHeap( LocalString.Buffer );
            }

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        IndentLevel = ObjectTypeList[Index].Level;

        if (IndentLevel >= cTabs) {
            IndentLevel = cTabs-1;
        }

        //
        // Indent the GUID.
        //

        Status = LsapAdtAppendZString(
            ResultantString,
            FreeWhenDone,
            Tabs[IndentLevel],
            &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // If this is the DS,
        //  convert the GUID to a name from the schema.
        //

        Status = LsapDsGuidToString( &ObjectTypeList[Index].ObjectType,
                                     &LocalString );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Append the GUID string to the output strings.
        //

        Status = LsapAdtAppendString(
                    ResultantString,
                    FreeWhenDone,
                    &LocalString,
                    &ResultantStringIndex );

        LsapFreeLsaHeap( LocalString.Buffer );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Put the GUID on a line by itself.
        //

        Status = LsapAdtAppendZString(
                    ResultantString,
                    FreeWhenDone,
                    LSAP_ADT_ACCESS_NAME_FORMATTING_NL,
                    &ResultantStringIndex );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

    }

    Status = STATUS_SUCCESS;
Cleanup:
    return Status;
}




NTSTATUS
LsapAdtBuildAccessesString(
    IN PUNICODE_STRING SourceModule,
    IN PUNICODE_STRING ObjectTypeName,
    IN ACCESS_MASK Accesses,
    IN BOOLEAN Indent,
    OUT PUNICODE_STRING ResultantString,
    OUT PBOOLEAN FreeWhenDone
    )

/*++

Routine Description:

    This function builds a unicode string containing parameter
    file replacement parameters (e.g. %%1043) separated by carriage
    return and tab characters suitable for display via the event viewer.


    The buffer returned by this routine must be deallocated when no
    longer needed if FreeWhenDone is true.


    NOTE: To enhance performance, each time a target source module
          descriptor is found, it is moved to the beginning of the
          source module list.  This ensures frequently accessed source
          modules are always near the front of the list.

          Similarly, target object descriptors are moved to the front
          of their lists when found.  This further ensures high performance
          by quicly locating



Arguments:

    SourceModule - The module (ala event viewer modules) defining the
        object type.

    ObjectTypeName - The type of object to which the access mask applies.

    Accesses - The access mask to be used in building the display string.

    Indent - Access Mask should be indented.

    ResultantString - Points to the unicode string header.  The body of this
        unicode string will be set to point to the resultant output value
        if successful.  Otherwise, the Buffer field of this parameter
        will be set to NULL.


    FreeWhenDone - If TRUE, indicates that the body of the ResultantString
        must be freed to process heap when no longer needed.

Return Values:

    STATUS_NO_MEMORY - indicates memory could not be allocated
        to store the object information.

    All other Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG AccessCount = 0;
    ULONG BaseOffset;
    ULONG i;
    ACCESS_MASK Mask;
    PLSAP_ADT_SOURCE Source;
    PLSAP_ADT_SOURCE FoundSource = NULL;
    PLSAP_ADT_OBJECT Object;
    PLSAP_ADT_OBJECT FoundObject = NULL;
    BOOLEAN Found;

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("Module:\t%wS\n", SourceModule);
    printf("\t   Object:\t%wS\n", ObjectTypeName);
    printf("\t Accesses:\t0x%lx\n", Accesses);
#endif

    //
    // If we have no accesses, return "-"
    //

    if (Accesses == 0) {

        RtlInitUnicodeString( ResultantString, L"-" );
        (*FreeWhenDone) = FALSE;
        return(STATUS_SUCCESS);
    }

    //
    // First figure out how large a buffer we need
    //

    Mask = Accesses;

    //
    // Count the number of set bits in the
    // passed access mask.
    //

    while ( Mask != 0 ) {
        Mask = Mask & (Mask - 1);
        AccessCount++;
    }


#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d bits set in mask.\n", AccessCount);
#endif


    //
    // We have accesses, allocate a string large enough to deal
    // with them all.  Strings will be of the format:
    //
    //      %%nnnnnnnnnn\n\r\t\t%%nnnnnnnnnn\n\r\t\t ... %nnnnnnnnnn\n\r\t\t
    //
    // where nnnnnnnnnn - is a decimal number 10 digits long or less.
    //
    // So, a typical string will look like:
    //
    //      %%601\n\r\t\t%%1604\n\r\t\t%%1608\n
    //
    // Since each such access may use at most:
    //
    //          10  (for the nnnnnnnnnn digit)
    //        +  2  (for %%)
    //        +  8  (for \n\t\t)
    //        --------------------------------
    //          20  wide characters
    //
    // The total length of the output string will be:
    //
    //           AccessCount    (number of accesses)
    //         x          20    (size of each entry)
    //         -------------------------------------
    //                          wchars
    //
    // Throw in 1 more WCHAR for null termination, and we are all set.
    //

    ResultantString->Length        = 0;
    ResultantString->MaximumLength = (USHORT)AccessCount * (20 * sizeof(WCHAR)) +
                                 sizeof(WCHAR);  //for the null termination

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
    printf("\t          \t%d byte buffer allocated.\n", ResultantString->MaximumLength);
#endif
    ResultantString->Buffer = LsapAllocateLsaHeap( ResultantString->MaximumLength );


    if (ResultantString->Buffer == NULL) {

        return(STATUS_NO_MEMORY);
    }

    (*FreeWhenDone) = TRUE;

    //
    // Special case standard and special access types.
    // Walk the lists for specific access types.
    //

    if (Accesses & STANDARD_RIGHTS_ALL) {

        if (Accesses & DELETE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringDelete);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));

        }


        if (Accesses & READ_CONTROL) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringReadControl);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_DAC) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteDac);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }


        if (Accesses & WRITE_OWNER) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringWriteOwner);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }

        if (Accesses & SYNCHRONIZE) {

            Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
            ASSERT( NT_SUCCESS( Status ));

            Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringSynchronize);
            ASSERT( NT_SUCCESS( Status ));

            if ( Indent ) {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
            } else {
                Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
            }
            ASSERT( NT_SUCCESS( Status ));
        }
    }


    if (Accesses & ACCESS_SYSTEM_SECURITY) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringAccessSysSec);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }

    if (Accesses & MAXIMUM_ALLOWED) {

        Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
        ASSERT( NT_SUCCESS( Status ));

        Status = RtlAppendUnicodeStringToString( ResultantString, &LsapAdtEventIdStringMaxAllowed);
        ASSERT( NT_SUCCESS( Status ));

        if ( Indent ) {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
        } else {
            Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
        }
        ASSERT( NT_SUCCESS( Status ));
    }


    //
    // If there are any specific access bits set, then get
    // the appropriate source module and object type base
    // message ID offset.  If there is no module-specific
    // object definition, then use SE_ACCESS_NAME_SPECIFIC_0
    // as the base.
    //

    if ((Accesses & SPECIFIC_RIGHTS_ALL) == 0) {
        return(Status);
    }

    LsapAdtSourceModuleLock();

    Source = (PLSAP_ADT_SOURCE)&LsapAdtSourceModules;
    Found  = FALSE;

    while ((Source->Next != NULL) && !Found) {

        if (RtlEqualUnicodeString(&Source->Next->Name, SourceModule, TRUE)) {

            Found = TRUE;
            FoundSource = Source->Next;

            //
            // Move to front of list of source modules.
            //

            Source->Next = FoundSource->Next;    // Remove from list
            FoundSource->Next = LsapAdtSourceModules; // point to first element
            LsapAdtSourceModules = FoundSource;       // Make it the first element

#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tModule Found.\n");
#endif

        } else {

            Source = Source->Next;
        }
    }


    if (Found == TRUE) {

        //
        // Find the object
        //

        Object = (PLSAP_ADT_OBJECT)&(FoundSource->Objects);
        Found  = FALSE;

        while ((Object->Next != NULL) && !Found) {

            if (RtlEqualUnicodeString(&Object->Next->Name, ObjectTypeName, TRUE)) {

                Found = TRUE;
                FoundObject = Object->Next;

                //
                // Move to front of list of soure modules.
                //

                Object->Next = FoundObject->Next;          // Remove from list
                FoundObject->Next = FoundSource->Objects;  // point to first element
                FoundSource->Objects = FoundObject;        // Make it the first element

            } else {

                Object = Object->Next;
            }
        }
    }


    //
    // We are done playing with link fields of the source modules
    // and objects.  Free the lock.
    //

    LsapAdtSourceModuleUnlock();

    //
    // If we have found an object, use it as our base message
    // ID.  Otherwise, use SE_ACCESS_NAME_SPECIFIC_0.
    //

    if (Found) {

        BaseOffset = FoundObject->BaseOffset;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif

    } else {

        BaseOffset = SE_ACCESS_NAME_SPECIFIC_0;
#ifdef LSAP_ADT_TEST_DUMP_SOURCES
printf("\t          \tObject NOT Found.  Base Offset: 0x%lx\n", BaseOffset);
#endif
    }


    //
    // At this point, we have a base offset (even if we had to use our
    // default).
    //
    // Now cycle through the specific access bits and see which ones need
    // to be added to ResultantString.
    //

    {
        UNICODE_STRING  IntegerString;
        WCHAR           IntegerStringBuffer[10]; //must be 10 wchar bytes long
        ULONG           NextBit;

        IntegerString.Buffer = (PWSTR)IntegerStringBuffer;
        IntegerString.MaximumLength = 10*sizeof(WCHAR);
        IntegerString.Length = 0;

        for ( i=0, NextBit=1  ; i<16 ;  i++, NextBit <<= 1 ) {

            //
            // specific access flags are in the low-order bits of the mask
            //

            if ((NextBit & Accesses) != 0) {

                //
                // Found one  -  add it to ResultantString
                //

                Status = RtlIntegerToUnicodeString (
                             (BaseOffset + i),
                             10,        //Base
                             &IntegerString
                             );

                if (NT_SUCCESS(Status)) {

                    Status = RtlAppendUnicodeToString( ResultantString, L"%%" );
                    ASSERT( NT_SUCCESS( Status ));

                    Status = RtlAppendUnicodeStringToString( ResultantString, &IntegerString);
                    ASSERT( NT_SUCCESS( Status ));

                    if ( Indent ) {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING );
                    } else {
                        Status = RtlAppendUnicodeToString( ResultantString, LSAP_ADT_ACCESS_NAME_FORMATTING_NL );
                    }
                    ASSERT( NT_SUCCESS( Status ));
                }
            }
        }
    }

    return(Status);


//ErrorAfterAlloc:
//
//    LsapFreeLsaHeap( ResultantString->Buffer );
//    ResultantString->Buffer = NULL;
//    (*FreeWhenDone) = FALSE;
//    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtmarshal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtmarshal.c

Abstract:

    Functions (de)marshalling of audit parameters

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"
#include "adtutil.h"

extern HANDLE LsapAdtLogHandle;


NTSTATUS
LsapAdtDemarshallAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and unpack it so that its information may be passed
    into the event logging service.

    Three parallel data structures are maintained:

    StringArray - Array of Unicode string structures.  This array
    is used primarily as temporary storage for returned string
    structures.

    StringPointerArray - Array of pointers to Unicode string structures.

    FreeWhenDone - Array of booleans describing how to dispose of each
    of the strings pointed to by the StringPointerArray.


    Note that entries in the StringPointerArray are contiguous, but that
    there may be gaps in the StringArray structure.  For each entry in the
    StringPointerArray there will be a corresponding entry in the FreeWhenDone
    array.  If the entry for a particular string is TRUE, the storage for
    the string buffer will be released to the process heap.



      StringArray
                                       Other strings
    +----------------+
    |                |<-----------+  +----------------+
    |                |            |  |                |<-------------------+
    +----------------+            |  |                |                    |
    |    UNUSED      |            |  +----------------+                    |
    |                |            |                                        |
    +----------------+            |                                        |
    |                |<------+    |  +----------------+                    |
    |                |       |    |  |                |<-----------+       |
    +----------------+       |    |  |                |            |       |
    |    UNUSED      |       |    |  +----------------+            |       |
    |                |       |    |                                |       |
    +----------------+       |    |                                |       |
    |                |<--+   |    |                                |       |
    |                |   |   |    |                                |       |
    +----------------+   |   |    |                                |       |
    |                |   |   |    |                                |       |
    |                |   |   |    |     StringPointerArray         |       |
          ....           |   |    |                                |       |
                         |   |    |     +----------------+         |       |
                         |   |    +-----|                |         |       |
                         |   |          +----------------+         |       |
                         |   |          |                |---------+       |
                         |   |          +----------------+                 |
                         |   +----------|                |                 |
                         |              +----------------+                 |
                         |              |                |-----------------+
                         |              +----------------+
                         +--------------|                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                        +----------------+
                                        |                |
                                              ....


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:


--*/

{

    ULONG ParameterCount;
    USHORT i;
    PUNICODE_STRING StringPointerArray[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING NewObjectTypeName;
    ULONG NewObjectTypeStringIndex = 0;
    BOOLEAN FreeWhenDone[SE_MAX_AUDIT_PARAM_STRINGS];
    UNICODE_STRING StringArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndexArray[SE_MAX_AUDIT_PARAM_STRINGS];
    USHORT StringIndex = 0;
    UNICODE_STRING DashString;
    BOOLEAN FreeDash;
    NTSTATUS Status;
    PUNICODE_STRING SourceModule;
    PSID UserSid;
    ULONG AuditId;

    AuditId = AuditParameters->AuditId;

    //
    // In w2k several events were introduced as explicit sucess/failure
    // cases. In whistler, we corrected this by folding each these event
    // pairs into a single event. We have retained the old failure event
    // schema so that anybody viewing w2k events from a whistler
    // machine can view them correctly.
    //
    // However, assert that we are not generating these events.
    //
    ASSERT((AuditId != SE_AUDITID_ADD_SID_HISTORY_FAILURE) &&
           (AuditId != SE_AUDITID_AS_TICKET_FAILURE)       &&
           (AuditId != SE_AUDITID_ACCOUNT_LOGON_FAILURE)   &&
           (AuditId != SE_AUDITID_ACCOUNT_NOT_MAPPED)      &&
           (AuditId != SE_AUDITID_TGS_TICKET_FAILURE));

    //
    // Initialization.
    //

    RtlZeroMemory( StringPointerArray, sizeof(StringPointerArray) );
    RtlZeroMemory( StringIndexArray, sizeof(StringIndexArray) );
    RtlZeroMemory( StringArray, sizeof(StringArray) );
    RtlZeroMemory( FreeWhenDone, sizeof(FreeWhenDone) );

    RtlInitUnicodeString( &NewObjectTypeName, NULL );

    Status = LsapAdtBuildDashString(
                 &DashString,
                 &FreeDash
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    ParameterCount = AuditParameters->ParameterCount;

    //
    // Parameter 0 will always be the user SID.  Convert the
    // offset to the SID into a pointer.
    //

    ASSERT( AuditParameters->Parameters[0].Type == SeAdtParmTypeSid );



    UserSid =      (PSID)AuditParameters->Parameters[0].Address;



    //
    // Parameter 1 will always be the Source Module (or Subsystem Name).
    // Unpack this now.
    //

    ASSERT( AuditParameters->Parameters[1].Type == SeAdtParmTypeString );



    SourceModule = (PUNICODE_STRING)AuditParameters->Parameters[1].Address;


    for (i=2; i<ParameterCount; i++) {
        StringIndexArray[i] = StringIndex;

        switch ( AuditParameters->Parameters[i].Type ) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT( FALSE && L"LsapAdtDemarshallAuditInfo: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
                {
                    StringPointerArray[StringIndex] = &DashString;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeString:
                {
                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeFileSpec:
                {
                    //
                    // Same as a string, except we must attempt to replace
                    // device information with a drive letter.
                    //

                    StringPointerArray[StringIndex] =
                        (PUNICODE_STRING)AuditParameters->Parameters[i].Address;


                    //
                    // This may not do anything, in which case just audit what
                    // we have.
                    //

                    LsapAdtSubstituteDriveLetter( StringPointerArray[StringIndex] );

                    FreeWhenDone[StringIndex] = FALSE;

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeHexUlong:
                {
                    ULONG Data;

                    Data = (ULONG) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildHexUlongString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeSid:
                {
                    PSID Sid;

                    Sid = (PSID)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildSidString(
                                 Sid,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;


                    break;
                }
            case SeAdtParmTypeLogonId:
                {
                    PLUID LogonId;
                    ULONG j;

                    LogonId = (PLUID)(&AuditParameters->Parameters[i].Data[0]);

                    Status = LsapAdtBuildLogonIdStrings(
                                 LogonId,
                                 &StringArray [ StringIndex     ],
                                 &FreeWhenDone[ StringIndex     ],
                                 &StringArray [ StringIndex + 1 ],
                                 &FreeWhenDone[ StringIndex + 1 ],
                                 &StringArray [ StringIndex + 2 ],
                                 &FreeWhenDone[ StringIndex + 2 ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        for (j=0; j<3; j++) {

                            StringPointerArray[StringIndex] = &StringArray[StringIndex];
                            StringIndex++;
                        }

                        //
                        // Finished, break out to surrounding loop.
                        //

                        break;

                    } else {

                        goto Cleanup;
                    }
                    break;
                }
            case SeAdtParmTypeNoLogonId:
                {
                    ULONG j;
                    //
                    // Create three "-" strings.
                    //

                    for (j=0; j<3; j++) {

                        StringPointerArray[ StringIndex ] = &DashString;
                        FreeWhenDone[ StringIndex ] = FALSE;
                        StringIndex++;
                    }

                    break;
                }
            case SeAdtParmTypeAccessMask:
                { 
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    ACCESS_MASK Accesses;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    Accesses= (ACCESS_MASK) AuditParameters->Parameters[i].Data[0];

                    //
                    // We can determine the index to the ObjectTypeName
                    // parameter since it was stored away in the Data[1]
                    // field of this parameter.
                    //

                    Status = LsapAdtBuildAccessesString(
                                 SourceModule,
                                 ObjectTypeName,
                                 Accesses,
                                 TRUE,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypePrivs:
                {

                    PPRIVILEGE_SET Privileges = (PPRIVILEGE_SET)AuditParameters->Parameters[i].Address;

                    Status = LsapBuildPrivilegeAuditString(
                                 Privileges,
                                 &StringArray [ StringIndex ],
                                 &FreeWhenDone[ StringIndex ]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[ StringIndex ] = &StringArray[ StringIndex ];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeTime:
                {
                    PLARGE_INTEGER pTime;

                    pTime = (PLARGE_INTEGER) &AuditParameters->Parameters[i].Data[0];

                    //
                    // First build a date string.
                    //

                    Status = LsapAdtBuildDateString(
                                 pTime,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    //
                    // Now build a time string.
                    //

                    Status = LsapAdtBuildTimeString(
                                 pTime,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }

            case SeAdtParmTypeObjectTypes:
                {
                    PUNICODE_STRING ObjectTypeName;
                    ULONG ObjectTypeNameIndex;
                    PSE_ADT_OBJECT_TYPE ObjectTypeList;
                    ULONG ObjectTypeCount;
                    ULONG j;

                    ObjectTypeNameIndex = (ULONG) AuditParameters->Parameters[i].Data[1];
                    NewObjectTypeStringIndex = StringIndexArray[ObjectTypeNameIndex];
                    ObjectTypeName = AuditParameters->Parameters[ObjectTypeNameIndex].Address;
                    ObjectTypeList = AuditParameters->Parameters[i].Address;
                    ObjectTypeCount = AuditParameters->Parameters[i].Length / sizeof(SE_ADT_OBJECT_TYPE);

                    //
                    // Will Fill in 10 entries.
                    //

                    (VOID) LsapAdtBuildObjectTypeStrings(
                               SourceModule,
                               ObjectTypeName,
                               ObjectTypeList,
                               ObjectTypeCount,
                               &StringArray [ StringIndex ],
                               &FreeWhenDone[ StringIndex ],
                               &NewObjectTypeName
                               );

                    for (j=0; j<10; j++) {
                        StringPointerArray[StringIndex] = &StringArray[StringIndex];
                        StringIndex++;
                    }


                    //
                    //
                    // &StringArray [ StringIndexArray[ObjectTypeNameIndex]],
                    // &FreeWhenDone[ StringIndexArray[ObjectTypeNameIndex]],

                    //
                    // Finished, break out to surrounding loop.
                    //

                    break;
                }
            case SeAdtParmTypePtr:
                {
                    PVOID Data;

                    Data = (PVOID) AuditParameters->Parameters[i].Data[0];

                    Status = LsapAdtBuildPtrString(
                                 Data,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];


                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;

                    break;
                }
            case SeAdtParmTypeGuid:
                {
                    LPGUID pGuid;

                    pGuid = (LPGUID)AuditParameters->Parameters[i].Address;

                    Status = LsapAdtBuildGuidString(
                                 pGuid,
                                 &StringArray[StringIndex],
                                 &FreeWhenDone[StringIndex]
                                 );

                    if ( NT_SUCCESS( Status )) {

                        StringPointerArray[StringIndex] = &StringArray[StringIndex];

                    } else {

                        goto Cleanup;
                    }

                    StringIndex++;
                    break;
                }
        }
    }

    //
    // If the generic object type name has been converted to something
    //  specific to this audit,
    //  substitute it now.
    //

    if ( NewObjectTypeName.Length != 0 ) {

        //
        // Free the previous object type name.
        //
        if ( FreeWhenDone[NewObjectTypeStringIndex] ) {
            LsapFreeLsaHeap( StringPointerArray[NewObjectTypeStringIndex]->Buffer );
        }

        //
        // Save the new object type name.
        //

        FreeWhenDone[NewObjectTypeStringIndex] = TRUE;
        StringPointerArray[NewObjectTypeStringIndex] = &NewObjectTypeName;

    }

#if DBG
    //
    // do some sanity check on the strings that we pass to ElfReportEventW.
    // If we dont do it here, it will be caught by ElfReportEventW and
    // it will involve more steps in debugger to determine the string
    // at fault. Checking it here saves us that trouble.
    //

    for (i=0; i<StringIndex; i++) {

        PUNICODE_STRING TempString;
        
        TempString = StringPointerArray[i];

        if ( !TempString )
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: string %d is NULL\n", i );
        }
        else if (!LsapIsValidUnicodeString( TempString ))
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: invalid string: %d @ %p ('%wZ' [%d / %d])\n",
                      i, TempString,
                      TempString, TempString->Length, TempString->MaximumLength);
            ASSERT( L"LsapAdtDemarshallAuditInfo: invalid string" && FALSE );
        }
    }
#endif

    //
    // Probably have to do this from somewhere else eventually, but for now
    // do it from here.
    //

    Status = ElfReportEventW (
                 LsapAdtLogHandle,
                 AuditParameters->Type,
                 (USHORT)AuditParameters->CategoryId,
                 AuditId,
                 UserSid,
                 StringIndex,
                 0,
                 StringPointerArray,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );

    //
    // If we are shutting down and we got an expected error back from the
    // eventlog, don't worry about it. This prevents bugchecking from an
    // audit failure while shutting down.
    //

    if ( ( (Status == RPC_NT_UNKNOWN_IF) || (Status == STATUS_UNSUCCESSFUL)) &&
         LsapState.SystemShutdownPending )
    {
        Status = STATUS_SUCCESS;
    }

 Cleanup:
    
    if ( !NT_SUCCESS(Status) )
    {
#if DBG
        if ( Status != STATUS_LOG_FILE_FULL )
        {
            DbgPrint( "LsapAdtDemarshallAuditInfo: failed: %x\n", Status );
            DsysAssertMsg( FALSE, "LsapAdtDemarshallAuditInfo: failed" );
        }
#endif        
        LsapAuditFailed( Status );
    }
    
    for (i=0; i<StringIndex; i++) {

        if (FreeWhenDone[i]) {
            LsapFreeLsaHeap( StringPointerArray[i]->Buffer );
        }
    }

    return( Status );
}




VOID
LsapAdtNormalizeAuditInfo(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters
    )

/*++

Routine Description:

    This routine will walk down a marshalled audit parameter
    array and turn it into an Absolute format data structure.


Arguments:

    AuditParameters - Receives a pointer to an audit
        parameters array in self-relative form.

Return Value:

    TRUE on success, FALSE on failure.

--*/

{

    ULONG ParameterCount;
    ULONG i;
    ULONG_PTR Address;
    PUNICODE_STRING Unicode;


    if ( !(AuditParameters->Flags & SE_ADT_PARAMETERS_SELF_RELATIVE)) {

        return;
    }

    ParameterCount = AuditParameters->ParameterCount;

    for (i=0; i<ParameterCount; i++) {

        switch ( AuditParameters->Parameters[i].Type ) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                //ASSERT( FALSE && L"LsapAdtNormalizeAuditInfo: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeTime:
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeNoLogonId:
            case SeAdtParmTypeAccessMask:
            case SeAdtParmTypePtr:
                {

                    break;
                }
            case SeAdtParmTypeGuid:
            case SeAdtParmTypeSid:
            case SeAdtParmTypePrivs:
            case SeAdtParmTypeObjectTypes:
            case SeAdtParmTypeString:
            case SeAdtParmTypeFileSpec:
                {
                    PUCHAR Fixup ;

                    Fixup = ((PUCHAR) AuditParameters ) +
                                (ULONG_PTR) AuditParameters->Parameters[i].Address ;

                    AuditParameters->Parameters[i].Address = (PVOID) Fixup ;

                    if ( (AuditParameters->Parameters[i].Type == SeAdtParmTypeString) ||
                         (AuditParameters->Parameters[i].Type == SeAdtParmTypeFileSpec ) )
                    {
                        //
                        // For the string types, also fix up the buffer pointer
                        // in the UNICODE_STRING
                        //

                        Unicode = (PUNICODE_STRING) Fixup ;
                        Unicode->Buffer = (PWSTR)((PCHAR)Unicode->Buffer + (ULONG_PTR)AuditParameters);
                    }

                    break;
                }
        }
    }
}




NTSTATUS
LsapAdtMarshallAuditRecord(
    IN PSE_ADT_PARAMETER_ARRAY AuditParameters,
    OUT PSE_ADT_PARAMETER_ARRAY *MarshalledAuditParameters
    )

/*++

Routine Description:

    This routine will take an AuditParamters structure and create
    a new AuditParameters structure that is suitable for placing
    to LSA.  It will be in self-relative form and allocated as
    a single chunk of memory.

Arguments:


    AuditParameters - A filled in set of AuditParameters to be marshalled.

    MarshalledAuditParameters - Returns a pointer to a block of heap memory
        containing the passed AuditParameters in self-relative form suitable
        for passing to LSA.


Return Value:

    None.

--*/

{
    ULONG i;
    ULONG TotalSize = sizeof( SE_ADT_PARAMETER_ARRAY );
    PUNICODE_STRING TargetString;
    PCHAR Base;
    ULONG BaseIncr;
    ULONG Size;
    PSE_ADT_PARAMETER_ARRAY_ENTRY pInParam, pOutParam;



    //
    // Calculate the total size required for the passed AuditParameters
    // block.  This calculation will probably be an overestimate of the
    // amount of space needed, because data smaller that 2 dwords will
    // be stored directly in the parameters structure, but their length
    // will be counted here anyway.  The overestimate can't be more than
    // 24 dwords, and will never even approach that amount, so it isn't
    // worth the time it would take to avoid it.
    //

    for (i=0; i<AuditParameters->ParameterCount; i++) {
        Size = AuditParameters->Parameters[i].Length;
        TotalSize += PtrAlignSize( Size );
    }

    //
    // Allocate a big enough block of memory to hold everything.
    // If it fails, quietly abort, since there isn't much else we
    // can do.
    //

    *MarshalledAuditParameters = LsapAllocateLsaHeap( TotalSize );

    if (*MarshalledAuditParameters == NULL) {

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlCopyMemory (
       *MarshalledAuditParameters,
       AuditParameters,
       sizeof( SE_ADT_PARAMETER_ARRAY )
       );

    (*MarshalledAuditParameters)->Length = TotalSize;
    (*MarshalledAuditParameters)->Flags  = SE_ADT_PARAMETERS_SELF_RELATIVE;

    pInParam  = &AuditParameters->Parameters[0];
    pOutParam = &((*MarshalledAuditParameters)->Parameters[0]);
   
    //
    // Start walking down the list of parameters and marshall them
    // into the target buffer.
    //

    Base = (PCHAR) ((PCHAR)(*MarshalledAuditParameters) + sizeof( SE_ADT_PARAMETER_ARRAY ));

    for (i=0; i<AuditParameters->ParameterCount; i++, pInParam++, pOutParam++) {


        switch (pInParam->Type) {
            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT( FALSE && L"LsapAdtMarshallAuditRecord: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
            case SeAdtParmTypeUlong:
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeLogonId:
            case SeAdtParmTypeNoLogonId:
            case SeAdtParmTypeAccessMask:
            case SeAdtParmTypePtr:
                {
                    //
                    // Nothing to do for this
                    //

                    break;

                }
            case SeAdtParmTypeString:
                {
                    PUNICODE_STRING SourceString;

                    //
                    // We must copy the body of the unicode string
                    // and then copy the body of the string.  Pointers
                    // must be turned into offsets.

                    TargetString = (PUNICODE_STRING)Base;

                    SourceString = pInParam->Address;

                    *TargetString = *SourceString;

                    //
                    // Reset the data pointer in the output parameters to
                    // 'point' to the new string structure.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base += sizeof( UNICODE_STRING );

                    RtlCopyMemory( Base, SourceString->Buffer, SourceString->Length );

                    //
                    // Make the string buffer in the target string point to where we
                    // just copied the data.
                    //

                    TargetString->Buffer = (PWSTR)(Base - (ULONG_PTR)(*MarshalledAuditParameters));

                    BaseIncr = PtrAlignSize(SourceString->Length);

                    Base += BaseIncr;

                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );

                    break;
                }
            case SeAdtParmTypeGuid:
            case SeAdtParmTypeSid:
            case SeAdtParmTypePrivs:
            case SeAdtParmTypeObjectTypes:
                {
#if DBG
                    switch (pInParam->Type)
                    {
                        case SeAdtParmTypeSid:
                            DsysAssertMsg( pInParam->Length >= RtlLengthSid(pInParam->Address),
                                           "LsapAdtMarshallAuditRecord" );
                            break;
                            
                        case SeAdtParmTypePrivs:
                            DsysAssertMsg( pInParam->Length >= LsapPrivilegeSetSize( (PPRIVILEGE_SET) pInParam->Address ),
                                           "LsapAdtMarshallAuditRecord" );
                            break;

                        case SeAdtParmTypeGuid:
                            DsysAssertMsg( pInParam->Length == sizeof(GUID),
                                           "LsapAdtMarshallAuditRecord" );
                            break;
                            
                        default:
                            break;
                        
                    }
#endif
                    //
                    // Copy the data into the output buffer
                    //

                    RtlCopyMemory( Base, pInParam->Address, pInParam->Length );

                    //
                    // Reset the 'address' of the data to be its offset in the
                    // buffer.
                    //

                    pOutParam->Address = Base - (ULONG_PTR)(*MarshalledAuditParameters);

                    Base +=  PtrAlignSize( pInParam->Length );

                    ASSERT( (ULONG_PTR)Base <= (ULONG_PTR)(*MarshalledAuditParameters) + TotalSize );

                    break;
                }
        }
    }

    return( STATUS_SUCCESS );
}




VOID
LsapAdtInitParametersArray(
    IN SE_ADT_PARAMETER_ARRAY* AuditParameters,
    IN ULONG AuditCategoryId,
    IN ULONG AuditId,
    IN USHORT AuditEventType,
    IN USHORT ParameterCount,
    ...)
/*++

Routine Description:

    This function initializes AuditParameters array in the format
    required by the LsapAdtWriteLog function.

Arguments:

    AuditParameters - pointer to audit parameters struct to be initialized

    AuditCategoryId - audit category id
        e.g. SE_CATEGID_OBJECT_ACCESS

    AuditId - sub-type of audit
        e.g. SE_AUDITID_OBJECT_OPERATION

    AuditEventType - The type of audit event to be generated.
        EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

    ParameterCount - number of parameter pairs after this parameter
        Each pair is in the form
        <parameter type>, <parameter value>
        e.g. SeAdtParmTypeString, <addr. of unicode string>

        The only exception is for SeAdtParmTypeAccessMask which is
        followed by <mask-value> and <index-to-object-type-entry>.
        Refer to LsapAdtGenerateObjectOperationAuditEvent for an example.
        

Return Value:

    None

Notes:

--*/
{
    va_list arglist;
    UINT i;

    PSE_ADT_PARAMETER_ARRAY_ENTRY Parameter;
    SE_ADT_PARAMETER_TYPE ParameterType;
    LUID Luid;
    LARGE_INTEGER LargeInteger;
    PPRIVILEGE_SET Privileges;
    PUNICODE_STRING String;
    PSID Sid;
    LPGUID pGuid;
    
    RtlZeroMemory ( (PVOID) AuditParameters,
                    sizeof(SE_ADT_PARAMETER_ARRAY) );

    AuditParameters->CategoryId     = AuditCategoryId;
    AuditParameters->AuditId        = AuditId;
    AuditParameters->Type           = AuditEventType;
    AuditParameters->ParameterCount = ParameterCount;

    Parameter = AuditParameters->Parameters;
    
    va_start (arglist, ParameterCount);

    for (i=0; i<ParameterCount; i++) {

        ParameterType = va_arg(arglist, SE_ADT_PARAMETER_TYPE);
        
        Parameter->Type = ParameterType;
        
        switch(ParameterType) {

            //
            // guard against somebody adding a new param type and not
            // adding appropriate code here.
            //
            default:
                ASSERT(FALSE && L"LsapAdtInitParametersArray: unknown param type");
                break;
                
            case SeAdtParmTypeNone:
                break;
                
            case SeAdtParmTypeFileSpec:
            case SeAdtParmTypeString:
                String = va_arg(arglist, PUNICODE_STRING);

                if ( String )
                {
                    Parameter->Length = sizeof(UNICODE_STRING)+String->Length;
                    Parameter->Address = String;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeHexUlong:
            case SeAdtParmTypeUlong:
                Parameter->Length = sizeof(ULONG);
                Parameter->Data[0] = va_arg(arglist, ULONG);
                break;
                
            case SeAdtParmTypePtr:
                Parameter->Length = sizeof(ULONG_PTR);
                Parameter->Data[0] = va_arg(arglist, ULONG_PTR);
                break;
                
            case SeAdtParmTypeSid:
                Sid = va_arg(arglist, PSID);

                if ( Sid )
                {
                    Parameter->Length = RtlLengthSid(Sid);
                    Parameter->Address = Sid;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeGuid:
                pGuid = va_arg(arglist, LPGUID);

                if ( pGuid )
                {
                    Parameter->Length  = sizeof(GUID);
                    Parameter->Address = pGuid;
                }
                else
                {
                    //
                    // if the caller passed NULL, make type == none
                    // so that a '-' will be emitted in the eventlog
                    //

                    Parameter->Type = SeAdtParmTypeNone;
                }
                break;
                
            case SeAdtParmTypeLogonId:
                Luid = va_arg(arglist, LUID);
                Parameter->Length = sizeof(LUID);
                *((LUID*) Parameter->Data) = Luid;
                break;

            case SeAdtParmTypeTime:
                LargeInteger = va_arg(arglist, LARGE_INTEGER);
                Parameter->Length = sizeof(LARGE_INTEGER);
                *((PLARGE_INTEGER) Parameter->Data) = LargeInteger;
                break;
                
            case SeAdtParmTypeNoLogonId:
                // no additional setting
                break;
                
            case SeAdtParmTypeAccessMask:
                Parameter->Length = sizeof(ACCESS_MASK);
                Parameter->Data[0] = va_arg(arglist, ACCESS_MASK);
                Parameter->Data[1] = va_arg(arglist, USHORT);
                break;
                
            case SeAdtParmTypePrivs:
                Privileges = va_arg(arglist, PPRIVILEGE_SET);
                Parameter->Length = LsapPrivilegeSetSize(Privileges);
                break;
                
            case SeAdtParmTypeObjectTypes:
                {
                    ULONG ObjectTypeCount;
                    
                    Parameter->Address = va_arg(arglist, PSE_ADT_OBJECT_TYPE);
                    ObjectTypeCount    = va_arg(arglist, ULONG);
                    Parameter->Length  = sizeof(SE_ADT_OBJECT_TYPE)*ObjectTypeCount;
                    Parameter->Data[1] = va_arg(arglist, ULONG);
                }
                break;
        }
        Parameter++;
    }
    
    va_end(arglist);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtpol.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    adtpol.c

Abstract:

    This file has functions related to audit policy.

Author:

    16-August-2000  kumarp

--*/

#include <lsapch2.h>
#include "adtp.h"


//
// Audit Events Information.
//

LSARM_POLICY_AUDIT_EVENTS_INFO LsapAdtEventsInformation;



BOOLEAN
LsapAdtIsAuditingEnabledForCategory(
    IN POLICY_AUDIT_EVENT_TYPE AuditCategory,
    IN UINT AuditEventType
    )
/*++

Routine Description:

    Find out if auditing is enabled for a certain event category and
    event success/failure case.

Arguments:

    AuditCategory - Category of event to be audited.
        e.g. AuditCategoryPolicyChange

    AuditEventType - status type of event
        e.g. EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

Return Value:

    TRUE or FALSE

--*/
{
    BOOLEAN AuditingEnabled;
    POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    
    ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
           (AuditEventType == EVENTLOG_AUDIT_FAILURE));
    
    AuditingEnabled = FALSE;
    
    if ( LsapAdtEventsInformation.AuditingMode ) {
        EventAuditingOptions =
            LsapAdtEventsInformation.EventAuditingOptions[AuditCategory];

        AuditingEnabled =
            (AuditEventType == EVENTLOG_AUDIT_SUCCESS) ?
            (BOOLEAN) (EventAuditingOptions & POLICY_AUDIT_EVENT_SUCCESS) :
            (BOOLEAN) (EventAuditingOptions & POLICY_AUDIT_EVENT_FAILURE);
    }

    return AuditingEnabled;
}


VOID
LsapAuditFailed(
    IN NTSTATUS AuditStatus
    )

/*++

Routine Description:

    Implements current policy of how to deal with a failed audit.

Arguments:

    None.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE KeyHandle;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    UCHAR NewValue;
    ULONG Response;
    ULONG_PTR HardErrorParam;
    BOOLEAN PrivWasEnabled;
    
    if (LsapCrashOnAuditFail) {

        //
        // Turn off flag in the registry that controls crashing on audit failure
        //

        RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa");

        InitializeObjectAttributes( &Obja,
                                    &KeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    NULL
                                    );
        do {

            Status = NtOpenKey(
                         &KeyHandle,
                         KEY_SET_VALUE,
                         &Obja
                         );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));

        //
        // If the LSA key isn't there, he's got big problems.  But don't crash.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {
            LsapCrashOnAuditFail = FALSE;
            return;
        }

        if (!NT_SUCCESS( Status )) {
            goto bugcheck;
        }

        RtlInitUnicodeString( &ValueName, CRASH_ON_AUDIT_FAIL_VALUE );

        NewValue = LSAP_ALLOW_ADIMIN_LOGONS_ONLY;

        do {

            Status = NtSetValueKey( KeyHandle,
                                    &ValueName,
                                    0,
                                    REG_DWORD,
                                    &NewValue,
                                    sizeof(UCHAR)
                                    );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
        ASSERT(NT_SUCCESS(Status));

        if (!NT_SUCCESS( Status )) {
            goto bugcheck;
        }

        do {

            Status = NtFlushKey( KeyHandle );

        } while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
        ASSERT(NT_SUCCESS(Status));

    //
    // go boom.
    //

bugcheck:

        HardErrorParam = AuditStatus;

        //
        // stop impersonating
        //
 
        Status = NtSetInformationThread(
                     NtCurrentThread(),
                     ThreadImpersonationToken,
                     NULL,
                     (ULONG) sizeof(HANDLE)
                     );

        DsysAssertMsg( NT_SUCCESS(Status), "LsapAuditFailed: NtSetInformationThread" );
        
        
        //
        // enable the shutdown privilege so that we can bugcheck
        // 

        Status = RtlAdjustPrivilege( SE_SHUTDOWN_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );

        DsysAssertMsg( NT_SUCCESS(Status), "LsapAuditFailed: RtlAdjustPrivilege" );
        
        Status = NtRaiseHardError(
                     STATUS_AUDIT_FAILED,
                     1,
                     0,
                     &HardErrorParam,
                     OptionShutdownSystem,
                     &Response
                     );

        //
        // if the bugcheck succeeds, we should not really come here
        //

        DsysAssertMsg( FALSE, "LsapAuditFailed: we should have bugchecked on the prior line!!" );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtutil.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtutil.h

Abstract:

    Misc helper functions

Author:

    15-August-2000   kumarp

--*/

ULONG
LsapSafeWcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    );


BOOL
LsapIsValidUnicodeString(
    IN PUNICODE_STRING pUString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtlq.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        A D T L Q . C
//
// Contents:    definitions of types/functions required for 
//              managing audit queue
//
//
// History:     
//   23-May-2000  kumarp        created
//
//------------------------------------------------------------------------



#ifndef _ADTLQ_H_
#define _ADTLQ_H_

EXTERN_C ULONG LsapAdtQueueLength;


NTSTATUS
LsapAdtAcquireLogQueueLock();

VOID
LsapAdtReleaseLogQueueLock();

NTSTATUS
LsapAdtInitializeLogQueue(
    );

NTSTATUS 
LsapAdtAddToQueue(
    IN PLSAP_ADT_QUEUED_RECORD pAuditRecord,
    IN DWORD Options
    );

NTSTATUS 
LsapAdtGetQueueHead(
    OUT PLSAP_ADT_QUEUED_RECORD *ppRecord
    );


NTSTATUS
LsapAdtFlushQueue( );

#endif // _ADTLQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\adtutil.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    adtutil.c

Abstract:

    Misc helper functions

Author:

    15-August-2000   kumarp

--*/
 

#include <lsapch2.h>
#include "adtp.h"


NTSTATUS
ImpersonateAnyClient(); // from ntdsa

VOID
UnImpersonateAnyClient(); // from ntdsa



ULONG
LsapSafeWcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    )
/*++

    Safewcslen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the size of a UNICODE_STRING
    (taken from elfapi.c)

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of bytes in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (p)
    {
        while ((MaxLength > 0) && (*p++ != UNICODE_NULL))
        {
            MaxLength -= sizeof(WCHAR);
            Count     += sizeof(WCHAR);
        }
    }

    return Count;
}


BOOL
LsapIsValidUnicodeString(
    IN PUNICODE_STRING pUString
    )

/*++

Routine Description:

    Verify the unicode string. The string is invalid if:
        The UNICODE_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.
    (taken from elfapi.c)

Arguments:

    pUString    - String to verify.

Return Value:

    TRUE   if the string is valid
    FALSE  otherwise

--*/
{
    return !(!pUString ||
             (pUString->MaximumLength < pUString->Length) ||
             (pUString->Length != LsapSafeWcslen(pUString->Buffer,
                                                 pUString->Length)));
}



BOOLEAN
LsapAdtLookupDriveLetter(
    IN PUNICODE_STRING FileName,
    OUT PUSHORT DeviceNameLength,
    OUT PWCHAR DriveLetter
    )

/*++

Routine Description:

    This routine will take a file name and compare it to the
    list of device names obtained during LSA initialization.
    If one of the device names matches the prefix of the file
    name the corresponding drive letter will be returned.

Arguments:

    FileName - Supplies a unicode string containing the file
        name obtained from the file system.

    DeviceNameLength - If successful, returns the length of
        the device name.

    DriveLetter - If successful, returns the drive letter
        corresponding to the device object.

Return Value:

    Returns TRUE of a mapping is found, FALSE otherwise.

--*/

{
    LONG i = 0;
    PUNICODE_STRING DeviceName;
    USHORT OldLength;


    for (i = MAX_DRIVE_MAPPING - 1; i >= 0; i--)
    {
    
        if (DriveMappingArray[i].DeviceName.Buffer != NULL ) {

            DeviceName = &DriveMappingArray[i].DeviceName;

            //
            // If the device name is longer than the passed file name,
            // it can't be a match.
            //

            if ( DeviceName->Length > FileName->Length ) {
                continue;
            }

            //
            // Temporarily truncate the file name to be the same
            // length as the device name by adjusting the length field
            // in its unicode string structure.  Then compare them and
            // see if they match.
            //
            // The test above ensures that this is a safe thing to
            // do.
            //

            OldLength = FileName->Length;
            FileName->Length = DeviceName->Length;


            if ( RtlEqualUnicodeString( FileName, DeviceName, TRUE ) ) {

                //
                // We've got a match.
                //

                FileName->Length = OldLength;
                *DriveLetter = DriveMappingArray[i].DriveLetter;
                *DeviceNameLength = DeviceName->Length;
                return( TRUE );

            }

            FileName->Length = OldLength;
        }
    }

    return( FALSE );
}



VOID
LsapAdtSubstituteDriveLetter(
    IN OUT PUNICODE_STRING FileName
    )

/*++

Routine Description:

    Takes a filename and replaces the device name part with a
    drive letter, if possible.

    The string will be edited directly in place, which means that
    the Length field will be adjusted, and the Buffer contents will
    be moved so that the drive letter is at the beginning of the
    buffer.  No memory will be allocated or freed.

Arguments:

    FileName - Supplies a pointer to a unicode string containing
        a filename.

Return Value:

    None.

--*/

{

    WCHAR DriveLetter;
    USHORT DeviceNameLength;
    PWCHAR p;
    PWCHAR FilePart;
    USHORT FilePartLength;

    if ( LsapAdtLookupDriveLetter( FileName, &DeviceNameLength, &DriveLetter )) {

        p = FileName->Buffer;
        FilePart = (PWCHAR)((PCHAR)(FileName->Buffer) + DeviceNameLength);
        FilePartLength = FileName->Length - DeviceNameLength;


        *p = DriveLetter;
        *++p = L':';

        //
        // THIS IS AN OVERLAPPED COPY!  DO NOT USE RTLCOPYMEMORY!
        //

        RtlMoveMemory( ++p, FilePart, FilePartLength );

        FileName->Length = FilePartLength + 2 * sizeof( WCHAR );
    }
}




NTSTATUS
LsapQueryClientInfo(
    PTOKEN_USER *UserSid,
    PLUID AuthenticationId
    )

/*++

Routine Description:

    This routine impersonates our client, opens the thread token, and
    extracts the User Sid.  It puts the Sid in memory allocated via
    LsapAllocateLsaHeap, which must be freed by the caller.

Arguments:

    None.

Return Value:

    Returns a pointer to heap memory containing a copy of the Sid, or
    NULL.

--*/

{
    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (!NT_SUCCESS(Status))
    {
        if (Status != STATUS_NO_TOKEN)
        {
            return Status;
        }

        if ( LsaDsStateInfo.DsInitializedAndRunning )
        {
           Status = I_RpcMapWin32Status(ImpersonateAnyClient());
        }
        else
        {
           Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));
        }

        if (NT_SUCCESS(Status))
        {
            Status = NtOpenThreadToken(
                         NtCurrentThread(),
                         TOKEN_QUERY,
                         TRUE,                    // OpenAsSelf
                         &TokenHandle
                         );

            if ( LsaDsStateInfo.DsInitializedAndRunning )
            {
                UnImpersonateAnyClient();
            }
            else
            {
                NTSTATUS DbgStatus;

                DbgStatus = I_RpcMapWin32Status(RpcRevertToSelf());

                ASSERT(NT_SUCCESS(DbgStatus));
            }

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }
        }
        else if (Status == RPC_NT_NO_CALL_ACTIVE)
        {
            Status = NtOpenProcessToken(
                         NtCurrentProcess(),
                         TOKEN_QUERY,
                         &TokenHandle
                         );

            if (!NT_SUCCESS(Status))
            {
                return Status;
            }
        }
        else
        {
            return Status;
        }
    }


    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength
                 );

    if ( Status != STATUS_BUFFER_TOO_SMALL ) {

        (void) NtClose( TokenHandle );
        return( Status );
    }

    *UserSid = LsapAllocateLsaHeap( ReturnLength );

    if ( *UserSid == NULL ) {

        NtClose( TokenHandle );
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 *UserSid,
                 ReturnLength,
                 &ReturnLength
                 );


    if ( !NT_SUCCESS( Status )) {

        NtClose( TokenHandle );
        LsapFreeLsaHeap( *UserSid );
        *UserSid = NULL;
        return( Status );
    }

    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenStatistics,
                 (PVOID)&TokenStats,
                 sizeof( TOKEN_STATISTICS ),
                 &ReturnLength
                 );

    NtClose( TokenHandle );

    if ( !NT_SUCCESS( Status )) {

        LsapFreeLsaHeap( *UserSid );
        *UserSid = NULL;
        return( Status );
    }

    *AuthenticationId = TokenStats.AuthenticationId;

    return( STATUS_SUCCESS );
}

BOOL
LsapIsLocalOrNetworkService(
    IN PUNICODE_STRING pUserName,
    IN PUNICODE_STRING pUserDomain
    )

/*++

Routine Description:

    This routine checks to see if the passed account name represents
    a local or network service

Arguments:

    None.

Return Value:

    TRUE  if the passed account name represents a local or network service
    FALSE otherwise

--*/
{
#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

    static UNICODE_STRING  LocalServiceName = { sizeof(LOCALSERVICE_NAME) - 2,
                                                sizeof(LOCALSERVICE_NAME),
                                                LOCALSERVICE_NAME };

    static UNICODE_STRING  NetworkServiceName = { sizeof(NETWORKSERVICE_NAME) - 2,
                                                  sizeof(NETWORKSERVICE_NAME),
                                                  NETWORKSERVICE_NAME };

    static UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - 2,
                                               sizeof(NTAUTHORITY_NAME),
                                               NTAUTHORITY_NAME };

    PUNICODE_STRING pLocalServiceName;
    PUNICODE_STRING pNetworkServiceName;
    PUNICODE_STRING pLocalDomainName;

    if ( !pUserName || !pUserDomain )
    {
        return FALSE;
    }

    //
    // Hardcoded english strings for LocalService and NetworkService
    // since the account names may come from the registry (which isn't
    // localized).
    //

    pLocalDomainName    = &WellKnownSids[LsapLocalServiceSidIndex].DomainName;
    pNetworkServiceName = &WellKnownSids[LsapNetworkServiceSidIndex].Name;
    pLocalServiceName   = &WellKnownSids[LsapLocalServiceSidIndex].Name;

    //
    // check both hardcode and localized names
    //

    if (((RtlCompareUnicodeString(&NTAuthorityName,     pUserDomain, TRUE) == 0) &&
         ((RtlCompareUnicodeString(&LocalServiceName,   pUserName, TRUE) == 0) ||
          (RtlCompareUnicodeString(&NetworkServiceName, pUserName, TRUE) == 0))) ||

        ((RtlCompareUnicodeString(pLocalDomainName,     pUserDomain, TRUE) == 0) &&
         ((RtlCompareUnicodeString(pLocalServiceName,   pUserName, TRUE) == 0) ||
          (RtlCompareUnicodeString(pNetworkServiceName, pUserName, TRUE) == 0))))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\aucred.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aucred.c

Abstract:

    This module provides credential management services within the
    LSA subsystem.  Some of these services are indirectly available for use
    by authentication packages.

Author:

    Jim Kelly (JimK) 27-February-1991

Revision History:

--*/

#include <lsapch2.h>

#if 1

RTL_RESOURCE                AuCredLock ;

#define AuReadLockCreds()   RtlAcquireResourceShared( &AuCredLock, TRUE );
#define AuWriteLockCreds()  RtlAcquireResourceExclusive( &AuCredLock, TRUE );
#define AuUnlockCreds()     RtlReleaseResource( &AuCredLock );

#else

RTL_CRITICAL_SECTION    AuCredLock ;

#define AuReadLockCreds()   RtlEnterCriticalSection( &AuCredLock );
#define AuWriteLockCreds()  RtlEnterCriticalSection( &AuCredLock );
#define AuUnlockCreds()     RtlLeaveCriticalSection( &AuCredLock );

#endif

NTSTATUS
LsapInitializeCredentials(
    VOID
    )
{
#if 1
    __try {
        RtlInitializeResource( &AuCredLock );
        return STATUS_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
#else
    return RtlInitializeCriticalSection( &AuCredLock );
#endif
}


NTSTATUS
LsapAddCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue,
    IN PSTRING Credentials
    )

/*++

Routine Description:

    This service is used by authentication packages to add credentials to a
    logon session.  These credentials may later be referenced using
    GetCredentials().

    This service acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session to add credentials to.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  This was received in the
        InitializePackage() call during DLL initialization.

    PrimaryKeyValue - Points to a string containing a value that the
        authentication package will later want to reference as a
        primary key of the credential data.  This may be used, for
        example, to keep the name of the domain or server the
        credentials are related to.  The format and meaning of this
        string are authentication package-specific.  Note that the
        string value does not have to be unique, even for the
        specified logon session.  For example, there could be two
        passwords for the same domain, each with the passwords stored
        as credentials and the domain name stored as the primary key.

    Credentials - Points to a string containing  data representing
        user credentials.  The format and meaning of this string are
        authentication package-specific.

Return Status:

    STATUS_SUCCESS - The credentials were successfully added.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

--*/

{

    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS NewCredentials = NULL;
    USHORT MaxPrimary;
    USHORT MaxCredentials;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    //
    // Allocate blocks needed to represent this credential
    // and copy the primary key and credential strings.
    //

    MaxPrimary = ROUND_UP_COUNT((PrimaryKeyValue->Length+sizeof(CHAR)), ALIGN_WORST);
    MaxCredentials = ROUND_UP_COUNT((Credentials->Length+sizeof(CHAR)), ALIGN_WORST);

    NewCredentials = LsapAllocatePrivateHeap( (ULONG)sizeof(LSAP_CREDENTIALS) +
                                          MaxPrimary +
                                          MaxCredentials
                                          );

    if ( NewCredentials == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    NewCredentials->PrimaryKey.MaximumLength = MaxPrimary;
    NewCredentials->PrimaryKey.Buffer = (PSTR)(NewCredentials+1);
    
    NewCredentials->Credentials.MaximumLength = MaxCredentials;
    NewCredentials->Credentials.Buffer = NewCredentials->PrimaryKey.Buffer +
                                         NewCredentials->PrimaryKey.MaximumLength;

    RtlCopyString( &NewCredentials->PrimaryKey, PrimaryKeyValue );
    RtlCopyString( &NewCredentials->Credentials, Credentials );


    //
    // Now get a pointer to the Package's credentials
    // (create one if necessary)
    //

    AuWriteLockCreds();

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  TRUE
                  );

    if ( !Package )
    {
        AuUnlockCreds();
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // insert new credentials in list.
    //

    NewCredentials->NextCredentials = Package->Credentials;

    Package->Credentials = NewCredentials;

    AuUnlockCreds();
    LsapReleaseLogonSession( LogonSession );

    return STATUS_SUCCESS;


Cleanup:

    LsapReleaseLogonSession( LogonSession );

    if ( NewCredentials )
    {
        if ( NewCredentials->PrimaryKey.Buffer )
        {
            ZeroMemory( NewCredentials->PrimaryKey.Buffer,
                        NewCredentials->PrimaryKey.Length );
        }

        if ( NewCredentials->Credentials.Buffer )
        {
            ZeroMemory( NewCredentials->Credentials.Buffer,
                        NewCredentials->Credentials.Length );
        }

        LsapFreePrivateHeap( NewCredentials );
    }

    return Status;

}


NTSTATUS
LsapGetCredentials(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN OUT PULONG QueryContext,
    IN BOOLEAN RetrieveAllCredentials,
    IN PSTRING PrimaryKeyValue,
    OUT PULONG PrimaryKeyLength,
    IN PSTRING Credentials
    )

/*++

Routine Description:

    This service is used by authentication packages to retrieve credentials
    associated with a logon session.  It is expected that each authentication
    package will provide its own version of this service to its "clients".
    For example, the MSV1_0 authentication package will provide services for
    the LM Redirector to retrieve credentials (and probably establish them)
    for remote accesses.  These authentication package level services may be
    implemented using the LsaCallAuthenticationPackage() API.

    This service acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session from which credentials
        are to be retrieved.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  Authentication packages
        should only retrieve their own credentials.

    QueryContext - A context value used across successive calls to
        retrieve multiple credentials.  The first time this service
        is used, the value pointed to by this argument should be
        zero.  Thereafter, this value will be updated to allow
        retrieval to continue where it left off.  This value should,
        therefore, not be changed until all credentials of a given
        query operation have been retrieved.

    RetrieveAllCredentials - A boolean value indicating whether all
        credentials for the specified logon session should be
        retrieved (TRUE), or only those matching the specified
        PrimaryKeyValue (FALSE).

    PrimaryKeyValue - This parameter serves two purposes.  If the
        RetrieveAllCredentials argument is FALSE, then this string
        contains the value to use as a primary key lookup value.  In
        this case, only credentials whose primary key matches this
        one (and belonging to the correct logon session) will be
        retrieved.  If, however, the RetrieveAllCredentials argument
        is FALSE, then the value of this string are ignored.  In this
        case, the primary key value of each retrieved credential will
        be returned in this string.

    PrimaryKeyLength - If the RetrieveAllCredentials argument value
        is FALSE, then this argument receives the length needed to
        store the PrimaryKeyValue.  If this value is larger than the
        length of the PrimaryKeyValue string, then
        STATUS_BUFFER_OVERFLOW is returned and no data is retrieved.

    Credentials - Points to a string whose buffer is to be set to
        contain the retrieved credential.

Return Status:

    STATUS_MORE_ENTRIES - Credentials were successfully retrieved,
        and there are more available.

    STATUS_SUCCESS - Credentials were successfully retrieved and
        there are no more available.

    STATUS_UNSUCCESSFUL - No more credentials are available.  If
        returned on the first call, then there are no credentials
        matching the selection criteria.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

    STATUS_BUFFER_OVERFLOW - Indicates the string provided to receive
        the PrimaryKeyValue was not large enough to hold the data.
        In this case, no data was retrieved. However, the length value
        is returned so that appropriately sized buffer can be passed in
        a successive call.


--*/

{
    //
    // NOTE: The QueryContext value is an index of the last retrieved
    //       credential matching the selection criteria.  To continue
    //       a search for successive credentials, skip QueryContext
    //       number of entries first.
    //
    //       This has the problem of changes between calls screwing
    //       up the result of successive calls.  That's tough.
    //


    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS NextCredentials;
    ULONG i;
    BOOLEAN SelectionMatch;



    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {
        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    AuReadLockCreds();

    //
    // Now get a pointer to the Package's credentials
    //

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  FALSE
                  );

    if ( Package == NULL ) {

        AuUnlockCreds();

        LsapReleaseLogonSession( LogonSession );

        return STATUS_UNSUCCESSFUL;
    }

    //
    // skip the credentials already evaluated in previous calls...
    //

    i = (*QueryContext);
    NextCredentials = Package->Credentials;
    while ( i > 0 ) {

        //
        // See if we have reached the end of the list
        //

        if (NextCredentials == NULL) {

            AuUnlockCreds();

            LsapReleaseLogonSession( LogonSession );

            return STATUS_UNSUCCESSFUL;
        }

        //
        // Nope, skip the next one...
        //

        NextCredentials = NextCredentials->NextCredentials;
        i -= 1;

    }


    //
    // Start evaluating each credential for a criteria match.
    //

    SelectionMatch = FALSE;
    while ( NextCredentials != NULL && !SelectionMatch ) {

        (*QueryContext) += 1;

        if (RetrieveAllCredentials) {

            SelectionMatch = TRUE;
            Status = LsapReturnCredential(
                         NextCredentials,
                         Credentials,
                         TRUE,
                         PrimaryKeyValue,
                         PrimaryKeyLength
                         );
        }

        //
        // Only retrieving credentials that match the specified primary
        // key.
        //

        if ( RtlEqualString( &NextCredentials->PrimaryKey, PrimaryKeyValue, FALSE) ) {

            SelectionMatch = TRUE;
            Status = LsapReturnCredential(
                         NextCredentials,
                         Credentials,
                         FALSE,
                         NULL,
                         NULL
                         );

        }

        NextCredentials = NextCredentials->NextCredentials;

    }

    AuUnlockCreds();

    LsapReleaseLogonSession( LogonSession );

    //
    // Figure out what return value to send.
    //

    if (SelectionMatch) {

        if ( Status == STATUS_BUFFER_OVERFLOW ) {
            (*QueryContext) -= 1;
            return STATUS_BUFFER_OVERFLOW;
        }


        if ( Status == STATUS_SUCCESS) {
            if ( NextCredentials == NULL ) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_MORE_ENTRIES;
            }
        }


    } else {

        //
        // didn't find a credential matching the selection criteria.
        //

        return STATUS_UNSUCCESSFUL;

    }

    return STATUS_UNSUCCESSFUL ;
}


NTSTATUS
LsapReturnCredential(
    IN PLSAP_CREDENTIALS SourceCredentials,
    IN PSTRING TargetCredentials,
    IN BOOLEAN ReturnPrimaryKey,
    IN PSTRING PrimaryKeyValue OPTIONAL,
    OUT PULONG PrimaryKeyLength OPTIONAL
    )

/*++

Routine Description:

    This routine returns a copy of the credentials in the specified
    credential record.  It also, optionally, returns a copy of the
    primary key value.

Arguments:

    SourceCredentials - Points to a credential record whose credential
        string and, optionally, primary key are to be copied.

    TargetCredentials - Points to a string whose buffer is to be set to
        contain a copy of the credential.  This copy will be allocated
        using LsapAllocateLsaHeap().

    ReturnPrimaryKey - A boolean indicating whether or not to return
        a copy of the primary key.  TRUE indicates a copy should be
        returned.  FALSE indicates a copy should not be returned.

    PrimaryKeyValue - Points to a string whose buffer is to be set to
        contain a copy of the primary key.  This copy will be allocated
        using LsapAllocateLsaHeap().  This parameter is ignored if the
        ReturnPrimaryKey argument value is FALSE.


    PrimaryKeyLength - Points to a value which will receive the
        length of the primary key value.  If this value is larger than the
        length of the PrimaryKeyValue string, then STATUS_BUFFER_OVERFLOW
        is returned and no data is retrieved.



Return Status:

    STATUS_SUCCESS - Credentials were successfully returned.

    STATUS_BUFFER_OVERFLOW - Indicates the string provided to receive
        the PrimaryKeyValue was not large enough to hold the data.
        In this case, no data was retrieved. However, the length value
        is returned so that appropriately sized buffer can be passed in
        a successive call.

--*/

{
    ULONG Length;

    //
    // First try to return the primary key value, since we can encounter
    // a buffer overflow situation in doing so that would prevent us from
    // returning a copy of the credential string.
    //

    if (ReturnPrimaryKey) {
        (*PrimaryKeyLength) = SourceCredentials->PrimaryKey.Length + 1;
        if ( (*PrimaryKeyLength) > PrimaryKeyValue->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
        }

        //
        // It fits
        //

        RtlCopyString( PrimaryKeyValue, &SourceCredentials->PrimaryKey );
    }

    //
    // Now allocate and copy the credential string copy.
    //

    TargetCredentials->MaximumLength = SourceCredentials->Credentials.Length
                                       + (USHORT)1;

    Length = (ULONG)TargetCredentials->MaximumLength;

    TargetCredentials->Buffer = (PCHAR)LsapAllocateLsaHeap( Length );

    if ( TargetCredentials->Buffer )
    {
        RtlCopyString( TargetCredentials, &SourceCredentials->Credentials );

        return STATUS_SUCCESS ;
    }
    else
    {
        return STATUS_NO_MEMORY ;
    }

}



NTSTATUS
LsapDeleteCredential(
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PSTRING PrimaryKeyValue
    )

/*++

Routine Description:

    This service is used to delete an existing credential.  This service
    deletes the first credential it finds with a matching logon session,
    authentication package ID, and primary key value.  If thee are
    multiple credentials that match this criteria, only one of them is
    deleted.

    This status acquires the AuLock.

Arguments:

    LogonId - The session ID of logon session whose credentials are to be
        deleted.

    AuthenticationPackage - The authentication package ID of the
        calling authentication package.  This was received in the
        InitializePackage() call during DLL initialization.

    PrimaryKeyValue - Points to string containing the primary key value
        of the credential to be deleted.


Return Status:

    STATUS_SUCCESS - The credentials were successfully deleted.

    STATUS_NO_SUCH_LOGON_SESSION - The specified logon session could
        not be found.

    STATUS_UNSUCCESSFUL - No such credential could be found.

--*/

{


    PLSAP_LOGON_SESSION LogonSession;
    PLSAP_PACKAGE_CREDENTIALS Package;
    PLSAP_CREDENTIALS *NextCredentials, GoodByeCredentials;





    //
    // Get a pointer to the logon session
    //

    LogonSession = LsapLocateLogonSession( LogonId );

    if ( LogonSession == NULL ) {

        return STATUS_NO_SUCH_LOGON_SESSION;
    }

    AuWriteLockCreds();


    //
    // Now get a pointer to the Package's credentials
    //

    Package = LsapGetPackageCredentials(
                  LogonSession,
                  AuthenticationPackage,
                  FALSE
                  );

    if ( Package == NULL ) {

        AuUnlockCreds();

        LsapReleaseLogonSession( LogonSession );

        return STATUS_UNSUCCESSFUL;
    }



    //
    // Start evaluating each credential for a primary key value match.
    //

    NextCredentials = &Package->Credentials;
    while ( (*NextCredentials) != NULL ) {


        if ( RtlEqualString(
                 &(*NextCredentials)->PrimaryKey,
                 PrimaryKeyValue,
                 FALSE)
           ) {

            //
            // remove it from the list
            //

            GoodByeCredentials = (*NextCredentials);
            (*NextCredentials) = GoodByeCredentials->NextCredentials;

            AuUnlockCreds();

            LsapReleaseLogonSession( LogonSession );

            //
            // Zero the contents of the credential record.
            //

            if( GoodByeCredentials->PrimaryKey.Buffer != NULL )
            {
                ZeroMemory( GoodByeCredentials->PrimaryKey.Buffer,
                            GoodByeCredentials->PrimaryKey.Length );
            }
            
            if( GoodByeCredentials->Credentials.Buffer != NULL )
            {
                ZeroMemory( GoodByeCredentials->Credentials.Buffer,
                            GoodByeCredentials->Credentials.Length );
            }

            //
            // Free the credential record itself.
            //

            LsapFreePrivateHeap( GoodByeCredentials );

            return STATUS_SUCCESS;
        }

        NextCredentials = &(*NextCredentials)->NextCredentials;

    }

    AuUnlockCreds();

    LsapReleaseLogonSession( LogonSession );

    //
    // Nothing matched
    //

    return STATUS_UNSUCCESSFUL;

}


PLSAP_PACKAGE_CREDENTIALS
LsapGetPackageCredentials(
    IN PLSAP_LOGON_SESSION LogonSession,
    IN ULONG PackageId,
    IN BOOLEAN CreateIfNecessary
    )


/*++

Routine Description:

    This service returns a pointer to a specified package's credential
    record.  If no such record exists, one will optionally be created.

    It is assumed that either the LogonSession record is not currently
    in the logon session record list, or, if it is, that the AuLock
    is currently held.

Arguments:

    LogonSession - Pointer to a logon session record within which to
        work.

    PackageId - The authentication package ID to look for.

    CreateIfNecessary - A boolean indicating whether or not the package
        record is to be created if one does not already exist.  TRUE
        indicates the package is to be created if necessary, FALSE indicates
        the record should not be created.


Return Status:

    non-NULL - A pointer to the specified package record.

    NULL - The specified package record does not exist (and one was not
        created automatically).

--*/

{

    PLSAP_PACKAGE_CREDENTIALS *NextPackage, TargetPackage;


    //
    // See if the session exists
    //

    NextPackage = &LogonSession->Packages;

    while ( (*NextPackage) != NULL) {
        if ( (*NextPackage)->PackageId == PackageId ) {

            //
            // Found it
            //

            TargetPackage = (*NextPackage);


            return TargetPackage;

        }

        //
        // Move on to next package.
        //

        NextPackage = &(*NextPackage)->NextPackage;

    }

    //
    // No such package exists yet.
    // Create one if necessary.

    if ( !CreateIfNecessary ) {
        return NULL;
    }

    TargetPackage = LsapAllocateLsaHeap( (ULONG)sizeof(LSAP_PACKAGE_CREDENTIALS) );

    if ( TargetPackage )
    {
        TargetPackage->PackageId = PackageId;
        TargetPackage->Credentials = NULL;
        TargetPackage->NextPackage = LogonSession->Packages;
        LogonSession->Packages = TargetPackage;
    }

    return TargetPackage;

}

VOID
LsapFreePackageCredentialList(
    IN PLSAP_PACKAGE_CREDENTIALS PackageCredentialList
    )

/*++

Routine Description:

    This service frees a list of packge credential records.  This service
    is not expected to be exposed to authentication packages.

    This service expects not to have to acquire the AuLock.  This may be
    because it is already held, or because the credentials being freed
    are no longer accessible via the global variables.

Arguments:

    PackageCredentialList - Is a pointer to a list of LSA_PACKAGE_CREDENTIALS
        data structures.


Return Status:

    None.

--*/

{

    PLSAP_PACKAGE_CREDENTIALS NextPackage, GoodByePackage;

    //
    // Get rid of each PACKAGE_CREDENTIAL record.
    //

    NextPackage = PackageCredentialList;
    while ( NextPackage != NULL ) {

        //
        // Save a pointer to the next package
        //

        GoodByePackage = NextPackage;
        NextPackage = GoodByePackage->NextPackage;


        LsapFreeCredentialList( GoodByePackage->Credentials );


        //
        // Free the package record itself.
        //

        LsapFreeLsaHeap( GoodByePackage );


    }


    return;

}


VOID
LsapFreeCredentialList(
    IN PLSAP_CREDENTIALS CredentialList
    )

/*++

Routine Description:

    This service frees a list of credential records.  This service is not
    expected to be exposed to authentication packages.

    This service expects not to have to acquire the AuLock.  This may be
    because it is already held, or because the credentials being freed
    are no longer accessible via the global variables.

Arguments:

    CredentialList - Is a pointer to a list of LSA_CREDENTIALS data
        structures.


Return Status:


--*/

{

    PLSAP_CREDENTIALS NextCredentials, GoodByeCredentials;

    //
    // Get rid of each PACKAGE_CREDENTIAL record.
    //

    NextCredentials = CredentialList;
    while ( NextCredentials != NULL ) {

        //
        // Save a pointer to the next credential
        //

        GoodByeCredentials = NextCredentials;
        NextCredentials = GoodByeCredentials->NextCredentials;

        //
        // Zero the contents of this credential record.
        //

        if( GoodByeCredentials->PrimaryKey.Buffer != NULL )
        {
            ZeroMemory( GoodByeCredentials->PrimaryKey.Buffer,
                        GoodByeCredentials->PrimaryKey.Length );
        }

        if( GoodByeCredentials->Credentials.Buffer != NULL )
        {
            ZeroMemory( GoodByeCredentials->Credentials.Buffer,
                        GoodByeCredentials->Credentials.Length );
        }

        //
        // Free the credential record itself.
        //

        LsapFreePrivateHeap( GoodByeCredentials );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\credapi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    credapi.c

Abstract:

    Credential Manager RPC API Interfaces

Author:

    Cliff Van Dyke      (CliffV)

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <credp.hxx>
#include <windns.h>

NTSTATUS
CrediGetLogonId(
    OUT PLUID LogonId
    )
/*++

Routine Description:

    This routine impersonates the client then gets the logon id from the impersonated token.
    This routine also checks to ensure the user sid isn't restricted.

    On successful return, we are still imperonating the client.  The caller should call
    RpcRevertToSelf();

Arguments:

    LogonId - Returns the logon ID.

Return Value:

    Status of the operation.

--*/

{
    NTSTATUS Status;

    //
    // Impersonate
    //

    Status = I_RpcMapWin32Status( RpcImpersonateClient( 0 ) );

    if ( NT_SUCCESS(Status) ) {
        HANDLE ClientToken;

        //
        // Open the token
        //
        Status = NtOpenThreadToken( NtCurrentThread(),
                                    TOKEN_QUERY,
                                    TRUE,
                                    &ClientToken );

        if ( NT_SUCCESS( Status ) ) {
            TOKEN_STATISTICS TokenStats;
            ULONG ReturnedSize;

            //
            // Get the LogonId
            //

            Status = NtQueryInformationToken( ClientToken,
                                              TokenStatistics,
                                              &TokenStats,
                                              sizeof( TokenStats ),
                                              &ReturnedSize );

            if ( NT_SUCCESS( Status ) ) {

                //
                // Save the logon id
                //

                *LogonId = TokenStats.AuthenticationId;


                //
                // Get the user sid
                //

                Status = NtQueryInformationToken (
                             ClientToken,
                             TokenUser,
                             NULL,
                             0,
                             &ReturnedSize );

                if ( Status == STATUS_BUFFER_TOO_SMALL ) {
                    PTOKEN_USER UserSid;

                    UserSid = LsapAllocateLsaHeap( ReturnedSize );

                    if ( UserSid == NULL ) {
                        Status = STATUS_NO_MEMORY;
                    } else {

                        Status = NtQueryInformationToken (
                                     ClientToken,
                                     TokenUser,
                                     UserSid,
                                     ReturnedSize,
                                     &ReturnedSize );


                        if ( NT_SUCCESS( Status )) {
                            BOOL IsMember;

                            //
                            // Ensure the user sid isn't restricted.
                            //

                            if ( !CheckTokenMembership( ClientToken,
                                                        UserSid->User.Sid,
                                                        &IsMember ) ) {

                                Status = I_RpcMapWin32Status( GetLastError() );

                            } else {

                                //
                                // If not, fail
                                //

                                if ( !IsMember ) {
                                    Status = STATUS_ACCESS_DENIED;
                                } else {

                                    BOOLEAN IsNetworkClient;

                                    //
                                    // Don't allow the caller to have come in from the network.
                                    //

                                    Status = LsapDbIsImpersonatedClientNetworkClient( &IsNetworkClient );

                                    if ( NT_SUCCESS(Status ) ) {
                                        if ( IsNetworkClient ) {
                                            Status = STATUS_ACCESS_DENIED;
                                        } else {
                                            Status = STATUS_SUCCESS;
                                        }
                                    }
                                }
                            }
                        }

                        LsapFreeLsaHeap( UserSid );
                    }

                }
            }

            NtClose( ClientToken );

        }

        if ( !NT_SUCCESS(Status) ) {
            RpcRevertToSelf();
        }

    }

    return Status;
}

NTSTATUS
CredrWrite(
    IN LPWSTR ServerName,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWrite API creates a new credential or modifies an existing
    credential in the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    The CredWrite API creates a credential if none already exists by the
    specified TargetName.  If the specified TargetName already exists, the
    specified credential replaces the existing one.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_PRESERVE_CREDENTIAL_BLOB: The credential blob should be preserved from the
            already existing credential with the same credential name and credential type.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.
            Returned only if CRED_PRESERVE_CREDENTIAL_BLOB was specified.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediWrite( &LogonId,
                         0,
                         Credential,
                         Flags );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrRead (
    IN LPWSTR ServerName,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags,
    OUT PENCRYPTED_CREDENTIALW *Credential
    )

/*++

Routine Description:

    The CredRead API reads a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetName - Specifies the name of the credential to read.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Credential - Returns a pointer to the credential.  The returned buffer
        must be freed by calling CredFree.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediRead( &LogonId,
                        CREDP_FLAGS_USE_MIDL_HEAP,  // Use MIDL_user_allocate
                        TargetName,
                        Type,
                        Flags,
                        Credential );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrEnumerate (
    IN LPWSTR ServerName,
    IN LPWSTR Filter,
    IN ULONG Flags,
    OUT PCREDENTIAL_ARRAY CredentialArray
    )

/*++

Routine Description:

    The CredEnumerate API enumerates the credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    Filter - Specifies a filter for the returned credentials.  Only credentials
        with a TargetName matching the filter will be returned.  The filter specifies
        a name prefix followed by an asterisk.  For instance, the filter "FRED*" will
        return all credentials with a TargetName beginning with the string "FRED".

        If NULL is specified, all credentials will be returned.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The returned buffer must be freed by calling CredFree.

Return Values:

    On success, TRUE is returned.  On failure, FALSE is returned.
    GetLastError() may be called to get a more specific status code.
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credentials matching the specified Filter.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;

    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Validate the credential array.
    //

    if ( CredentialArray == NULL ||
         CredentialArray->CredentialCount != 0 ||
         CredentialArray->Credentials != NULL ) {

         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediEnumerate( &LogonId,
                             0,
                             Filter,
                             Flags,
                             &CredentialArray->CredentialCount,
                             &CredentialArray->Credentials );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrWriteDomainCredentials (
    IN LPWSTR ServerName,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN PENCRYPTED_CREDENTIALW Credential,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredWriteDomainCredentials API writes a new domain
    credential to the user's credential set.  The new credential is
    associated with the logon session of the current token.  The token
    must not have the user's SID disabled.

    CredWriteDomainCredentials differs from CredWrite in that it handles
    the idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetInfo - Specifies the target information identifying the target server.

    Credential - Specifies the credential to be written.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

        STATUS_INVALID_PARAMETER - Certain fields may not be changed in an
            existing credential.  If such a field does not match the value
            specified in the existing credential, this error is returned.

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified
            or the credential specified did not have the Type field set to
            CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediWriteDomainCredentials( &LogonId,
                                          0,
                                          TargetInfo,
                                          Credential,
                                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}



NTSTATUS
CredrReadDomainCredentials (
    IN LPWSTR ServerName,
    IN PCREDENTIAL_TARGET_INFORMATIONW TargetInfo,
    IN ULONG Flags,
    OUT PCREDENTIAL_ARRAY CredentialArray
    )

/*++

Routine Description:

    The CredReadDomainCredentials API reads the domain credentials from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

    CredReadDomainCredentials differs from CredRead in that it handles the
    idiosyncrasies of domain (CRED_TYPE_DOMAIN_PASSWORD or CRED_TYPE_DOMAIN_CERTIFICATE)
    credentials.  Domain credentials contain more than one target field.

    At least one of the naming parameters must be specified: NetbiosServerName,
    DnsServerName, NetbiosDomainName, DnsDomainName or DnsForestName. This API returns
    the most specific credentials that match the naming parameters.  That is, if there
    is a credential that matches the target server name and a credential that matches
    the target domain name, only the server specific credential is returned.  This is
    the credential that would be used.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetInfo - Specifies the target information identifying the target ser

    Flags - Specifies flags to control the operation of the API.
        The following flags are defined:

        CRED_CACHE_TARGET_INFORMATION: The TargetInfo should be cached for a subsequent read via
            CredGetTargetInfo.

    Count - Returns a count of the number of credentials returned in Credentials.

    Credentials - Returns a pointer to an array of pointers to credentials.
        The most specific existing credential matching the TargetInfo is returned.
        If there is both a CRED_TYPE_DOMAIN_PASSWORD and CRED_TYPE_DOMAIN_CERTIFICATE
        credential, both are returned. If a connection were to be made to the named
        target, this most-specific credential would be used.

        The returned buffer must be freed by calling CredFree.

Return Values:

    The following status codes may be returned:

        STATUS_INVALID_PARAMETER - None of the naming parameters were specified.

        STATUS_NOT_FOUND - There are no credentials matching the specified naming parameters.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;
    ULONG CredFlags = 0;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Validate the credential array.
    //

    if ( CredentialArray == NULL ||
         CredentialArray->CredentialCount != 0 ||
         CredentialArray->Credentials != NULL ) {

         Status = STATUS_INVALID_PARAMETER;
         goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Handle caching target info.
    //
    // The Credi* routine caches by default and has to be asked to not cache.
    // Whereas the public API doesn't cache by default.
    //

    if ( Flags & CRED_CACHE_TARGET_INFORMATION ) {
        Flags &= ~CRED_CACHE_TARGET_INFORMATION;
    } else {
        CredFlags |= CREDP_FLAGS_DONT_CACHE_TI;
    }

    //
    // Call the internal routine
    //

    Status = CrediReadDomainCredentials(
                             &LogonId,
                             CredFlags,
                             TargetInfo,
                             Flags,
                             &CredentialArray->CredentialCount,
                             &CredentialArray->Credentials );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrDelete (
    IN LPWSTR ServerName,
    IN LPWSTR TargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredDelete API deletes a credential from the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetName - Specifies the name of the credential to delete.

    Type - Specifies the Type of the credential to find.
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:

    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediDelete( &LogonId,
                          0,
                          TargetName,
                          Type,
                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}

NTSTATUS
CredrRename (
    IN LPWSTR ServerName,
    IN LPWSTR OldTargetName,
    IN LPWSTR NewTargetName,
    IN ULONG Type,
    IN ULONG Flags
    )

/*++

Routine Description:

    The CredRename API renames a credential in the user's credential set.
    The credential set used is the one associated with the logon session
    of the current token.  The token must not have the user's SID disabled.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    OldTargetName - Specifies the current name of the credential to rename.

    NewTargetName - Specifies the new name of the credential.

    Type - Specifies the Type of the credential to rename
        One of the CRED_TYPE_* values should be specified.

    Flags - Specifies flags to control the operation of the API.
        Reserved.  Must be zero.

Return Values:
    The following status codes may be returned:

        STATUS_NOT_FOUND - There is no credential with the specified OldTargetName.

        STATUS_OBJECT_NAME_COLLISION - There is already a credential named NewTargetName.

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediRename( &LogonId,
                          OldTargetName,
                          NewTargetName,
                          Type,
                          Flags );
    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrGetTargetInfo (
    IN LPWSTR ServerName,
    IN LPWSTR TargetServerName,
    IN ULONG Flags,
    OUT PCREDENTIAL_TARGET_INFORMATIONW *TargetInfo
    )

/*++

Routine Description:

    The CredGetTargetInfo API gets all of the known target name information
    for the named target machine.  This executed locally
    and does not need any particular privilege.  The information returned is expected
    to be passed to the CredReadDomainCredentials and CredWriteDomainCredentials APIs.
    The information should not be used for any other purpose.

    Authentication packages compute TargetInfo when attempting to authenticate to
    ServerName.  The authentication packages cache this target information to make it
    available to CredGetTargetInfo.  Therefore, the target information will only be
    available if we've recently attempted to authenticate to ServerName.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    TargetServerName - This parameter specifies the name of the machine to get the information
        for.

    Flags - Specifies flags to control the operation of the API.

        CRED_ALLOW_NAME_RESOLUTION - Specifies that if no target info can be found for
            TargetName, then name resolution should be done on TargetName to convert it
            to other forms.  If target info exists for any of those other forms, that
            target info is returned.  Currently only DNS name resolution is done.

            This bit is useful if the application doesn't call the authentication package
            directly.  The application might pass the TargetName to another layer of software
            to authenticate to the server.  That layer of software might resolve the name and
            pass the resolved name to the authentication package.  As such, there will be no
            target info for the original TargetName.

    TargetInfo - Returns a pointer to the target information.
        At least one of the returned fields of TargetInfo will be non-NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_MEMORY - There isn't enough memory to complete the operation.

        STATUS_NOT_FOUND - There is no credential with the specified TargetName.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        return STATUS_INVALID_COMPUTER_NAME;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediGetTargetInfo( &LogonId, TargetServerName, Flags, TargetInfo );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrGetSessionTypes (
    IN LPWSTR ServerName,
    IN DWORD MaximumPersistCount,
    OUT LPDWORD MaximumPersist
    )

/*++

Routine Description:

    CredGetSessionTypes returns the maximum persistence supported by the current logon
    session.

    For whistler, CRED_PERSIST_LOCAL_MACHINE and CRED_PERSIST_ENTERPRISE credentials can not
    be stored for sessions where the profile is not loaded.  If future releases, credentials
    might not be associated with the user's profile.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

    MaximumPersistCount - Specifies the number of elements in the MaximumPersist array.
        The caller should specify CRED_TYPE_MAXIMUM for this parameter.

    MaximumPersist - Returns the maximum persistance supported by the current logon session for
        each credential type.  Index into the array with one of the CRED_TYPE_* defines.
        Returns CRED_PERSIST_NONE if no credential of this type can be stored.
        Returns CRED_PERSIST_SESSION if only session specific credential may be stored.
        Returns CRED_PERSIST_LOCAL_MACHINE if session specific and machine specific credentials
            may be stored.
        Returns CRED_PERSIST_ENTERPRISE if any credential may be stored.

Return Values:

    STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/

{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediGetSessionTypes( &LogonId, MaximumPersistCount, MaximumPersist );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}


NTSTATUS
CredrProfileLoaded (
    IN LPWSTR ServerName
    )

/*++

Routine Description:

    The CredProfileLoaded API is a private API used by LoadUserProfile to notify the
    credential manager that the profile for the current user has been loaded.

    The caller must be impersonating the logged on user.

Arguments:

    ServerName - Name of server this APi was remoted to.
        Must be NULL.

Return Values:

    The following status codes may be returned:

        STATUS_NO_SUCH_LOGON_SESSION - The logon session does not exist or
            there is no credential set associated with this logon session.
            Network logon sessions do not have an associated credential set.

--*/
{
    NTSTATUS Status;
    LUID LogonId;

    //
    // Ensure this is a local call.
    //

    if ( ServerName != NULL ) {
        Status = STATUS_INVALID_COMPUTER_NAME;
        goto Cleanup;
    }

    //
    // Get the LogonId for the caller.
    //

    Status = CrediGetLogonId( &LogonId );

    if ( !NT_SUCCESS(Status) ) {

        //
        // This is a notification API.  Don't bother the caller with trivia.
        //  This might be a network token.  Network tokens don't have credentials.
        //

        if ( Status == STATUS_ACCESS_DENIED ) {
            Status = STATUS_SUCCESS;
        }
        goto Cleanup;
    }

    //
    // Call the internal routine
    //

    Status = CrediProfileLoaded( &LogonId );

    RpcRevertToSelf();

    //
    // Cleanup
    //
Cleanup:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\aupckg.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aupckg.c

Abstract:

    This module provides code that initializes authentication packages.

    It also provides the dispatch code for LsaLookupPackage() and
    LsaCallPackage().

Author:

    Jim Kelly (JimK) 27-February-1991

Revision History:

--*/

#include "lsapch2.h"





NTSTATUS
LsapAuApiDispatchCallPackage(
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This function is the dispatch routine for LsaCallPackage().

Arguments:

    Request - Represents the client's LPC request message and context.
        The request message contains a LSAP_CALL_PACKAGE_ARGS message
        block.


Return Value:

    In addition to the status values that an authentication package
    might return, this routine will return the following:

    STATUS_QUOTA_EXCEEDED -  This error indicates that the call could
        not be completed because the client does not have sufficient
        quota to allocate the return buffer.

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.



--*/

{

    NTSTATUS Status;
    PLSAP_CALL_PACKAGE_ARGS Arguments;
    PVOID LocalProtocolSubmitBuffer;    // Receives a copy of protocol submit buffer
    PLSAP_SECURITY_PACKAGE AuthPackage;
    SECPKG_CLIENT_INFO ClientInfo;

    Status = LsapGetClientInfo(
                &ClientInfo
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    Arguments = &ClientRequest->Request->Arguments.CallPackage;


    //
    // Get the address of the package to call
    //


    AuthPackage = SpmpValidRequest(
                    Arguments->AuthenticationPackage,
                    SP_ORDINAL_CALLPACKAGE
                    );

    if ( AuthPackage == NULL ) {
        return STATUS_NO_SUCH_PACKAGE;
    }



    //
    // Fetch a copy of the profile buffer from the client's
    // address space.
    //

    if (Arguments->SubmitBufferLength != 0) {

        LocalProtocolSubmitBuffer =
            LsapAllocateLsaHeap( Arguments->SubmitBufferLength );


        if (LocalProtocolSubmitBuffer == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            Status = LsapCopyFromClientBuffer (
                         (PLSA_CLIENT_REQUEST)ClientRequest,
                         Arguments->SubmitBufferLength,
                         LocalProtocolSubmitBuffer,
                         Arguments->ProtocolSubmitBuffer
                         );

            if ( !NT_SUCCESS(Status) ) {
                LsapFreeLsaHeap( LocalProtocolSubmitBuffer );
                DbgPrint("LSA/CallPackage(): Failed to retrieve submit buffer %lx\n",Status);
                return Status;
            }
        }

    } else {
        LocalProtocolSubmitBuffer = NULL;
    }


    if (NT_SUCCESS(Status)) {
        
        SetCurrentPackageId(AuthPackage->dwPackageID);

        StartCallToPackage(AuthPackage);

        DebugLog(( DEB_TRACE, "CallPackage(%ws, %d)\n",
                  AuthPackage->Name.Buffer,
                  *(DWORD *)LocalProtocolSubmitBuffer ));
        __try {

            //
            // Now call the package. For trusted clients, call the normal
            // CallPackage API.  For untrusted clients, use the untrusted version.
            //

            if (ClientInfo.HasTcbPrivilege) {
                Status = (AuthPackage->FunctionTable.CallPackage)(
                                          (PLSA_CLIENT_REQUEST)ClientRequest,
                                          LocalProtocolSubmitBuffer,
                                          Arguments->ProtocolSubmitBuffer,
                                          Arguments->SubmitBufferLength,
                                          &Arguments->ProtocolReturnBuffer,
                                          &Arguments->ReturnBufferLength,
                                          &Arguments->ProtocolStatus
                                          );

            } else if (AuthPackage->FunctionTable.CallPackageUntrusted != NULL) {
                Status = (AuthPackage->FunctionTable.CallPackageUntrusted)(
                                          (PLSA_CLIENT_REQUEST)ClientRequest,
                                          LocalProtocolSubmitBuffer,
                                          Arguments->ProtocolSubmitBuffer,
                                          Arguments->SubmitBufferLength,
                                          &Arguments->ProtocolReturnBuffer,
                                          &Arguments->ReturnBufferLength,
                                          &Arguments->ProtocolStatus
                                          );

            } else {
                Status = STATUS_NOT_SUPPORTED;
            }
        }
        __except(SP_EXCEPTION)
        {
            Status = GetExceptionCode();
            Status = SPException(Status, AuthPackage->dwPackageID);

        }
        EndCallToPackage(AuthPackage);

    }

    //
    // Free the local copy of the protocol submit buffer
    //

    if (LocalProtocolSubmitBuffer != NULL) {
        LsapFreeLsaHeap( LocalProtocolSubmitBuffer );
    }


    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\eserver.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    eserver.c

Abstract:

    EFS RPC server code.

Author:

    Robert Gu       (RobertG)    Aug, 1997

Environment:

Revision History:

--*/

#define UNICODE

#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <lsapch2.h>
#include <efsrpc.h>
#include <efsstruc.h>
#include <lm.h>
#include "efssrv.hxx"
#include <rpcasync.h>

extern BOOLEAN EfsPersonalVer;
extern BOOLEAN EfsDisabled;

long GetLocalFileName(
    LPCWSTR FileName,
    LPWSTR *LocalFileName,
    WORD   *Flag
    );

BOOL EfsShareDecline(
    LPCWSTR FileName,
    BOOL    VerifyShareAccess,
    DWORD   dwDesiredAccess
    )
/*++

Routine Description:

    Check to see if the FileName is a UNC name and if the user could access the share.
    
Arguments:

    FileName -- File UNC name.
    
    VerifyShareAccess -- if we need to verify the access.
    
    dwDesiredAccess -- Desired access.


Return Value:

    TRUE if the user can't access the file.

--*/
{
    BOOL b = TRUE;
    DWORD FileNameLength = wcslen(FileName);

    if (FileNameLength >= 3) {
        if ((FileName[0] == L'\\') && (FileName[1] == L'\\' )) {

            //
            //  Check if somebody play the trick \\?\
            //

            if ((FileName[2] != L'?')) {

                //
                //  This is a UNC name. If bad name passed in , we will catch later.
                //

                b = FALSE;

            } else {

                SetLastError(ERROR_INVALID_PARAMETER);

            }
        } else {

            SetLastError(ERROR_INVALID_PARAMETER);

        }
    }

    if (!b && VerifyShareAccess) {

        LPWSTR  NetFileName = NULL;
        HANDLE  hFile;

        if ( FileNameLength >= MAX_PATH ) {

            //
            // We need \\?\UNC\server\share\dir\file format to open the file.
            //

            NetFileName = LsapAllocateLsaHeap( (FileNameLength + 8) * sizeof (WCHAR) );
            if (!NetFileName) {
                return TRUE;
            }

            wcscpy(NetFileName, L"\\\\?\\UNC");
            wcscat(NetFileName, &FileName[1]);

        } else {

            NetFileName = (LPWSTR) FileName;

        }

        //
        //  Testing for access rights
        //

        hFile = CreateFile(
                   NetFileName,
                   dwDesiredAccess,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   FILE_FLAG_BACKUP_SEMANTICS, // In case this is a directory
                   NULL
                   );

        if (hFile != INVALID_HANDLE_VALUE) {
            
            
            CloseHandle( hFile );

        } else {

            b = TRUE;

        }

        if (NetFileName != FileName) {
            LsapFreeLsaHeap( NetFileName );
        }

    }

    return b;

}

BOOL EfsCheckForNetSession(
    )
/*++

Routine Description:

    Check to see if the session is from network
        
Arguments:

Return Value:

    TRUE if the session is network session.

--*/
{

    NTSTATUS Status;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    BOOL  b = FALSE;
    BYTE  PefBuffer[1024];

    Status = NtOpenThreadToken(
                 NtCurrentThread(),
                 TOKEN_QUERY,
                 TRUE,                    // OpenAsSelf
                 &TokenHandle
                 );

    if (NT_SUCCESS( Status )) {

        Status = NtQueryInformationToken (
                     TokenHandle,
                     TokenGroups,
                     PefBuffer,
                     sizeof (PefBuffer),
                     &ReturnLength
                     );

        if (NT_SUCCESS( Status ) || (Status == STATUS_BUFFER_TOO_SMALL)) {

            PTOKEN_GROUPS pGroups = NULL;
            PTOKEN_GROUPS pAllocGroups = NULL;

            if ( NT_SUCCESS( Status ) ) {

                pGroups = (PTOKEN_GROUPS) PefBuffer;

            } else {

                pAllocGroups = (PTOKEN_GROUPS)LsapAllocateLsaHeap( ReturnLength );

                if (pAllocGroups) {

                    Status = NtQueryInformationToken (
                                 TokenHandle,
                                 TokenGroups,
                                 pAllocGroups,
                                 ReturnLength,
                                 &ReturnLength
                                 );
    
                    if ( NT_SUCCESS( Status )) {
    
                       pGroups = pAllocGroups;
    
                    }

                }


            }


            if (pGroups) {

                //
                // Search the network SID. Looks like this SID tends to appear at the
                // end of the list. We search from back to the first.
                //

                int SidIndex;

                for ( SidIndex = (int)(pGroups->GroupCount - 1); SidIndex >= 0; SidIndex--) {
                    if (RtlEqualSid(LsapNetworkSid, pGroups->Groups[SidIndex].Sid)) {
                        b = TRUE;
                        break;
                    }
                }

            } else {

                //
                // Playing safe here. Any failure in this routine will assume net session.
                //
        
                b = TRUE;

            }

            if (pAllocGroups) {
                LsapFreeLsaHeap( pAllocGroups );
            }

        } else {

            //
            // Playing safe here. Any failure in this routine will assume net session.
            //
    
            b = TRUE;

        }

        NtClose( TokenHandle );

    } else {

        //
        // Playing safe here. Any failure in this routine will assume net session.
        //

        b = TRUE;

    }

    return( b );
}

long EfsRpcOpenFileRaw(
    handle_t binding_h,
    PPEXIMPORT_CONTEXT_HANDLE pphContext,
    wchar_t __RPC_FAR *FileName,
    long Flags
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsOpenFileRaw()

Arguments:

    binding_h -- Binding handle.

    pphContext -- RPC context handle.

    FileName -- Target file name.

    Flags -- Flags of the open request.

Return Value:

    Result of the operation.

--*/
{
    DWORD   hResult;
    LPWSTR LocalFileName;
    BOOL    NetSession = TRUE;
    WORD    WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (pphContext == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        *pphContext = (PEXIMPORT_CONTEXT_HANDLE) NULL;
        DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult =  RpcImpersonateClient( NULL );

    if (NetSession = EfsCheckForNetSession()) {

        if (EfsShareDecline(FileName, FALSE, 0 )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        *pphContext = (PEXIMPORT_CONTEXT_HANDLE) NULL;
        LsapFreeLsaHeap( LocalFileName );
        DebugLog((DEB_ERROR, "EfsRpcOpenFileRaw: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    hResult = EfsOpenFileRaw(
                        FileName,
                        LocalFileName,
                        NetSession,
                        Flags,
                        pphContext
                        );

    RpcRevertToSelf();

    LsapFreeLsaHeap( LocalFileName );
    return hResult;
}

void EfsRpcCloseRaw(
    PPEXIMPORT_CONTEXT_HANDLE pphContext
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsCloseRaw()

Arguments:

    pphContext -- RPC context handle.

Return Value:

    None.

--*/
{
    if ( *pphContext &&
          (((PEXPORT_CONTEXT) *pphContext)->ContextID == EFS_CONTEXT_ID)){
        EfsCloseFileRaw( *pphContext );
        *pphContext = NULL;
    }
}

void __RPC_USER
PEXIMPORT_CONTEXT_HANDLE_rundown(
    PEXIMPORT_CONTEXT_HANDLE phContext
    )
/*++

Routine Description:

    Standard RPC Context Run Down Routine

Arguments:

    phContext -- RPC context handle.

Return Value:

    None.

--*/
{
    EfsCloseFileRaw( phContext );
}

long EfsRpcReadFileRaw(
    PEXIMPORT_CONTEXT_HANDLE phContext,
    EFS_EXIM_PIPE __RPC_FAR *EfsOutPipe
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsReadFileRaw

Arguments:

    phContext -- Context handle.
    EfsOutPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    return (EfsReadFileRaw(
                        phContext,
                        EfsOutPipe
                        )
                );
}

long EfsRpcWriteFileRaw(
    PEXIMPORT_CONTEXT_HANDLE phContext,
    EFS_EXIM_PIPE __RPC_FAR *EfsInPipe
    )
/*++

Routine Description:

    RPC Stub code for EFS Server EfsWriteFileRaw

Arguments:

    phContext -- Context handle.
    EfsInPipe -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    long hResult;

    hResult =  RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcWriteFileRaw: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    hResult = EfsWriteFileRaw(
                        phContext,
                        EfsInPipe
                        );

    RpcRevertToSelf();

    return hResult;

}

DWORD
EFSSendPipeData(
    char    *DataBuf,
    ULONG   DataLength,
    PVOID   Context
    )
/*++

Routine Description:

    This is a wrapper routine for calling RPC pipe. The purposes of this routine
    and EfsRpcReadFileRaw() are to isolate efsapi.c from RPC details,
    and implemtation details from eserver.c.

Arguments:

    DataBuf -- Data buffer.
    DataLength -- The length of data in bytes to be sent out to the client.
    Context -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    EFS_EXIM_PIPE __RPC_FAR *EfsOutPipe;
    DWORD   HResult = NO_ERROR;

    ASSERT( Context );

    EfsOutPipe = ( EFS_EXIM_PIPE __RPC_FAR * )Context;

    RpcTryExcept {

        EfsOutPipe->push(
            EfsOutPipe->state,
            DataBuf,
            DataLength
            );

    }  RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
            HResult = RpcExceptionCode();
    } RpcEndExcept;

    return (HResult);
}

DWORD
EFSReceivePipeData(
    char    *DataBuf,
    ULONG*   DataLength,
    PVOID   Context
    )
/*++

Routine Description:

    This is a wrapper routine for calling RPC pipe. The purposes of this routine
    and EfsRpcWriteFileRaw() are to isolate efsapi.c from RPC details,
    and implemtation details from eserver.c.

Arguments:

    DataBuf -- Data buffer.
    DataLength -- The length of data in bytes to be got from the client.
    Context -- Pipe handle.

Return Value:

    The result of operation.

--*/
{
    EFS_EXIM_PIPE __RPC_FAR *EfsInPipe;
    DWORD   HResult = NO_ERROR;
    char    *WorkBuf;
    ULONG   MoreDataBytes;
    ULONG   BytesGot = 0;
    BOOLEAN GetMoreData = TRUE;


    ASSERT( Context );

    EfsInPipe = ( EFS_EXIM_PIPE __RPC_FAR * )Context;
    WorkBuf = DataBuf;
    MoreDataBytes = *DataLength;

    while ( GetMoreData ) {
        BytesGot = 0;

        RpcTryExcept {

            EfsInPipe->pull(
                EfsInPipe->state,
                WorkBuf,
                MoreDataBytes,
                &BytesGot
                );

        }  RpcExcept( I_RpcExceptionFilter( RpcExceptionCode()) ) {
                HResult = RpcExceptionCode();
                GetMoreData = FALSE;
        } RpcEndExcept;
        if ( BytesGot && (BytesGot < MoreDataBytes)){
            WorkBuf += BytesGot;
            MoreDataBytes -= BytesGot;
        } else {
            GetMoreData = FALSE;
        }
    }

    if (HResult == NO_ERROR){
        *DataLength =  (ULONG)(WorkBuf - DataBuf) + BytesGot;
    }

    return (HResult);
}

long EfsRpcEncryptFileSrv(
    handle_t binding_h,
    wchar_t __RPC_FAR *FileName
    )
/*++

Routine Description:

    RPC Stub code for EFS Server Encryption

Arguments:

    binding_h -- RPC binding handle.
    FileName -- Target name.

Return Value:

    The result of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DestFileName;
    DWORD hResult;
    UNICODE_STRING  RootPath;
    HANDLE LogFile;
    LPWSTR LocalFileName;
    HANDLE hToken;
    HANDLE hProfile;
    EFS_USER_INFO EfsUserInfo;
    DWORD FileAttributes;
    BOOL b;
    WORD WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(FileName, TRUE, FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()));
            return GetLastError();

        }
    }
    if (hResult == RPC_S_OK) {
        if (WebDavPath == WEBDAVPATH) {

            //
            // This is a WEB DAV path. We will treat it specially.
            //

            FileAttributes = GetFileAttributes( LocalFileName );
            if (FileAttributes == -1) {

                DWORD rc = GetLastError();

                LsapFreeLsaHeap( LocalFileName );
                RpcRevertToSelf();
                DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetFileAttributes failed on WEBDAV file, Error = (%x)\n" ,GetLastError()));
                return rc;
            }

            //
            // Mapping the attributes and fake the call of FileEncryptionStatus. 
            //

            if (FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) {
                hResult = FILE_IS_ENCRYPTED;
            } else if (FileAttributes & FILE_ATTRIBUTE_READONLY) {
                hResult = FILE_READ_ONLY;
            } else {
                hResult = FILE_UNKNOWN;
            }

            b = TRUE;

        } else {
            b = FileEncryptionStatus(LocalFileName, &hResult);
        }
    } else {
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    RpcRevertToSelf();

    if ( b ){
        if ( (hResult != FILE_ENCRYPTABLE) && (hResult != FILE_UNKNOWN)){

            //
            // No encryption is allowed or file is already encrypted
            //

            if ( hResult == FILE_IS_ENCRYPTED ){

                HANDLE hSourceFile;

                hResult = RpcImpersonateClient( NULL );
                if (hResult == RPC_S_OK) {

                    FileAttributes = GetFileAttributes( LocalFileName );
    
                    if (FileAttributes != -1) {
    
                        if ( FileAttributes & FILE_ATTRIBUTE_DIRECTORY ){
                            hResult = ERROR_SUCCESS;
                        } else {
    
                            hSourceFile =  CreateFile(
                                                LocalFileName,
                                                FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                                                0,
                                                NULL,
                                                OPEN_EXISTING,
                                                FILE_FLAG_OPEN_REPARSE_POINT,
                                                NULL
                                                );

                            if (hSourceFile == INVALID_HANDLE_VALUE) {
                                hResult = GetLastError();
                            } else {

                                CloseHandle( hSourceFile );
                                hResult = ERROR_SUCCESS;

                            }
    

                        }
                    } else{
                        hResult = GetLastError();
                    }

                    RpcRevertToSelf();

                } 

            } else if (hResult == FILE_DIR_DISALLOWED ) {
                hResult = ERROR_DIR_EFS_DISALLOWED;
            } else if ( hResult == FILE_READ_ONLY ){
                hResult = ERROR_FILE_READ_ONLY;
            } else {
                hResult = ERROR_ACCESS_DENIED;
            }
            LsapFreeLsaHeap( LocalFileName );
            return hResult;

        }
    } else {

        //
        // Error occured checking the status
        //
        DebugLog((DEB_TRACE_EFS, "EfsRpcEncryptFileSrv: FileEncryptionStatus() failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    DestFileName.Length = sizeof (WCHAR) * wcslen(LocalFileName);
    DestFileName.MaximumLength = DestFileName.Length + sizeof (WCHAR);
    DestFileName.Buffer = LocalFileName;
    //
    //   Get the rootname
    //

    if (WebDavPath == WEBDAVPATH){

        //
        //  Do not support LOGFILE for WEB DAV
        //

        LogFile = NULL;
        RpcRevertToSelf();

    } else {
        hResult = GetVolumeRoot(&DestFileName, &RootPath);
        RpcRevertToSelf();
        if (hResult != ERROR_SUCCESS) {
            DebugLog((DEB_ERROR, "EfsRpcEncryptFileSrv: GetVolumeRoot failed, Error = (%x)\n" ,hResult  ));
            LsapFreeLsaHeap( LocalFileName );
            return( hResult );
        }
    
        Status = GetLogFile( &RootPath, &LogFile );
        LsapFreeLsaHeap( RootPath.Buffer );
    }

    if (NT_SUCCESS( Status )) {
        hResult = RpcImpersonateClient( NULL );

        if (hResult == RPC_S_OK) {

            if (EfspGetUserInfo( &EfsUserInfo )) {
                if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {
                    hResult = EncryptFileSrv( &EfsUserInfo, &DestFileName, LogFile );
                    EfspUnloadUserProfile( hToken, hProfile );
                } else {
                    hResult = GetLastError();
                }
                EfspFreeUserInfo( &EfsUserInfo );
            } else{
                hResult = GetLastError();
            }

        } else {
            if (LogFile) {
                MarkFileForDelete( LogFile );
            }
        }

        RpcRevertToSelf();
        if (LogFile) {
            CloseHandle(LogFile);
        }
    }
    if (!NT_SUCCESS( Status )){
        hResult = RtlNtStatusToDosError( Status );

        //
        // Make sure the error was mapped
        //

        if (hResult == ERROR_MR_MID_NOT_FOUND) {

            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_ENCRYPTION_FAILED\n" , Status  ));
            hResult = ERROR_ENCRYPTION_FAILED;
        }
    }

    LsapFreeLsaHeap( LocalFileName );
    return( hResult );
}

long EfsRpcDecryptFileSrv(
    handle_t binding_h,
    wchar_t __RPC_FAR *FileName,
    unsigned long OpenFlag
    )
/*++

Routine Description:

    RPC Stub code for EFS Server Decryption

Arguments:

    binding_h -- RPC binding handle.
    FileName -- Target name.
    OpenFlag -- Open for recovery or decryption

Return Value:

    The result of operation.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DestFileName;
    DWORD hResult;
    UNICODE_STRING  RootPath;
    HANDLE LogFile;
    LPWSTR LocalFileName;
    DWORD  FileAttributes;
    WORD   WebDavPath;

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    hResult = GetLocalFileName(
                        FileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }


    hResult =  RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(FileName, TRUE, FILE_READ_DATA | FILE_WRITE_DATA | FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }
    FileAttributes = GetFileAttributes( LocalFileName );
    if (-1 != FileAttributes){
        if ( !(FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) ){

            //
            // No decryption is needed.
            //

            hResult = ERROR_SUCCESS;
            RpcRevertToSelf();
            LsapFreeLsaHeap( LocalFileName );
            return hResult;

        }
    } else {

        //
        // Error occured checking the status
        //

        hResult = GetLastError();
        RpcRevertToSelf();
        DebugLog((DEB_TRACE_EFS, "EfsRpcDecryptFileSrv: GetFileAttributes() failed, Error = (%x)\n" , hResult));
        LsapFreeLsaHeap( LocalFileName );
        return hResult;
    }

    DestFileName.Length = sizeof (WCHAR) * wcslen(LocalFileName);
    DestFileName.MaximumLength = DestFileName.Length + sizeof (WCHAR);
    DestFileName.Buffer = LocalFileName;
    //
    //   Get the rootname
    //

    if (WebDavPath == WEBDAVPATH){

        //
        //  Do not support LOGFILE for WEB DAV
        //

        LogFile = NULL;
        RpcRevertToSelf();

    } else {

        hResult = GetVolumeRoot(&DestFileName, &RootPath);
        RpcRevertToSelf();
        if (hResult != ERROR_SUCCESS) {
            DebugLog((DEB_ERROR, "EfsRpcDecryptFileSrv: GetVolumeRoot failed, Error = (%x)\n" ,hResult  ));
            LsapFreeLsaHeap( LocalFileName );
            return( hResult );
        }
    
        Status = GetLogFile( &RootPath, &LogFile );
        LsapFreeLsaHeap( RootPath.Buffer );
    
    }


    if (NT_SUCCESS( Status )) {

        hResult =  RpcImpersonateClient( NULL );

        if (hResult == RPC_S_OK) {
            hResult = DecryptFileSrv( &DestFileName, LogFile, OpenFlag );
        } else {
            if (LogFile) {
                MarkFileForDelete( LogFile );
            }
        }

        RpcRevertToSelf();
        if (LogFile) {
            CloseHandle(LogFile);
        }
    }

    if (!NT_SUCCESS( Status )){
        hResult = RtlNtStatusToDosError( Status );

        //
        // Make sure the error was mapped
        //

        if (hResult == ERROR_MR_MID_NOT_FOUND) {

            DebugLog((DEB_WARN, "Unable to map NT Error (%x) to Win32 error, returning ERROR_DECRYPTION_FAILED\n" , Status  ));
            hResult = ERROR_DECRYPTION_FAILED;
        }
    }

    LsapFreeLsaHeap( LocalFileName );
    return( (long)hResult );
}

long GetLocalFileName(
    LPCWSTR FileName,
    LPWSTR *LocalFileName,
    WORD   *Flag
    )
/*++

Routine Description:

    Get the local file name from the UNC name

Arguments:

    FileName -- Target UNC file name.

    LocalFileName -- Local file name.
    
    Flag  -- Indicating special path, such as WEB DAV path.

Return Value:

    The result of operation.

--*/
{
    long RetCode = ERROR_SUCCESS;
    LPWSTR NetName;
    ULONG ii, jj;
    LPBYTE ShareInfo;
    DWORD  PathLen;
    DWORD  BufLen;
    BOOL   SharePath = FALSE;
    BOOL   LocalCheckLength = TRUE;

    *Flag = 0;
    if ( FileName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }
    PathLen = wcslen(FileName);
    BufLen = MAX_PATH >= PathLen + 1? MAX_PATH + 1: PathLen + 10;

    //
    // Check the WEB DAV path first
    //

    if (DAVHEADER == FileName[0]) {

        //
        // This is the WEB DAV path. Treat it as the local case.
        // Take whatever the user passed in.
        //

        *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( PathLen * sizeof (WCHAR));
        if (NULL == *LocalFileName) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *Flag = WEBDAVPATH;
        wcscpy(*LocalFileName, &FileName[1]);
        return ERROR_SUCCESS;

    }


    //
    //  See if the pass in name is \\server\share
    //

    if ((PathLen > 4) && (FileName[0] == L'\\') && (FileName[1] == L'\\')) {
        if ((FileName[2] != L'?') && FileName[2] != L'.') {
            SharePath = TRUE;
        } else {
            if (FileName[3] != L'\\') {
                SharePath = TRUE;
            } else {

                //
                //  path \\?\ or \\.\
                //

                LocalCheckLength = FALSE;
            }
        }
    }

    *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( BufLen * sizeof (WCHAR));
    if (  NULL == *LocalFileName ){
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!SharePath) {

        //
        // This is a local path. Just copy it.
        //

        if (LocalCheckLength && PathLen >= MAX_PATH) {

            //
            // This is for Win2K compatibility
            //

            wcscpy(*LocalFileName, L"\\\\?\\");
            wcscat(*LocalFileName, FileName);
        } else {
            wcscpy(*LocalFileName, FileName);
        }
        return ERROR_SUCCESS;

    }

    NetName = (LPWSTR)LsapAllocateLsaHeap( PathLen * sizeof (WCHAR));
    if ( NULL == NetName ){
        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Extract the net name
    //

    ii = jj = 0;

    while ( (FileName[jj]) && (FileName[jj] == L'\\') ){
        jj++;
    }
    while ( (FileName[jj]) && (FileName[jj++] != L'\\') );
    while ( (FileName[jj]) && (FileName[jj] != L'\\')){
        NetName[ii++] = FileName[jj++];
    }

    if ( !(FileName[jj]) ){

        //
        // Invalid path name
        //

        LsapFreeLsaHeap( NetName );
        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        return ERROR_BAD_NETPATH ;

    }

    NetName[ii] = 0;
    RetCode = NetShareGetInfo(
                            NULL,
                            NetName,
                            2,
                            &ShareInfo
                            );

    if ( NERR_Success == RetCode ){

        PathLen = wcslen(((LPSHARE_INFO_2)ShareInfo)->shi2_path) +
                  wcslen(&FileName[jj]) + 1;

        if ( PathLen >= MAX_PATH ){
            if (PathLen + 5 > BufLen){
                LsapFreeLsaHeap( *LocalFileName );
                BufLen = PathLen + 5;
                *LocalFileName = (LPWSTR)LsapAllocateLsaHeap( BufLen * sizeof (WCHAR));
                if ( NULL == *LocalFileName ){
                    NetApiBufferFree(ShareInfo);
                    LsapFreeLsaHeap( NetName );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

            }

        }
        if (MAX_PATH <= PathLen){

            //
            // Put in the \\?\. Buffer should be bigger enough.
            //
            wcscpy(*LocalFileName,L"\\\\?\\");
            wcscat(
                *LocalFileName,
                ((LPSHARE_INFO_2)ShareInfo)->shi2_path
                );
            wcscat(*LocalFileName, &FileName[jj]);

        } else {
            wcscpy(
                *LocalFileName,
                ((LPSHARE_INFO_2)ShareInfo)->shi2_path
                );
            wcscat(*LocalFileName, &FileName[jj]);
        }
        NetApiBufferFree(ShareInfo);

    } else {

        //
        // Invalid path name
        //

        LsapFreeLsaHeap( *LocalFileName );
        *LocalFileName = NULL;
        RetCode = ERROR_BAD_NETPATH ;

    }

    LsapFreeLsaHeap( NetName );
    return RetCode;

}

DWORD
EfsRpcQueryUsersOnFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST *pUsersList
    )
{
    DWORD hResult;
    PENCRYPTION_CERTIFICATE_HASH_LIST pHashList;
    LPWSTR LocalFileName;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcQueryUsersOnFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (pUsersList == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcQueryUsersOnFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    //
    // Allocate the structure we're going to return
    //

    pHashList = (PENCRYPTION_CERTIFICATE_HASH_LIST)MIDL_user_allocate( sizeof( ENCRYPTION_CERTIFICATE_HASH_LIST ));

    *pUsersList = pHashList;

    if (pHashList) {

        hResult = QueryUsersOnFileSrv(
                      LocalFileName,
                      &pHashList->nCert_Hash,
                      &pHashList->pUsers
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            MIDL_user_free( pHashList );
            *pUsersList = NULL;   // paranoia
        }
    
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD EfsRpcQueryRecoveryAgents(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    OUT PENCRYPTION_CERTIFICATE_HASH_LIST * pRecoveryAgents
    )
{
    DWORD hResult;
    PENCRYPTION_CERTIFICATE_HASH_LIST pHashList;
    LPWSTR LocalFileName;
    HANDLE hToken;
    HANDLE hProfile;
    EFS_USER_INFO EfsUserInfo;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcQueryRecoveryAgents\n"   ));
    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (pRecoveryAgents == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcQueryRecoveryAgents: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    //
    // Allocate the structure we're going to return
    //

    pHashList = (PENCRYPTION_CERTIFICATE_HASH_LIST)MIDL_user_allocate( sizeof( ENCRYPTION_CERTIFICATE_HASH_LIST ));

    *pRecoveryAgents = pHashList;

    if (pHashList) {

        hResult = QueryRecoveryAgentsSrv(
                      LocalFileName,
                      &pHashList->nCert_Hash,
                      &pHashList->pUsers
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            MIDL_user_free( pHashList );
            *pRecoveryAgents = NULL;   // paranoia
        }

    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD EfsRpcRemoveUsersFromFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_HASH_LIST pUsers
    )
{
    DWORD hResult;
    LPWSTR LocalFileName;
    HANDLE hToken;
    HANDLE hProfile;
    EFS_USER_INFO EfsUserInfo;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcRemoveUsersFromFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if ((pUsers == NULL) || (lpFileName == NULL) || (pUsers->pUsers == NULL)) {
       return ERROR_INVALID_PARAMETER;
    }

    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES| FILE_WRITE_DATA )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcRemoveUsersFromFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            //
            // The cert hash list could be garbage
            //

            __try{

                hResult = RemoveUsersFromFileSrv(
                              &EfsUserInfo,
                              LocalFileName,
                              pUsers->nCert_Hash,
                              pUsers->pUsers
                              );

            } __except (EXCEPTION_EXECUTE_HANDLER) {

                hResult = ERROR_INVALID_PARAMETER;

            }

            EfspUnloadUserProfile( hToken, hProfile );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        hResult = GetLastError();
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}

DWORD
EfsRpcAddUsersToFile(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates
    )
{
    DWORD hResult;
    LPWSTR LocalFileName;

    HANDLE hToken;
    HANDLE hProfile;
    EFS_USER_INFO EfsUserInfo;
    WORD   WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcAddUsersToFile\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }

    if (pEncryptionCertificates == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,                       
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES| FILE_WRITE_DATA )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcAddUsersToFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            //
            // We may be passed in garbage for the cert list
            //

            __try {
                hResult = AddUsersToFileSrv(
                             &EfsUserInfo,
                             LocalFileName,
                             pEncryptionCertificates->nUsers,
                             pEncryptionCertificates->pUsers
                             );
            } __except (EXCEPTION_EXECUTE_HANDLER) {

                hResult = ERROR_INVALID_PARAMETER;

            }


            EfspUnloadUserProfile( hToken, hProfile );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );

    } else {

        hResult = GetLastError();
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}


DWORD
EfsRpcSetFileEncryptionKey(
    IN handle_t binding_h,
    IN PENCRYPTION_CERTIFICATE pEncryptionCertificate
    )
{

    DWORD hResult;

    HANDLE hToken;
    HANDLE hProfile;

    EFS_USER_INFO EfsUserInfo;

    DebugLog((DEB_WARN, "Made it into EfsRpcSetFileEncryptionKey\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    hResult = RpcImpersonateClient( NULL );

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcSetFileEncryptionKey: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        return( hResult );
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            hResult = SetFileEncryptionKeySrv( &EfsUserInfo, pEncryptionCertificate );

            EfspUnloadUserProfile( hToken, hProfile );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );
    }

    RpcRevertToSelf();

    return( hResult );
}


DWORD
EfsRpcDuplicateEncryptionInfoFile(
    IN handle_t binding_h,
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
    DWORD hResult;

    HANDLE hToken;
    HANDLE hProfile;
    LPWSTR LocalSrcFileName;
    LPWSTR LocalDestFileName;
    BOOLEAN NetSession=FALSE;
    WORD   WebDavPathSrc;
    WORD   WebDavPathDst;

    EFS_USER_INFO EfsUserInfo;
    DebugLog((DEB_WARN, "Made it into EfsRpcDuplicateEncryptionInfoFile\n"   ));


    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    hResult = GetLocalFileName(
                        lpSrcFileName,
                        &LocalSrcFileName,
                        &WebDavPathSrc
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = GetLocalFileName(
                        lpDestFileName,
                        &LocalDestFileName,
                        &WebDavPathDst
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalSrcFileName );
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpSrcFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalDestFileName );
            LsapFreeLsaHeap( LocalSrcFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }

        if (EfsShareDecline(lpDestFileName, FALSE, 0 )) {

            LsapFreeLsaHeap( LocalDestFileName );
            LsapFreeLsaHeap( LocalSrcFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
        NetSession = TRUE;

    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcDuplicateEncryptionInfoFile: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalDestFileName );
        LsapFreeLsaHeap( LocalSrcFileName );
        return ( hResult );
    }

    if (EfspGetUserInfo( &EfsUserInfo )) {

        //
        // Load the profile so we can open the source file
        //

        if (EfspLoadUserProfile( &EfsUserInfo, &hToken, &hProfile )) {

            hResult = DuplicateEncryptionInfoFileSrv( &EfsUserInfo, 
                                                      LocalSrcFileName, 
                                                      LocalDestFileName,
                                                      NetSession? lpDestFileName: NULL,
                                                      dwCreationDistribution, 
                                                      dwAttributes, 
                                                      pRelativeSD,
                                                      bInheritHandle
                                                      );

            EfspUnloadUserProfile( hToken, hProfile );

        } else {

            hResult = GetLastError();
        }

        EfspFreeUserInfo( &EfsUserInfo );
    }

    LsapFreeLsaHeap( LocalDestFileName );
    LsapFreeLsaHeap( LocalSrcFileName );
    RpcRevertToSelf();

    return( hResult );
}

DWORD EfsRpcFileKeyInfo(
    IN handle_t binding_h,
    IN LPCWSTR lpFileName,
    IN DWORD   InfoClass,
    OUT PEFS_RPC_BLOB *KeyInfo
    )
{
    DWORD hResult;
    PEFS_RPC_BLOB pKeyInfo;
    LPWSTR LocalFileName;
    WORD  WebDavPath;

    DebugLog((DEB_WARN, "Made it into EfsRpcFileKeyInfo\n"   ));

    if (EfsPersonalVer) {
        return ERROR_NOT_SUPPORTED;
    }
    if (EfsDisabled) {
        return ERROR_EFS_DISABLED;
    }
    if (KeyInfo == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    hResult = GetLocalFileName(
                        lpFileName,
                        &LocalFileName,
                        &WebDavPath
                        );

    if (hResult){
        DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: GetLocalFileName failed, Error = (%x)\n" ,hResult  ));
        return hResult;
    }

    hResult = RpcImpersonateClient( NULL );

    if (EfsCheckForNetSession()) {
        if (EfsShareDecline(lpFileName, TRUE, FILE_READ_ATTRIBUTES )) {

            LsapFreeLsaHeap( LocalFileName );
            RpcRevertToSelf();
            DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: EfsShareDecline failed, Error = (%x)\n" ,GetLastError()  ));
            return GetLastError();

        }
    }

    if (hResult != RPC_S_OK) {
        DebugLog((DEB_ERROR, "EfsRpcFileKeyInfo: RpcImpersonateClient failed, Error = (%x)\n" ,hResult  ));
        LsapFreeLsaHeap( LocalFileName );
        return( hResult );
    }

    //
    // Allocate the structure we're going to return
    //

    pKeyInfo = (PEFS_RPC_BLOB)MIDL_user_allocate( sizeof( EFS_RPC_BLOB ));

    *KeyInfo = pKeyInfo;

    if (pKeyInfo) {

        hResult = EfsFileKeyInfoSrv(
                      LocalFileName,
                      InfoClass,
                      &pKeyInfo->cbData,
                      &pKeyInfo->pbData
                      );

        if (hResult != ERROR_SUCCESS) {

            //
            // Free the structure we allocated
            //

            MIDL_user_free( pKeyInfo );
            *KeyInfo = NULL;   // paranoia
        }
    
    }

    RpcRevertToSelf();
    LsapFreeLsaHeap( LocalFileName );

    return( hResult );
}


DWORD
EfsRpcNotSupported(
    IN handle_t binding_h,
    IN LPCWSTR lpSrcFileName,
    IN LPCWSTR lpDestFileName,
    IN DWORD dwCreationDistribution, 
    IN DWORD dwAttributes, 
    IN PEFS_RPC_BLOB pRelativeSD,
    IN BOOL bInheritHandle
    )
{
    DebugLog((DEB_WARN, "Made it into EfsRpcNotSupported\n"   ));

    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\aufilter.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aufilter.c

Abstract:

    This module contains the famous LSA logon Filter/Augmentor logic.

Author:

    Jim Kelly (JimK) 11-Mar-1992

Revision History:

--*/

#include <lsapch2.h>

//#define LSAP_DONT_ASSIGN_DEFAULT_DACL

#define LSAP_CONTEXT_SID_USER_INDEX          0
#define LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX 1
#define LSAP_CONTEXT_SID_WORLD_INDEX         2
#define LSAP_MAX_STANDARD_IDS                6  // user, group, world, logontype, terminal server, authuser

#define LSAP_MAX_DEFAULT_PRIVILEGES         20  // Start with 20 privileges

//
// Internal limit on the number of SIDs that can be assigned to a single
// security context.  If, for some reason, someone logs on to an account
// and is assigned more than this number of SIDs, the logon will fail.
// An error should be logged in this case.
//

#define LSAP_CONTEXT_SID_LIMIT 1000


#define ALIGN_SIZEOF(_u,_v)                  FIELD_OFFSET( struct { _u _test1; _v  _test2; }, _test2 )
#define OFFSET_ALIGN(_p,_t)                  (_t *)(((INT_PTR)(((PBYTE)(_p))+TYPE_ALIGNMENT(_t) - 1)) & ~(TYPE_ALIGNMENT(_t)-1))


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module local macros                                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define LsapFreeSampUlongArray( A )                 \
{                                                   \
        if ((A)->Element != NULL) {                 \
            MIDL_user_free((A)->Element);           \
        }                                           \
}

#define IsTerminalServer() (BOOLEAN)(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer))



//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module-wide global variables                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//
// Indicates whether we have already opened SAM handles and initialized
// corresponding variables.
//

ULONG LsapAuSamOpened = FALSE;




//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Module local routine definitions                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

VOID
LsapAuSetLogonPrivilegeStates(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges
    );

NTSTATUS
LsapAuSetPassedIds(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID                      TokenInformation,
    IN PTOKEN_GROUPS              LocalGroups,
    OUT PULONG                    FinalIdCount,
    OUT PSID_AND_ATTRIBUTES       FinalIds,
    OUT PSID                    * UserSid
    );


NTSTATUS
LsapSetDefaultDacl(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    OUT    PLSA_TOKEN_INFORMATION_V2 TokenInfo
    );


NTSTATUS
LsapAuAddStandardIds(
    IN SECURITY_LOGON_TYPE LogonType,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN BOOLEAN fNullSessionRestricted,
    IN PSID UserSid OPTIONAL,
    IN OUT PULONG FinalIdCount,
    IN OUT PSID_AND_ATTRIBUTES FinalIds
    );


NTSTATUS
LsapAuBuildTokenInfoAndAddLocalAliases(
    IN     LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN     PVOID               OldTokenInformation,
    IN     ULONG               HighRateIdCount,
    IN     ULONG               FinalIdCount,
    IN     PSID_AND_ATTRIBUTES FinalIds,
    OUT    PLSA_TOKEN_INFORMATION_V2 *TokenInfo,
    OUT    PULONG              TokenSize
    );


NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    );

NTSTATUS
LsapAuVerifyLogonType(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG SystemAccess
    );

NTSTATUS
LsapAuSetTokenInformation(
    IN OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN OUT PVOID *TokenInformation,
    IN ULONG FinalIdCount,
    IN PSID_AND_ATTRIBUTES FinalIds,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN ULONG NewTokenInfoSize,
    IN OUT PLSA_TOKEN_INFORMATION_V2 *NewTokenInfo

    );

NTSTATUS
LsapAuCopySidAndAttributes(
    PSID_AND_ATTRIBUTES Target,
    PSID_AND_ATTRIBUTES Source,
    PULONG SourceProperties
    );

NTSTATUS
LsapAuDuplicateSid(
    PSID *Target,
    PSID Source
    );

NTSTATUS
LsapAuCopySid(
    PSID *Target,
    PSID_AND_ATTRIBUTES Source,
    PULONG SourceProperties
    );

BOOLEAN
LsapIsSidLogonSid(
    PSID Sid
    );

BOOLEAN
CheckNullSessionAccess(
    VOID
    );

BOOL
IsTerminalServerRA(
    VOID
    );

BOOLEAN
IsTSUSerSidEnabled(
   VOID
   );

BOOLEAN
CheckAdminOwnerSetting(
    VOID
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Routines                                                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


NTSTATUS
LsapAuUserLogonPolicyFilter(
    IN SECURITY_LOGON_TYPE          LogonType,
    IN PLSA_TOKEN_INFORMATION_TYPE  TokenInformationType,
    IN PVOID                       *TokenInformation,
    IN PTOKEN_GROUPS                LocalGroups,
    OUT PQUOTA_LIMITS               QuotaLimits,
    OUT PPRIVILEGE_SET             *PrivilegesAssigned
    )

/*++

Routine Description:

    This routine performs per-logon filtering and augmentation to
    implement local system security policies.  These policies include
    assignment of local aliases, privileges, and quotas.

    The basic logic flow of the filter augmentor is:


         1) Receive a set of user and group IDs that have already
            been assigned as a result of authentication.  Presumably
            these IDs have been provided by the authenticating
            security authority.


         2) Based upon the LogonType, add a set of standard IDs to the
            list.  This will include WORLD and an ID representing the
            logon type (e.g., INTERACTIVE, NETWORK, SERVICE).


         3) Call SAM to retrieve additional ALIAS IDs assigned by the
            local ACCOUNTS domain.


         4) Call SAM to retrieve additional ALIAS IDs assigned by the
            local BUILTIN domain.


         5) Retrieve any privileges and or quotas assigned to the resultant
            set of IDs.  This also informs us whether or not the specific
            type of logon is to be allowed.  Enable privs for network logons.


         6) If a default DACL has not already been established, assign
            one.


         7) Shuffle all high-use-rate IDs to preceed those that aren't
            high-use-rate to obtain maximum performance.



Arguments:

    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Provides the set of user and group IDs.  This
        structure will be modified as necessary to incorporate local
        security policy (e.g., SIDs added or removed, privileges added
        or removed).

    QuotaLimits - Quotas assigned to the user logging on.

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

    STATUS_INSUFFICIENT_RESOURCES - heap could not be allocated to house
        the combination of the existing and new groups.

    STATUS_INVALID_LOGON_TYPE - The value specified for LogonType is not
        a valid value.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the user has not been granted
        the requested type of logon by local security policy.  Logon should
        be rejected.
--*/

{
    NTSTATUS Status;

    BOOLEAN fNullSessionRestricted = FALSE;
    ULONG i;
    ULONG FinalIdCount = 0, HighRateIdCount = 0, FinalPrivilegeCount = 0;
    PRIVILEGE_SET *FinalPrivileges = NULL;
    PTOKEN_PRIVILEGES pPrivs = NULL;
    LSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo;
    PSID  UserSid = NULL;

    SID_AND_ATTRIBUTES *FinalIds = NULL;
    PLSA_TOKEN_INFORMATION_V2  TokenInfo = NULL;
    ULONG TokenInfoSize = 0;

    //
    // Validate the Logon Type.
    //

    if ( (LogonType != Interactive) &&
         (LogonType != Network)     &&
         (LogonType != Service)     &&
         (LogonType != Batch)       &&
         (LogonType != NetworkCleartext) &&
         (LogonType != NewCredentials ) &&
         (LogonType != CachedInteractive) &&
         (LogonType != RemoteInteractive ) ) {

        Status = STATUS_INVALID_LOGON_TYPE;
        goto UserLogonPolicyFilterError;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Build up a list of IDs and privileges to return                      //
    // This list is initialized to contain the set of IDs                   //
    // passed in.                                                           //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    // Start out with the IDs passed in and no privileges
    //
    if ((*TokenInformationType) == LsaTokenInformationNull) {
        fNullSessionRestricted = CheckNullSessionAccess();
    }
    else if ((*TokenInformationType) == LsaTokenInformationV1 ||
             (*TokenInformationType) == LsaTokenInformationV2)
    {
        //
        // Get a local pointer to the privileges -- it'll be used below
        //

        pPrivs = ((PLSA_TOKEN_INFORMATION_V2) (*TokenInformation))->Privileges;
    }

    SafeAllocaAllocate( FinalIds, (LSAP_CONTEXT_SID_LIMIT * sizeof(SID_AND_ATTRIBUTES)) );
    if( FinalIds == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto UserLogonPolicyFilterError;
    }

    FinalIdCount = LSAP_CONTEXT_SID_WORLD_INDEX + (fNullSessionRestricted?0:1);


    HighRateIdCount = FinalIdCount;

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Build a list of low rate ID's from standard list                     //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    Status = LsapAuSetPassedIds(
                 (*TokenInformationType),
                 (*TokenInformation),
                 LocalGroups,
                 &FinalIdCount,
                 FinalIds,
                 &UserSid
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    Status = LsapAuAddStandardIds(
                 LogonType,
                 (*TokenInformationType),
                 fNullSessionRestricted,
                 UserSid,
                 &FinalIdCount,
                 FinalIds
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Copy in aliases from the local domains (BUILT-IN and ACCOUNT)        //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    Status = LsapAuBuildTokenInfoAndAddLocalAliases(
                 (*TokenInformationType),
                 (*TokenInformation),
                 HighRateIdCount,
                 FinalIdCount,
                 FinalIds,
                 &TokenInfo,
                 &TokenInfoSize
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }


    //////////////////////////////////////////////////////////////////////////
    //                                                                      //
    // Retrieve Privileges And Quotas                                       //
    //                                                                      //
    //////////////////////////////////////////////////////////////////////////

    //
    // Get the union of all Privileges, Quotas and System Accesses assigned
    // to the user's list of ids from the LSA Policy Database.
    //

    FinalIds[0] = TokenInfo->User.User;
    FinalIdCount = 1;
    for(i=0; i < TokenInfo->Groups->GroupCount; i++)
    {
        FinalIds[FinalIdCount] = TokenInfo->Groups->Groups[i];
        FinalIdCount++;
    }
    FinalPrivilegeCount = 0;

    Status = LsapDbQueryAllInformationAccounts(
                 (LSAPR_HANDLE) LsapPolicyHandle,
                 FinalIdCount,
                 FinalIds,
                 &AccountInfo
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

    //
    // Verify that we have the necessary System Access for our logon type.
    // We omit this check if we are using the NULL session.  Override the
    // privilges supplied by policy if they're explicitly set in the
    // token info (i.e., in the case where we've cloned an existing logon
    // session for a LOGON32_LOGON_NEW_CREDENTIALS logon).
    //

    if (pPrivs != NULL)
    {
        FinalPrivileges = (PPRIVILEGE_SET) MIDL_user_allocate(sizeof(PRIVILEGE_SET)
                                            + (pPrivs->PrivilegeCount - 1) * sizeof(LUID_AND_ATTRIBUTES));

        if (FinalPrivileges == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }

        FinalPrivileges->PrivilegeCount = FinalPrivilegeCount = pPrivs->PrivilegeCount;
        FinalPrivileges->Control        = 0;

        RtlCopyMemory(FinalPrivileges->Privilege,
                      pPrivs->Privileges,
                      pPrivs->PrivilegeCount * sizeof(LUID_AND_ATTRIBUTES));

        MIDL_user_free( AccountInfo.PrivilegeSet );
    }
    else if (AccountInfo.PrivilegeSet != NULL)
    {
        FinalPrivileges = AccountInfo.PrivilegeSet;
        FinalPrivilegeCount = AccountInfo.PrivilegeSet->PrivilegeCount;
    }

    AccountInfo.PrivilegeSet = NULL;

    if (UserSid != NULL)
    {
        if (RtlEqualSid(UserSid, LsapLocalSystemSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_INTERACTIVE_LOGON |
                                       SECURITY_ACCESS_NETWORK_LOGON |
                                       SECURITY_ACCESS_BATCH_LOGON |
                                       SECURITY_ACCESS_SERVICE_LOGON |
                                       SECURITY_ACCESS_PROXY_LOGON |
                                       SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ;
        }
        else if (RtlEqualSid(UserSid, LsapLocalServiceSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_SERVICE_LOGON;
        }
        else if (RtlEqualSid(UserSid, LsapNetworkServiceSid))
        {
            AccountInfo.SystemAccess = SECURITY_ACCESS_SERVICE_LOGON;
        }
    }


    if (*TokenInformationType != LsaTokenInformationNull) {

        Status = LsapAuVerifyLogonType( LogonType, AccountInfo.SystemAccess );

        if (!NT_SUCCESS(Status)) {

            goto UserLogonPolicyFilterError;
        }
    }


    if(FinalPrivilegeCount > LSAP_MAX_DEFAULT_PRIVILEGES)
    {
        PLSA_TOKEN_INFORMATION_V2 NewTokenInfo = NULL;
        INT_PTR PointerOffset = 0;

        // We have too many privileges to fit in our pre-allocated block, so we must grow our TokenInfo structure
        NewTokenInfo = (PLSA_TOKEN_INFORMATION_V2)LsapAllocateLsaHeap(TokenInfoSize +
                                                                      sizeof(LUID_AND_ATTRIBUTES)*
                                                                       (FinalPrivilegeCount - LSAP_MAX_DEFAULT_PRIVILEGES));
        if(NULL == NewTokenInfo)
        {
            Status = STATUS_NO_MEMORY;
            goto UserLogonPolicyFilterError;
        }

        // Copy over all the data
        RtlCopyMemory(NewTokenInfo, TokenInfo, TokenInfoSize);
        TokenInfoSize +=  sizeof(LUID_AND_ATTRIBUTES)* (FinalPrivilegeCount - LSAP_MAX_DEFAULT_PRIVILEGES);

        PointerOffset = ((INT_PTR)NewTokenInfo) - (INT_PTR)TokenInfo;

        // Fix up the pointers
        (PBYTE)(NewTokenInfo->Groups) +=  PointerOffset;
        (PBYTE)(NewTokenInfo->User.User.Sid)  +=  PointerOffset;
        for(i=0; i < NewTokenInfo->Groups->GroupCount; i ++)
        {
            (PBYTE)(NewTokenInfo->Groups->Groups[i].Sid) += PointerOffset;
        }

        if(TokenInfo->PrimaryGroup.PrimaryGroup)
        {
            (PBYTE)NewTokenInfo->PrimaryGroup.PrimaryGroup += PointerOffset;
        }

        (PBYTE)(NewTokenInfo->Privileges) += PointerOffset;

        if(TokenInfo->Owner.Owner)
        {
            (PBYTE)NewTokenInfo->Owner.Owner += PointerOffset;
        }

        if(TokenInfo->DefaultDacl.DefaultDacl)
        {
            (PBYTE)(NewTokenInfo->DefaultDacl.DefaultDacl) += PointerOffset;
        }

        LocalFree(TokenInfo);
        TokenInfo = NewTokenInfo;
        NewTokenInfo = NULL;
    }


#ifndef LSAP_DONT_ASSIGN_DEFAULT_DACL

    Status = LsapSetDefaultDacl( (*TokenInformationType),
                                 (*TokenInformation),
                                 TokenInfo
                                 );
    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }

#endif //LSAP_DONT_ASSIGN_DEFAULT_DACL


    //
    // Now update the TokenInformation structure.
    // This causes all allocated IDs and privileges to be
    // freed (even if unsuccessful).
    //

    Status = LsapAuSetTokenInformation(
                 TokenInformationType,
                 TokenInformation,
                 FinalIdCount,
                 FinalIds,
                 FinalPrivilegeCount,
                 FinalPrivileges->Privilege,
                 TokenInfoSize,
                 &TokenInfo
                 );

    if (!NT_SUCCESS(Status)) {

        goto UserLogonPolicyFilterError;
    }
    //
    // Enable or Disable privileges according to our logon type
    // This is necessary until we get dynamic security tracking.
    //

    if (pPrivs == NULL)
    {
        LsapAuSetLogonPrivilegeStates(
            LogonType,
            ((PLSA_TOKEN_INFORMATION_V2)(*TokenInformation))->Privileges->PrivilegeCount,
            ((PLSA_TOKEN_INFORMATION_V2)(*TokenInformation))->Privileges->Privileges
            );
    }

    //
    // Return these so they can be audited.  Data
    // will be freed in the caller.
    //

    *QuotaLimits = AccountInfo.QuotaLimits;
    *PrivilegesAssigned = FinalPrivileges;

UserLogonPolicyFilterFinish:

    if( FinalIds )
    {
        SafeAllocaFree(FinalIds);
    }

    if(TokenInfo)
    {
        LsapFreeTokenInformationV2(TokenInfo);
    }

    return(Status);

UserLogonPolicyFilterError:


    //
    // If necessary, clean up Privileges buffer
    //

    if (FinalPrivileges != NULL) {

        MIDL_user_free( FinalPrivileges );
        FinalPrivileges = NULL;
    }

    goto UserLogonPolicyFilterFinish;
}


NTSTATUS
LsapAuVerifyLogonType(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    This function verifies that a User has the system access granted necessary
    for the speicifed logon type.

Arguments

    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    SystemAccess - Specifies the System Access granted to the User.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The user has the necessary system access.

        STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
            has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Determine if the specified Logon Type is granted by any of the
    // groups or aliases specified.
    //

    switch (LogonType) {

    case Interactive:
    case CachedInteractive:

        if (!(SystemAccess & SECURITY_ACCESS_INTERACTIVE_LOGON) ||
            (SystemAccess & SECURITY_ACCESS_DENY_INTERACTIVE_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case NewCredentials:

        //
        // NewCredentials does not require a logon type, since this is a dup
        // of someone who has logged on already somewhere else.
        //

        NOTHING;

        break;

    case Network:
    case NetworkCleartext:

        if (!(SystemAccess & SECURITY_ACCESS_NETWORK_LOGON)||
            (SystemAccess & SECURITY_ACCESS_DENY_NETWORK_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case Batch:

        if ((SystemAccess & SECURITY_ACCESS_DENY_BATCH_LOGON) ||
            !(SystemAccess & SECURITY_ACCESS_BATCH_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case Service:

        if ((SystemAccess & SECURITY_ACCESS_DENY_SERVICE_LOGON) ||
            !(SystemAccess & SECURITY_ACCESS_SERVICE_LOGON)) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        }

        break;

    case RemoteInteractive:
        if ( ( SystemAccess & SECURITY_ACCESS_DENY_REMOTE_INTERACTIVE_LOGON ) ||
             ! ( SystemAccess & SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON ) ) {

            Status = STATUS_LOGON_TYPE_NOT_GRANTED ;
        }
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    return(Status);
}




NTSTATUS
LsapAuSetPassedIds(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID                      TokenInformation,
    IN PTOKEN_GROUPS              LocalGroups,
    OUT PULONG                    FinalIdCount,
    OUT PSID_AND_ATTRIBUTES       FinalIds,
    OUT PSID                    * UserSid
    )

/*++

Routine Description:

    This routine initializes the FinalIds array.



Arguments:


    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Provides the initial set of user and group IDs.

    FinalIdCount - Will be set to contain the number of IDs passed.

    FinalIds - will contain the set of IDs passed in.

    IdProperties - Will be set to indicate none of the initial
        IDs were locally allocated.  It will also identify the
        first two ids (if there are two ids) to be HIGH_RATE.



Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_TOO_MANY_CONTEXT_IDS - There are too many IDs in the context.


--*/

{

    ULONG i;
    PTOKEN_USER   User;
    PTOKEN_GROUPS Groups;
    PTOKEN_PRIMARY_GROUP PrimaryGroup;
    PSID PrimaryGroupSid = NULL;
    PULONG PrimaryGroupAttributes = NULL;

    DWORD  TotalGroupCount = 0;
    ULONG CurrentId = 0;

    //
    // Get the passed ids
    //

    ASSERT(  (TokenInformationType == LsaTokenInformationNull ) ||
             (TokenInformationType == LsaTokenInformationV1) ||
             (TokenInformationType == LsaTokenInformationV2));

    if (TokenInformationType == LsaTokenInformationNull) {
        User = NULL;
        Groups = ((PLSA_TOKEN_INFORMATION_NULL)(TokenInformation))->Groups;
        PrimaryGroup = NULL;
    } else {
        User = &((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->User;
        Groups = ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Groups;
        PrimaryGroup = &((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->PrimaryGroup;
    }

    *UserSid = NULL;

    if (User != NULL) {

        //
        // TokenInformation included a user ID.
        //
        *UserSid = User->User.Sid ;

        FinalIds[LSAP_CONTEXT_SID_USER_INDEX] = User->User;

    }
    else
    {
        // Set the user as anonymous

        FinalIds[LSAP_CONTEXT_SID_USER_INDEX].Sid = LsapAnonymousSid;
        FinalIds[LSAP_CONTEXT_SID_USER_INDEX].Attributes = (SE_GROUP_MANDATORY   |
                                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                                            SE_GROUP_ENABLED
                                                            );
    }


    if(PrimaryGroup != NULL)    {
        //
        // TokenInformation included a primary group ID.
        //

        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Sid = PrimaryGroup->PrimaryGroup;
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes = (SE_GROUP_MANDATORY   |
                                                            SE_GROUP_ENABLED_BY_DEFAULT |
                                                            SE_GROUP_ENABLED
                                                            );

        //
        // Store a pointer to the attributes and the sid so we can later
        // fill in the attributes from the rest of the group memebership.
        //

        PrimaryGroupAttributes = &FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes;
        PrimaryGroupSid = PrimaryGroup->PrimaryGroup;

    }
    else
    {
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Sid = LsapNullSid;
        FinalIds[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX].Attributes = 0;
    }

    TotalGroupCount = LSAP_MAX_STANDARD_IDS;

    if(Groups)
    {
        TotalGroupCount += Groups->GroupCount;
    }
    if(LocalGroups)
    {
        TotalGroupCount += LocalGroups->GroupCount;
    }

    if(TotalGroupCount > LSAP_CONTEXT_SID_LIMIT)
    {
        return (STATUS_TOO_MANY_CONTEXT_IDS);
    }



    if(Groups == NULL)
    {
        Groups = LocalGroups;
    }

    CurrentId = (*FinalIdCount);

    while(Groups != NULL) {
        for (i=0; i < Groups->GroupCount; i++) {

            //
            // If this sid is the primary group, it is already in the list
            // of final IDs but we need to add the attribute
            //

            if ((PrimaryGroupSid != NULL) && RtlEqualSid(
                    PrimaryGroupSid,
                    Groups->Groups[i].Sid
                    )) {
                *PrimaryGroupAttributes = Groups->Groups[i].Attributes;
            } else {

                // Ownership of the SID remains with the LocalGroups structure, which
                // will be freed by the caller
                FinalIds[CurrentId] = Groups->Groups[i];


                //
                // if this SID is a logon SID, then set the SE_GROUP_LOGON_ID
                // attribute
                //

                if (LsapIsSidLogonSid(FinalIds[CurrentId].Sid) == TRUE)  {
                    FinalIds[CurrentId].Attributes |= SE_GROUP_LOGON_ID;
                }
                CurrentId++;

            }

        }
        if(Groups != LocalGroups)
        {
            Groups = LocalGroups;
        }
        else
        {
            break;
        }
    }

    (*FinalIdCount) = CurrentId;

    return(STATUS_SUCCESS);

}



NTSTATUS
LsapSetDefaultDacl(
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN PVOID TokenInformation,
    IN OUT PLSA_TOKEN_INFORMATION_V2 TokenInfo
    )

/*++

Routine Description:

    This routine produces a default DACL if the existing TokenInformation
    does not already have one.  NULL logon types don't have default DACLs
    and so this routine simply returns success for those logon types.


    The default DACL will be:

            SYSTEM: ALL Access
            Owner:  ALL Access


            !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !!

                NOTE: The FinalOwnerIndex should not be changed after
                      calling this routine.

            !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !! IMPORTANT  !!


Arguments:


    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - Points to token information which has the current
        default DACL.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_MEMORY - Indicates there was not enough heap memory available
        to allocate the default DACL.




--*/

{
    NTSTATUS
        Status;

    PACL
        Acl;

    ULONG
        Length;

    SID_IDENTIFIER_AUTHORITY
        NtAuthority = SECURITY_NT_AUTHORITY;

    PLSA_TOKEN_INFORMATION_V2
        CastTokenInformation;

    PSID OwnerSid = NULL;


    //
    // NULL token information?? (has no default dacl)
    //

    if (TokenInformationType == LsaTokenInformationNull) {
        return(STATUS_SUCCESS);
    }
    ASSERT((TokenInformationType == LsaTokenInformationV1) ||
           (TokenInformationType == LsaTokenInformationV2));


    CastTokenInformation = (PLSA_TOKEN_INFORMATION_V2)TokenInformation;


    //
    // Already have a default DACL?
    //

    Acl = CastTokenInformation->DefaultDacl.DefaultDacl;
    if (Acl != NULL) {
        ACL_SIZE_INFORMATION AclSize;

        Status = RtlQueryInformationAcl(Acl,
                                        &AclSize,
                                        sizeof(AclSize),
                                        AclSizeInformation);

        if (!NT_SUCCESS(Status)) {

            return Status;
        }

        RtlCopyMemory(TokenInfo->DefaultDacl.DefaultDacl, Acl,AclSize.AclBytesFree +  AclSize.AclBytesInUse);

        return(STATUS_SUCCESS);
    }


    Acl = TokenInfo->DefaultDacl.DefaultDacl;

    OwnerSid = TokenInfo->Owner.Owner?TokenInfo->Owner.Owner:TokenInfo->User.User.Sid;

    Length      =  sizeof(ACL) +
                (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                RtlLengthSid(OwnerSid)  +
                RtlLengthSid( LsapLocalSystemSid );

    Status = RtlCreateAcl( Acl, Length, ACL_REVISION2);
    if(!NT_SUCCESS(Status) )
    {
        goto error;
    }



    //
    // OWNER access - put this one first for performance sake
    //

    Status = RtlAddAccessAllowedAce (
                 Acl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 OwnerSid
                 );
    if(!NT_SUCCESS(Status) )
    {
        goto error;
    }


    //
    // SYSTEM access
    //

    Status = RtlAddAccessAllowedAce (
                 Acl,
                 ACL_REVISION2,
                 GENERIC_ALL,
                 LsapLocalSystemSid
                 );
error:

    return(Status);
}



NTSTATUS
LsapAuAddStandardIds(
    IN SECURITY_LOGON_TYPE LogonType,
    IN LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN BOOLEAN fNullSessionRestricted,
    IN PSID UserSid OPTIONAL,
    IN OUT PULONG FinalIdCount,
    IN OUT PSID_AND_ATTRIBUTES FinalIds
    )

/*++

Routine Description:

    This routine adds standard IDs to the FinalIds array.

    This causes the WORLD id to be added and an ID representing
    logon type to be added.

    For anonymous logons, it will also add the ANONYMOUS id.





Arguments:


    LogonType - Specifies the type of logon being requested (e.g.,
        Interactive, network, et cetera).

    TokenInformationType - The token information type returned by
        the authentication package.  The set of IDs added is dependent
        upon the type of logon.

    FinalIdCount - Will be incremented to reflect newly added IDs.

    FinalIds - will have new IDs added to it.

    IdProperties - Will be set to indicate that these IDs must be
        copied and that WORLD is a high-hit-rate id.



Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_TOO_MANY_CONTEXT_IDS - There are too many IDs in the context.


--*/

{

    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;

    i = (*FinalIdCount);


    if( !fNullSessionRestricted ) {

        // This is a high rate id, so it's has a reserved space
        FinalIds[LSAP_CONTEXT_SID_WORLD_INDEX].Sid = LsapWorldSid;
        FinalIds[LSAP_CONTEXT_SID_WORLD_INDEX].Attributes = (SE_GROUP_MANDATORY          |
                                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                                  SE_GROUP_ENABLED
                                                  );
    }


    //
    // Add Logon type SID
    //

    switch ( LogonType ) {
    case Interactive:
    case NewCredentials:
    case CachedInteractive:

        FinalIds[i].Sid = LsapInteractiveSid;
        break;

    case RemoteInteractive:
        FinalIds[i].Sid = LsapRemoteInteractiveSid;
        break;

    case Network:
    case NetworkCleartext:
        FinalIds[i].Sid = LsapNetworkSid;
        break;

    case Batch:
        FinalIds[i].Sid = LsapBatchSid;
        break;

    case Service:
        FinalIds[i].Sid = LsapServiceSid;
        break;

    default:
        ASSERT("Unknown new logon type in LsapAuAddStandardIds" && FALSE);
    }



    if ( FinalIds[ i ].Sid )
    {
        FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED
                                  );
        i++;
    }


    //
    // Add SIDs that are required when TS is running.
    //
    if ( IsTerminalServer() )
    {
        switch ( LogonType )
        {
        case RemoteInteractive:
            // check to see if we are suppose to add the INTERACTIVE SID to the remote session
            // for console level app compatability.
            FinalIds[i].Sid = LsapInteractiveSid;
            FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                      SE_GROUP_ENABLED_BY_DEFAULT |
                                      SE_GROUP_ENABLED
                                      );
                i++;

            //
            // fall thru
            //

        case Interactive :
        case NewCredentials:
        case CachedInteractive:

            // check to see if we are suppose to add the TSUSER SID to the session. This
            // is for TS4-app-compatability security mode.

            if ( IsTSUSerSidEnabled() )
            {

               //
               // Don't add TSUSER sid for GUEST logon
               //
               if ( ( TokenInformationType != LsaTokenInformationNull ) &&
                    ( UserSid ) &&
                    ( *RtlSubAuthorityCountSid( UserSid ) > 0 ) &&
                    ( *RtlSubAuthoritySid( UserSid,
                              (ULONG) (*RtlSubAuthorityCountSid( UserSid ) ) - 1) != DOMAIN_USER_RID_GUEST ) )
               {

                    FinalIds[i].Sid = LsapTerminalServerSid;
                    FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                              SE_GROUP_ENABLED_BY_DEFAULT |
                                              SE_GROUP_ENABLED
                                              );
                    i++;
               }
            }

        }   // logon type switch for TS SIDs

    } // if TS test


    //
    // If this is a not a null logon, and not a GUEST logon,
    // then add in the AUTHENTICATED USER SID.
    //

    if ( ( TokenInformationType != LsaTokenInformationNull ) &&
         ( UserSid ) &&
         ( *RtlSubAuthorityCountSid( UserSid ) > 0 ) &&
         ( *RtlSubAuthoritySid( UserSid,
                   (ULONG) (*RtlSubAuthorityCountSid( UserSid ) ) - 1) != DOMAIN_USER_RID_GUEST ) ) {

        FinalIds[i].Sid = LsapAuthenticatedUserSid;         //Use the global SID
        FinalIds[i].Attributes = (SE_GROUP_MANDATORY          |
                                  SE_GROUP_ENABLED_BY_DEFAULT |
                                  SE_GROUP_ENABLED
                                  );
        i++;
    }

    (*FinalIdCount) = i;
    return(Status);

}



NTSTATUS
LsapAuBuildTokenInfoAndAddLocalAliases(
    IN     LSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN     PVOID               OldTokenInformation,
    IN     ULONG               HighRateIdCount,
    IN     ULONG               FinalIdCount,
    IN     PSID_AND_ATTRIBUTES FinalIds,
    OUT    PLSA_TOKEN_INFORMATION_V2 *TokenInfo,
    OUT    PULONG              TokenInfoSize
    )

/*++

Routine Description:

    This routine adds aliases assigned to the IDs in FinalIds.

    This will look in both the BUILT-IN and ACCOUNT domains locally.


        1) Adds aliases assigned to the user via the local ACCOUNTS
           domain.

        2) Adds aliases assigned to the user via the local BUILT-IN
           domain.

        3) If the ADMINISTRATORS alias is assigned to the user, then it
           is made the user's default owner.


    NOTE:  Aliases, by their nature, are expected to be high-use-rate
           IDs.

Arguments:


    FinalIdCount - Will be incremented to reflect any newly added IDs.

    FinalIds - will have any assigned alias IDs added to it.

    IdProperties - Will be set to indicate that any aliases added were
        allocated by this routine.


Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_TOO_MANY_CONTEXT_IDS - There are too many IDs in the context.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS, SuccessExpected;
    ULONG i;
    SAMPR_SID_INFORMATION *SidArray = NULL;
    SAMPR_ULONG_ARRAY AccountMembership, BuiltinMembership;
    SAMPR_PSID_ARRAY SamprSidArray;

    ULONG                       TokenSize = 0;
    PLSA_TOKEN_INFORMATION_V2   NewTokenInfo = NULL;
    PSID_AND_ATTRIBUTES         GroupArray = NULL;

    PBYTE                       CurrentSid = NULL;
    ULONG                       CurrentSidLength = 0;
    ULONG                       CurrentGroup = 0;

    PLSA_TOKEN_INFORMATION_V2   OldTokenInfo = NULL;
    ULONG                       DefaultDaclSize = 0;

    BOOLEAN                     fAdminOwner;

    if((TokenInformationType == LsaTokenInformationV1) ||
       (TokenInformationType == LsaTokenInformationV2))
    {
        OldTokenInfo = (PLSA_TOKEN_INFORMATION_V2)OldTokenInformation;
    }

    //
    // Make sure SAM has been opened.  We'll get hadnles to both of the
    // SAM Local Domains.
    //

    Status = LsapAuOpenSam( FALSE );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    SafeAllocaAllocate( SidArray, (LSAP_CONTEXT_SID_LIMIT * sizeof(SAMPR_SID_INFORMATION)) );
    if( SidArray == NULL )
    {
        return STATUS_NO_MEMORY;
    }


    for ( i=0; i<FinalIdCount; i++) {

        SidArray[i].SidPointer = (PRPC_SID)FinalIds[i].Sid;
    }


    SamprSidArray.Count = FinalIdCount;
    SamprSidArray.Sids  = &SidArray[0];

    //
    // For the given set of Sids, obtain their collective membership of
    // Aliases in the Accounts domain
    //

    AccountMembership.Count = 0;
    AccountMembership.Element = NULL;
    Status = SamIGetAliasMembership( LsapAccountDomainHandle,
                                     &SamprSidArray,
                                     &AccountMembership
                                     );
    if (!NT_SUCCESS(Status)) {

        SafeAllocaFree( SidArray );
        SidArray = NULL;
        return(Status);
    }

    //
    // For the given set of Sids, obtain their collective membership of
    // Aliases in the Built-In domain
    //

    BuiltinMembership.Count = 0;
    BuiltinMembership.Element = NULL;
    Status = SamIGetAliasMembership( LsapBuiltinDomainHandle,
                                     &SamprSidArray,
                                     &BuiltinMembership
                                     );
    if (!NT_SUCCESS(Status)) {

        LsapFreeSampUlongArray( &AccountMembership );
        SafeAllocaFree( SidArray );
        SidArray = NULL;

        return(Status);
    }

    //
    // Allocate memory to build the tokeninfo
    //

    // Calculate size of resulting tokeninfo

    CurrentSidLength = RtlLengthSid( FinalIds[0].Sid);

    // Size the base structure and group array
    TokenSize = ALIGN_SIZEOF(LSA_TOKEN_INFORMATION_V2, TOKEN_GROUPS) +
                sizeof(TOKEN_GROUPS) +
                (AccountMembership.Count +
                 BuiltinMembership.Count +
                 FinalIdCount - 1 - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES); // Do not include the User SID in this array


    // Sids are ULONG aligned, whereas the SID_AND_ATTRIBUTES should be ULONG or greater aligned
    TokenSize += CurrentSidLength +
                 LsapAccountDomainMemberSidLength*AccountMembership.Count +
                 LsapBuiltinDomainMemberSidLength*BuiltinMembership.Count;

    // Add in size of all passed in/standard sids
    for(i=1; i < FinalIdCount; i++)
    {
        TokenSize +=  RtlLengthSid( FinalIds[i].Sid);
    }


    // Add the size for the DACL
    if(OldTokenInfo)
    {
        if(OldTokenInfo->DefaultDacl.DefaultDacl)
        {
            ACL_SIZE_INFORMATION AclSize;

            Status = RtlQueryInformationAcl(OldTokenInfo->DefaultDacl.DefaultDacl,
                                            &AclSize,
                                            sizeof(AclSize),
                                            AclSizeInformation);

            if (!NT_SUCCESS(Status)) {

                goto Cleanup;
            }
            DefaultDaclSize = AclSize.AclBytesFree + AclSize.AclBytesInUse;
        }
        else
        {

         DefaultDaclSize =  sizeof(ACL) +                                          // Default ACL
                (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG))) +
                max(CurrentSidLength, LsapBuiltinDomainMemberSidLength) +
                RtlLengthSid( LsapLocalSystemSid );
        }
        TokenSize = PtrToUlong(OFFSET_ALIGN((ULONG_PTR)TokenSize, ACL)) + DefaultDaclSize;
    }

    // Add the privilege estimate
    TokenSize = (INT_PTR)OFFSET_ALIGN((ULONG_PTR)TokenSize, TOKEN_PRIVILEGES) +
                sizeof(TOKEN_PRIVILEGES) +                                    // Prealloc some room for privileges
                sizeof(LUID_AND_ATTRIBUTES) * (LSAP_MAX_DEFAULT_PRIVILEGES - ANYSIZE_ARRAY);



    NewTokenInfo = (PLSA_TOKEN_INFORMATION_V2)LsapAllocateLsaHeap(TokenSize);
    if(NULL == NewTokenInfo)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(NewTokenInfo, TokenSize);

    // Fixup pointers
    NewTokenInfo->Groups = (PTOKEN_GROUPS)OFFSET_ALIGN((NewTokenInfo + 1), TOKEN_GROUPS);
    NewTokenInfo->Groups->GroupCount = AccountMembership.Count + BuiltinMembership.Count + FinalIdCount - 1;

    CurrentSid = (PBYTE)(&NewTokenInfo->Groups->Groups[NewTokenInfo->Groups->GroupCount]);

    // Copy user sid
    RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[0].Sid);
    NewTokenInfo->User.User.Sid  = (PSID)CurrentSid;
    NewTokenInfo->User.User.Attributes = FinalIds[0].Attributes;
    CurrentSid += CurrentSidLength;

    GroupArray = NewTokenInfo->Groups->Groups;

    // Copy high rate sids to array (they are static globals, so they don't need to be copied into buffer)
    for(i=1; i < HighRateIdCount; i++)
    {
        CurrentSidLength = RtlLengthSid( FinalIds[i].Sid);
        RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[i].Sid);
        GroupArray[CurrentGroup].Sid = CurrentSid;
        GroupArray[CurrentGroup].Attributes = FinalIds[i].Attributes;
        CurrentGroup++;
        CurrentSid += CurrentSidLength;
    }

    NewTokenInfo->PrimaryGroup.PrimaryGroup = GroupArray[LSAP_CONTEXT_SID_PRIMARY_GROUP_INDEX-1].Sid;



    // Copy Account Aliases

    for ( i=0; i<AccountMembership.Count; i++) {
        SuccessExpected = RtlCopySid( LsapAccountDomainMemberSidLength,
                                      CurrentSid,
                                      LsapAccountDomainMemberSid
                                      );
        ASSERT(NT_SUCCESS(SuccessExpected));


        (*RtlSubAuthoritySid( CurrentSid, LsapAccountDomainSubCount-1)) =
            AccountMembership.Element[i];
        GroupArray[CurrentGroup].Sid = (PSID)CurrentSid;

        GroupArray[CurrentGroup].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED);

        CurrentSid += LsapAccountDomainMemberSidLength;
        CurrentGroup++;

    }

    // Copy Builtin Aliases

    fAdminOwner = CheckAdminOwnerSetting();

    for ( i=0; i<BuiltinMembership.Count; i++) {
        SuccessExpected = RtlCopySid( LsapBuiltinDomainMemberSidLength,
                                      CurrentSid,
                                      LsapBuiltinDomainMemberSid
                                      );
        ASSERT(NT_SUCCESS(SuccessExpected));

        (*RtlSubAuthoritySid( CurrentSid, LsapBuiltinDomainSubCount-1)) =
            BuiltinMembership.Element[i];

        GroupArray[CurrentGroup].Sid = (PSID)CurrentSid;
        GroupArray[CurrentGroup].Attributes = (SE_GROUP_MANDATORY          |
                                               SE_GROUP_ENABLED_BY_DEFAULT |
                                               SE_GROUP_ENABLED);

        if (BuiltinMembership.Element[i] == DOMAIN_ALIAS_RID_ADMINS) {

            //
            // ADMINISTRATORS alias member - set it up as the default owner
            //
            GroupArray[CurrentGroup].Attributes |= (SE_GROUP_OWNER);

            if (fAdminOwner) {
                NewTokenInfo->Owner.Owner = (PSID)CurrentSid;
            }
        }
        CurrentSid += LsapBuiltinDomainMemberSidLength;
        CurrentGroup++;
    }

    // Finish up with the low rate
    // Copy high rate sids to array (they are static globals, so they don't need to be copied into buffer)
    for(i=HighRateIdCount; i < FinalIdCount; i++)
    {
        CurrentSidLength = RtlLengthSid( FinalIds[i].Sid);
        RtlCopySid(CurrentSidLength, CurrentSid, FinalIds[i].Sid);
        GroupArray[CurrentGroup].Sid = CurrentSid;
        GroupArray[CurrentGroup].Attributes = FinalIds[i].Attributes;
        CurrentGroup++;
        CurrentSid += CurrentSidLength;
    }


    if(OldTokenInfo)
    {
        CurrentSid = (PSID)OFFSET_ALIGN(CurrentSid, ACL);
        NewTokenInfo->DefaultDacl.DefaultDacl = (PACL)CurrentSid;
        CurrentSid += DefaultDaclSize;
    }
    CurrentSid = (PSID) OFFSET_ALIGN(CurrentSid, TOKEN_PRIVILEGES);
    NewTokenInfo->Privileges = (PTOKEN_PRIVILEGES)CurrentSid;
    NewTokenInfo->Privileges->PrivilegeCount = 0;

    LsapDsDebugOut((DEB_TRACE, "NewTokenInfo : %lx\n", NewTokenInfo));
    LsapDsDebugOut((DEB_TRACE, "TokenSize : %lx\n", TokenSize));
    LsapDsDebugOut((DEB_TRACE, "CurrentSid : %lx\n", CurrentSid));

    ASSERT((PBYTE)NewTokenInfo + TokenSize == CurrentSid + sizeof(TOKEN_PRIVILEGES) +                                    // Prealloc some room for privileges
                                                          sizeof(LUID_AND_ATTRIBUTES) * (LSAP_MAX_DEFAULT_PRIVILEGES -
                                                          ANYSIZE_ARRAY));


    (*TokenInfo) = NewTokenInfo;
    NewTokenInfo = NULL;
    (*TokenInfoSize) = TokenSize;

Cleanup:

    if( SidArray != NULL )
    {
        SafeAllocaFree( SidArray );
    }

    if(NewTokenInfo)
    {
        LsapFreeLsaHeap(NewTokenInfo);
    }

    LsapFreeSampUlongArray( &AccountMembership );
    LsapFreeSampUlongArray( &BuiltinMembership );

    return(Status);

}



NTSTATUS
LsapAuSetTokenInformation(
    IN OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    IN       PVOID *TokenInformation,
    IN ULONG FinalIdCount,
    IN PSID_AND_ATTRIBUTES FinalIds,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges,
    IN ULONG NewTokenInfoSize,
    IN OUT PLSA_TOKEN_INFORMATION_V2 *NewTokenInfo
    )

/*++

Routine Description:

    This routine takes the information from the current TokenInformation,
    the FinalIds array, and the Privileges and incorporates them into a
    single TokenInformation structure.  It may be necessary to free some
    or all of the original TokenInformation.  It may even be necessary to
    produce a different TokenInformationType to accomplish this task.


Arguments:


    TokenInformationType - Indicates what format the provided set of
        token information is in.

    TokenInformation - The information in this structure will be superseeded
        by the information in the FinalIDs parameter and the Privileges
        parameter.

    FinalIdCount - Indicates the number of IDs (user, group, and alias)
        to be incorporated in the final TokenInformation.

    FinalIds - Points to an array of SIDs and their corresponding
        attributes to be incorporated into the final TokenInformation.

    IdProperties - Points to an array of properties relating to the FinalIds.


    PrivilegeCount - Indicates the number of privileges to be incorporated
        into the final TokenInformation.

    Privileges -  Points to an array of privileges that are to be
        incorporated into the TokenInformation.  This array will be
        used directly in the resultant TokenInformation.






Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_NO_MEMORY - Indicates there was not enough heap memory available
        to produce the final TokenInformation structure.


--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Length, i;

    PLSA_TOKEN_INFORMATION_V2 OldV2;
    PLSA_TOKEN_INFORMATION_NULL OldNull;

    ASSERT(( *TokenInformationType == LsaTokenInformationV1) ||
            (*TokenInformationType == LsaTokenInformationNull) ||
            ( *TokenInformationType == LsaTokenInformationV2));





    if(*TokenInformationType == LsaTokenInformationNull)
    {
        OldNull = (PLSA_TOKEN_INFORMATION_NULL)(*TokenInformation);
        (*NewTokenInfo)->ExpirationTime = OldNull->ExpirationTime;
    }
    else
    {
        OldV2 = (PLSA_TOKEN_INFORMATION_V2)(*TokenInformation);
        (*NewTokenInfo)->ExpirationTime = OldV2->ExpirationTime;
    }

    ////////////////////////////////////////////////////////////////////////
    //                                                                    //
    // Set the Privileges, if any                                         //
    //                                                                    //
    ////////////////////////////////////////////////////////////////////////



    (*NewTokenInfo)->Privileges->PrivilegeCount = PrivilegeCount;

    ASSERT((PBYTE)&(*NewTokenInfo)->Privileges->Privileges[PrivilegeCount] <=
             ((PBYTE)(*NewTokenInfo)) + NewTokenInfoSize);

    for ( i=0; i<PrivilegeCount; i++) {
        (*NewTokenInfo)->Privileges->Privileges[i] = Privileges[i];
    }





    ////////////////////////////////////////////////////////////////////////
    //                                                                    //
    // Free the old TokenInformation and set the new                      //
    //                                                                    //
    ////////////////////////////////////////////////////////////////////////


    if (NT_SUCCESS(Status)) {

        switch ( (*TokenInformationType) ) {
        case LsaTokenInformationNull:
            LsapFreeTokenInformationNull(
                (PLSA_TOKEN_INFORMATION_NULL)(*TokenInformation));
            break;

        case LsaTokenInformationV1:
            LsapFreeTokenInformationV1(
                (PLSA_TOKEN_INFORMATION_V1)(*TokenInformation));
            break;

        case LsaTokenInformationV2:
            LsapFreeTokenInformationV2(
                (PLSA_TOKEN_INFORMATION_V2)(*TokenInformation));
            break;
        }


        //
        // Set the new TokenInformation
        //

        (*TokenInformationType) = LsaTokenInformationV2;
        (*TokenInformation) = (*NewTokenInfo);
        (*NewTokenInfo) = NULL;
    }

    return(Status);

}


NTSTATUS
LsapAuCopySidAndAttributes(
    PSID_AND_ATTRIBUTES Target,
    PSID_AND_ATTRIBUTES Source,
    PULONG SourceProperties
    )

/*++

Routine Description:

    Copy or reference a SID and its corresonding attributes.

    The SID may be referenced if the SourceProperties indicate it
    has been allocated.  In this case, the SourceProperties must be
    changed to indicate the SID is now a copy.


Arguments:

    Target - points to the SID_AND_ATTRIBUTES structure to receive
        the copy of Source.

    Source - points to the SID_AND_ATTRIBUTES structure to be copied.

    SourceProperties - Contains LSAP_AU_SID_PROP_Xxx flags providing
        information about the source.  In some cases, the source may
        be referenced instead of copied.

Return Value:

    STATUS_SUCCESS - The copy was successful.

    STATUS_NO_MEMORY - memory could not be allocated to perform the copy.

--*/

{
    ULONG Length;


    if ((*SourceProperties) & LSAP_AU_SID_PROP_ALLOCATED) {

        (*Target) = (*Source);
        (*SourceProperties) &= ~LSAP_AU_SID_PROP_ALLOCATED;
        (*SourceProperties) |= LSAP_AU_SID_PROP_COPY;

        return(STATUS_SUCCESS);
    }

    //
    // The SID needs to be copied ...
    //

    Length = RtlLengthSid( Source->Sid );
    Target->Sid = LsapAllocateLsaHeap( Length );
    if (Target->Sid == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlMoveMemory( Target->Sid, Source->Sid, Length );
    Target->Attributes = Source->Attributes;

    return(STATUS_SUCCESS);

}

NTSTATUS
LsapAuDuplicateSid(
    PSID *Target,
    PSID Source
    )

/*++

Routine Description:

    Duplicate a SID.


Arguments:

    Target - Recieves a pointer to the SID copy.

    Source - points to the SID to be copied.


Return Value:

    STATUS_SUCCESS - The copy was successful.

    STATUS_NO_MEMORY - memory could not be allocated to perform the copy.

--*/

{
    ULONG Length;

    //
    // The SID needs to be copied ...
    //

    Length = RtlLengthSid( Source );
    (*Target) = LsapAllocateLsaHeap( Length );
    if ((*Target == NULL)) {
        return(STATUS_NO_MEMORY);
    }

    RtlMoveMemory( (*Target), Source, Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
LsapAuCopySid(
    PSID *Target,
    PSID_AND_ATTRIBUTES Source,
    PULONG SourceProperties
    )

/*++

Routine Description:

    Copy or reference a SID.

    The SID may be referenced if the SourceProperties indicate it
    has been allocated.  In this case, the SourceProperties must be
    changed to indicate the SID is now a copy.


Arguments:

    Target - Recieves a pointer to the SID copy.

    Source - points to a SID_AND_ATTRIBUTES structure containing the SID
        to be copied.

    SourceProperties - Contains LSAP_AU_SID_PROP_Xxx flags providing
        information about the source.  In some cases, the source may
        be referenced instead of copied.

Return Value:

    STATUS_SUCCESS - The copy was successful.

    STATUS_NO_MEMORY - memory could not be allocated to perform the copy.

--*/

{
    ULONG Length;


    if ((*SourceProperties) & LSAP_AU_SID_PROP_ALLOCATED) {

        (*Target) = Source->Sid;
        (*SourceProperties) &= ~LSAP_AU_SID_PROP_ALLOCATED;
        (*SourceProperties) |= LSAP_AU_SID_PROP_COPY;

        return(STATUS_SUCCESS);
    }

    //
    // The SID needs to be copied ...
    //
    return LsapAuDuplicateSid(
                                Target,
                                Source->Sid
    );
}



NTSTATUS
LsapAuOpenSam(
    BOOLEAN DuringStartup
    )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:

    DuringStartup - TRUE if this is the call made during startup.  In that case,
        there is no need to wait on the SAM_STARTED_EVENT since the caller ensures
        that SAM is started before the call is made.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    NTSTATUS Status, IgnoreStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;


    if (LsapAuSamOpened == TRUE) {
        return(STATUS_SUCCESS);
    }

    Status = LsapOpenSamEx( DuringStartup );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // Set up the Built-In Domain Member Sid Information.
    //

    LsapBuiltinDomainSubCount = (*RtlSubAuthorityCountSid(LsapBuiltInDomainSid) + 1);
    LsapBuiltinDomainMemberSidLength = RtlLengthRequiredSid( LsapBuiltinDomainSubCount );

    //
    // Get the member Sid information for the account domain
    // and set the global variables related to this information.
    //

    Status = LsapGetAccountDomainInfo( &PolicyAccountDomainInfo );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    LsapAccountDomainSubCount =
        (*(RtlSubAuthorityCountSid( PolicyAccountDomainInfo->DomainSid ))) +
        (UCHAR)(1);
    LsapAccountDomainMemberSidLength =
        RtlLengthRequiredSid( (ULONG)LsapAccountDomainSubCount );

    //
    // Build typical SIDs for members of the BUILTIN and ACCOUNT domains.
    // These are used to build SIDs when API return only RIDs.
    // Don't bother setting the last RID to any particular value.
    // It is always changed before use.
    //

    LsapAccountDomainMemberSid = LsapAllocateLsaHeap( LsapAccountDomainMemberSidLength );
    if (LsapAccountDomainMemberSid != NULL) {
        LsapBuiltinDomainMemberSid = LsapAllocateLsaHeap( LsapBuiltinDomainMemberSidLength );
        if (LsapBuiltinDomainMemberSid == NULL) {

            LsapFreeLsaHeap( LsapAccountDomainMemberSid );

            LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyAccountDomainInformation,
                (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

            return STATUS_NO_MEMORY ;
        }
    }
    else
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

        return STATUS_NO_MEMORY ;
    }

    IgnoreStatus = RtlCopySid( LsapAccountDomainMemberSidLength,
                                LsapAccountDomainMemberSid,
                                PolicyAccountDomainInfo->DomainSid);
    ASSERT(NT_SUCCESS(IgnoreStatus));
    (*RtlSubAuthorityCountSid(LsapAccountDomainMemberSid))++;

    IgnoreStatus = RtlCopySid( LsapBuiltinDomainMemberSidLength,
                                LsapBuiltinDomainMemberSid,
                                LsapBuiltInDomainSid);
    ASSERT(NT_SUCCESS(IgnoreStatus));
    (*RtlSubAuthorityCountSid(LsapBuiltinDomainMemberSid))++;


    //
    // Free the ACCOUNT domain information
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyAccountDomainInformation,
        (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

    if (NT_SUCCESS(Status)) {
        LsapAuSamOpened = TRUE;
    }

    return(Status);
}




BOOLEAN
LsapIsSidLogonSid(
    PSID Sid
    )
/*++

Routine Description:

    Test to see if the provided sid is a LOGON_ID.
    Such sids start with S-1-5-5 (see ntseapi.h for more on logon sids).



Arguments:

    Sid - Pointer to SID to test.  The SID is assumed to be a valid SID.


Return Value:

    TRUE - Sid is a logon sid.

    FALSE - Sid is not a logon sid.

--*/
{
    SID *ISid;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    ISid = Sid;


    //
    // if the identifier authority is SECURITY_NT_AUTHORITY and
    // there are SECURITY_LOGON_IDS_RID_COUNT sub-authorities
    // and the first sub-authority is SECURITY_LOGON_IDS_RID
    // then this is a logon id.
    //


    if (ISid->SubAuthorityCount == SECURITY_LOGON_IDS_RID_COUNT) {
        if (ISid->SubAuthority[0] == SECURITY_LOGON_IDS_RID) {
            if (
              (ISid->IdentifierAuthority.Value[0] == NtAuthority.Value[0]) &&
              (ISid->IdentifierAuthority.Value[1] == NtAuthority.Value[1]) &&
              (ISid->IdentifierAuthority.Value[2] == NtAuthority.Value[2]) &&
              (ISid->IdentifierAuthority.Value[3] == NtAuthority.Value[3]) &&
              (ISid->IdentifierAuthority.Value[4] == NtAuthority.Value[4]) &&
              (ISid->IdentifierAuthority.Value[5] == NtAuthority.Value[5])
                ) {

                return(TRUE);
            }
        }
    }

    return(FALSE);

}


VOID
LsapAuSetLogonPrivilegeStates(
    IN SECURITY_LOGON_TYPE LogonType,
    IN ULONG PrivilegeCount,
    IN PLUID_AND_ATTRIBUTES Privileges
    )
/*++

Routine Description:

    This is an interesting routine.  Its purpose is to establish the
    intial state (enabled/disabled) of privileges.  This information
    comes from LSA, but we need to over-ride that information for the
    time being based upon logon type.

    Basically, without dynamic context tracking supported across the
    network, network logons have no way to enable privileges.  Therefore,
    we will enable all privileges for network logons.

    For interactive, service, and batch logons, the programs or utilities
    used are able to enable privileges when needed.  Therefore, privileges
    for these logon types will be disabled.

    Despite the rules above, the SeChangeNotifyPrivilege will ALWAYS
    be enabled if granted to a user (even for interactive, service, and
    batch logons).


Arguments:

    PrivilegeCount - The number of privileges being assigned for this
        logon.

    Privileges - The privileges, and their attributes, being assigned
        for this logon.


Return Value:

    None.

--*/
{


    ULONG
        i,
        NewAttributes;

    LUID
        ChangeNotify;


    //
    // Enable or disable all privileges according to logon type
    //

    if ((LogonType == Network) ||
        (LogonType == NetworkCleartext)) {
        NewAttributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
                         SE_PRIVILEGE_ENABLED);
    } else {
        NewAttributes = 0;
    }


    for (i=0; i<PrivilegeCount; i++) {
        Privileges[i].Attributes = NewAttributes;
    }



    //
    // Interactive, Service, and Batch need to have the
    // SeChangeNotifyPrivilege enabled.  Network already
    // has it enabled.
    //

    if ((LogonType == Network) ||
        (LogonType == NetworkCleartext)) {
        return;
    }


    ChangeNotify = RtlConvertLongToLuid(SE_CHANGE_NOTIFY_PRIVILEGE);

    for ( i=0; i<PrivilegeCount; i++) {
        if (RtlEqualLuid(&Privileges[i].Luid, &ChangeNotify) == TRUE) {
            Privileges[i].Attributes = (SE_PRIVILEGE_ENABLED_BY_DEFAULT |
                                        SE_PRIVILEGE_ENABLED);
        }
    }

    return;

}

BOOLEAN
CheckNullSessionAccess(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should restict null session access.
    in the registry under system\currentcontrolset\Control\Lsa\
    AnonymousIncludesEveryone indicating whether or not to restrict access.
    If the value is zero (or doesn't exist), we restrict anonymous by
    preventing Everyone and Network from entering the groups.

Arguments:

    none.

Return Value:

    TRUE - NullSession access is restricted.
    FALSE - NullSession access is not restricted.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG Flag;

    BOOLEAN fRestrictNullSessions = TRUE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        L"EveryoneIncludesAnonymous"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            Flag = (PULONG) KeyValueInformation->Data;

            if (*Flag != 0 ) {
                fRestrictNullSessions = FALSE;
            }
        }

    }
    NtClose(KeyHandle);

Cleanup:

    return fRestrictNullSessions;
}

BOOL
IsTerminalServerRA(
    VOID
    )
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));

    dwlConditionMask = VerSetConditionMask(dwlConditionMask, VER_SUITENAME, VER_AND);

    osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
    osVersionInfo.wSuiteMask = VER_SUITE_SINGLEUSERTS;

    return VerifyVersionInfo(
                  &osVersionInfo,
                  VER_SUITENAME,
                 dwlConditionMask);
}


BOOLEAN
IsTSUSerSidEnabled(
   VOID
   )
{
   NTSTATUS NtStatus;
   UNICODE_STRING KeyName;
   OBJECT_ATTRIBUTES ObjectAttributes;
   HANDLE KeyHandle;
   UCHAR Buffer[100];
   PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
   ULONG KeyValueLength = 100;
   ULONG ResultLength;
   PULONG Flag;


   BOOLEAN fIsTSUSerSidEnabled = TRUE;


   //
   // We don't add TSUserSid for Remote Admin mode of TS
   //
   if (IsTerminalServerRA() == TRUE) {
      return FALSE;
   }


   //
   // Check in the registry if TSUserSid should be added to
   // to the token
   //

   //
   // Open the Terminal Server key in the registry
   //

   RtlInitUnicodeString(
       &KeyName,
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server"
       );

   InitializeObjectAttributes(
       &ObjectAttributes,
       &KeyName,
       OBJ_CASE_INSENSITIVE,
       0,
       NULL
       );

   NtStatus = NtOpenKey(
               &KeyHandle,
               KEY_READ,
               &ObjectAttributes
               );

   if (!NT_SUCCESS(NtStatus)) {
       goto Cleanup;
   }


   RtlInitUnicodeString(
       &KeyName,
       L"TSUserEnabled"
       );

   NtStatus = NtQueryValueKey(
                   KeyHandle,
                   &KeyName,
                   KeyValuePartialInformation,
                   KeyValueInformation,
                   KeyValueLength,
                   &ResultLength
                   );


   if (NT_SUCCESS(NtStatus)) {

       //
       // Check that the data is the correct size and type - a ULONG.
       //

       if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
           (KeyValueInformation->Type == REG_DWORD)) {


           Flag = (PULONG) KeyValueInformation->Data;

           if (*Flag == 0) {
               fIsTSUSerSidEnabled = FALSE;
           }
       }

   }
   NtClose(KeyHandle);

Cleanup:

    return fIsTSUSerSidEnabled;

}

BOOLEAN
CheckAdminOwnerSetting(
    VOID
    )
/*++

Routine Description:

    This routine checks to see if we should set the default owner to the
    ADMINISTRATORS alias.  If the value is zero (or doesn't exist), then
    the ADMINISTRATORS alias will be set as the default owner (if present).
    Otherwise, no default owner is set.

Arguments:

    none.

Return Value:

    TRUE - If the ADMINISTRATORS alias is present, make it the default owner.
    FALSE - Do not set a default owner.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    UCHAR Buffer[100];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    ULONG KeyValueLength = 100;
    ULONG ResultLength;
    PULONG Flag;

    BOOLEAN fSetAdminOwner = TRUE;

    //
    // Open the Lsa key in the registry
    //

    RtlInitUnicodeString(
        &KeyName,
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Lsa"
        );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyName,
        OBJ_CASE_INSENSITIVE,
        0,
        NULL
        );

    NtStatus = NtOpenKey(
                &KeyHandle,
                KEY_READ,
                &ObjectAttributes
                );

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &KeyName,
        L"NoDefaultAdminOwner"
        );

    NtStatus = NtQueryValueKey(
                    KeyHandle,
                    &KeyName,
                    KeyValuePartialInformation,
                    KeyValueInformation,
                    KeyValueLength,
                    &ResultLength
                    );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Check that the data is the correct size and type - a ULONG.
        //

        if ((KeyValueInformation->DataLength >= sizeof(ULONG)) &&
            (KeyValueInformation->Type == REG_DWORD)) {


            Flag = (PULONG) KeyValueInformation->Data;

            if (*Flag != 0 ) {
                fSetAdminOwner = FALSE;
            }
        }

    }
    NtClose(KeyHandle);

Cleanup:

    return fSetAdminOwner;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\aulogon.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    aulogon.c

Abstract:

    This module provides the dispatch code for LsaLogonUser() and
    related logon support routines.

    This file does NOT include the LSA Filter/Augmentor logic.

Author:

    Jim Kelly (JimK) 11-Mar-1992

Revision History:

--*/

#include <lsapch2.h>
#include <msaudite.h>
#include <ntmsv1_0.h>
#include <limits.h>    // ULONG_MAX
#include "adtp.h"
#include "ntlsapi.h"


//
// Pointer to license server routines in ntlsapi.dll
//
PNT_LICENSE_REQUEST_W LsaNtLicenseRequestW = NULL;
PNT_LS_FREE_HANDLE LsaNtLsFreeHandle = NULL;

// #define LOGON_SESSION_TRACK 1

VOID LogonSessionLogWrite( PCHAR Format, ... );

#ifdef LOGON_SESSION_TRACK
#define LSLog( x )  LogonSessionLogWrite x
#else
#define LSLog( x )
#endif



NTSTATUS
LsaCallLicenseServer(
    IN PWCHAR LogonProcessName,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName OPTIONAL,
    IN BOOLEAN IsAdmin,
    OUT HANDLE *LicenseHandle
    )

/*++

Routine Description:

    This function loads the license server DLL and calls it to indicate the
    specified logon process has successfully authenticated the specified user.

Arguments:

    LogonProcessName - Name of the process authenticating the user.

    AccountName - Name of the account authenticated.

    DomainName - Name of the domain containing AccountName

    IsAdmin - TRUE if the logged on user is an administrator

    LicenseHandle - Returns a handle to the LicenseServer that must be
        closed when the session goes away.  INVALID_HANDLE_VALUE is returned
        if the handle need not be closed.

Return Value:

    None.


--*/

{
    NTSTATUS Status;

    NT_LS_DATA NtLsData;
    ULONG BufferSize;
    LPWSTR Name;
    LS_STATUS_CODE LsStatus;
    LS_HANDLE LsHandle;

    static enum {
            FirstCall,
            DllMissing,
            DllLoaded } DllState = FirstCall ;

    HINSTANCE DllHandle;


    //
    // Initialization
    //

    NtLsData.DataType = NT_LS_USER_NAME;
    NtLsData.Data = NULL;
    NtLsData.IsAdmin = IsAdmin;
    *LicenseHandle = INVALID_HANDLE_VALUE;


    //
    // Load the license server DLL if this is the first call to this routine.
    //


    if ( DllState == FirstCall ) {

        //
        // Load the DLL
        //

        DllHandle = LoadLibraryA( "ntlsapi" );

        if ( DllHandle == NULL ) {
            DllState = DllMissing;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Find the License routine
        //


        LsaNtLicenseRequestW = (PNT_LICENSE_REQUEST_W)
            GetProcAddress(DllHandle, "NtLicenseRequestW");

        if ( LsaNtLicenseRequestW == NULL ) {
            DllState = DllMissing;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Find the License handle free routine
        //


        LsaNtLsFreeHandle = (PNT_LS_FREE_HANDLE)
            GetProcAddress(DllHandle, "NtLSFreeHandle");

        if ( LsaNtLsFreeHandle == NULL ) {
            DllState = DllMissing;
            LsaNtLicenseRequestW = NULL;
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        DllState = DllLoaded;

    //
    // Ensure the Dll was loaded on a previous call
    //
    } else if ( DllState != DllLoaded ) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }




    //
    // Allocate a buffer for the combined DomainName\UserName
    //

    BufferSize = AccountName->Length + sizeof(WCHAR);
    if ( DomainName != NULL && DomainName->Length != 0 ) {
        BufferSize += DomainName->Length + sizeof(WCHAR);
    }

    NtLsData.Data = LsapAllocateLsaHeap( BufferSize );

    if ( NtLsData.Data == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the DomainName\UserName
    //

    Name = (LPWSTR)(NtLsData.Data);

    if ( DomainName != NULL && DomainName->Length != 0 ) {
        RtlCopyMemory( Name,
                       DomainName->Buffer,
                       DomainName->Length );
        Name += DomainName->Length / sizeof(WCHAR);
        *Name = L'\\';
        Name++;
    }

    RtlCopyMemory( Name,
                   AccountName->Buffer,
                   AccountName->Length );
    Name += AccountName->Length / sizeof(WCHAR);
    *Name = L'\0';


    //
    // Call the license server.
    //

    LsStatus = (*LsaNtLicenseRequestW)(
                    LogonProcessName,
                    NULL,
                    &LsHandle,
                    &NtLsData );

    switch (LsStatus) {
    case LS_SUCCESS:
        Status = STATUS_SUCCESS;
        *LicenseHandle = (HANDLE) LsHandle;
        break;

    case LS_INSUFFICIENT_UNITS:
        Status = STATUS_LICENSE_QUOTA_EXCEEDED;
        break;

    case LS_RESOURCES_UNAVAILABLE:
        Status = STATUS_NO_MEMORY;
        break;

    default:
        //
        // Unavailability of the license server isn't fatal.
        //
        Status = STATUS_SUCCESS;
        break;
    }



    //
    // Cleanup and return.
    //
Cleanup:
    if ( NtLsData.Data != NULL ) {
        LsapFreeLsaHeap( NtLsData.Data );
    }

    return Status;
}




VOID
LsaFreeLicenseHandle(
    IN HANDLE LicenseHandle
    )

/*++

Routine Description:

    Free a handle returned by LsaCallLicenseServer.

Arguments:

    LicenseHandle - Handle returned to license for this logon session.

Return Value:

    None.


--*/

{
    if ( LsaNtLsFreeHandle != NULL && LicenseHandle != INVALID_HANDLE_VALUE ) {
        LS_HANDLE LsHandle;
        LsHandle = (LS_HANDLE) LicenseHandle;
        (*LsaNtLsFreeHandle)( LsHandle );
    }
}




BOOLEAN
LsapSidPresentInGroups(
    IN PTOKEN_GROUPS TokenGroups,
    IN SID * Sid
    )
/*++

Purpose:

    Determines whether the given SID is present in the given groups

Parameters:

    TokenGroups    groups to check
    Sid            SID to look for

Returns:

    TRUE if yes
    FALSE if no

--*/
{
    ULONG i;

    if ( Sid == NULL ||
         TokenGroups == NULL ) {

        return FALSE;
    }


    for ( i = 0; i < TokenGroups->GroupCount; i++ ) {

        if ( RtlEqualSid(
                 Sid,
                 TokenGroups->Groups[i].Sid)) {

            return( 0 != ( TokenGroups->Groups[i].Attributes & SE_GROUP_ENABLED ));
        }
    }

    return FALSE;
}


VOID
LsapUpdateNamesAndCredentials(
    IN SECURITY_LOGON_TYPE ActiveLogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials
    )
{
    PLSAP_LOGON_SESSION  LogonSession    = NULL;
    PLSAP_DS_NAME_MAP    pUpnMap         = NULL;
    PLSAP_DS_NAME_MAP    pDnsMap         = NULL;
    UNICODE_STRING       OldUpn          = PrimaryCredentials->Upn;
    UNICODE_STRING       OldDnsName      = PrimaryCredentials->DnsDomainName;
    NTSTATUS             Status;


    //
    // Stuff the UPN and DnsDomainName into the PrimaryCredentials if necessary
    // so they're available to the packages.
    //

    if (OldDnsName.Length == 0 || OldUpn.Length == 0)
    {
        LogonSession = LsapLocateLogonSession(&PrimaryCredentials->LogonId);

        if (LogonSession == NULL)
        {
            ASSERT(LogonSession != NULL);
            return;
        }

        if (OldDnsName.Length == 0)
        {
            Status = LsapGetNameForLogonSession(LogonSession,
                                                NameDnsDomain,
                                                &pDnsMap,
                                                TRUE);

            if (NT_SUCCESS(Status))
            {
                PrimaryCredentials->DnsDomainName = pDnsMap->Name;
            }
        }

        if (OldUpn.Length == 0)
        {
            Status = LsapGetNameForLogonSession(LogonSession,
                                                NameUserPrincipal,
                                                &pUpnMap,
                                                TRUE);

            if (NT_SUCCESS(Status))
            {
                PrimaryCredentials->Upn = pUpnMap->Name;
            }
        }

        LsapReleaseLogonSession(LogonSession);
        LogonSession = NULL;
    }
        
    LsapUpdateCredentialsWorker(ActiveLogonType,
                                AccountName,
                                PrimaryCredentials,
                                Credentials);

    PrimaryCredentials->DnsDomainName = OldDnsName;
    PrimaryCredentials->Upn           = OldUpn;

    ASSERT(LogonSession == NULL);

    if (pDnsMap != NULL)
    {
        LsapDerefDsNameMap(pDnsMap);
    }

    if (pUpnMap != NULL)
    {
        LsapDerefDsNameMap(pUpnMap);
    }
}


NTSTATUS
LsapAuApiDispatchLogonUser(
    IN OUT PLSAP_CLIENT_REQUEST ClientRequest
    )

/*++

Routine Description:

    This function is the dispatch routine for LsaLogonUser().

Arguments:

    Request - Represents the client's LPC request message and context.
        The request message contains a LSAP_LOGON_USER_ARGS message
        block.

Return Value:

    In addition to the status values that an authentication package
    might return, this routine will return the following:

    STATUS_NO_SUCH_PACKAGE - The specified authentication package is
        unknown to the LSA.


--*/

{
    NTSTATUS Status, TmpStatus, IgnoreStatus;
    PLSAP_LOGON_USER_ARGS Arguments;
    PVOID LocalAuthenticationInformation;    // Receives a copy of authentication information
    PTOKEN_GROUPS ClientTokenGroups;
    PVOID TokenInformation = NULL ;
    LSA_TOKEN_INFORMATION_TYPE TokenInformationType = 0;
    LSA_TOKEN_INFORMATION_TYPE OriginalTokenType = LsaTokenInformationNull;
    PLSA_TOKEN_INFORMATION_V2 TokenInformationV2;
    PLSA_TOKEN_INFORMATION_NULL TokenInformationNull;
    HANDLE Token = INVALID_HANDLE_VALUE ;
    PUNICODE_STRING AccountName = NULL;
    PUNICODE_STRING AuthenticatingAuthority = NULL;
    PUNICODE_STRING WorkstationName = NULL;
    PSID UserSid = NULL;
    LUID AuthenticationId;
    PPRIVILEGE_SET PrivilegesAssigned = NULL;
    BOOLEAN CallLicenseServer;
    PSession Session;
    PLSAP_SECURITY_PACKAGE AuthPackage;
    PLSAP_SECURITY_PACKAGE SupplementalPackage;
    ULONG LogonOrdinal;
    SECPKG_CLIENT_INFO ClientInfo;
    SECPKG_PRIMARY_CRED PrimaryCredentials;
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY Credentials = NULL;
    SECURITY_LOGON_TYPE ActiveLogonType;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    PROCESS_SESSION_INFORMATION SessionInfo;
    HANDLE hClientProcess;
    BOOLEAN fUsedSubAuthEx = FALSE;
    QUOTA_LIMITS QuotaLimits;
    BOOLEAN fHasTcbPrivilege;
    LUID LocalServiceLuid   = LOCALSERVICE_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

#endif  // _WIN64


    //
    // allow untrusted clients to call this API in a limited fashion.
    // save the untrusted indicator for later use.
    //

    Status = LsapGetClientInfo(
                &ClientInfo
                );

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }


    //
    // client is not required to hold SeTcbPrivilege if supplemental groups
    // not supplied.
    //

    fHasTcbPrivilege = ClientInfo.HasTcbPrivilege;



    //
    // MultiUser NT(HYDRA). Query the Client Process's SessionID
    //

    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    ClientId.UniqueProcess = (HANDLE)LongToHandle(ClientInfo.ProcessID);
    ClientId.UniqueThread = (HANDLE)NULL;

    Status = NtOpenProcess(
                 &hClientProcess,
                 (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
                 &Obja,
                 &ClientId
                 );

    if( !NT_SUCCESS(Status) ) {
       ASSERT( NT_SUCCESS(Status) );
       return Status;
    }


    Status = NtQueryInformationProcess(
                 hClientProcess,
                 ProcessSessionInformation,
                 &SessionInfo,
                 sizeof(SessionInfo),
                 NULL
                 );

    NtClose(hClientProcess);

    if (!NT_SUCCESS(Status)) {
       ASSERT( NT_SUCCESS(Status) );
       return(Status);
    }


    RtlZeroMemory(
        &PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    Arguments = &ClientRequest->Request->Arguments.LogonUser;

    Arguments->ProfileBuffer = NULL;

    //
    // Determine if the LicenseServer should be called.
    //  Turn off the flag to prevent confusing any other logic below.
    //

    if ( Arguments->AuthenticationPackage & LSA_CALL_LICENSE_SERVER ) {
        Arguments->AuthenticationPackage &= ~LSA_CALL_LICENSE_SERVER ;
        CallLicenseServer = TRUE;
    } else {
        CallLicenseServer = FALSE;
    }


    //
    // Map an unlock logon into an interactive logon
    //

    ActiveLogonType = Arguments->LogonType;
    if (ActiveLogonType == Unlock) {
        ActiveLogonType = Interactive;
    }



    //
    // Get the address of the package to call
    //

    LogonOrdinal = SP_ORDINAL_LOGONUSEREX2;
    AuthPackage = SpmpValidRequest(
                    Arguments->AuthenticationPackage,
                    LogonOrdinal
                    );

    if (AuthPackage == NULL)
    {
        LogonOrdinal = SP_ORDINAL_LOGONUSEREX;
        AuthPackage = SpmpValidRequest(
                        Arguments->AuthenticationPackage,
                        LogonOrdinal
                        );
        if (AuthPackage == NULL)
        {
            LogonOrdinal = SP_ORDINAL_LOGONUSER;
            AuthPackage = SpmpValidRequest(
                            Arguments->AuthenticationPackage,
                            LogonOrdinal
                            );

            if (AuthPackage == NULL) {
                return( STATUS_NOT_SUPPORTED );
            }
        }

    }

    SetCurrentPackageId(AuthPackage->dwPackageID);



    //
    // Fetch a copy of the authentication information from the client's
    // address space.
    //

    if (Arguments->AuthenticationInformationLength != 0) {

        LocalAuthenticationInformation =
            LsapAllocateLsaHeap( Arguments->AuthenticationInformationLength );
        if (LocalAuthenticationInformation == NULL) {
            return(STATUS_NO_MEMORY);
        }

        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     Arguments->AuthenticationInformationLength,
                     LocalAuthenticationInformation,
                     Arguments->AuthenticationInformation
                     );

        if ( !NT_SUCCESS(Status) ) {

            LsapFreeLsaHeap( LocalAuthenticationInformation );

            DbgPrint("LSA/LogonUser(): Failed to retrieve Auth. Info. %lx\n",Status);

            return Status;
        }

    } else {
        LocalAuthenticationInformation = NULL;
    }


    //
    // Capture the local groups ( a rather complicated task ).
    //

    ClientTokenGroups = Arguments->LocalGroups; // Save so we can restore it later
    Arguments->LocalGroups = NULL;


    if( ClientTokenGroups != NULL ) {
        if( fHasTcbPrivilege ) {

            Status = LsapCaptureClientTokenGroups(
                         ClientRequest,
                         Arguments->LocalGroupsCount,
                         ClientTokenGroups,
                         (PTOKEN_GROUPS *)&Arguments->LocalGroups
                         );
        } else {

            //
            // callers that don't hold SeTcbPrivilege cannot supply additional
            // groups.
            //

            Status = STATUS_ACCESS_DENIED;
        }

    } else {

        //
        // build the Logon and Local Sid.
        //

        Status = LsapBuildDefaultTokenGroups(
                        Arguments
                        );

    }



    if ( !NT_SUCCESS(Status) ) {
        DbgPrint("LSA/LogonUser(): Failed to retrieve local groups %lx\n",Status);
        LsapFreeLsaHeap( LocalAuthenticationInformation );
        return Status;
    }


    // HACK for ARAP: If we are calling MSV and we are doing SubAuthEx, do
    // not delete the profile buffer.

    if (AuthPackage->Name.Length == MSV1_0_PACKAGE_NAMEW_LENGTH)
    {
        if (wcscmp(AuthPackage->Name.Buffer, MSV1_0_PACKAGE_NAMEW) == 0)
        {
            PMSV1_0_LM20_LOGON TempAuthInfo = (PMSV1_0_LM20_LOGON) LocalAuthenticationInformation;

            if (TempAuthInfo->MessageType == MsV1_0SubAuthLogon)
            {
                fUsedSubAuthEx = TRUE;
            }
        }
    }

    //
    // Now call the package...
    //
    //
    // Once the authentication package returns success from this
    // call, it is LSA's responsibility to clean up the logon
    // session when it is no longer needed.  This is true whether
    // the logon fails due to other constraints, or because the
    // user ultimately logs off.
    //

    try {

        if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX2)
        {

            Status = (AuthPackage->FunctionTable.LogonUserEx2)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority,
                                       &WorkstationName,
                                       &PrimaryCredentials,
                                       &Credentials
                                       );
        } else if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX)
        {

            Status = (AuthPackage->FunctionTable.LogonUserEx)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority,
                                       &WorkstationName
                                       );
        } else if (LogonOrdinal == SP_ORDINAL_LOGONUSER) {

            //
            // We checked to make sure that at least one of these was exported
            // from the package, so we know we can call this if LsapApLogonUserEx
            // doesn't exist.
            //

            Status = (AuthPackage->FunctionTable.LogonUser)(
                                      (PLSA_CLIENT_REQUEST)ClientRequest,
                                       ActiveLogonType,
                                       LocalAuthenticationInformation,
                                       Arguments->AuthenticationInformation,    //client base
                                       Arguments->AuthenticationInformationLength,
                                       &Arguments->ProfileBuffer,
                                       &Arguments->ProfileBufferLength,
                                       &Arguments->LogonId,
                                       &Arguments->SubStatus,
                                       &TokenInformationType,
                                       &TokenInformation,
                                       &AccountName,
                                       &AuthenticatingAuthority
                                       );
        }
    } except(SP_EXCEPTION) {
        Status = GetExceptionCode();
        Status = SPException(Status, AuthPackage->dwPackageID);

    }

    SetCurrentPackageId( IntToPtr(SPMGR_ID) );

    //
    // Free the local copy of the authentication information
    //

    if (LocalAuthenticationInformation != NULL) {
        LsapFreeLsaHeap( LocalAuthenticationInformation );
    }


    AuthenticationId = Arguments->LogonId;

    if ( !NT_SUCCESS(Status) ) {
        LsapFreeTokenGroups( Arguments->LocalGroups );
        Arguments->LocalGroups = ClientTokenGroups;   // Restore to client's value

        // HACK for ARAP: If we are calling MSV and we are doing SubAuthEx,
        // do not delete the profile buffer.

        if (!fUsedSubAuthEx)
        {
            LsapClientFree(
                Arguments->ProfileBuffer
                );
            Arguments->ProfileBuffer = NULL;
        }

        goto Done;
    }

    //
    // Build the PrimaryCredentials structure if we didn't get it from logon
    //

    if (LogonOrdinal != SP_ORDINAL_LOGONUSEREX2)
    {
        PrimaryCredentials.LogonId = AuthenticationId;
        PrimaryCredentials.DomainName = *AuthenticatingAuthority;
        PrimaryCredentials.DownlevelName = *AccountName;
    }

    if ((PrimaryCredentials.Flags & PRIMARY_CRED_PACKAGE_MASK) != 0)
    {
        ULONG RealLogonPackage;

        //
        // If the caller indicated that another package did the logon,
        // reset the logon package in the logon session.
        //

        RealLogonPackage = PrimaryCredentials.Flags >> PRIMARY_CRED_LOGON_PACKAGE_SHIFT;
        //
        // Locate the packge by RPC id
        //

        SupplementalPackage = SpmpLookupPackageByRpcId( RealLogonPackage );

        if (SupplementalPackage != NULL) {

            PLSAP_LOGON_SESSION LogonSession;

            //
            // Locate the logon session
            //

            LogonSession = LsapLocateLogonSession(
                            &Arguments->LogonId
                            );
            //
            // Update the creating package
            //

            if (LogonSession != NULL) {

                LogonSession->CreatingPackage = SupplementalPackage->dwPackageID;

                LsapReleaseLogonSession( LogonSession );
            }
        }
    }

    OriginalTokenType = TokenInformationType;

    //
    // Pass the token information through the Local Security Policy
    // Filter/Augmentor.  This may cause some or all of the token
    // information to be replaced/augmented.
    //

    Status = LsapAuUserLogonPolicyFilter(
                 ActiveLogonType,
                 &TokenInformationType,
                 &TokenInformation,
                 Arguments->LocalGroups,
                 &QuotaLimits,
                 &PrivilegesAssigned
                 );

    if(Arguments->LocalGroups)
    {
        // We don't need these anymore
        LsapFreeTokenGroups( Arguments->LocalGroups );
    }

    Arguments->LocalGroups = ClientTokenGroups;   // Restore to client's value

#if _WIN64

    //
    // QUOTA_LIMITS structure contains SIZE_Ts, which are
    // smaller on 32-bit.  Make sure we don't overflow the
    // client's buffer.
    //

    LsapGetCallInfo(&CallInfo);

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PQUOTA_LIMITS_WOW64  pQuotaLimitsWOW64 = (PQUOTA_LIMITS_WOW64) &Arguments->Quotas;

        pQuotaLimitsWOW64->PagedPoolLimit        = (ULONG) min(ULONG_MAX, QuotaLimits.PagedPoolLimit);
        pQuotaLimitsWOW64->NonPagedPoolLimit     = (ULONG) min(ULONG_MAX, QuotaLimits.NonPagedPoolLimit);
        pQuotaLimitsWOW64->MinimumWorkingSetSize = (ULONG) min(ULONG_MAX, QuotaLimits.MinimumWorkingSetSize);
        pQuotaLimitsWOW64->MaximumWorkingSetSize = (ULONG) min(ULONG_MAX, QuotaLimits.MaximumWorkingSetSize);
        pQuotaLimitsWOW64->PagefileLimit         = (ULONG) min(ULONG_MAX, QuotaLimits.PagefileLimit);
        pQuotaLimitsWOW64->TimeLimit             = QuotaLimits.TimeLimit;
    }
    else
    {

#endif  // _WIN64

        Arguments->Quotas = QuotaLimits;

#if _WIN64

    }

#endif

    if ( !NT_SUCCESS(Status) ) {

        //
        // Notify the logon package so it can clean up its
        // logon session information.
        //

        (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );

        //
        // And delete the logon session
        //

        IgnoreStatus = LsapDeleteLogonSession( &Arguments->LogonId );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Free up the TokenInformation buffer and ProfileBuffer
        // and return the error.
        //

        IgnoreStatus =
            LsapClientFree(
                Arguments->ProfileBuffer
                );
        Arguments->ProfileBuffer = NULL;

        switch ( TokenInformationType ) {
        case LsaTokenInformationNull:
            LsapFreeTokenInformationNull(
                (PLSA_TOKEN_INFORMATION_NULL)TokenInformation
                );
            break;


        case LsaTokenInformationV1:
            LsapFreeTokenInformationV1(
                (PLSA_TOKEN_INFORMATION_V1)TokenInformation
                );
            break;

        case LsaTokenInformationV2:
            LsapFreeTokenInformationV2(
                (PLSA_TOKEN_INFORMATION_V2)TokenInformation
                );
            break;
        }

        goto Done;
    }

    //
    // Check if we only allow admins to logon.  We do allow null session
    // connections since they are severly restricted, though. Since the
    // token type may have been changed, we use the token type originally
    // returned by the package.
    //

    if (LsapAllowAdminLogonsOnly &&
        ((OriginalTokenType == LsaTokenInformationV1) ||
        (OriginalTokenType == LsaTokenInformationV2) ) &&
        !RtlEqualLuid(&Arguments->LogonId, &LocalServiceLuid) &&
        !RtlEqualLuid(&Arguments->LogonId, &NetworkServiceLuid) &&
        !LsapSidPresentInGroups(
            ((PLSA_TOKEN_INFORMATION_V2) TokenInformation)->Groups,
            (SID *)LsapAliasAdminsSid))
    {
        //
        // Set the status to be invalid workstation, since all accounts
        // except administrative ones are locked out for this
        // workstation.
        //

        Arguments->SubStatus = STATUS_INVALID_WORKSTATION;
        Status = STATUS_ACCOUNT_RESTRICTION;
        //
        // Notify the logon package so it can clean up its
        // logon session information.
        //

        (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );

        //
        // And delete the logon session
        //

        IgnoreStatus = LsapDeleteLogonSession( &Arguments->LogonId );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

        //
        // Free up the TokenInformation buffer and ProfileBuffer
        // and return the error.
        //

        IgnoreStatus =
            LsapClientFree(
                Arguments->ProfileBuffer
                );
        Arguments->ProfileBuffer = NULL;

        switch ( TokenInformationType ) {
        case LsaTokenInformationNull:
            LsapFreeTokenInformationNull(
                (PLSA_TOKEN_INFORMATION_NULL)TokenInformation
                );
            break;


        case LsaTokenInformationV1:
            LsapFreeTokenInformationV1(
                (PLSA_TOKEN_INFORMATION_V1)TokenInformation
                );
            break;

        case LsaTokenInformationV2:
            LsapFreeTokenInformationV2(
                (PLSA_TOKEN_INFORMATION_V2)TokenInformation
                );
            break;

        }

        goto Done;
    }
    //
    // Call the LicenseServer
    //

    if ( CallLicenseServer ) {

        PLSAP_LOGON_SESSION LogonSession;
        HANDLE LicenseHandle;
        BOOLEAN IsAdmin = FALSE;

        //
        // Determine if we're logged on as administrator.
        //
        if ((( TokenInformationType == LsaTokenInformationV1) ||
             ( TokenInformationType == LsaTokenInformationV2))&&
            ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Owner.Owner != NULL &&
            RtlEqualSid(
                ((PLSA_TOKEN_INFORMATION_V2)TokenInformation)->Owner.Owner,
                LsapAliasAdminsSid ) ) {

            IsAdmin = TRUE;

        }

        //
        // Call the license server.
        //


        Session = (PSession) TlsGetValue(dwSession);

        Status = LsaCallLicenseServer(
                    (Session->ClientProcessName != NULL) ? Session->ClientProcessName : L"",
                    AccountName,
                    AuthenticatingAuthority,
                    IsAdmin,
                    &LicenseHandle );

        if ( !NT_SUCCESS(Status) ) {

            //
            // Notify the logon package so it can clean up its
            // logon session information.
            //

            (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );

            //
            // And delete the logon session
            //

            IgnoreStatus = LsapDeleteLogonSession( &Arguments->LogonId );
            ASSERT( NT_SUCCESS(IgnoreStatus) );

            //
            // Free up the TokenInformation buffer and ProfileBuffer
            // and return the error.
            //

            IgnoreStatus =
                LsapClientFree(
                    Arguments->ProfileBuffer
                    );
            Arguments->ProfileBuffer = NULL;


            switch ( TokenInformationType ) {
            case LsaTokenInformationNull:
                LsapFreeTokenInformationNull(
                    (PLSA_TOKEN_INFORMATION_NULL)TokenInformation
                    );
                break;


            case LsaTokenInformationV1:
                LsapFreeTokenInformationV1(
                    (PLSA_TOKEN_INFORMATION_V1)TokenInformation
                    );
                break;

            case LsaTokenInformationV2:
                LsapFreeTokenInformationV2(
                    (PLSA_TOKEN_INFORMATION_V2)TokenInformation
                    );
                break;

            }

            goto Done;
        }

        //
        // Save the LicenseHandle in the LogonSession so we can close the
        //  handle on logoff.
        //
        LogonSession = LsapLocateLogonSession ( &Arguments->LogonId );

        if ( LogonSession != NULL ) {

            LogonSession->LicenseHandle = LicenseHandle;

            LsapReleaseLogonSession( LogonSession );
        }

        //
        // If we couldn't save the handle,
        //  close it now.
        //
        if ( LogonSession == NULL ) {
            LsaFreeLicenseHandle( LicenseHandle );
        }

    }



    //
    // Case on the token information returned (and subsequently massaged)
    // to create the correct kind of token.
    //

    switch (TokenInformationType) {

    case LsaTokenInformationNull:

        TokenInformationNull = TokenInformation;

        //
        // The user hasn't logged on to any particular account.
        // An impersonation token with WORLD as owner
        // will be created.
        //


        Status = LsapCreateNullToken(
                     &Arguments->LogonId,
                     &Arguments->SourceContext,
                     TokenInformationNull,
                     &Token
                     );


        //
        // Deallocate all the heap that was passed back from the
        // authentication package via the TokenInformation buffer.
        //

        UserSid = NULL;

        LsapFreeTokenInformationNull( TokenInformationNull );


        break;




    case LsaTokenInformationV1:
    case LsaTokenInformationV2:
        TokenInformationV2 = TokenInformation;


        //
        // Copy out the User Sid
        //

        if ( NT_SUCCESS( Status )) {

            Status = LsapDuplicateSid(
                         &UserSid,
                         TokenInformationV2->User.User.Sid
                         );

            if ( !NT_SUCCESS( Status )) {

                break;
            }
        }
        //
        // the type of token created depends upon the type of logon
        // being requested:
        //
        // Batch, Interactive, Service, (Unlock), and NewCredentials
        // all get a Primary token.  Network and NetworkCleartext
        // get an ImpersonationToken.
        //
        //

        if ( ( ActiveLogonType != Network ) &&
             ( ActiveLogonType != NetworkCleartext ) ) {

            //
            // Primary token
            //

            Status = LsapCreateV2Token(
                         &Arguments->LogonId,
                         &Arguments->SourceContext,
                         TokenInformationV2,
                         TokenPrimary,
                         SecurityImpersonation,
                         &Token
                         );


        } else {

            //
            // Impersonation token
            //

            Status = LsapCreateV2Token(
                         &Arguments->LogonId,
                         &Arguments->SourceContext,
                         TokenInformationV2,
                         TokenImpersonation,
                         SecurityImpersonation,
                         &Token
                         );


        }




        //
        // Deallocate all the heap that was passed back from the
        // authentication package via the TokenInformation buffer.
        //

        if(TokenInformationType == LsaTokenInformationV2)
        {
            LsapFreeTokenInformationV2( TokenInformation );
        }
        else
        {
            LsapFreeTokenInformationV1( TokenInformation );
        }


        break;

    }

    if ( !NT_SUCCESS(Status) ) {

        //
        // Notify the logon package so it can clean up its
        // logon session information.
        //

        (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );

        //
        // And delete the logon session.  Note, we could have failed creating
        // the logon session to begin with, so this may not work.
        //

        IgnoreStatus = LsapDeleteLogonSession( &Arguments->LogonId );

        IgnoreStatus =
            LsapClientFree(
                Arguments->ProfileBuffer
                );
        Arguments->ProfileBuffer = NULL;

        goto Done;

    }
    //
    // Multi-User NT (HYDRA). Ensure the new token has client's SessionId
    //
    else {

        PLSAP_LOGON_SESSION LogonSession;

        LogonSession = LsapLocateLogonSession( &Arguments->LogonId );

        if ( LogonSession )
        {
            LogonSession->Session = SessionInfo.SessionId ;

            LsapReleaseLogonSession( LogonSession );
        }

        Status = NtSetInformationToken( Token, TokenSessionId,
                               &(SessionInfo.SessionId), sizeof( ULONG ) );

        ASSERT( NT_SUCCESS(Status) );
    }


    //
    // Set the token on the session
    //

    if ( NT_SUCCESS(Status) ) {
        Status = LsapSetSessionToken( Token, &Arguments->LogonId );
    }



    //
    // Duplicate the token handle back into the calling process
    //

    if ( NT_SUCCESS(Status) ) {
        Status = LsapDuplicateHandle(
                    Token,
                    &Arguments->Token
                    );
    }

    IgnoreStatus = NtClose( Token );
    ASSERT( NT_SUCCESS(IgnoreStatus) );

    if ( !NT_SUCCESS(Status) ) {

        //
        // Notify the logon package so it can clean up its
        // logon session information.
        //

        (AuthPackage->FunctionTable.LogonTerminated)( &Arguments->LogonId );


        IgnoreStatus =
            LsapClientFree(
                Arguments->ProfileBuffer
                );
        Arguments->ProfileBuffer = NULL;

        goto Done;

    }

    //
    // Now call accept credentials for all packages that support it. We
    // don't do this for network logons because that requires delegation
    // which is not supported.
    //


    LSLog(( "Updating logon session %x:%x for logon type %d\n",
           PrimaryCredentials.LogonId.HighPart,
           PrimaryCredentials.LogonId.LowPart,
           ActiveLogonType ));

    if (ActiveLogonType != Network)
    {
        LsapUpdateNamesAndCredentials(ActiveLogonType,
                                      AccountName,
                                      &PrimaryCredentials,
                                      Credentials);
    }


Done:

    //
    // Audit the logon attempt.  The event type and logged information
    // will depend to some extent on the whether we failed and why.
    //

    if( AuthPackage )
    {
        SetCurrentPackageId(AuthPackage->dwPackageID);
    }

    if( (NT_SUCCESS(Status)) &&
        (OriginalTokenType == LsaTokenInformationNull) )
    {
        //
        // audit Null/Anonymous logon.
        //

        LsapAuditLogon(
                Status,
                Arguments->SubStatus,
                &WellKnownSids[LsapAnonymousSidIndex].Name,
                &WellKnownSids[LsapAnonymousSidIndex].DomainName,
                WorkstationName,
                UserSid,
                Arguments->LogonType,
                &Arguments->SourceContext,
                &AuthenticationId
                );

    } else {


        LsapAuditLogon(
                Status,
                Arguments->SubStatus,
                AccountName,
                AuthenticatingAuthority,
                WorkstationName,
                UserSid,
                Arguments->LogonType,
                &Arguments->SourceContext,
                &AuthenticationId
                );

    }

    SetCurrentPackageId( IntToPtr(SPMGR_ID) );

    if ( ( Status == STATUS_LOGON_FAILURE ) &&
         (( Arguments->SubStatus == STATUS_WRONG_PASSWORD ) ||
          ( Arguments->SubStatus == STATUS_NO_SUCH_USER   )) ) {

        //
        // Blow away the substatus, we don't want it to
        // get back to our caller.
        //

        Arguments->SubStatus = STATUS_SUCCESS;
    }
    
    //
    // The WorkstationName is only used by the audit, free it here.
    //

    if (WorkstationName != NULL) {
        if (WorkstationName->Buffer != NULL) {
            LsapFreeLsaHeap( WorkstationName->Buffer );
        }
        LsapFreeLsaHeap( WorkstationName );
    }

    TmpStatus = STATUS_SUCCESS;

    //
    // Audit special privilege assignment, if there were any
    //

    if ( PrivilegesAssigned != NULL ) {

        //
        // Examine the list of privileges being assigned, and
        // audit special privileges as appropriate.
        //

        if ( NT_SUCCESS( Status )) {
            LsapAdtAuditSpecialPrivileges( PrivilegesAssigned, AuthenticationId, UserSid );
        }

        MIDL_user_free( PrivilegesAssigned );
    }

    //
    // Set the logon session names.
    //

    if (NT_SUCCESS(Status)) {

        //
        // If the original was a null session, set the user name & domain name
        // to be anonymous. If the allocation fail, just use the original name
        //

        if (OriginalTokenType == LsaTokenInformationNull) {
            LPWSTR TempAccountName;
            LPWSTR TempAuthorityName;

            TempAccountName = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength);

            if (TempAccountName != NULL) {

                TempAuthorityName = (LPWSTR) LsapAllocateLsaHeap(WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength);

                if (TempAuthorityName != NULL) {

                    //
                    // Free the original names and copy the new names
                    // into the structures.
                    //

                    LsapFreeLsaHeap(AccountName->Buffer);
                    LsapFreeLsaHeap(AuthenticatingAuthority->Buffer);

                    AccountName->Buffer = TempAccountName;
                    AuthenticatingAuthority->Buffer = TempAuthorityName;

                    AccountName->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].Name.MaximumLength;
                    RtlCopyUnicodeString(
                        AccountName,
                        &WellKnownSids[LsapAnonymousSidIndex].Name
                        );

                    AuthenticatingAuthority->MaximumLength = WellKnownSids[LsapAnonymousSidIndex].DomainName.MaximumLength;
                    RtlCopyUnicodeString(
                        AuthenticatingAuthority,
                        &WellKnownSids[LsapAnonymousSidIndex].DomainName
                        );

                }
                else
                {
                    LsapFreeLsaHeap(TempAccountName);
                }
            }


        }

        TmpStatus = LsapSetLogonSessionAccountInfo(
                        &AuthenticationId,
                        AccountName,
                        AuthenticatingAuthority,
                        NULL,
                        &UserSid,
                        Arguments->LogonType,
                        ((LogonOrdinal == SP_ORDINAL_LOGONUSEREX2) ? &PrimaryCredentials : NULL)
                        );
    }

    if (LogonOrdinal == SP_ORDINAL_LOGONUSEREX2)
    {
        if (PrimaryCredentials.DownlevelName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
        }
        if (PrimaryCredentials.Password.Buffer != NULL)
        {
            RtlZeroMemory(
                PrimaryCredentials.Password.Buffer,
                PrimaryCredentials.Password.Length );

            LsapFreeLsaHeap(PrimaryCredentials.Password.Buffer);
        }
        if (PrimaryCredentials.DomainName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
        }
        if (PrimaryCredentials.UserSid != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.UserSid);
        }
        if (PrimaryCredentials.LogonServer.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
        }
        if (PrimaryCredentials.DnsDomainName.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.DnsDomainName.Buffer);
        }
        if (PrimaryCredentials.Upn.Buffer != NULL)
        {
            LsapFreeLsaHeap(PrimaryCredentials.Upn.Buffer);
        }
        if (Credentials != NULL)
        {
            LsapFreeLsaHeap(Credentials);
        }
    }

    //
    // If we already had an error, or we receive an error from setting the
    // logon , free any buffers related to the logon session.
    //

    if ((!NT_SUCCESS(Status)) || (!NT_SUCCESS(TmpStatus))) {

        if (AccountName != NULL) {
            if (AccountName->Buffer != NULL) {
                LsapFreeLsaHeap( AccountName->Buffer );
            }
            LsapFreeLsaHeap( AccountName );
            AccountName = NULL ;
        }

        if (AuthenticatingAuthority != NULL) {
            if (AuthenticatingAuthority->Buffer != NULL) {
                LsapFreeLsaHeap( AuthenticatingAuthority->Buffer );
            }
            LsapFreeLsaHeap( AuthenticatingAuthority );
            AuthenticatingAuthority = NULL ;
        }
    }

    if ( NT_SUCCESS( Status ) )
    {
        if ( AccountName )
        {
            LsapFreeLsaHeap( AccountName );
        }

        if ( AuthenticatingAuthority )
        {
            LsapFreeLsaHeap( AuthenticatingAuthority );
        }
    }

    if ( UserSid != NULL ) {
        LsapFreeLsaHeap( UserSid );
    }

    return Status;
}






NTSTATUS
LsapCreateNullToken(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull,
    OUT PHANDLE Token
    )

/*++

Routine Description:

    This function creates a token representing a null logon.

Arguments:

    LogonId - The logon ID to assign to the new token.

    TokenSource - Points to the value to use as the source of the token.

    TokenInformationNull - Information received from the authentication
        package authorizing this logon.

    Token - receives the new token's handle value.  The token is opened
        for TOKEN_ALL_ACCESS.


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    TOKEN_USER UserId;
    TOKEN_PRIMARY_GROUP PrimaryGroup;
    TOKEN_GROUPS GroupIds;
    TOKEN_PRIVILEGES Privileges;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;



        UserId.User.Sid = LsapWorldSid;
        UserId.User.Attributes = 0;
        GroupIds.GroupCount = 0;
        Privileges.PrivilegeCount = 0;
        PrimaryGroup.PrimaryGroup = LsapWorldSid;

        //
        // Set the object attributes to specify an Impersonation impersonation
        // level.
        //

        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
        ImpersonationQos.ImpersonationLevel = SecurityImpersonation;
        ImpersonationQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
        ImpersonationQos.EffectiveOnly = TRUE;
        ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
        ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

        Status = NtCreateToken(
                     Token,                    // Handle
                     (TOKEN_ALL_ACCESS),       // DesiredAccess
                     &ObjectAttributes,        // ObjectAttributes
                     TokenImpersonation,       // TokenType
                     LogonId,                  // Authentication LUID
                     &TokenInformationNull->ExpirationTime,
                                               // Expiration Time
                     &UserId,                  // User ID
                     &GroupIds,                // Group IDs
                     &Privileges,              // Privileges
                     NULL,                     // Owner
                     &PrimaryGroup,            // Primary Group
                     NULL,                     // Default Dacl
                     TokenSource               // TokenSource
                     );

        return Status;

}


NTSTATUS
LsapCreateV2Token(
    IN PLUID LogonId,
    IN PTOKEN_SOURCE TokenSource,
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2,
    IN TOKEN_TYPE TokenType,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    OUT PHANDLE Token
    )

/*++

Routine Description:

    This function creates a token from the information in a
    TOKEN_INFORMATION_V2 structure.

Arguments:

    LogonId - The logon ID to assign to the new token.

    TokenSource - Points to the value to use as the source of the token.

    TokenInformationV2 - Information received from the authentication
        package authorizing this logon.

    TokenType - The type of token (Primary or impersonation) to create.

    ImpersonationLevel - Level of impersonation to use for impersonation
        tokens.

    Token - receives the new token's handle value.  The token is opened
        for TOKEN_ALL_ACCESS.


Return Value:

    The status value of the NtCreateToken() call.



--*/

{
    NTSTATUS Status;

    PTOKEN_OWNER Owner;
    PTOKEN_DEFAULT_DACL Dacl;
    TOKEN_PRIVILEGES NoPrivileges;
    PTOKEN_PRIVILEGES Privileges;

    OBJECT_ATTRIBUTES ObjectAttributes;
    SECURITY_QUALITY_OF_SERVICE ImpersonationQos;
    ULONG AclLength ;
    PACL Acl = NULL ;
    PSession Session = GetCurrentSession();
    UCHAR   OwnerBuffer[ 64 ];
    UCHAR   UserBuffer[ 64 ];
    HANDLE ProcessToken ;
    PTOKEN_USER ProcessUser = NULL ;
    PTOKEN_OWNER ProcessOwner = NULL ;
    SECURITY_DESCRIPTOR SecDesc ;
    ULONG Size ;



    //
    // Set an appropriate Owner and DefaultDacl argument value
    //

    Owner = NULL;
    if ( TokenInformationV2->Owner.Owner != NULL ) {
        Owner = &TokenInformationV2->Owner;
    }

    Dacl = NULL;
    if ( TokenInformationV2->DefaultDacl.DefaultDacl !=NULL ) {
       Dacl = &TokenInformationV2->DefaultDacl;
    }

    if ( TokenInformationV2->Privileges == NULL ) {
       Privileges = &NoPrivileges;
       NoPrivileges.PrivilegeCount = 0;
    } else {
       Privileges = TokenInformationV2->Privileges;
    }


    //
    // Create the security descriptor for the token itself.
    //

    if ( Session )
    {
        LUID  LocalServiceLuid   = LOCALSERVICE_LUID;
        LUID  NetworkServiceLuid = NETWORKSERVICE_LUID;

        if (RtlEqualLuid(LogonId, &LocalServiceLuid)
             ||
            RtlEqualLuid(LogonId, &NetworkServiceLuid))
        {
            ProcessUser  = &TokenInformationV2->User;
            ProcessOwner = NULL;
        }
        else if ( OpenProcessToken( Session->hProcess,
                               TOKEN_QUERY,
                               &ProcessToken ) )
        {
            ProcessUser = (PTOKEN_USER) UserBuffer ;

            Status = NtQueryInformationToken( ProcessToken,
                                              TokenUser,
                                              ProcessUser,
                                              sizeof( UserBuffer ),
                                              &Size );
            if ( !NT_SUCCESS( Status ) )
            {
                ProcessUser = NULL ;
            }

            ProcessOwner = (PTOKEN_OWNER) OwnerBuffer ;

            Status = NtQueryInformationToken( ProcessToken,
                                              TokenOwner,
                                              ProcessOwner,
                                              sizeof( OwnerBuffer ),
                                              &Size );

            if ( !NT_SUCCESS( Status ) )
            {
                ProcessOwner = NULL ;
            }

            if ( ProcessOwner && ProcessUser )
            {
                if ( RtlEqualSid( ProcessOwner->Owner, ProcessUser->User.Sid ) )
                {
                    ProcessOwner = NULL ;
                }
            }

            NtClose( ProcessToken );
        }

        //
        // If this is a local system create, then the default object DACL is fine.  Skip
        // all this.  Otherwise, create the acl
        //

        //
        // stress failure exposed bug where ProcessUser is NULL due to
        // OpenProcessToken() failing.  If ProcessUser is NULL, assume
        // this is NOT system (since SYSTEM caller should not fail above).
        //

        if ( (ProcessUser == NULL) || !RtlEqualSid( ProcessUser->User.Sid, LsapLocalSystemSid ) )
        {
            AclLength = sizeof( ACL ) +
                        sizeof( ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapLocalSystemSid ) - sizeof( ULONG ) +
                        sizeof( ACCESS_ALLOWED_ACE ) +
                            RtlLengthSid( LsapAliasAdminsSid ) - sizeof( ULONG ) ;

            if ( ProcessOwner )
            {
                AclLength += sizeof( ACCESS_ALLOWED_ACE ) +
                                RtlLengthSid( ProcessOwner->Owner ) - sizeof( ULONG ) ;
            }

            if ( ProcessUser )
            {
                AclLength += sizeof( ACCESS_ALLOWED_ACE ) +
                                RtlLengthSid( ProcessUser->User.Sid ) - sizeof( ULONG );
            }

            Acl = LsapAllocatePrivateHeap( AclLength );

            if ( Acl )
            {
                RtlCreateAcl( Acl, AclLength, ACL_REVISION2 );

                RtlAddAccessAllowedAce( Acl,
                                        ACL_REVISION2,
                                        TOKEN_ALL_ACCESS,
                                        LsapLocalSystemSid );

                RtlAddAccessAllowedAce( Acl,
                                        ACL_REVISION2,
                                        TOKEN_READ,
                                        LsapAliasAdminsSid );

                if ( ProcessOwner )
                {
                    RtlAddAccessAllowedAce( Acl,
                                            ACL_REVISION2,
                                            TOKEN_ALL_ACCESS,
                                            ProcessOwner->Owner );
                }

                if ( ProcessUser )
                {
                    RtlAddAccessAllowedAce( Acl,
                                            ACL_REVISION2,
                                            TOKEN_ALL_ACCESS,
                                            ProcessUser->User.Sid );
                }

                RtlCreateSecurityDescriptor( &SecDesc,
                                             SECURITY_DESCRIPTOR_REVISION );

                RtlSetDaclSecurityDescriptor( &SecDesc,
                                              TRUE,
                                              Acl,
                                              FALSE );

                if ( ProcessOwner )
                {
                    RtlSetOwnerSecurityDescriptor( &SecDesc,
                                                   ProcessOwner->Owner,
                                                   FALSE );
                }
            }
        }
    }


    //
    // Create the token - The impersonation level is only looked at
    // if the token type is TokenImpersonation.
    //


    if ( Acl )
    {
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, &SecDesc );
    }
    else
    {
        InitializeObjectAttributes( &ObjectAttributes, NULL, 0, NULL, NULL );
    }

    ImpersonationQos.ImpersonationLevel = ImpersonationLevel;
    ImpersonationQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    ImpersonationQos.EffectiveOnly = FALSE;
    ImpersonationQos.Length = (ULONG)sizeof(SECURITY_QUALITY_OF_SERVICE);
    ObjectAttributes.SecurityQualityOfService = &ImpersonationQos;

    Status =
        NtCreateToken(
            Token,                                   // Handle
            (TOKEN_ALL_ACCESS),                      // DesiredAccess
            &ObjectAttributes,                       // ObjectAttributes
            TokenType,                               // TokenType
            LogonId,                                 // Authentication LUID
            &TokenInformationV2->ExpirationTime,     // Expiration Time
            &TokenInformationV2->User,               // User ID
            TokenInformationV2->Groups,              // Group IDs
            Privileges,                              // Privileges
            Owner,                                   // Owner
            &TokenInformationV2->PrimaryGroup,       // Primary Group
            Dacl,                                    // Default Dacl
            TokenSource                              // TokenSource
            );

    if ( Acl )
    {
        LsapFreePrivateHeap( Acl );
    }

    return Status;

}



NTSTATUS
LsapCaptureClientTokenGroups(
    IN PLSAP_CLIENT_REQUEST ClientRequest,
    IN ULONG GroupCount,
    IN PTOKEN_GROUPS ClientTokenGroups,
    OUT PTOKEN_GROUPS *CapturedTokenGroups
    )

/*++

Routine Description:

    This function retrieves a copy of a TOKEN_GROUPS structure from a
    client process.

    This is a messy operation because it involves so many virtual memory
    read requests.  First the variable length TOKEN_GROUPS structure must
    be retrieved.  Then, for each SID, the SID header must be retrieved
    so that the SubAuthorityCount can be used to calculate the length of
    the SID, which is susequently retrieved.

Arguments:

    ClientRequest - Identifies the client.

    GroupCount - Indicates the number of groups in the TOKEN_GROUPS.

    ClientTokenGroups - Points to a TOKEN_GROUPS structure to be captured from
        the client process.

    CapturedTokenGroups - Receives a pointer to the captured token groups.

Return Value:

    STATUS_INSUFFICIENT_RESOURCES - Indicates not enough resources are
        available to the LSA to handle the request right now.

    Any status value returned by LsapCopyFromClientBuffer().



--*/

{

    NTSTATUS Status;
    ULONG i, Length, RetrieveCount, SidHeaderLength;
    PTOKEN_GROUPS LocalGroups;
    PSID SidHeader, NextClientSid;


    if ( GroupCount == 0) {
        (*CapturedTokenGroups) = NULL;
        return STATUS_SUCCESS;
    }



    //
    // First the variable length TOKEN_GROUPS structure
    // is retrieved.
    //

    Length = (ULONG)sizeof(TOKEN_GROUPS)
             + GroupCount * (ULONG)sizeof(SID_AND_ATTRIBUTES)
             - ANYSIZE_ARRAY * (ULONG)sizeof(SID_AND_ATTRIBUTES);

    LocalGroups = LsapAllocatePrivateHeap( Length );
    (*CapturedTokenGroups) = LocalGroups;
    if ( LocalGroups == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = LsapCopyFromClientBuffer (
                 (PLSA_CLIENT_REQUEST)ClientRequest,
                 Length,
                 LocalGroups,
                 ClientTokenGroups
                 );


    if (!NT_SUCCESS(Status) ) {
        LsapFreePrivateHeap( LocalGroups );
        return Status;
    }



    //
    // Now retrieve each group
    //

    RetrieveCount = 0;     // Used for cleanup, if necessary.
    SidHeaderLength  = RtlLengthRequiredSid( 0 );
    SidHeader = LsapAllocatePrivateHeap( SidHeaderLength );
    if ( SidHeader == NULL ) {
        LsapFreePrivateHeap( LocalGroups );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = STATUS_SUCCESS;
    i = 0;
    while ( i < LocalGroups->GroupCount ) {

        //
        // Retrieve the next SID header
        //

        NextClientSid = LocalGroups->Groups[i].Sid;
        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     SidHeaderLength,
                     SidHeader,
                     NextClientSid
                     );
        if ( !NT_SUCCESS(Status) ) {
            break;
        }

        //
        // and use the header information to get the whole SID
        //

        Length = RtlLengthSid( SidHeader );
        LocalGroups->Groups[i].Sid = LsapAllocatePrivateHeap( Length );

        if ( LocalGroups->Groups[i].Sid == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        } else {
            RetrieveCount += 1;
        }



        Status = LsapCopyFromClientBuffer (
                     (PLSA_CLIENT_REQUEST)ClientRequest,
                     Length,
                     LocalGroups->Groups[i].Sid,
                     NextClientSid
                     );
        if ( !NT_SUCCESS(Status) ) {
            break;
        }


        i += 1;

    }
    LsapFreePrivateHeap( SidHeader );


    if ( NT_SUCCESS(Status) ) {
        return Status;
    }



    //
    // There was a failure along the way.
    // We need to deallocate what has already been allocated.
    //

    i = 0;
    while ( i < RetrieveCount ) {
        LsapFreePrivateHeap( LocalGroups->Groups[i].Sid );
        i += 1;
    }

    LsapFreePrivateHeap( LocalGroups );

    return Status;

}

NTSTATUS
LsapBuildDefaultTokenGroups(
    PLSAP_LOGON_USER_ARGS Arguments
    )
/*++

Routine Description:

    This function builds the default token groups inserted into a token
    during a non-privileged call to LsaLogonUser().

--*/
{
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY LocalSidAuthority = SECURITY_LOCAL_SID_AUTHORITY;

    LUID Luid;
    PTOKEN_GROUPS TokenGroups = NULL;
    PSID LocalSid = NULL;
    PSID LogonSid = NULL;
    ULONG Length;

    NTSTATUS Status = STATUS_SUCCESS;


    Arguments->LocalGroupsCount = 0;
    Arguments->LocalGroups = NULL;

    Status = NtAllocateLocallyUniqueId( &Luid );

    if(!NT_SUCCESS( Status ))
    {
        return Status;
    }


#define TOKEN_GROUP_COUNT   2 // We'll add the local SID and the logon SID

    Length = sizeof(TOKEN_GROUPS) +
                  (TOKEN_GROUP_COUNT - ANYSIZE_ARRAY) * sizeof(SID_AND_ATTRIBUTES)
                  ;

    TokenGroups = (PTOKEN_GROUPS) LsapAllocatePrivateHeap( Length );

    if (TokenGroups == NULL) {
        return(STATUS_NO_MEMORY);
    }

    //
    // Fill in the logon token group list
    //

    Length = RtlLengthRequiredSid( 1 );

    LocalSid = (PSID)LsapAllocatePrivateHeap( Length );

    if (LocalSid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlInitializeSid(LocalSid, &LocalSidAuthority, 1);
    *(RtlSubAuthoritySid(LocalSid, 0)) = SECURITY_LOCAL_RID;


    //
    // logon Sid
    //

    Length = RtlLengthRequiredSid(SECURITY_LOGON_IDS_RID_COUNT);

    LogonSid = (PSID)LsapAllocatePrivateHeap( Length );

    if (LogonSid == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlInitializeSid(LogonSid, &SystemSidAuthority, SECURITY_LOGON_IDS_RID_COUNT);

    ASSERT(SECURITY_LOGON_IDS_RID_COUNT == 3);

    *(RtlSubAuthoritySid(LogonSid, 0)) = SECURITY_LOGON_IDS_RID;
    *(RtlSubAuthoritySid(LogonSid, 1)) = Luid.HighPart;
    *(RtlSubAuthoritySid(LogonSid, 2)) = Luid.LowPart;



    TokenGroups->GroupCount = TOKEN_GROUP_COUNT;
    TokenGroups->Groups[0].Sid = LogonSid;
    TokenGroups->Groups[0].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_LOGON_ID;
    TokenGroups->Groups[1].Sid = LocalSid;
    TokenGroups->Groups[1].Attributes =
            SE_GROUP_MANDATORY | SE_GROUP_ENABLED |
            SE_GROUP_ENABLED_BY_DEFAULT;


    Arguments->LocalGroupsCount = TokenGroups->GroupCount;
    Arguments->LocalGroups = TokenGroups;

Cleanup:

    if(!NT_SUCCESS( Status ))
    {
        if( LocalSid != NULL )
        {
            LsapFreePrivateHeap( LocalSid );
        }
        if( LogonSid != NULL )
        {
            LsapFreePrivateHeap( LogonSid );
        }
        if( TokenGroups != NULL )
        {
            LsapFreePrivateHeap( TokenGroups );
        }
    }


    return Status;
}


VOID
LsapFreeTokenGroups(
    IN PTOKEN_GROUPS TokenGroups OPTIONAL
    )

/*++

Routine Description:

    This function frees the local groups of a logon user arguments buffer.
    The local groups are expected to have been captured into the server
    process.


Arguments:

    TokenGroups - Points to the TOKEN_GROUPS to be freed.  This may be
        NULL, allowing the caller to pass whatever was returned by
        LsapCaptureClientTokenGroups() - even if there were no local
        groups.

Return Value:

    None.

--*/

{

    ULONG i;

    if ( !ARGUMENT_PRESENT(TokenGroups) ) {
        return;
    }


    i = 0;
    while ( i < TokenGroups->GroupCount ) {
        LsapFreePrivateHeap( TokenGroups->Groups[i].Sid );
        i += 1;
    }

    LsapFreePrivateHeap( TokenGroups );

    return;

}


VOID
LsapFreeTokenInformationNull(
    IN PLSA_TOKEN_INFORMATION_NULL TokenInformationNull
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_NULL data structure.


Arguments:

    TokenInformationNull - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{

    LsapFreeTokenGroups( TokenInformationNull->Groups );
    LsapFreeLsaHeap( TokenInformationNull );

}


VOID
LsapFreeTokenInformationV1(
    IN PLSA_TOKEN_INFORMATION_V1 TokenInformationV1
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_V1 data structure.


Arguments:

    TokenInformationV1 - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{

    //
    // Free the user SID (a required field)
    //

    LsapFreeLsaHeap( TokenInformationV1->User.User.Sid );


    //
    // Free any groups present
    //

    LsapFreeTokenGroups( TokenInformationV1->Groups );



    //
    // Free the primary group.
    // This is a required field, but it is freed only if non-NULL
    // so this routine can be used by the filter routine while building
    // a V1 token information structure.
    //


    if ( TokenInformationV1->PrimaryGroup.PrimaryGroup != NULL ) {
        LsapFreeLsaHeap( TokenInformationV1->PrimaryGroup.PrimaryGroup );
    }



    //
    // Free the privileges.
    // If there are no privileges this field will be NULL.
    //


    if ( TokenInformationV1->Privileges != NULL ) {
       LsapFreeLsaHeap( TokenInformationV1->Privileges );
    }



    //
    // Free the owner SID, if one is present
    //

    if ( TokenInformationV1->Owner.Owner != NULL) {
        LsapFreeLsaHeap( TokenInformationV1->Owner.Owner );
    }




    //
    // Free the default DACL if one is present.
    //

    if ( TokenInformationV1->DefaultDacl.DefaultDacl != NULL) {
        LsapFreeLsaHeap( TokenInformationV1->DefaultDacl.DefaultDacl );
    }



    //
    // Free the structure itself.
    //

    LsapFreeLsaHeap( TokenInformationV1 );


}

VOID
LsapFreeTokenInformationV2(
    IN PLSA_TOKEN_INFORMATION_V2 TokenInformationV2
    )

/*++

Routine Description:

    This function frees the allocated structures associated with a
    LSA_TOKEN_INFORMATION_V2 data structure.


Arguments:

    TokenInformationV2 - Pointer to the data structure to be released.

Return Value:

    None.

--*/

{
    LsapFreeLsaHeap( TokenInformationV2 );
}






VOID
LsapAuLogonTerminatedPackages(
    IN PLUID LogonId
    )

/*++

Routine Description:

    This function notifies all loaded authentication packages that a logon
    session is about to be deleted.  The reference monitor portion of the
    logon session has already been deleted, and the LSA portion will be
    immediately after this routine completes.

    To protect themselves against each other, authentication packages should
    assume that the logon session does not necessarily currently exist.
    That is, if the authentication package goes to query information from the
    logon session credential information, and finds no such logon session,
    it may be due to an error in another authentication package.



Arguments:

    LogonId - The LUID of the logon session.


Return Value:

    None.


--*/

{

    ULONG PackageCount;
    PLSAP_SECURITY_PACKAGE AuthPackage;




    //
    // Look at each loaded package for a name match
    //


    AuthPackage = SpmpIteratePackagesByRequest( NULL, SP_ORDINAL_LOGONTERMINATED );
    while ( AuthPackage != NULL ) {


        SetCurrentPackageId(AuthPackage->dwPackageID);

        //
        // Now call the package...
        //


        (AuthPackage->FunctionTable.LogonTerminated)( LogonId );

        AuthPackage = SpmpIteratePackagesByRequest( AuthPackage, SP_ORDINAL_LOGONTERMINATED );

    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\global.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    global.c

Abstract:

    LSA Subsystem - globals for server side

    This file contains variables that are global to the Lsa Server Side

Author:

    Mike Swift          (MikeSw)        January 14, 1997

Environment:

Revision History:

--*/


#include <lsapch2.h>





//
// Well known LUIDs
//

LUID LsapSystemLogonId;
LUID LsapAnonymousLogonId;


//
//  Well known privilege values
//


LUID LsapCreateTokenPrivilege;
LUID LsapAssignPrimaryTokenPrivilege;
LUID LsapLockMemoryPrivilege;
LUID LsapIncreaseQuotaPrivilege;
LUID LsapUnsolicitedInputPrivilege;
LUID LsapTcbPrivilege;
LUID LsapSecurityPrivilege;
LUID LsapTakeOwnershipPrivilege;

//
// Strings needed for auditing.
//

UNICODE_STRING LsapLsaAuName;
UNICODE_STRING LsapRegisterLogonServiceName;



//
//  The following information pertains to the use of the local SAM
//  for authentication.
//


// Length of typical Sids of members of the Account or Built-In Domains

ULONG LsapAccountDomainMemberSidLength,
      LsapBuiltinDomainMemberSidLength;

// Sub-Authority Counts for members of the Account or Built-In Domains

UCHAR LsapAccountDomainSubCount,
      LsapBuiltinDomainSubCount;

// Typical Sids for members of Account or Built-in Domains

PSID LsapAccountDomainMemberSid,
     LsapBuiltinDomainMemberSid;

//
// Policy realted globals

UNICODE_STRING LsapDbNames[DummyLastName];
UNICODE_STRING LsapDbObjectTypeNames[DummyLastObject];


//
// Installed, absolute minimum and absolute maximum Quota Limits.
//

QUOTA_LIMITS LsapDbInstalledQuotaLimits;
QUOTA_LIMITS LsapDbAbsMinQuotaLimits;
QUOTA_LIMITS LsapDbAbsMaxQuotaLimits;


LUID LsapSystemLogonId;
LUID LsapZeroLogonId;



//
//  Well known privilege values
//


LUID LsapCreateTokenPrivilege;
LUID LsapAssignPrimaryTokenPrivilege;
LUID LsapLockMemoryPrivilege;
LUID LsapIncreaseQuotaPrivilege;
LUID LsapUnsolicitedInputPrivilege;
LUID LsapTcbPrivilege;
LUID LsapSecurityPrivilege;
LUID LsapTakeOwnershipPrivilege;


SID_IDENTIFIER_AUTHORITY    LsapNullSidAuthority    = SECURITY_NULL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapWorldSidAuthority   = SECURITY_WORLD_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapLocalSidAuthority   = SECURITY_LOCAL_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapCreatorSidAuthority = SECURITY_CREATOR_SID_AUTHORITY;
SID_IDENTIFIER_AUTHORITY    LsapNtAuthority         = SECURITY_NT_AUTHORITY;

//
// Well Known Sid Table Pointer
//

PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\auinit.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    auinit.c

Abstract:

    This module performs initialization of the authentication aspects
    of the lsa.

Author:

    Jim Kelly (JimK) 26-February-1991

Revision History:

--*/

#include <lsapch2.h>

#include <string.h>



BOOLEAN
LsapAuInit(
    VOID
    )

/*++

Routine Description:

    This function initializes the LSA authentication services.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LUID SystemLuid = SYSTEM_LUID;
    LUID AnonymousLuid = ANONYMOUS_LOGON_LUID;

    LsapSystemLogonId = SystemLuid;
    LsapZeroLogonId.LowPart = 0;
    LsapZeroLogonId.HighPart = 0;
    LsapAnonymousLogonId = AnonymousLuid;

    //
    // Strings needed for auditing.
    //

    RtlInitUnicodeString( &LsapLsaAuName, L"NT Local Security Authority / Authentication Service" );
    RtlInitUnicodeString( &LsapRegisterLogonServiceName, L"LsaRegisterLogonProcess()" );

    if (!LsapEnableCreateTokenPrivilege() ) {
        return FALSE;
    }



    return TRUE;

}



BOOLEAN
LsapEnableCreateTokenPrivilege(
    VOID
    )

/*++

Routine Description:

    This function enabled the SeCreateTokenPrivilege privilege.

Arguments:

    None.

Return Value:

    TRUE  if privilege successfully enabled.
    FALSE if not successfully enabled.

--*/
{

    NTSTATUS Status;
    HANDLE Token;
    LUID CreateTokenPrivilege;
    PTOKEN_PRIVILEGES NewState;
    ULONG ReturnLength;


    //
    // Open our own token
    //

    Status = NtOpenProcessToken(
                 NtCurrentProcess(),
                 TOKEN_ADJUST_PRIVILEGES,
                 &Token
                 );
    ASSERTMSG( "LSA/AU Cant open own process token.", NT_SUCCESS(Status) );


    //
    // Initialize the adjustment structure
    //

    CreateTokenPrivilege =
        RtlConvertLongToLuid(SE_CREATE_TOKEN_PRIVILEGE);

    ASSERT( (sizeof(TOKEN_PRIVILEGES) + sizeof(LUID_AND_ATTRIBUTES)) < 100);
    NewState = LsapAllocateLsaHeap( 100 );

    if ( NewState == NULL )
    {
        NtClose( Token );
        return FALSE ;
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = CreateTokenPrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;


    //
    // Set the state of the privilege to ENABLED.
    //

    Status = NtAdjustPrivilegesToken(
                 Token,                            // TokenHandle
                 FALSE,                            // DisableAllPrivileges
                 NewState,                         // NewState
                 0,                                // BufferLength
                 NULL,                             // PreviousState (OPTIONAL)
                 &ReturnLength                     // ReturnLength
                 );
    ASSERTMSG("LSA/AU Cant enable CreateTokenPrivilege.", NT_SUCCESS(Status) );


    //
    // Clean up some stuff before returning
    //

    LsapFreeLsaHeap( NewState );
    Status = NtClose( Token );
    ASSERTMSG("LSA/AU Cant close process token.", NT_SUCCESS(Status) );


    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\lsaerror.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsaerror.c

Abstract:

    Local Security Authority Protected Subsystem - Error Routines

Author:

    Scott Birrell       (ScottBi)       April 30, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <netlibnt.h>   // for NetpApiStatusToNtStatus


VOID
LsapLogError(
    IN OPTIONAL PUCHAR Message,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This function retrieves the status of Lsa Initialization.

Arguments:

    Message - Optional Message to be printed out if debugging enabled.

    Status - Standard Nt Result Code supplied by calling routine.

Return Value:

    None.

--*/

{

#if DBG

     if (ARGUMENT_PRESENT(Message)) {

         DbgPrint( Message, Status );
     }

#endif //DBG

}


NTSTATUS
LsapWinerrorToNtStatus(
    IN DWORD WinError
    )
/*++

Routine Description:

    Convert Win32 error code to NTSTATUS code

Arguments:

    WinError - Win32 error code

Return Value:

    Equivalent NTSTATUS code

--*/
{
    return NetpApiStatusToNtStatus( WinError );
}


NTSTATUS
LsapNtStatusFromLastWinError(
    )
/*++

Routine Description:

    Convert error returned by GetLastError() to NTSTATUS code and return

Arguments:

    None

Return Value:

    NTSTATUS code equivalent of GetLastError()

--*/
{
    return LsapWinerrorToNtStatus( GetLastError() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\safemode.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    safemode.c

Abstract:

    Module to determine what boot mode the system was boot into.

Author:

    Colin Brace         (ColinBr)    May 27, 1997.

Environment:

    User mode

Revision History:

--*/

#include <lsapch2.h>
#include <safeboot.h>
#include "safemode.h"

//
// Variables global to just this module.  They are kept non-static
// for debugging ease.
//
BOOLEAN fLsapSafeMode;

//
// Forward prototypes
//

BOOLEAN
LsapGetRegistryProductType(
    PNT_PRODUCT_TYPE NtProductType
    );

BOOLEAN
LsapBaseNtSetupIsRunning(
    VOID
    );


//
// Function definitions
//

NTSTATUS
LsapCheckBootMode(
    VOID
    )
/*++

Routine Description:

    This routine determine if the environment variable SAFEBOOT_OPTION is 
    set and if the product type is domain controller.  If so, LsaISafeMode 
    will return TRUE; otherwise it will return FALSE.        

    Note that during kernel initialization, the kernel detects the safemode 
    boot option and if the product type is LanmanNT will set 
    SharedUserData->ProductType to ServerNT, so that RtlNtGetProductType() 
    will return ServerNT for this boot session.

Arguments:

    None.

Return Values:

    STATUS_SUCCESS on completion;
    Otherwise error from system services - this is fatal to the boot session.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NT_PRODUCT_TYPE     CurrentProductType;
    NT_PRODUCT_TYPE     OriginalProductType;

    WCHAR               SafeBootEnvVar[sizeof(SAFEBOOT_DSREPAIR_STR_W)];

    BOOLEAN             fSafeModeBootOptionPresent = FALSE;

    RtlZeroMemory(SafeBootEnvVar, sizeof(SafeBootEnvVar));

    //
    // If we are running during base nt setup, there is no point doing any
    // further investigation
    //
    if (LsapBaseNtSetupIsRunning()) {
        fLsapSafeMode = FALSE;
        return STATUS_SUCCESS;
    }

    //
    // Does environment variable exist
    //
    RtlZeroMemory( SafeBootEnvVar, sizeof( SafeBootEnvVar ) );
    if ( GetEnvironmentVariableW(L"SAFEBOOT_OPTION", SafeBootEnvVar, sizeof(SafeBootEnvVar)/sizeof(SafeBootEnvVar[0]) ) )
    {
        if ( !wcscmp( SafeBootEnvVar, SAFEBOOT_DSREPAIR_STR_W ) )
        {
            fSafeModeBootOptionPresent = TRUE;
            OutputDebugStringA("LSASS: found ds repair option\n");
        }
    }

    //
    // Get the  product type as determined by RtlGetNtProductType
    //
    if (!RtlGetNtProductType(&CurrentProductType)) {
        OutputDebugStringA("LSASS: RtlGetNtProductType failed\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // See what the original product type is
    //
    if (!LsapGetRegistryProductType(&OriginalProductType)) {
        OutputDebugStringA("LSASS: RtlGetNtProductType failed\n");
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Now for some analysis
    //
    if (fSafeModeBootOptionPresent
    && (OriginalProductType == NtProductLanManNt)) {

        // We are entering safe mode boot

        ASSERT(CurrentProductType == NtProductServer);

        fLsapSafeMode = TRUE;

        OutputDebugStringA("LSASS: Booting into Ds Repair Mode\n");

    } else {

        // This is a normal boot
        fLsapSafeMode = FALSE;

    }

    return(NtStatus);
}


BOOLEAN
LsaISafeMode(
    VOID
    )
/*++

Routine Description:

    This function is meant be called from in process servers of lsass.exe to
    determine if the current boot session is a "safe mode" boot session.

Arguments:

    None.

Return Values:

    TRUE  : the system is in safe mode

    FALSE :  the system is in safe mode

--*/
{
    DebugLog((DEB_TRACE_LSA, "LsaISafeMode entered\n"));
    return fLsapSafeMode;
}

BOOLEAN
LsapGetRegistryProductType(
    PNT_PRODUCT_TYPE NtProductType
    )
/*++

Routine Description:

    This routine retrieves the product type as stored in the registry.
    Note that when the safemode option is set and the product type at
    kernel initialization is LanmanNT then then SharedUserData->ProductType
    is set the ServerNT, which is what RtlGetNtProductType returns.

Arguments:

    None.

Return Values:

--*/
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    ULONG KeyValueInfoLength;
    ULONG ResultLength;
    UNICODE_STRING KeyPath;
    UNICODE_STRING ValueName;
    UNICODE_STRING Value;
    UNICODE_STRING WinNtValue;
    UNICODE_STRING LanmanNtValue;
    UNICODE_STRING ServerNtValue;
    BOOLEAN Result;

    //
    // Prepare default value for failure case
    //

    *NtProductType = NtProductWinNt;
    Result = FALSE;

    RtlInitUnicodeString( &KeyPath, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ProductOptions" );
    RtlInitUnicodeString( &ValueName, L"ProductType" );

    InitializeObjectAttributes( &ObjectAttributes,
                                &KeyPath,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = NtOpenKey( &KeyHandle,
                        MAXIMUM_ALLOWED,
                        &ObjectAttributes
                      );
    KeyValueInformation = NULL;
    if (NT_SUCCESS( Status )) {
        KeyValueInfoLength = 256;
        KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0,
                                               KeyValueInfoLength
                                             );
        if (KeyValueInformation == NULL) {
            Status = STATUS_NO_MEMORY;
        } else {
            Status = NtQueryValueKey( KeyHandle,
                                      &ValueName,
                                      KeyValueFullInformation,
                                      KeyValueInformation,
                                      KeyValueInfoLength,
                                      &ResultLength
                                    );
        }
    } else {
        KeyHandle = NULL;
    }

    if (NT_SUCCESS( Status ) && KeyValueInformation->Type == REG_SZ) {

        //
        // Decide which product we are installed as
        //

        Value.Buffer = (PWSTR)((PCHAR)KeyValueInformation + KeyValueInformation->DataOffset);
        Value.Length = (USHORT)(KeyValueInformation->DataLength - sizeof( UNICODE_NULL ));
        Value.MaximumLength = (USHORT)(KeyValueInformation->DataLength);
        RtlInitUnicodeString(&WinNtValue, L"WinNt");
        RtlInitUnicodeString(&LanmanNtValue, L"LanmanNt");
        RtlInitUnicodeString(&ServerNtValue, L"ServerNt");

        if (RtlEqualUnicodeString(&Value, &WinNtValue, TRUE)) {
            *NtProductType = NtProductWinNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &LanmanNtValue, TRUE)) {
            *NtProductType = NtProductLanManNt;
            Result = TRUE;
        } else if (RtlEqualUnicodeString(&Value, &ServerNtValue, TRUE)) {
            *NtProductType = NtProductServer;
            Result = TRUE;
        } else {
#if DBG
            DbgPrint("RtlGetNtProductType: Product type unrecognised <%wZ>\n", &Value);
#endif // DBG
        }
    } else {
#if DBG
        DbgPrint("RtlGetNtProductType: %wZ\\%wZ not found or invalid type\n", &KeyPath, &ValueName );
#endif // DBG
    }

    //
    // Clean up our resources.
    //

    if (KeyValueInformation != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    if (KeyHandle != NULL) {
        NtClose( KeyHandle );
    }

    //
    // Return result.
    //

    return(Result);

}

BOOLEAN
LsapBaseNtSetupIsRunning(
    VOID
    )
/*++

Routine Description:

    This function returns TRUE if the boot context is base nt setup

Arguments:

    None.

Return Values:

    TRUE is it can be determined that base nt setup is running
    FALSE otherwise

--*/
{
    BOOLEAN fUpgrade;
    return SamIIsSetupInProgress(&fUpgrade);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\lsaifree.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    lsaifree.c

Abstract:

    This file contains routines to free structure allocated by the lsar
    routines.  These routines are used by lsa clients which live in the
    lsae process as the lsa server and call the lsar routines directly.


Author:

    Scott Birrell     (ScottBi)    April 15, 1992

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <lsapch2.h>


VOID
LsaiFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees the node and the graph of allocated subnodes
    pointed to by an LSAPR_SR_SECURITY_DESCRIPTOR structure.

Parameters:

    Source - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( SecurityDescriptor )) {

        _fgs__LSAPR_SR_SECURITY_DESCRIPTOR ( SecurityDescriptor );
        MIDL_user_free ( SecurityDescriptor );
    }
}


VOID
LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER (
    PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_ACCOUNT_ENUM_BUFFER structure. The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT(EnumerationBuffer)) {

        _fgs__LSAPR_ACCOUNT_ENUM_BUFFER ( EnumerationBuffer );
    }
}


VOID
LsaIFree_LSAPR_TRANSLATED_SIDS (
    PLSAPR_TRANSLATED_SIDS TranslatedSids
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRANSLATED_SIDS structure.

Parameters:

    TranslatedSids - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TranslatedSids )) {

        _fgs__LSAPR_TRANSLATED_SIDS ( TranslatedSids );
//        MIDL_user_free( TranslatedSids );
    }
}



VOID
LsaIFree_LSAPR_TRANSLATED_NAMES (
    PLSAPR_TRANSLATED_NAMES TranslatedNames
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRANSLATED_NAMES structure.

Parameters:

    TranslatedNames - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TranslatedNames )) {

        _fgs__LSAPR_TRANSLATED_NAMES( TranslatedNames );
//        MIDL_user_free( TranslatedNames );
    }
}


VOID
LsaIFree_LSAPR_POLICY_INFORMATION (
    POLICY_INFORMATION_CLASS InformationClass,
    PLSAPR_POLICY_INFORMATION PolicyInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_POLICY_INFORMATION structure.

Parameters:

    PolicyInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PolicyInformation )) {

        _fgu__LSAPR_POLICY_INFORMATION ( PolicyInformation, InformationClass );
        MIDL_user_free( PolicyInformation );
    }
}

VOID
LsaIFree_LSAPR_POLICY_DOMAIN_INFORMATION (
    IN POLICY_DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PLSAPR_POLICY_DOMAIN_INFORMATION PolicyDomainInformation
    )
/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_POLICY_DOMAIN_INFORMATION structure.

Parameters:

    PolicyDomainInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PolicyDomainInformation )) {

        _fgu__LSAPR_POLICY_DOMAIN_INFORMATION ( PolicyDomainInformation, DomainInformationClass );
        MIDL_user_free( PolicyDomainInformation );
    }
}



VOID
LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO (
    TRUSTED_INFORMATION_CLASS InformationClass,
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRUSTED_DOMAIN_INFO structure.

Parameters:

    InformationClass - Specifies the Trusted Domain Information Class
        to which the TrustedDomainInformation relates.

    TrustedDomainInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustedDomainInformation )) {

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( TrustedDomainInformation, InformationClass );
        MIDL_user_free( TrustedDomainInformation );
    }
}


VOID
LsaIFree_LSAPR_REFERENCED_DOMAIN_LIST (
    PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_REFERENCED_DOMAIN_LIST structure.

Parameters:

    ReferencedDomains - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( ReferencedDomains )) {

        _fgs__LSAPR_REFERENCED_DOMAIN_LIST ( ReferencedDomains );
        MIDL_user_free( ReferencedDomains );
    }
}


VOID
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER (
    PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( EnumerationBuffer )) {

        _fgs__LSAPR_TRUSTED_ENUM_BUFFER ( EnumerationBuffer );
    }
}

VOID
LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX (
    PLSAPR_TRUSTED_ENUM_BUFFER_EX EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( EnumerationBuffer )) {

        _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX ( EnumerationBuffer );
    }
}


VOID
LsaIFree_LSAPR_TRUST_INFORMATION (
    PLSAPR_TRUST_INFORMATION TrustInformation
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated nodes pointed to by
    an LSAPR_TRUST_INFORMATION structure.

Parameters:

    TrustInformation - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustInformation )) {

        _fgs__LSAPR_TRUST_INFORMATION ( TrustInformation );
        MIDL_user_free( TrustInformation );
    }
}


VOID
LsaIFree_LSAPR_TRUSTED_DOMAIN_AUTH_BLOB (
    PLSAPR_TRUSTED_DOMAIN_AUTH_BLOB TrustedDomainAuthBlob
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_TRUSTED_DOMAIN_AUTH_BLOB structure.

Parameters:

    TrustedDomainAuthBlob - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( TrustedDomainAuthBlob )) {

        MIDL_user_free( TrustedDomainAuthBlob->AuthBlob );
    }
}

VOID
LsaIFree_LSAI_SECRET_ENUM_BUFFER (
    PVOID EnumerationBuffer,
    ULONG Count
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAI_SECRET_ENUM_BUFFER structure.  The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
        is to be freed.

    Count - Count of the number of Entries in the structure.

Return Values:

    None.

--*/

{
    ULONG Index;

    PLSAPR_UNICODE_STRING EnumerationBufferU = (PLSAPR_UNICODE_STRING) EnumerationBuffer;

    if ( ARGUMENT_PRESENT( EnumerationBuffer)) {

        for (Index = 0; Index < Count; Index++ ) {

            _fgs__LSAPR_UNICODE_STRING( &EnumerationBufferU[Index] );
        }

        MIDL_user_free( EnumerationBufferU );
    }
}


VOID
LsaIFree_LSAI_PRIVATE_DATA (
    PVOID Data
    )

/*++

Routine Description:

    This routine frees a structure containing LSA Private Database
    Information.

Parameters:

    Data - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( Data )) {

        MIDL_user_free( Data );
    }

}


VOID
LsaIFree_LSAPR_SR_SECURITY_DESCRIPTOR (
    PLSAPR_SR_SECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_SR_SECURITY_DESCRIPTOR structure.

Parameters:

    SecurityDescriptor - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( SecurityDescriptor )) {

        _fgs__LSAPR_SR_SECURITY_DESCRIPTOR( SecurityDescriptor );
        MIDL_user_free( SecurityDescriptor );
    }
}




VOID
LsaIFree_LSAPR_UNICODE_STRING (
    IN PLSAPR_UNICODE_STRING UnicodeName
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_UNICODE_STRING structure.

Parameters:

    UnicodeName - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( UnicodeName )) {

        _fgs__LSAPR_UNICODE_STRING( UnicodeName );
        MIDL_user_free( UnicodeName );
    }
}


VOID
LsaIFree_LSAPR_UNICODE_STRING_BUFFER (
    IN PLSAPR_UNICODE_STRING UnicodeName
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_UNICODE_STRING structure.

Parameters:

    UnicodeName - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( UnicodeName )) {

        _fgs__LSAPR_UNICODE_STRING( UnicodeName );
    }
}


VOID
LsaIFree_LSAPR_PRIVILEGE_SET (
    IN PLSAPR_PRIVILEGE_SET PrivilegeSet
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_PRIVILEGE_SET structure.

Parameters:

    PrivilegeSet - A pointer to the node to free.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT( PrivilegeSet )) {

        MIDL_user_free( PrivilegeSet );
    }
}


VOID
LsaIFree_LSAPR_CR_CIPHER_VALUE (
    IN PLSAPR_CR_CIPHER_VALUE CipherValue
    )

/*++

Routine Description:

    This routine frees the node and graph of allocated subnodes pointed to by
    an LSAPR_CR_CIPHER_VALUE structure.  Note that this structure is in
    fact allocated(all_nodes) on the server side of LSA.

Parameters:

    CipherValue - A pointer to the node to free.

Return Values:

    None.

--*/

{
    MIDL_user_free( CipherValue );
}


VOID
LsaIFree_LSAPR_PRIVILEGE_ENUM_BUFFER (
    PLSAPR_PRIVILEGE_ENUM_BUFFER EnumerationBuffer
    )

/*++

Routine Description:

    This routine frees the graph of allocated subnodes pointed to by
    an LSAPR_PRIVILEGE_ENUM_BUFFER structure. The structure itself is
    left intact.

Parameters:

    EnumerationBuffer - A pointer to the node whose graph of subnodes
       is to be freed.

Return Values:

    None.

--*/

{
    if (ARGUMENT_PRESENT(EnumerationBuffer)) {

        _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER ( EnumerationBuffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\lsainit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsainit.c

Abstract:

    Local Security Authority Protected Subsystem - Initialization

Author:

    Scott Birrell       (ScottBi)       March 12, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <secur32p.h>
#include <ntddksec.h>
#include <ntdsa.h>
#include "adtp.h"
#include "spinit.h"
#include "efssrv.hxx"
#include "dssetp.h"
#include "sidcache.h"
#include "klpcstub.h"
#include "lsawmi.h"
#include "dpapiprv.h"

//
// Name of event which says that the LSA RPC server is ready
//

#define LSA_RPC_SERVER_ACTIVE           L"LSA_RPC_SERVER_ACTIVE"



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


#if LSAP_DIAGNOSTICS
//
// LSA Global Controls
//

ULONG LsapGlobalFlag = 0;
#endif //LSAP_DIAGNOSTICS




//
// Handles used to talk to SAM directly.
// Also, a flag to indicate whether or not the handles are valid.
//


BOOLEAN LsapSamOpened = FALSE;

SAMPR_HANDLE LsapAccountDomainHandle;
SAMPR_HANDLE LsapBuiltinDomainHandle;

PWSTR   pszPreferred;

//
// Handle to KSecDD device, for passing down ioctls.
//

HANDLE KsecDevice ;



//
// For outside calls (e.g. RPC originated) CallInfo won't be there,
// but some helper functions will look for it.  This is a default one
// that can be used.
//

LSA_CALL_INFO   LsapDefaultCallInfo ;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Module-Wide variables                                          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

BOOLEAN
    LsapHealthCheckingEnabled = FALSE;

BOOLEAN LsapPromoteInitialized = FALSE;



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Internal routine prototypes                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



NTSTATUS
LsapActivateRpcServer();

DWORD
LsapRpcServerThread(
    LPVOID Parameter
    );

NTSTATUS
LsapInstallationPause();

VOID
LsapSignalRpcIsActive();

NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    );



//
// Open the KSec Device
//

VOID
LsapOpenKsec(
    VOID
    )
{
    NTSTATUS Status ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES ObjA ;
    IO_STATUS_BLOCK IoStatus ;

    RtlInitUnicodeString( &String, DD_KSEC_DEVICE_NAME_U );

    InitializeObjectAttributes( &ObjA,
                                &String,
                                0,
                                0,
                                0);

    Status = NtOpenFile( &KsecDevice,
                         GENERIC_READ | GENERIC_WRITE,
                         &ObjA,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to open %ws, status %x\n",
                        String.Buffer, Status ));
        return;
    }

    Status = NtDeviceIoControlFile(
                    KsecDevice,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_KSEC_CONNECT_LSA,
                    NULL,
                    0,
                    NULL,
                    0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_ERROR, "FAILED to send ioctl, status %x\n", Status ));
    }
    else
    {
        LsapFindEfsSession();
    }

}





/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Routines                                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

VOID
FixupEnvironment(
    VOID
    )
{

    WCHAR Root[ MAX_PATH ];
    DWORD Length;
    PWCHAR PostFix = TEXT("\\System32");
    BOOL RetVal;

    Length = GetEnvironmentVariable( TEXT("SystemRoot"),
                                     Root,
                                     MAX_PATH );

    ASSERT (Length && Length < MAX_PATH); // Let someone know if the call doesn't work

    wcsncat( Root, PostFix, MAX_PATH - Length - 1);

    ASSERT (MAX_PATH - Length > wcslen (PostFix)); // Let someone know if buffer is too small

    DebugLog((DEB_TRACE_INIT, "Setting PATH to %ws\n", Root ));

    RetVal = SetEnvironmentVariable( TEXT("Path"), Root);
    ASSERT (RetVal);

}

VOID
LsapSetupTuningParameters(
    VOID
    )
{

    NT_PRODUCT_TYPE ProductType;
    HKEY LsaKey ;
    int err ;
    ULONG Value ;
    ULONG Type ;
    ULONG Size ;
    ULONG GlobalReturn = 0 ;
    NTSTATUS scRet ;

    LsaTuningParameters.ThreadLifespan = 60 ;
    LsaTuningParameters.SubQueueLifespan = 30 ;
    LsaTuningParameters.Options = TUNE_TRIM_WORKING_SET ;
    LsaTuningParameters.ShrinkOn = FALSE ;


    scRet = RtlGetNtProductType( &ProductType );

    if ( NT_SUCCESS( scRet ) )
    {
        if ( ProductType != NtProductWinNt )
        {
            LsaTuningParameters.ThreadLifespan = 15 * 60 ;
            LsaTuningParameters.SubQueueLifespan = 5 * 60 ;
            LsaTuningParameters.Options = TUNE_RM_THREAD ;

            if ( ProductType == NtProductLanManNt )
            {
                LsaTuningParameters.Options |= TUNE_PRIVATE_HEAP ;

                //
                // On DCs, link to the real version of the NTDSA
                // save and restore.
                //
                GetDsaThreadState = (DSA_THSave *) THSave ;
                RestoreDsaThreadState = (DSA_THRestore *) THRestore ;
            }

        }
    }
    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                        0,
                        KEY_READ | KEY_WRITE,
                        &LsaKey );

    if ( err == 0 )
    {
        Value = GetCurrentProcessId();

        RegSetValueEx(
            LsaKey,
            TEXT("LsaPid"),
            0,
            REG_DWORD,
            (PUCHAR) &Value,
            sizeof( DWORD ) );

        Size = sizeof(DWORD);

        err = RegQueryValueEx(  LsaKey,
                                TEXT("GeneralThreadLifespan"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            LsaTuningParameters.ThreadLifespan = Value ;
        }

        Size = sizeof( DWORD );
        err = RegQueryValueEx(  LsaKey,
                                TEXT("DedicatedThreadLifespan"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            LsaTuningParameters.SubQueueLifespan = Value ;
        }

        Size = sizeof( DWORD );

        err = RegQueryValueEx(  LsaKey,
                                TEXT("HighPriority"),
                                0,
                                &Type,
                                (PUCHAR) &Value,
                                &Size );

        if ( err == 0 )
        {
            if ( Value )
            {
                LsaTuningParameters.Options |= TUNE_SRV_HIGH_PRIORITY ;
            }
        }

        RegCloseKey( LsaKey );
    }


    DebugLog(( DEB_TRACE_INIT, "Tuning parameters:\n" ));
    DebugLog(( DEB_TRACE_INIT, "   Thread Lifespan %d sec\n",
                    LsaTuningParameters.ThreadLifespan ));
    DebugLog(( DEB_TRACE_INIT, "   SubQueue Lifespan %d sec\n",
                    LsaTuningParameters.SubQueueLifespan ));
    DebugLog(( DEB_TRACE_INIT, "   Options:\n" ));
}


NTSTATUS
LsapInitLsa(
    )

/*++

Routine Description:

    This process is activated as a standard SM subsystem.  Initialization
    completion of a SM subsystem is indicated by having the first thread
    exit with status.

    This function initializes the LSA.  The initialization procedure comprises
    the following steps:

    o  LSA Heap Initialization
    o  LSA Command Server Initialization
    o  LSA Database Load
    o  Reference Monitor State Initialization
    o  LSA RPC Server Initialization
    o  LSA Auditing Initialization
    o  LSA Authentication Services Initialization
    o  Wait for Setup to complete (if necessary)
    o  LSA database initialization (product type-specific)
    o  Start backgroup thread to register WMI tracing guids

    Any failure in any of the above steps is fatal and causes the LSA
    process to terminate.  The system must be aborted.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS Status;
    BOOLEAN BooleanStatus = TRUE;
    DWORD EFSRecoverThreadID;
    HANDLE EFSThread ;
    SYSTEM_INFO SysInfo ;

#if DBG
    InitDebugSupport();
#endif

    FixupEnvironment();

    //
    // Optional break point
    //

    BreakOnError(BREAK_ON_BEGIN_INIT);

    //
    // Init the TLS indices
    //

    (void) InitThreadData();

    //
    // Initialize the stack allocator
    //

    SafeAllocaInitialize(
        SAFEALLOCA_USE_DEFAULT,
        SAFEALLOCA_USE_DEFAULT,
        LsapAllocatePrivateHeap,
        LsapFreePrivateHeap
        );


    LsapSetupTuningParameters();

#if DBG
    LsaTuningParameters.Options |= TUNE_PRIVATE_HEAP ;
#endif

    GetSystemInfo( &SysInfo );
    LsapPageSize = SysInfo.dwPageSize ;
    LsapUserModeLimit = (ULONG_PTR) SysInfo.lpMaximumApplicationAddress ;

    LsapHeapInitialize( ((LsaTuningParameters.Options & TUNE_PRIVATE_HEAP ) != 0) );



    //
    // Initialize this thread:
    //

    SpmpThreadStartup();

    //
    // Update the SSPI cache
    //

    SecCacheSspiPackages();

    //
    // Initialize session tracking:
    //

    if (!InitSessionManager())
    {
        DebugLog((DEB_ERROR, "InitSessionManager failed?\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto InitLsaError;
    }



    //
    // Initialize misc. global variables:
    //

    LsapDefaultCallInfo.Session = pDefaultSession ;
    LsapDefaultCallInfo.LogContext = NULL ;
    LsapDefaultCallInfo.LogonId.HighPart = 0 ;
    LsapDefaultCallInfo.LogonId.LowPart = 999 ;
    LsapDefaultCallInfo.InProcCall = TRUE ;
    LsapDefaultCallInfo.Allocs = MAX_BUFFERS_IN_CALL ;


#if defined(REMOTE_BOOT)
    //
    // Initilize the state indicating whether this is a remote boot machine.
    //

    LsapDbInitializeRemoteBootState();
#endif // defined(REMOTE_BOOT)


    //
    // Initialize scavenger thread control

    if ( !LsapInitializeScavenger() )
    {
        DebugLog(( DEB_ERROR, "Could not initialize scavenger thread\n"));
        Status = STATUS_INTERNAL_ERROR ;
        goto InitLsaError ;
    }

    //
    // Start up the thread pool for support for LPC.
    //

    if (!InitializeThreadPool())
    {
        DebugLog((DEB_ERROR, "Could not init thread pool\n"));
        Status = STATUS_INTERNAL_ERROR;
        goto InitLsaError;

    }


    DebugLog((DEB_TRACE_INIT, "Current TraceLevel is %x\n", SPMInfoLevel));

    //
    // Load parameters from Registry:
    //

    Status = LoadParameters();
    if (!NT_SUCCESS(Status)) {
        goto InitLsaError;
    }



    //
    // Initialize a copy of the Well-Known Sids, etc. for use by
    // the LSA.
    //

    Status = LsapDbInitializeWellKnownValues();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }


    //
    // If this is a time-checking build, load the timer support
    // functions and initialize them.
    //

#ifdef TIME_SPM

    InitTimer();

#endif

    //
    // If we're going to be in a setup phase, tag it.
    //

    SetupPhase = SpmpIsSetupPass();

    //
    // Tell base/wincon how to shut us down.
    // First, tell base to shut us down as late in the game as possible.

    SetProcessShutdownParameters(SPM_SHUTDOWN_VALUE, SHUTDOWN_NORETRY);

    // And, tell them what function to call when we are being shutdown:

    SetConsoleCtrlHandler(SpConsoleHandler, TRUE);



    //
    // Set security on the synchronization event
    //

    Status = LsapBuildSD(BUILD_KSEC_SD, NULL);

    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR,"Failed to set Ksec security: 0x%x\n",Status));
        goto InitLsaError;
    }


    //
    // Perform LSA Command Server Initialization.  This involves creating
    // an LPC port called the LSA Command Server Port so that the Reference
    // monitor can send commands to the LSA via the port.  After the port
    // is created, an event created by the Reference Monitor is signalled,
    // so that the Reference Monitor can proceed to connect to the port.

    Status = LsapRmInitializeServer();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform LSA Database Server Initialization - Pass 1.
    // This initializes the non-product-type-specific information.
    //

    Status = LsapDbInitializeServer(1);

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform Auditing Initialization - Pass 1.
    //

    Status = LsapAdtInitialize();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }


    Status = LsapAdtObjsInitialize();

    ASSERT( NT_SUCCESS( Status ));

    //
    // Load packages:
    //


    // The System Logon session must be present before (at least) the
    // NegpackageLoad routine is called, so we can set it's creating package
    // id, otherwise the package id is 0, which is normally ok, but when a
    // machine is joined to a pre NT5 domain, this will mean that we
    // will not do NTLM in a system logon session.

    if ( !LsapLogonSessionInitialize() )
    {
        goto InitLsaError ;
    }

    Status = LoadPackages(  ppszPackages,
                            ppszOldPkgs,
                            pszPreferred );
    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR, "Error loading packages, terminating (0x%08x)\n",
                Status));
        goto InitLsaError;
    }


    //
    // Initialize the credential manager
    //

    Status = CredpInitialize();

    if ( !NT_SUCCESS( Status )) {
        goto InitLsaError;
    }

    //
    // Initialize data for System LogonID (999):
    //

    InitSystemLogon();

    //
    // Perform RPC Server Initialization.
    //

    Status = LsapRPCInit();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }






    //
    // Initialize Authentication Services
    //

    if (!LsapAuInit()) {

        Status = STATUS_UNSUCCESSFUL;
        goto InitLsaError;
    }




    //
    // Initialize the sid cache
    //

    Status = LsapDbInitSidCache();
    if (!NT_SUCCESS(Status)) {
        DebugLog((DEB_ERROR, "Error initializing sid cache: 0x%x\n",Status));
        goto InitLsaError;
    }

    //
    // Initialize LPC Server to talk to the FSPs waiting on the device driver
    //

    Status = StartLpcThread();

    if (FAILED(Status))
    {
        DebugLog((DEB_ERROR, "Error starting LPC thread, no DD support (0x%08x)\n",
            Status));
        goto InitLsaError;
    }


    //
    // open ksec and have it connect back to us in our own context.
    //

    LsapOpenKsec();

    //
    // Optional breakpoint when initialization complete
    //

    BreakOnError(BREAK_ON_BEGIN_END);


    //
    //  Start processing RPC calls
    //

    Status = LsapActivateRpcServer();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Initialize DPAPI
    //
    Status = DPAPIInitialize(&LsapSecpkgFunctionTable);
    if ( !NT_SUCCESS( Status )) {
        goto InitLsaError;
    }

    //
    // Pause for installation if necessary
    //

    Status = LsapInstallationPause();

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }

    //
    // Perform LSA Database Server Initialization - Pass 2.
    // This initializes the product-type-specific information.
    //

    Status = LsapDbInitializeServer(2);

    if (!NT_SUCCESS(Status)) {

        goto InitLsaError;
    }


    //
    // Initialize EFS
    //

    ( VOID )EfsServerInit();

    //
    // If EfsServerInit() fails because of policy & etc.
    // the recovery thread should not be run.
    //

    EFSThread = CreateThread( NULL,
                          0,
                          EFSRecover,
                          NULL,
                          0,
                          &EFSRecoverThreadID );

    if ( EFSThread )
    {
        CloseHandle( EFSThread );
    }
    //
    // Initialize the Setup APIs
    //
    if ( !LsapPromoteInitialized ) {

        DsRolepInitialize();

    }

    Status = LsapStartWmiTraceInitThread();

    if (!NT_SUCCESS(Status)) {
        goto InitLsaError;
    }


InitLsaFinish:

    return(Status);

InitLsaError:

    goto InitLsaFinish;
}


NTSTATUS
LsapActivateRpcServer( VOID )


/*++

Routine Description:

    This function creates a thread for the RPC server.
    The new Thread then goes on to activate the RPC server,
    which causes RPC calls to be delivered when recieved.



Arguments:

    None.

Return Value:


        STATUS_SUCCESS - The thread was successfully created.

        Other status values that may be set by CreateThread().


--*/

{

    NTSTATUS Status;
    ULONG WaitCount = 0;

    // Start listening for remote procedure calls.  The first
    // argument to RpcServerListen is the minimum number of call
    // threads to create; the second argument is the maximum number
    // of concurrent calls allowed.  The final argument indicates that
    // this routine should not wait.  After everything has been initialized,
    // we return.

    Status = I_RpcMapWin32Status(RpcServerListen(1, 1234, 1));

    ASSERT( Status == RPC_S_OK );

    //
    // Set event which signals that RPC server is available.
    //

    LsapSignalRpcIsActive();

    return(STATUS_SUCCESS);


}

NTSTATUS
LsapInstallationPause( VOID )


/*++

Routine Description:

    This function checks to see if the system is in an
    installation state.  If so, it suspends further initialization
    until the installation state is complete.

    Installation state is signified by the existance of a well known
    event.


Arguments:

    None.

Return Value:


        STATUS_SUCCESS - Proceed with initialization.

        Other status values are unexpected.

--*/

{

    if ( SpmpIsSetupPass() ) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        //

        LsapSetupWasRun = TRUE;

        //
        // Intialize the promotion interface
        //
        DsRolepInitialize();
        LsapDsInitializePromoteInterface();
        LsapPromoteInitialized = TRUE;

        //
        // Make sure we are not in mini-setup
        //
        if ( SpmpIsMiniSetupPass() ) {

            LsapSetupWasRun = FALSE;
        }

    }

    return( STATUS_SUCCESS );

}


BOOLEAN
LsaISetupWasRun(
    )

/*++

Routine Description:

    This function determines whether Setup was run.

Arguments:

    None

Return Values

    BOOLEAN - TRUE if setup was run, else FALSE

--*/

{
    return(LsapSetupWasRun);
}


VOID
LsapSignalRpcIsActive(
    )
/*++

Routine Description:

    It creates the LSA_RPC_SERVER_ACTIVE event if one does not already exist
    and signals it so that the service controller can proceed with LSA calls.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status;
    HANDLE EventHandle;


    EventHandle = CreateEventW(
                      NULL,    // No special security
                      TRUE,    // Must be manually reset
                      FALSE,   // The event is initially not signalled
                      LSA_RPC_SERVER_ACTIVE
                      );

    if (EventHandle == NULL) {

        status = GetLastError();

        //
        // If the event already exists, the service controller beats us
        // to creating it.  Just open it.
        //

        if (status == ERROR_ALREADY_EXISTS) {

            EventHandle = OpenEventW(
                              GENERIC_WRITE,
                              FALSE,
                              LSA_RPC_SERVER_ACTIVE
                              );
        }

        if (EventHandle == NULL) {
            //
            // Could not create or open the event.  Nothing we can do...
            //
            return;
        }
    }

    (VOID) SetEvent(EventHandle);
}


NTSTATUS
LsapGetAccountDomainInfo(
    PPOLICY_ACCOUNT_DOMAIN_INFO *PolicyAccountDomainInfo
    )

/*++

Routine Description:

    This routine retrieves ACCOUNT domain information from the LSA
    policy database.


Arguments:

    PolicyAccountDomainInfo - Receives a pointer to a
        POLICY_ACCOUNT_DOMAIN_INFO structure containing the account
        domain info.



Return Value:

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

             LsaOpenPolicy()
             LsaQueryInformationPolicy()
--*/

{
    NTSTATUS Status;



    //
    // Query the account domain information
    //

    Status = LsarQueryInformationPolicy( LsapPolicyHandle,
                                        PolicyAccountDomainInformation,
                                        (PLSAPR_POLICY_INFORMATION *) PolicyAccountDomainInfo );
#if DBG
    if ( NT_SUCCESS(Status) ) {
        ASSERT( (*PolicyAccountDomainInfo) != NULL );
        ASSERT( (*PolicyAccountDomainInfo)->DomainSid != NULL );
    }
#endif // DBG


    return(Status);
}


NTSTATUS
LsapOpenSam( VOID )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    return LsapOpenSamEx( FALSE );
}


NTSTATUS
LsapOpenSamEx(
    BOOLEAN DuringStartup
    )

/*++

Routine Description:

    This routine opens SAM for use during authentication.  It
    opens a handle to both the BUILTIN domain and the ACCOUNT domain.

Arguments:


    DuringStartup - TRUE if this is the call made during startup.  In that case,
        there is no need to wait on the SAM_STARTED_EVENT since the caller ensures
        that SAM is started before the call is made.

Return Value:

    STATUS_SUCCESS - Succeeded.
--*/

{
    NTSTATUS Status, IgnoreStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SAMPR_HANDLE SamHandle;


    if (LsapSamOpened == TRUE) {    // Global variable
        return(STATUS_SUCCESS);
    }

    //
    // Make sure SAM has initialized
    //

    if ( !DuringStartup ) {
        HANDLE EventHandle;
        OBJECT_ATTRIBUTES EventAttributes;
        UNICODE_STRING EventName;
        LARGE_INTEGER Timeout;

        RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );
        Status = NtOpenEvent( &EventHandle, SYNCHRONIZE, &EventAttributes );

        if ( !NT_SUCCESS(Status)) {

            if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

                //
                // SAM hasn't created this event yet, let us create it now.
                // SAM opens this event to set it.
                //

                Status = NtCreateEvent(
                               &EventHandle,
                               SYNCHRONIZE|EVENT_MODIFY_STATE,
                               &EventAttributes,
                               NotificationEvent,
                               FALSE // The event is initially not signaled
                               );

                if( Status == STATUS_OBJECT_NAME_EXISTS ||
                    Status == STATUS_OBJECT_NAME_COLLISION ) {

                    //
                    // second change, if the SAM created the event before we
                    // do.
                    //

                    Status = NtOpenEvent( &EventHandle,
                                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                                            &EventAttributes );

                }
            }

        }


        if (NT_SUCCESS(Status)) {

            //
            // See if SAM has signalled that he is initialized.
            //

            Timeout.QuadPart = -10000000; // 1000 seconds
            Timeout.QuadPart *= 1000;
            Status = NtWaitForSingleObject( EventHandle, FALSE, &Timeout );
            IgnoreStatus = NtClose( EventHandle );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {

            return( STATUS_INVALID_SERVER_STATE );
        }
    }


    //
    // Get the member Sid information for the account domain
    //

    Status = LsapGetAccountDomainInfo( &PolicyAccountDomainInfo );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Get our handles to the ACCOUNT and BUILTIN domains.
    //

    Status = SamIConnect( NULL,     // No server name
                          &SamHandle,
                          SAM_SERVER_CONNECT,
                          TRUE );   // Indicate we are privileged

    if ( NT_SUCCESS(Status) ) {

        //
        // Open the ACCOUNT domain.
        //

        Status = SamrOpenDomain( SamHandle,
                                 DOMAIN_ALL_ACCESS,
                                 PolicyAccountDomainInfo->DomainSid,
                                 &LsapAccountDomainHandle );

        if (NT_SUCCESS(Status)) {

            //
            // Open the BUILTIN domain.
            //


            Status = SamrOpenDomain( SamHandle,
                                     DOMAIN_ALL_ACCESS,
                                     LsapBuiltInDomainSid,
                                     &LsapBuiltinDomainHandle );


            if (NT_SUCCESS(Status)) {

                LsapSamOpened = TRUE;

            } else {

                IgnoreStatus = SamrCloseHandle( &LsapAccountDomainHandle );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

        IgnoreStatus = SamrCloseHandle( &SamHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the ACCOUNT domain information
    //

    LsaIFree_LSAPR_POLICY_INFORMATION(
        PolicyAccountDomainInformation,
        (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo );

    return(Status);
}



NTSTATUS
LsapDsInitializePromoteInterface(
    VOID
    )
/*++

Routine Description:

    Performs the initialization required for the Dc promotion/demotions apis, apart
    from what is done during LsaInit

Arguments:

    VOID


Return Values:

    STATUS_SUCCESS -- Success.

--*/
{

    NTSTATUS Status = STATUS_SUCCESS;

    if ( LsapPromoteInitialized == FALSE ) {

        Status = DsRolepInitializePhase2();

    }

    return( Status );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\oldstub.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    oldstub.c

Abstract:

    This file contains functions generated by midl v1.0.  These
    function were designed to only be called by the stubs,
    these paticular functions are called by user code.  This
    file is needed in order to compile lsa with midl v2.0 which
    doesn't generated these paticular functions anymore.

Author:

    Mario Goertzel      (MarioGo)    Jan 10, 1994

Environment:

    User Mode - Win32

Revision History:


--*/
#include <lsapch2.h>

/* routine that frees graph for struct _STRING */
void _fgs__STRING (STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_SID_INFORMATION */
void _fgs__LSAPR_SID_INFORMATION (LSAPR_SID_INFORMATION  * _source)
  {
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_SID_ENUM_BUFFER */
void _fgs__LSAPR_SID_ENUM_BUFFER (LSAPR_SID_ENUM_BUFFER  * _source)
  {
  if (_source->SidInfo !=0)
    {
      {
      unsigned long _sym5;
      for (_sym5 = 0; _sym5 < (unsigned long )(0 + _source->Entries); _sym5++)
        {
        _fgs__LSAPR_SID_INFORMATION ((LSAPR_SID_INFORMATION *)&_source->SidInfo[_sym5]);
        }
      }
    MIDL_user_free((void  *)(_source->SidInfo));
    }
  }

  /* routine that frees graph for struct _LSAPR_ACCOUNT_INFORMATION */
void _fgs__LSAPR_ACCOUNT_INFORMATION (LSAPR_ACCOUNT_INFORMATION  * _source)
  {
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_ACCOUNT_ENUM_BUFFER */
void _fgs__LSAPR_ACCOUNT_ENUM_BUFFER (LSAPR_ACCOUNT_ENUM_BUFFER  * _source)
  {
  if (_source->Information !=0)
    {
      {
      unsigned long _sym11;
      for (_sym11 = 0; _sym11 < (unsigned long )(0 + _source->EntriesRead); _sym11++)
        {
        _fgs__LSAPR_ACCOUNT_INFORMATION ((LSAPR_ACCOUNT_INFORMATION *)&_source->Information[_sym11]);
        }
      }
    MIDL_user_free((void  *)(_source->Information));
    }
  }

  /* routine that frees graph for struct _LSAPR_UNICODE_STRING */
void _fgs__LSAPR_UNICODE_STRING (LSAPR_UNICODE_STRING  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_SECURITY_DESCRIPTOR */
void _fgs__LSAPR_SECURITY_DESCRIPTOR (LSAPR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->Owner !=0)
    {
    MIDL_user_free((void  *)(_source->Owner));
    }
  if (_source->Group !=0)
    {
    MIDL_user_free((void  *)(_source->Group));
    }
  if (_source->Sacl !=0)
    {
    MIDL_user_free((void  *)(_source->Sacl));
    }
  if (_source->Dacl !=0)
    {
    MIDL_user_free((void  *)(_source->Dacl));
    }
  }

  /* routine that frees graph for struct _LSAPR_SR_SECURITY_DESCRIPTOR */
void _fgs__LSAPR_SR_SECURITY_DESCRIPTOR (LSAPR_SR_SECURITY_DESCRIPTOR  * _source)
  {
  if (_source->SecurityDescriptor !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PRIVILEGE_DEF */
void _fgs__LSAPR_POLICY_PRIVILEGE_DEF (LSAPR_POLICY_PRIVILEGE_DEF  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_PRIVILEGE_ENUM_BUFFER */
void _fgs__LSAPR_PRIVILEGE_ENUM_BUFFER (LSAPR_PRIVILEGE_ENUM_BUFFER  * _source)
  {
  if (_source->Privileges !=0)
    {
      {
      unsigned long _sym25;
      for (_sym25 = 0; _sym25 < (unsigned long )(0 + _source->Entries); _sym25++)
        {
        _fgs__LSAPR_POLICY_PRIVILEGE_DEF ((LSAPR_POLICY_PRIVILEGE_DEF *)&_source->Privileges[_sym25]);
        }
      }
    MIDL_user_free((void  *)(_source->Privileges));
    }
  }

  /* routine that frees graph for struct _LSAPR_OBJECT_ATTRIBUTES */
void _fgs__LSAPR_OBJECT_ATTRIBUTES (LSAPR_OBJECT_ATTRIBUTES  * _source)
  {
  if (_source->RootDirectory !=0)
    {
    MIDL_user_free((void  *)(_source->RootDirectory));
    }
  if (_source->ObjectName !=0)
    {
    _fgs__STRING ((STRING *)_source->ObjectName);
    MIDL_user_free((void  *)(_source->ObjectName));
    }
  if (_source->SecurityDescriptor !=0)
    {
    _fgs__LSAPR_SECURITY_DESCRIPTOR ((LSAPR_SECURITY_DESCRIPTOR *)_source->SecurityDescriptor);
    MIDL_user_free((void  *)(_source->SecurityDescriptor));
    }
  if (_source->SecurityQualityOfService !=0)
    {
    MIDL_user_free((void  *)(_source->SecurityQualityOfService));
    }
  }

  /* routine that frees graph for struct _LSAPR_CR_CIPHER_VALUE */
void _fgs__LSAPR_CR_CIPHER_VALUE (LSAPR_CR_CIPHER_VALUE  * _source)
  {
  if (_source->Buffer !=0)
    {
    MIDL_user_free((void  *)(_source->Buffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUST_INFORMATION */
void _fgs__LSAPR_TRUST_INFORMATION (LSAPR_TRUST_INFORMATION  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_ENUM_BUFFER */
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER (LSAPR_TRUSTED_ENUM_BUFFER  * _source)
  {
  if (_source->Information !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->EntriesRead); _sym31++)
        {
        _fgs__LSAPR_TRUST_INFORMATION ((LSAPR_TRUST_INFORMATION *)&_source->Information[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->Information));
    }
  }


  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX (LSAPR_TRUSTED_DOMAIN_INFORMATION_EX  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->FlatName);
  MIDL_user_free(_source->Sid);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_ENUM_BUFFER_EX */
void _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX (LSAPR_TRUSTED_ENUM_BUFFER_EX  * _source)
  {
  if (_source->EnumerationBuffer !=0)
    {
      {
      unsigned long _sym31;
      for (_sym31 = 0; _sym31 < (unsigned long )(0 + _source->EntriesRead); _sym31++)
        {
        _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX (&_source->EnumerationBuffer[_sym31]);
        }
      }
    MIDL_user_free((void  *)(_source->EnumerationBuffer));
    }
  }

  /* routine that frees graph for struct _LSAPR_REFERENCED_DOMAIN_LIST */
void _fgs__LSAPR_REFERENCED_DOMAIN_LIST (LSAPR_REFERENCED_DOMAIN_LIST  * _source)
  {
  if (_source->Domains !=0)
    {
      {
      unsigned long _sym37;
      for (_sym37 = 0; _sym37 < (unsigned long )(0 + _source->Entries); _sym37++)
        {
        _fgs__LSAPR_TRUST_INFORMATION ((LSAPR_TRUST_INFORMATION *)&_source->Domains[_sym37]);
        }
      }
    MIDL_user_free((void  *)(_source->Domains));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_SIDS */
void _fgs__LSAPR_TRANSLATED_SIDS (LSAPR_TRANSLATED_SIDS  * _source)
  {
  if (_source->Sids !=0)
    {
    MIDL_user_free((void  *)(_source->Sids));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_NAME */
void _fgs__LSAPR_TRANSLATED_NAME (LSAPR_TRANSLATED_NAME  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_TRANSLATED_NAMES */
void _fgs__LSAPR_TRANSLATED_NAMES (LSAPR_TRANSLATED_NAMES  * _source)
  {
  if (_source->Names !=0)
    {
      {
      unsigned long _sym58;
      for (_sym58 = 0; _sym58 < (unsigned long )(0 + _source->Entries); _sym58++)
        {
        _fgs__LSAPR_TRANSLATED_NAME ((LSAPR_TRANSLATED_NAME *)&_source->Names[_sym58]);
        }
      }
    MIDL_user_free((void  *)(_source->Names));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_ACCOUNT_DOM_INFO */
void _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO (LSAPR_POLICY_ACCOUNT_DOM_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DomainName);
  if (_source->DomainSid !=0)
    {
    MIDL_user_free((void  *)(_source->DomainSid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PRIMARY_DOM_INFO */
void _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO (LSAPR_POLICY_PRIMARY_DOM_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_DNS_DOMAIN_INFO */
void _fgs__LSAPR_POLICY_DNS_DOMAIN_INFO (LSAPR_POLICY_DNS_DOMAIN_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DnsDomainName);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->DnsForestName);
  if (_source->Sid !=0)
    {
    MIDL_user_free((void  *)(_source->Sid));
    }
  }

  /* routine that frees graph for struct _LSAPR_POLICY_PD_ACCOUNT_INFO */
void _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO (LSAPR_POLICY_PD_ACCOUNT_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_POLICY_REPLICA_SRCE_INFO */
void _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO (LSAPR_POLICY_REPLICA_SRCE_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->ReplicaSource);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->ReplicaAccountName);
  }

  /* routine that frees graph for struct _LSAPR_POLICY_AUDIT_EVENTS_INFO */
void _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO (LSAPR_POLICY_AUDIT_EVENTS_INFO  * _source)
  {
  if (_source->EventAuditingOptions !=0)
    {
    MIDL_user_free((void  *)(_source->EventAuditingOptions));
    }
  }

  /* routine that frees graph for union _LSAPR_POLICY_INFORMATION */
void _fgu__LSAPR_POLICY_INFORMATION (LSAPR_POLICY_INFORMATION  * _source, POLICY_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case PolicyAuditLogInformation :
      {
      break;
      }
    case PolicyAuditEventsInformation :
      {
      _fgs__LSAPR_POLICY_AUDIT_EVENTS_INFO ((LSAPR_POLICY_AUDIT_EVENTS_INFO *)&_source->PolicyAuditEventsInfo);
      break;
      }
    case PolicyPrimaryDomainInformation :
      {
      _fgs__LSAPR_POLICY_PRIMARY_DOM_INFO ((LSAPR_POLICY_PRIMARY_DOM_INFO *)&_source->PolicyPrimaryDomainInfo);
      break;
      }
    case PolicyAccountDomainInformation :
      {
      _fgs__LSAPR_POLICY_ACCOUNT_DOM_INFO ((LSAPR_POLICY_ACCOUNT_DOM_INFO *)&_source->PolicyAccountDomainInfo);
      break;
      }
    case PolicyPdAccountInformation :
      {
      _fgs__LSAPR_POLICY_PD_ACCOUNT_INFO ((LSAPR_POLICY_PD_ACCOUNT_INFO *)&_source->PolicyPdAccountInfo);
      break;
      }
    case PolicyLsaServerRoleInformation :
      {
      break;
      }
    case PolicyReplicaSourceInformation :
      {
      _fgs__LSAPR_POLICY_REPLICA_SRCE_INFO ((LSAPR_POLICY_REPLICA_SRCE_INFO *)&_source->PolicyReplicaSourceInfo);
      break;
      }
    case PolicyDefaultQuotaInformation :
      {
      break;
      }
    case PolicyModificationInformation :
      {
      break;
      }
    case PolicyAuditFullSetInformation :
      {
      break;
      }
    case PolicyAuditFullQueryInformation :
      {
      break;
      }
    case PolicyDnsDomainInformation :
      {
      _fgs__LSAPR_POLICY_DNS_DOMAIN_INFO ((LSAPR_POLICY_DNS_DOMAIN_INFO *)&_source->PolicyDnsDomainInfo);
      break;
      }
    }
  }

  /* routine that frees graph for union _LSAPR_POLICY_DOMAIN_INFORMATION */
void _fgu__LSAPR_POLICY_DOMAIN_INFORMATION (LSAPR_POLICY_DOMAIN_INFORMATION  * _source,
                                            POLICY_DOMAIN_INFORMATION_CLASS _branch)
{
    switch (_branch)
    {
    case PolicyDomainEfsInformation:
    case PolicyDomainKerberosTicketInformation:

        break;

    }
  }


  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_NAME_INFO */
void _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO (LSAPR_TRUSTED_DOMAIN_NAME_INFO  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_CONTROLLERS_INFO */
void _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO (LSAPR_TRUSTED_CONTROLLERS_INFO  * _source)
  {
  if (_source->Names !=0)
    {
      {
      unsigned long _sym69;
      for (_sym69 = 0; _sym69 < (unsigned long )(0 + _source->Entries); _sym69++)
        {
        _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Names[_sym69]);
        }
      }
    MIDL_user_free((void  *)(_source->Names));
    }
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC (LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  MIDL_user_free(_source->Sid);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION */
void _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION (LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION  * _source)
{

    ULONG Index;
    if (_source->IncomingAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->IncomingAuthInfos ; Index++ ) {
            if (_source->IncomingAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->IncomingAuthenticationInformation[Index].AuthInfo);
            }
        }
        MIDL_user_free (_source->IncomingAuthenticationInformation );
    }
    if (_source->IncomingPreviousAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->IncomingAuthInfos ; Index++ ) {
            if (_source->IncomingPreviousAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->IncomingPreviousAuthenticationInformation[Index].AuthInfo);
            }
          }
          MIDL_user_free (_source->IncomingPreviousAuthenticationInformation );
      }
    if (_source->OutgoingAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->OutgoingAuthInfos ; Index++ ) {
            if (_source->OutgoingAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->OutgoingAuthenticationInformation[Index].AuthInfo);
            }
        }
        MIDL_user_free (_source->OutgoingAuthenticationInformation );
    }
    if (_source->OutgoingPreviousAuthenticationInformation != NULL) {
        for (Index = 0; Index < _source->OutgoingAuthInfos ; Index++ ) {
            if (_source->OutgoingPreviousAuthenticationInformation[Index].AuthInfo != NULL) {
                MIDL_user_free(_source->OutgoingPreviousAuthenticationInformation[Index].AuthInfo);
            }
          }
          MIDL_user_free (_source->OutgoingPreviousAuthenticationInformation );
      }
}

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION */
void _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION (LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION  * _source)
  {
  _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX( &_source->Information );
  _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION( &_source->AuthInformation );
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 */
void _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 (LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2  * _source)
  {
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->Name);
  _fgs__LSAPR_UNICODE_STRING ((LSAPR_UNICODE_STRING *)&_source->FlatName);
  MIDL_user_free(_source->Sid);
  MIDL_user_free(_source->ForestTrustInfo);
  }

  /* routine that frees graph for struct _LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 */
void _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 (LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2  * _source)
  {
  _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2( &_source->Information );
  _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION( &_source->AuthInformation );
  }

  /* routine that frees graph for union _LSAPR_TRUSTED_DOMAIN_INFO */
void _fgu__LSAPR_TRUSTED_DOMAIN_INFO (LSAPR_TRUSTED_DOMAIN_INFO  * _source, TRUSTED_INFORMATION_CLASS _branch)
  {
  switch (_branch)
    {
    case TrustedDomainNameInformation :
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_NAME_INFO ((LSAPR_TRUSTED_DOMAIN_NAME_INFO *)&_source->TrustedDomainNameInfo);
      break;
      }
    case TrustedControllersInformation :
      {
      _fgs__LSAPR_TRUSTED_CONTROLLERS_INFO ((LSAPR_TRUSTED_CONTROLLERS_INFO *)&_source->TrustedControllersInfo);
      break;
      }
    case TrustedPosixOffsetInformation :
      {
      break;
      }
   case TrustedPasswordInformation:
      {
      break;
      }
    case TrustedDomainInformationBasic:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC ((LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC *)&_source->TrustedDomainInfoBasic);
      break;
      }
    case TrustedDomainInformationEx:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ((LSAPR_TRUSTED_DOMAIN_INFORMATION_EX *)&_source->TrustedDomainInfoEx);
      break;
      }
    case TrustedDomainAuthInformation:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION ((LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION *)&_source->TrustedAuthInfo);
      break;
      }
    case TrustedDomainFullInformation:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION ((LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION *)&_source->TrustedFullInfo);
      break;
      }
    case TrustedDomainInformationEx2Internal:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 ((LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 *)&_source->TrustedDomainInfoEx2);
      break;
      }
    case TrustedDomainFullInformation2Internal:
      {
      _fgs__LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 ((LSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 *)&_source->TrustedFullInfo2);
      break;
      }
    }
  }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\lsarm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsarm.c

Abstract:

    Local Security Authority - Reference Monitor Communication

Author:

    Scott Birrell       (ScottBi)      March 26, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>

//
// LSA Global State
//

LSAP_STATE LsapState;

//
// Lsa Reference Monitor Server Command Dispatch Table
//

NTSTATUS
LsapAsyncWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    );

PLSA_COMMAND_WORKER LsapCommandDispatch[] = {

    LsapComponentTestWrkr,
    LsapAdtWriteLogWrkr,
    LsapComponentTestWrkr,
    LsapAsyncWrkr               // LogonSessionDelete handled async

};

PLSA_COMMAND_WORKER LsapAsyncCommandDispatch[] = {
    LsapComponentTestWrkr,
    LsapAdtWriteLogWrkr,
    LsapComponentTestWrkr,
    LsapLogonSessionDeletedWrkr
};

#if 0
DWORD
LsapRmServerWorker(
    PVOID Ignored
    )
{
    PLSA_REPLY_MESSAGE Reply;
    LSA_COMMAND_MESSAGE CommandMessage;

    NTSTATUS Status;

    //
    // Initialize the LPC port message header type and data sizes for
    // for the reply message.
    //

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    ReplyMessage.MessageHeader.u1.s1.DataLength =
    ReplyMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // Called whenever the port handle is signalled
    //

    return 0;


}
#endif

NTSTATUS
LsapAsyncRmWorker(
    IN PLSA_COMMAND_MESSAGE CommandMessage
    )
{
    LSA_REPLY_MESSAGE ReplyMessage;
    NTSTATUS Status ;

    Status = (LsapAsyncCommandDispatch[CommandMessage->CommandNumber])(
                         CommandMessage,
                         &ReplyMessage);

    ReplyMessage.MessageHeader = CommandMessage->MessageHeader ;
    ReplyMessage.ReturnedStatus = Status ;

    Status = NtReplyPort( LsapState.LsaCommandPortHandle,
                          (PPORT_MESSAGE) &ReplyMessage );

    LsapFreePrivateHeap( CommandMessage );

    return Status ;


}

NTSTATUS
LsapAsyncWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )
{
    LsapAssignThread( LsapAsyncRmWorker,
                      CommandMessage,
                      pDefaultSession,
                      FALSE );

    return STATUS_PENDING ;
}



VOID
LsapRmServerThread(
   )

/*++

Routine Description:

    This function is executed by the LSA Reference Monitor Server Thread.  This
    thread receives messages from the Reference Monitor.  Examples of messages
    include Audit Messages,...  The function is implemented as a for loop
    which runs indefinitely unless an error occurs.  Currently, any
    error is fatal.  On each iteration a message is received from the
    Reference Monitor and dispatched to a handler.

Arguments:

    None.

Return Value:

    None.  Any return is a fatal error.

--*/

{
    PLSA_REPLY_MESSAGE Reply;
    // LSA_COMMAND_MESSAGE CommandMessage;
    LSA_REPLY_MESSAGE ReplyMessage;
    PLSA_COMMAND_MESSAGE CommandMessage = NULL;

    NTSTATUS Status;

    //
    // Initialize the LPC port message header type and data sizes for
    // for the reply message.
    //

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        (CSHORT) sizeof(RM_COMMAND_MESSAGE);
    ReplyMessage.MessageHeader.u1.s1.DataLength =
    ReplyMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // First time through, there is no reply.
    //

    Reply = NULL;

    //
    // Now loop indefinitely, processing incoming Command Message Packets
    //

    for(;;) {

        //
        // Wait for and receive a message from the Reference Monitor through
        // the Lsa Command LPC Port.
        //

        //
        // If Reply is NULL, then this is either the first time through the
        // loop, or we have spun the last command off async, so don't screw
        // with its buffer.  Otherwise, the pointer is valid, and ready to
        // be reused.
        //

        if ( !Reply )
        {
            CommandMessage = LsapAllocatePrivateHeap(
                                sizeof( LSA_COMMAND_MESSAGE ) );

            while ( !CommandMessage )
            {
                //
                // A bit of a pickle.  We need to have a buffer to receive on.
                // Spin and retry:
                //

                Sleep( 100 );

                CommandMessage = LsapAllocatePrivateHeap(
                                    sizeof( LSA_COMMAND_MESSAGE ) );
            }
        }

        Status = NtReplyWaitReceivePort(
                    LsapState.LsaCommandPortHandle,
                    NULL,
                    (PPORT_MESSAGE) Reply,
                    (PPORT_MESSAGE) CommandMessage
                    );


        if (Status != 0) {
            if (!NT_SUCCESS( Status ) &&
                Status != STATUS_INVALID_CID &&
                Status != STATUS_UNSUCCESSFUL
               ) {
                KdPrint(("LSASS: Lsa message receive from Rm failed x%lx\n", Status));
            }

            //
            // Ignore if client went away.
            //

            Reply = NULL;
            continue;
        }

        //
        // If an LPC request, process it.
        //

        if (CommandMessage->MessageHeader.u2.s2.Type == LPC_REQUEST) {

            //
            //
            // Now dispatch to a routine to handle the command.  Allow
            // command errors to occur without bringing system down.
            //

            Reply = &ReplyMessage;
            Reply->MessageHeader = CommandMessage->MessageHeader ;

            Status = (LsapCommandDispatch[CommandMessage->CommandNumber])(
                         CommandMessage,
                         Reply);

            if ( Status == STATUS_PENDING )
            {
                //
                // It has been sent off asynchronously.  Set the reply
                // to NULL so that we don't trip the LPC at the top of
                // the loop, and the handler will do it when it is done.
                //

                Reply = NULL ;
            }
            else
            {
                ReplyMessage.ReturnedStatus = Status;
            }

        } else {

            Reply = NULL;
        }

    }  // end_for

    return;
}


BOOLEAN
LsapRmInitializeServer(
    )

/*++

Routine Description:

    This function initializes the Lsa Reference Monitor Server Thread.
    The following steps are performed.

    o Create the Lsa Command LPC Port
    o Open the Lsa Init event created by the Reference Monitor
    o Signal the Lsa Init Event, telling RM to go ahead and connect
      to the port
    o Connect to the Reference Monitor Command Port as client
    o Listen for the Reference Monitor to connect to the port
    o Accept the connection to the port
    o Complete the connection to the port
    o Create the LSA Reference Monitor Server Thread

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if successful, else FALSE

--*/

{
    NTSTATUS Status;

    BOOLEAN BooleanStatus = FALSE;

    PORT_MESSAGE ConnectionRequest;
    REMOTE_PORT_VIEW ClientView;

    HANDLE LsaInitEventHandle;
    OBJECT_ATTRIBUTES LsaInitEventObjA;
    UNICODE_STRING LsaInitEventName;

    UNICODE_STRING RmCommandPortName, LsaCommandPortName;

    OBJECT_ATTRIBUTES LsaCommandPortObjA;
    SECURITY_QUALITY_OF_SERVICE DynamicQos;

    HANDLE Thread;
    DWORD Ignore;

    //
    // Create the Lsa Command LPC Port.  This port will receive
    // commands from the Reference Monitor.
    //

    RtlInitUnicodeString( &LsaCommandPortName, L"\\SeLsaCommandPort" );

    //
    // Setup to create LSA Command Port
    //

    InitializeObjectAttributes(
        &LsaCommandPortObjA,
        &LsaCommandPortName,
        0,
        NULL,
        NULL
        );

    Status = NtCreatePort(
                 &LsapState.LsaCommandPortHandle,
                 &LsaCommandPortObjA,
                 0,
                 sizeof(LSA_COMMAND_MESSAGE),
                 sizeof(LSA_COMMAND_MESSAGE) * 32
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Create failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Open the LSA Init Event created by the Reference Monitor
    //

    RtlInitUnicodeString( &LsaInitEventName, L"\\SeLsaInitEvent" );

    InitializeObjectAttributes(
        &LsaInitEventObjA,
        &LsaInitEventName,
        0,
        NULL,
        NULL
        );

    Status = NtOpenEvent(
        &LsaInitEventHandle,
        EVENT_MODIFY_STATE,
        &LsaInitEventObjA
        );

    //
    // If the LSA Init event could not be opened, the LSA cannot
    // synchronize with the Reference Monitor so neither component will
    // function correctly.
    //

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Lsa Init Event Open failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Signal the LSA Init Event.  If the signalling fails, the LSA
    // is not able to synchronize properly with the Reference Monitor.
    // This is a serious error which prevents both components from
    // functioning correctly.
    //

    Status = NtSetEvent( LsaInitEventHandle, NULL );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Init Event Open failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Set up the security quality of service parameters to use over the
    // port.  Use the most efficient (least overhead) - which is dynamic
    // rather than static tracking.
    //

    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    //
    // Connect to the Reference Monitor Command Port.  This port
    // is used to send commands from the LSA to the Reference Monitor.
    //

    RtlInitUnicodeString( &RmCommandPortName, L"\\SeRmCommandPort" );

    Status = NtConnectPort(
                 &LsapState.RmCommandPortHandle,
                 &RmCommandPortName,
                 &DynamicQos,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Connect to Rm Command Port failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Listen for the Reference Monitor To Connect to the LSA
    // Command Port.
    //

    ConnectionRequest.u1.s1.TotalLength = sizeof(ConnectionRequest);
    ConnectionRequest.u1.s1.DataLength = (CSHORT)0;
    Status = NtListenPort(
                 LsapState.LsaCommandPortHandle,
                 &ConnectionRequest
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Listen failed 0x%lx\n",Status));
        goto InitServerError;
    }

    //
    // Accept the connection to the Lsa Command Port.
    //

    ClientView.Length = sizeof(ClientView);
    Status = NtAcceptConnectPort(
                 &LsapState.LsaCommandPortHandle,
                 NULL,
                 &ConnectionRequest,
                 TRUE,
                 NULL,
                 &ClientView
                 );

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Accept Connect failed 0x%lx\n",Status));

        goto InitServerError;
    }

    //
    // Complete the connection
    //

    Status = NtCompleteConnectPort(LsapState.LsaCommandPortHandle);

    if (!NT_SUCCESS(Status)) {

        KdPrint(("LsapRmInitializeServer - Port Complete Connect failed 0x%lx\n",Status));
        goto InitServerError;
    }



    //
    // Create the LSA Reference Monitor Server Thread
    //

    Thread = CreateThread(
                 NULL,
                 0L,
                 (LPTHREAD_START_ROUTINE) LsapRmServerThread,
                 (LPVOID)0,
                 0L,
                 &Ignore
                 );

    if (Thread == NULL) {

        KdPrint(("LsapRmInitializeServer - Create Thread  failed 0x%lx\n",Status));
    } else {
        CloseHandle(Thread);
        Thread = NULL;
    }

    BooleanStatus = TRUE;

    goto InitServerCleanup;

InitServerError:

    //
    // Perform cleanup needed only in error cases here.
    //

InitServerCleanup:

    //
    // Perform cleanup needed in all cases here
    //

    return BooleanStatus;
}


NTSTATUS
LsapCallRm(
    IN RM_COMMAND_NUMBER CommandNumber,
    IN OPTIONAL PVOID CommandParams,
    IN ULONG CommandParamsLength,
    OUT OPTIONAL PVOID ReplyBuffer,
    IN ULONG ReplyBufferLength
    )

/*++

Routine Description:

    This function sends a command to the Reference Monitor from the LSA via
    the LSA Command LPC Port.  This function must only be called from within
    Lsa code.  If the command has parameters, they will be copied directly
    into a message structure and sent via LPC, therefore, the supplied
    parameters may not contain any absolute pointers.  A caller must remove
    pointers by "marshalling" them into the buffer CommandParams.

    To implement a new RM command, do the following:
    ================================================

    (1)  Provide in the executive an RM worker routine called
         SepRm<command>Wrkr to service the command.  See file
         ntos\se\rmmain.c for examples.  NOTE: If the command takes
         parameters, they must not contain any absolute pointers (addresses).

    (2)  In file private\inc\ntrmlsa.h, append the name of the new command to
         the enumerated type RM_COMMAND_NUMBER.  Change the #define for
         RmMaximumCommand to reference the new command.

    (3)  Add the SepRm<command>Wrkr to the command dispatch table structure
         SepRmCommandDispatch[] in file ntos\se\rmmain.c.

    (4)  Add function prototypes to lsap.h and sep.h.

Arguments:

    CommandNumber - Specifies the command

    CommandParams - Optional command-dependent parameters.  The parameters
        must be in marshalled format, that is, there must not be any
        absolute address pointers in the buffer.

    CommandParamsLength - Length in bytes of command parameters.  Must be 0
          if no command parameters supplied.

    ReplyBuffer - Reply Buffer in which data (if any) from the command will
        be returned.

    ReplyBufferLength - Length of ReplyBuffer in bytes.

Return Value:

    NTSTATUS - Result Code.  This is either a result code returned from
        trying to send the command/receive the reply, or a status code
        from the command itself.

--*/

{
    NTSTATUS Status;
    RM_COMMAND_MESSAGE CommandMessage;
    RM_REPLY_MESSAGE ReplyMessage;

    //
    // Assert that the Command Number is valid.
    //

    ASSERT( CommandNumber >= RmMinimumCommand &&
            CommandNumber <= RmMaximumCommand );

    //
    // If command parameters are supplied, assert that the length of the
    // command parameters is positive and not too large.  If no command
    // parameters are supplied, assert that the length field is 0.
    //

    ASSERT( ( ARGUMENT_PRESENT( CommandParams ) &&
              CommandParamsLength > 0 &&
              CommandParamsLength <= RM_MAXIMUM_COMMAND_PARAM_SIZE ) ||

            ( !ARGUMENT_PRESENT( CommandParams ) &&
              CommandParamsLength == 0 )
          );

    //
    // If a Reply Buffer is provided, assert that its length is > 0
    // and not too large.
    //

    ASSERT( ( ARGUMENT_PRESENT( ReplyBuffer ) &&
              ReplyBufferLength > 0 &&
              ReplyBufferLength <= LSA_MAXIMUM_REPLY_BUFFER_SIZE ) ||

            ( !ARGUMENT_PRESENT( ReplyBuffer ) &&
              ReplyBufferLength == 0 )
          );

    //
    // Construct a message for LPC.  First, fill in the message header
    // fields for LPC, specifying the message type and data sizes for
    // the outgoing CommandMessage and the incoming ReplyMessage.
    //

    CommandMessage.MessageHeader.u2.ZeroInit = 0;
    CommandMessage.MessageHeader.u1.s1.TotalLength =
        ((CSHORT) RM_COMMAND_MESSAGE_HEADER_SIZE +
        (CSHORT) CommandParamsLength);
    CommandMessage.MessageHeader.u1.s1.DataLength =
        CommandMessage.MessageHeader.u1.s1.TotalLength -
        (CSHORT) sizeof(PORT_MESSAGE);

    ReplyMessage.MessageHeader.u2.ZeroInit = 0;
    ReplyMessage.MessageHeader.u1.s1.DataLength = (CSHORT) ReplyBufferLength;
    ReplyMessage.MessageHeader.u1.s1.TotalLength =
        ReplyMessage.MessageHeader.u1.s1.DataLength +
        (CSHORT) sizeof(PORT_MESSAGE);

    //
    // Next, fill in the header info needed by the Reference Monitor.
    //

    CommandMessage.CommandNumber = CommandNumber;
    ReplyMessage.ReturnedStatus = STATUS_SUCCESS;

    //
    // Finally, copy the command parameters (if any) into the message buffer.
    //

    if (CommandParamsLength > 0) {

        RtlCopyMemory(CommandMessage.CommandParams,CommandParams,CommandParamsLength);
    }

    // Send Message to the RM via the RM Command Server LPC Port
    //

    Status = NtRequestWaitReplyPort(
                 LsapState.RmCommandPortHandle,
                 (PPORT_MESSAGE) &CommandMessage,
                 (PPORT_MESSAGE) &ReplyMessage
                 );

    //
    // If the command was successful, copy the data back to the output
    // buffer.
    //

    if (NT_SUCCESS(Status)) {

        //
        // Move output from command (if any) to buffer.  Note that this
        // is done even if the command returns status, because some status
        // values are not errors.
        //

        if (ARGUMENT_PRESENT(ReplyBuffer)) {

            RtlCopyMemory(
                ReplyBuffer,
                ReplyMessage.ReplyBuffer,
                ReplyBufferLength
                );

        }

        //
        // Return status from command.
        //

        Status = ReplyMessage.ReturnedStatus;

    } else {

        KdPrint(("Security: Command sent from LSA to RM returned 0x%lx\n",Status));
    }

    return Status;
}



NTSTATUS
LsapComponentTestWrkr(
    IN PLSA_COMMAND_MESSAGE CommandMessage,
    OUT PLSA_REPLY_MESSAGE ReplyMessage
    )

/*++

Routine Description:

    This function processes the Component Test LSA Rm Server command.
    This is a temporary command that can be used to verifiey that the link
    from RM to LSA is working.

Arguments:

    CommandMessage - Pointer to structure containing LSA command message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command number (LsapComponentTestCommand).  This command
        currently has one parameter, the fixed value 0x1234567.

    ReplyMessage - Pointer to structure containing LSA reply message
        information consisting of an LPC PORT_MESSAGE structure followed
        by the command ReturnedStatus field in which a status code from the
        command will be returned.

Return Value:

    STATUS_SUCCESS - The test call has completed successfully.

    STATUS_INVALID_PARAMETER - The argument value received was not the
        expected argument value.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Strict check that command is correct.
    //

    ASSERT( CommandMessage->CommandNumber == LsapComponentTestCommand );

    KdPrint(("Security: LSA Component Test Command Received\n"));

    //
    // Verify that the parameter value passed is as expected.
    //

    if (*((ULONG *) CommandMessage->CommandParams) !=
        LSA_CT_COMMAND_PARAM_VALUE ) {

        Status = STATUS_INVALID_PARAMETER;
    }

    UNREFERENCED_PARAMETER(ReplyMessage); // Intentionally not referenced
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\lsasrvmm.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    lsasrvmm.c

Abstract:

    This module provides LSA Server Memory Management including the following

    - Heap allocation and free routines
    - Free List Management.
    - RPC memory copy routines

Author:

    Jim Kelly         JimK         February 26, 1991
    Scott Birrell     ScottBi      February 29, 1992

Revision History:

--*/

#include <lsapch2.h>




NTSTATUS
LsapMmCreateFreeList(
    OUT PLSAP_MM_FREE_LIST FreeList,
    IN ULONG MaxEntries
    )

/*++

Routine Description:

    This function creates a Free List.  The Free List structure is
    initialized and, if a non-zero maximum entry count is
    specified, an array of buffer entries is created.

Arguments:

    FreeList - Pointer to Free List structure to be initialized.  It is
        the caller's responsibility to provide memory for this structure.

    MaxEntries - Specifies the maximum entries for the Free List.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.  In this case,
            the Free List header is initialized with a zero count.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    FreeList->MaxCount = MaxEntries;
    FreeList->UsedCount = 0;

    if (MaxEntries > 0) {

        FreeList->Buffers =
            LsapAllocateLsaHeap(MaxEntries * sizeof(LSAP_MM_FREE_LIST_ENTRY));

        if (FreeList->Buffers == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            FreeList->MaxCount = 0;
        }
    }

    return(Status);
}


NTSTATUS
LsapMmAllocateMidl(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PVOID *BufferAddressLocation,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This function allocates memory for a buffer via MIDL_user_allocate
    and returns the resulting buffer address in a specified location.
    The address of the allocated buffer is recorded in the Free List.

Arguments:

    FreeList - Optional pointer to Free List.

    BufferAddressLocation - Pointer to location that will receive either the
        address of the allocated buffer, or NULL.

    BufferLength - Size of the buffer in bytes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.

--*/

{
    //
    // If no Free List is specified, just allocate the memory.
    //

    if (FreeList == NULL) {

        *BufferAddressLocation = MIDL_user_allocate(BufferLength);

        if (*BufferAddressLocation != NULL) {

            return(STATUS_SUCCESS);
        }

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // A Free List is specified.
    //

    if (FreeList->UsedCount < FreeList->MaxCount) {

        *BufferAddressLocation = MIDL_user_allocate(BufferLength);

        if (*BufferAddressLocation != NULL) {

            FreeList->Buffers[FreeList->UsedCount].Buffer = *BufferAddressLocation;
            FreeList->Buffers[FreeList->UsedCount].Options = LSAP_MM_MIDL;
            FreeList->UsedCount++;
            return(STATUS_SUCCESS);
        }
    }

    *BufferAddressLocation = NULL;
    return(STATUS_INSUFFICIENT_RESOURCES);
}


VOID
LsapMmFreeLastEntry(
    IN PLSAP_MM_FREE_LIST FreeList
    )

/*++

Routine Description:

    This function frees the last buffer appeended to the Free List.

Arguments:

    FreeList - Pointer to Free List.

--*/

{
    ULONG LastIndex = FreeList->UsedCount - 1;

    if (FreeList->Buffers[LastIndex].Options & LSAP_MM_MIDL) {

        MIDL_user_free( FreeList->Buffers[LastIndex].Buffer );

    } else {

        LsapFreeLsaHeap( FreeList->Buffers[LastIndex].Buffer );
    }

    FreeList->Buffers[LastIndex].Buffer = NULL;
    FreeList->UsedCount--;
}

VOID
LsapMmCleanupFreeList(
    IN PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Options
    )

/*++

Routine Description:

    This function optionally frees up buffers on the specified Free List,
    and disposes of the List buffer pointer array.

Arguments:

    FreeList - Pointer to Free List

    Options - Specifies optional actions to be taken

        LSAP_MM_FREE_BUFFERS - Free buffers on the list.

Return Values:

    None.

--*/

{
    ULONG Index;
    PVOID Buffer = NULL;

    //
    // If requested, free up the memory for each buffer on the list.
    //

    if (Options & LSAP_MM_FREE_BUFFERS) {

        for (Index = 0; Index < FreeList->UsedCount; Index++) {

            Buffer = FreeList->Buffers[Index].Buffer;

            if (FreeList->Buffers[Index].Options & LSAP_MM_MIDL) {

                MIDL_user_free(Buffer);
                continue;
            }

            if (FreeList->Buffers[Index].Options & LSAP_MM_HEAP) {

                LsapFreeLsaHeap(Buffer);
            }
        }
    }

    //
    // Now dispose of the List buffer pointer array.
    //

    if (FreeList->MaxCount > 0) {

        LsapFreeLsaHeap( FreeList->Buffers );
        FreeList->Buffers = NULL;
    }
}


NTSTATUS
LsapRpcCopyUnicodeString(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString
    )

/*++

Routine Description:

    This function copies a Unicode String to an output string, allocating
    memory for the output string's buffer via MIDL_user_allocate.  The
    buffer is recorded on the specified Free List (if any).

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationString - Pointer to Output Unicode String structure to
        be initialized.

    SourceString - Pointer to input string

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PWSTR Buffer = NULL;

    //
    // Copy the Unicode String structure.
    //

    *DestinationString = *SourceString;

    //
    // If there is no source string buffer, just return.
    //

    if (SourceString->Buffer == NULL) {

        goto RpcCopyUnicodeStringFinish;
    }

    //
    // If the source string is of NULL length, set the destination buffer
    // to NULL.
    //

    if (SourceString->MaximumLength == 0) {

        DestinationString->Buffer = NULL;
        goto RpcCopyUnicodeStringFinish;
    }

    if (ARGUMENT_PRESENT(FreeList)) {

        Status = LsapMmAllocateMidl(
                     FreeList,
                     (PVOID *) &DestinationString->Buffer,
                     SourceString->MaximumLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto RpcCopyUnicodeStringError;
        }

    } else {

         DestinationString->Buffer =
             MIDL_user_allocate( SourceString->MaximumLength );

         if (DestinationString->Buffer == NULL) {

             goto RpcCopyUnicodeStringError;
         }
    }

    //
    // Copy the source Unicode string over to the MIDL-allocated destination.
    //

    RtlCopyUnicodeString( DestinationString, SourceString );

RpcCopyUnicodeStringFinish:

    return(Status);

RpcCopyUnicodeStringError:

    Status = STATUS_INSUFFICIENT_RESOURCES;
    goto RpcCopyUnicodeStringFinish;
}


NTSTATUS
LsapRpcCopyUnicodeStrings(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    IN ULONG Count,
    OUT PUNICODE_STRING *DestinationStrings,
    IN PUNICODE_STRING SourceStrings
    )

/*++

Routine Description:

    This function constructs an array of Unicode strings in which the
    memory for the array and the string buffers has been allocated via
    MIDL_user_allocate().  It is called by server API workers to construct
    output string arrays.  Memory allocated can optionally be placed on
    the caller's Free List (if any).

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationStrings - Receives a pointer to an initialized array of Count
        Unicode String structures.

    SourceStrings - Pointer to input array of Unicode String structures.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0, FreeIndex;
    PUNICODE_STRING OutputDestinationStrings = NULL;
    ULONG OutputDestinationStringsLength;

    if (Count == 0) {

        goto CopyUnicodeStringsFinish;
    }

    //
    // Allocate zero-filled memory for the array of Unicode String
    // structures.
    //

    OutputDestinationStringsLength = Count * sizeof (UNICODE_STRING);
    OutputDestinationStrings = MIDL_user_allocate( OutputDestinationStringsLength );

    Status = STATUS_INSUFFICIENT_RESOURCES;

    if (OutputDestinationStrings == NULL) {

        goto CopyUnicodeStringsError;
    }

    //
    // Now copy each string, allocating memory via MIDL_user_allocate()
    // for its buffer if non-NULL.
    //

    for (Index = 0; Index < Count; Index++) {

        Status = LsapRpcCopyUnicodeString(
                     FreeList,
                     &OutputDestinationStrings[Index],
                     &SourceStrings[Index]
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto CopyUnicodeStringsError;
    }

CopyUnicodeStringsFinish:

    *DestinationStrings = OutputDestinationStrings;

    return(Status);

CopyUnicodeStringsError:

    //
    // If necessary, free up any Unicode string buffers allocated here.
    //

    for (FreeIndex = 0; FreeIndex < Index; FreeIndex++) {

        if (OutputDestinationStrings[ FreeIndex].Buffer != NULL) {

            MIDL_user_free( &OutputDestinationStrings[ FreeIndex].Buffer );
        }
    }

    //
    // If necessary, free the buffer allocated to hold the array of
    // Unicode string structures.
    //

    if (OutputDestinationStrings != NULL) {

        MIDL_user_free( OutputDestinationStrings );
        OutputDestinationStrings = NULL;
    }

    goto CopyUnicodeStringsFinish;
}


NTSTATUS
LsapRpcCopySid(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PSID *DestinationSid,
    IN PSID SourceSid
    )

/*++

Routine Description:

    This function makes a copy of a Sid in which memory is allocated
    via MIDL user allocate.  It is called to return Sids via RPC to
    the client.

Arguments:

    FreeList - Optional pointer to Free List.

    DestinationSid - Receives a pointer to the Sid copy.

    SourceSid - Pointer to the Sid to be copied.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG SidLength;

    if ( SourceSid ) {

        SidLength = RtlLengthSid( SourceSid );

        Status = LsapMmAllocateMidl(
                     FreeList,
                     DestinationSid,
                     SidLength
                     );

        if (NT_SUCCESS(Status)) {

            RtlCopyMemory( *DestinationSid, SourceSid, SidLength );
        }

    } else {

        *DestinationSid = NULL;
    }

    return( Status );
}


NTSTATUS
LsapRpcCopyTrustInformation(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUST_INFORMATION OutputTrustInformation,
    IN PLSAPR_TRUST_INFORMATION InputTrustInformation
    )

/*++

Routine Description:

    This function makes a copy of a Trust Information structure in which
    the Sid and Name buffer have been allocated individually by
    MIDL_user_allocate.  The function is used to generate output
    Trust Information for RPC server API.  Cleanup is the responsibility
    of the caller.

Arguments:

    FreeList - Optional pointer to Free List.

    OutputTrustInformation - Points to Trust Information structure to
        be filled in.  This structure has normally been allocated via
        MIDL_user_allocate.

    InputTrustInformation - Pointer to input Trust Information.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Copy the Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->Name,
                 (PUNICODE_STRING) &InputTrustInformation->Name
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Sid.
    //

    Status = LsapRpcCopySid(
                 FreeList,
                 (PSID) &OutputTrustInformation->Sid,
                 (PSID) InputTrustInformation->Sid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

CopyTrustInformationFinish:

    return(Status);

CopyTrustInformationError:

    goto CopyTrustInformationFinish;
}



NTSTATUS
LsapRpcCopyTrustInformationEx(
    IN OPTIONAL PLSAP_MM_FREE_LIST FreeList,
    OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX OutputTrustInformation,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX InputTrustInformation
    )
/*++

Routine Description:

    This function makes a copy of a Trust Information Ex structure in which
    the Sid and Name buffers have been allocated individually by
    MIDL_user_allocate.  The function is used to generate output
    Trust Information for RPC server API.  Cleanup is the responsibility
    of the caller.

Arguments:

    FreeList - Optional pointer to Free List.

    OutputTrustInformation - Points to Trust Information structure to
        be filled in.  This structure has normally been allocated via
        MIDL_user_allocate.

    InputTrustInformation - Pointer to input Trust Information.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( OutputTrustInformation, sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ) );
    //
    // Copy the Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->Name,
                 (PUNICODE_STRING) &InputTrustInformation->Name
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Flat Name.
    //

    Status = LsapRpcCopyUnicodeString(
                 FreeList,
                 (PUNICODE_STRING) &OutputTrustInformation->FlatName,
                 (PUNICODE_STRING) &InputTrustInformation->FlatName
                 );

    if (!NT_SUCCESS(Status)) {

        goto CopyTrustInformationError;
    }

    //
    // Copy the Sid.
    //

    if ( InputTrustInformation->Sid ) {

        Status = LsapRpcCopySid(
                     FreeList,
                     (PSID) &OutputTrustInformation->Sid,
                     (PSID) InputTrustInformation->Sid
                     );

        if (!NT_SUCCESS(Status)) {

            goto CopyTrustInformationError;
        }

    } else {

        OutputTrustInformation->Sid = NULL;
    }

    //
    // Copy the remaining information
    //
    OutputTrustInformation->TrustType = InputTrustInformation->TrustType;
    OutputTrustInformation->TrustDirection = InputTrustInformation->TrustDirection;
    OutputTrustInformation->TrustAttributes = InputTrustInformation->TrustAttributes;

CopyTrustInformationFinish:

    return(Status);

CopyTrustInformationError:

    if ( FreeList == NULL ) {

        MIDL_user_free( OutputTrustInformation->Name.Buffer );
        OutputTrustInformation->Name.Buffer = NULL;

        MIDL_user_free( OutputTrustInformation->FlatName.Buffer );
        OutputTrustInformation->FlatName.Buffer = NULL;

        MIDL_user_free( OutputTrustInformation->Sid );
        OutputTrustInformation->Sid = NULL;
    }

    goto CopyTrustInformationFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\rpcinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    rpcinit.c

Abstract:

    LSA - RPC Server Initialization

Author:

    Scott Birrell       (ScottBi)      April 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include <efsrpc.h>

#include "adtgenp.h"

PVOID LsapRegisterTcpIpTask = NULL;

NTSTATUS
LsapRegisterTcpIp(
    PVOID pVoid
    )
/*++

Routine Description:

    This routine registers the LSA interface over any protocols that have
    been registered so far.  This routine is designed to be called on a
    domain controller after the DS has started since it already waits
    for the conditions necessary to register its RPC interface over TCP/IP.
    

    N.B. Should the DS ever not register of TCP/IP this mechanism will
    need to be updated.
    
    N.B. This routine is called from the thread pool call back mechanism.
    
Arguments:

    pVoid -- ignored.

Return Value:

    STATUS_SUCCESS

--*/
{
    ULONG RpcStatus = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    RPC_BINDING_VECTOR *BindingVector;

    //
    // Register LSA's interface over the new interfaces
    //
    RpcStatus = RpcServerInqBindings(&BindingVector);
    if (RpcStatus == 0) {

        RpcStatus = RpcEpRegister(
                        lsarpc_ServerIfHandle,
                        BindingVector,
                        NULL,                   // no uuid vector
                        L""  // no annotation
                        );

        RpcBindingVectorFree(&BindingVector);
    }

    if (RpcStatus != 0) {

        SpmpReportEvent( TRUE,
                         EVENTLOG_WARNING_TYPE,
                         LSAEVENT_LOOKUP_TCPIP_NOT_INSTALLED,
                         0,
                         sizeof( ULONG ),
                         &RpcStatus,
                         0);
    }

    //
    // Deregister ourselves
    //
    ASSERT(NULL != LsapRegisterTcpIpTask);
    Status = LsaICancelNotification(LsapRegisterTcpIpTask);
    ASSERT(NT_SUCCESS(Status));
    LsapRegisterTcpIpTask = NULL;

    //
    // Close the handle
    //
    ASSERT(pVoid != NULL);
    CloseHandle((HANDLE)pVoid);

    return STATUS_SUCCESS;

}

NTSTATUS
LsapRPCInit(
    )

/*++

Routine Description:

    This function performs the initialization of the RPC server in the LSA
    subsystem.  Clients such as the Local Security Manager on this or some
    other machine will then be able to call the LSA API that use RPC .

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code.

        All Result Code returned are from called routines.

Environment:

     User Mode
--*/

{
    NTSTATUS         NtStatus;
    NTSTATUS         TmpStatus;
    LPWSTR           ServiceName;


    //
    // Publish the Lsa server interface package...
    //
    //
    // NOTE:  Now all RPC servers in lsass.exe (now winlogon) share the same
    // pipe name.  However, in order to support communication with
    // version 1.0 of WinNt,  it is necessary for the Client Pipe name
    // to remain the same as it was in version 1.0.  Mapping to the new
    // name is performed in the Named Pipe File System code.
    //
    //

    ServiceName = L"lsass";
    NtStatus = RpcpAddInterface( ServiceName, lsarpc_ServerIfHandle);

    if (!NT_SUCCESS(NtStatus)) {

        LsapLogError(
            "LSASS:  Could Not Start RPC Server.\n"
            "        Failing to initialize LSA Server.\n",
            NtStatus
            );
    }

    TmpStatus = RpcpAddInterface( ServiceName, efsrpc_ServerIfHandle);
    if (!NT_SUCCESS(TmpStatus)) {

        LsapLogError(
            "LSASS:  Could Not Start RPC Server.\n"
            "        Failing to initialize LSA Server.\n",
            TmpStatus
            );
    }

    //
    // Register for authenticated RPC for name and sid lookups
    //

#ifndef RPC_C_AUTHN_NETLOGON
#define RPC_C_AUTHN_NETLOGON 0x44
#endif // RPC_C_AUTHN_NETLOGON

    TmpStatus = I_RpcMapWin32Status(RpcServerRegisterAuthInfo(
                    NULL,                       // no principal name
                    RPC_C_AUTHN_NETLOGON,
                    NULL,                       // no get key fn
                    NULL                        // no get key argument
                    ));
    if (!NT_SUCCESS(TmpStatus))
    {
        DebugLog((DEB_ERROR,"Failed to register NETLOGON auth info: 0x%x\n",TmpStatus));
    }

    //
    // If we are a DC, register our interface over TCP/IP for fast
    // lookups.  Note that this routine is called so early on in startup
    // the the TCP/IP interface is not ready yet.  We must wait until
    // it is ready.  The DS currently waits on the necessary conditions, so
    // simply wait until the DS is ready to register our interface over
    // TCP/IP.
    //
    {
        NT_PRODUCT_TYPE Product;
        if (   RtlGetNtProductType( &Product ) 
           && (Product == NtProductLanManNt) ) {

            HANDLE hDsStartup;

            hDsStartup = CreateEvent(NULL, 
                                     TRUE,  
                                     FALSE,
                                     NTDS_DELAYED_STARTUP_COMPLETED_EVENT);

            if (hDsStartup) {
                
                LsapRegisterTcpIpTask = LsaIRegisterNotification(
                                         LsapRegisterTcpIp,
                                         (PVOID) hDsStartup,
                                         NOTIFIER_TYPE_HANDLE_WAIT,
                                         0, // no class,
                                         0,
                                         0,
                                         hDsStartup);
            }
        } 
    }
    
    {
        RPC_STATUS RpcStatus;

        //
        // enable lsa rpc server to listen on LRPC transport on endpoint 'audit'
        // this endpoint is used by auditing clients
        //

        RpcStatus = RpcServerUseProtseqEp(
                        L"ncalrpc",
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT , // max concurrent calls
                        L"audit",                        // end point
                        NULL                             // security descriptor
                        );

        if ( RpcStatus != RPC_S_OK )
        {
            DebugLog((DEB_ERROR, "RpcServerUseProtseqEp failed for ncalrpc: %d\n",
                      RpcStatus));
            NtStatus = I_RpcMapWin32Status( RpcStatus );
        }
    }
    

    return(NtStatus);
}

VOID LSAPR_HANDLE_rundown(
    LSAPR_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status;

    //
    // Close and free the handle.  Since the container handle reference
    // count includes one reference for every reference made to the
    // target handle, the container's reference count will be decremented
    // by n where n is the reference count in the target handle.
    //

    Status = LsapDbCloseObject(
                 &LsaHandle,
                 LSAP_DB_DEREFERENCE_CONTR |
                    LSAP_DB_VALIDATE_HANDLE |
                    LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES,
                 STATUS_SUCCESS
                 );

}


VOID PLSA_ENUMERATION_HANDLE_rundown(
    PLSA_ENUMERATION_HANDLE LsaHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    DBG_UNREFERENCED_PARAMETER(LsaHandle);

    return;
}

VOID AUDIT_HANDLE_rundown(
    AUDIT_HANDLE hAudit
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle.

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = LsapUnregisterAuditEvent( &hAudit );
    
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"AUDIT_HANDLE_rundown: LsapUnregisterAuditEvent: 0x%x\n", Status));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\sepriv.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    sepriv.c

Abstract:

    Security Runtime Library Privilege Routines

    (Temporary copy of \nt\private\ntos\rtl\sepriv.c to allow
     ntdailybld version of ntdll.dll to be used)

    These routines perform operations with privilege sets

Author:

    Scott Birrell       (ScottBi)       June 17, 1991

Environment:

Revision History:
    Pete Skelly         (petesk)        Modified LsapRtlAddPrivileges to work within a preallocated
                                        buffer for performance reasons

--*/
#include <lsapch2.h>
#include <string.h>

#define LsapRtlEqualPrivileges(FirstPrivilege, SecondPrivilege)                 \
    (RtlEqualLuid(&(FirstPrivilege)->Luid, &(SecondPrivilege)->Luid))

#define PRIVILEGE_SET_STEP_SIZE 20


NTSTATUS
LsapRtlAddPrivileges(
    IN OUT PPRIVILEGE_SET * RunningPrivileges,
    IN OUT PULONG           MaxRunningPrivileges,
    IN PPRIVILEGE_SET       PrivilegesToAdd,
    IN ULONG                Options,
    OUT OPTIONAL BOOLEAN *  Changed
    )

/*++

Routine Description:

    This function adds and/or updates privileges in a privilege set.  The
    existing privilege set is unaltered, a new privilege set being generated.
    Existing privileges and Udpate privilege sets may point to the same location.
    The memory for the new privilege set must already be allocated by the
    caller.  To assist in calculating the size of buffer required, the
    routine may be called in 'query' mode by supplying buffer size of 0.  In
    this mode, the amount of memory required is returned and no copying
    takes place.

    WARNING:  Privileges within each privilege set must all be distinct, that
    is, there must not be two privileges in the same set having the same LUID.

Arguments:

    RunningPrivileges - Pointer to a pointer pointing to a running privilege set.

    MaxRunningPrivileges - maximum number of privileges that can be copied into the current privilege set
                           before it must be grown.

    PrivilegesToAdd - Pointer to privilege set specifying privileges to
        be added.  The attributes of privileges in this set that also exist
        in the ExistingPrivileges set supersede the attributes therein.

    Options - Specifies optional actions.

        RTL_COMBINE_PRIVILEGE_ATTRIBUTES - If the two privilege sets have
            privileges in common, combine the attributes

        RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES - If the two privilege sets
            have privileges in common, supersede the existing attributes
            with those specified in PrivilegesToAdd.

    Changed - Used to indicate whether any change has been made

Return Value:

    NTSTATUS - Standard Nt Result Code

        - STATUS_BUFFER_OVERFLOW - This warning indicates that the buffer
              output privilege set overflowed.  Caller should test for this
              warning and if received, allocate a buffer of sufficient size
              and repeat the call.

Environment:

    User or Kernel modes.

--*/

{
    PLUID_AND_ATTRIBUTES Privilege;
    ULONG AddIndex = 0L;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CurrentPrivilegeCount = 0;
    DWORD OldPrivilegeSetSize = 0;

    //
    // Verify that mandatory parameters have been specified.
    // specified.
    //

    if (RunningPrivileges == NULL ||
        MaxRunningPrivileges == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Validate the Options parameter.
    //

    if ((Options != RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES) &&
        (Options != RTL_COMBINE_PRIVILEGE_ATTRIBUTES)) {

        return STATUS_INVALID_PARAMETER;
    }

    if ( Changed ) {

        *Changed = FALSE;
    }

    if((PrivilegesToAdd == NULL) || (PrivilegesToAdd->PrivilegeCount == 0))
    {
        return STATUS_SUCCESS;
    }

    if(*RunningPrivileges == NULL)
    {
        PPRIVILEGE_SET UpdatedPrivileges = NULL;

        ASSERT(PrivilegesToAdd->PrivilegeCount > 0);

        OldPrivilegeSetSize = sizeof (PRIVILEGE_SET) + sizeof(LUID_AND_ATTRIBUTES)*
                                                       (PrivilegesToAdd->PrivilegeCount - ANYSIZE_ARRAY);


        // We need to grow our privilege set
        UpdatedPrivileges = (PPRIVILEGE_SET)MIDL_user_allocate(  OldPrivilegeSetSize + 
                                                                sizeof(LUID_AND_ATTRIBUTES)* PRIVILEGE_SET_STEP_SIZE);

        if (UpdatedPrivileges == NULL) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(UpdatedPrivileges, PrivilegesToAdd,  OldPrivilegeSetSize);
        *RunningPrivileges = UpdatedPrivileges;
        *MaxRunningPrivileges = PrivilegesToAdd->PrivilegeCount + PRIVILEGE_SET_STEP_SIZE;

        if ( Changed ) {

            *Changed = TRUE;
        }

        return STATUS_SUCCESS;
    }

    CurrentPrivilegeCount = (*RunningPrivileges)->PrivilegeCount;

    //
    // For each privilege to add, see if it's in the running privilege list,
    // set the attributes if it is, append it if it isn't.
    //

    //
    // Note, we dont' modify the count of RunningPrivileges until the end, so we don't 
    // inefficiently search things we are currently adding (there should be no duplicates in what
    // we're currently adding);
    //

    for(AddIndex = 0;
        AddIndex < PrivilegesToAdd->PrivilegeCount;
        AddIndex++) {

            Privilege = NULL;

            if ((Privilege = LsapRtlGetPrivilege(
                                 &PrivilegesToAdd->Privilege[AddIndex],
                                 *RunningPrivileges
                                 )) != NULL) {

                if( Options & RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES &&
                    Privilege->Attributes != PrivilegesToAdd->Privilege[AddIndex].Attributes ) {

                    if ( Changed ) {

                        *Changed = TRUE;
                    }

                    Privilege->Attributes = PrivilegesToAdd->Privilege[AddIndex].Attributes;
                }
            }
            else
            {
                // This is a new privilege, so add it to the end

                ASSERT(*MaxRunningPrivileges >= CurrentPrivilegeCount);
                if((CurrentPrivilegeCount+1) > *MaxRunningPrivileges)
                {

                    // We need to grow our privilege set
                    PPRIVILEGE_SET UpdatedPrivileges = (PPRIVILEGE_SET)MIDL_user_allocate( sizeof (PRIVILEGE_SET) + 
                                                                           sizeof(LUID_AND_ATTRIBUTES)*
                                                                                  (*MaxRunningPrivileges + 
                                                                                   PRIVILEGE_SET_STEP_SIZE - 1));

                    if (UpdatedPrivileges == NULL) {

                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                    if(*MaxRunningPrivileges > 0)
                    {
                        RtlCopyMemory(UpdatedPrivileges, *RunningPrivileges, sizeof (PRIVILEGE_SET) + 
                                                                           sizeof(LUID_AND_ATTRIBUTES)*
                                                                                  (*MaxRunningPrivileges - 1));
                    }
                    else
                    {
                        RtlCopyMemory(UpdatedPrivileges, *RunningPrivileges, sizeof (PRIVILEGE_SET));
                    }
                    MIDL_user_free(*RunningPrivileges);
                    *RunningPrivileges = UpdatedPrivileges;
                    *MaxRunningPrivileges += PRIVILEGE_SET_STEP_SIZE;
                }

                (*RunningPrivileges)->Privilege[CurrentPrivilegeCount++] = PrivilegesToAdd->Privilege[AddIndex];

                if ( Changed ) {

                    *Changed = TRUE;
                }
            }
    }

    (*RunningPrivileges)->PrivilegeCount = CurrentPrivilegeCount;

    return Status;
}



NTSTATUS
LsapRtlRemovePrivileges(
    IN OUT PPRIVILEGE_SET ExistingPrivileges,
    IN PPRIVILEGE_SET PrivilegesToRemove
    )

/*++

Routine Description:

    This function removes privileges in a privilege set.  The existing
    privilege set is unaltered, a new privilege set being generated.

    WARNING:  Privileges within each privilege set must all be distinct, that
    is, there must not be two privileges in the same set having the same LUID.

Arguments:

    ExistingPrivileges - Pointer to existing privilege set

    PrivilegesToRemove - Pointer to privilege set specifying privileges to
        be removed.  The privilege attributes are ignored.  Privileges
        in the PrivilegesToRemove set that are not present in the
        ExistingPrivileges set will be ignored.

    UpdatedPrivileges - Pointer to buffer that will receive the updated
        privilege set.  Care must be taken to ensure that UpdatedPrivileges
        occupies memory disjoint from that occupied by ExistingPrivileges
        and PrivilegesToChange.

    UpdatedPrivilegesSize - Pointer to variable that contains a size.
        On input, the size is the size of the UpdatedPrivileges buffer
        (if any).  On output, the size is the size needed/used for the
        updated privilege set.  If the updated privilege set will be
        NULL, 0 is returned.

Return Value:

    NTSTATUS - Standard Nt Result Code

        - STATUS_INVALID_PARAMETER - Invalid parameter(s)
              Mandatory parameters not specified
              UpdatedPrivileges buffer not specified (except on
              query-only calls

        - STATUS_BUFFER_OVERFLOW - This warning indicates that the buffer
              output privilege set overflowed.  Caller should test for this
              warning and if received, allocate a buffer of sufficient size
              and repeat the call.

Environment:

    User or Kernel modes.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ExistingIndex = 0;
    ULONG ExistingNew = 0;
    ULONG RemoveIndex;

    //
    // Verify that mandatory parameters have been specified.
    //

    if (ExistingPrivileges == NULL ||
        PrivilegesToRemove == NULL) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Scan through the privileges in the existing privilege set.  Look up
    // each privilege in the list of privileges to be removed.  If the
    // privilege is not found there, it is to be retained, so copy it
    // to the output buffer/count it.
    //

    for (ExistingIndex = 0, ExistingNew = 0;
        ExistingIndex < ExistingPrivileges->PrivilegeCount;
        ExistingIndex++) 
    {

        //
        // If the next privilege is not in the set to be deleted,
        // copy it to output/count it
        //

        for(RemoveIndex = 0; RemoveIndex < PrivilegesToRemove->PrivilegeCount; RemoveIndex++)
        {
            if(LsapRtlEqualPrivileges(
                &(ExistingPrivileges->Privilege[ExistingIndex]),
                &(PrivilegesToRemove->Privilege[RemoveIndex])))
            {
                break;
            }
        }
        if(RemoveIndex == PrivilegesToRemove->PrivilegeCount)
        {
            // We don't need to remove this one, so move it if necessary
            if(ExistingIndex != ExistingNew)
            {
                ExistingPrivileges->Privilege[ExistingNew] = ExistingPrivileges->Privilege[ExistingIndex];
            }
            ExistingNew++;
        }
    }

    ExistingPrivileges->PrivilegeCount = ExistingNew;
    
    return Status;
}


PLUID_AND_ATTRIBUTES
LsapRtlGetPrivilege(
    IN PLUID_AND_ATTRIBUTES Privilege,
    IN PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

WARNING: THIS ROUTINE IS NOT YET AVAILABLE

    This function locates a privilege in a privilege set.  If found,
    a pointer to the privilege wihtin the set is returned, otherwise NULL
    is returned.

Arguments:

    Privilege - Pointer to the privilege to be looked up.

    Privileges - Pointer to the privilege set to be scanned.

Return Value:

    PLUID_AND_ATTRIBUTES - If the privilege is found, a pointer to its
        LUID and ATTRIBUTES structure within the privilege set is returned,
        otherwise NULL is returned.

Environment:

    User or Kernel modes.

--*/

{
    ULONG PrivilegeIndex;

    for (PrivilegeIndex = 0;
         PrivilegeIndex < Privileges->PrivilegeCount;
         PrivilegeIndex++) {

        if (LsapRtlEqualPrivileges(
                Privilege,
                &(Privileges->Privilege[PrivilegeIndex])
                )) {

            return &(Privileges->Privilege[PrivilegeIndex]);
        }
    }

    //
    // The privilege was no found.  Return NULL
    //

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\chicago\negfunc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        kerbfunc.h
//
// Contents:    prototypes for Kerberos export functions
//
//
// History:     21-Jan-94   MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __KERBFUNC_H__
#define __KERBFUNC_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
SpInitializeFn                  NegInitialize;
SpGetInfoFn                     SpGetInfo;


LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle2;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
SpShutdownFn                    NegShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KERBFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\services.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    services.c

Abstract:

    This is the service dispatcher for the security process.  It contains
    the service dispatcher initialization routine and the routines to
    load the DLL for the individual serices and execute them.

Author:

    Rajen Shah  (rajens)    11-Apr-1991

[Environment:]

    User Mode - Win32

Revision History:

    11-Apr-1991         RajenS
        created
    27-Sep-1991 JohnRo
        More work toward UNICODE.
    24-Jan-1991 CliffV
        Converted to be service dispatcher for the security process.

--*/

#include <lsapch2.h>

#include <lmcons.h>
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmsname.h>
#include <crypt.h>
#include <logonmsv.h>
#include <ntdsa.h>
#include <netlib.h>             // SET_SERVICE_EXITCODE


#if DBG
#define IF_DEBUG()    if (TRUE)
#else
#define IF_DEBUG()    if (FALSE)
#endif


//
// Names of services run in-proc
//

#ifndef SERVICE_KDC
#define SERVICE_KDC TEXT("KDC")
#endif

#ifndef SERVICE_SAM
#define SERVICE_SAM TEXT("SAMSS")
#endif

#ifndef SERVICE_IPSECPOLICYAGENT
#define SERVICE_IPSECPOLICYAGENT TEXT("PolicyAgent")
#endif

#ifndef SERVICE_PSTORE
#define SERVICE_PSTORE TEXT("ProtectedStorage")
#endif

#ifndef SERVICE_W3SSL
#define SERVICE_W3SSL TEXT("W3SSL")
#endif


//
// Private API to tell the Service Controller
// that this is the LSA.
//

VOID
I_ScIsSecurityProcess(
    VOID
    );


//
// Internal service table structure/enum definitions
//

typedef struct _LSAP_SERVICE_TABLE
{
    LPCSTR  lpDllName;
    LPCSTR  lpEntryPoint;
    LPCWSTR lpServiceName;
}
LSAP_SERVICE_TABLE, *PLSAP_SERVICE_TABLE;


typedef enum
{
    LSAP_SERVICE_NETLOGON,
    LSAP_SERVICE_KDC,
    LSAP_SERVICE_IPSECPOLICYAGENT,
    LSAP_SERVICE_PROTECTEDSTORAGE,
    LSAP_SERVICE_W3SSL,
    LSAP_SERVICE_MAX
}
LSAP_SERVICE_TYPE, *PLSAP_SERVICE_TYPE;


//
// Keep this list in order with the service types above
//

LSAP_SERVICE_TABLE g_LsaServiceTable[LSAP_SERVICE_MAX] = {
                       { "netlogon.dll" , "NlNetlogonMain"   , SERVICE_NETLOGON         } ,
                       { "kdcsvc.dll"   , "KdcServiceMain"   , SERVICE_KDC              } ,
                       { "ipsecsvc.dll" , "SPDServiceMain"   , SERVICE_IPSECPOLICYAGENT } ,
                       { "pstorsvc.dll" , "PSTOREServiceMain", SERVICE_PSTORE           } ,
                       { "w3ssl.dll"    , "W3SSLServiceMain" , SERVICE_W3SSL            }
                   };



//
// Prototypes for the service-specific start routines themselves
//

VOID
SrvLoadNetlogon(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadKdc(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadIPSecSvcs(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadNtlmssp(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadPSTORE(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadSamss(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );

VOID
SrvLoadW3SSL(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    );


//
// The actual dispatch table for the in-proc services and their start routines
//

SERVICE_TABLE_ENTRY  SecurityServiceDispatchTable[] = {
                        { SERVICE_NETLOGON,         SrvLoadNetlogon     },
                        { SERVICE_KDC,              SrvLoadKdc          },
                        { SERVICE_NTLMSSP,          SrvLoadNtlmssp      },
                        { SERVICE_IPSECPOLICYAGENT, SrvLoadIPSecSvcs    },
                        { SERVICE_PSTORE,           SrvLoadPSTORE       },
                        { SERVICE_SAM,              SrvLoadSamss        },
                        { SERVICE_W3SSL,            SrvLoadW3SSL        },
                        { NULL,                     NULL                }
                    };



BOOLEAN
LsapWaitForSamService(
    SERVICE_STATUS_HANDLE hService,
    SERVICE_STATUS *SStatus
    );


VOID
DummyControlHandler(
    IN DWORD opcode
    )
/*++

Routine Description:

    Process and respond to a control signal from the service controller.

Arguments:

    opcode - Supplies a value which specifies the action for the Netlogon
        service to perform.

Return Value:

    None.

    NOTE : this is a dummy handler, used to uninstall the netlogon service
           when we unable to load netlogon dll.
--*/
{

    IF_DEBUG() {
        DbgPrint( "[Security Process] in control handler\n");
    }

    return;
}


VOID
LsapStartService(
    IN LSAP_SERVICE_TYPE  ServiceType,
    IN DWORD              dwNumServicesArgs,
    IN LPTSTR             *lpServiceArgVectors,
    IN BOOLEAN            fUnload
    )
{
    NET_API_STATUS          NetStatus;
    HANDLE                  DllHandle = NULL;
    LPSERVICE_MAIN_FUNCTION pfnServiceMain;

    SERVICE_STATUS_HANDLE ServiceHandle;
    SERVICE_STATUS        ServiceStatus;

    //
    // Load the service DLL
    //

    DllHandle = LoadLibraryA(g_LsaServiceTable[ServiceType].lpDllName);

    if (DllHandle == NULL)
    {
        NetStatus = GetLastError();

        IF_DEBUG()
        {
            DbgPrint("[Security process] load library %s failed %ld\n",
                     g_LsaServiceTable[ServiceType].lpDllName,
                     NetStatus);
        }

        goto Cleanup;
    }

    //
    // Find the main entry point for the service
    //

    pfnServiceMain = (LPSERVICE_MAIN_FUNCTION) GetProcAddress(DllHandle,
                                                         g_LsaServiceTable[ServiceType].lpEntryPoint);

    if (pfnServiceMain == NULL)
    {
        NetStatus = GetLastError();

        IF_DEBUG()
        {
            DbgPrint("[Security process] GetProcAddress %s failed %ld\n",
                     g_LsaServiceTable[ServiceType].lpEntryPoint,
                     NetStatus);
        }

        goto Cleanup;
    }

    //
    // Call the service entrypoint
    //

    (*pfnServiceMain)(dwNumServicesArgs, lpServiceArgVectors);

    //
    // Don't unload the library since other threads in the DLL may
    // still be running even after the ServiceMain call returns.
    //

    if(fUnload)
    {
        FreeLibrary(DllHandle);
    }

    return;

Cleanup:

    if (DllHandle != NULL)
    {
        FreeLibrary(DllHandle);
    }

    //
    // Register the service to the Service Controller
    //

    ServiceHandle = RegisterServiceCtrlHandler(g_LsaServiceTable[ServiceType].lpServiceName,
                                               DummyControlHandler);

    if (ServiceHandle != 0)
    {
        //
        // inform service controller that the service can't start.
        //

        ServiceStatus.dwServiceType      = SERVICE_WIN32;
        ServiceStatus.dwCurrentState     = SERVICE_STOPPED;
        ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
        ServiceStatus.dwCheckPoint       = 0;
        ServiceStatus.dwWaitHint         = 0;

        SET_SERVICE_EXITCODE(NetStatus,
                             ServiceStatus.dwWin32ExitCode,
                             ServiceStatus.dwServiceSpecificExitCode);

        if (!SetServiceStatus( ServiceHandle, &ServiceStatus))
        {
            IF_DEBUG()
            {
                DbgPrint("[Security process] SetServiceStatus for %ws failed %ld\n",
                         g_LsaServiceTable[ServiceType].lpServiceName,
                         GetLastError());
            }
        }
    }
    else
    {
        IF_DEBUG()
        {
            DbgPrint("[Security process] RegisterServiceCtrlHandler for %ws failed %ld\n",
                     g_LsaServiceTable[ServiceType].lpServiceName,
                     GetLastError());
        }
    }

    return;
}


VOID
SrvLoadNetlogon (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the netlogon service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_NETLOGON, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}



VOID
SrvLoadKdc (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_KDC, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


SERVICE_STATUS_HANDLE hService;
SERVICE_STATUS SStatus;

void
NtlmsspHandler(DWORD   dwControl)
{

    switch (dwControl)
    {

    case SERVICE_CONTROL_STOP:
        SStatus.dwCurrentState = SERVICE_STOPPED;
        if (!SetServiceStatus(hService, &SStatus)) {
            KdPrint(("Failed to set service status: %d\n",GetLastError()));
            hService = 0;
        }
        break;

    default:
        break;

    }

}


VOID
SrvLoadNtlmssp (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    NET_API_STATUS NetStatus;

    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_NTLMSSP, NtlmsspHandler);
    if (hService)
    {

        SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        SStatus.dwCurrentState = SERVICE_RUNNING;
        SStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
        SStatus.dwWin32ExitCode = 0;
        SStatus.dwServiceSpecificExitCode = 0;
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
        if (!SetServiceStatus(hService, &SStatus)) {
            KdPrint(("Failed to set service status: %d\n",GetLastError()));
        }
    }
    else
    {
        KdPrint(("Could not register handler, %d\n", GetLastError()));
    }
    return;
}


VOID
SrvLoadIPSecSvcs (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the IPSEC Services.  It loads
    ipsecsvc.dll (which contains the service implementation) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_IPSECPOLICYAGENT, dwNumServicesArgs, lpServiceArgVectors, TRUE);
}


VOID
SrvLoadPSTORE (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the PSTORE service.  It loads
    cryptsvc.dll (which contains the service implementation) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_PROTECTEDSTORAGE, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


VOID
SrvLoadW3SSL(
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the w3ssl service, run in-proc
    for improving SSL performance.  It loads w3ssl.dll (which contains the
    remainder of the service) and calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    LsapStartService(LSAP_SERVICE_W3SSL, dwNumServicesArgs, lpServiceArgVectors, FALSE);
}


VOID
SrvLoadSamss (
    IN DWORD dwNumServicesArgs,
    IN LPTSTR *lpServiceArgVectors
    )

/*++

Routine Description:

    This routine is the 'main' routine for the KDC service.  It loads
    Netlogon.dll (which contains the remainder of the service) and
    calls the main entry point there.

Arguments:

    dwNumServicesArgs - Number of arguments in lpServiceArgVectors.

    lpServiceArgVectors - Argument strings.

Return Value:

    return nothing.

Note:


--*/
{
    NET_API_STATUS NetStatus;
    SERVICE_STATUS_HANDLE hService;
    SERVICE_STATUS SStatus;
    HANDLE hDsStartup = NULL;
    DWORD err = 0;
    DWORD netError = ERROR_GEN_FAILURE;
    NT_PRODUCT_TYPE prod;

    //
    // Notify the service controller that we are starting.
    //

    hService = RegisterServiceCtrlHandler(SERVICE_SAM, DummyControlHandler);
    if (hService == 0 ) {
        KdPrint(("Could not register handler, %d\n", GetLastError()));
        return;
    }

    //
    // Which product are we running on?
    //

    if ( !RtlGetNtProductType( &prod ) ) {
        KdPrint(("RtlGetNtProductType failed with %d. Defaulting to Winnt\n",
                 GetLastError()));
        prod = NtProductWinNt;
    } 

    //
    // if this is a DS, also wait for the DS
    //

    if ( prod == NtProductLanManNt ) {

        if ( SampUsingDsData() ) {

            hDsStartup = CreateEvent(NULL, TRUE,  FALSE,
                            NTDS_DELAYED_STARTUP_COMPLETED_EVENT);

            if ( hDsStartup == NULL ) {
                KdPrint(("SrvLoadSamss: CreateEvent failed with %d\n",GetLastError()));
            }
        }
    }

    SStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    SStatus.dwCurrentState = SERVICE_START_PENDING;
    SStatus.dwControlsAccepted = 0;
    SStatus.dwWin32ExitCode = 0;
    SStatus.dwServiceSpecificExitCode = 0;
    SStatus.dwCheckPoint = 1;
    SStatus.dwWaitHint = 30*1000;    // 30 sec

    //
    // Wait for sam startup
    //

    if (!LsapWaitForSamService(hService, &SStatus)) {
        KdPrint(("error waiting for sam\n"));
        goto exit;
    }

    //
    // Wait for DS
    //

    if ( hDsStartup != NULL ) {

        SStatus.dwWaitHint = 64*1000;    // 64 sec
        do {
            if (!SetServiceStatus(hService, &SStatus)) {
                KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
            }

            SStatus.dwCheckPoint++;
            err = WaitForSingleObject(hDsStartup, 60 * 1000);
                            
        } while ( err == WAIT_TIMEOUT );
    } else {
        err = WAIT_OBJECT_0;
    }

exit:

    if ( err == WAIT_OBJECT_0 ) {
        SStatus.dwCurrentState = SERVICE_RUNNING;
    } else {
        KdPrint(("SAM service failed to start[Error %d].\n", netError));
        SStatus.dwCurrentState = SERVICE_STOPPED;
        SET_SERVICE_EXITCODE(
            netError,
            SStatus.dwWin32ExitCode,
            SStatus.dwServiceSpecificExitCode
            );
    }

    SStatus.dwCheckPoint = 0;
    SStatus.dwWaitHint = 0;

    if (!SetServiceStatus(hService, &SStatus)) {
        KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
    }


    if ( hDsStartup != NULL ) {
        CloseHandle(hDsStartup);
    }
    return;
} // SrvLoadSamss



DWORD
ServiceDispatcherThread (
    LPVOID Parameter
    )

/*++

Routine Description:

    This routine synchronizes with the  service controller.  It waits
    for the service controller to set the SECURITY_SERVICES_STARTED
    event then starts up the main
    thread that is going to handle the control requests from the service
    controller.

    It basically sets up the ControlDispatcher and, on return, exits from
    this main thread. The call to NetServiceStartCtrlDispatcher does
    not return until all services have terminated, and this process can
    go away.

    It will be up to the ControlDispatcher thread to start/stop/pause/continue
    any services. If a service is to be started, it will create a thread
    and then call the main routine of that service.


Arguments:

    EventHandle - Event handle to wait on before continuing.

Return Value:

    Exit status of thread.

Note:


--*/
{
    DWORD WaitStatus;
    HANDLE EventHandle;
    BOOL StartStatus;

    //
    // Create an event for us to wait on.
    //

    EventHandle = CreateEventW( NULL,   // No special security
                                TRUE,   // Must be manually reset
                                FALSE,  // The event is initially not signalled
                                SECURITY_SERVICES_STARTED );

    if ( EventHandle == NULL ) {
        WaitStatus = GetLastError();

        //
        // If the event already exists,
        //  the service controller already created it.  Just open it.
        //

        if ( WaitStatus == ERROR_ALREADY_EXISTS ) {

            EventHandle = OpenEventW( EVENT_ALL_ACCESS,
                                      FALSE,
                                      SECURITY_SERVICES_STARTED );

            if ( EventHandle == NULL ) {
                WaitStatus = GetLastError();

                IF_DEBUG() {

                    DbgPrint("[Security process] OpenEvent failed %ld\n",
                              WaitStatus );
                }

                return WaitStatus;
            }

        } else {

            IF_DEBUG() {
                DbgPrint("[Security process] CreateEvent failed %ld\n",
                            WaitStatus);
            }

            return WaitStatus;
        }
    }


    //
    // Wait for the service controller to come up.
    //

    WaitStatus = WaitForSingleObject( (HANDLE) EventHandle, (DWORD) -1 );
    (VOID) CloseHandle( EventHandle );

    if ( WaitStatus != 0 ) {

        IF_DEBUG() {

            DbgPrint("[Security process] WaitForSingleObject failed %ld\n",
                      WaitStatus );
        }

        return WaitStatus;
    }


    //
    // Let the client side of the Service Controller know that
    // is the security process
    //

    I_ScIsSecurityProcess();

    //
    // Call NetServiceStartCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    StartStatus = StartServiceCtrlDispatcher(SecurityServiceDispatchTable);

    IF_DEBUG()
    {
        DbgPrint("[Security process] return from StartCtrlDispatcher %ld \n",
                    StartStatus );
    }

    return StartStatus;

    UNREFERENCED_PARAMETER(Parameter);
}


NTSTATUS
ServiceInit (
    VOID
    )

/*++

Routine Description:

    This is a main routine for the service dispatcher of the security process.
    It starts up a thread responsible for coordinating with the
    service controller.


Arguments:

    NONE.

Return Value:

    Status of the thread creation operation.

Note:


--*/
{
    DWORD ThreadId;
    HANDLE ThreadHandle;

    //
    // The control dispatcher runs in a thread of its own.
    //

    ThreadHandle = CreateThread(
                        NULL,       // No special thread attributes
                        0,          // No special stack size
                        &ServiceDispatcherThread,
                        NULL,       // No special parameter
                        0,          // No special creation flags
                        &ThreadId);

    if ( ThreadHandle == NULL ) {
        return (NTSTATUS) GetLastError();
    } else {
        CloseHandle(ThreadHandle);
    }

    return STATUS_SUCCESS;
}


BOOLEAN
LsapWaitForSamService(
    SERVICE_STATUS_HANDLE hService,
    SERVICE_STATUS* SStatus
    )
/*++

Routine Description:

    This procedure waits for the SAM service to start and to complete
    all its initialization.

Arguments:

    NetlogonServiceCalling:
         TRUE if this is the netlogon service proper calling
         FALSE if this is the changelog worker thread calling

Return Value:

    TRUE : if the SAM service is successfully starts.

    FALSE : if the SAM service can't start.

--*/
{
    NTSTATUS Status;
    DWORD WaitStatus;
    UNICODE_STRING EventName;
    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;

    //
    // open SAM event
    //

    RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    Status = NtOpenEvent( &EventHandle,
                            SYNCHRONIZE|EVENT_MODIFY_STATE,
                            &EventAttributes );

    if ( !NT_SUCCESS(Status)) {

        if( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

            //
            // SAM hasn't created this event yet, let us create it now.
            // SAM opens this event to set it.
            //

            Status = NtCreateEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes,
                           NotificationEvent,
                           FALSE // The event is initially not signaled
                           );

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                //
                // second change, if the SAM created the event before we
                // do.
                //

                Status = NtOpenEvent( &EventHandle,
                                        SYNCHRONIZE|EVENT_MODIFY_STATE,
                                        &EventAttributes );

            }
        }

        if ( !NT_SUCCESS(Status)) {

            //
            // could not make the event handle
            //

            KdPrint(("NlWaitForSamService couldn't make the event handle : "
                "%lx\n", Status));

            return( FALSE );
        }
    }

    //
    // Loop waiting.
    //

    for (;;) {
        WaitStatus = WaitForSingleObject( EventHandle,
                                          5*1000 );  // 5 Seconds

        if ( WaitStatus == WAIT_TIMEOUT ) {

            if (!SetServiceStatus(hService, SStatus)) {
                KdPrint(("LoadSamss: Failed to set service status: %d\n",GetLastError()));
            }
    
            SStatus->dwCheckPoint++;
            continue;

        } else if ( WaitStatus == WAIT_OBJECT_0 ) {
            break;

        } else {
            KdPrint(("NlWaitForSamService: error %ld %ld\n",
                     GetLastError(),
                     WaitStatus ));
            (VOID) NtClose( EventHandle );
            return FALSE;
        }
    }

    (VOID) NtClose( EventHandle );
    return TRUE;

} // LsapWaitForSamService
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\chicago\ntcalls.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntcalls.cxx
//
// Contents:    Code for rtl support on Win95
//
//
// History:     01-April-1997   Created        ChandanS 
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#ifndef WIN32_CHICAGO
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,247 years, or around 10,682,247 days.

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/



//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


VOID
MyRtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
MyRtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}
#endif // WIN32_CHICAGO

VOID
MyRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
MyRtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}

NTSTATUS
MyRtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index = 0;
    NTSTATUS st = STATUS_SUCCESS;

    UnicodeLength = SourceString->MaximumLength * sizeof(WCHAR);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (PWSTR) LocalAlloc(0, UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = MultiByteToWideChar(
             CP_ACP,
             MB_PRECOMPOSED,
             SourceString->Buffer,
             SourceString->Length,
             DestinationString->Buffer,
             DestinationString->MaximumLength
             );

        if (Index == 0) {
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }

            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = UNICODE_NULL;

    return st;
}

BOOLEAN
MyRtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSTR SourceString
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if (!ARGUMENT_PRESENT(SourceString))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        return (TRUE);
    }

    MyRtlInitAnsiString( &AnsiString, SourceString );
    Status = MyRtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


NTSTATUS
MyRtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;


    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Upcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
        LPTSTR TempString;
        CHAR TempChar  = (CHAR)(SourceString->Buffer[Index]);
        TempString  = CharUpper(&TempChar);
        DestinationString->Buffer[Index] = (WCHAR)(*TempString);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Downcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
        LPTSTR TempString;
        CHAR TempChar  = (CHAR)(SourceString->Buffer[Index]);
        TempString  = CharLower(&TempChar);
        DestinationString->Buffer[Index] = (WCHAR)(*TempString);
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


VOID
MyRtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    if (AnsiString->Buffer) {
        LocalFree(AnsiString->Buffer);
#if 0 
        memset( AnsiString, 0, sizeof( *AnsiString ) );
#endif
        ZeroMemory( AnsiString, sizeof( *AnsiString ) );
        }
}

BOOLEAN
MyRtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2;
    ULONG n1, n2, Count;
    CHAR c1, c2;
    PCHAR uc1, uc2;

    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

#if 0
        DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

        Limit = (PWCHAR)((PCHAR)s1 + n1);
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;
                
// WIN32_CHICAGO Do something better than AnsiUpper
                uc1= AnsiUpper (&c1);
                uc2 = AnsiUpper (&c2);
                if ((c1 != c2) && ((*uc1) != *(uc2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }
#else // 0
        if (CaseInSensitive) 
        {
            Count = 0;
            // Can't use wcsnicmp

            while (Count < (n1/sizeof(WCHAR)))
            {
                c1 = (CHAR) *(s1 + Count);
                c2 = (CHAR) *(s2 + Count);
                uc1= AnsiUpper (&c1);
                uc2 = AnsiUpper (&c2);
                if (*uc1 != *uc2) {
                    return FALSE;
                }
                Count++;
            }
            return TRUE;
        }
        else 
        {
            if (wcsncmp (s1, s2, (n1/sizeof(WCHAR))) == 0)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
#endif // 0

    } else {
        return FALSE;
    }
}

NTSTATUS
MyRtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index = 0;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOL fUsed;

    AnsiLength = (SourceString->Length / sizeof(WCHAR)) + 1;
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = WideCharToMultiByte(
             CP_ACP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL, 
             &fUsed
             );

        if (Index == 0)
        { // WIN32_CHICAGO do something useful here
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }
            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function upper cases the specified unicode source string and then
    converts it into an oem string. The translation is done with respect
    to the OEM code page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    // NOTE: This routine is not DBCS safe yet!
    ULONG OemLength;
    ULONG Index;
    BOOL fUsed;
    NTSTATUS st = STATUS_SUCCESS;

    // Do not rely on callers to set MaximumLength as Length + 2
    OemLength = (SourceString->Length  / sizeof(WCHAR)) + 1;
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = WideCharToMultiByte(
             CP_OEMCP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL, 
             &fUsed
             );
    if (Index == 0)
    { // WIN32_CHICAGO do something useful here
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
        return STATUS_NO_MEMORY;
    }
/*
    st = RtlUnicodeToMultiByteN(
                    DestinationString->Buffer,
                    DestinationString->Length,
                    &Index,
                    SourceString->Buffer,
                    SourceString->Length
                    );
    if (!NT_SUCCESS(st))
    {
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
    }
*/

    DestinationString->Buffer[Index] = '\0';

    return st;
}


BOOLEAN
MyRtlEqualString(
    IN POEM_STRING String1,
    IN POEM_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;
    PUCHAR uc1, uc2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = (PUCHAR)String1->Buffer;
        s2 = (PUCHAR)String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
 // WIN32_CHICAGO Use something better to upcase here
                    uc1 = (PUCHAR)AnsiUpper((PCHAR)&c1);
                    uc2 = (PUCHAR)AnsiUpper((PCHAR)&c2);
                    if (*uc1 != *uc2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

VOID
MyRtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    if (OemString->Buffer) {
        LocalFree(OemString->Buffer);
        memset( OemString, 0, sizeof( *OemString ) );
        }
}


BOOLEAN
MyRtlEqualDomainName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualDomainName function compares two domain names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReturnValue = FALSE;
    OEM_STRING OemString1;
    OEM_STRING OemString2;

    //
    // Upper case and convert the first string to OEM
    //

    Status = MyRtlUpcaseUnicodeStringToOemString( &OemString1,
                                                String1,
                                                TRUE );   // Allocate Dest

    if ( NT_SUCCESS( Status ) ) {

        //
        // Upper case and convert the second string to OEM
        //

        Status = MyRtlUpcaseUnicodeStringToOemString( &OemString2,
                                                    String2,
                                                    TRUE );   // Allocate Dest

        if ( NT_SUCCESS( Status ) ) {

            //
            // Do a case insensitive comparison.
            //

            ReturnValue = MyRtlEqualString( &OemString1,
                                          &OemString2,
                                          FALSE );

            MyRtlFreeOemString( &OemString2 );
        }

        MyRtlFreeOemString( &OemString1 );
    }

    return ReturnValue;
}


VOID
MyRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
}

LONG
MyRtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;
    PCHAR puc1, puc2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);
    DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {

                //
                // Note that this needs to reference the translation table!
                //

// WIN32_CHICAGO Need to do something better here
                puc1 = AnsiUpper((PCHAR)&c1);
                puc2 = AnsiUpper((PCHAR)&c2);
                if (*puc1 != *puc2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


VOID
MyRtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{

    if (UnicodeString->Buffer) {
        LocalFree(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


//
// Inline functions to convert between FILETIME and TimeStamp
//
#pragma warning( disable : 4035)    // Don't complain about no return

TimeStamp __inline
FileTimeToTimeStamp(
    const FILETIME *pft)
{
    _asm {
        mov edx, pft
        mov eax, [edx].dwLowDateTime
        mov edx, [edx].dwHighDateTime
    }
}

#pragma warning( default : 4035)    // Reenable warning

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    )
/*++

Routine Description:

    This routine returns the current system time (UTC), as a timestamp
    (a 64-bit unsigned integer, in 100-nanosecond increments).

Arguments:

    None.

Return Value:

    The current system time.

--*/

{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    *SystemTimeStamp = FileTimeToTimeStamp(&FileTime);

    return STATUS_SUCCESS; // WIN32_CHICAGO do something useful here
}


NTSTATUS
MyNtAllocateLocallyUniqueId(
    OUT PLUID Luid
    )
{
    // WIN32_CHICAGO do something useful here
    Luid->HighPart = 1;
    Luid->LowPart = 1;
    return STATUS_SUCCESS;
}

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    )
{
    // We don't care about these. Just fake it so that the common code does
    // look too unreadable.

    MyNtAllocateLocallyUniqueId (&ClientInfo->LogonId);
    ClientInfo->HasTcbPrivilege = TRUE;
    return STATUS_SUCCESS;
}

PVOID
AllocateLsaHeap(
    IN ULONG Length
    )
{
    return LocalAlloc(0, Length);
}

VOID
FreeLsaHeap(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    )
{
    RtlCopyMemory(
        BufferToCopy,
        ClientBaseAddress,
        Length
        );
    return STATUS_SUCCESS;
}

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )
{
    *ClientBaseAddress = (PVOID)AllocateLsaHeap(LengthRequired);
    if (ClientBaseAddress == NULL)
    {
        return STATUS_NO_MEMORY;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )
{
    RtlCopyMemory(
        ClientBaseAddress,
        BufferToCopy,
        Length
        );

    return STATUS_SUCCESS;
}

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    )
{
    FreeLsaHeap(ClientBaseAddress);

    return STATUS_SUCCESS;
}

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    )
{
    // WIN32_CHICAGO do something useful here
}

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

VOID
FreeReturnBuffer(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    LocalFree(pvContextBuffer);
    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\chicago\debug.h ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    NtLmSsp service debug support

Author:

    Ported from Lan Man 2.0

Revision History:

    21-May-1991 (cliffv)
        Ported to NT.  Converted to NT style.
    09-Apr-1992 JohnRo
        Prepare for WCHAR.H (_wcsicmp vs _wcscmpi, etc).

--*/

//
// kerbstub.cxx will #include this file with DEBUG_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef DEBUG_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif


////////////////////////////////////////////////////////////////////////
//
// Debug Definititions
//
////////////////////////////////////////////////////////////////////////

// bits from kerberos (from kerbdbg.h)

#define DEB_ERROR             0x0001
#define DEB_WARN              0x0002
#define DEB_TRACE             0x0004
#define DEB_TRACE_API         0x0008
#define DEB_TRACE_NEG         0x00001000
#define DEB_TRACE_NEG_LOCKS   0x00040000

// bits from kerberos (from security\dsysdbg.h)
#define DSYSDBG_CLEAN         0x40000000

//
// Name and directory of log file
//

#define DEBUG_DIR           L"\\debug"
#define DEBUG_FILE          L"\\ntlmssp.log"
#define DEBUG_BAK_FILE      L"\\ntlmssp.bak"

#if DBG

#define DebugLog(_x_) NegPrintRoutine _x_

VOID __cdecl
NegPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FORMATSTRING,     // PRINTF()-STYLE FORMAT STRING.
    ...                         // OTHER ARGUMENTS ARE POSSIBLE.
    );

#else

#define IF_DEBUG(Function) if (FALSE)

// Nondebug version.
#define DebugLog(_x_)

#endif // DBG

#undef EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dsdll\makefile.inc ===
..\credmgr.cxx: ..\..\netclient\credapi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\chicago\negstub.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    negstub.hxx

Abstract:

    Header file describing the interface to code common to the
    NT Lanman Security Support Provider (NtLmSsp) Service and the DLL.

Author:

    Cliff Van Dyke (CliffV) 17-Sep-1993

Revision History:

--*/

#ifndef _NEGSTUB_INCLUDED_
#define _NEGSTUB_INCLUDED_

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef NEGSTUB_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN CRITICAL_SECTION NegDllCritSect;    // Serializes access to all globals in module

#if DBG

//
// To serialize access to log file.
//

EXTERN CRITICAL_SECTION NegGlobalLogFileCritSect;

//
// Control which messages get displayed
//

EXTERN DWORD NegInfoLevel;
#endif // DBG

EXTERN SecurityFunctionTable NegDllSecurityFunctionTable;
EXTERN LSA_SECPKG_FUNCTION_TABLE FunctionTable;

////////////////////////////////////////////////////////////////////////
//
// Procedure Forwards
//
////////////////////////////////////////////////////////////////////////

//
// Procedure forwards from negstub.cxx
//

SECURITY_STATUS
NegEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    );

SECURITY_STATUS
NegQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo * Package
    );

SECURITY_STATUS SEC_ENTRY
NegFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    );

SECURITY_STATUS
SpAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    );

SECURITY_STATUS
SpFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    );

SECURITY_STATUS
SpQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS
SpSspiLogonUser(
    IN LPTSTR PackageName,
    IN LPTSTR UserName,
    IN LPTSTR DomainName,
    IN LPTSTR Password
    );

SECURITY_STATUS
SpInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

SECURITY_STATUS
SpAcceptSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN PSecBufferDesc InputToken,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    );

SECURITY_STATUS
SpDeleteSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
SpApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    );


SECURITY_STATUS
SpImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
SpRevertSecurityContext (
    PCtxtHandle ContextHandle
    );

SECURITY_STATUS
SpQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS
NegQueryContextAttributes(
    IN ULONG ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    );

SECURITY_STATUS SEC_ENTRY
SpCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    );

SECURITY_STATUS SEC_ENTRY
NegCompleteAuthToken (
    ULONG ContextHandle,
    PSecBufferDesc BufferDescriptor
    );

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    );

// fake it.
//typedef ULONG LSA_CLIENT_REQUEST;
//typedef LSA_CLIENT_REQUEST *LSA_CLIENT_REQUEST;

NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    );

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    );

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    );

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    );

PVOID
AllocateLsaHeap(
    IN ULONG Length
    );

VOID
FreeLsaHeap(
    IN PVOID Base
    );

VOID
FreeReturnBuffer(
    IN PVOID Base
    );

NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    );

#endif // ifndef _KERBSTUB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\cfiles\sidcache.c ===
//+-----------------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        sidcache.c
//
// Contents:    code for cache for sid/name translation, lookup
//
//
// History:     17-May-1994     MikeSw      Created
//
//------------------------------------------------------------------------------

#include <lsapch2.h>
#include <sidcache.h>

#include <ntdsapi.h>

//
// Global data
//

//
// This is the head of the linked list that implements the sid cache
//
PLSAP_DB_SID_CACHE_ENTRY LsapSidCache = NULL;

//
// This lock gaurds access to the linked list
//
RTL_CRITICAL_SECTION LsapSidCacheLock;

//
// This is the number of elements current in LsapSidCache.
//
ULONG LsapSidCacheCount = 0;


//
// The amount of time an entry can be used before it needs to be refreshed.
//

// This is interpreted as minutes in the registry
#define LSAP_LOOKUP_CACHE_REFRESH_NAME  L"LsaLookupCacheRefreshTime"

// 10 minutes
#define LSAP_DEFAULT_REFRESH_TIME 10

LARGE_INTEGER LsapSidCacheRefreshTime;

//
// The amount of time an entry can be used before it is no longer valid.
//

// This is interpreted as minutes in the registry
#define LSAP_LOOKUP_CACHE_EXPIRY_NAME   L"LsaLookupCacheExpireTime"

// 7 days
#define LSAP_DEFAULT_EXPIRY_TIME (7 * 24 * 60)

LARGE_INTEGER LsapSidCacheExpiryTime;

//
// The maximum size of the cache.
//

#define LSAP_LOOKUP_CACHE_MAX_SIZE_NAME   L"LsaLookupCacheMaxSize"

#define LSAP_DEFAULT_MAX_CACHE_SIZE  128

ULONG LsapSidCacheMaxSize = LSAP_DEFAULT_MAX_CACHE_SIZE;


//
// Forward function declarations
//
PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntry(
    IN PSID Sid,
    IN BOOLEAN UseOldEntries
    );

BOOLEAN
LsapAccountIsFromLocalDatabase(
    IN PSID Sid
    );

VOID
LsapUpdateConfigSettings(
    VOID
    );

#define LockSidCache()     RtlEnterCriticalSection(&LsapSidCacheLock);

#define UnLockSidCache()   RtlLeaveCriticalSection(&LsapSidCacheLock);

#define SidUnmapped(TranslatedName) (((TranslatedName).Use == SidTypeUnknown))

#define NameUnmapped(TranslatedSid) (((TranslatedSid).Use == SidTypeUnknown))


#define LsapNamesMatch(x, y)                                        \
  ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,                  \
                                DS_DEFAULT_LOCALE_COMPARE_FLAGS,    \
                                (x)->Buffer,                        \
                                (x)->Length/sizeof(WCHAR),          \
                                (y)->Buffer,                        \
                                (y)->Length/sizeof(WCHAR) )))

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFreeCacheEntry
//
//  Synopsis:   Frees a cache entry structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDbFreeCacheEntry(PLSAP_DB_SID_CACHE_ENTRY CacheEntry)
{
    if (CacheEntry->Sid != NULL)
    {
        LsapFreeLsaHeap(CacheEntry->Sid);
    }
    if (CacheEntry->DomainSid != NULL)
    {
        LsapFreeLsaHeap(CacheEntry->DomainSid);
    }
    if (CacheEntry->DomainName.Buffer != NULL)
    {
        MIDL_user_free(CacheEntry->DomainName.Buffer);
    }
    if (CacheEntry->AccountName.Buffer != NULL)
    {
        MIDL_user_free(CacheEntry->AccountName.Buffer);
    }
    LsapFreeLsaHeap(CacheEntry);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsapDbPurgeOneSid
//
//  Synopsis:   removes the least-recently accessed sid from the cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    sid cache be locked
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOL
LsapDbPurgeOneSid()
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY PrevEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY OldestEntry = NULL;
    PLSAP_DB_SID_CACHE_ENTRY OldestPrevEntry = NULL;
    LARGE_INTEGER OldestTime;
    LARGE_INTEGER CurrentTime ;
    BOOL Retried = FALSE;

    //
    // Set the max time to the oldest time so if there are any entries
    // is is guaranteed to change.
    //

    OldestTime.QuadPart = 0x7fffffffffffffff;
    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

RetryScan:
    for (CacheEntry = LsapSidCache, PrevEntry = NULL;
         CacheEntry != NULL;
         CacheEntry = CacheEntry->Next )
    {
        if ( CacheEntry->InUseCount == 0 &&
             ( CacheEntry->LastUse.QuadPart < OldestTime.QuadPart) &&
             ( CacheEntry->ExpirationTime.QuadPart < CurrentTime.QuadPart ) )
        {
            OldestTime = CacheEntry->LastUse;
            OldestEntry = CacheEntry;
            OldestPrevEntry = PrevEntry;
        }
        PrevEntry = CacheEntry;
    }

    if ( !Retried && !OldestEntry )
    {
        CurrentTime.QuadPart = 0x7FFFFFFFFFFFFFFF;
        Retried = TRUE;
        goto RetryScan ;
    }

    if (OldestEntry != NULL)
    {
        if (OldestPrevEntry != NULL)
        {
            OldestPrevEntry->Next = OldestEntry->Next;
        }
        else
        {
            ASSERT(LsapSidCache == OldestEntry);
            LsapSidCache = OldestEntry->Next;
        }
        LsapDbFreeCacheEntry(OldestEntry);
        LsapSidCacheCount--;
    }

    return (OldestEntry != NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbAddOneSidToCache
//
//  Synopsis:   Adds one sid to cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    sid cache be locked
//
//  Notes:
//
//
//--------------------------------------------------------------------------

//
// This operation flag means that the name is known not to exist
// in the cache.  That is, the list has already been scanned
//
#define LSAP_SID_CACHE_UNIQUE 0x00000001

NTSTATUS
LsapDbAddOneSidToCache(
    IN PSID Sid,
    IN PUNICODE_STRING Name,
    IN SID_NAME_USE Use,
    IN PLSAPR_TRUST_INFORMATION Domain,
    IN ULONG Flags,
    IN ULONG OperationalFlags,
    OUT PLSAP_DB_SID_CACHE_ENTRY * CacheEntry OPTIONAL
    )
{
    PLSAP_DB_SID_CACHE_ENTRY NewEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL Continue = TRUE;

    if ((OperationalFlags & LSAP_SID_CACHE_UNIQUE) == 0) {

        NewEntry = LsapDbFindSidCacheEntry(Sid, TRUE);
    
        if (NewEntry)
        {
            LARGE_INTEGER NewTime;
    
            GetSystemTimeAsFileTime( (LPFILETIME) &NewTime );
            NewEntry->LastUse = NewTime;
            NewEntry->RefreshTime.QuadPart = NewTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
    
            if (CacheEntry)
            {
                *CacheEntry = NewEntry;
            }
    
            return STATUS_SUCCESS;
        }
    }

    //
    // Make sure we haven't exceeded the maximum cache size.  Since the
    // max cache size may have changed recently, don't just check the
    // boundary.
    //

    if (LsapSidCacheMaxSize == 0)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    while (LsapSidCacheCount >= LsapSidCacheMaxSize && Continue)
    {
        Continue = LsapDbPurgeOneSid();
    }

    //
    // A large number of cache entries are currently in use and we can't
    // remove any to make space, so return a failure instead.  This shouldn't
    // happen very often since all the SIDs must be logon SIDs.
    //
    if (LsapSidCacheCount >= LsapSidCacheMaxSize)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Build the new cache entry
    //

    NewEntry = (PLSAP_DB_SID_CACHE_ENTRY) LsapAllocateLsaHeap(sizeof(LSAP_DB_SID_CACHE_ENTRY));
    if (NewEntry == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlZeroMemory(NewEntry,sizeof(PLSAP_DB_SID_CACHE_ENTRY));

    Status = LsapDuplicateSid(
                &NewEntry->Sid,
                Sid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status= LsapDuplicateSid(
                &NewEntry->DomainSid,
                Domain->Sid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                &NewEntry->AccountName,
                Name
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsapRpcCopyUnicodeString(
                NULL,
                &NewEntry->DomainName,
                (PUNICODE_STRING) &Domain->Name
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    NewEntry->SidType = Use;
    GetSystemTimeAsFileTime( (LPFILETIME) &NewEntry->CreateTime );
    NewEntry->LastUse = NewEntry->CreateTime;
    NewEntry->ExpirationTime.QuadPart = NewEntry->CreateTime.QuadPart + LsapSidCacheExpiryTime.QuadPart ;
    NewEntry->RefreshTime.QuadPart = NewEntry->CreateTime.QuadPart + LsapSidCacheRefreshTime.QuadPart ;
    NewEntry->Next = LsapSidCache;
    NewEntry->InUseCount = 0;
    NewEntry->Flags = (Flags & LSA_LOOKUP_NAME_NOT_SAM_ACCOUNT_NAME) ? LSAP_SID_CACHE_UPN : LSAP_SID_CACHE_SAM_ACCOUNT_NAME;
    LsapSidCache = NewEntry;
    LsapSidCacheCount++;

    if ( CacheEntry )
    {
        *CacheEntry = NewEntry ;
    }

Cleanup:

    if (!NT_SUCCESS(Status) && (NewEntry != NULL))
    {
        LsapDbFreeCacheEntry(NewEntry);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDbAddSidsToCache
//
//  Synopsis:   Adds a new sid entries to the cache and saves the cache
//
//  Effects:    Grabs a the SidCacheLock resource for write access
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsapDbAddLogonNameToCache(
    PUNICODE_STRING AccountName,
    PUNICODE_STRING DomainName,
    PSID AccountSid
    )
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry ;
    NTSTATUS Status ;
    LSAPR_TRUST_INFORMATION Trust ;
    PSID Sid ;
    UCHAR SubAuthorityCount ;

    Trust.Name.Buffer = DomainName->Buffer ;
    Trust.Name.Length = DomainName->Length ;
    Trust.Name.MaximumLength = DomainName->MaximumLength ;

    if (LsapSidCacheMaxSize == 0) {
        //
        // If the maximum cache size is zero, there is nothing to do
        // here
        //
        return;
    }

    if ( RtlEqualSid( AccountSid, LsapLocalSystemSid ) 
      || RtlEqualSid( AccountSid, LsapAnonymousSid )  ) {
        //
        // Someone logon'ed on as local system (ie used the machine
        // account).  Don't cache this value as it confuse lookups
        // on the machine account, which should return the real
        // sid of the machine account, not local system
        //
        // Also, don't cache the anonymous sid, either
        //
        return;
    }

    if ( LsapAccountIsFromLocalDatabase( AccountSid ) ) {

        //
        // The account is from the local database which means
        // we always lookup regardless of network conditions
        //
        return;
    }

    Sid = LsapAllocatePrivateHeap( RtlLengthSid( AccountSid ) );

    if ( !Sid )
    {
        return;
    }

    RtlCopyMemory( Sid, AccountSid, RtlLengthSid( AccountSid ) );

    Trust.Sid = Sid ;

    SubAuthorityCount = *RtlSubAuthorityCountSid( Sid );
    if ( SubAuthorityCount > 1 )
    {
        SubAuthorityCount-- ;
        *RtlSubAuthorityCountSid( Sid ) = SubAuthorityCount ;
    }

    LockSidCache();

    Status = LsapDbAddOneSidToCache(
                AccountSid,
                AccountName,
                SidTypeUser,
                &Trust,
                0, // no flags
                0, // no operation flags
                &CacheEntry );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Logon sessions increment the reference count so that
        // the cache entry does not expire.
        //
        CacheEntry->InUseCount++;
    }

    UnLockSidCache();

    LsapFreePrivateHeap( Sid );

}

VOID
LsapDbReleaseLogonNameFromCache(
    PSID Sid
    )
{
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry ;

    LockSidCache();

    CacheEntry = LsapDbFindSidCacheEntry(
                        Sid,
                        TRUE );

    if ( CacheEntry )
    {
        if (CacheEntry->InUseCount > 0)
        {
            CacheEntry->InUseCount--;
        }

        if (CacheEntry->InUseCount == 0)
        {
            LARGE_INTEGER CurrentTime;

            GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
            CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart ;
            CacheEntry->ExpirationTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheExpiryTime.QuadPart ;
        }
    }

    UnLockSidCache();

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFindSidCacheEntry
//
//  Synopsis:   Checks the cache for a specific SID
//
//  Effects:
//
//  Arguments:
//
//  Requires:   the SidCacheLock resource must be locked for read access
//
//  Returns:    the entry found, or NULL if nothing was found
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntry(
    PSID Sid,
    BOOLEAN UseOldEntries
    )
{
    ULONG CacheIndex;
    LARGE_INTEGER LimitTime;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
    for (CacheEntry = LsapSidCache; CacheEntry != NULL; CacheEntry = CacheEntry->Next )
    {
        if (RtlEqualSid(
                CacheEntry->Sid,
                Sid
                )
          && ((CacheEntry->Flags & LSAP_SID_CACHE_SAM_ACCOUNT_NAME) == LSAP_SID_CACHE_SAM_ACCOUNT_NAME)  )
        {
            DebugLog((DEB_TRACE_LSA,"Found cache entry %wZ\n",
                        &CacheEntry->AccountName));

            //
            // If we are not using OldEntries, then we are subject to the
            // refresh time
            //
            if (!UseOldEntries) {
                LimitTime.QuadPart = CacheEntry->RefreshTime.QuadPart;
            } else {
                LimitTime.QuadPart = CacheEntry->ExpirationTime.QuadPart;
            }

            if ( (CacheEntry->InUseCount == 0)
              &&  LimitTime.QuadPart < CurrentTime.QuadPart ) {

                //
                // can't use this entry
                //
                break;
            }

            CacheEntry->LastUse = CurrentTime;
            return(CacheEntry);
        }
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFindSidCacheEntryByName
//
//  Synopsis:   Checks the cache for a specific name
//
//  Effects:
//
//  Arguments:
//
//  Requires:   the SidCacheLock resource must be locked for read access
//
//  Returns:    the entry found, or NULL if nothing was found
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PLSAP_DB_SID_CACHE_ENTRY
LsapDbFindSidCacheEntryByName(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    BOOLEAN UseOldEntries
    )
{
    ULONG CacheIndex;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER LimitTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );
    for (CacheEntry = LsapSidCache; CacheEntry != NULL; CacheEntry = CacheEntry->Next )
    {
        if (RtlEqualUnicodeString(
                &CacheEntry->AccountName,
                AccountName,
                TRUE                    // case insensitive
                ) &&
            ((DomainName->Length == 0) ||
             RtlEqualUnicodeString(
                &CacheEntry->DomainName,
                DomainName,
                TRUE                    // case insensitive
                )))
        {
            DebugLog((DEB_TRACE_LSA,"Found cache entry %wZ\n",
                        &CacheEntry->AccountName));

            //
            // If we are not using OldEntries, then we are subject to the
            // refresh time
            //
            if (!UseOldEntries) {
                LimitTime.QuadPart = CacheEntry->RefreshTime.QuadPart;
            } else {
                LimitTime.QuadPart = CacheEntry->ExpirationTime.QuadPart;
            }

            if ( (CacheEntry->InUseCount == 0)
              &&  LimitTime.QuadPart < CurrentTime.QuadPart ) {

                //
                // can't use this entry
                //
                break;
            }

            CacheEntry->LastUse = CurrentTime;
            return(CacheEntry);
        }
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbMapCachedSids
//
//  Synopsis:   Checks the SPMgr's cache of sid-name pairs for the sid
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapDbMapCachedSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_NAMES_EX TranslatedNames,
    OUT PULONG MappedCount
    )
{
    ULONG SidIndex;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInformation;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    PLSA_TRANSLATED_NAME_EX OutputNames = NULL;

    OutputNames = (PLSA_TRANSLATED_NAME_EX) TranslatedNames->Names;

    LockSidCache();

    for (SidIndex = 0; SidIndex < Count ; SidIndex++)
    {

        if (TranslatedNames->Names[SidIndex].Use != SidTypeUnknown) {

            continue;

        }

        //
        // lookup the sid in the cache
        //

        CacheEntry = LsapDbFindSidCacheEntry(Sids[SidIndex], UseOldEntries);
        if (CacheEntry == NULL)
        {
            //
            // Sid wasn't found - continue
            //

            continue;
        }

        TrustInformation.Name = *(PLSAPR_UNICODE_STRING) &CacheEntry->DomainName;
        TrustInformation.Sid = (PLSAPR_SID) CacheEntry->DomainSid;

        //
        // At least one Sid has the domain Sid as prefix (or is the
        // domain SID).  Add the domain to the list of Referenced
        // Domains and obtain a Domain Index back.
        //

        Status = LsapDbLookupAddListReferencedDomains(
                     ReferencedDomains,
                     &TrustInformation,
                     &DomainIndex
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        OutputNames[SidIndex].Use = CacheEntry->SidType;
        OutputNames[SidIndex].DomainIndex = DomainIndex;

        Status = LsapRpcCopyUnicodeString(
                    NULL,
                    &OutputNames[SidIndex].Name,
                    &CacheEntry->AccountName
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        (*MappedCount)++;
    }

Cleanup:

    UnLockSidCache();

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapDbMapCachedNames
//
//  Synopsis:   Checks the LSA's cache of sid-name pairs for the name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
LsapDbMapCachedNames(
    IN ULONG           LookupOptions,
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN BOOLEAN UseOldEntries,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT PULONG MappedCount
    )
{
    ULONG SidIndex;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL;
    LSAPR_TRUST_INFORMATION TrustInformation;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG DomainIndex;
    PLSA_TRANSLATED_SID_EX2 OutputSids = NULL;

    OutputSids = (PLSA_TRANSLATED_SID_EX2) TranslatedSids->Sids;

    LockSidCache();
    for (SidIndex = 0; SidIndex < Count ; SidIndex++)
    {
        //
        // lookup the Sids in the cache
        //
        if (TranslatedSids->Sids[SidIndex].Use != SidTypeUnknown) {

            continue;

        }

        if ( (LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL)
         &&  (DomainNames[SidIndex].Length == 0) ) {

            //
            // If the name is isolated don't map to a name that
            // was found off machine
            //
            continue;
        }

        CacheEntry = LsapDbFindSidCacheEntryByName(
                        &AccountNames[SidIndex],
                        &DomainNames[SidIndex],
                        UseOldEntries
                        );

        if (CacheEntry == NULL)
        {
            //
            // Name wasn't found - continue
            //

            continue;
        }

        TrustInformation.Name = *(PLSAPR_UNICODE_STRING) &CacheEntry->DomainName;
        TrustInformation.Sid = (PLSAPR_SID) CacheEntry->DomainSid;

        //
        // At least one Sid has the domain Sid as prefix (or is the
        // domain SID).  Add the domain to the list of Referenced
        // Domains and obtain a Domain Index back.
        //

        Status = LsapDbLookupAddListReferencedDomains(
                     ReferencedDomains,
                     &TrustInformation,
                     &DomainIndex
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        OutputSids[SidIndex].Use = CacheEntry->SidType;
        OutputSids[SidIndex].DomainIndex = DomainIndex;

        Status = LsapRpcCopySid(NULL,
                                &OutputSids[SidIndex].Sid,
                                CacheEntry->Sid);
        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

//        LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: Cache hit for %wZ\%wZ\n", &DomainNames[SidIndex], &AccountNames[SidIndex] ));

        (*MappedCount)++;
    }

Cleanup:


    UnLockSidCache();

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbFreeSidCache
//
//  Synopsis:   frees the entire sid cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
LsapDbFreeSidCache()
//
// SidCache is the global sid cache
//
{
    LockSidCache();

    while ( LsapSidCache != NULL )
    {
        PLSAP_DB_SID_CACHE_ENTRY Temp = LsapSidCache;

        Temp = LsapSidCache->Next;

        LsapDbFreeCacheEntry( LsapSidCache );

        LsapSidCache = Temp;
    }

    LsapSidCacheCount = 0;

    UnLockSidCache();

}

//+-------------------------------------------------------------------------
//
//  Function:   LsapDbInitSidCache
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDbInitSidCache(
    VOID
    )
{
    NTSTATUS Status = RtlInitializeCriticalSection(&LsapSidCacheLock);

    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // Sets the global parameters
    //
    LsapSidCacheReadParameters(NULL);

    //
    // Move old settings to new location -- note this will
    // cause the global parameters to be re-read if there
    // are any changes.
    //
    LsapUpdateConfigSettings();

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   LsapAccountIsFromLocalDatabase
//
//  Synopsis:   Returns TRUE if the passed in SID is from the local account
//              database; FALSE otherwise
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
LsapAccountIsFromLocalDatabase(
    IN PSID Sid
    )
{
    BOOLEAN fLocal = FALSE;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo;
    NTSTATUS Status;
    UCHAR SubAuthorityCount;
    BOOLEAN fRevert = FALSE;

    Status = LsapDbLookupGetDomainInfo(&AccountDomainInfo,
                                       NULL);
    if ( NT_SUCCESS( Status ) ) {
        SubAuthorityCount = *RtlSubAuthorityCountSid( Sid );
        if ( SubAuthorityCount > 1 )
        {
            SubAuthorityCount-- ;
            *RtlSubAuthorityCountSid( Sid ) = SubAuthorityCount ;
            fRevert = TRUE;
        }
    
        if ( RtlEqualSid( Sid, AccountDomainInfo->DomainSid ) ) {
            fLocal = TRUE;
        }
    }

    if ( fRevert ) {
        *RtlSubAuthorityCountSid( Sid ) += 1;
    }

    return fLocal;

}


VOID
LsapUpdateConfigSettings(
    VOID
    )

/*++

Routine Description:

    This routine moves the configuration data from the old location
    (under HKLM\Security\SidCache) to the new location.  Note, 
    the act of writing the value to the new location will trigger
    LsapSidCacheReadParameters to run.
            
Arguments:

    None.
        
Return Values:

    None.

--*/
{

#define SID_CACHE_STORAGE_ROOT  L"Security\\SidCache"
#define SID_CACHE_MAX_ENTRIES_NAME L"MaxEntries"

    DWORD err;        
    HKEY PrevKey = NULL;
    HKEY Key = NULL;
    ULONG Size = sizeof(ULONG);
    ULONG MaxEntries;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     SID_CACHE_STORAGE_ROOT,
                     &PrevKey);

    if (ERROR_SUCCESS == err) {

        err = RegQueryValueEx(PrevKey,
                              SID_CACHE_MAX_ENTRIES_NAME,
                              NULL,
                              NULL,
                              (PUCHAR) &MaxEntries,
                              &Size);

        if (ERROR_SUCCESS == err) {

            //
            // A value existed -- move it over to the new location
            //
            err = RegOpenKey(HKEY_LOCAL_MACHINE,
                             L"SYSTEM\\CurrentControlSet\\Control\\LSA",
                             &Key);

            if (ERROR_SUCCESS == err) {

                err = RegSetValueEx(Key,
                                    LSAP_LOOKUP_CACHE_MAX_SIZE_NAME,
                                    0,
                                    REG_DWORD,
                                    (CONST BYTE*)&MaxEntries,
                                     sizeof(MaxEntries));

                if (ERROR_SUCCESS == err) {
                    
                    //
                    // And delete the old one
                    //
                    (VOID) RegDeleteValue(PrevKey,
                                          SID_CACHE_MAX_ENTRIES_NAME);

                }
            }

        }
    }

    if (PrevKey) {
        RegCloseKey(PrevKey);
    }

    if (Key) {
        RegCloseKey(Key);
    }
}

VOID
LsapSidCacheReadParameters(
    IN HKEY hKey OPTIONAL
    )
/*++

Routine Description:

    This routine reads in the configurable parameters of the SID cache
    from the registry and updates the corresponding global parameters.
    
    N.B. This routine is called when ever a change occurs under
    SYSTEM\CCS\Control\LSA
    
Arguments:

    hKey -- a handle to SYSTEM\CCS\Control\LSA
    
Return Values:

    None.

--*/
{
    DWORD err;
    NT_PRODUCT_TYPE ProductType;
    DWORD dwType;
    DWORD dwValue;
    DWORD dwValueSize;
    HKEY LocalKey = NULL;

    if (!RtlGetNtProductType( &ProductType ) ) {
        ProductType = NtProductWinNt;
    }

    if ( NtProductLanManNt == ProductType ) { 
        //
        // Disable the cache and ignore the parameters
        //
        LsapSidCacheMaxSize = 0;
        return;

    } 

    if (hKey == NULL) {

        err = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                            L"SYSTEM\\CurrentControlSet\\Control\\Lsa",
                            0, // reserved
                            KEY_QUERY_VALUE,
                            &LocalKey );
        if (err) {
            return;
        }
        hKey = LocalKey;
    }

    //
    // Read in the SID cache parameters
    //
    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_REFRESH_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );

    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue)) ) {
          // dwValue is good
          NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_REFRESH_TIME;
    }
    LsapSidCacheRefreshTime.QuadPart = Int32x32To64(dwValue*60, 10000000i64);

    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_EXPIRY_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );


    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue))) {
        // dwValue is good
        NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_EXPIRY_TIME;
    }
    LsapSidCacheExpiryTime.QuadPart = Int32x32To64(dwValue*60, 10000000i64);

    dwValueSize = sizeof(dwValue);
    err = RegQueryValueExW( hKey,
                            LSAP_LOOKUP_CACHE_MAX_SIZE_NAME,
                            NULL,  //reserved,
                            &dwType,
                            (PBYTE)&dwValue,
                            &dwValueSize );


    if ( (ERROR_SUCCESS == err)
      && (dwType == REG_DWORD)
      && (dwValueSize == sizeof(dwValue))) {
        // dwValue is good
        NOTHING;
    } else {
        dwValue = LSAP_DEFAULT_MAX_CACHE_SIZE;
    }
    LsapSidCacheMaxSize = dwValue;


    //
    // If the cache size is set to 0, immediately free everthing.
    //
    if (0 ==  LsapSidCacheMaxSize) {
        LsapDbFreeSidCache();
    }

    if (LocalKey) {
        RegCloseKey(LocalKey);
    }

    return;
}


VOID
LsapDbUpdateCacheWithSids(
    IN PSID *Sids,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSA_TRANSLATED_NAME_EX TranslatedNames
    )
/*++

Routine Description:

    This routine updates the global cache with the results of resolving
    Sids at a domain controller.  If a SID was resolved, any existing entry
    is refreshed; otherwise any existing entry is removed.

Arguments:

    Sids -- the list of SID's to update in the cache
    
    Count -- number of elements in Sids
    
    ReferencedDomains -- the domains that elements in Sids belong to
    
    TranslatedNames -- the resolved names, if any, of Sids

Return Values:

    None.

--*/
{
    ULONG i;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL, PrevEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

    LockSidCache();

    //
    // For each entry, try to find in cache
    //
    for (i = 0; i < Count; i++) {

        BOOLEAN SidWasResolved = TRUE;
        BOOLEAN EntryUpdated = FALSE;

        if (TranslatedNames[i].Flags & LSA_LOOKUP_SID_FOUND_BY_HISTORY) {
            //
            // The SID cache doesn't currently handle lookup's by SID history
            //
            continue;
        }

        if (  (TranslatedNames[i].Use == SidTypeUnknown)
           || (TranslatedNames[i].Use == SidTypeDeletedAccount)
           || (TranslatedNames[i].Use == SidTypeInvalid)  ) {

            SidWasResolved = FALSE;

        }

        PrevEntry = NULL;
        CacheEntry = LsapSidCache;
        while (CacheEntry != NULL) {

            if ( RtlEqualSid(CacheEntry->Sid, Sids[i]) ) {

                PLSAP_DB_SID_CACHE_ENTRY DiscardEntry = NULL;

                //
                // An entry for this SID exists
                //
                if (SidWasResolved) {
                

                    if ((CacheEntry->Flags & LSAP_SID_CACHE_SAM_ACCOUNT_NAME)) {

                        if (LsapNamesMatch(&CacheEntry->AccountName, &TranslatedNames[i].Name)
                         && LsapNamesMatch(&CacheEntry->DomainName, &ReferencedDomains->Domains[TranslatedNames[i].DomainIndex].Name) ) {

                            //
                            // This entry is still valid -- update refresh time
                            //
                            ASSERT(FALSE == EntryUpdated);
                            CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
                            EntryUpdated = TRUE;

                        } else {

                            //
                            // There is an entry with this SID and a sam
                            // account name but not the name that was returned.
                            // This is the account rename case.
                            DiscardEntry = CacheEntry;
                        }
                    } else {

                        //
                        // The SID was resolved and this entry has a UPN
                        // in it. Don't update since we don't know if
                        // the UPN is still valid
                        //
                    }

                } else {

                    //
                    // This SID could not be found -- discard this entry
                    // and remove from the list.
                    //
                    DiscardEntry = CacheEntry;
                }

                if ( DiscardEntry
                  && (DiscardEntry->InUseCount == 0) ) {


                    DiscardEntry = CacheEntry;
                    if (PrevEntry) {
                        ASSERT(PrevEntry->Next == CacheEntry);
                        PrevEntry->Next = CacheEntry->Next;
                        CacheEntry = PrevEntry;
                    } else {
                        ASSERT(LsapSidCache == CacheEntry);
                        LsapSidCache = CacheEntry->Next;
                        CacheEntry = LsapSidCache;
                    }
                    PrevEntry = NULL;
                    LsapDbFreeCacheEntry(DiscardEntry);
                    LsapSidCacheCount--;
                }
            }

            PrevEntry = CacheEntry;
            if (CacheEntry) {
                CacheEntry = CacheEntry->Next;
            }
        }

        if ( SidWasResolved 
         && !EntryUpdated   ) {

            //
            // Add an entry
            //
            (VOID) LsapDbAddOneSidToCache(
                        Sids[i],
                        &TranslatedNames[i].Name,
                        TranslatedNames[i].Use,
                        &ReferencedDomains->Domains[TranslatedNames[i].DomainIndex],
                        TranslatedNames[i].Flags,
                        LSAP_SID_CACHE_UNIQUE,
                        NULL
                        );
        }
    }

    UnLockSidCache();

}


VOID
LsapDbUpdateCacheWithNames(
    IN PUNICODE_STRING AccountNames,
    IN PUNICODE_STRING DomainNames,
    IN ULONG Count,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN PLSAPR_TRANSLATED_SID_EX2 TranslatedSids
    )
/*++

Routine Description:

    This routine updates the global cache with the results of resolving
    AccountNames at a domain controller.  If a name was resolved, any existing
    entry is refreshed; otherwise any existing entry is removed.

Arguments:

    AccountNames/DomainNames -- the list of names to update in the cache
    
    Count -- the number of elements in both AccountNames and DomainNames
    
    ReferencedDomains -- the domains that elements in Account belong to
    
    TranslatedNames -- the resolved SIDs, if any, of AccountNames

Return Values:

    None.

--*/
{
    ULONG i;
    LARGE_INTEGER CurrentTime;
    PLSAP_DB_SID_CACHE_ENTRY CacheEntry = NULL, PrevEntry = NULL;

    GetSystemTimeAsFileTime( (LPFILETIME) &CurrentTime );

    LockSidCache();

    //
    // For each entry, try to find in cache
    //
    for (i = 0; i < Count; i++) {

        BOOLEAN NameWasResolved = TRUE;
        BOOLEAN EntryUpdated = FALSE;


        if (  (TranslatedSids[i].Use == SidTypeUnknown)
           || (TranslatedSids[i].Use == SidTypeDeletedAccount)
           || (TranslatedSids[i].Use == SidTypeInvalid)  ) {

            NameWasResolved = FALSE;

        }

        PrevEntry = NULL;
        CacheEntry = LsapSidCache;
        while (CacheEntry != NULL) {

            BOOLEAN fNameMatched = FALSE;

            if (CacheEntry->SidType == SidTypeDomain) {
                //
                // No account name -- try just the domain name
                //
                fNameMatched =  LsapNamesMatch(&CacheEntry->DomainName, &AccountNames[i]);

            } else {

                if (NameWasResolved) {

                    fNameMatched =  LsapNamesMatch(&CacheEntry->AccountName, &AccountNames[i]) 
                                 && LsapNamesMatch(&CacheEntry->DomainName, &ReferencedDomains->Domains[TranslatedSids[i].DomainIndex].Name);

                } else {
                    //
                    // We don't have the translated name
                    //
                    fNameMatched =  LsapNamesMatch(&CacheEntry->AccountName, &AccountNames[i]);
                    if (fNameMatched 
                     && DomainNames[i].Length != 0) {
                        fNameMatched =  LsapNamesMatch(&CacheEntry->DomainName, &DomainNames[i]);
                    }
                }
            }

            if ( fNameMatched ) {

                PLSAP_DB_SID_CACHE_ENTRY DiscardEntry = NULL;

                //
                // An entry for this name exists
                //
                if (NameWasResolved) {
                
                    if  (RtlEqualSid(CacheEntry->Sid, TranslatedSids[i].Sid)) {

                        //
                        // This entry is still valid -- update refresh time
                        //
                        ASSERT(FALSE == EntryUpdated);
                        CacheEntry->RefreshTime.QuadPart = CurrentTime.QuadPart + LsapSidCacheRefreshTime.QuadPart;
                        EntryUpdated = TRUE;
                    } else {

                        //
                        // The entry has the same name as the resolved name
                        // but a different SID. This can happen in usual
                        // rename cases.
                        //
                        DiscardEntry = CacheEntry;
                    }

                } else {

                    //
                    // The name was not resolved -- remove
                    //
                    DiscardEntry = CacheEntry;
                }

                if ( DiscardEntry
                  && (DiscardEntry->InUseCount == 0) ) {

                    //
                    // Discard and remove from list
                    //
                    DiscardEntry = CacheEntry;
                    if (PrevEntry) {
                        ASSERT(PrevEntry->Next == CacheEntry);
                        PrevEntry->Next = CacheEntry->Next;
                        CacheEntry = PrevEntry;
                    } else {
                        ASSERT(LsapSidCache == CacheEntry);
                        LsapSidCache = CacheEntry->Next;
                        CacheEntry = LsapSidCache;
                    }
                    PrevEntry = NULL;
                    LsapDbFreeCacheEntry(DiscardEntry);
                    LsapSidCacheCount--;
                }
            }

            PrevEntry = CacheEntry;
            if (CacheEntry) {
                CacheEntry = CacheEntry->Next;
            }
        }

        if ( NameWasResolved 
         && !EntryUpdated   ) {

            //
            // Add an entry
            //
            (VOID) LsapDbAddOneSidToCache(
                        TranslatedSids[i].Sid,
                        &AccountNames[i],
                        TranslatedSids[i].Use,
                        &ReferencedDomains->Domains[TranslatedSids[i].DomainIndex],
                        TranslatedSids[i].Flags,
                        LSAP_SID_CACHE_UNIQUE,
                        NULL
                        );
        }
    }

    UnLockSidCache();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\chicago\negstub.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    negstub.cxx

Abstract:

    Negotiate Security Support Provider client stubs.

Author:

    Chandana Surlu (ChandanS) 11-Aug-1997

Environment:  Win9x User Mode

Revision History:

--*/

#include <kerb.hxx>

#define NEGSTUB_ALLOCATE

#include <stdarg.h>       // Variable-length argument support
#include <cryptdll.h>
#include "negotiat.hxx"
#include <debug.h>

SECPKG_DLL_FUNCTIONS UserFunctionTable;
VOID
NegShutdownSecurityInterface(
    VOID
    );

VOID DumpLogonSession();

BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    ULONG  dwReason,
    PVOID  lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeCriticalSection( &NegDllCritSect );

#if DBG
        InitializeCriticalSection( &NegGlobalLogFileCritSect );
        NegInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API | 
                        DEB_TRACE_NEG | DEB_TRACE_NEG_LOCKS;
#endif // DBG
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        NegShutdownSecurityInterface();
#if DBG
        DeleteCriticalSection( &NegGlobalLogFileCritSect );
#endif // DBG

        DeleteCriticalSection( &NegDllCritSect );
    }

    return TRUE;
}


PSecurityFunctionTable
InitSecurityInterfaceA(
    VOID
    )

/*++

Routine Description:

    RPC calls this function to get the addresses of all the other functions
    that it might call.

Arguments:

    None.

Return Value:

    A pointer to our static SecurityFunctionTable.  The caller need
    not deallocate this table.

--*/

{
    SECURITY_STATUS Status = SEC_E_OK;

    // BUBUG Init this to something, we need Parameters.DomainName,
    // Parameters.DnsDomainName & Parameters.version at least

    SECPKG_PARAMETERS Parameters;

    DebugLog((DEB_TRACE_API, "Entering InitSecurityInterface\n"));

    // Initialize the SecurityFunctionTable
    ZeroMemory( &NegDllSecurityFunctionTable,
                sizeof(NegDllSecurityFunctionTable) );

    NegDllSecurityFunctionTable.dwVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;

    NegDllSecurityFunctionTable.EnumerateSecurityPackages = NegEnumerateSecurityPackages;
    NegDllSecurityFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    NegDllSecurityFunctionTable.FreeCredentialHandle = SpFreeCredentialsHandle;
    NegDllSecurityFunctionTable.InitializeSecurityContext = SpInitializeSecurityContext;
    NegDllSecurityFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes;
    NegDllSecurityFunctionTable.AcceptSecurityContext = SpAcceptSecurityContext;
    NegDllSecurityFunctionTable.CompleteAuthToken = SpCompleteAuthToken;
    NegDllSecurityFunctionTable.QueryContextAttributes = SpQueryContextAttributes;
    NegDllSecurityFunctionTable.SspiLogonUser = NULL;
    NegDllSecurityFunctionTable.DeleteSecurityContext = SpDeleteSecurityContext;
    NegDllSecurityFunctionTable.ApplyControlToken = SpApplyControlToken;
    NegDllSecurityFunctionTable.ImpersonateSecurityContext = NULL;
    NegDllSecurityFunctionTable.RevertSecurityContext = NULL;
    NegDllSecurityFunctionTable.MakeSignature = NULL;
    NegDllSecurityFunctionTable.VerifySignature = NULL;
    NegDllSecurityFunctionTable.FreeContextBuffer = NegFreeContextBuffer; 
    NegDllSecurityFunctionTable.QuerySecurityPackageInfo = NegQuerySecurityPackageInfo;
    NegDllSecurityFunctionTable.Reserved3 = NULL;
    NegDllSecurityFunctionTable.Reserved4 = NULL;
  
    Parameters.MachineState = SECPKG_STATE_STANDALONE;
    Status = NegInitialize(2, &Parameters, &FunctionTable);

    DebugLog((DEB_TRACE_API, "NegInitialize returned 0x%x\n", Status));
    DebugLog((DEB_TRACE_API, "Leaving InitSecurityInterface\n"));
    return SEC_SUCCESS(Status) ? &NegDllSecurityFunctionTable : NULL;
}


VOID
NegShutdownSecurityInterface(
    VOID
    )

/*++

Routine Description:

    Cleanup the data shared by the DLL and SERVICE.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DebugLog((DEB_TRACE_API, "Entering NegShutdownSecurityInterface\n"));

//    NegShutdown();

    DebugLog((DEB_TRACE_API, "Leaving NegShutdownSecurityInterface\n"));

}


SECURITY_STATUS
NegEnumerateSecurityPackages(
    OUT PULONG PackageCount,
    OUT PSecPkgInfo *PackageInfo
    )

/*++

Routine Description:

    This API returns a list of Security Packages available to client (i.e.
    those that are either loaded or can be loaded on demand).  The caller
    must free the returned buffer with FreeContextBuffer.  This API returns
    a list of all the security packages available to a service.  The names
    returned can then be used to acquire credential handles, as well as
    determine which package in the system best satisfies the requirements
    of the caller.  It is assumed that all available packages can be
    included in the single call.

    This is really a dummy API that just returns information about this
    security package.  It is provided to ensure this security package has the
    same interface as the multiplexer DLL does.

Arguments:

     PackageCount - Returns the number of packages supported.

     PackageInfo - Returns an allocate array of structures
        describing the security packages.  The array must be freed
        using FreeContextBuffer.

Return Value:

    SEC_E_OK -- Call completed successfully

    SEC_E_PACKAGE_UNKNOWN -- Package being queried is not this package
    SEC_E_INSUFFICIENT_MEMORY -- Not enough memory

--*/
{
    //
    // Get the information for this package.
    //

    LPTSTR Where;

    DebugLog((DEB_TRACE_API, "Entering NegEnumerateSecurityPackages\n"));
    *PackageCount = 1;
    //
    // Allocate a buffer for the PackageInfo
    //

    *PackageInfo = (PSecPkgInfo) LocalAlloc( 0, sizeof(SecPkgInfo) +
                                  sizeof(NEGOSSP_NAME_A) +
                                  sizeof(NEGOSSP_PACKAGE_COMMENT) );

    if ( *PackageInfo == NULL ) {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    //
    // Fill in the information.
    //

    (*PackageInfo)->fCapabilities = SECPKG_FLAG_INTEGRITY |
                                    SECPKG_FLAG_PRIVACY |
                                    SECPKG_FLAG_DATAGRAM |
                                    SECPKG_FLAG_CONNECTION |
                                    SECPKG_FLAG_MULTI_REQUIRED |
                                    SECPKG_FLAG_EXTENDED_ERROR |
                                    SECPKG_FLAG_IMPERSONATION |
                                    SECPKG_FLAG_ACCEPT_WIN32_NAME |
                                    SECPKG_FLAG_LOGON;
    (*PackageInfo)->wVersion = 1;
    (*PackageInfo)->wRPCID = NEGOSSP_RPCID;
    (*PackageInfo)->cbMaxToken = 4000;

    Where = (LPTSTR)((*PackageInfo)+1);

    (*PackageInfo)->Name = Where;
    lstrcpy( Where, NEGOSSP_NAME);
    Where += lstrlen(Where) + 1;

    (*PackageInfo)->Comment = Where;
    lstrcpy( Where, NEGOSSP_PACKAGE_COMMENT);
    Where += lstrlen(Where) + 1;


    return SEC_E_OK;

}

SECURITY_STATUS
NegQuerySecurityPackageInfo (
    LPTSTR PackageName,
    PSecPkgInfo SEC_FAR * Package
    )
{
    ULONG PackageCount;

    DebugLog((DEB_TRACE_API, "Entering NegQuerySecurityPackageInfo\n"));
	return ( NegEnumerateSecurityPackages(
                &PackageCount,
				Package));

}



SECURITY_STATUS SEC_ENTRY
NegFreeContextBuffer (
    void __SEC_FAR * ContextBuffer
    )

/*++

Routine Description:

    This API is provided to allow callers of security API such as
    InitializeSecurityContext() for free the memory buffer allocated for
    returning the outbound context token.

Arguments:

    ContextBuffer - Address of the buffer to be freed.

Return Value:

    SEC_E_OK - Call completed successfully

--*/

{
    //
    // The only allocated buffer that the kerb currently returns to the caller
    // is from EnumeratePackages.  It uses LocalAlloc to allocate memory.  If
    // we ever need memory to be allocated by the service, we have to rethink
    // how this routine distinguishes between to two types of allocated memory.
    //

    DebugLog((DEB_TRACE_API, "Entering NegFreeContextBuffer\n"));
    (VOID) LocalFree( ContextBuffer );
    return SEC_E_OK;
}


SECURITY_STATUS
SpAcquireCredentialsHandle(
    IN LPTSTR PrincipalName,
    IN LPTSTR PackageName,
    IN ULONG CredentialUseFlags,
    IN PVOID LogonId,
    IN PVOID AuthData,
    IN SEC_GET_KEY_FN GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PCredHandle CredentialHandle,
    OUT PTimeStamp Lifetime
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;
    UNICODE_STRING NewPrincipalName;

    DebugLog((DEB_TRACE_API, "Entering SpAcquireCredentialsHandle\n"));
    //
    // Validate the arguments
    //

    if ( lstrcmpi( PackageName, NEGOSSP_NAME) != 0 ) {
        SecStatus = SEC_E_SECPKG_NOT_FOUND;
        goto Cleanup;
    }

    if ( (CredentialUseFlags & SECPKG_CRED_OUTBOUND) &&
         ARGUMENT_PRESENT(PrincipalName) && *PrincipalName != '\0' ) {
        SecStatus = SEC_E_UNKNOWN_CREDENTIALS;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(LogonId) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyFunction) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ( ARGUMENT_PRESENT(GetKeyArgument) ) {
        SecStatus = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if (!RtlCreateUnicodeStringFromAsciiz (&NewPrincipalName, PrincipalName))
    {
        SecStatus = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    SecStatus = NegAcquireCredentialsHandle(
                            &NewPrincipalName,
                            CredentialUseFlags,
                            (PLUID)LogonId,
                            AuthData,
                            GetKeyFunction,
                            GetKeyArgument,
                            &CredentialHandle->dwUpper,
                            Lifetime );

Cleanup:

    return SecStatus;

}

SECURITY_STATUS
SpFreeCredentialsHandle(
    IN PCredHandle CredentialHandle
    )

/*++

Routine Description:

    This API is used to notify the security system that the credentials are
    no longer needed and allows the application to free the handle acquired
    in the call described above. When all references to this credential
    set has been removed then the credentials may themselves be removed.

Arguments:

    CredentialHandle - Credential Handle obtained through
        AcquireCredentialHandle.

Return Value:


    SEC_E_OK -- Call completed successfully

    SEC_E_NO_SPM -- Security Support Provider is not running
    SEC_E_INVALID_HANDLE -- Credential Handle is invalid


--*/

{
    SECURITY_STATUS SecStatus;


    DebugLog((DEB_TRACE_API, "Entering SpFreeCredentialsHandle\n"));


    SecStatus = NegFreeCredentialsHandle(
                            CredentialHandle->dwUpper );



    return SecStatus;

}

SECURITY_STATUS
SpQueryCredentialsAttributes(
    IN PCredHandle CredentialsHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    SECURITY_STATUS SecStatus;

    DebugLog((DEB_TRACE_API, "Entering SpQueryCredentialsAttributes\n"));

    SecStatus = NegQueryCredentialsAttributes(
                            CredentialsHandle->dwUpper,
                            Attribute,
                            Buffer );

    return SecStatus;
}

SECURITY_STATUS
SpInitializeSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN LPTSTR TargetName,
    IN ULONG ContextReqFlags,
    IN ULONG Reserved1,
    IN ULONG TargetDataRep,
    IN PSecBufferDesc InputToken,
    IN ULONG Reserved2,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )
{
    UNICODE_STRING TargetNameUStr;
    BOOLEAN fMappedContext;
    SecBuffer ContextData;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    SECURITY_STATUS SecondaryStatus = SEC_E_OK;
    SecBufferDesc EmptyBuffer =  {0,0, NULL};

    DebugLog((DEB_TRACE_API, "Entering SpInitializeSecurityContext\n"));
    RtlCreateUnicodeStringFromAsciiz (&TargetNameUStr, TargetName);

    if (!ARGUMENT_PRESENT(InputToken))
    {
        InputToken = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(OutputToken))
    {
        OutputToken = &EmptyBuffer;
    }

    SecStatus = NegInitLsaModeContext (
                          CredentialHandle ? CredentialHandle->dwUpper : NULL,
                          OldContextHandle ? OldContextHandle->dwUpper : NULL,
                          &TargetNameUStr,
                          ContextReqFlags,
                          TargetDataRep,
                          InputToken,
                          &NewContextHandle->dwUpper,
                          OutputToken,
                          ContextAttributes,
                          ExpirationTime,
                          &fMappedContext,
                          &ContextData);

    (VOID) RtlFreeUnicodeString( &TargetNameUStr );

    return SecStatus;
}


SECURITY_STATUS
SpAcceptSecurityContext(
    IN PCredHandle CredentialHandle,
    IN PCtxtHandle OldContextHandle,
    IN PSecBufferDesc InputToken,
    IN ULONG ContextReqFlags,
    IN ULONG TargetDataRep,
    OUT PCtxtHandle NewContextHandle,
    OUT PSecBufferDesc OutputToken,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime
    )
{
    BOOLEAN fMappedContext;
    SecBuffer ContextData;
    SECURITY_STATUS SecStatus = SEC_E_OK;
    SECURITY_STATUS SecondaryStatus = SEC_E_OK;
    SecBufferDesc EmptyBuffer =  {0,0, NULL};

    DebugLog((DEB_TRACE_API, "Entering SpAcceptSecurityContext\n"));

    if (!ARGUMENT_PRESENT(InputToken))
    {
        InputToken = &EmptyBuffer;
    }

    if (!ARGUMENT_PRESENT(OutputToken))
    {
        OutputToken = &EmptyBuffer;
    }

    SecStatus = NegAcceptLsaModeContext (
                          CredentialHandle ? CredentialHandle->dwUpper : NULL,
                          OldContextHandle ? OldContextHandle->dwUpper : NULL,
                          InputToken,
                          ContextReqFlags,
                          TargetDataRep,
                          &NewContextHandle->dwUpper,
                          OutputToken,
                          ContextAttributes,
                          ExpirationTime,
                          &fMappedContext,
                          &ContextData);

    return SecStatus;
}

SECURITY_STATUS
SpDeleteSecurityContext (
    IN PCtxtHandle ContextHandle
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    DebugLog((DEB_TRACE_API, "Entering SpDeleteSecurityContext\n"));
    SecStatus = NegDeleteLsaModeContext (ContextHandle->dwUpper);

    return SecStatus;

}

SECURITY_STATUS
SpApplyControlToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc Input
    )
{
    SECURITY_STATUS SecStatus = SEC_E_OK;

    DebugLog((DEB_TRACE_API, "Entering SpApplyControlToken\n"));
    SecStatus = NegApplyControlToken(ContextHandle->dwUpper, Input);

    return SecStatus;
}


SECURITY_STATUS
NegImpersonateSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    DebugLog((DEB_TRACE_API, "Entering NegImpersonateSecurityContext\n"));
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
NegRevertSecurityContext (
    PCtxtHandle ContextHandle
    )
{
    DebugLog((DEB_TRACE_API, "Entering NegRevertSecurityContext\n"));
    return (SEC_E_NO_IMPERSONATION);
}

SECURITY_STATUS
SpQueryContextAttributes(
    IN PCtxtHandle ContextHandle,
    IN ULONG Attribute,
    OUT PVOID Buffer
    )
{
    DebugLog((DEB_TRACE_API, "Entering SpQueryContextAttributes\n"));
    return (SEC_E_UNSUPPORTED_FUNCTION);

}

SECURITY_STATUS SEC_ENTRY
SpCompleteAuthToken (
    PCtxtHandle ContextHandle,
    PSecBufferDesc BufferDescriptor
    )
{
    DebugLog((DEB_TRACE_API, "Entering SpCompleteAuthToken\n"));
    return (SEC_E_UNSUPPORTED_FUNCTION);
}

#if DBG
//
// Control which messages get displayed
//

// DWORD NegInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API;

//
// SspPrintRoutine - Displays debug output
//
VOID __cdecl
NegPrintRoutine(
    IN DWORD DebugFlag,
    IN LPCSTR FormatString,    // PRINTF()-STYLE FORMAT STRING.
    ...                        // OTHER ARGUMENTS ARE POSSIBLE.
    )
{
    static char prefix[] = "NEG: ";
    char outbuf[256];
    va_list args;

    if ( DebugFlag & NegInfoLevel) {
        EnterCriticalSection( &NegGlobalLogFileCritSect );
        lstrcpy(outbuf, prefix);
        va_start(args, FormatString);
        wvsprintf(outbuf + sizeof(prefix) - 1, FormatString, args);
        OutputDebugString(outbuf);
        LeaveCriticalSection( &NegGlobalLogFileCritSect );
    }

    return;
}
#endif DBG

//+-------------------------------------------------------------------------
//
//  Function:   LsapDuplicateString
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
NTSTATUS
LsapDuplicateString(
    OUT PUNICODE_STRING pDest,
    IN PUNICODE_STRING pSrc
    )

{
    pDest->Length = 0;
    if (pSrc == NULL)
    {
        pDest->Buffer = NULL;
        pDest->MaximumLength = 0;
        return(STATUS_SUCCESS);
    }

    pDest->Buffer = (LPWSTR) LsapAllocateLsaHeap(pSrc->Length + sizeof(WCHAR));
    if (pDest->Buffer)
    {
        pDest->MaximumLength = pSrc->Length + sizeof(WCHAR);
        RtlCopyMemory(
            pDest->Buffer,
            pSrc->Buffer,
            pSrc->Length
            );
        pDest->Buffer[pSrc->Length/sizeof(WCHAR)] = L'\0';
        pDest->Length = pSrc->Length;
        return(STATUS_SUCCESS);

    } else
    {
        pDest->MaximumLength = 0;
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocation routine for use by RPC client stubs
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  BufferSize - size of buffer, in bytes, to allocate
//
//  Requires:
//
//  Returns:    Buffer pointer or NULL on allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return(LocalAlloc( 0, BufferSize) );
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Memory free routine for RPC client stubs
//
//  Effects:    frees the buffer with LsaFunctions.FreeLsaHeap
//
//  Arguments:  Buffer - Buffer to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    LocalFree( Buffer );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbaccnt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbaccnt.c

Abstract:

    LSA - Database - Account Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      April 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Datatypes                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

//
// The following structures define output for the LsarQueryInformationAccount()
// API.  Curerently, this API is internal.  If made external, these structures
// should be moved to lsarpc.idl and annotated with MIDL qualifiers [..].
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _ACCOUNT_INFORMATION_CLASS {

    AccountSystemAccessInformation = 1,
    AccountPrivilegeInformation,
    AccountQuotaInformation

} ACCOUNT_INFORMATION_CLASS, *PACCOUNT_INFORMATION_CLASS;

typedef PRIVILEGE_SET LSAPR_ACCOUNT_PRIVILEGE_INFO;
typedef QUOTA_LIMITS LSAPR_ACCOUNT_QUOTA_INFO;
typedef ULONG LSAPR_ACCOUNT_SYSTEM_ACCESS_INFO;

typedef union _LSAPR_ACCOUNT_INFO {

    LSAPR_ACCOUNT_PRIVILEGE_INFO          AccountPrivilegeInfo;
    LSAPR_ACCOUNT_QUOTA_INFO              AccountQuotaInfo;
    LSAPR_ACCOUNT_SYSTEM_ACCESS_INFO      AccountSystemAccessInfo;

} LSAPR_ACCOUNT_INFO, *PLSAPR_ACCOUNT_INFO;

#define LsapDbFirstAccount()                                              \
    ((PLSAP_DB_ACCOUNT) LsapDbAccountList.Links.Flink)

#define LsapDbNextAccount( Account )                                      \
    ((PLSAP_DB_ACCOUNT) Account->Links.Flink)


#define LSAP_DB_BUILD_ACCOUNT_LIST_LENGTH     ((ULONG) 0x00001000L)

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Function Prototypes                                             //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapDbSlowQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    );

NTSTATUS
LsapDbSlowQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    );

NTSTATUS
LsapDbSlowQueryPrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    );

NTSTATUS
LsapDbSlowQueryQuotasAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
LsapDbSlowQuerySystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    );

NTSTATUS
LsapDbLookupAccount(
    IN PSID AccountSid,
    OUT PLSAP_DB_ACCOUNT *Account
    );

NTSTATUS
LsapDbUpdateSystemAccessAccount(
    IN PLSAPR_SID AccountSid,
    IN PULONG SystemAccess
    );

NTSTATUS
LsapDbUpdatePrivilegesAccount(
    IN PLSAPR_SID AccountSid,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    );

NTSTATUS
LsapDbUpdateQuotasAccount(
    IN PLSAPR_SID AccountSid,
    IN PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
LsapDbCreateAccountList(
    OUT PLSAP_DB_ACCOUNT_LIST AccountList
    );

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Private Global Data                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

LSAP_DB_ACCOUNT_LIST LsapDbAccountList;

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Code                                                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarCreateAccount(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE AccountHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateAccount API.

    The LsaCreateAccount API creates a new Account Object.  The account will
    be opened with the specified accesses granted.  The caller must
    have POLICY_CREATE_ACCOUNT access to the Policy Object.

    Note that no verification is done to ensure the SID actually represents
    a valid user, group or alias in any trusted domain.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    AccountSid - Points to the SID of the account.

    DesiredAccess - Specifies the accesses to be granted to the newly
        created and opened account at this time.

    AccountHandle - Receives a handle referencing the newly created
        account.  This handle is used on subsequent accesses to the
        account object.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_EXISTS - An account object having the given Sid
            already exists and has been opened because LSA_OBJECT_OPEN_IF
            disposition has been specified.  This is a warning only.

        STATUS_OBJECT_NAME_COLLISION - An account object having the given Sid
            already exists but has not been opened because LSA_OBJECT_CREATE
            disposition has been specified.  This is an error.

        STATUS_INVALID_PARAMETER - An invalid parameter has been specified.
--*/

{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_ACCOUNT];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    UNICODE_STRING LogicalNameU;
    ULONG AttributeCount;
    BOOLEAN ContainerReferenced = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarCreateAccount\n" ));


    LogicalNameU.Length = 0;

    //
    // Set up the object's attributes specific to the Account object type.
    // These are the Account Type and the Sid.
    //

    AttributeCount = 0;
    NextAttribute = Attributes;

    //
    // Validate the Account Sid.
    //

    if (!RtlValidSid( (PSID) AccountSid )) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateAccountError;
    }

    Status = LsapDbMakeSidAttributeDs(
                 AccountSid,
                 Sid,
                 NextAttribute
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    AttributeCount++;
    NextAttribute++;

    //
    // Acquire the Lsa Database lock.  Verify that the PolicyHandle
    // is valid and has the necessary access granted.  Reference the Policy
    // Object handle (as container object).
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_CREATE_ACCOUNT,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    ContainerReferenced = TRUE;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // account object.  The Logical Name is constructed from the account
    // Sid by extracting the Relative Id (lowest subauthority) and converting
    // it to an 8-digit numeric Unicode String in which leading zeros are
    // added if needed.
    //

    Status = LsapDbSidToLogicalNameObject(AccountSid, &LogicalNameU);

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    //
    // Fill in the ObjectInformation structure.  Initialize the
    // embedded Object Attributes with the PolicyHandle as the
    // Root Directory (Container Object) handle and the Logical Name
    // of the account. Store the types of the object and its container.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,
        NULL
        );

    ObjectInformation.ObjectTypeId = AccountObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = AccountSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Create the Account Object.  We fail if the object already exists.
    // Note that the object create routine performs a Database transaction.
    // If caching is supported, the object will also be added to the cache.
    //

    Status = LsapDbCreateObject(
                 &ObjectInformation,
                 DesiredAccess,
                 LSAP_DB_OBJECT_CREATE,
                 0,
                 Attributes,
                 AttributeCount,
                 AccountHandle
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

CreateAccountFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (ContainerReferenced) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( AccountObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );
    }

    //
    // If necessary, free the Unicode String buffer allocated for the Logical Name
    //

    if (LogicalNameU.Length > 0) {

        RtlFreeUnicodeString(&LogicalNameU);
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarCreateAccount: 0x%lx\n", Status ));

    return( Status );

CreateAccountError:

    //
    // If necessary, dereference the Container Object, release the LSA
    // Database Lock and return.
    //

    if (ContainerReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ContainerReferenced = FALSE;
    }

    goto CreateAccountFinish;
}


NTSTATUS
LsarOpenAccount(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID AccountSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE AccountHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the LsaOpenAccount
    API.

    The LsaOpenAccount API opens an account object in the Lsa Database of the
    target system.  An account must be opened before any operation can be
    performed, including deletion of the account.  A handle to the account
    object is returned for use on subsequent API calls that access the
    account.  Before calling this API, the caller must have connected to
    the target system's LSA and opened the LsaDatabase object by means
    of a preceding call to LsaOpenPolicy.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    AccountSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested for the Account object.  These access types
        are reconciled with the Discretionary Access Control List of the
        object to determine whether the accesses will be granted or denied.

    AccountHandle - Pointer to location in which a handle to the opened
        account object will be returned if the call succeeds.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no account object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    UNICODE_STRING LogicalNameU;
    BOOLEAN ContainerReferenced = FALSE;
    BOOLEAN AcquiredLock = FALSE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenAccount\n" ));


    //
    // Validate the Account Sid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!RtlValidSid( AccountSid )) {

        goto OpenAccountError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, and is of the expected type.
    // Reference the container object handle.  This reference remains in
    // effect until the child object handle is closed.
    //
    // We can't check access on the policy handle.  Too many applications
    //  rely on no access being acquired.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }

    AcquiredLock = TRUE;
    ContainerReferenced =TRUE;

    //
    // Setup Object Information prior to calling the Object
    // Open routine.  The Object Type, Container Object Type and
    // Logical Name (derived from the Sid) need to be filled in.
    //

    ObjectInformation.ObjectTypeId = AccountObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = AccountSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // account object.  The Logical Name is constructed from the account
    // Sid by extracting the Relative Id (lowest subauthority) and converting
    // it to an 8-digit numeric Unicode String in which leading zeros are
    // added if needed.
    //

    Status = LsapDbSidToLogicalNameObject(AccountSid,&LogicalNameU);

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }
    //
    // Initialize the Object Attributes.  The Container Object Handle and
    // Logical Name (Internal Name) of the object must be set up.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        0,
        PolicyHandle,
        NULL
        );

    //
    // Open the specific account object.  Note that the account object
    // handle returned is an RPC Context Handle.
    //

    Status = LsapDbOpenObject(
                 &ObjectInformation,
                 DesiredAccess,
                 0,
                 AccountHandle
                 );

    RtlFreeUnicodeString( &LogicalNameU );

    if (!NT_SUCCESS(Status)) {

        goto OpenAccountError;
    }

OpenAccountFinish:

    //
    // If necessary, release the LSA Database lock.
    //

    if (AcquiredLock) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( AccountObject,
                             LSAP_DB_READ_ONLY_TRANSACTION );

        AcquiredLock = FALSE;
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarOpenAccount: 0x%lx\n", Status ));

    return( Status );

OpenAccountError:

    //
    // If necessary, dereference the Container Object handle.  Note that
    // this is only done in the error case.  In the non-error case, the
    // Container handle stays referenced until the Account object is
    // closed.
    //

    if (ContainerReferenced) {

        *AccountHandle = NULL;

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ContainerReferenced = FALSE;
        AcquiredLock = FALSE;
    }

    goto OpenAccountFinish;

}


NTSTATUS
LsarEnumerateAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateAccounts API.

    The LsaEnumerateAccounts API returns information about the accounts
    in the target system's Lsa Database.  This call requires
    LSA_ENUMERATE_ACCOUNTS access to the Policy object.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can be
    used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.  On each
    subsequent call, the value returned by the preceding call should be passed
    in unchanged.  The enumeration is complete when the warning
    STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the accounts enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        account.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects are enumerated because the
            EnumerationContext value passed in is too high.
--*/

{
    NTSTATUS Status;
    LSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer;
    ULONG MaxLength;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarEnumerateAccounts\n" ));



    //
    // If no Enumeration Structure or index is provided, return an error.
    //

    if ( !ARGUMENT_PRESENT(EnumerationBuffer) ||
         !ARGUMENT_PRESENT(EnumerationBuffer)    ) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the internal Lsa Database Enumeration Buffer, and
    // the provided Enumeration Buffer to NULL.
    //

    DbEnumerationBuffer.EntriesRead = 0;
    DbEnumerationBuffer.Sids = NULL;
    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (NT_SUCCESS(Status)) {

       //
       // Limit the enumeration length except for trusted callers
       //

       if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted   &&
            (PreferedMaximumLength > LSA_MAXIMUM_ENUMERATION_LENGTH)
            ) {
            MaxLength = LSA_MAXIMUM_ENUMERATION_LENGTH;
        } else {
            MaxLength = PreferedMaximumLength;
        }

        //
        // Call general Sid enumeration routine.
        //
        Status = LsapDbEnumerateSids(
                     PolicyHandle,
                     AccountObject,
                     EnumerationContext,
                     &DbEnumerationBuffer,
                     MaxLength
                     );


        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_NO_DS_OP_TRANSACTION |
                        LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

    }

    //
    // Copy the enumerated information to the output.  We can use the
    // information actually returned by LsapDbEnumerateSids because it
    // happens to be in exactly the correct form.
    //
    EnumerationBuffer->EntriesRead = DbEnumerationBuffer.EntriesRead;
    EnumerationBuffer->Information = (PLSAPR_ACCOUNT_INFORMATION) DbEnumerationBuffer.Sids;



    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarEnumerateAccounts:0x%lx\n", Status ));

    return(Status);

}


NTSTATUS
LsarEnumeratePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumeratePrivilegesOfAccount API.

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    return(LsarQueryInformationAccount(
               AccountHandle,
               AccountPrivilegeInformation,
               (PLSAPR_ACCOUNT_INFO *) Privileges
               ));
}


NTSTATUS
LsarAddPrivilegesToAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PLSAPR_PRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaAddPrivilegesToAccount API.

    The LsaAddPrivilegesToAccount API adds privileges and their attributes
    to an account object.  If any provided privilege is already assigned
    to the account object, the attributes of that privilege are replaced
    by the newly rpovided values.  This API call requires
    LSA_ACCOUNT_ADJUST_PRIVILEGES access to the account object.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be added.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Points to a set of privileges (and their attributes) to
        be assigned to the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

--*/

{
    return LsapAddPrivilegesToAccount( AccountHandle, Privileges, TRUE );
}



NTSTATUS
LsapAddPrivilegesToAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarAddPrivilegesToAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsapAddPrivilegesToAccount\n" ));


    Status = LsapDbChangePrivilegesAccount( AccountHandle,
                                            AddPrivileges,
                                            FALSE,
                                            (PPRIVILEGE_SET) Privileges,
                                            LockSce );

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsapAddPrivilegesToAccount: 0x%lx\n", Status ));

    return( Status );
}


NTSTATUS
LsarRemovePrivilegesFromAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PLSAPR_PRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function is the RPC server worker routine for the
    LsaRemovePrivilegesFromAccount API.

    The LsaRemovePrivilegesFromAccount API removes privileges from an
    account object.  This API call requires LSA_ACCOUNT_ADJUST_PRIVILEGES
    access to the account object.  Note that if all privileges are removed
    from the account object, the account object remains in existence until
    deleted explicitly via a    call to the LsaDeleteAccount API.

Arguments:

    AccountHandle - The handle to the open account object to which
        privileges are to be removed.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    AllPrivileges - If TRUE, then all privileges are to be removed from
        the account.  In this case, the Privileges parameter must be
        specified as NULL.  If FALSE, the Privileges parameter specifies
        the privileges to be removed, and must be non NULL.

    Privileges - Optionally points to a set of privileges (and their
        attributes) to be removed from the account object.  The attributes
        fields of this structure are ignored.  This parameter must
        be specified as non-NULL if and only if AllPrivileges is set to
        FALSE.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INVALID_PARAMETER - The optional Privileges paraemter was
            specified as NULL and AllPrivileges was set to FALSE.

--*/

{
    return LsapRemovePrivilegesFromAccount( AccountHandle, AllPrivileges, Privileges, TRUE );
}



NTSTATUS
LsapRemovePrivilegesFromAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PLSAPR_PRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarRemovePrivilegesFromAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsapRemovePrivilegesFromAccount\n" ));


    //
    // Verify that a meaningful combination of AllPrivileges and Privileges
    // has been specified.
    //

    if (AllPrivileges) {

        if (Privileges != NULL) {

            return STATUS_INVALID_PARAMETER;
        }

    } else {

        if (Privileges == NULL) {

            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Remove the privileges requested.
    //

    Status = LsapDbChangePrivilegesAccount(
                 AccountHandle,
                 RemovePrivileges,
                 AllPrivileges,
                 (PPRIVILEGE_SET) Privileges,
                 LockSce
                 );

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsapRemovePrivilegesFromAccount: 0x%lx\n", Status ));

    return(Status);
}



NTSTATUS
LsapDbChangePrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN LSAP_DB_CHANGE_PRIVILEGE_MODE ChangeMode,
    IN BOOLEAN AllPrivileges,
    IN OPTIONAL PPRIVILEGE_SET Privileges,
    IN BOOL LockSce
    )

/*++

Routine Description:

    This function changes the privileges assigned to an account.  It is
    called only by LsarAddPrivilegesToAccount and LsarRemovePrivilegesFrom-
    Account.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    AccountHandle - Handle to open Account object obtained from LsaOpenAccount.

    ChangeMode - Specifies the change mode

        AddPrivileges - Add the privileges
        RemovePrivileges - Delete the privileges

    AllPrivileges - If removing privileges from an account and this boolean
        is set to TRUE, all privileges are to be removed.  In this case,
        the Privileges parameter must be set to NULL.  In all other cases,
        AllPrivileges must be set to FALSE and Privileges must be non-NULL.

    Privileges - Specifies set of privileges to be changed.  This parameter
        must be set to NULL if and only if removing all privileges.

    LockSce - Specifies whether SCE policy should be locked or not (should be FALSE
              for situations where the caller already has it locked)

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    ULONG ExistingPrivilegesSize;
    LSAPR_HANDLE SubKeyHandle = NULL;
    PPRIVILEGE_SET ExistingPrivileges = NULL;
    BOOLEAN TransactionAbort = FALSE;
    ULONG AuditEventId;
    PLUID_AND_ATTRIBUTES Luids = NULL;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAPR_SID AccountSid = NULL;
    LSAP_DB_HANDLE InternalHandle = AccountHandle;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    ULONG MaxPrivileges = 0;

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandleChild ) {

        if ( LockSce ) {

            RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
            if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                Status = STATUS_TOO_MANY_THREADS;
            }
            RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

            if ( !NT_SUCCESS( Status )) {

                goto ChangePrivilegesError;
            }

            WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
            RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
            ASSERT( !g_ScePolicyLocked );
            ScePolicyLocked = TRUE;
        }

        NotifySce = TRUE;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_ADJUST_PRIVILEGES,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_START_TRANSACTION |
                    LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto ChangePrivilegesError;
    }

    ObjectReferenced = TRUE;

    //
    // Except in the case where AllPrivileges == TRUE on a remove call,
    // we need to read the existing privilege set.
    //

    if (!(AllPrivileges && (ChangeMode == RemovePrivileges)) ) {

        //
        // Query size of buffer needed for the existing Privileges.
        // Read the Account Object's Privileges data from the LSA Database
        //
        ExistingPrivilegesSize = 0;

        //
        // If we're doing a SetPrivileges and we're in registry mode, we'll just pretend we
        // have no existing privs and do an add
        //
        if ( ChangeMode == SetPrivileges ) {

            ExistingPrivileges = NULL;
            ChangeMode = AddPrivileges;

        } else {

            Status = LsapDbReadAttributeObject(
                         AccountHandle,
                         &LsapDbNames[Privilgs],
                         NULL,
                         &ExistingPrivilegesSize
                         );

            if (!NT_SUCCESS(Status)) {

                //
                // The only error permitted is STATUS_OBJECT_NAME_NOT_FOUND
                // because the account object does not have any privileges
                // assigned and has no Privilgs attribute.
                //

                if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                    goto ChangePrivilegesError;
                }

                //
                // Account has no existing privileges.
                //

                ExistingPrivileges = NULL;

            } else {

                //
                // Account already has privileges.  Allocate buffer for reading
                // the existing privilege set and read them in.
                //

                ExistingPrivileges = LsapAllocateLsaHeap( ExistingPrivilegesSize );

                if (ExistingPrivileges == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto ChangePrivilegesError;
                }

                Status = LsapDbReadAttributeObject(
                             AccountHandle,
                             &LsapDbNames[Privilgs],
                             ExistingPrivileges,
                             &ExistingPrivilegesSize
                             );

                if (!NT_SUCCESS(Status)) {

                    goto ChangePrivilegesError;
                }
            }
        }

        //
        // Now query the size of buffer required for the updated privilege
        // set
        //

        if ( ExistingPrivileges ) {

            MaxPrivileges = ExistingPrivileges->PrivilegeCount;
        }

        if (ChangeMode == AddPrivileges) {

            BOOLEAN Changed = FALSE;

            Status = LsapRtlAddPrivileges(
                         &ExistingPrivileges,
                         &MaxPrivileges,
                         Privileges,
                         RTL_SUPERSEDE_PRIVILEGE_ATTRIBUTES,
                         &Changed
                         );

            if ( NT_SUCCESS( Status ) && !Changed ) {

                //
                // Nothing has changed, so bail
                //

                goto ChangePrivilegesFinish;
            }

        } else {

            Status = LsapRtlRemovePrivileges(
                         ExistingPrivileges,
                         Privileges
                         );
        }
    }


    //
    // If privileges remain, write the updated privilege set back to
    // the LSA Database as the value of the Privilgs attribute of the
    // account object.  If no privileges remain, delete the Privilgs
    // attribute.
    //

    if (ExistingPrivileges && (ExistingPrivileges->PrivilegeCount > 0)) {

        Status = LsapDbWriteAttributeObject(
                     AccountHandle,
                     &LsapDbNames[Privilgs],
                     ExistingPrivileges,
                     sizeof (PRIVILEGE_SET) + (ExistingPrivileges->PrivilegeCount - 1)*sizeof(LUID_AND_ATTRIBUTES)
                     );

    } else {

        Status = LsapDbDeleteAttributeObject(
                     AccountHandle,
                     &LsapDbNames[Privilgs],
                     FALSE
                     );

        //
        // The only error permitted is STATUS_OBJECT_NAME_NOT_FOUND
        // because the account object does not have any privileges
        // assigned and so has no Privilgs attribute.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            Status = STATUS_SUCCESS;
        }
    }

    //
    // If auditing of policy changes is enabled, generate an audit.
    //

    AccountSid = LsapDbSidFromHandle( AccountHandle );

    if (LsapAdtAuditingPolicyChanges()) {

        AuditEventId = ((ChangeMode == AddPrivileges) ?
                           SE_AUDITID_USER_RIGHT_ASSIGNED :
                           SE_AUDITID_USER_RIGHT_REMOVED);

        //
        // Audit the privilege set change.  Ignore failures from Auditing.
        //

        IgnoreStatus = LsapAdtGenerateLsaAuditEvent(
                           AccountHandle,
                           SE_CATEGID_POLICY_CHANGE,
                           AuditEventId,
                           Privileges,
                           1,
                           (PSID *) &AccountSid,
                           0,
                           NULL,
                           NULL
                           );
    }

    //
    // Update the Account Object Cache while holding the Lsa Database Lock.
    // If the commit to backing storage below fails, caching will automatically
    // be turned off.
    //
    // NOTE: A pointer to the UpdatedPrivileges buffer will be placed directly
    // in the cached Account Object, so it should not be freed by this routine.
    //

    if (ExistingPrivileges && (ExistingPrivileges->PrivilegeCount > 0)) {

        IgnoreStatus = LsapDbUpdatePrivilegesAccount(
                           AccountSid,
                           ExistingPrivileges
                           );

        //
        // The cache takes ownership of the privileges structure, so we don't
        // want to free it.
        //

        ExistingPrivileges = NULL;

    } else {

        IgnoreStatus = LsapDbUpdatePrivilegesAccount(
                           AccountSid,
                           NULL
                           );
    }

ChangePrivilegesFinish:

    //
    // If necessary, free the ExistingPrivileges buffer.
    //

    if (ExistingPrivileges != NULL) {

        LsapFreeLsaHeap(ExistingPrivileges);
        ExistingPrivileges = NULL;
    }

    //
    // If necessary, dereference the Account object, close the database
    // transaction, release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        IgnoreStatus = LsapDbDereferenceObject(
                           &AccountHandle,
                           AccountObject,
                           AccountObject,
                           LSAP_DB_LOCK |
                           LSAP_DB_FINISH_TRANSACTION |
                              LSAP_DB_NO_DS_OP_TRANSACTION,
                           SecurityDbChange,
                           Status
                           );
    }

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbChange,
            SecurityDbObjectLsaAccount,
            InternalHandle->Sid
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    return Status;

ChangePrivilegesError:

    goto ChangePrivilegesFinish;
}


NTSTATUS
LsarGetQuotasForAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsarGetQuotasForAccount API.

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota and explicit value is returned.  This
    call requires LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS Status;
    PLSAPR_ACCOUNT_INFO AccountInformation = NULL;

    LsarpReturnCheckSetup();

    //
    // Stub it out
    //
    LsapDsDebugOut(( DEB_TRACE,
                     "LsarGetQuotasForAccount has been removed.  Returning STATUS_SUCCESS anyway\n" ));

    RtlZeroMemory( QuotaLimits, sizeof( QUOTA_LIMITS ) );
    return( STATUS_SUCCESS );



    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsarSetQuotasForAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetQuotasForAccount API.

    The LsaSetQuotasForAccount API sets the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota an explicit value or the system default
    may be specified.  This call requires LSA_ACCOUNT_ADJUST_QUOTAS
    access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be set.  This handle will have been returned from a prior
        LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure containing the system resource
        quota limits applicable to each session logged on to this account.
        A zero value specified in any field indicates that the current
        System Default Quota Limit is to be applied.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    NTSTATUS Status, IgnoreStatus;

    ULONG QuotaLimitsLength = sizeof (QUOTA_LIMITS);
    QUOTA_LIMITS UpdatedQuotaLimits;
    QUOTA_LIMITS DefaultQuotaLimits;
    ULONG DefaultQuotaLimitsLength = sizeof (QUOTA_LIMITS);
    BOOLEAN ObjectReferenced = FALSE;
    PLSAPR_SID AccountSid = NULL;

    LsarpReturnCheckSetup();

    //
    // Quotas have been disabled.
    //
    LsapDsDebugOut(( DEB_TRACE,
                     "LsarSetQuotasForAccount has been removed: Returning STATUS_SUCCESS anyway\n" ));

    return( STATUS_SUCCESS );
}


NTSTATUS
LsarGetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    The LsaGetSystemAccessAccount() service returns the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:
                             
    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS Status;
    PLSAPR_ACCOUNT_INFO AccountInformation = NULL;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarGetSystemAccessAccount\n" ));


    Status = LsarQueryInformationAccount(
                 AccountHandle,
                 AccountSystemAccessInformation,
                 &AccountInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto GetSystemAccessAccountError;
    }

    *SystemAccess = *((PULONG) AccountInformation);

GetSystemAccessAccountFinish:

    //
    // If necessary, free the buffer in which the Account Information was
    // returned.
    //

    if (AccountInformation != NULL) {

        MIDL_user_free( AccountInformation );
        AccountInformation = NULL;
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarGetSystemAccessAccount: 0x%lx\n", Status ));

    return(Status);

GetSystemAccessAccountError:

    *SystemAccess = 0;
    goto GetSystemAccessAccountFinish;
}


NTSTATUS
LsarSetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG SystemAccess
    )

/*++

Routine Description:

    The LsaSetSystemAccessAccount() service sets the System Access
    account flags for an Account object.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_ADJUST_SYSTEM_ACCESS access.

    SystemAccess - A mask of the system access flags to assign to the
        Account object.  The valid access flags include:

        POLICY_MODE_INTERACTIVE - Account can be accessed interactively

        POLICY_MODE_NETWORK - Account can be accessed remotely

        POLICY_MODE_SERVICE - TBS

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

        STATUS_INVALID_PARAMETER - The specified Access Flags are invalid.
--*/

{
    return LsapSetSystemAccessAccount( AccountHandle, SystemAccess, TRUE );
}



NTSTATUS
LsapSetSystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ULONG SystemAccess,
    IN BOOL LockSce
    )
/*++

Routine Description:

    This is the worker routine for LsarSetSystemAccessAccount, with an added
    semantics of not locking the SCE policy.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAPR_SID AccountSid = NULL;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )AccountHandle;
    BOOLEAN ScePolicyLocked = FALSE;
    BOOLEAN NotifySce = FALSE;
    PLSAPR_ACCOUNT_INFO pAccountInfo = NULL;
    LONG i;
    BOOLEAN bObtainedPreviousAccountInfo = TRUE;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSystemAccessAccount\n" ));


    //
    // Verify that the specified flags are valid
    //


    if (SystemAccess != (SystemAccess & (POLICY_MODE_ALL))) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetSystemAccessAccountError;
    }

    //
    // Do not grab the SCE policy lock for handles opened as SCE policy handles
    //

    if ( !InternalHandle->SceHandleChild ) {

        if ( LockSce ) {

            RtlEnterCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );
            if ( LsapDbState.ScePolicyLock.NumberOfWaitingShared > MAX_SCE_WAITING_SHARED ) {

                Status = STATUS_TOO_MANY_THREADS;
            }
            RtlLeaveCriticalSection( &LsapDbState.ScePolicyLock.CriticalSection );

            if ( !NT_SUCCESS( Status )) {

                goto SetSystemAccessAccountError;
            }

            WaitForSingleObject( LsapDbState.SceSyncEvent, INFINITE );
            RtlAcquireResourceShared( &LsapDbState.ScePolicyLock, TRUE );
            ASSERT( !g_ScePolicyLocked );
            ScePolicyLocked = TRUE;
        }

        NotifySce = TRUE;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle and open a database transaction.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_ADJUST_SYSTEM_ACCESS,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSystemAccessAccountError;
    }

    ObjectReferenced = TRUE;

    //
    // Record the previous access flags for auditing.
    //

    Status = LsapDbQueryInformationAccount(
                 AccountHandle,
                 AccountSystemAccessInformation,
                 &pAccountInfo
                 );

    if (!NT_SUCCESS(Status)) {

        bObtainedPreviousAccountInfo = FALSE;
    }
    
    //
    // Write the System Access flags
    //
    Status = LsapDbWriteAttributeObject(
                 AccountHandle,
                 &LsapDbNames[ActSysAc],
                 &SystemAccess,
                 sizeof (ULONG)
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetSystemAccessAccountError;
    }

    AccountSid = LsapDbSidFromHandle( AccountHandle );

    //
    // Update the Account Object Cache while holding the Lsa Database Lock.
    // If the commit to backing storage below fails, caching will automatically
    // be turned off.
    //

    IgnoreStatus = LsapDbUpdateSystemAccessAccount(
                       AccountSid,
                       &SystemAccess
                       );

    //
    // If auditing of policy changes is enabled, generate an audit.
    //

    if (bObtainedPreviousAccountInfo && LsapAdtAuditingPolicyChanges()) {

        //
        // Audit the system access change.  Ignore failures from Auditing.
        //

        NTSTATUS Status = STATUS_SUCCESS;
        LUID ClientAuthenticationId;
        PTOKEN_USER TokenUserInformation;
        PSID ClientSid;
        
        PWCHAR GrantedAccess[11]; 
        LONG GrantedAccessCount = 0;
        ULONG GrantedAccessMask = 0;
        
        PWCHAR RemovedAccess[11]; 
        LONG RemovedAccessCount = 0;
        ULONG RemovedAccessMask = 0;
        
        USHORT EventType = NT_SUCCESS( IgnoreStatus ) ? EVENTLOG_AUDIT_SUCCESS : EVENTLOG_AUDIT_FAILURE;

        //
        // Determine the rights that were enabled.
        //

        GrantedAccessMask = (pAccountInfo != NULL ) ? SystemAccess & (~pAccountInfo->AccountSystemAccessInfo) : SystemAccess;

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_INTERACTIVE_LOGON_NAME;
        } 
        
        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_NETWORK)) {
            GrantedAccess[GrantedAccessCount++] = SE_NETWORK_LOGON_NAME;
        }
        
        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_BATCH)) {
            GrantedAccess[GrantedAccessCount++] = SE_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_SERVICE)) {
            GrantedAccess[GrantedAccessCount++] = SE_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_REMOTE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_INTERACTIVE_LOGON_NAME;
        } 
        
        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_NETWORK)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_NETWORK_LOGON_NAME;
        }
        
        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_BATCH)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_SERVICE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_SERVICE_LOGON_NAME;
        }                

        if (FLAG_ON(GrantedAccessMask, POLICY_MODE_DENY_REMOTE_INTERACTIVE)) {
            GrantedAccess[GrantedAccessCount++] = SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        //
        // Determine the rights which were turned off.
        //

        RemovedAccessMask = (pAccountInfo != NULL) ? pAccountInfo->AccountSystemAccessInfo & (~SystemAccess) : SystemAccess;

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_INTERACTIVE_LOGON_NAME;
        } 
        
        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_NETWORK)) {
            RemovedAccess[RemovedAccessCount++] = SE_NETWORK_LOGON_NAME;
        }
        
        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_BATCH)) {
            RemovedAccess[RemovedAccessCount++] = SE_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_SERVICE)) {
            RemovedAccess[RemovedAccessCount++] = SE_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_REMOTE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_INTERACTIVE_LOGON_NAME;
        } 
        
        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_NETWORK)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_NETWORK_LOGON_NAME;
        }
        
        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_BATCH)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_BATCH_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_SERVICE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_SERVICE_LOGON_NAME;
        }

        if (FLAG_ON(RemovedAccessMask, POLICY_MODE_DENY_REMOTE_INTERACTIVE)) {
            RemovedAccess[RemovedAccessCount++] = SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME;
        }

        Status = LsapQueryClientInfo(
                     &TokenUserInformation,
                     &ClientAuthenticationId
                     );

        if ( NT_SUCCESS( Status )) {

            //
            // We can't generate an audit without a
            // user Sid.
            //

            ClientSid = TokenUserInformation->User.Sid;

            //
            // Audit any granted system access rights
            //
            
            for (i = 0; i < GrantedAccessCount; i++) {
                LsapAdtGenerateLsaAuditSystemAccessChange(
                             SE_CATEGID_POLICY_CHANGE,
                             SE_AUDITID_SYSTEM_ACCESS_GRANTED,
                             EventType,
                             ClientSid,
                             ClientAuthenticationId,
                             AccountSid,
                             GrantedAccess[i]
                             );
            }

            //
            // Audit any removed system access rights
            //
            
            for (i = 0; i < RemovedAccessCount; i++) {
                LsapAdtGenerateLsaAuditSystemAccessChange(
                             SE_CATEGID_POLICY_CHANGE,
                             SE_AUDITID_SYSTEM_ACCESS_REMOVED,
                             EventType,
                             ClientSid,
                             ClientAuthenticationId,
                             AccountSid,
                             RemovedAccess[i]
                             );
            }
            
            LsapFreeLsaHeap( TokenUserInformation );
        }
    }

SetSystemAccessAccountFinish:

    if (NULL != pAccountInfo) {
        LsaFreeMemory(pAccountInfo);
    }

    //
    // If necessary, dereference the Account object, close the database
    // transaction, notify the LSA Database Replicator of the change,
    // release the LSA Database lock and return.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &AccountHandle,
                     AccountObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION | LSAP_DB_NO_DS_OP_TRANSACTION,
                     SecurityDbChange,
                     Status
                     );
    }

    //
    // Notify SCE of the change.  Only notify for callers
    // that did not open their policy handles with LsaOpenPolicySce.
    //

    if ( NotifySce && NT_SUCCESS( Status )) {

        LsapSceNotify(
            SecurityDbChange,
            SecurityDbObjectLsaAccount,
            AccountSid
            );
    }

    if ( ScePolicyLocked ) {

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarSetSystemAccessAccount: 0x%lx\n", Status ));

    return(Status);

SetSystemAccessAccountError:

    goto SetSystemAccessAccountFinish;
}


NTSTATUS
LsarQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  Currently,
    LsarGet...Account() API call this routine.  In the future, this
    routine may be added as an API.

    The LsaQueryInformationAccount API obtains information from the Policy
    object.  The caller must have access appropriate to the information
    being requested (see InformationClass parameter).

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    AccountInformation - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    PLSAPR_ACCOUNT_INFO CachedAccountInformation = NULL;

    LsarpReturnCheckSetup();
    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryInformationAccount\n" ));


    //
    // Acquire the Lsa Database lock.  Verify that the Account Object handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 AccountHandle,
                 ACCOUNT_VIEW,
                 AccountObject,
                 AccountObject,
                 LSAP_DB_LOCK |
                    LSAP_DB_NO_DS_OP_TRANSACTION |
                    LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (NT_SUCCESS(Status)) {


        if (LsapDbIsCacheValid(AccountObject)) {

            Status = LsapDbQueryInformationAccount(
                         AccountHandle,
                         InformationClass,
                         AccountInformation
                         );

        } else {

            Status = LsapDbSlowQueryInformationAccount(
                         AccountHandle,
                         InformationClass,
                         AccountInformation
                         );
        }

        Status = LsapDbDereferenceObject(
                     &AccountHandle,
                     AccountObject,
                     AccountObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_NO_DS_OP_TRANSACTION |
                        LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsarpReturnPrologue();

    LsapDsDebugOut(( DEB_FTRACE, "LsarQueryInformationAccount: 0x%lx\n", Status ));

    return(Status);

}


NTSTATUS
LsapDbQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *AccountInformation
    )

/*++

Routine Description:

    This function is the fast LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  It is called
    when the in-memory Account List is valid.

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    AccountInformation - Receives a pointer to the buffer returned containing
        the requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    ULONG AccountInformationLength = 0;
    PLSAPR_ACCOUNT_INFO CachedAccountInformation = NULL;
    ULONG PrivilegesCount;
    PLSAPR_PRIVILEGE_SET OutputPrivilegeSet = NULL;


    (*AccountInformation) = NULL;

    //
    // Lookup the Account.
    //

    Status = LsapDbLookupAccount(
                 LsapDbSidFromHandle( AccountHandle ),
                 &Account
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

    //
    // Branch on Information Class.
    //

    switch (InformationClass) {

    case AccountPrivilegeInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        PrivilegesCount = 0;

        if (Account->Info.PrivilegeSet != NULL) {

            PrivilegesCount = Account->Info.PrivilegeSet->PrivilegeCount;
        }

        AccountInformationLength = sizeof(PRIVILEGE_SET) +
            (PrivilegesCount * sizeof(LUID_AND_ATTRIBUTES)) -
            (sizeof(LUID_AND_ATTRIBUTES));

        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) Account->Info.PrivilegeSet;
        break;

    case AccountQuotaInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        AccountInformationLength = sizeof(QUOTA_LIMITS);
        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) &Account->Info.QuotaLimits;
        break;

    case AccountSystemAccessInformation:

        //
        // Calculate size of buffer needed for the output privilege set.
        //

        AccountInformationLength = sizeof(ULONG);
        CachedAccountInformation = (PLSAPR_ACCOUNT_INFO) &Account->Info.SystemAccess;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

    //
    // Allocate output buffer.
    //

    *AccountInformation = MIDL_user_allocate( AccountInformationLength );

    Status = STATUS_NO_MEMORY;

    if (*AccountInformation == NULL) {

        goto QueryInformationAccountError;
    }

    Status = STATUS_SUCCESS;

    //
    // Copy the data requested if the cached information is non-NULL.
    //

    if (CachedAccountInformation != NULL) {

        RtlCopyMemory(
            *AccountInformation,
            CachedAccountInformation,
            AccountInformationLength
            );

        goto QueryInformationAccountFinish;
    }

    //
    // The cached information is NULL.  The only information class for which
    // this can happen is AccountPrivilegeInformation, since this is the
    // only class for which a pointer is kept rather than in-structure data.
    //

    if (InformationClass == AccountPrivilegeInformation) {

        OutputPrivilegeSet = (PLSAPR_PRIVILEGE_SET) *AccountInformation;
        OutputPrivilegeSet->PrivilegeCount = 0;
        OutputPrivilegeSet->Control = 0;

    } else {

        Status = STATUS_INTERNAL_DB_CORRUPTION;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInformationAccountError;
    }

QueryInformationAccountFinish:

    return(Status);

QueryInformationAccountError:

    if (*AccountInformation) {
        MIDL_user_free(*AccountInformation);
    }
    (*AccountInformation) = NULL;
    goto QueryInformationAccountFinish;
}


NTSTATUS
LsapDbSlowQueryInformationAccount(
    IN LSAPR_HANDLE AccountHandle,
    IN ACCOUNT_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_ACCOUNT_INFO *Buffer
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    (as yet non-existent) LsarQueryInformationAccount API.  It is called
    when the in-memory Account List is valid.

Arguments:

    AccountHandle - Handle from an LsaOpenAccount call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        AccountPrivilegeInformation       ACCOUNT_VIEW
        AccountQuotaInformation           ACCOUNT_VIEW
        AccountSystemAccessInformation    ACCOUNT_VIEW

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INTERNAL_DB_CORRUPTION - The Policy Database is possibly
            corrupt.  The returned Policy Information is invalid for
            the given class.
--*/

{
    NTSTATUS Status;
    QUOTA_LIMITS QuotaLimits;
    ULONG SystemAccess;
    PLSAPR_ACCOUNT_INFO OutputBuffer = NULL;

    //
    // Branch on Information Class.
    //

    switch (InformationClass) {

    case AccountPrivilegeInformation:

        Status = LsapDbSlowQueryPrivilegesAccount(
                     AccountHandle,
                     (PLSAPR_PRIVILEGE_SET *) &OutputBuffer
                     );
        break;

    case AccountQuotaInformation:

        Status = LsapDbSlowQueryQuotasAccount(
                     AccountHandle,
                     &QuotaLimits
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        OutputBuffer = MIDL_user_allocate( sizeof(QUOTA_LIMITS));

        Status = STATUS_NO_MEMORY;

        if (OutputBuffer == NULL) {

            break;
        }

        *((PQUOTA_LIMITS) OutputBuffer) = QuotaLimits;
        Status = STATUS_SUCCESS;
        break;

    case AccountSystemAccessInformation:

        Status = LsapDbSlowQuerySystemAccessAccount(
                     AccountHandle,
                     &SystemAccess
                     );

        if (!NT_SUCCESS(Status)) {

            break;
        }

        OutputBuffer = MIDL_user_allocate( sizeof(ULONG));

        Status = STATUS_NO_MEMORY;

        if (OutputBuffer == NULL) {

            break;
        }

        *((PULONG) OutputBuffer) = SystemAccess;
        Status = STATUS_SUCCESS;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryInformationAccountError;
    }

    *Buffer = OutputBuffer;

SlowQueryInformationAccountFinish:

    return(Status);

SlowQueryInformationAccountError:

    *Buffer = NULL;
    goto SlowQueryInformationAccountFinish;
}


NTSTATUS
LsapDbQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    )

/*++

Routine Description:

    This routine:

        1) Gets all privileges assigned to the user (or any group/alias
           the user is a member of).

        2) Establishes the quotas assigned to the user.  This is the
           maximum of the system default quotas or any quotas assigned
           to the user (or any group/alias the user is a member of).

        3) Gets all the System Accesses assigned to the user.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must
        have POLICY_VIEW_LOCAL_INFORMATION access granted.

    IdCount - Indicates the number of IDs being provided in the Ids array.

    Ids - Points to an array of SIDs.

    AccountInfo - Pointer to buffer that will receive the Account information
        comprising its Privilege Set, System Access Flags and Quotas.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
        has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status;
    BOOLEAN ObjectReferenced = FALSE;
    PPRIVILEGE_SET RunningPrivileges = NULL;
    ULONG          MaxRunningPrivileges = 0;

    PPRIVILEGE_SET NextPrivileges = NULL;
    ULONG RunningSystemAccess;
    QUOTA_LIMITS NextQuotaLimits;
    QUOTA_LIMITS RunningQuotaLimits;
    PQUOTA_LIMITS PolicyDefaultQuotaLimits = NULL;
    PPOLICY_DEFAULT_QUOTA_INFO PolicyDefaultQuotaInfo = NULL;
    ULONG SidIndex;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // If we are unable to use the Account List, use the slow method
    // for querying Privileges and Quotas
    //

    if (!LsapDbIsCacheValid(AccountObject)) {

        return(LsapDbSlowQueryAllInformationAccounts(
                   PolicyHandle,
                   IdCount,
                   Ids,
                   AccountInfo
                   ));
    }

    //
    // The Account List is valid.  We'll use it instead of opening individual
    // Account objects.  Verify that the Policy Handle is valid, is the handle
    // object and has the necessary access granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    ObjectReferenced = TRUE;

    //
    // Obtain the Master Default Quota Limits from the Policy Object.  If
    // the Policy Object is cached (partially for now) instruct the query
    // routine to just copy the data.

    PolicyDefaultQuotaLimits = &RunningQuotaLimits;

    Status = LsapDbQueryInformationPolicy(
                 PolicyHandle,
                 PolicyDefaultQuotaInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyDefaultQuotaLimits
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    //
    // Iterate through all of the Sids provided.  For each one, check if the
    // Sid is that of an Account object in the local LSA.  If it is,
    //
    // (1)  Obtain the System Accesses and add those found so far.
    // (2)  Obtain the Account Privileges and add to those found so far.
    // (3)  Obtain the Quota Limits (if any) assigned to the account.
    //      Compare these with the quota limits obtained so far.  If any
    //      limits are more generous than the running values, update
    //      the running values.
    //

    RunningSystemAccess = 0;

    for( SidIndex = 0; SidIndex < IdCount; SidIndex++) {

        //
        // Locate the Account information block for this Sid.
        //

        Status = LsapDbLookupAccount( Ids[SidIndex].Sid, &Account );

        if (!NT_SUCCESS(Status)) {

            if (Status == STATUS_NO_SUCH_USER) {

                Status = STATUS_SUCCESS;
                continue;
            }

            break;
        }

        //
        // We have found the Account information.  Add in the System Accesses
        // for this account.
        //

        RunningSystemAccess |= Account->Info.SystemAccess;

        //
        // Obtain the account's Special privileges.
        //

        NextPrivileges = Account->Info.PrivilegeSet;

        //
        // Add the Privileges of this account (if any) to the running set.
        //

        if (NextPrivileges != NULL) {

            Status = LsapRtlAddPrivileges(
                         &RunningPrivileges,
                         &MaxRunningPrivileges,
                         NextPrivileges,
                         RTL_COMBINE_PRIVILEGE_ATTRIBUTES,
                         NULL // don't care if the set has changed or not
                         );

            if (!NT_SUCCESS(Status)) {

                goto QueryAllInformationAccountsError;
            }
        }

        //
        // Obtain the special Quota Limits for this account (if any).
        //

        RtlMoveMemory(&NextQuotaLimits, &Account->Info.QuotaLimits, sizeof(QUOTA_LIMITS));

        //
        // Special Quota Limits are assigned.  Compare each of the quota
        // limits obtained with the running values.  If a quota limit just
        // obtained is less restrictive than the running value, supersede the
        // running value.
        //

        if (RunningQuotaLimits.PagedPoolLimit < NextQuotaLimits.PagedPoolLimit) {

            RunningQuotaLimits.PagedPoolLimit = NextQuotaLimits.PagedPoolLimit;
        }

        if (RunningQuotaLimits.NonPagedPoolLimit < NextQuotaLimits.NonPagedPoolLimit) {

            RunningQuotaLimits.NonPagedPoolLimit = NextQuotaLimits.NonPagedPoolLimit;
        }

        if (RunningQuotaLimits.MinimumWorkingSetSize > NextQuotaLimits.MinimumWorkingSetSize) {

            RunningQuotaLimits.MinimumWorkingSetSize = NextQuotaLimits.MinimumWorkingSetSize;
        }

        if (RunningQuotaLimits.MaximumWorkingSetSize < NextQuotaLimits.MaximumWorkingSetSize) {

            RunningQuotaLimits.MaximumWorkingSetSize = NextQuotaLimits.MaximumWorkingSetSize;
        }

        if (RunningQuotaLimits.PagefileLimit < NextQuotaLimits.PagefileLimit) {

            RunningQuotaLimits.PagefileLimit = NextQuotaLimits.PagefileLimit;
        }

        if (RunningQuotaLimits.TimeLimit.QuadPart < NextQuotaLimits.TimeLimit.QuadPart) {

            RunningQuotaLimits.TimeLimit = NextQuotaLimits.TimeLimit;
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryAllInformationAccountsError;
    }

    //
    // Return the collective Privilege Set
    //

    AccountInfo->PrivilegeSet = RunningPrivileges;

    //
    // Return the collective System Accesses

    AccountInfo->SystemAccess = RunningSystemAccess;

    //
    // Return the collective Quota Limits
    //

    AccountInfo->QuotaLimits = RunningQuotaLimits;

QueryAllInformationAccountsFinish:

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_NO_DS_OP_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

QueryAllInformationAccountsError:

    //
    // If necessary, free the memory allocated for the Privilege Set.
    //

    if (RunningPrivileges != NULL) {

        MIDL_user_free( RunningPrivileges );
        RunningPrivileges = NULL;
    }



    //
    // Return null values
    //

    RtlZeroMemory( &AccountInfo->QuotaLimits, sizeof(QUOTA_LIMITS) );
    AccountInfo->SystemAccess = 0;
    AccountInfo->PrivilegeSet = NULL;
    goto QueryAllInformationAccountsFinish;
}


NTSTATUS
LsapDbSlowQueryAllInformationAccounts(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG IdCount,
    IN PSID_AND_ATTRIBUTES Ids,
    OUT PLSAP_DB_ACCOUNT_TYPE_SPECIFIC_INFO AccountInfo
    )

/*++

Routine Description:

    This routine is the slow version of LsapDbQueryInformation().
    It is called when the Account List is not available, and assembles the
    necessary information from the Policy Database.

    This routine:

        1) Gets all privileges assigned to the user (or any group/alias
           the user is a member of).

        2) Establishes the quotas assigned to the user.  This is the
           maximum of the system default quotas or any quotas assigned
           to the user (or any group/alias the user is a member of).

        3) Gets all the System Accesses assigned to the user.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.  The handle must
        have POLICY_VIEW_LOCAL_INFORMATION access granted.

    IdCount - Indicates the number of IDs being provided in the Ids array.

    Ids - Points to an array of SIDs.

    AccountInfo - Pointer to buffer that will receive the Account information
        comprising its Privilege Set, System Access Flags and Quotas.

Return Value:

    STATUS_SUCCESS - Succeeded.

    STATUS_LOGON_TYPE_NOT_GRANTED - Indicates the specified type of logon
        has not been granted to any of the IDs in the passed set.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS LocalStatus;
    BOOLEAN ObjectReferenced = FALSE;
    PPRIVILEGE_SET RunningPrivileges = NULL;
    ULONG          MaxRunningPrivileges = 0;
    PPRIVILEGE_SET NextPrivileges = NULL;

    ULONG RunningSystemAccess;
    QUOTA_LIMITS NextQuotaLimits;
    QUOTA_LIMITS RunningQuotaLimits;
    PQUOTA_LIMITS PointerToNextQuotaLimits = NULL;
    PQUOTA_LIMITS PolicyDefaultQuotaLimits = NULL;
    ULONG SidIndex;
    LSAPR_HANDLE AccountHandle = NULL;
    PULONG SystemAccessThisId = NULL;

    //
    // Verify that the Policy Handle is valid, is the handle to the Policy
    // object and has the necessary access granted.  Reference the handle.
    // Note that the Lsa Database lock is NOT held at this point.  Instead,
    // the lock is taken and released by called routines where required.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 AccountObject,
                 LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION |
                    LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION
                 );

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    ObjectReferenced = TRUE;

    PolicyDefaultQuotaLimits = &RunningQuotaLimits;

    //
    // Obtain the Master Default Quota Limits from the Policy Object.
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDefaultQuotaInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyDefaultQuotaLimits
                 );

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    //
    // Iterate through all of the Sids provided.  For each one, check if the
    // Sid is that of an Account object in the local LSA.  If it is,
    //
    // (1)  Obtain the System Accesses and add those found so far.
    // (2)  Obtain the Account Privileges and add to thosde found so far.
    // (3)  Obtain the Quota Limits (if any) assigned to the account.
    //      Compare these with the quota limits obtained so far.  If any
    //      limits are more generous than the running values, update
    //      the running values.
    //

    RunningSystemAccess = 0;

    for( SidIndex = 0; SidIndex < IdCount; SidIndex++) {

        //
        // Attempt to open an Lsa Account object specifying the next Sid.
        // If successful, the open returns a Trusted handle to the account.
        //

        Status = LsarOpenAccount(
                     PolicyHandle,
                     Ids[SidIndex].Sid,
                     ACCOUNT_VIEW,
                     (LSAPR_HANDLE *) &AccountHandle
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                break;
            }

            Status = STATUS_SUCCESS;
            continue;
        }

        //
        // An account object has been successfully opened.  Obtain
        // its system accesses.
        //

        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountSystemAccessInformation,
                     (PLSAPR_ACCOUNT_INFO *) &SystemAccessThisId
                     );

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        RunningSystemAccess |= *SystemAccessThisId;
        MIDL_user_free(SystemAccessThisId);
        SystemAccessThisId = NULL;

        //
        // Obtain the account's Special privileges.
        //

        ASSERT( NextPrivileges == NULL );
        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountPrivilegeInformation,
                     (PLSAPR_ACCOUNT_INFO *) &NextPrivileges
                     );

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        //
        // Add the Privileges of this account (if any) to the running set.
        //

        if (NextPrivileges != NULL) {

            Status = LsapRtlAddPrivileges(
                         &RunningPrivileges,
                         &MaxRunningPrivileges,
                         NextPrivileges,
                         RTL_COMBINE_PRIVILEGE_ATTRIBUTES,
                         NULL // don't care if the set has changed or not
                         );

            MIDL_user_free(NextPrivileges);
            NextPrivileges = NULL;

            if (!NT_SUCCESS(Status))  {

                goto SlowQueryAllInformationAccountsError;
            }
        }

        //
        // Obtain the special Quota Limits for this account (if any).
        //

        Status = LsapDbSlowQueryInformationAccount(
                     AccountHandle,
                     AccountQuotaInformation,
                     (PLSAPR_ACCOUNT_INFO *) &PointerToNextQuotaLimits
                     );

        if (Status == STATUS_NO_QUOTAS_FOR_ACCOUNT) {

            LocalStatus = LsapCloseHandle( &AccountHandle, STATUS_SUCCESS );
            continue;
        }

        if (!NT_SUCCESS(Status)) {

            goto SlowQueryAllInformationAccountsError;
        }

        NextQuotaLimits = *PointerToNextQuotaLimits;
        MIDL_user_free(PointerToNextQuotaLimits);
        PointerToNextQuotaLimits = NULL;

        //
        // Special Quota Limits are assigned.  Compare each of the quota
        // limits obtained with the running values.  If a quota limit just
        // obtained is less restrictive than the running value, supersede the
        // running value.
        //

        if (RunningQuotaLimits.PagedPoolLimit < NextQuotaLimits.PagedPoolLimit) {

            RunningQuotaLimits.PagedPoolLimit = NextQuotaLimits.PagedPoolLimit;
        }

        if (RunningQuotaLimits.NonPagedPoolLimit < NextQuotaLimits.NonPagedPoolLimit) {

            RunningQuotaLimits.NonPagedPoolLimit = NextQuotaLimits.NonPagedPoolLimit;
        }

        if (RunningQuotaLimits.MinimumWorkingSetSize > NextQuotaLimits.MinimumWorkingSetSize) {

            RunningQuotaLimits.MinimumWorkingSetSize = NextQuotaLimits.MinimumWorkingSetSize;
        }

        if (RunningQuotaLimits.MaximumWorkingSetSize < NextQuotaLimits.MaximumWorkingSetSize) {

            RunningQuotaLimits.MaximumWorkingSetSize = NextQuotaLimits.MaximumWorkingSetSize;
        }

        if (RunningQuotaLimits.PagefileLimit < NextQuotaLimits.PagefileLimit) {

            RunningQuotaLimits.PagefileLimit = NextQuotaLimits.PagefileLimit;
        }

        if (RunningQuotaLimits.TimeLimit.QuadPart < NextQuotaLimits.TimeLimit.QuadPart) {

            RunningQuotaLimits.TimeLimit = NextQuotaLimits.TimeLimit;
        }

        //
        // Close the account handle
        //

        LocalStatus = LsapCloseHandle( &AccountHandle, STATUS_SUCCESS );
    }

    if (!NT_SUCCESS(Status)) {

        goto SlowQueryAllInformationAccountsError;
    }

    //
    // Return the collective Privilege Set
    //

    AccountInfo->PrivilegeSet = RunningPrivileges;

    //
    // Return the collective System Accesses

    AccountInfo->SystemAccess = RunningSystemAccess;

    //
    // Return the collective Quota Limits
    //

    AccountInfo->QuotaLimits = RunningQuotaLimits;

SlowQueryAllInformationAccountsFinish:

    if ( NextPrivileges != NULL ) {
        MIDL_user_free( NextPrivileges );
    }

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     AccountObject,
                     LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_NO_DS_OP_TRANSACTION | LSAP_DB_READ_ONLY_TRANSACTION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

SlowQueryAllInformationAccountsError:

    //
    // If necessary, free the memory allocated for the Privilege Set.
    //

    if (RunningPrivileges != NULL) {

        MIDL_user_free( RunningPrivileges );
        RunningPrivileges = NULL;
    }

    //
    // Close an account handle, if one is open
    //

    if (AccountHandle != NULL) {

        LocalStatus = LsapCloseHandle( &AccountHandle, Status );
    }

    //
    // Return null values
    //

    RtlZeroMemory( &AccountInfo->QuotaLimits, sizeof(QUOTA_LIMITS) );
    AccountInfo->SystemAccess = 0;
    AccountInfo->PrivilegeSet = NULL;
    goto SlowQueryAllInformationAccountsFinish;
}



NTSTATUS
LsapDbSlowQueryPrivilegesAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PLSAPR_PRIVILEGE_SET *Privileges
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsaEnumeratePrivilegesOfAccount API.

    The LsaEnumeratePrivilegesOfAccount API obtains information which
    describes the privileges assigned to an account.  This call requires
    ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose privilege
        information is to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    Privileges - Receives a pointer to a buffer containing the Privilege
        Set.  The Privilege Set is an array of structures, one for each
        privilege.  Each structure contains the LUID of the privilege and
        a mask of the privilege's attributes.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status;
    PPRIVILEGE_SET PrivilegeSet = NULL;
    ULONG PrivilegeSetLength;
    BOOLEAN ObjectReferenced = FALSE;
    LSAP_DB_ATTRIBUTE Attribute;
    PPRIVILEGE_SET DsPrivs;

    UCHAR FastBuffer[ 256 ];

    //
    // Attempt query of attribute using fast stack buffer.
    //

    PrivilegeSetLength = sizeof(FastBuffer);

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[Privilgs],
                 FastBuffer,
                 &PrivilegeSetLength
                 );

    if(NT_SUCCESS(Status)) {
        if( PrivilegeSetLength <= (sizeof(PRIVILEGE_SET) - sizeof (LUID_AND_ATTRIBUTES)) )
        {
            //
            // The privilege set attribute exists but has zero entries.
            // fall-through and handle it same way as non-existent entry.
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        } else {

            //
            // Success!  copy the fast buffer for the caller.
            //

            PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

            if (PrivilegeSet == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SlowQueryPrivilegesError;
            }

            RtlCopyMemory( PrivilegeSet, FastBuffer, PrivilegeSetLength );
            *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;
            goto SlowQueryPrivilegesFinish;

        }
    }

    if ((Status == STATUS_OBJECT_NAME_NOT_FOUND)) {

        //
        // If the Privileg attribute does not exist, convert the status
        // back to STATUS_SUCCESS.  Note that an account object need not
        // have any privileges assigned so STATUS_OBJECT_NAME_NOT_FOUND is
        // not an error in this case.  Return a Privilege Set containing
        // a zero Count.
        //

        PrivilegeSetLength = sizeof(PRIVILEGE_SET) - sizeof(LUID_AND_ATTRIBUTES);

        PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

        if (PrivilegeSet == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SlowQueryPrivilegesError;
        }

        Status = STATUS_SUCCESS;

        PrivilegeSet->Control = (ULONG) 0L;
        PrivilegeSet->PrivilegeCount = (ULONG) 0L;
        *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;
        goto SlowQueryPrivilegesFinish;

    }

    //
    // The Privileg attribute exists and has a value assigned.  Allocate
    // a buffer for its value.
    //

    PrivilegeSet = MIDL_user_allocate ( PrivilegeSetLength );

    if (PrivilegeSet == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SlowQueryPrivilegesError;
    }

    //
    // Read the Privilgs attribute into the buffer.  Note that although
    // the value of this attribute has a variable length, it is bounded
    // above.
    //

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[Privilgs],
                 PrivilegeSet,
                 &PrivilegeSetLength
                 );

    if (!NT_SUCCESS(Status)) {

        MIDL_user_free(PrivilegeSet);
        goto SlowQueryPrivilegesError;
    }

    //
    // Return the Privilege Set or NULL
    //

    *Privileges = (PLSAPR_PRIVILEGE_SET) PrivilegeSet;

SlowQueryPrivilegesFinish:

    return( Status );

SlowQueryPrivilegesError:

    *Privileges = NULL;
    goto SlowQueryPrivilegesFinish;
}

NTSTATUS
LsapDbSlowQueryQuotasAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function is the slow LSA server RPC worker routine for the
    LsarGetQuotasForAccount API.

    The LsaGetQuotasForAccount API obtains the quota limits for pageable and
    non-pageable memory (in Kilobytes) and the maximum execution time (in
    seconds) for any session logged on to the account specified by
    AccountHandle.  For each quota and explicit value is returned.  This
    call requires LSA_ACCOUNT_VIEW access to the account object.

Arguments:

    AccountHandle - The handle to the open account object whose quotas
        are to be obtained.  This handle will have been returned
        from a prior LsaOpenAccount or LsaCreateAccountInLsa API call.

    QuotaLimits - Pointer to structure in which the system resource
        quota limits applicable to each session logged on to this account
        will be returned.  Note that all quotas, including those specified
        as being the system default values, are returned as actual values.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - The specified AccountHandle is not valid.
--*/

{
    //
    // Quotas are defunct.
    //

    QuotaLimits->PagedPoolLimit = 0;
    QuotaLimits->NonPagedPoolLimit = 0;
    QuotaLimits->MinimumWorkingSetSize = 0;
    QuotaLimits->MaximumWorkingSetSize = 0;

    return( STATUS_NO_QUOTAS_FOR_ACCOUNT );

}


NTSTATUS
LsapDbSlowQuerySystemAccessAccount(
    IN LSAPR_HANDLE AccountHandle,
    OUT PULONG SystemAccess
    )

/*++

Routine Description:

    This function is the Slow worker for the LsaGetSystemAccessAccount()
    API.

Arguments:

    AccountHandle - The handle to the Account object whose system access
        flags are to be read.  This handle will have been returned
        from a preceding LsaOpenAccount() or LsaCreateAccount() call
        an must be open for ACCOUNT_VIEW access.

    SystemAccess - Points to location that will receive the system access
        flags for the account.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful.

        STATUS_ACCESS_DENIED - The AccountHandle does not specify
            ACCOUNT_VIEW access.

        STATUS_INVALID_HANDLE - The specified AccountHandle is invalid.

--*/

{
    NTSTATUS Status;
    ULONG ReturnedSystemAccess;
    ULONG ReturnedSystemAccessLength;

    //
    // Read the Account Object's System Access Flags
    //

    ReturnedSystemAccessLength = sizeof(ULONG);

    Status = LsapDbReadAttributeObject(
                 AccountHandle,
                 &LsapDbNames[ActSysAc],
                 &ReturnedSystemAccess,
                 &ReturnedSystemAccessLength
                 );


    if (!NT_SUCCESS(Status)) {

        //
        // If there is no System Access attribute, return the system default
        // access.
        //
        // NOTE: The Master Default for the System Access attribute is
        //       currently hardwired.
        //

        if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

            goto SlowQuerySystemAccessAccountError;
        }

        ReturnedSystemAccess = LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS;
        Status = STATUS_SUCCESS;

    } else {

        //
        // Verify that the returned flags are valid
        //

        if (ReturnedSystemAccess != (ReturnedSystemAccess & POLICY_MODE_ALL)) {

            if ( ReturnedSystemAccess == 0 && LsapDsWriteDs ) {

                ReturnedSystemAccess = LSAP_DB_ACCOUNT_DEFAULT_SYS_ACCESS;
                Status = STATUS_SUCCESS;
            } else {

                Status = STATUS_INTERNAL_DB_CORRUPTION;
                goto SlowQuerySystemAccessAccountError;

            }

        }
    }

    *SystemAccess = ReturnedSystemAccess;

SlowQuerySystemAccessAccountFinish:

    return(Status);

SlowQuerySystemAccessAccountError:

    *SystemAccess = 0;
    goto SlowQuerySystemAccessAccountFinish;
}


NTSTATUS
LsapDbLookupAccount(
    IN PSID AccountSid,
    OUT PLSAP_DB_ACCOUNT *Account
    )

/*++

Routine Description:

    This function looks up the Account information for a given Lsa Account.

Arguments:

    AccountSid - Sid of the account

    Account - Receives a pointer to the Account information.

--*/

{
    PLSAP_DB_ACCOUNT NextAccount = NULL;
    ULONG AccountIndex;
    BOOLEAN AccountFound = FALSE;

    //
    // Scan the list of Accounts.
    //

    for (AccountIndex = 0, NextAccount = LsapDbFirstAccount();
         AccountIndex < LsapDbAccountList.AccountCount;
         AccountIndex++, NextAccount = LsapDbNextAccount( NextAccount)
         ) {

        //
        // If the Sids match, we've found the account.
        //

        if (RtlEqualSid( AccountSid, NextAccount->Sid )) {

            *Account = NextAccount;
            AccountFound = TRUE;
            break;
        }
    }

    if (AccountFound) {

        return(STATUS_SUCCESS);
    }

    return(STATUS_NO_SUCH_USER);
}


NTSTATUS
LsapDbCreateAccount(
    IN PLSAPR_SID AccountSid,
    OUT OPTIONAL PLSAP_DB_ACCOUNT *Account
    )

/*++

Routine Description:

    This function creates an Account's information block

Arguments:

    AccountSid - Specifies the Sid of the Account

    Account - Optionally receives a pointer to the newly created Account
        information block.

--*/

{
    NTSTATUS Status;
    PLSAPR_SID CopiedSid = NULL;
    PLSAP_DB_ACCOUNT OutputAccount = NULL;

    //
    // Verify that the Account List is valid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if ((!LsapDbIsCacheValid(AccountObject)) && LsapInitialized ) {

        goto CreateAccountError;
    }

    //
    // Make a copy of the Sid.
    //

    Status = LsapRpcCopySid(
                 NULL,
                 (PSID *) &CopiedSid,
                 (PSID) AccountSid
                 );

    if (!NT_SUCCESS(Status)) {

        goto CreateAccountError;
    }

    //
    // Allocate memory for the Account information block.
    //

    OutputAccount = MIDL_user_allocate( sizeof(LSAP_DB_ACCOUNT) );

    Status = STATUS_NO_MEMORY;

    if (OutputAccount == NULL) {

        goto CreateAccountError;
    }

    //
    // Zeroise the new block.
    //

    RtlZeroMemory( OutputAccount, sizeof(LSAP_DB_ACCOUNT) );

    //
    // Copy in the Sid.
    //

    OutputAccount->Sid = CopiedSid;

    //
    // Link the Account to the head of the Account List.
    //

    InsertHeadList( &LsapDbAccountList.Links, &OutputAccount->Links );

    //
    // If requested, return a pointer to the Account.
    //

    if (Account != NULL) {

        *Account = OutputAccount;
    }

    LsapDbAccountList.AccountCount++;

    Status = STATUS_SUCCESS;

CreateAccountFinish:

    return(Status);

CreateAccountError:

    //
    // If necessary, free the copied Sid.
    //

    if (CopiedSid != NULL) {

        MIDL_user_free( CopiedSid );
        CopiedSid = NULL;
    }

    //
    // If necessary, free the memory allocated for the Account block.
    //

    if (OutputAccount != NULL) {

        MIDL_user_free( OutputAccount);
        OutputAccount = NULL;
    }

    //
    // If a return pointer was specified, return NULL.
    //

    if (Account != NULL) {

        *Account = NULL;
    }

    goto CreateAccountFinish;
}


NTSTATUS
LsapDbDeleteAccount(
    IN PLSAPR_SID AccountSid
    )

/*++

Routine Description:

    This function deletes an Account's information block

Arguments:

    AccountSid - Specifies the Sid of the Account

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!LsapDbIsCacheValid(AccountObject)) {

        goto DeleteAccountError;
    }

    //
    // Lookup the Account Information Block to be deleted
    //

    Status = LsapDbLookupAccount( AccountSid, &Account);

    if (!NT_SUCCESS(Status)) {

        goto DeleteAccountError;
    }

    //
    // We found the account.  Unlink it from the Account List
    //

    RemoveEntryList( &Account->Links );

    //
    // Now free the Account Information
    //

    if (Account->Sid != NULL) {

        MIDL_user_free( Account->Sid);
        Account->Sid = NULL;
    }

    if (Account->Info.PrivilegeSet != NULL) {

        MIDL_user_free( Account->Info.PrivilegeSet );
        Account->Info.PrivilegeSet = NULL;
    }

    MIDL_user_free( Account );

    LsapDbAccountList.AccountCount--;

DeleteAccountFinish:

    return(Status);

DeleteAccountError:

    goto DeleteAccountFinish;
}


NTSTATUS
LsapDbUpdateSystemAccessAccount(
    IN PLSAPR_SID AccountSid,
    IN PULONG SystemAccess
    )

/*++

Routine Description:

    This function updates the System Access flags in an Account's information
    block.

Arguments:

    AccountSid - Sid of account

    SystemAccess - Pointer to new System Access flags.  These flags
        will overwrite the old value

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!LsapDbIsCacheValid(AccountObject)) {

        goto UpdateSystemAccessAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdateSystemAccessAccountError;
    }

    //
    // Update the System Access Flags
    //

    Account->Info.SystemAccess = *SystemAccess;

UpdateSystemAccessAccountFinish:

    return(Status);

UpdateSystemAccessAccountError:

    goto UpdateSystemAccessAccountFinish;
}


NTSTATUS
LsapDbUpdateQuotasAccount(
    IN PLSAPR_SID AccountSid,
    IN PQUOTA_LIMITS QuotaLimits
    )

/*++

Routine Description:

    This function updates the Quota Limits an Account's information
    block.

Arguments:

    AccountSid - Sid of Account

    Quotas - Pointer to new Quota Limits flags.  These flags
        will overwrite the old value

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Verify that the Account List is valid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!LsapDbIsCacheValid(AccountObject)) {

        goto UpdateQuotasAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdateQuotasAccountError;
    }

    //
    // Update the System Access Flags
    //

    Account->Info.QuotaLimits = *QuotaLimits;

UpdateQuotasAccountFinish:

    return(Status);

UpdateQuotasAccountError:

    goto UpdateQuotasAccountFinish;
}


NTSTATUS
LsapDbUpdatePrivilegesAccount(
    IN PLSAPR_SID AccountSid,
    IN OPTIONAL PPRIVILEGE_SET Privileges
    )

/*++

Routine Description:

    This function replates the Privilege Set in an Account's information
    block with the one given.  The existing Privilege Set (if any) in the
    block will be freed.

Arguments:

    AccountSid - Sid of account

    Privileges - Optional pointer to new Privilege Set.  These flags
        will overwrite the old value.  if NULL is specified, a Privilege
        Set containing 0 entries will be written.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;
    PLSAP_DB_ACCOUNT Account = NULL;
    PPRIVILEGE_SET OutputPrivileges = Privileges;

    //
    // Verify that the Account List is valid.
    //

    Status = STATUS_INVALID_PARAMETER;

    if (!LsapDbIsCacheValid( AccountObject)) {

        goto UpdatePrivilegesAccountError;
    }

    //
    // Lookup the Account
    //

    Status = LsapDbLookupAccount( AccountSid, &Account );

    if (!NT_SUCCESS(Status)) {

        goto UpdatePrivilegesAccountError;
    }

    //
    // If NULL was specified for the Privileges, construct a Privilege Set
    // having 0 entries.
    //

    if (OutputPrivileges == NULL) {

        Status = STATUS_NO_MEMORY;

        OutputPrivileges = MIDL_user_allocate( sizeof(PRIVILEGE_SET) );

        if (OutputPrivileges == NULL) {

            goto UpdatePrivilegesAccountError;
        }

        OutputPrivileges->PrivilegeCount = 0;
        OutputPrivileges->Control = 0;
    }

    //
    // If there is an existing Privilege Set in the cache, free it.
    //

    if (Account->Info.PrivilegeSet != NULL) {

        MIDL_user_free( Account->Info.PrivilegeSet );
        Account->Info.PrivilegeSet = NULL;
    }

    //
    // Update the Privileges
    //

    Account->Info.PrivilegeSet = OutputPrivileges;

UpdatePrivilegesAccountFinish:

    return(Status);

UpdatePrivilegesAccountError:

    if (Account != NULL) {

        Account->Info.PrivilegeSet = NULL;
    }

    goto UpdatePrivilegesAccountFinish;
}


NTSTATUS
LsapDbCreateAccountList(
    OUT PLSAP_DB_ACCOUNT_LIST AccountList
    )

/*++

Routine Description:

    This function creates an empty Account List

Arguments

    AccountList - Pointer to Account List structure that will be initialized.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    AccountList->AccountCount = 0;

    InitializeListHead( &AccountList->Links );

    return(Status);
}


NTSTATUS
LsapDbBuildAccountCache(
    )

/*++

Routine Description:

    This function constructs a cache for the Account objects.  The cache
    is a counted doubly linked list of blocks, one for each Account Object
    found in the LSA Policy Database.

Arguments:

    None.

Return Values:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    SID_AND_ATTRIBUTES AccountSidAndAttributes;
    ULONG EnumerationIndex, EnumerationContext;
    LSAPR_ACCOUNT_ENUM_BUFFER EnumerationBuffer;
    PLSAPR_SID AccountSid = NULL;
    PLSAP_DB_ACCOUNT Account = NULL;

    //
    // Ensure caching of Account objects is turned off.
    //

    LsapDbMakeCacheBuilding( AccountObject );

    //
    // Initialize the Account List header with a skeleton entry for the
    // System Account.
    //

    Status = LsapDbCreateAccountList(&LsapDbAccountList);

    if (!NT_SUCCESS(Status)) {

        goto BuildAccountCacheError;
    }

    LsapDbMakeCacheInvalid( AccountObject );

    //
    // Enumerate each of the LSA Account objects
    //

    Status = STATUS_MORE_ENTRIES;
    EnumerationContext = 0;

    while (Status == STATUS_MORE_ENTRIES) {

        //
        // Enumerate the next bunch of accounts.
        //

        Status = LsarEnumerateAccounts(
                     LsapPolicyHandle,
                     &EnumerationContext,
                     &EnumerationBuffer,
                     LSAP_DB_BUILD_ACCOUNT_LIST_LENGTH
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // We might just have got the warning that there are no more
            // accounts.  Reset to STATUS_SUCCESS and break out.
            //

            if (Status == STATUS_NO_MORE_ENTRIES) {

                Status = STATUS_SUCCESS;
            }

            break;
        }

        //
        // We've got some more accounts.  Add them to the Account List
        //

        for( EnumerationIndex = 0;
             EnumerationIndex < EnumerationBuffer.EntriesRead;
             EnumerationIndex++ ) {

            AccountSid = EnumerationBuffer.Information[ EnumerationIndex ].Sid;

            Status = LsapDbCreateAccount( AccountSid, &Account );

            if (!NT_SUCCESS(Status)) {

                break;
            }

            AccountSidAndAttributes.Sid = (PSID) AccountSid;
            AccountSidAndAttributes.Attributes = 0;

            Status = LsapDbSlowQueryAllInformationAccounts(
                         LsapPolicyHandle,
                         1,
                         &AccountSidAndAttributes,
                         &Account->Info
                         );

            if (!NT_SUCCESS(Status)) {

                if (Status != STATUS_NO_MORE_ENTRIES) {

                    break;
                }

                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS(Status)) {

            break;
        }

        Status = STATUS_MORE_ENTRIES;

        LsaIFree_LSAPR_ACCOUNT_ENUM_BUFFER( &EnumerationBuffer );
    }

    if (!NT_SUCCESS(Status)) {

        goto BuildAccountCacheError;
    }

    //
    // Turn on caching for Account objects.
    //

    LsapDbMakeCacheValid( AccountObject );

    Status = STATUS_SUCCESS;

BuildAccountCacheFinish:

    return(Status);

BuildAccountCacheError:

    LsapDbMakeCacheInvalid(AccountObject);
    LsapDbMakeCacheUnsupported(AccountObject);
    goto BuildAccountCacheFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dsexe\makefile.inc ===
# MOF resources required for WMI tracing
lsasrv.bmf: lsasrv.mof
    mofcomp -WMI -B:lsasrv.bmf lsasrv.mof
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dsexe\lsass.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    lsass.c

Abstract:

    Local Security Authority Subsystem - Main Program.

Author:

    Scott Birrell       (ScottBi)    Mar 12, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "ntrpcp.h"
#include "lmcons.h"
#include "lmalert.h"
#include "alertmsg.h"
#include <samisrv.h>
#include "safemode.h"



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Shared Global Variables                                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



#if DBG

IMAGE_LOAD_CONFIG_DIRECTORY _load_config_used = {
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // Reserved
    0,                          // GlobalFlagsClear
    0,                          // GlobalFlagsSet
    900000,                     // CriticalSectionTimeout (milliseconds)
    0,                          // DeCommitFreeBlockThreshold
    0,                          // DeCommitTotalFreeThreshold
    0,                          // LockPrefixTable
    0, 0, 0, 0, 0, 0, 0         // Reserved
};


#endif \\DBG



/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Internal routine prototypes                                    //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



VOID
LsapNotifyInitializationFinish(
   IN NTSTATUS CompletionStatus
   );




/////////////////////////////////////////////////////////////////////////
//                                                                     //
//      Routines                                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

LONG
WINAPI
LsaTopLevelExceptionHandler(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )

/*++

Routine Description:

    The Top Level exception filter for lsass.exe.

    This ensures the entire process will be cleaned up if any of
    the threads fail.  Since lsass.exe is a distributed application,
    it is better to fail the entire process than allow random threads
    to continue executing.

Arguments:

    ExceptionInfo - Identifies the exception that occurred.


Return Values:

    EXCEPTION_EXECUTE_HANDLER - Terminate the process.

    EXCEPTION_CONTINUE_SEARCH - Continue processing as though this filter
        was never called.


--*/
{
    return RtlUnhandledExceptionFilter(ExceptionInfo);
}



VOID __cdecl
main ()
{
    NTSTATUS  Status = STATUS_SUCCESS;
    KPRIORITY BasePriority;
    BOOLEAN   EnableAlignmentFaults = TRUE;
    LSADS_INIT_STATE    LsaDsInitState;

    //
    // Define a top-level exception handler for the entire process.
    //

    (VOID) SetErrorMode( SEM_FAILCRITICALERRORS );

    (VOID) SetUnhandledExceptionFilter( &LsaTopLevelExceptionHandler );

    //
    // Run the LSA in the foreground.
    //
    // Several processes which depend on the LSA (like the lanman server)
    // run in the foreground.  If we don't run in the foreground, they'll
    // starve waiting for us.
    //

    BasePriority = FOREGROUND_BASE_PRIORITY;

    Status = NtSetInformationProcess(
                NtCurrentProcess(),
                ProcessBasePriority,
                &BasePriority,
                sizeof(BasePriority)
                );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }


    //
    // Do the following:
    //
    //
    //      Check the boot environment
    //          If this is a DC booted into safe mode, set the appropriate
    //          flag so LsaISafeBoot returns TRUE.
    //
    //      Initialize the service-controller service
    //      dispatcher.
    //
    //      Initialize LSA Pass-1
    //          This starts the RPC server.
    //          Does not do product type-specific initialization.
    //
    //      Pause for installation if necessary
    //          Allows product type-specific information to be
    //          collected.
    //
    //      Initialize LSA Pass-2
    //          Product type-specific initialization.
    //
    //      Initialize SAM
    //

    //
    // Analyse the boot environment
    //
    Status = LsapCheckBootMode();
    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }


    //
    // Initialize the service dispatcher.
    //
    // We initialize the service dispatcher before the sam
    // service is started.  This will make the service controller
    // start successfully even if SAM takes a long time to initialize.
    //

    Status = ServiceInit();

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Initialize the LSA.
    // If unsuccessful, we must exit with status so that the SM knows
    // something has gone wrong.
    //

    Status = LsapInitLsa();

    if (!NT_SUCCESS(Status)) {

        goto Cleanup;
    }

    //
    // Initialize SAM
    //

    Status = SamIInitialize();

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }


    //
    // Do the second phase of the dc promote/demote API initialization
    //
    Status = LsapDsInitializePromoteInterface();
    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Open a Trusted Handle to the local SAM server.
    //

    Status = LsapAuOpenSam( TRUE );

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    //
    // Handle the LsaDs initialization
    //
    LsapDsDebugInitialize();

    if ( NT_SUCCESS( Status ) ) {

        if ( SampUsingDsData() ) {

            LsaDsInitState = LsapDsDs;

        } else {

            LsaDsInitState = LsapDsNoDs;

        }

        Status = LsapDsInitializeDsStateInfo( LsaDsInitState );
        if ( !NT_SUCCESS( Status ) ) {

            goto Cleanup;
        }
    }


Cleanup:

    LsapNotifyInitializationFinish(Status);

    ExitThread( Status );

}

VOID
LsapNotifyInitializationFinish(
   IN NTSTATUS CompletionStatus
   )

/*++

Routine Description:

    This function handles the notification of successful or
    unsuccessful completion of initialization of the Security Process
    lsass.exe.  If initialization was unsuccessful, a popup appears.  If
    setup was run, one of two events is set.  The SAM_SERVICE_STARTED event
    is set if LSA and SAM started OK and the SETUP_FAILED event is set if LSA
    or SAM server setup failed.  Setup waits multiple on this object pair so
    that it can detect either event being set and notify the user if necessary
    that setup failed.

Arguments:

    CompletionStatus - Contains a standard Nt Result Code specifying
        the success or otherwise of the initialization/installation.

Return Values:

    None.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Response;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttributes;
    HANDLE EventHandle = NULL;

    if (NT_SUCCESS(CompletionStatus)) {

        //
        // Set an event telling anyone wanting to call SAM that we're initialized.
        //

        RtlInitUnicodeString( &EventName, L"\\SAM_SERVICE_STARTED");
        InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

        Status = NtCreateEvent(
                     &EventHandle,
                     SYNCHRONIZE|EVENT_MODIFY_STATE,
                     &EventAttributes,
                     NotificationEvent,
                     FALSE                // The event is initially not signaled
                     );


        if ( !NT_SUCCESS(Status)) {

            //
            // If the event already exists, a waiting thread beat us to
            // creating it.  Just open it.
            //

            if( Status == STATUS_OBJECT_NAME_EXISTS ||
                Status == STATUS_OBJECT_NAME_COLLISION ) {

                Status = NtOpenEvent(
                             &EventHandle,
                             SYNCHRONIZE|EVENT_MODIFY_STATE,
                             &EventAttributes
                             );
            }

            if ( !NT_SUCCESS(Status)) {

                KdPrint(("SAMSS:  Failed to open SAM_SERVICE_STARTED event. %lX\n",
                     Status ));
                KdPrint(("        Failing to initialize SAM Server.\n"));
                goto InitializationFinishError;
            }
        }

        //
        // Set the SAM_SERVICE_STARTED event.  Except when an error occurs,
        // don't close the event.  Closing it would delete the event and
        // a future waiter would never see it be set.
        //

        Status = NtSetEvent( EventHandle, NULL );

        if ( !NT_SUCCESS(Status)) {

            KdPrint(("SAMSS:  Failed to set SAM_SERVICE_STARTED event. %lX\n",
                Status ));
            KdPrint(("        Failing to initialize SAM Server.\n"));
            NtClose(EventHandle);
            goto InitializationFinishError;

        }

    } else {

        //
        // The initialization/installation of Lsa and/or SAM failed.  Handle errors returned
        // from the initialization/installation of LSA or SAM.  Issue a popup
        // and, if installing, set an event so that setup will continue and
        // clean up.
        //

        ULONG_PTR Parameters[1];

        //
        // don't reboot unless LSA was running as SYSTEM.
        // this prevents a user who runs lsass.exe from causing an instant reboot.
        //

        if(ImpersonateSelf( SecurityImpersonation ))
        {
            HANDLE hThreadToken;

            if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hThreadToken))
            {
                BOOL DoShutdown = TRUE;
                BOOL fIsMember;
                PSID psidSystem = NULL;
                SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;


                if(AllocateAndInitializeSid(
                                &sia,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0,0,0,0,0,0,0,
                                &psidSystem
                                ))
                {
                    if(CheckTokenMembership(hThreadToken, psidSystem, &fIsMember))
                    {
                        DoShutdown = fIsMember;
                    }

                    if( psidSystem != NULL )
                    {
                        FreeSid( psidSystem );
                    }
                }

                CloseHandle( hThreadToken );
                RevertToSelf();

                if( !DoShutdown )
                {
                    goto InitializationFinishFinish;
                }
            } else {
                RevertToSelf();
            }
        }

        
        Parameters[0] = MB_OK | MB_ICONSTOP | MB_SETFOREGROUND;

        Status = NtRaiseHardError(
                     CompletionStatus | HARDERROR_OVERRIDE_ERRORMODE,
                     1,
                     0,
                     Parameters,
                     OptionOk,
                     &Response
                     );

        //
        // If setup.exe was run, signal the SETUP_FAILED event.  setup.exe
        // waits multiple on the SAM_SERVICE_STARTED and SETUP_FAILED events
        // so setup will resume and cleanup/continue as appropriate if
        // either of these events are set.
        //

        if (LsaISetupWasRun()) {

            //
            // Once the user has clicked OK in response to the popup, we come
            // back to here.  Set the event SETUP_FAILED.  The Setup
            // program (if running) waits multiple on the SAM_SERVICE_STARTED
            // and SETUP_FAILED events.
            //

            RtlInitUnicodeString( &EventName, L"\\SETUP_FAILED");
            InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

            //
            // Open the SETUP_FAILED event (exists if setup.exe is running).
            //

            Status = NtOpenEvent(
                           &EventHandle,
                           SYNCHRONIZE|EVENT_MODIFY_STATE,
                           &EventAttributes
                           );

            if ( !NT_SUCCESS(Status)) {

                //
                // Something is inconsistent.  We know that setup was run
                // so the event should exist.
                //

                KdPrint(("LSA Server:  Failed to open SETUP_FAILED event. %lX\n",
                    Status ));
                KdPrint(("        Failing to initialize Lsa Server.\n"));
                goto InitializationFinishError;
            }

            Status = NtSetEvent( EventHandle, NULL );

        } else if ( NT_SUCCESS( Status )) {

            //
            // This is not setup, so the only option is to shut down the system
            //

            BOOLEAN WasEnabled;

            //
            // issue shutdown request
            //
            RtlAdjustPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                TRUE,       // enable shutdown privilege.
                FALSE,
                &WasEnabled
                );

            //
            // Shutdown and Reboot now.
            // Note: use NtRaiseHardError to shutdown the machine will result Bug C
            //

            NtShutdownSystem( ShutdownReboot );

            //
            // if Shutdown request failed, (returned from above API)
            // reset shutdown privilege to previous value.
            //

            RtlAdjustPrivilege(
                SE_SHUTDOWN_PRIVILEGE,
                WasEnabled,   // reset to previous state.
                FALSE,
                &WasEnabled
                );
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto InitializationFinishError;
    }

InitializationFinishFinish:

    return;

InitializationFinishError:

    goto InitializationFinishFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbattr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbattr.c

Abstract:

    LSA Database Handle Manager - Object Attribute Routines

    These routines manipulate or construct LSA Database Object Attributes
    or their content.

Author:

    Scott Birrell       (ScottBi)     January 21, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

NTSTATUS
LsapDbMakeUnicodeAttribute(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Unicode String form.  The Unicode String is converted to
    Self-Relative form after validation and the given Attribute
    structure is filled in.

    If a NULL UnicodeValue, or string of length 0 is specified, NULL is
    propagated as the attribute value.

    WARNING! - This routine allocates memory for the Self-Relative Unicode
    string produced.  This memory must be freed after use by calling
    MIDL_user_free()

Arguments:

    UnicodeValue - Pointer to Unicode String containing the Attribute's
        Value.  NULL may be specified, in which case, NULL will be stored
        in the output Attribute.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources such
            as memory to complete the call.

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a Unicode String.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING_SR OutputAttributeValue = NULL;
    ULONG OutputAttributeValueLength = 0;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    //
    // Mark attribute initially as not having had memory allocated by
    // setting MemoryAllocated to FALSE.  If routine succeeds and we allocate
    // memory via MIDL_user_allocate() change MemoryAllocated field to TRUE.
    //

    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(UnicodeValue) && UnicodeValue->Length != 0) {

        //
        // Validate the string
        //
        if ( !LsapValidateLsaUnicodeString( UnicodeValue ) ) {
            return STATUS_INVALID_PARAMETER;
        }


        //
        //  Calculate the size of memory required for a Self-Relative
        //  Unicode String and allocate the memory.
        //

        OutputAttributeValueLength =
            sizeof(UNICODE_STRING_SR) + (ULONG) UnicodeValue->MaximumLength;
        OutputAttributeValue = MIDL_user_allocate(OutputAttributeValueLength);

        if (OutputAttributeValue == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        Attribute->MemoryAllocated = TRUE;

        //
        // Setup self-relative Unicode String (but with absolute buffer pointer
        // referencing buffer following UNICODE_STRING header)
        // Copy source Unicode Value to Self-relative Unicode String.  Set buffer pointer
        // to NULL as it will not be used here.
        //

        OutputAttributeValue->Length = UnicodeValue->Length;
        OutputAttributeValue->MaximumLength = UnicodeValue->MaximumLength;
        OutputAttributeValue->Offset = sizeof(UNICODE_STRING_SR);

        //
        // Copy the Unicode string Buffer
        //

        RtlCopyMemory( OutputAttributeValue + 1,
                       UnicodeValue->Buffer,
                       UnicodeValue->Length );
    }

    Attribute->AttributeName = AttributeName;
    Attribute->AttributeValue = OutputAttributeValue;
    Attribute->AttributeValueLength = OutputAttributeValueLength;

    return(Status);
}


NTSTATUS
LsapDbMakeMultiUnicodeAttribute(
    OUT PLSAP_DB_ATTRIBUTE Attribute,
    IN PUNICODE_STRING AttributeName,
    IN PUNICODE_STRING UnicodeStrings,
    IN ULONG Entries
    )

/*++

Routine Description:

    This function constructs an attribute value containing one or more
    Unicode Strings in Self-Relative format.  Memory for the attribute's
    value will be allocated via MIDL_user_allocate and must be freed
    when no longer required via MIDL_user_free.

    If a NULL UnicodeValue, or string of length 0 is specified, NULL is
    propagated as the attribute value.

    WARNING!  The caller is expected to provide valid parameters.  No
    checking will be done.

Arguments:

    Attribute - Pointer to attribute structure that will be initialized
        to reference the newly constructed value.

    AttributeName - Pointer to Unicode string specifying the name of
        the attribute to be constructed.

    UnicodeStrings - Pointer to an array of Unicode String structures.

    Entries - Number of Unicode Strings specified in the array.  Zero
        is specifiable.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG MultiUnicodeStringLength;
    PLSAP_DB_MULTI_UNICODE_STRING MultiUnicodeString;
    PUNICODE_STRING NextInputUnicodeString;
    PUNICODE_STRING_SR NextOutputUnicodeString;
    PUNICODE_STRING LastInputUnicodeString;
    PUCHAR NextOutputUnicodeBuffer;
    BOOLEAN MemoryAllocated;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    //
    // If the number of strings is Zero, initialize the attribute to
    // NULL.
    //

    if (Entries != 0) {

        LastInputUnicodeString = &UnicodeStrings[Entries - 1];

        //
        // Calculate the amount of memory required for the
        // Multi-Unicode string.  First get the size of the header.
        //

        MultiUnicodeStringLength =
            sizeof (LSAP_DB_MULTI_UNICODE_STRING) +
                ((Entries - 1) * sizeof (UNICODE_STRING_SR));

        //
        // Now add in the length of each Unicode Buffer.
        //

        for( NextInputUnicodeString = UnicodeStrings;
             NextInputUnicodeString <= LastInputUnicodeString;
             NextInputUnicodeString++
             ) {

            //
            // Validate the string
            //
            if ( !LsapValidateLsaUnicodeString( NextInputUnicodeString ) ) {
                return STATUS_INVALID_PARAMETER;
            }

            MultiUnicodeStringLength += NextInputUnicodeString->Length;
        }

        //
        // Now allocate the memory.
        //

        MultiUnicodeString = MIDL_user_allocate( MultiUnicodeStringLength );

        if (MultiUnicodeString == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // Copy in each Unicode String, making it Self-Relative as we go.
        // The Unicode String buffers are placed right after the end of
        // the array of Unicode String structures.
        //

        NextOutputUnicodeBuffer =
            (PUCHAR)(MultiUnicodeString->UnicodeStrings + Entries);

        for ( NextInputUnicodeString = UnicodeStrings,
                 NextOutputUnicodeString = MultiUnicodeString->UnicodeStrings;
             NextInputUnicodeString <= LastInputUnicodeString;
             NextInputUnicodeString++, NextOutputUnicodeString++
             ) {

            //
            // First set the Length fields of the output Unicode String
            // Structure.
            //

            NextOutputUnicodeString->Length = NextInputUnicodeString->Length;
            NextOutputUnicodeString->MaximumLength = NextInputUnicodeString->Length;

            //
            // Now replace the absolute pointer to the Unicode Buffer
            // with a self-relative offset.  Note that this offset
            // is relative to the start of the Unicode String structure,
            // NOT relative to the start of the MultiUnicodeString.
            //

            NextOutputUnicodeString->Offset =
                (ULONG) (NextOutputUnicodeBuffer - (PUCHAR) NextOutputUnicodeString);

            //
            // Copy in the Unicode Buffer.
            //

            RtlMoveMemory(
                NextOutputUnicodeBuffer,
                NextInputUnicodeString->Buffer,
                NextInputUnicodeString->Length
                );

            //
            // Update destination Unicode Buffer pointer
            //

            NextOutputUnicodeBuffer += NextInputUnicodeString->Length;
        }

        MultiUnicodeString->Entries = Entries;
        MemoryAllocated = TRUE;

    } else {

        MultiUnicodeString = NULL;
        MultiUnicodeStringLength = 0;
        MemoryAllocated = FALSE;
    }

    //
    // Initialize the output attribute structure.
    //

    LsapDbInitializeAttribute(
        Attribute,
        AttributeName,
        MultiUnicodeString,
        MultiUnicodeStringLength,
        MemoryAllocated
        );

    return(Status);
}



VOID
LsapDbCopyUnicodeAttributeNoAlloc(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    )
/*++

Routine Description:

    This function makes a UNICODE_STRING structure reference the value of
    an attribute that has a Unicode String as its value.  No memory is allocated
    for the attribute values's Unicode Buffer.

Arguments:

    OutputString - Pointer to UNICODE_STRING structure that will be made
        to reference the  attribute value's Unicode Buffer.

    Attribute - Pointer to attribute information block whose
        AttributeValue field is a pointer to a Unicode String,
        or NULL.  If NULL or if the string has length 0, the output Unicode
        String is initialized with a buffer pointer equal to NULL and a zero
        length.

    SelfRelative - TRUE if the input Unicode String is expected to be
        in Self-Relative form, else FALSE.
Returns:

    Nothing

--*/
{
    UNICODE_STRING AbsInputUnicodeString;
    PUNICODE_STRING InputUnicodeString;
    PUNICODE_STRING ReturnedUnicodeString = NULL;

    //
    // The Length field will be accessed before we know whether we have
    // a self-relative string structure.
    //

    C_ASSERT( FIELD_OFFSET( UNICODE_STRING, Length ) ==
              FIELD_OFFSET( UNICODE_STRING_SR, Length ));

    //
    // Obtain pointer to input Unicode String contained in Attribute.
    // Convert it to absolute form if necessary.
    //

    InputUnicodeString = (PUNICODE_STRING) Attribute->AttributeValue;

    if ((InputUnicodeString != NULL) && (InputUnicodeString->Length != 0)) {

        if (SelfRelative) {

            PUNICODE_STRING_SR InputUnicodeStringSr;

            InputUnicodeStringSr =
                (PUNICODE_STRING_SR) Attribute->AttributeValue;

            AbsInputUnicodeString.Length = InputUnicodeStringSr->Length;
            AbsInputUnicodeString.MaximumLength =
                InputUnicodeStringSr->MaximumLength;

            AbsInputUnicodeString.Buffer =
                (PWSTR)
                (((PUCHAR)(InputUnicodeStringSr)) +
                InputUnicodeStringSr->Offset);

            InputUnicodeString = &AbsInputUnicodeString;
        }

        OutputString->Buffer = InputUnicodeString->Buffer;
        OutputString->Length = InputUnicodeString->Length;
        OutputString->MaximumLength = InputUnicodeString->MaximumLength;

    } else {

        //
        // The attribute contains a NULL Unicode String or one of length
        // 0.  Set the output Unicode String to NULL.
        //

        OutputString->Length = OutputString->MaximumLength = 0;
        OutputString->Buffer = (PWSTR) NULL;
    }
}



NTSTATUS
LsapDbCopyUnicodeAttribute(
    OUT PUNICODE_STRING OutputString,
    IN PLSAP_DB_ATTRIBUTE Attribute,
    IN BOOLEAN SelfRelative
    )

/*++

Routine Description:

This function makes a UNICODE_STRING structure reference the value of
an attribute that has a Unicode String as its value.  Memory for the
attribute values's Unicode Buffer is allocated via MIDL_user_allocate.

Arguments:

    OutputString - Pointer to UNICODE_STRING structure that will be made
        to reference the  attribute value's Unicode Buffer.

    Attribute - Pointer to attribute information block whose
        AttributeValue field is a pointer to a Unicode String,
        or NULL.  If NULL or if the string has length 0, the output Unicode String is initialized
        with a buffer pointer equal to NULL and a zero length.

    SelfRelative - TRUE if the input Unicode String is expected to be
        in Self-Relative form, else FALSE.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call was successful

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            such as memory to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    UNICODE_STRING AbsInputUnicodeString;
    PUNICODE_STRING InputUnicodeString;
    PUNICODE_STRING_SR InputUnicodeStringSr;
    PUNICODE_STRING ReturnedUnicodeString = NULL;

    //
    // The Length field will be accessed before we know whether we have
    // a self-relative string structure.
    //

    C_ASSERT( FIELD_OFFSET( UNICODE_STRING, Length ) ==
              FIELD_OFFSET( UNICODE_STRING_SR, Length ));

    //
    // Obtain pointer to input Unicode String contained in Attribute.
    // Convert it to absolute form if necessary.
    //

    InputUnicodeString = (PUNICODE_STRING) Attribute->AttributeValue;

    if ((InputUnicodeString != NULL) && (InputUnicodeString->Length != 0)) {

        if (SelfRelative) {

            InputUnicodeStringSr =
                (PUNICODE_STRING_SR) Attribute->AttributeValue;

            AbsInputUnicodeString.Length = InputUnicodeStringSr->Length;
            AbsInputUnicodeString.MaximumLength =
                InputUnicodeStringSr->MaximumLength;

            AbsInputUnicodeString.Buffer =
                (PWSTR)
                (((PUCHAR)(InputUnicodeStringSr)) +
                InputUnicodeStringSr->Offset);

            InputUnicodeString = &AbsInputUnicodeString;
        }

        //
        // Now allocate memory for the Unicode String Buffer.
        //

        OutputString->Buffer =
            MIDL_user_allocate(InputUnicodeString->MaximumLength);

        if (OutputString->Buffer == NULL) {

            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        //
        // Initialize UNICODE_STRING header
        //

        OutputString->Length = InputUnicodeString->Length;
        OutputString->MaximumLength = InputUnicodeString->MaximumLength;

        //
        // Copy the input Unicode String
        //

        RtlCopyUnicodeString( OutputString, InputUnicodeString );

    } else {

        //
        // The attribute contains a NULL Unicode String or one of length
        // 0.  Set the output Unicode String to NULL.
        //

        OutputString->Length = OutputString->MaximumLength = 0;
        OutputString->Buffer = (PWSTR) NULL;
    }

    return(Status);
}



NTSTATUS
LsapDbMakeSidAttribute(
    IN OPTIONAL PSID Sid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Sid form.  The Sid is validated and the given
    Attribute structure is filled in.

Arguments:

    Sid - Pointer to the Sid or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    Attribute->AttributeName = AttributeName;
    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(Sid)) {

        if (RtlValidSid(Sid)) {

            Attribute->AttributeValue = Sid;
            Attribute->AttributeValueLength = RtlLengthSid(Sid);
            return(Status);
        }

        Status = STATUS_INVALID_PARAMETER;
    }

    //
    // The supplied Sid is NULL or invalid.
    //

    Attribute->AttributeValue = NULL;
    Attribute->AttributeValueLength = 0;

    return(Status);
}



NTSTATUS
LsapDbMakeGuidAttribute(
    IN OPTIONAL GUID *Guid,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in GUID form.  The given Attribute structure is filled in.

Arguments:

    Guid - Pointer to the GUID or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
     NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    Attribute->AttributeName = AttributeName;
    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(Guid)) {

        Attribute->AttributeValue = Guid;
        Attribute->AttributeValueLength = sizeof(GUID);
        return(Status);
    }

    //
    // The supplied GUID is NULL
    //

    Attribute->AttributeValue = NULL;
    Attribute->AttributeValueLength = 0;

    return(Status);
}


NTSTATUS
LsapDbMakeBlobAttribute(
    IN  ULONG   BlobLength,
    IN  PBYTE   pBlob,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in blob form.  The given Attribute structure is filled in.

Arguments:

    BlobLength - Length of the blob (in BYTES)

    pBlob - Pointer to the Blob or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlZeroMemory( Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

    Attribute->AttributeName = AttributeName;
    Attribute->MemoryAllocated = FALSE;

    if (ARGUMENT_PRESENT(pBlob)) {

        Attribute->AttributeValue = pBlob;
        Attribute->AttributeValueLength = BlobLength;
        return(Status);
    }

    //
    // The supplied Blob is NULL
    //

    Attribute->AttributeValue = NULL;
    Attribute->AttributeValueLength = 0;

    return(Status);
}


NTSTATUS
LsapDbReadAttribute(
    IN LSAPR_HANDLE ObjectHandle,
    IN OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function reads an attribute of an object, allocating memory if
    requested for the buffer containing the attribute's value.

Arguments:

    ObjectHandle - Handle to object obtained from LsapDbCreateObject or
        LsapDbOpenObject

    Attributes - Pointer to an array of Attribute Information blocks each
        containing pointers to the attribute's Unicode Name, an optional
        pointer to a buffer that will receive the value and an optional
        length of the value expected in bytes.

        If the AttributeValue field in this structure is specified as non-NULL,
        the attribute's data will be returned in the specified buffer.  In
        this case, the AttributeValueLength field must specify a sufficiently
        large buffer size in bytes.  If the specified size is too small,
        a warning is returned and the buffer size required is returned in
        AttributeValueLength.

        If the AttributeValue field in this structure is NULL, the routine
        will allocate memory for the attribute value's buffer, via MIDL_user_allocate().  If
        the AttributeValueLength field is non-zero, the number of bytes specified
        will be allocated.  If the size of buffer allocated is too small to
        hold the attribute's value, a warning is returned.  If the
        AttributeValuelength field is 0, the routine will first query the size
        of buffer required and then allocate its memory.

        In all success cases and buffer overflow cases, the
        AttributeValueLength is set upon exit to the size of data required.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ATTRIBUTE DsAttribute;

    if (Attribute->AttributeValue != NULL) {

        if (Attribute->AttributeValueLength == 0) {

            return(STATUS_INVALID_PARAMETER);
        }
    }

    //
    // Deal with the Ds case seperately
    //
    if ( LsapDsIsWriteDs( ObjectHandle ) &&
         Attribute->DbNameIndex != SecDesc ) {

        RtlCopyMemory( &DsAttribute, Attribute, sizeof( LSAP_DB_ATTRIBUTE ) );

        //
        // Now, do the read...
        //
        Status = LsapDsReadAttributes( &((LSAP_DB_HANDLE)ObjectHandle)->PhysicalNameDs,
                                       LSAPDS_OP_NO_LOCK,
                                       &DsAttribute,
                                       1 );

        if ( NT_SUCCESS( Status ) ) {

            Attribute->AttributeValueLength = DsAttribute.AttributeValueLength;

            if ( Attribute->AttributeValue != NULL ) {

                if ( Attribute->AttributeValueLength >= DsAttribute.AttributeValueLength ) {

                    RtlCopyMemory( Attribute->AttributeValue, DsAttribute.AttributeValue,
                                   DsAttribute.AttributeValueLength );
                } else {

                    Status = STATUS_BUFFER_OVERFLOW;
                }


            } else {

                Attribute->AttributeValue = DsAttribute.AttributeValue;
                DsAttribute.AttributeValue = NULL;
            }

            MIDL_user_free( DsAttribute.AttributeValue );
        }

        return( Status );
    }

    Attribute->MemoryAllocated = FALSE;

    //
    // If an explicit buffer pointer is given, verify that the length
    // specified is non-zero and attempt to use that buffer.
    //

    if (Attribute->AttributeValue != NULL) {

        if (Attribute->AttributeValueLength == 0) {

            return(STATUS_INVALID_PARAMETER);
        }

        Status = LsapDbReadAttributeObject(
                     ObjectHandle,
                     Attribute->AttributeName,
                     Attribute->AttributeValue,
                     &Attribute->AttributeValueLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto ReadAttributeError;
        }

        return(Status);
    }

    //
    // No output buffer pointer has been given.  If a zero buffer
    // size is given, query size of memory required.  Since the
    // buffer length is 0, STATUS_SUCCESS should be returned rather
    // than STATUS_BUFFER_OVERFLOW.
    //

    if (Attribute->AttributeValueLength == 0) {

        Status = LsapDbReadAttributeObject(
                     ObjectHandle,
                     Attribute->AttributeName,
                     NULL,
                     &Attribute->AttributeValueLength
                     );

        if (!NT_SUCCESS(Status)) {

            goto ReadAttributeError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // If the attribute value size needed is 0, return NULL pointer
    //

    if (Attribute->AttributeValueLength == 0) {

        Attribute->AttributeValue = NULL;
        return(STATUS_SUCCESS);
    }

    //
    // Allocate memory for the buffer.
    //

    Attribute->AttributeValue =
        MIDL_user_allocate(Attribute->AttributeValueLength);

    if (Attribute->AttributeValue == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto ReadAttributeError;
    }

    Attribute->MemoryAllocated = TRUE;

    //
    // Now read the attribute into the buffer.
    //

    Status = LsapDbReadAttributeObject(
                 ObjectHandle,
                 Attribute->AttributeName,
                 Attribute->AttributeValue,
                 &Attribute->AttributeValueLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto ReadAttributeError;
    }

ReadAttributeFinish:

    return(Status);

ReadAttributeError:

    //
    // If memory was allocated for any values read, it must be freed.
    //

    if (Attribute->MemoryAllocated) {

        MIDL_user_free( Attribute->AttributeValue );
    }

    goto ReadAttributeFinish;
}


NTSTATUS
LsapDbFreeAttributes(
    IN ULONG Count,
    IN PLSAP_DB_ATTRIBUTE Attributes
    )

/*++

Routine Description:

    This function frees memory allocated for Attribute Values in an
    array of attributes.

Arguments:

    Count - Count of attributes in the array

    Attributes - Pointer to array of attributes.  Only those attributes
        in which MemoryAllocated is set to TRUE will have their
        Attribute Value buffers freed.  For these attributes, MemoryAllocated
        will be set to false.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index;

    for (Index = 0; Index < Count; Index++) {

        if (Attributes[Index].MemoryAllocated) {

            MIDL_user_free(Attributes[Index].AttributeValue);
            Attributes[Index].MemoryAllocated = FALSE;
            Attributes[Index].AttributeValue = NULL;
            Attributes[Index].AttributeValueLength = 0;
        }
    }

    return(Status);
}


NTSTATUS
LsapDbMakeUnicodeAttributeDs(
    IN OPTIONAL PUNICODE_STRING UnicodeValue,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeUnicodeAttribute( UnicodeValue,
                                                  &LsapDbNames[Name],
                                                  Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}



NTSTATUS
LsapDbMakeMultiUnicodeAttributeDs(
    OUT PLSAP_DB_ATTRIBUTE Attribute,
    IN LSAP_DB_NAMES Name,
    IN PUNICODE_STRING UnicodeNames,
    IN ULONG Entries
    )
{
    NTSTATUS Status = LsapDbMakeMultiUnicodeAttribute( Attribute,
                                                       &LsapDbNames[Name],
                                                       UnicodeNames,
                                                       Entries );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}



NTSTATUS
LsapDbMakeSidAttributeDs(
    IN PSID Sid,
    IN IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeSidAttribute( Sid,
                                              &LsapDbNames[Name],
                                              Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}



NTSTATUS
LsapDbMakeGuidAttributeDs(
    IN GUID *Guid,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeGuidAttribute( Guid,
                                               &LsapDbNames[Name],
                                               Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}



NTSTATUS
LsapDbMakeBlobAttributeDs(
    IN  ULONG   BlobLength,
    IN  PBYTE   pBlob,
    IN LSAP_DB_NAMES Name,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )
{
    NTSTATUS Status = LsapDbMakeBlobAttribute( BlobLength,
                                               pBlob,
                                               &LsapDbNames[Name],
                                               Attribute );

    if ( NT_SUCCESS( Status ) ) {

        Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
        Attribute->AttribType = LsapDbDsAttInfo[Name].AttributeType;
        Attribute->DbNameIndex = Name;
    }

    return( Status );
}

NTSTATUS
LsapDbMakePByteAttributeDs(
    IN OPTIONAL PBYTE Buffer,
    IN ULONG BufferLength,
    IN LSAP_DB_ATTRIB_TYPE AttribType,
    IN PUNICODE_STRING AttributeName,
    OUT PLSAP_DB_ATTRIBUTE Attribute
    )

/*++

Routine Description:

    This function constructs Attribute Information for an attribute value
    that is in Sid form.  The Sid is validated and the given
    Attribute structure is filled in.

Arguments:

    Sid - Pointer to the Sid or NULL.

    AttributeName - Pointer to the Unicode name of the attribute.

    Attribute - Pointer to structure that will receive the
        attributes's information.  This consists of the attribute's name,
        value and value length.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_PARAMETER - The specified AttributeValue is not a
            pointer to a syntactically valid Sid, or NULL.
--*/

{
     NTSTATUS Status = STATUS_SUCCESS;

     Attribute->AttributeName = AttributeName;
     Attribute->MemoryAllocated = FALSE;

     if (ARGUMENT_PRESENT(Buffer)) {

        Attribute->AttributeValue = Buffer;
        Attribute->AttributeValueLength = BufferLength;

     } else {

         //
         // The supplied Sid is NULL or invalid.
         //

         Attribute->AttributeValue = NULL;
         Attribute->AttributeValueLength = 0;

     }

     Attribute->DsAttId    = LsapDbDsAttInfo[Name].AttributeId;
     Attribute->AttribType = AttribType;
     Attribute->DbNameIndex = Name;

     return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dsexe\main.c ===
#include <windows.h>
#include <stdio.h>

int __cdecl main(int, char **, char **);

typedef void (__cdecl *_PVFV)(void);

#pragma data_seg(".CRT$XIA")
_PVFV __xi_a[] = { NULL };


#pragma data_seg(".CRT$XIZ")
_PVFV __xi_z[] = { NULL };


#pragma data_seg(".CRT$XCA")
_PVFV __xc_a[] = { NULL };


#pragma data_seg(".CRT$XCZ")
_PVFV __xc_z[] = { NULL };


#pragma data_seg(".CRT$XPA")
_PVFV __xp_a[] = { NULL };


#pragma data_seg(".CRT$XPZ")
_PVFV __xp_z[] = { NULL };


#pragma data_seg(".CRT$XTA")
_PVFV __xt_a[] = { NULL };


#pragma data_seg(".CRT$XTZ")
_PVFV __xt_z[] = { NULL };

#if defined(_IA64_)
#pragma comment(linker, "/merge:.CRT=.srdata")
#else
#pragma comment(linker, "/merge:.CRT=.rdata")
#endif

#pragma data_seg()  /* reset */

_PVFV *__onexitbegin;
_PVFV *__onexitend;

static void
_initterm (
    _PVFV * pfbegin,
    _PVFV * pfend
    )
{
    /*
     * walk the table of function pointers from the bottom up, until
     * the end is encountered.  Do not skip the first entry.  The initial
     * value of pfbegin points to the first valid entry.  Do not try to
     * execute what pfend points to.  Only entries before pfend are valid.
     */
    while ( pfbegin < pfend ) {
        /*
         * if current table entry is non-NULL, call thru it.
         */
        if ( *pfbegin != NULL )
            (**pfbegin)();
        ++pfbegin;
    }
}

void
mainNoCRTStartup(
    void
    )
{
    __try {

        // do C initializations
        _initterm( __xi_a, __xi_z );
        // do C++ initializations
        _initterm( __xc_a, __xc_z );

        main(1, 0, 0);

    } __except ( EXCEPTION_EXECUTE_HANDLER ) {

    }

    __try {
        // Do C++ terminators
        _initterm(__onexitbegin, __onexitend);

        // do pre-terminators
        _initterm(__xp_a, __xp_z);

        // do C terminiators
        _initterm(__xt_a, __xt_z);

    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbadmin.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbadmin.c

Abstract:

    Local Security Authority - Database Administration

    This file contains routines that perform general Lsa Database
    administration functions

Author:

    Scott Birrell       (ScottBi)       August 27, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "adtp.h"

#if DBG
LSADS_THREAD_INFO_NODE LsapDsThreadInfoList[ LSAP_THREAD_INFO_LIST_MAX ];
SAFE_RESOURCE LsapDsThreadInfoListResource;
#endif

LSADS_INIT_STATE LsaDsInitState;

NTSTATUS
LsapDbSetStates(
    IN ULONG DesiredStatesSet,
    IN LSAPR_HANDLE ObjectHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId
    )

/*++

Routine Description:

    This routine turns on special states in the Lsa Database.  These
    states can be turned off using LsapDbResetStates.

Arguments:

    DesiredStatesSet - Specifies the states to be set.

        LSAP_DB_LOCK - Acquire the Lsa Database lock.

        LSAP_DB_LOG_QUEUE_LOCK - Acquire the Lsa Audit Log
            Queue Lock.

        LSAP_DB_START_TRANSACTION - Start an Lsa Database transaction.  There
            must not already be one in progress.

        LSAP_DB_READ_ONLY_TRANSACTION - Open a transaction for read only

        LSAP_DB_DS_OP_TRANSACTION - Perform a single Ds operation per transaction

    ObjectHandle - Pointer to handle to be validated and referenced.

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_STATE - The Database is not in the correct state
            to allow this state change.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    ULONG StatesSetHere = 0;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbSetStates\n" ));

    //
    // If we have an object type that doesn't write to the Ds, make sure we have
    // the options set appropriately
    //
    if ( ObjectTypeId == PolicyObject ||
         ObjectTypeId == AccountObject ) {

        DesiredStatesSet |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    if ( ObjectTypeId == TrustedDomainObject ) {

        DesiredStatesSet |= LSAP_DB_READ_ONLY_TRANSACTION;
    }

    //
    // If requested, lock the Audit Log Queue
    //

    if (DesiredStatesSet & LSAP_DB_LOG_QUEUE_LOCK) {

        Status = LsapAdtAcquireLogFullLock();

        if (!NT_SUCCESS(Status)) {

            goto SetStatesError;
        }

        StatesSetHere |= LSAP_DB_LOG_QUEUE_LOCK;
    }

    //
    // If requested, lock the Lsa database
    //

    if (DesiredStatesSet & LSAP_DB_LOCK) {

        LsapDbAcquireLockEx( ObjectTypeId,
                             DesiredStatesSet );

        StatesSetHere |= LSAP_DB_LOCK;
    }


    //
    // If requested, open a database update transaction.
    //

    if ( FLAG_ON( DesiredStatesSet, LSAP_DB_READ_ONLY_TRANSACTION |
                                    LSAP_DB_NO_DS_OP_TRANSACTION |
                                    LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_START_TRANSACTION ) ) {


        Status = LsapDbOpenTransaction( DesiredStatesSet );

        if (!NT_SUCCESS(Status)) {

            goto SetStatesError;
        }

        StatesSetHere |= LSAP_DB_START_TRANSACTION;
    }


SetStatesFinish:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbSetStates: 0x%lx\n", Status ));
    return( Status );

SetStatesError:

    //
    // If we started a transaction, abort it.
    //

    if (StatesSetHere & LSAP_DB_START_TRANSACTION) {

        SecondaryStatus = LsapDbAbortTransaction( DesiredStatesSet );
    }

    //
    // If we locked the database, unlock it.
    //

    if (StatesSetHere & LSAP_DB_LOCK) {

        LsapDbReleaseLockEx( ObjectTypeId,
                             DesiredStatesSet );
    }

    //
    // If we locked the Audit Log Queue, unlock it.
    //

    if (StatesSetHere & LSAP_DB_LOG_QUEUE_LOCK) {

        LsapAdtReleaseLogFullLock();
    }

    goto SetStatesFinish;
}


NTSTATUS
LsapDbResetStates(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN NTSTATUS PreliminaryStatus
    )

/*++

Routine Description:

    This function resets the Lsa Database states specified.  It is used
    to reset states set by LsapDbSetStates.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    Options - Specifies optional actions, including states to be reset

        LSAP_DB_LOCK - Lsa Database lock to be released

        LSAP_DB_LOG_QUEUE_LOCK - Lsa Audit Log Queue Lock to
            be released.

        LSAP_DB_FINISH_TRANSACTION - Lsa database transaction open.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
             Replicators.

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.

    PreliminaryStatus - Indicates the preliminary result code of the
        calling routine.  Allows reset action to vary depending on the
        result code, for example, apply or abort transaction.

Return Value:

    NTSTATUS - Standard Nt Result Code.  This is the final status to be used
        by the caller and is equal to the Preliminary status except in the
        case where that is as success status and this routine fails.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG StatesResetAttempted = 0;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbResetStates (Prelim: 0x%lx )\n", PreliminaryStatus ));

    //
    // If we have an object type that doesn't write to the Ds, make sure we have
    // the options set appropriately
    //
    if ( ObjectTypeId == PolicyObject ||
         ObjectTypeId == AccountObject ) {

        Options |= LSAP_DB_NO_DS_OP_TRANSACTION;
    }

    if ( ObjectTypeId == TrustedDomainObject ) {

        Options |= LSAP_DB_READ_ONLY_TRANSACTION;
    }

    //
    // If requested, finish a database update transaction.
    //
    if ( !FLAG_ON( Options, LSAP_DB_STANDALONE_REFERENCE ) &&
         FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION |
                              LSAP_DB_NO_DS_OP_TRANSACTION |
                              LSAP_DB_DS_OP_TRANSACTION |
                              LSAP_DB_FINISH_TRANSACTION ) ) {

        StatesResetAttempted |= LSAP_DB_FINISH_TRANSACTION;

        if (NT_SUCCESS(PreliminaryStatus)) {

            Status = LsapDbApplyTransaction(
                         ObjectHandle,
                         Options,
                         SecurityDbDeltaType
                         );

        } else {

            Status = LsapDbAbortTransaction( Options );
        }

        if (!NT_SUCCESS(Status)) {

            goto ResetStatesError;
        }
    }

    //
    // If unlocking requested, unlock the Lsa Database.
    //

    if (Options & LSAP_DB_LOCK) {

        StatesResetAttempted |= LSAP_DB_LOCK;
        LsapDbReleaseLockEx( ObjectTypeId,
                             Options );
    }

    //
    // If unlocking if the Audit Log Queue requested, unlock the queue.
    //

    if (Options & LSAP_DB_LOG_QUEUE_LOCK) {

        StatesResetAttempted |= LSAP_DB_LOG_QUEUE_LOCK;
        LsapAdtReleaseLogFullLock();
    }

    //
    // The requested reset operations were performed successfully.
    // Propagate the preliminary status back to the caller.
    //

    Status = PreliminaryStatus;

ResetStatesFinish:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbResetStates: 0x%lx\n", Status ));
    return( Status );

ResetStatesError:

    //
    // One or more of the requested reset operations could not be performed.
    // Attempt to restore the database to a usable state.
    //

    LsapDbResetStatesError(
        ObjectHandle,
        PreliminaryStatus,
        Options,
        SecurityDbDeltaType,
        StatesResetAttempted
        );

    goto ResetStatesFinish;
}


VOID
LsapDbResetStatesError(
    IN LSAPR_HANDLE ObjectHandle,
    IN NTSTATUS PreliminaryStatus,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType,
    IN ULONG StatesResetAttempted
    )

/*++

Routine Description:

    This function attempts to restore the Lsa Database state to a usable
    form after a call to LsapDbResetStates() has failed.  It will attempt
    resets that were not attempted by that function because an error
    occurred.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    PreliminaryStatus - The preliminary Result Code that the caller of
        LsapDbResetStates had.  This is normally propagated back by that
        caller.

    Options - Specifies optional actions, including states to be reset

        LSAP_DB_LOCK - Lsa Database lock to be released

        LSAP_DB_LOG_QUEUE_LOCK - Lsa Audit Log Queue Lock to
            be released.

        LSAP_DB_FINISH_TRANSACTION - Lsa database transaction open.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
             Replicators.

        LSAP_DB_REBUILD_CACHE - Rebuild the cache for the object's type.
             Note the the cache is normally rebuilt only if the
             Preliminary Status was success and the Final Status was
             a failure.

    StatesResetAttempted - Specifies the state resets that were actually
        attempted.
--*/

{
    NTSTATUS SecondaryStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId = NullObject;

    //
    // If finishing of a database update transaction was requested but
    // not attempted, do it now.  SecondaryStatus is intentionally NOT
    // checked afterwards.
    //

    if ( FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION |
                              LSAP_DB_NO_DS_OP_TRANSACTION |
                              LSAP_DB_DS_OP_TRANSACTION |
                              LSAP_DB_FINISH_TRANSACTION )  &&
        !(StatesResetAttempted & LSAP_DB_FINISH_TRANSACTION)) {

        if (NT_SUCCESS(PreliminaryStatus)) {

            SecondaryStatus = LsapDbApplyTransaction(
                                  ObjectHandle,
                                  Options,
                                  SecurityDbDeltaType
                                  );

        } else {

            SecondaryStatus = LsapDbAbortTransaction( Options );
        }
    }

    //
    // If the PreliminaryStatus was successful, attempt to rebuild
    // the cache for this object type.
    //

    if (NT_SUCCESS(PreliminaryStatus)) {

        ObjectTypeId = ((LSAP_DB_HANDLE) ObjectHandle)->ObjectTypeId;

        IgnoreStatus = LsapDbRebuildCache( ObjectTypeId );
    }

    //
    // If an unlock of the database was requested but not attempted,
    // do this now.
    //

    if ((Options & LSAP_DB_LOCK) &&
        !(StatesResetAttempted & LSAP_DB_LOCK)) {

        LsapDbReleaseLockEx( ObjectTypeId,
                             Options );
    }


    //
    // If an unlock of the Audlt Log Queue was requested but not attempted,
    // do this now.
    //

    if ((Options & LSAP_DB_LOG_QUEUE_LOCK) &&
        !(StatesResetAttempted & LSAP_DB_LOG_QUEUE_LOCK)) {

        LsapAdtReleaseLogFullLock();
    }
}


NTSTATUS
LsapDbOpenTransaction(
    IN ULONG Options
    )

/*++

Routine Description:

    This function starts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    Options - Options to apply when opening the transaction.  Valid values are:
        LSAP_DB_READ_ONLY_TRANSACTION - Open a transaction for read only

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  RegTransactionOpened = FALSE;
  

    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        Status = LsapRegOpenTransaction();
        if (NT_SUCCESS(Status))
        {
            RegTransactionOpened = TRUE;
        }
      
    }

    if ( NT_SUCCESS( Status ) && LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pOpenTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pOpenTransaction) ( Options );
        if ((!NT_SUCCESS(Status)) && RegTransactionOpened)
        { 
            NTSTATUS IgnoreStatus;

            IgnoreStatus = LsapRegAbortTransaction();
        }
        

    }

    return Status;
}


NTSTATUS
LsapDbApplyTransaction(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN SECURITY_DB_DELTA_TYPE SecurityDbDeltaType
    )

/*++

Routine Description:

    This function applies a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    ObjectHandle - Handle to an LSA object.  This is expected to have
        already been validated.

    Options - Specifies optional actions to be taken.  The following
        options are recognized, other options relevant to calling routines
        are ignored.

        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION - Omit notification to
            Replicator.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE InternalHandle = ( LSAP_DB_HANDLE )ObjectHandle;
    BOOLEAN RegApplied = FALSE, Notify = FALSE;
    BOOLEAN RestoreModifiedId = FALSE;
    BOOLEAN RegistryLocked = FALSE;
    LARGE_INTEGER Increment = {1,0},
                  OriginalModifiedId = { 0 };
    PLSADS_PER_THREAD_INFO CurrentThreadInfo;
    ULONG SavedDsOperationCount = 0;

    //
    // Reference the thread state so it doesn't disappear in the middle of this
    //  routine.
    //
    CurrentThreadInfo = LsapQueryThreadInfo();
    if ( CurrentThreadInfo ) {
        SavedDsOperationCount = CurrentThreadInfo->DsOperationCount;
        LsapCreateThreadInfo();
    }


    //
    // Verify that the LSA Database is locked
    // One of many locks is locked
    //
    //ASSERT (LsapDbIsLocked());

    //
    // Apply the DS transaction before grabbing any more locks.
    //
    // Note that this applies the transaction before updating the modified ID.
    // If we crash before updateing the modified ID, NT 4 BDCs won't be notified
    // of this change.
    //

    if ( LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pApplyTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pApplyTransaction)( Options );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // Notify the replicator unless:
    //  We are to omit replicator (e.g. for creation of a local secret), OR
    //  we are installing the Policy Object,
    //  notification globally disabled.
    //

    if ((!(Options & LSAP_DB_OMIT_REPLICATOR_NOTIFICATION)) &&
        (LsapDbHandle != NULL) &&
        (LsapDbState.ReplicatorNotificationEnabled )) {

        BOOLEAN DbChanged = FALSE;

        //
        // If the object is in the DS,
        //  determine if the DS changed.
        //

        if ( LsapDsIsHandleDsHandle( InternalHandle )) {

            //
            // Netlogon notification of DS object change is *ALWAYS* handled
            //  in the DS notification callback routine.  That's the easiest
            //  way to handle things like TDO changes result in both TDO notifications
            //  and the corresponding global secret notification.
            //

            ASSERT( InternalHandle->ObjectTypeId == TrustedDomainObject ||
                    InternalHandle->ObjectTypeId == SecretObject );

        //
        // If the object is a registry object,
        //  determine if the registry has changed.
        //

        } else {

            //
            // Grab the registry lock.
            //  It serializes access to the global ModifiedId
            //

            LsapDbLockAcquire( &LsapDbState.RegistryLock );
            RegistryLocked = TRUE;

            ASSERT( SavedDsOperationCount == 0 ||
                    InternalHandle->ObjectTypeId == PolicyObject );

            if ( LsapDbState.RegistryModificationCount > 0 ) {
                DbChanged = TRUE;

                //
                // No one should change the database on a read only transaction.
                //

                ASSERT( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION) );
            }
        }

        //
        // If the DbChanged,
        //  increment the NT 4 change serial number.
        //

        if ( DbChanged ) {

            OriginalModifiedId = LsapDbState.PolicyModificationInfo.ModifiedId;
            RestoreModifiedId = TRUE;

            //
            // Increment Modification Count.
            //

            //
            // we want to increment the modification count only if we
            // are running on a DC
            //
            // see bug# 327474
            //
            if (LsapProductType == NtProductLanManNt)
            {
                LsapDbState.PolicyModificationInfo.ModifiedId.QuadPart +=
                    Increment.QuadPart;
            }

            if ( FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

                Status = LsapRegOpenTransaction();

                if ( !NT_SUCCESS( Status ) ) {
                    goto Cleanup;
                }

                Options &= ~LSAP_DB_READ_ONLY_TRANSACTION;
            }

            Status = LsapDbWriteAttributeObject( LsapDbHandle,
                                                 &LsapDbNames[ PolMod ],
                                                 &LsapDbState.PolicyModificationInfo,
                                                 (ULONG) sizeof (POLICY_MODIFICATION_INFO) );

            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            Notify = TRUE;

            //
            // Invalidate the cache for the Policy Modification Information
            //

            LsapDbMakeInvalidInformationPolicy( PolicyModificationInformation );
        }

    } else {

        Notify = FALSE;
    }

    //
    // If there is a registry transaction in progress,
    //  apply it.
    //

    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        // Either we locked it or our caller did
        ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));

        //
        // Apply the Registry Transaction.
        //

        Status = LsapRegApplyTransaction( );

        if ( !NT_SUCCESS( Status ) ) {

            goto Cleanup;
        }

        RegApplied = TRUE;
    }

    //
    // Notify the Replicator
    //
    if ( Notify ) {

        Status = LsapDbNotifyChangeObject( ObjectHandle, SecurityDbDeltaType );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;



Cleanup:

    if ( !NT_SUCCESS(Status) ) {

        //
        // Transaction failed.  Adjust in-memory copy of the Modification
        // Count, noting that backing store copy is unaltered.
        //

        if ( RestoreModifiedId ) {
            LsapDbState.PolicyModificationInfo.ModifiedId = OriginalModifiedId;
        }


        //
        // Abort the registry transaction
        //  (Unless the isn't one or it has already been applied.)
        //
        if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) && !RegApplied ) {
            (VOID) LsapRegAbortTransaction( );
        }


    }

    if ( RegistryLocked ) {
        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }
    if ( CurrentThreadInfo ) {
        LsapClearThreadInfo();
    }
    return( Status );

}



NTSTATUS
LsapDbAbortTransaction(
    IN ULONG Options
    )

/*++

Routine Description:

    This function aborts a transaction within the LSA Database.

    WARNING:  The Lsa Database must be in the locked state when this function
              is called.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Result codes are those returned from the Registry Transaction
        Package.
--*/

{
    NTSTATUS    Status = STATUS_SUCCESS;
    //
    // Verify that the LSA Database is locked
    //  (One of many locks is locked.)
    // ASSERT (LsapDbIsLocked());

    //
    // Abort the Registry Transaction
    //
    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        ASSERT( LsapDbIsLocked( &LsapDbState.RegistryLock ));

        Status = LsapRegAbortTransaction( );
        ASSERT( NT_SUCCESS( Status ) );
    }

    if ( NT_SUCCESS( Status ) && LsapDsIsFunctionTableValid() ) {

        ASSERT( LsaDsStateInfo.DsFuncTable.pAbortTransaction );
        Status = (*LsaDsStateInfo.DsFuncTable.pAbortTransaction)( Options );

        ASSERT( NT_SUCCESS( Status ) );
    }


    return ( Status );
}


BOOLEAN
LsapDbIsServerInitialized(
    )

/*++

Routine Description:

    This function indicates whether the Lsa Database Server is initialized.

Arguments:

    None.

Return Value:

    BOOLEAN - TRUE if the LSA Database Server is initialized, else FALSE.

--*/

{
    if (LsapDbState.DbServerInitialized) {

        return TRUE;

    } else {

        return FALSE;
    }
}


VOID
LsapDbEnableReplicatorNotification(
    )

/*++

Routine Description:

    This function turns on Replicator Notification.

Arguments:

    None.

Return Value:

    None.
--*/

{
    LsapDbState.ReplicatorNotificationEnabled = TRUE;
}

VOID
LsapDbDisableReplicatorNotification(
    )

/*++

Routine Description:

    This function turns off Replicator Notification.

Arguments:

    None.

Return Value:

    None.
--*/

{
    LsapDbState.ReplicatorNotificationEnabled = FALSE;
}


VOID
LsapDbAcquireLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    )
/*++

Routine Description:

    This function manages the lock status of the LSA database for a given operation.
    The LSA no longer grabs a global lock for all operations.  Instead, access locking only
    occurs for operations involving a write.  Locks can be obtained for read or write, or
    converted between the two.

Arguments:

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    Options - Specifies optional additional actions including database state
        changes to be made, or actions not to be performed.

        LSAP_DB_READ_ONLY_TRANSACTION    do not lock the registry lock

Return Value:

    None

--*/
{
    BOOLEAN RegLock = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbAcquireLockEx(%x,%x)\n",
                        ObjectTypeId, Options ));

    ASSERT( ObjectTypeId == PolicyObject ||
            ObjectTypeId == TrustedDomainObject ||
            ObjectTypeId == AccountObject ||
            ObjectTypeId == SecretObject ||
            ObjectTypeId == NullObject ||
            ObjectTypeId == AllObject );

    //
    // Determine what lock we're talking about
    //
    switch ( ObjectTypeId ) {
    case PolicyObject:
        LsapDbLockAcquire( &LsapDbState.PolicyLock );
        RegLock = TRUE;
        break;

    case TrustedDomainObject:
        LsapDbAcquireWriteLockTrustedDomainList();
        break;

    case AccountObject:
        LsapDbLockAcquire( &LsapDbState.AccountLock );
        RegLock = TRUE;
        break;

    case SecretObject:
        LsapDbAcquireWriteLockTrustedDomainList();
        LsapDbLockAcquire( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    case NullObject:
        break;

    case AllObject:
        LsapDbLockAcquire( &LsapDbState.PolicyLock );
        LsapDbAcquireWriteLockTrustedDomainList();
        LsapDbLockAcquire( &LsapDbState.AccountLock );
        LsapDbLockAcquire( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    default:
        goto AcquireLockExExit;
    }

    //
    // See about the registry lock.  Only take it after holding an object type lock.
    //
    if ( RegLock &&
         !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) ) {

        LsapDbLockAcquire( &LsapDbState.RegistryLock );
    }

AcquireLockExExit:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbAcquireLockEx\n" ));
    return;
}


VOID
LsapDbReleaseLockEx(
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN ULONG Options
    )
/*++

Routine Description:

    This function releases the lock obtained in the previous function.  Depending on the
    state of the preliminary status, the potentially opened transaction is either aborted or
    applied

Arguments:

    ObjectTypeId - Specifies the expected object type to which the handle
        relates.  An error is returned if this type does not match the
        type contained in the handle.

    Options - Specifies optional additional actions including database state
        changes to be made, or actions not to be performed.

        LSAP_DB_READ_ONLY_TRANSACTION    do not release the registry lock

Return Value:

    None

--*/
{
    BOOLEAN RegLock = FALSE;

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReleaseLockEx(%x,%x)\n",
                     ObjectTypeId, Options ));

    //
    // Special-case check until reference count handling logic is fixed,
    // then it should go away.
    //
    if ( FLAG_ON( Options, LSAP_DB_NO_LOCK ) && !FLAG_ON( Options, LSAP_DB_LOCK ) ) {

        goto ReleaseLockExExit;
    }

    ASSERT( ObjectTypeId == PolicyObject ||
            ObjectTypeId == TrustedDomainObject ||
            ObjectTypeId == AccountObject ||
            ObjectTypeId == SecretObject ||
            ObjectTypeId == NullObject ||
            ObjectTypeId == AllObject );

    //
    // Determine what lock we're talking about
    //
    switch ( ObjectTypeId ) {
    case PolicyObject:
        LsapDbLockRelease( &LsapDbState.PolicyLock );
        RegLock = TRUE;
        break;

    case TrustedDomainObject:
        LsapDbReleaseLockTrustedDomainList();
        break;

    case AccountObject:
        LsapDbLockRelease( &LsapDbState.AccountLock );
        RegLock = TRUE;
        break;

    case SecretObject:
        LsapDbReleaseLockTrustedDomainList();
        LsapDbLockRelease( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    case NullObject:
        break;

    case AllObject:
        LsapDbLockRelease( &LsapDbState.PolicyLock );
        LsapDbReleaseLockTrustedDomainList();
        LsapDbLockRelease( &LsapDbState.AccountLock );
        LsapDbLockRelease( &LsapDbState.SecretLock );
        RegLock = TRUE;
        break;

    default:
        goto ReleaseLockExExit;
    }

    //
    // See about the registry lock
    //
    if ( !FLAG_ON( Options, LSAP_DB_READ_ONLY_TRANSACTION ) && RegLock ) {

#if DBG
        HANDLE CurrentThread =(HANDLE) (NtCurrentTeb())->ClientId.UniqueThread;
        ASSERT( LsapDbState.RegistryLock.CriticalSection.OwningThread==CurrentThread);
        ASSERT( LsapDbIsLocked(&LsapDbState.RegistryLock));
#endif
        ASSERT( LsapDbState.RegistryTransactionOpen == FALSE );
        LsapDbLockRelease( &LsapDbState.RegistryLock );
    }

ReleaseLockExExit:

    LsapDsDebugOut(( DEB_FTRACE, "LsapDbReleaseLockEx\n" ));
    return;
}



PLSADS_PER_THREAD_INFO
LsapCreateThreadInfo(
    VOID
    )
/*++

Routine Description:

    This function will create a thread info structure to be used to maintain state on
    the current operation while a ds/registry operation is happening

    If a thread info is currently active on the thread, it's ref count is incremented

Arguments:

    NONE

Return Value:

    Created thread info on success

    NULL on failure

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // If we have a current operation state, increment it's use count so we know how many
    // times we have been called...
    //
    if ( CurrentThreadInfo ) {

        CurrentThreadInfo->UseCount++;

    } else {

        //
        // Have to allocate one
        //
        CurrentThreadInfo = LsapAllocateLsaHeap( sizeof( LSADS_PER_THREAD_INFO ) );

        if ( CurrentThreadInfo ) {

            if ( TlsSetValue( LsapDsThreadState, CurrentThreadInfo ) == FALSE ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "TlsSetValue for %p on %lu failed with %lu\n",
                                 CurrentThreadInfo,
                                 GetCurrentThreadId(),
                                 GetLastError() ));

                LsapFreeLsaHeap( CurrentThreadInfo );
                CurrentThreadInfo = NULL;

            } else {

                RtlZeroMemory( CurrentThreadInfo, sizeof( LSADS_PER_THREAD_INFO ) );

                CurrentThreadInfo->UseCount++;

#if DBG
                //
                // Add ourselves to the list
                //
                SafeAcquireResourceExclusive( &LsapDsThreadInfoListResource, TRUE );
                {
                    ULONG i;
                    BOOLEAN Inserted = FALSE;

                    for (i = 0; i < LSAP_THREAD_INFO_LIST_MAX; i++ ) {

                        ASSERT( LsapDsThreadInfoList[ i ].ThreadId != GetCurrentThreadId( ));

                        if ( LsapDsThreadInfoList[ i ].ThreadInfo == NULL ) {

                            LsapDsThreadInfoList[ i ].ThreadInfo = CurrentThreadInfo;
                            LsapDsThreadInfoList[ i ].ThreadId = GetCurrentThreadId( );
                            Inserted = TRUE;
                            break;
                        }
                    }

                    if ( !Inserted ) {

                        LsapDsDebugOut(( DEB_ERROR,
                                         "Failed to insert THREAD_INFO %p in list for %lu: "
                                         "List full\n",
                                         CurrentThreadInfo,
                                         GetCurrentThreadId() ));
                    }
                }

                SafeReleaseResource( &LsapDsThreadInfoListResource );
#endif
            }
        }

    }

    return( CurrentThreadInfo );
}


VOID
LsapClearThreadInfo(
    VOID
    )
/*++

Routine Description:

    This function will remove a thread info structure to be used to maintain state on
    the current operation while a ds/registry operation is happening

    If a thread info's ref count is greater than 1, the ref count is decremented, but the
    thread info remains

Arguments:

    NONE

Return Value:

    VOID

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;
    NTSTATUS Status;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        if ( CurrentThreadInfo->UseCount > 1 ) {

            CurrentThreadInfo->UseCount--;

        } else {

            ASSERT( CurrentThreadInfo->UseCount == 1 );

            if ( CurrentThreadInfo->DsTransUseCount != 0 ) {
                ASSERT( CurrentThreadInfo->DsTransUseCount == 0 );
                LsapDsDebugOut(( DEB_ERROR,
                                 "Aborting transaction inside cleanup!\n" ));
                LsapDsCauseTransactionToCommitOrAbort( FALSE );
            }

            if ( CurrentThreadInfo->DsThreadStateUseCount != 0 ) {
                ASSERT( CurrentThreadInfo->DsThreadStateUseCount == 0 );
                LsapDsDebugOut(( DEB_ERROR,
                                 "Clear DS thread state inside cleanup!\n" ));

                Status = LsapDsMapDsReturnToStatus( THDestroy( ) );
                ASSERT( NT_SUCCESS( Status ) );

                THRestore( CurrentThreadInfo->InitialThreadState );
                CurrentThreadInfo->InitialThreadState = NULL;

                CurrentThreadInfo->DsThreadStateUseCount = 0;

            }


#if DBG
            //
            // Remove ourselves from the list
            //
            SafeAcquireResourceExclusive( &LsapDsThreadInfoListResource, TRUE );
            {
                ULONG i;
                for (i = 0; i < LSAP_THREAD_INFO_LIST_MAX; i++ ) {

                    if ( LsapDsThreadInfoList[ i ].ThreadId == GetCurrentThreadId( ) ) {

                        ASSERT( LsapDsThreadInfoList[ i ].ThreadInfo == CurrentThreadInfo );
                        LsapDsThreadInfoList[ i ].ThreadInfo = NULL;
                        LsapDsThreadInfoList[ i ].ThreadId = 0;
                        break;
                    }
                }
            }

            SafeReleaseResource( &LsapDsThreadInfoListResource );
#endif

            //
            // Clear the entry out of the thread local storage
            //
            if ( TlsSetValue( LsapDsThreadState, NULL ) == FALSE ) {

                LsapDsDebugOut(( DEB_ERROR,
                                 "Failed to remove %p for thread %lu: %lu\n",
                                 CurrentThreadInfo,
                                 GetCurrentThreadId(),
                                 GetLastError() ));
            }

            LsapFreeLsaHeap( CurrentThreadInfo );
        }
    }

}


VOID
LsapSaveDsThreadState(
    VOID
    )
/*++

Routine Description:

    This function will save off the current DS thread state that may exist at the time
    the function is called.  It does not distinguish between a thread state created by
    an outside caller (say SAM), or one created by Lsa itself

    If a thread info block does not exist at the time this function is called, nothing
    is done

    Calling this function refcounts the thread info

Arguments:

    NONE

Return Value:

    VOID

--*/
{
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        ASSERT( CurrentThreadInfo->UseCount > 0 );
        CurrentThreadInfo->UseCount++;

        ASSERT( !CurrentThreadInfo->SavedTransactionValid );
        CurrentThreadInfo->SavedTransactionValid = TRUE;
        CurrentThreadInfo->SavedThreadState = THSave();
    }
}


VOID
LsapRestoreDsThreadState(
    VOID
    )
/*++

Routine Description:

    This function will restore a previously saved DS thread state

    If a thread info block does not exist at the time this function is called or there is
    no previously saved state exists, nothing is done

    Calling this function refcounts the thread info

Arguments:

    NONE

Return Value:

    VOID

--*/
{

    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    //
    // No thread info, nothing to do
    //
    if ( CurrentThreadInfo ) {

        CurrentThreadInfo->UseCount--;
        ASSERT( CurrentThreadInfo->UseCount > 0 );

        if ( CurrentThreadInfo->SavedTransactionValid == TRUE ) {

            CurrentThreadInfo->SavedTransactionValid = FALSE;
            if ( CurrentThreadInfo->SavedThreadState ) {

                THRestore( CurrentThreadInfo->SavedThreadState );
            }
            CurrentThreadInfo->SavedThreadState = NULL;

        }
    }
}



VOID
LsapServerRpcThreadReturnNotify(
    LPWSTR CallingFunction
    )
/*++

Routine Description:

    This API is called when an RPC thread which has a notify routine specified in the servers
    ACF file.


Arguments:

    NONE

Return Values:

    NONE

--*/
{
#if DBG
    static BOOLEAN CleanAsRequired = TRUE;
    PLSADS_PER_THREAD_INFO CurrentThreadInfo = NULL;
    NTSTATUS Status;
    HANDLE ThreadHandle = GetCurrentThread();

    if ( ( LsaDsInitState == LsapDsNoDs ) ||
         ( LsaDsInitState == LsapDsUnknown ) )
    {
        return ;
    }

    CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

    ASSERT( CurrentThreadInfo == NULL );

    if ( CurrentThreadInfo ) {

        LsapDsDebugOut(( DEB_ERROR, "ThreadInfo left by %ws\n", CallingFunction ));
        LsapClearThreadInfo();
    }

    ASSERT( !THQuery() );

    if ( THQuery() ) {

        LsapDsDebugOut(( DEB_ERROR,
                         "Open threadstate in cleanup.  Aborting...\n" ));

        if ( SampExistsDsTransaction() ) {

            LsapDsDebugOut(( DEB_ERROR, "Ds transaction left by %ws\n", CallingFunction ));
            LsapDsCauseTransactionToCommitOrAbort( FALSE );
            THDestroy( );
        }
    }

    //
    // Make sure we are not holding any of the locks when we exit
    //
#if 0
    ASSERT( ThreadHandle != LsapDbState.AccountLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.PolicyLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.SecretLock.ExclusiveOwnerThread );
    ASSERT( ThreadHandle != LsapDbState.RegistryLock.ExclusiveOwnerThread );
#endif

#endif

    UNREFERENCED_PARAMETER( CallingFunction );
}



NTSTATUS
LsaIHealthCheck(
    IN LSAPR_HANDLE DomainHandle OPTIONAL,
    IN ULONG StateChange,
    IN OUT PVOID StateChangeData,
    IN OUT PULONG StateChangeDataLength
    )

/*++

Routine Description:

    This function is actually invoked by Sam to indicate that state of interest to the Lsa
    has changed, and provide that state to the Lsa.  Specifically, currently, it is the Sam
    SessionKey

    This function USED to perform sanity checks within LSA.  It was invoked from
    SAM on a regular basis.  However, it was no longer needed.  Instead, we took the
    function, leaving the appropriate export from lsasrv.dll, to obsfucate the fact that
    we are now using to pass the Sam encryption key back and forth...

Arguments:

    DomainHandle - What domain this refers to.  Null means the root domain

    StateChange - What Sam/other in process client state changed that LSA cares about.  Can be:
        LSAI_SAM_STATE_SESS_KEY -   SAM's session key has changed

    StateChangeData - What data has changed.  Dependent on the type of the state change.  The
        data format must be pre-agreed upon by the Lsa and the invoker.


Return Values:

    None.

--*/

{

    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CipherKey;

    LsapEnterFunc( "LsaIHealthCheck" );


    UNREFERENCED_PARAMETER( DomainHandle );

    switch ( StateChange ) {
    case LSAI_SAM_STATE_SESS_KEY:

        //
        // Copy the syskey into memory
        //

        ASSERT(LSAP_SYSKEY_SIZE==*StateChangeDataLength);
        LsapDbSetSyskey(StateChangeData, LSAP_SYSKEY_SIZE);
        //
        // Now do a database upgrade if necessary
        //

        Status = LsapDbUpgradeRevision(TRUE, FALSE);
        break;

    case LSAI_SAM_STATE_UNROLL_SP4_ENCRYPTION:

        
        CipherKey.Length = CipherKey.MaximumLength = (USHORT)*StateChangeDataLength;
        CipherKey.Buffer = StateChangeData;
        Status = LsapDbInitializeCipherKey( &CipherKey,
                                            &LsapDbSP4SecretCipherKey );

        break;

    case LSAI_SAM_STATE_RETRIEVE_SESS_KEY:

        //
        // Return the syskey as part of state change data
        //
        
        if (NULL!=LsapDbSysKey)
        {
            RtlCopyMemory(StateChangeData, LsapDbSysKey, LSAP_SYSKEY_SIZE);
            *StateChangeDataLength = LSAP_SYSKEY_SIZE;
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

    case LSAI_SAM_STATE_CLEAR_SESS_KEY:

        //
        // Clear the syskey in memory
        //

        RtlZeroMemory(LsapDbSysKey,LSAP_SYSKEY_SIZE);
        LsapDbSysKey = NULL;
        break;

    case LSAI_SAM_GENERATE_SESS_KEY:

        //
        // Generate a new syskey and perform the database upgrade
        //
        
        Status = LsapDbUpgradeRevision(TRUE,TRUE);
        break;

    case LSAI_SAM_STATE_OLD_SESS_KEY:

        //
        // Return the old syskey as part of state change data
        //
        
        if (NULL!=LsapDbOldSysKey)
        {
            RtlCopyMemory(StateChangeData, LsapDbOldSysKey, LSAP_SYSKEY_SIZE);
            *StateChangeDataLength = LSAP_SYSKEY_SIZE;
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

   

    default:
        LsapDsDebugOut(( DEB_ERROR,
                         "Unhandled state change %lu\n", StateChange ));
        break;

    }

    LsapExitFunc( "LsaIHealthCheck", Status );

    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbdata.c

Abstract:

    Local Security Authority - Database Server Global Data

Author:

    Scott Birrell       (ScottBi)       July 25, 1991

Environment:

    User Mode

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"

OBJECT_ATTRIBUTES  LsapDbObjectAttributes;
STRING  LsapDbNameString;
LARGE_INTEGER LsapDbInitSize;
LARGE_INTEGER LsapDbMaximumSizeOfSection;




//
// LSA Initialized Status
//

BOOLEAN LsapInitialized = FALSE;

//
// Setup Event Existed
// This is necessary to distinguish a psuedo install done
// during a developer's first boot after install (which does
// an auto init) and the case where a real setup was run.
//

BOOLEAN LsapSetupWasRun = FALSE;

//
// Boolean indicating that the Ds is up and running
//
BOOLEAN LsapDsIsRunning = FALSE;

//
// Database initialization has been performed
//

BOOLEAN LsapDatabaseSetupPerformed = FALSE;

//
// Type of product we are running
//

NT_PRODUCT_TYPE LsapProductType;

//
// Product suites available on the current machine
//
WORD LsapProductSuiteMask=0;


//
// LSA Database State information
//

LSAP_DB_STATE LsapDbState;

#ifdef DBG
BOOL g_ScePolicyLocked = FALSE;
#endif

//
// LsaDb object Handle used internally.
// Also one for use throughout LSA.
//

LSAPR_HANDLE LsapDbHandle;
LSAPR_HANDLE LsapPolicyHandle = NULL;

//
// LSA Database Encryption Key
//

PLSAP_CR_CIPHER_KEY LsapDbCipherKey;
PLSAP_CR_CIPHER_KEY LsapDbSP4SecretCipherKey;
PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyRead;
PLSAP_CR_CIPHER_KEY LsapDbSecretCipherKeyWrite;
PVOID   LsapDbSysKey = NULL;
PVOID   LsapDbOldSysKey = NULL;

//
// Is this a DC in the root domain?
//

BOOLEAN DcInRootDomain = FALSE;

//
// Queue of name/sid lookup activities.
//

LSAP_DB_LOOKUP_WORK_QUEUE LookupWorkQueue;


//
// LSA Database Object SubKey Unicode name string and attributes array
//

UNICODE_STRING LsapDbNames[DummyLastName];
PLSAP_DB_DS_INFO LsapDbDsAttInfo;

//
// LSA Database Object Type Containing Directory Names
//

UNICODE_STRING LsapDbContDirs[DummyLastObject];

//
// Object Information Requirements.  These arrays, indexed by object
// type id indicated whether objects have Sids or Names.
//
// WARNING! - These arrays must be kept in sync with the LSAP_DB_OBJECT_TYPE_ID
// enumerated type.
//

BOOLEAN LsapDbRequiresSidInfo[DummyLastObject] = {

    FALSE, // NullObject
    FALSE, // LsaDatabaseObject
    FALSE, // BuiltInAccountObject
    TRUE,  // AccountObject
    FALSE  // SecretObject
};

BOOLEAN LsapDbRequiresNameInfo[DummyLastObject] = {

    FALSE, // NullObject,
    TRUE,  // LsaDatabaseObject
    TRUE,  // BuiltInAccountObject
    FALSE, // AccountObject
    TRUE   // SecretObject
};

//
// Table of accesses required to query Policy Information.  This table
// is indexed by Policy Information Class
//

ACCESS_MASK LsapDbRequiredAccessQueryPolicy[PolicyDnsDomainInformationInt + 1] = {

        0,                              // Information classes start at 1
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditLogInformation
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditEventsInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyPrimaryDomainInformation
        POLICY_GET_PRIVATE_INFORMATION, // PolicyPdAccountInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyAccountDomainInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyLsaServerRoleInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyReplicaSourceInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDefaultQuotaInformation
        0,                              // Not settable by non-trusted call
        0,                              // Not applicable
        POLICY_VIEW_AUDIT_INFORMATION,  // PolicyAuditFullQueryInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDnsDomainInformation
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDnsDomainInformationInt
};

ACCESS_MASK LsapDbRequiredAccessQueryDomainPolicy[PolicyDomainKerberosTicketInformation + 1] = {

        0,                              // Information classes start at 2
        0,                              // PolicyDomainQualityOfServiceInformation (outdated)
        POLICY_VIEW_LOCAL_INFORMATION,  // PolicyDomainEfsInformation
        POLICY_VIEW_LOCAL_INFORMATION   // PolicyDomainKerberosTicketInformation
};

//
// Table of accesses required to set Policy Information.  This table
// is indexed by Policy Information Class
//

ACCESS_MASK LsapDbRequiredAccessSetPolicy[PolicyDnsDomainInformationInt + 1] = {

        0,                              // Information classes start at 1
        POLICY_AUDIT_LOG_ADMIN,         // PolicyAuditLogInformation
        POLICY_SET_AUDIT_REQUIREMENTS,  // PolicyAuditEventsInformation
        POLICY_TRUST_ADMIN,             // PolicyPrimaryDomainInformation
        0,                              // Not settable by non-trusted call
        POLICY_TRUST_ADMIN,             // PolicyAccountDomainInformation
        POLICY_SERVER_ADMIN,            // PolicyLsaServerRoleInformation
        POLICY_SERVER_ADMIN,            // PolicyReplicaSourceInformation
        POLICY_SET_DEFAULT_QUOTA_LIMITS,// PolicyDefaultQuotaInformation
        0,                              // Not settable by non-trusted call
        POLICY_AUDIT_LOG_ADMIN,         // PolicyAuditFullSetInformation
        0,                              // Not applicable
        POLICY_TRUST_ADMIN,             // PolicyDnsDomainInformation
        POLICY_TRUST_ADMIN,             // PolicyDnsDomainInformationInt
};

ACCESS_MASK LsapDbRequiredAccessSetDomainPolicy[PolicyDomainKerberosTicketInformation + 1] = {

        0,                              // Information classes start at 2
        0,                              // PolicyDomainQualityOfServiceInformation (outdated)
        POLICY_SERVER_ADMIN,            // PolicyDomainEfsInformation
        POLICY_SERVER_ADMIN             // PolicyDomainKerberosTicketInformation
};


//
// Table of accesses required to query TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

ACCESS_MASK LsapDbRequiredAccessQueryTrustedDomain[TrustedDomainFullInformation2Internal + 1] = {

    0,                              // Information classes start at 1
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainNameInformation
    TRUSTED_QUERY_CONTROLLERS,      // TrustedControllersInformation
    TRUSTED_QUERY_POSIX,            // TrustedPosixOffsetInformation
    TRUSTED_QUERY_AUTH,             // TrustedPasswordInformation
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationBasic
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationEx
    TRUSTED_QUERY_AUTH,             // TrustedDomainAuthInformation
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH,         // TrustedDomainFullInformation
    TRUSTED_QUERY_AUTH,             // TrustedDomainAuthInformationInternal
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH,         // TrustedDomainFullInformationInternal
    TRUSTED_QUERY_DOMAIN_NAME,      // TrustedDomainInformationEx2Internal
    TRUSTED_QUERY_DOMAIN_NAME |
        TRUSTED_QUERY_POSIX |
        TRUSTED_QUERY_AUTH          // TrustedDomainFullInformation2Internal
};

//
// Table of accesses required to set TrustedDomain Information.  This table
// is indexed by TrustedDomain Information Class
//

ACCESS_MASK LsapDbRequiredAccessSetTrustedDomain[TrustedDomainFullInformation2Internal + 1] = {

    0,                              // Information classes start at 1
    0,                              // not settable (TrustedDomainNameInformation)
    TRUSTED_SET_CONTROLLERS,        // TrustedControllersInformation
    TRUSTED_SET_POSIX,              // TrustedPosixOffsetInformation
    TRUSTED_SET_AUTH,               // TrustedPasswordInformation
    TRUSTED_SET_POSIX,              // TrustedDomainInformationBasic  POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_POSIX,              // TrustedDomainInformationEx     POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_AUTH,               // TrustedDomainAuthInformation
    TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH,           // TrustedDomainFullInformation
    TRUSTED_SET_AUTH,               // TrustedDomainAuthInformationInternal
    TRUSTED_SET_POSIX |
        TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH,           // TrustedDomainFullInformationInternal
    TRUSTED_SET_POSIX,              // TrustedDomainInformationEx2Internal    POSIX is a bad bit, but its too late to change it
    TRUSTED_SET_POSIX |
        TRUSTED_SET_AUTH            // TrustedDomainFullInformation2Internal
};


//
// Cached Policy Object.  Only default Quota Limits is cached just now.
//

LSAP_DB_POLICY LsapDbPolicy = {0};

NTSTATUS
LsaIGetPrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    OUT PULONG DataLength,
    OUT PVOID *Data
    )

/*++

Routine Description:

    This service is a required part of replication.  Private LSA Database
    information (i.e. not accessible via other LSA services even at the
    trusted level) must be replicated the the beginning of each attempt
    to replicate.  This call is used to read Private LSA Database data from
    the Primary Domain Controller (PDC) involved in a replication.  The data
    returned from this call must be provided to a corresponding
    LsaISetPrivateData() call for each Backup Domain Controller involved
    in the replication in order to update the private LSA Database information
    on those controller(s).

Arguments:

    PolicyHandle - Trusted Handle to an Lsa Policy Object.

    DataLength - Length in bytes of the Private Data.

    Data - Pointer to the Private Data.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - The specified PolicyHandle is not Trusted.

        STATUS_INVALID_HANDLE - The specified PolicyHandle is not a
            valid handle to a Policy Object.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAP_DB_POLICY_PRIVATE_DATA PolicyPrivateData = NULL;
    LSAP_DB_ATTRIBUTE Attribute = { 0 };

    //
    // Acquire the Lsa Database lock.  Verify that the handle is a valid
    // Trusted handle to the Policy object.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 PolicyObject,
                 LSAP_DB_LOCK | LSAP_DB_TRUSTED
                 );

    if (!NT_SUCCESS(Status)) {

        goto GetPrivateDataError;
    }

    ObjectReferenced = TRUE;

    //
    // Read the private LSA Database Data.
    //

    Attribute.AttributeName = &LsapDbNames[PolState];
    Attribute.AttributeValue = NULL;
    Attribute.AttributeValueLength = sizeof (LSAP_DB_POLICY_PRIVATE_DATA);
    Attribute.MemoryAllocated = FALSE;

    Status = LsapDbReadAttribute( PolicyHandle, &Attribute );

    if (!NT_SUCCESS(Status)) {

        goto GetPrivateDataError;
    }

GetPrivateDataFinish:

    *Data = Attribute.AttributeValue;
    *DataLength = Attribute.AttributeValueLength;

    //
    // If necessary, dereference the Policy Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

GetPrivateDataError:

    Attribute.AttributeValueLength = 0;

    //
    // If necessary, free the returned buffer.
    //

    if ( Attribute.AttributeValue != NULL ) {

        MIDL_user_free( Attribute.AttributeValue );
        Attribute.AttributeValue = NULL;
    }

    goto GetPrivateDataFinish;
}



NTSTATUS
LsaISetPrivateData(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG DataLength,
    IN PVOID Data
    )

/*++

Routine Description:

    This service is a required part of replication.  Private LSA Database
    information (i.e. not accessible via other LSA services even at the
    trusted level) must be replicated the the beginning of each attempt
    to replicate.  Information specified on this call must have been
    obtained from a corresponding LsaIGetPrivateData() call that accessed
    the Primary Domain Controller (PDC) involved in a replication.

Arguments:

    PolicyHandle - Trusted Handle to the Lsa Policy Object of a
        Backup Domain Controller (BDC) involved in a repilcation.

    ModifiedCount - Specifies a value to be set for the current count of
        modifications made to the LSA Database.

    CreationTime - Specifies a value to be set for the date and time at
        which the LSA Database was created.

    DataLength - Length in bytes of the Private Data.

    Data - Pointer to the Private Data.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - The specified PolicyHandle is not Trusted.

        STATUS_INVALID_HANDLE - The specified PolicyHandle is not a
            valid handle to a Policy Object.
--*/

{
    NTSTATUS Status;
    BOOLEAN ObjectReferenced = FALSE;

    //
    // Acquire the Lsa Database lock.  Verify that the handle is a valid
    // Trusted handle to the Policy object.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 PolicyObject,
                 LSAP_DB_LOCK | LSAP_DB_TRUSTED
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetPrivateDataError;
    }

    ObjectReferenced = TRUE;

    Status = LsapDbWriteAttributeObject(
                 PolicyHandle,
                 &LsapDbNames[PolState],
                 Data,
                 DataLength
                 );

    if (!NT_SUCCESS(Status)) {

        goto SetPrivateDataError;
    }

SetPrivateDataFinish:

    //
    // If necessary, dereference the Policy Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     PolicyObject,
                     LSAP_DB_LOCK,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

SetPrivateDataError:

    goto SetPrivateDataFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbftrust.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbftrust.h

Abstract:

    Forest trust cache class declaration

--*/

#ifndef __FTCACHE_H
#define __FTCACHE_H

class FTCache
{
friend NTSTATUS
       LsarSetForestTrustInformation(
           IN LSAPR_HANDLE PolicyHandle,
           IN LSA_UNICODE_STRING * TrustedDomainName,
           IN LSA_FOREST_TRUST_RECORD_TYPE HighestRecordType,
           IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
           IN BOOLEAN CheckOnly,
           OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo );

friend NTSTATUS
       LsapForestTrustCacheInsert(
           IN UNICODE_STRING * TrustedDomainName,
           IN OPTIONAL PSID TrustedDomainSid,
           IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
           IN BOOLEAN LocalForestEntry );

public:

     FTCache();
    ~FTCache();

    NTSTATUS Initialize();

    void SetValid() { m_Valid = TRUE; }
    void SetInvalid();
    BOOLEAN IsValid() { return m_Valid; }

    NTSTATUS
    Remove(
        IN UNICODE_STRING * TrustedDomainName );

    NTSTATUS
    Retrieve(
        IN UNICODE_STRING * TrustedDomainName,
        OUT LSA_FOREST_TRUST_INFORMATION * * ForestTrustInfo );

    NTSTATUS
    Match(
        IN LSA_ROUTING_MATCH_TYPE Type,
        IN PVOID Data,
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
private:
#endif

    BOOLEAN m_Initialized;
    BOOLEAN m_Valid;

    RTL_AVL_TABLE m_TdoTable;
    RTL_AVL_TABLE m_TopLevelNameTable;
    RTL_AVL_TABLE m_DomainSidTable;
    RTL_AVL_TABLE m_DnsNameTable;
    RTL_AVL_TABLE m_NetbiosNameTable;

    //
    // Every TDO the forest trust information for which is stored in the
    // cache is going to have an entry like this created for it.
    // This way, retrieving and setting information for a particular TDO
    // can be performed efficiently.
    //

    struct TDO_ENTRY {

        UNICODE_STRING TrustedDomainName; // name of the corresponding TDO
        PSID TrustedDomainSid;      // SID of the corresponding TDO
        LIST_ENTRY TlnList;         // list of top level name entries for this TDO list entry
        LIST_ENTRY DomainInfoList;  // list of domain info entries for this TDO
        LIST_ENTRY BinaryList;      // list of unrecognized entries for this TDO list entry
        ULONG RecordCount;          // combined number of records
        BOOLEAN LocalForestEntry;   // does this entry correspond to the local forest?

        BOOLEAN Excludes( IN const UNICODE_STRING * Name );

#pragma warning(disable:4200)
        WCHAR TrustedDomainNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Top level name key for AVL tree lookups
    // Contains a top level name and a list of entries matching this TLN
    //

    struct TLN_KEY {

        UNICODE_STRING TopLevelName; // MUST be the first field
        ULONG Count;                 // Number of entries under this key
        LIST_ENTRY List;             // List of entries under this key

#pragma warning(disable:4200)
        WCHAR TopLevelNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Top level name entry for AVL tree lookups
    //

    struct TLN_ENTRY {

        //
        // This 'friend' relationship is a work-around for an ia64 compiler
        // bug that causes FTCache::TDO_ENTRY::Excludes to fail access control
        //

        friend BOOLEAN
        TDO_ENTRY::Excludes( IN const UNICODE_STRING * Name );

        LIST_ENTRY TdoListEntry;
        LIST_ENTRY AvlListEntry;
        LARGE_INTEGER Time;
        BOOLEAN Excluded;
        ULONG Index;
        TDO_ENTRY * TdoEntry;
        union {
            TLN_ENTRY * SubordinateEntry; // for regular entries
            TLN_ENTRY * SuperiorEntry;    // for excluded entries
        };
        TLN_KEY * TlnKey;

        BOOLEAN Enabled() {

            return Excluded ?
                       FALSE :
                       SubordinateEntry ?
                          SubordinateEntry->Enabled() :
                          (( m_Flags & LSA_FTRECORD_DISABLED_REASONS ) == 0 );
        }

        ULONG Flags() {

            return Excluded ?
                       m_Flags :
                       SubordinateEntry ?
                          SubordinateEntry->Flags() :
                          m_Flags;
        }

        void SetFlags( IN ULONG NewValue ) {

            if ( Excluded ) {

                m_Flags = NewValue; // value ignored for excluded entries

            } else if ( SubordinateEntry ) {

                SubordinateEntry->SetFlags( NewValue );

            } else {

                m_Flags = NewValue;
            }
        }

        static TLN_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       TLN_ENTRY,
                       TdoListEntry
                       );
        }

        static TLN_ENTRY *
        EntryFromAvlEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       TLN_ENTRY,
                       AvlListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    //
    // Domain SID key for AVL tree lookups
    // Contains a domain SID and a list of entries matching this domain SID
    //

    struct DOMAIN_SID_KEY {

        SID * DomainSid;    // MUST be the first field
        ULONG Count;        // Number of entries under this key
        LIST_ENTRY List;    // List of entries under this key

#pragma warning(disable:4200)
        ULONG SidBuffer[];
#pragma warning(default:4200)
    };

    //
    // DNS name key for AVL tree lookups
    // Contains a domain name and a list of entries matching this DNS name
    //

    struct DNS_NAME_KEY {

        UNICODE_STRING DnsName;   // MUST be the first field
        ULONG Count;              // Number of entries under this key
        LIST_ENTRY List;          // List of entries under this key

#pragma warning(disable:4200)
        WCHAR DnsNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Netbios name key for AVL tree lookups
    // Contains a Netbios name and a list of entries matching this Netbios name
    //

    struct NETBIOS_NAME_KEY {

        UNICODE_STRING NetbiosName; // MUST be the first field
        ULONG Count;                // Number of entries under this key
        LIST_ENTRY List;            // List of entries under this key

#pragma warning(disable:4200)
        WCHAR NetbiosNameBuffer[];
#pragma warning(default:4200)
    };

    //
    // Domain info entry for AVL tree lookups
    //

    struct DOMAIN_INFO_ENTRY {

        LIST_ENTRY TdoListEntry;
        LIST_ENTRY SidAvlListEntry;
        LIST_ENTRY DnsAvlListEntry;
        LIST_ENTRY NetbiosAvlListEntry;
        LARGE_INTEGER Time;
        ULONG Index;
        SID * Sid;
        TDO_ENTRY * TdoEntry;
        TLN_ENTRY * SubordinateTo;
        DOMAIN_SID_KEY * SidKey;
        DNS_NAME_KEY * DnsKey;
        NETBIOS_NAME_KEY * NetbiosKey;

#define SID_DISABLED_MASK ( LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_CONFLICT )
        BOOLEAN SidEnabled() { return (( m_Flags & SID_DISABLED_MASK ) == 0 ); }

#define NETBIOS_DISABLED_MASK ( LSA_NB_DISABLED_ADMIN | LSA_NB_DISABLED_CONFLICT )
        BOOLEAN NetbiosEnabled() { return (( m_Flags & NETBIOS_DISABLED_MASK ) == 0 ); }

        ULONG Flags() { return m_Flags; }

        void SetFlags( IN ULONG NewValue ) {

            m_Flags = NewValue;
        }

        void SetSidConflict() {

            SetFlags( Flags() | LSA_SID_DISABLED_CONFLICT );
        }

        void SetNetbiosConflict() {

            SetFlags( Flags() | LSA_NB_DISABLED_CONFLICT );
        }

        BOOLEAN IsAdminDisabled() {

            return ( 0 != ( Flags() && ( LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_ADMIN )));
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntryTdo ) {

            return CONTAINING_RECORD(
                       ListEntryTdo,
                       DOMAIN_INFO_ENTRY,
                       TdoListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromSidEntry( IN LIST_ENTRY * ListEntrySid ) {

            return CONTAINING_RECORD(
                       ListEntrySid,
                       DOMAIN_INFO_ENTRY,
                       SidAvlListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromDnsEntry( IN LIST_ENTRY * ListEntryDns ) {

            return CONTAINING_RECORD(
                       ListEntryDns,
                       DOMAIN_INFO_ENTRY,
                       DnsAvlListEntry
                       );
        }

        static DOMAIN_INFO_ENTRY *
        EntryFromNetbiosEntry( IN LIST_ENTRY * ListEntryNB ) {

            return CONTAINING_RECORD(
                       ListEntryNB,
                       DOMAIN_INFO_ENTRY,
                       NetbiosAvlListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    struct BINARY_ENTRY {

        LIST_ENTRY TdoListEntry;
        LARGE_INTEGER Time;
        LSA_FOREST_TRUST_RECORD_TYPE Type;
        LSA_FOREST_TRUST_BINARY_DATA Data;

        BOOLEAN Enabled() { return (( m_Flags & LSA_FTRECORD_DISABLED_REASONS ) == 0 ); }

        ULONG Flags() { return m_Flags; }

        void SetFlags( IN ULONG NewValue ) {

            m_Flags = NewValue;
        }

        static BINARY_ENTRY *
        EntryFromTdoEntry( IN LIST_ENTRY * ListEntry ) {

            return CONTAINING_RECORD(
                       ListEntry,
                       BINARY_ENTRY,
                       TdoListEntry
                       );
        }

#if !defined(LSAEXTS) // anything in lsaexts.cxx gets full access
        private:
#endif

        ULONG m_Flags;
    };

    struct CONFLICT_PAIR {

        LSA_FOREST_TRUST_RECORD_TYPE EntryType1;

        union {
            void * Entry1;
            TLN_ENTRY * TlnEntry1;
            DOMAIN_INFO_ENTRY * DomainInfoEntry1;
        };

        ULONG Flag1;

        LSA_FOREST_TRUST_RECORD_TYPE EntryType2;

        union {
            void * Entry2;
            TLN_ENTRY * TlnEntry2;
            DOMAIN_INFO_ENTRY * DomainInfoEntry2;
        };

        ULONG Flag2;

        TDO_ENTRY * TdoEntry1() {

            switch ( EntryType1 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                ASSERT( TlnEntry1 );
                ASSERT( TlnEntry1->TdoEntry );

                return TlnEntry1->TdoEntry;

            case ForestTrustDomainInfo:

                ASSERT( DomainInfoEntry1 );
                ASSERT( DomainInfoEntry1->TdoEntry );

                return DomainInfoEntry1->TdoEntry;

            default:

                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                return NULL;
            }
        }

        TDO_ENTRY * TdoEntry2() {

            switch ( EntryType2 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                ASSERT( TlnEntry2 );
                ASSERT( TlnEntry2->TdoEntry );

                return TlnEntry2->TdoEntry;

            case ForestTrustDomainInfo:

                ASSERT( DomainInfoEntry2 );
                ASSERT( DomainInfoEntry2->TdoEntry );

                return DomainInfoEntry2->TdoEntry;

            default:

                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                return NULL;
            }
        }

        void DisableEntry1() {

            switch ( EntryType1 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                TlnEntry1->SetFlags( TlnEntry1->Flags() | Flag1 );
                break;

            case ForestTrustDomainInfo:

                DomainInfoEntry1->SetFlags( DomainInfoEntry1->Flags() | Flag1 );
                break;

            default:
                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                break;
            }
        }

        void DisableEntry2() {

            switch ( EntryType2 ) {

            case ForestTrustTopLevelName:
            case ForestTrustTopLevelNameEx:

                TlnEntry2->SetFlags( TlnEntry2->Flags() | Flag2 );
                break;

            case ForestTrustDomainInfo:

                DomainInfoEntry2->SetFlags( DomainInfoEntry2->Flags() | Flag2 );
                break;

            default:
                ASSERT( FALSE ); // who created this entry??? it makes no sense.
                break;
            }
        }
    };

    BOOLEAN
    IsEmpty() { return NULL != RtlEnumerateGenericTableAvl( &m_TdoTable, TRUE ); }

    NTSTATUS
    Insert(
        IN UNICODE_STRING * TrustedDomainName,
        IN OPTIONAL PSID TrustedDomainSid,
        IN LSA_FOREST_TRUST_INFORMATION * ForestTrustInfo,
        IN BOOLEAN LocalForestEntry,
        OUT TDO_ENTRY * TdoEntryOld,
        OUT TDO_ENTRY * * TdoEntryNew,
        OUT CONFLICT_PAIR * * ConflictPairs,
        OUT ULONG * ConflictPairsTotal );

    static
    void
    ReconcileConflictPairs(
        IN OPTIONAL const TDO_ENTRY * TdoEntry,
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal );

    static
    NTSTATUS
    GenerateConflictInfo(
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal,
        IN TDO_ENTRY * TdoEntry,
        OUT PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo );

    static
    NTSTATUS
    MarshalBlob(
        IN TDO_ENTRY * TdoEntry,
        OUT ULONG * MarshaledSize,
        OUT PBYTE * MarshaledBlob );

    void Purge();

    void
    RollbackChanges(
        IN TDO_ENTRY * TdoEntryNew,
        IN TDO_ENTRY * TdoEntryOld );

    void
    PurgeTdoEntry( IN TDO_ENTRY * TdoEntry );

    void
    RemoveTdoEntry( IN TDO_ENTRY * TdoEntry );

    static
    void
    CopyTdoEntry(
        IN TDO_ENTRY * Destination,
        IN TDO_ENTRY * Source );

    LSA_FOREST_TRUST_RECORD * RecordFromTopLevelNameEntry( IN TLN_ENTRY * Entry );
    LSA_FOREST_TRUST_RECORD * RecordFromDomainInfoEntry( IN DOMAIN_INFO_ENTRY * Entry );
    LSA_FOREST_TRUST_RECORD * RecordFromBinaryEntry( IN BINARY_ENTRY * Entry );

    NTSTATUS
    MatchSid(
        IN SID * Sid,
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

    NTSTATUS
    MatchDnsName(
        IN UNICODE_STRING * String,
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

    NTSTATUS
    MatchNetbiosName(
        IN UNICODE_STRING * String,
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

    NTSTATUS
    MatchUpn( 
        IN UNICODE_STRING * String,
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

    NTSTATUS
    MatchSpn( 
        IN UNICODE_STRING * String, 
        OUT UNICODE_STRING * TrustedDomainName,
        OUT OPTIONAL BOOLEAN * IsLocal );

    TLN_ENTRY *
    LongestSubstringMatchTln(
        IN UNICODE_STRING * String,
        OUT OPTIONAL BOOLEAN * IsLocal );

    static
    NTSTATUS
    AddConflictPair(
        IN OUT CONFLICT_PAIR * * ConflictPairs,
        IN OUT ULONG * ConflictPairTotal,
        IN LSA_FOREST_TRUST_RECORD_TYPE Type1,
        IN void * Conflict1,
        IN ULONG Flag1,
        IN LSA_FOREST_TRUST_RECORD_TYPE Type2,
        IN void * Conflict2,
        IN ULONG Flag2 );

    void
    AuditChanges(
        IN const TDO_ENTRY * OldEntry,
        IN const TDO_ENTRY * NewEntry );

    void
    AuditCollisions(
        IN CONFLICT_PAIR * ConflictPairs,
        IN ULONG ConflictPairsTotal );

#if DBG

    //
    // Debug-only statistics
    //

    static DWORD sm_TdoEntries;
    static DWORD sm_TlnEntries;
    static DWORD sm_DomainInfoEntries;
    static DWORD sm_BinaryEntries;
    static DWORD sm_TlnKeys;
    static DWORD sm_SidKeys;
    static DWORD sm_DnsNameKeys;
    static DWORD sm_NetbiosNameKeys;

#endif
};

#endif // __FTCACHE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbhandle.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbhandle.c

Abstract:

    LSA Database Handle Manager

    Access to an LSA database object involves a sequence of API calls
    which involve the following:

    o  A call to an object-type dependent "open" API
    o  One or more calls to API that manipulate the object
    o  A call to the LsaClose API

    It is necessary to track context for each open of an object, for example,
    the accesses granted and the underlying LSA database handle to the
    object.  Lsa handles provide this mechanism:  an Lsa handle is simply a
    pointer to a data structure containing this context.

Author:

    Scott Birrell       (ScottBi)       May 29, 1991

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include "adtp.h"


//
// Handle Table anchor.  The handle table is just a linked list
//

struct _LSAP_DB_HANDLE LsapDbHandleTable;
LSAP_DB_HANDLE_TABLE LsapDbHandleTableEx;

NTSTATUS
LsapDbInitHandleTables(
    VOID
    )
/*++

Routine Description:

    This function initializes the LSA Database Handle Tables.  It initializes the table members
    and the locks, so it must be called before the table is accessed.

Arguments:

    None.

Return Value:

    VOID

--*/
{
    LsapDbHandleTableEx.UserCount = 0;
    InitializeListHead( &LsapDbHandleTableEx.UserHandleList );

    LsapDbHandleTableEx.FreedUserEntryCount = 0;

    //
    // Now, also initialize the flat list
    //
    LsapDbHandleTable.Next = &LsapDbHandleTable;
    LsapDbHandleTable.Previous = &LsapDbHandleTable;

    return STATUS_SUCCESS;
}

NTSTATUS
LsapDbInsertHandleInTable(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN LSAPR_HANDLE NewHandle,
    IN PLUID UserId,
    IN HANDLE UserToken
    )
/*++

Routine Description:

    This routine will enter a new handle into the lsa global policy handle table.


Arguments:

    ObjectInformation - Information on the object being created.

    NewHandle - New handle to be inserted

    UserId - LUID of the user creating the handle.
        0: means trusted handle

    UserToken - Token handle of the user creating the handle.  NULL means local system

Return Value:

    STATUS_SUCCESS - Success

    STATUS_INSUFFICIENT_RESOURCES - A memory allocation failed


--*/
{
    NTSTATUS Status;
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    BOOLEAN UserAdded = FALSE;
    BOOLEAN PolicyHandleCountIncremented = FALSE;
    LSAP_DB_HANDLE DbHandle = ( LSAP_DB_HANDLE )NewHandle;

    LsapEnterFunc( "LsapDbInsertHandleInTable" );

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    //
    // Find the entry that corresponds to our given user.
    //

    for ( HandleEntry = LsapDbHandleTableEx.UserHandleList.Flink;
          HandleEntry != &LsapDbHandleTableEx.UserHandleList;
          HandleEntry = HandleEntry->Flink ) {

        CurrentUserEntry = CONTAINING_RECORD( HandleEntry,
                                              LSAP_DB_HANDLE_TABLE_USER_ENTRY,
                                              Next );

        if ( RtlEqualLuid( &CurrentUserEntry->LogonId, UserId )  ) {

            LsapDsDebugOut(( DEB_HANDLE, "Handle 0x%lp belongs to entry 0x%lp\n",
                            NewHandle,
                            CurrentUserEntry ));
            break;

        }

        CurrentUserEntry = NULL;
    }

    //
    // Allocate a new entry if necessary.
    //
    if ( CurrentUserEntry == NULL ) {

        LsapDsDebugOut(( DEB_HANDLE, "Handle list not found for user %x:%x\n",
                        UserId->HighPart,
                        UserId->LowPart ));

        //
        // See if we can grab one off the lookaside list
        //
        if ( LsapDbHandleTableEx.FreedUserEntryCount ) {

            CurrentUserEntry = LsapDbHandleTableEx.FreedUserEntryList[
                                                LsapDbHandleTableEx.FreedUserEntryCount - 1 ];
            LsapDsDebugOut(( DEB_HANDLE,
                             "Using user entry 0x%lp from free list spot %lu\n",
                             CurrentUserEntry,
                             LsapDbHandleTableEx.FreedUserEntryCount-1 ));
            LsapDbHandleTableEx.FreedUserEntryCount--;

            ASSERT( CurrentUserEntry );


        } else {

            CurrentUserEntry = LsapAllocateLsaHeap( sizeof( LSAP_DB_HANDLE_TABLE_USER_ENTRY ) );

            if ( CurrentUserEntry == NULL ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto InsertHandleInTableEntryExit;
            }
        }


        LsapDsDebugOut(( DEB_HANDLE,
                         "Allocated user entry 0x%lp\n", CurrentUserEntry ));

        //
        // Set the information in the new entry, and then insert it into the lists
        //
        InitializeListHead( &CurrentUserEntry->PolicyHandles );
        InitializeListHead( &CurrentUserEntry->ObjectHandles );
        CurrentUserEntry->PolicyHandlesCount = 0;
        RtlCopyLuid( &CurrentUserEntry->LogonId, UserId );
        CurrentUserEntry->MaxPolicyHandles = LSAP_DB_MAXIMUM_HANDLES_PER_USER ;

        if ( RtlEqualLuid( UserId, &LsapSystemLogonId ) ||
             RtlEqualLuid( UserId, &LsapZeroLogonId ) )
        {

            CurrentUserEntry->MaxPolicyHandles = 0x7FFFFFFF ;

        }
        else if ( UserToken != NULL )
        {
            UCHAR   Buffer[ 128 ];
            PTOKEN_USER User ;
            NTSTATUS Status2 ;
            ULONG Size ;

            User = (PTOKEN_USER) Buffer ;

            Status2 = NtQueryInformationToken(
                            UserToken,
                            TokenUser,
                            User,
                            sizeof( Buffer ),
                            &Size );

            if ( NT_SUCCESS( Status2 ) )
            {
                if ( RtlEqualSid( User->User.Sid, LsapAnonymousSid ) )
                {
                    CurrentUserEntry->MaxPolicyHandles = 0x7FFFFFFF ;
                }
            }

        }
#if DBG
        if ( UserToken != NULL ) {

            OBJECT_ATTRIBUTES ObjAttrs;
            SECURITY_QUALITY_OF_SERVICE SecurityQofS;
            NTSTATUS Status2;

            //
            // Duplicate the token
            //
            InitializeObjectAttributes( &ObjAttrs, NULL, 0L, NULL, NULL );
            SecurityQofS.Length = sizeof( SECURITY_QUALITY_OF_SERVICE );
            SecurityQofS.ImpersonationLevel = SecurityImpersonation;
            SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
            SecurityQofS.EffectiveOnly = FALSE;
            ObjAttrs.SecurityQualityOfService = &SecurityQofS;

            Status2 = NtDuplicateToken( UserToken,
                                        TOKEN_READ | TOKEN_WRITE | TOKEN_EXECUTE,
                                        &ObjAttrs,
                                        FALSE,
                                        TokenImpersonation,
                                        &CurrentUserEntry->UserToken );
            if ( !NT_SUCCESS( Status2 ) ) {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Failed to duplicate the token for handle 0x%lp: 0x%lx\n",
                                 NewHandle,
                                 Status2 ));

                CurrentUserEntry->UserToken = NULL;
            }

            //
            // A failure to copy the token doesn constitute a failure to add the entry
            //

        }
#endif

        InsertTailList( &LsapDbHandleTableEx.UserHandleList,
                        &CurrentUserEntry->Next );
        LsapDbHandleTableEx.UserCount++;
        UserAdded = TRUE;
    }


    //
    // Ok, now that we have the entry, let's add it to the appropriate list...
    //
    if ( ObjectInformation->ObjectTypeId == PolicyObject ) {
        ASSERT( DbHandle->ObjectTypeId == PolicyObject );

        if ( CurrentUserEntry->PolicyHandlesCount >= CurrentUserEntry->MaxPolicyHandles ) {

            LsapDsDebugOut(( DEB_HANDLE,
                             "Quota exceeded for user %x:%x, handle 0x%lp\n",
                             UserId->HighPart,
                             UserId->LowPart,
                             NewHandle ));
            Status = STATUS_QUOTA_EXCEEDED;
            goto InsertHandleInTableEntryExit;

        } else {

            InsertTailList( &CurrentUserEntry->PolicyHandles, &DbHandle->UserHandleList );
            CurrentUserEntry->PolicyHandlesCount++;
            PolicyHandleCountIncremented = TRUE;
        }

    } else {
        ASSERT( DbHandle->ObjectTypeId != PolicyObject );

        InsertTailList( &CurrentUserEntry->ObjectHandles, &DbHandle->UserHandleList );
    }

    //
    // Finally, make sure to insert it in the flat list
    //
    DbHandle->Next = LsapDbHandleTable.Next;
    DbHandle->Previous = &LsapDbHandleTable;
    DbHandle->Next->Previous = DbHandle;
    DbHandle->Previous->Next = DbHandle;

    DbHandle->UserEntry = ( PVOID )CurrentUserEntry;
    Status = STATUS_SUCCESS;

InsertHandleInTableEntryExit:

    //
    // If we succesfully created the entry, make sure we remove it...
    //
    if ( !NT_SUCCESS( Status ) && UserAdded ) {

        RemoveEntryList( &DbHandle->UserHandleList );
        if ( PolicyHandleCountIncremented ) {
            CurrentUserEntry->PolicyHandlesCount--;
        }

        if ( CurrentUserEntry->UserToken ) {

            NtClose( CurrentUserEntry->UserToken );
        }

        LsapDbHandleTableEx.UserCount--;
        RemoveEntryList( &CurrentUserEntry->Next );
        LsapFreeLsaHeap( CurrentUserEntry );

    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    LsapExitFunc( "LsapDbInsertHandleInTable", Status );
    return( Status );
}


BOOLEAN
LsapDbFindIdenticalHandleInTable(
    IN OUT PLSAPR_HANDLE OriginalHandle
    )
/*++

Routine Description:

    This routine will find an existing handle in the lsa global policy handle
    table that matches the passed in handle.  If a matching handle is found,
    the passed in handle is dereferenced and the matching handle is returned.

    If no matching handle is found, the original passed in handle is returned.

Arguments:

    OriginalHandle - Passes in the original handle to compare with.
        Returns the handle that is to be used.

Return Value:

    TRUE - Original handle was returned or new handle was returned.

    FALSE - New handle would exceed maximum allowed reference count if it were used.
        Original handle is returned.

--*/
{
    BOOLEAN RetBool = TRUE;
    LSAP_DB_HANDLE InputHandle;
    LSAP_DB_HANDLE DbHandle;
    PLIST_ENTRY HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;

    LsapEnterFunc( "LsapDbFindIndenticalHandleInTable" );

    //
    // Return immediately if the handle isn't a policy handle
    //

    InputHandle = (LSAP_DB_HANDLE) *OriginalHandle;
    if  ( InputHandle->ObjectTypeId != PolicyObject ) {
        LsapExitFunc( "LsapDbFindIdenticalHandleInTable", 0 );
        return TRUE;
    }

    CurrentUserEntry = (PLSAP_DB_HANDLE_TABLE_USER_ENTRY) InputHandle->UserEntry;
    ASSERT( CurrentUserEntry != NULL );

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );



    //
    // If this is not a trusted handle,
    //  try to share the handle.
    //

    if ( !RtlEqualLuid( &CurrentUserEntry->LogonId, &LsapZeroLogonId )  ) {

        //
        // Now, walk the appropriate list to find one for the matching access.
        //

        for ( HandleEntry = CurrentUserEntry->PolicyHandles.Flink;
              HandleEntry != &CurrentUserEntry->PolicyHandles;
              HandleEntry = HandleEntry->Flink ) {

            //
            // See if the access masks match.  If so, we have a winner
            //
            DbHandle = CONTAINING_RECORD( HandleEntry,
                                          struct _LSAP_DB_HANDLE,
                                          UserHandleList );

            //
            // Ignore the original handle
            //

            if ( DbHandle == InputHandle ) {
                /* Do nothing here */


            //
            // The handles are considered identical if the GrantedAccess matches.
            //

            } else if ( DbHandle->GrantedAccess == InputHandle->GrantedAccess ) {

                //
                // Don't let this handle be cloned too many times
                //

                if ( DbHandle->ReferenceCount >= LSAP_DB_MAXIMUM_REFERENCE_COUNT ) {
                    RetBool = FALSE;
                    break;
                }

                DbHandle->ReferenceCount++;


#if DBG
                GetSystemTimeAsFileTime( (LPFILETIME) &DbHandle->HandleLastAccessTime );
#endif // DBG

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Found handle 0x%lp for user %x:%x using access 0x%lx (%ld)\n",
                                 DbHandle,
                                 CurrentUserEntry->LogonId.HighPart,
                                 CurrentUserEntry->LogonId.LowPart,
                                 DbHandle->GrantedAccess,
                                 DbHandle->ReferenceCount ));

                *OriginalHandle = (LSAPR_HANDLE)DbHandle;

                //
                // Dereference the original handle.
                //

                LsapDbDereferenceHandle( (LSAPR_HANDLE)InputHandle );
                break;

            } else {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Handle 0x%lp for user %x:%x has access 0x%lx, need 0x%lx\n",
                                 DbHandle,
                                 CurrentUserEntry->LogonId.HighPart,
                                 CurrentUserEntry->LogonId.LowPart,
                                 DbHandle->GrantedAccess,
                                 InputHandle->GrantedAccess ));

            }
        }
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    LsapExitFunc( "LsapDbFindIdenticalHandleInTable", 0 );
    return RetBool;
}


NTSTATUS
LsapDbRemoveHandleFromTable(
    IN PLSAPR_HANDLE Handle
    )
/*++

Routine Description:

    This routine removes an existing handle from all tables it is in.

    Enter with LsapDbState.HandleTableLock locked.

Arguments:

    Handle - Handle to remove.

Return Value:

    STATUS_SUCCESS - Success

    STATUS_OBJECT_NAME_NOT_FOUND - The handle for the specified user cannot be found

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY HandleList, HandleEntry;
    PLSAP_DB_HANDLE_TABLE_USER_ENTRY CurrentUserEntry = NULL;
    LSAP_DB_HANDLE DbHandle = ( LSAP_DB_HANDLE )Handle, FoundHandle;
    PULONG EntryToDecrement ;

    LsapEnterFunc( "LsapDbRemoveHandleFromTable" );

    CurrentUserEntry = DbHandle->UserEntry;
    ASSERT( CurrentUserEntry != NULL );


    if ( DbHandle->ObjectTypeId == PolicyObject ) {

        HandleList = &CurrentUserEntry->PolicyHandles;
        EntryToDecrement = &CurrentUserEntry->PolicyHandlesCount;

    } else {

        HandleList = &CurrentUserEntry->ObjectHandles;
        EntryToDecrement = NULL ;
    }

    Status = STATUS_NOT_FOUND;

    for ( HandleEntry = HandleList->Flink;
          HandleEntry != HandleList;
          HandleEntry = HandleEntry->Flink ) {


        FoundHandle = CONTAINING_RECORD( HandleEntry,
                                         struct _LSAP_DB_HANDLE,
                                         UserHandleList );

        if ( FoundHandle == DbHandle ) {

            RemoveEntryList( &FoundHandle->UserHandleList );
            FoundHandle->Next->Previous = FoundHandle->Previous;
            FoundHandle->Previous->Next = FoundHandle->Next;

            if ( EntryToDecrement ) {
                *EntryToDecrement -= 1 ;
            }

            //
            // See if we can remove the entry itself
            //
            if ( IsListEmpty( &CurrentUserEntry->PolicyHandles ) &&
                 IsListEmpty( &CurrentUserEntry->ObjectHandles ) ) {

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Removing empty user list 0x%lp\n",
                                 CurrentUserEntry ));

                RemoveEntryList( &CurrentUserEntry->Next );

                LsapDbHandleTableEx.UserCount--;

                if ( CurrentUserEntry->UserToken ) {

                    NtClose( CurrentUserEntry->UserToken );
                }

                LsapDsDebugOut(( DEB_HANDLE,
                                 "Removing user entry 0x%lp\n", CurrentUserEntry ));

                if ( LsapDbHandleTableEx.FreedUserEntryCount < LSAP_DB_HANDLE_FREE_LIST_SIZE ) {

                    LsapDbHandleTableEx.FreedUserEntryList[
                                    LsapDbHandleTableEx.FreedUserEntryCount ] = CurrentUserEntry;
                    LsapDsDebugOut(( DEB_HANDLE,
                                     "Moving user entry 0x%lp to free list spot %lu\n",
                                     CurrentUserEntry,
                                     LsapDbHandleTableEx.FreedUserEntryCount ));
                    LsapDbHandleTableEx.FreedUserEntryCount++;

                } else {

                    LsapFreeLsaHeap( CurrentUserEntry );
                }
            }
            Status = STATUS_SUCCESS;
            break;

        } else {

            LsapDsDebugOut(( DEB_HANDLE,
                             "Looking for user entry 0x%lp against 0x%lp\n",
                             FoundHandle,
                             DbHandle ));
        }
    }


    LsapExitFunc( "LsapDbRemoveHandleFromTable", Status );
    return( Status );
}


NTSTATUS
LsapDbCreateHandle(
    IN PLSAP_DB_OBJECT_INFORMATION ObjectInformation,
    IN ULONG Options,
    IN ULONG CreateHandleOptions,
    OUT LSAPR_HANDLE *CreatedHandle
    )

/*++

Routine Description:

    This function creates and initializes a handle for an LSA Database object.
    The handle is allocated from the LSA Heap and added to the handle table.
    Using the Object Type, and either the Sid or Name provided in
    ObjectInformation, the Logical and Physical Names of the object are
    constructed and pointers to them are stored in the handle.  The LSA
    Database must be locked before calling this function.

    If there is a Container Handle specified in the ObjectInformation, the
    newly created handle inherits its trusted status (TRUE if trusted, else
    FALSE).  If there is no container handle, the trusted status is set
    to FALSE by default.  When a non-trusted handle is used to access an
    object, impersonation and access validation occurs.

Arguments:

    ObjectInformation - Pointer to object information structure which must
        have been validated by a calling routine.  The following information
        items must be specified:

        o Object Type Id
        o Object Logical Name (as ObjectAttributes->ObjectName, a pointer to
             a Unicode string)
        o Container object handle (for any object except the Policy object).
        o Object Sid (if any)
        All other fields in ObjectAttributes portion of ObjectInformation
        such as SecurityDescriptor are ignored.

    Options - Optional actions

        LSAP_DB_TRUSTED - Handle is to be marked as Trusted.
            handle is use, access checking will be bypassed.  If the
            handle is used to create or open a lower level object, that
            object's handle will by default inherit the Trusted property.

        LSAP_DB_NON_TRUSTED - Handle is to be marked as Non-Trusted.

        If neither of the above options is specified, the handle will
        either inherit the trusted status of the Container Handle
        provilde in ObjectInformation, or, if none, the handle will
        be marked non-trusted.

    CreateHandleOptions - Options used to control the behavior of the CreateHandle function.

    CreatedHandle - Where the created handle is returned

Return Value:

    STATUS_SUCCESS -- Success

    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

    STATUS_INVALID_SID - A bogus sid was encountered

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE Handle = NULL;
    PSID Sid = NULL;
    ULONG SidLength;
    BOOLEAN ObjectInReg = TRUE, ObjectInDs = FALSE, NewTrustObject = FALSE;
    HANDLE ClientToken;
    LUID UserId;
    TOKEN_STATISTICS TokenStats;
    ULONG InfoReturned;
    BOOL Locked = FALSE ;
    HANDLE ClientTokenToFree = NULL;

    //
    // First, grab the handle table lock.
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    Locked = TRUE ;


    //
    // Get the current users token, unless we are trusted...
    //

    UserId = LsapZeroLogonId;
    if ( ObjectInformation->ObjectAttributes.RootDirectory == NULL ||
         !( (LSAP_DB_HANDLE)ObjectInformation->ObjectAttributes.RootDirectory )->Trusted ) {

        Status = I_RpcMapWin32Status( RpcImpersonateClient( 0 ) );

        if ( NT_SUCCESS( Status )  ) {

            Status = NtOpenThreadToken( NtCurrentThread(),
                                        TOKEN_QUERY | TOKEN_DUPLICATE,
                                        TRUE,
                                        &ClientToken );

            if ( NT_SUCCESS( Status ) ) {

                Status = NtQueryInformationToken( ClientToken,
                                                  TokenStatistics,
                                                  &TokenStats,
                                                  sizeof( TokenStats ),
                                                  &InfoReturned );

                if ( NT_SUCCESS( Status ) ) {

                    UserId = TokenStats.AuthenticationId;
                }

                ClientTokenToFree = ClientToken;
            }

            RpcRevertToSelf();
        }

    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    Locked = FALSE ;

    //
    // Allocate memory for the new handle from the process heap.
    //

    Handle = LsapAllocateLsaHeap(sizeof(struct _LSAP_DB_HANDLE));

    if (Handle == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto CreateHandleError;
    }

    //
    // Mark the handle as allocated and initialize the reference count
    // to one.  Initialize other fields based on the object information
    // supplied.
    //

    Handle->Allocated = TRUE;
    Handle->KeyHandle = NULL;
    Handle->ReferenceCount = 1;
    Handle->ObjectTypeId = ObjectInformation->ObjectTypeId;
    Handle->ContainerHandle = ( LSAP_DB_HANDLE )ObjectInformation->ObjectAttributes.RootDirectory;
    Handle->Sid = NULL;
    Handle->Trusted = FALSE;
    Handle->DeletedObject = FALSE;
    Handle->GenerateOnClose = FALSE;
    Handle->Options = Options;
    Handle->LogicalNameU.Buffer = NULL;
    Handle->PhysicalNameU.Buffer = NULL;
    Handle->PhysicalNameDs.Buffer = NULL;
    Handle->RequestedAccess = ObjectInformation->DesiredObjectAccess;
    InitializeListHead( &Handle->UserHandleList );
    Handle->UserEntry = NULL;
    Handle->SceHandle = (( Options & LSAP_DB_SCE_POLICY_HANDLE ) != 0 );
    Handle->SceHandleChild = (( ObjectInformation->ObjectAttributes.RootDirectory != NULL ) &&
                              ((( LSAP_DB_HANDLE )ObjectInformation->ObjectAttributes.RootDirectory)->SceHandle ));
#ifdef DBG

    //
    // ScePolicy lock must be held when opening an SCE Policy handle
    //

    if ( Handle->SceHandle ) {

        ASSERT( LsapDbResourceIsLocked( ( PSAFE_RESOURCE )&LsapDbState.ScePolicyLock ));
    }

    RtlZeroMemory( &Handle->HandleLastAccessTime, sizeof( LARGE_INTEGER ) );

    GetSystemTimeAsFileTime( (LPFILETIME) &Handle->HandleCreateTime );

#endif

    //
    // By default, the handle inherits the Trusted status of the
    // container handle.
    //

    if (Handle->ContainerHandle != NULL) {

        Handle->Trusted = Handle->ContainerHandle->Trusted;
    }

    //
    // If Trusted/Non-Trusted status is explicitly specified, set the
    // status to that specified.
    //

    if (Options & LSAP_DB_TRUSTED) {

        Handle->Trusted = TRUE;

    }

    //
    // Capture the object's Logical and construct Physical Names from the
    // Object Information and store them in the handle.  These names are
    // internal to the Lsa Database.  Note that the input Logical Name
    // cannot be directly stored in the handle because it will be in
    // storage that is scoped only to the underlying server API call if
    // the object for which this create handle is being done is of a type
    // that is opened or created by name rather than by Sid.
    //

    //
    // Set the objects location
    //
    Handle->PhysicalNameDs.Length = 0;

    switch ( ObjectInformation->ObjectTypeId ) {

    case TrustedDomainObject:
    case NewTrustedDomainObject:

        ObjectInReg = !LsapDsWriteDs;
        ObjectInDs = LsapDsWriteDs;
        Handle->ObjectTypeId = TrustedDomainObject;
        break;

    case AccountObject:
    case PolicyObject:

        ObjectInReg = TRUE;
        ObjectInDs = FALSE;
        break;

    case SecretObject:

        ObjectInReg = TRUE;
        if ( LsapDsWriteDs && FLAG_ON( Options, LSAP_DB_OBJECT_SCOPE_DS ) ) {

            ObjectInDs = TRUE;
        }

        break;

    }

    Status = LsapDbGetNamesObject( ObjectInformation,
                                   CreateHandleOptions,
                                   &Handle->LogicalNameU,
                                   ObjectInReg ? &Handle->PhysicalNameU : NULL,
                                   ObjectInDs ? &Handle->PhysicalNameDs : NULL );

    if (!NT_SUCCESS(Status)) {

        goto CreateHandleError;
    }

    //
    // Make a copy of the object's Sid and store pointer to it in
    // the handle.
    //

    if (ObjectInformation->Sid != NULL) {

        Sid = ObjectInformation->Sid;

        if (!RtlValidSid( Sid )) {

            Status = STATUS_INVALID_SID;
            goto CreateHandleError;
        }

        SidLength = RtlLengthSid( Sid );

        Handle->Sid = LsapAllocateLsaHeap( SidLength );

        if (Handle->Sid == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto CreateHandleError;
        }

        RtlCopySid( SidLength, Handle->Sid, Sid );
    }

    //
    // Append the handle to the linked list
    //


    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    Locked = TRUE ;

    Status = LsapDbInsertHandleInTable( ObjectInformation,
                                        Handle,
                                        &UserId,
                                        ClientTokenToFree
                                        );
    if ( !NT_SUCCESS( Status ) ) {

        goto CreateHandleError;
    }

    //
    // Increment the handle table count
    //

    LsapDbState.OpenHandleCount++;

CreateHandleFinish:

    if ( ClientTokenToFree ) {

        NtClose( ClientTokenToFree );
    }

    *CreatedHandle = ( LSAPR_HANDLE )Handle;

    LsapDsDebugOut(( DEB_HANDLE, "Handle Created 0x%lp\n",
                    Handle ));

    if ( Locked )
    {
        LsapDbLockRelease( &LsapDbState.HandleTableLock );
    }

    return( Status );

CreateHandleError:

    //
    // If necessary, free the handle and contents.
    //

    if (Handle != NULL) {

        //
        // If a Sid was allocated, free it.
        //

        if (Handle->Sid != NULL) {

            LsapFreeLsaHeap( Handle->Sid );
        }

        //
        // If a Logical Name Buffer was allocated, free it.
        //

        if ((Handle->LogicalNameU.Length != 0) &&
            (Handle->LogicalNameU.Buffer != NULL)) {

            RtlFreeUnicodeString( &Handle->LogicalNameU );
        }

        //
        // If a Physical Name Buffer was allocated, free it.
        //

        if ((Handle->PhysicalNameU.Length != 0) &&
            (Handle->PhysicalNameU.Buffer != NULL)) {

            LsapFreeLsaHeap( Handle->PhysicalNameU.Buffer );
        }

        //
        // Free the handle itself.
        //

        LsapFreeLsaHeap( Handle );
        Handle = NULL;
    }

    Handle = NULL;
    goto CreateHandleFinish;
}


NTSTATUS
LsapDbVerifyHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN ULONG Options,
    IN LSAP_DB_OBJECT_TYPE_ID ExpectedObjectTypeId,
    IN BOOLEAN ReferenceHandle
    )

/*++

Routine Description:

    This function verifies that a handle has a valid address and is of valid
    format.  The handle must be allocated and have a positive reference
    count within the valid range.  The object type id must be within range
    and optionally equal to a specified type.  The Lsa Database must be
    locked before calling this function.

Arguments:

    ObjectHandle - Handle to be validated.

    Options - Specifies optional actions to be taken

        LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES - Allow handles for
            deleted objects to pass the validation.

        Other option flags may be specified.  They will be ignored.

    ExpectedObjectTypeId - Expected object type.  If NullObject is
        specified, the object type id is only range checked.

    ReferenceHandle - True if handle reference count is to be incemented

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid address or handle contents
--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;

    //
    // Lock the handle table.
    //

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );


    //
    // First verify that the handle's address is valid.
    //

    if (!LsapDbLookupHandle( ObjectHandle )) {

        goto VerifyHandleError;
    }

    //
    // Verify that the handle is allocated
    //

    if (!Handle->Allocated) {

        goto VerifyHandleError;
    }

    //
    // If the handle is marked as invalid, return an error unless
    // these are admissible, e.g when validating for a close option
    //

    if (Handle->DeletedObject) {

        if (!(Options & LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES)) {

            goto VerifyHandleError;
        }
    }

    //
    // Verify that the handle contains a non-NULL handle to a Registry
    // Key
    //

    if (!Handle->fWriteDs && Handle->KeyHandle == NULL) {

        goto VerifyHandleError;
    }

    //
    // Now either range-check or match the handle type
    //

    if (ExpectedObjectTypeId == NullObject) {

        if ((Handle->ObjectTypeId < PolicyObject) ||
            (Handle->ObjectTypeId >= DummyLastObject)) {

            goto VerifyHandleError;
        }

    } else {

        ASSERT (ExpectedObjectTypeId >= PolicyObject &&
                ExpectedObjectTypeId < DummyLastObject);

        if (Handle->ObjectTypeId != ExpectedObjectTypeId) {

            //
            // For a secret object, it's possible that we were given a trusted domain
            // handle as well.
            //
            if ( !(ExpectedObjectTypeId == SecretObject &&
                   Handle->ObjectTypeId == TrustedDomainObject &&
                   FLAG_ON( Handle->Options, LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET ) ) ) {

                goto VerifyHandleError;
            }
        }
    }

    //
    // Verify that the handle's reference count is valid and positive
    //

    if (Handle->ReferenceCount == 0) {
        goto VerifyHandleError;
    }

#ifdef LSAP_TRACK_HANDLE
    GetSystemTimeAsFileTime( (LPFILETIME) &Handle->HandleLastAccessTime );
#endif

    Status = STATUS_SUCCESS;

VerifyHandleFinish:

    //ASSERT( Status != STATUS_INVALID_HANDLE );


    //
    // Reference the handle
    //
    if ( ReferenceHandle && NT_SUCCESS(Status) ) {

        //
        // This is an internal reference.
        //  Don't enforce LSAP_DB_MAXIMUM_REFERENCE_COUNT.
        //

        Handle->ReferenceCount++;
        LsapDsDebugOut(( DEB_HANDLE, "Handle Rref 0x%lp (%ld)\n",
                         Handle,
                         Handle->ReferenceCount ));
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );
    return(Status);

VerifyHandleError:
    Status = STATUS_INVALID_HANDLE;
    goto VerifyHandleFinish;
}


BOOLEAN
LsapDbLookupHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function checks if a handle address is valid.  The Lsa Database must
    be locked before calling this function.

Arguments:

    ObjectHandle - handle to be validated.

Return Value:

    BOOLEAN - TRUE if handle is valid. FALSE if handle does not exist or
        is invalid.

--*/

{
    BOOLEAN ReturnValue = FALSE;
    LSAP_DB_HANDLE ThisHandle;

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    //
    // Simply do a linear scan of the small list of handles.  Jazz this
    // up later if needed.
    //

    for (ThisHandle = LsapDbHandleTable.Next;
         ThisHandle != &LsapDbHandleTable && ThisHandle != NULL;
         ThisHandle = ThisHandle->Next) {

        if (ThisHandle == (LSAP_DB_HANDLE) ObjectHandle) {

            ReturnValue = TRUE;
            break;
        }
    }

    ASSERT( ThisHandle );

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return( ReturnValue );
}


NTSTATUS
LsapDbCloseHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function closes an LSA Handle.  The memory for the handle is
    freed.  The LSA database must be locked before calling this function.

    NOTE:  Currently, handles do not have reference counts since they
    are not shared among client threads.

Arguments:

    ObjectHandle - Handle to be closed.

Return Value:

    NTSTATUS - Return code.

--*/

{
    NTSTATUS Status;

    LSAP_DB_HANDLE TempHandle;

    //
    // Verify that the handle exists.  It may be marked invalid
    //

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );
    Status = LsapDbVerifyHandle(
                 ObjectHandle,
                 LSAP_DB_ADMIT_DELETED_OBJECT_HANDLES,
                 NullObject,
                 FALSE );

    if (!NT_SUCCESS(Status)) {
        LsapDbDereferenceHandle( ObjectHandle );
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return Status;
}


BOOLEAN
LsapDbDereferenceHandle(
    IN LSAPR_HANDLE ObjectHandle
    )

/*++

Routine Description:

    This function decrement the reference count on the handle.
    If the reference count is decremented to zero,
    this function unlinks a handle and frees its memory.  If the handle
    contains a non-NULL Registry Key handle that handle is closed.

Arguments:

    ObjectHandle - handle to be dereferenced

Return Value:

    TRUE if the reference count reached zero.

--*/

{
    NTSTATUS Status;
    LSAP_DB_HANDLE Handle = (LSAP_DB_HANDLE) ObjectHandle;
    BOOLEAN RetVal = FALSE;

    //
    // Dereference the handle
    //
    LsapDbLockAcquire( &LsapDbState.HandleTableLock );
    Handle->ReferenceCount --;
    if ( Handle->ReferenceCount != 0 ) {

        LsapDsDebugOut(( DEB_HANDLE, "Handle Deref 0x%lp %ld\n",
                        Handle,
                        Handle->ReferenceCount ));
        goto Cleanup;
    }

    //
    // Avoid freeing the global policy handle
    //
    if ( ObjectHandle == LsapPolicyHandle ) {

        ASSERT( Handle->ReferenceCount != 0 );
        if ( Handle->ReferenceCount == 0 ) {
            Handle->ReferenceCount++;
        }
#ifdef DBG
        DbgPrint("Freeing global policy handle\n");
#endif
        goto Cleanup;
    }

    LsapDsDebugOut(( DEB_HANDLE, "Handle Freed 0x%lp\n",
                    Handle ));

    //
    // Unhook the handle from the linked list
    //
    Status = LsapDbRemoveHandleFromTable( ObjectHandle );
    if ( !NT_SUCCESS( Status ) ) {
        DbgPrint( "LSASRV:Failed to remove handle 0x%lp from the global table!\n", ObjectHandle );
        goto Cleanup;
    }



    //
    // Free the Registry Key Handle (if any).
    //

    if (Handle->KeyHandle != NULL) {

        Status = NtClose(Handle->KeyHandle);
        ASSERT(NT_SUCCESS(Status));
        Handle->KeyHandle = NULL;
    }

    //
    // Audit that we're closing the handle
    //

    Status = NtCloseObjectAuditAlarm (
                    &LsapState.SubsystemName,
                    ObjectHandle,
                    Handle->GenerateOnClose );

    if (!NT_SUCCESS( Status )) {
        LsapAuditFailed( Status );
    }

    //
    // Mark the handle as not allocated.
    //

    Handle->Allocated = FALSE;

    //
    // Free fields of the handle
    //

    if (Handle->LogicalNameU.Buffer != NULL) {

        RtlFreeUnicodeString( &Handle->LogicalNameU );
    }

    if (Handle->PhysicalNameU.Buffer != NULL) {

        LsapFreeLsaHeap( Handle->PhysicalNameU.Buffer );
    }

    if (Handle->PhysicalNameDs.Buffer != NULL) {

        LsapFreeLsaHeap( Handle->PhysicalNameDs.Buffer );
    }

    if (Handle->Sid != NULL) {

        LsapFreeLsaHeap( Handle->Sid );
    }

    if (Handle->SceHandle) {

#ifdef DBG
        ASSERT( WAIT_TIMEOUT == WaitForSingleObject( LsapDbState.SceSyncEvent, 0 ));
        ASSERT( g_ScePolicyLocked );
        g_ScePolicyLocked = FALSE;
#endif

        RtlReleaseResource( &LsapDbState.ScePolicyLock );
        SetEvent( LsapDbState.SceSyncEvent );
    }

    //
    // Decrement the count of open handles.
    //

    ASSERT(LsapDbState.OpenHandleCount > 0);
    LsapDbState.OpenHandleCount--;

#ifdef LSAP_TRACK_HANDLE
    if ( Handle->ClientToken ) {

        NtClose( Handle->ClientToken );
    }
#endif

    //
    // Free the handle structure itself

    LsapFreeLsaHeap( ObjectHandle );
    RetVal = TRUE;

Cleanup:
    LsapDbLockRelease( &LsapDbState.HandleTableLock );

    return RetVal;

}


NTSTATUS
LsapDbMarkDeletedObjectHandles(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MarkSelf
    )

/*++

Routine Description:

    This function invalidates open handles to an object.  It is used
    by object deletion code.  Once an object has been deleted, the only
    operation permitted on open handles remaining is to close them.

Arguments:

    ObjectHandle - Handle to an Lsa object.

    MarkSelf -  If TRUE, all handles to the object will be marked to
        indicate that the object to which they relate has been deleted.
        including the passed handle.  If FALSE, all handles to the object
        except the passed handle will be so marked.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE ThisHandle;
    LSAP_DB_HANDLE Handle = ObjectHandle;

    LsapDbLockAcquire( &LsapDbState.HandleTableLock );

    ThisHandle = LsapDbHandleTable.Next;

    while (ThisHandle != &LsapDbHandleTable) {

        //
        // Match on Object Type Id.
        //

        if (ThisHandle->ObjectTypeId == Handle->ObjectTypeId) {

            //
            // Object Type Id's match.  If the Logical Names also
            // match, invalidate the handle unless the handle is the
            // passed one and we're to leave it valid.
            //

            if (RtlEqualUnicodeString(
                    &(ThisHandle->LogicalNameU),
                    &(Handle->LogicalNameU),
                    FALSE
                    )) {

                if (MarkSelf || ThisHandle != (LSAP_DB_HANDLE) ObjectHandle) {

                    ThisHandle->DeletedObject = TRUE;
                }
            }
        }

        ThisHandle = ThisHandle->Next;
    }

    LsapDbLockRelease( &LsapDbState.HandleTableLock );


    return(Status);
}


NTSTATUS
LsapDbObjectNameFromHandle(
    IN LSAPR_HANDLE ObjectHandle,
    IN BOOLEAN MakeCopy,
    IN LSAP_DB_OBJECT_NAME_TYPE ObjectNameType,
    OUT PLSAPR_UNICODE_STRING ObjectName
    )

/*++

Routine Description:

    This function retrieves a name from an Lsa Object Handle.  The handle
    is assumed to be valid and the Lsa Database lock should be held while
    calling this function.

Arguments

    ObjectHandle - A handle to the object

    MakeCopy - TRUE if a copy of the object name Unicode buffer is
        to be allocated via MIDL_user_allocate, else FALSE.

    ObjectNameType - Specifies the type of obejct name to be returned.

        LsapDbObjectPhysicalName - Return the Physical Name
        LsapDbObjectLogicalName - Return the Logical Name

    ObjectName - Pointer to Unicode String structure which will be
        initialized to point to the object name.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS  The call completed successfully

        STATUS_NO_MEMORY - Insufficient memory to allocate the buffer
            for a copy of the object name when MakeCopy = TRUE.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_HANDLE InternalHandle = (LSAP_DB_HANDLE) ObjectHandle;
    LSAPR_UNICODE_STRING OutputObjectName;
    PLSAPR_UNICODE_STRING SourceName = NULL;

    //
    //  Copy over the name.
    //

    switch (ObjectNameType) {

    case LsapDbObjectPhysicalName:

        SourceName = (PLSAPR_UNICODE_STRING) &InternalHandle->PhysicalNameU;
        break;

    case LsapDbObjectLogicalName:

        SourceName = (PLSAPR_UNICODE_STRING) &InternalHandle->LogicalNameU;
        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto ObjectNameFromHandleError;
    }

    OutputObjectName = *SourceName;

    //
    // If a copy was requested, allocate memory
    //

    if (MakeCopy) {

        OutputObjectName.Buffer = MIDL_user_allocate( OutputObjectName.MaximumLength );

        Status = STATUS_NO_MEMORY;

        if (OutputObjectName.Buffer == NULL) {

            goto ObjectNameFromHandleError;
        }

        Status = STATUS_SUCCESS;

        RtlMoveMemory(
            OutputObjectName.Buffer,
            SourceName->Buffer,
            SourceName->Length
            );
    }

    *ObjectName = OutputObjectName;

ObjectNameFromHandleFinish:

    return(Status);

ObjectNameFromHandleError:

    ObjectName->Buffer = NULL;
    ObjectName->Length = ObjectName->MaximumLength = 0;
    goto ObjectNameFromHandleFinish;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinit.c

Abstract:

    Local Security Authority - Database Server Initialization

    This module contains functions which perform initialization of
    the Database Server.  Certain information is obtained from the
    LSA database and is set up in global data for easy retrieval.

Author:

    Scott Birrell       (ScottBi)       July 25, 1991

Environment:

    User Mode

Revision History:

    12-Nov-1997         MikeSw
        Added lsa policy handle cache for interdomain lookups

--*/


//
// Define this to allocate all globals in this module
//

#include <lsapch2.h>
#include "lsasrvp.h"
#include "dbp.h"
#include <bndcache.h>
#include <wincrypt.h>
#include <lsapmsgs.h>
#include <ntddnfs.h>
#include <remboot.h>
#ifdef DS_LOOKUP
#include <dslookup.h>
#endif
#include <sertlp.h>
#include <cryptdll.h>
#include <md5.h>
#include <rc4.h>
#include <wxlpc.h>
#include <dnsapi.h>

extern LSAP_DB_TRUSTED_DOMAIN_LIST LsapDbTrustedDomainList;


NTSTATUS
LsapDbBuildObjectCaches(
    );

NTSTATUS
LsapAssignInitialHiveProtection(
    HANDLE HiveRoot
    );

NTSTATUS
LsapCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    );

NTSTATUS
LsapGenerateRandomDomainSid(
    OUT PSID NewDomainSid
    );

NTSTATUS
LsapSetupInitialize(
    VOID
    );

NTSTATUS
LsapUpdateDatabaseProtection(
    IN ULONG Revision
    );

NTSTATUS
LsapDsInitFixupQueue(
    VOID
    );

static  UCHAR SyskeyBuffer[LSAP_SYSKEY_SIZE];
static  UCHAR OldSyskeyBuffer[LSAP_SYSKEY_SIZE];


NTSTATUS
LsapDbInitializeServer(
    IN ULONG Pass
    )
/*++

Routine Description:

    This function initializes the LSA Database Server.  The following
    steps are performed:

    o Initialize the LSA Database Lock
    o Acquire the LSA Database Lock
    o Initialize the Unicode Strings for the fixed names within the
      LSA Database, e.g. LSA Database object attributes and well-known
      object names.
    o Initialize the Unicode Strings for the LSA Database Object constant
      and well known names, e.g SubKeys, fixed object names.
    o Initialize the Unicode Strings for LSA Object Containing Dirs
    o Initialize the Generic Mappings for Database Object Types
    o Initialize the Lsa Database Handle Table
    o Install the LSA Database if necessary - Creates the Lsa Database
    o    and Manager account objects, and initializes the transaction
         subtree
    o Initialize the abs min, abs max and installation default quota limits
    o Release the LSA Database Lock

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, IgnoreStatus;
    BOOL BooleanStatus = TRUE;
    BOOLEAN AcquiredLock = FALSE;
    BOOLEAN FreeComputerName = FALSE;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    PLSAPR_POLICY_ACCOUNT_DOM_INFO PolicyAccountDomainInfo = NULL;
    PLSAPR_POLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;
    UNICODE_STRING ComputerName, CipherKey;
    ULONG Length;
    ULONG Revision, RevisionLength = sizeof( ULONG );
    DWORD WinStatus;

    //
    // Initialize the LSA Database Lock and set it into the locked state
    //

    if (Pass == 1 ) {

        LsapDsDebugInitialize();

        RtlZeroMemory( &LsaDsStateInfo, sizeof( LsaDsStateInfo ) );
        LsapDbState.DbServerInitialized = FALSE;
#if DBG
        LsapDbState.RegistryTransactionOpen = FALSE;
#endif

        //
        // Disable Replicator Notifications.
        //

        LsapDbDisableReplicatorNotification();

        //
        // This function call will initialize all of the global or well known locks used by
        // the Lsa
        //
        Status = LsapDbInitializeLock();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        Status = LsapDbInitHandleTables();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Initialize the forest trust cache.
        // The cache is not usable until populated.
        //
        Status = LsapForestTrustCacheInitialize();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Initialize the policy change notification mechanism
        //
        Status = LsapInitializeNotifiyList();
        if ( !NT_SUCCESS( Status ) ) {
            goto InitializeServerError ;
        }

        //
        // Initialize the Fixup queue
        //

        Status = LsapDsInitFixupQueue();
        if ( !NT_SUCCESS( Status ))
        {
            goto InitializeServerError ;
        }

        //
        // Initialize the binding handle cache
        //
        Status = LsapInitBindingCache();
        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

#ifdef DS_LOOKUP
        Status = LsapDsLookupInitializeLookupTable( NULL );

        if ( !NT_SUCCESS( Status ) ) {

            goto InitializeServerError;
        }
#endif

    }

    //
    // Acquire the LSA Database Lock.  This allows subroutines to
    // assert that the LSA Database is locked.  Otherwise, it is
    // not actually necessary, given that no other thread can access the
    // LSA until initialization is complete.
    //

    if (Pass == 1) {

        //
        // Initialize the Unicode Strings for the fixed names within the
        // LSA Database, e.g. LSA Database object attributes and well-known
        // object names.
        //

        Status = LsapDbInitializeUnicodeNames();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the Unicode Strings for the Containing Directories for
        // each LSA Database Object Type.
        //

        Status = LsapDbInitializeContainingDirs();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the LSA Subsystem name string.  This is needed for
        // NtAccessCheckAuditAlarm calls
        //

        RtlInitUnicodeString(&LsapState.SubsystemName, L"LSA");

        //
        // Initialize the Shutdown Pending state.
        //

        LsapState.SystemShutdownPending = FALSE;

        //
        // Initialize the Database Object Types.  Information stored
        // includes the Generic mappings and Object Counts.
        //

        Status = LsapDbInitializeObjectTypes();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Open the LSA Database root Registry subkey.  This stays
        // open for use in adding transactions.
        //

        Status = LsapDbOpenRootRegistryKey();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the Lsa Database Cipher Key
        //
        RtlInitUnicodeString( &CipherKey, L"823543" );

        Status = LsapDbInitializeCipherKey( &CipherKey,
                                            &LsapDbCipherKey );

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the LSA Database Transaction Subtree, creating it if
        // one does not already exist.  If the Transaction Subtree exists,
        // commit any partially committed transaction if appropriate.
        //

        Status = RtlInitializeRXact(
                     LsapDbState.DbRootRegKeyHandle,
                     TRUE,
                     (PRTL_RXACT_CONTEXT *) &LsapDbState.RXactContext
                     );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_RXACT_STATE_CREATED) {

                LsapLogError(
                    "LsapDbInitializeServer: Registry Transaction Init returned 0x%lx\n",
                    Status
                    );

                goto InitializeServerError;
            }

            LsapLogError(
                "LsapDbInitializeServer: Registry Transaction State Did Not Exist\n",
                Status
                );

            goto InitializeServerError;
        }

        //
        // Setup attributes for opening the Policy object.
        //

        ObjectInformation.ObjectTypeId = PolicyObject;
        ObjectInformation.ContainerTypeId = 0;
        ObjectInformation.Sid = NULL;
        ObjectInformation.ObjectAttributeNameOnly = FALSE;
        ObjectInformation.DesiredObjectAccess = 0;

        InitializeObjectAttributes(
            &ObjectInformation.ObjectAttributes,
            &LsapDbNames[Policy],
            0L,
            NULL,
            NULL
            );

        //
        // Now try to open the root LSA Database object (Policy).  This is a
        // trusted call, so no access checking or impersonation will be done.
        // Note that the handle obtained will remain open indefinitely.  It is
        // used after initialization for all internally generated accesses to
        // the Policy object
        //

        Status = LsapDbOpenObject(
                     &ObjectInformation,
                     0L,
                     LSAP_DB_TRUSTED,
                     &LsapDbHandle
                     );

        if (!NT_SUCCESS(Status)) {

            //
            // Open of LSA Database object failed.  If any error other than
            // object not found, there is a serious error which prevents the
            // LSA from functioning, so abort.
            //

            if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

                LsapLogError(
                    "LsapDbInitializeServer: Open failed 0x%lx\n"
                    "The Lsa Database must be reinstalled or manually\n"
                    "erased before using the system\n",
                    Status
                    );

                goto InitializeServerError;
            }

            //
            // The Lsa Database object was not found.  Run the database installation
            // routine so that people can boot without having to run the
            // installation applet first.
            //

            LsapDatabaseSetupPerformed = TRUE;

            Status = LsapDbInstallLsaDatabase(1);

            if (!NT_SUCCESS(Status)) {

                goto InitializeServerError;
            }
        }

        //
        // The Lsa Database object was successfully opened, possibly after
        // having just been created.  Proceed with the rest of server
        // initialization.  First, setup in-memory copies of the Installation
        // Default, Absolute Min and Absolute Max system quota limits.
        //

        //
        // Make the policy handle available throughout LSA
        //

        LsapPolicyHandle = LsapDbHandle;


        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }


        //
        // Bring the database up to the current revision level,
        // if necessary. This is not a syskey upgrade.
        //

        Status = LsapDbUpgradeRevision(FALSE,FALSE);
        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Read the revision attribute. If the revision is greater than
        // LSAP_DB_REVSION_1_5 then obtain the syskey from winlogon. In previous
        // revisions SAM would have obtained the syskey from winlogon if the machine
        // had been syskey'd
        //


        Status = LsapDbReadAttributeObject(
                     LsapDbHandle,
                     &LsapDbNames[PolRevision],
                     (PVOID) &Revision,
                     &RevisionLength
                     );

        if ( !NT_SUCCESS(Status) ) {
            goto InitializeServerError;
        }

        //
        // Query the syskey from winlogon. Do so only if the revision is greater than 1_5.
        // This is because in previous builds SAM used to manage the syskey. From this
        // release onwards. The below routine also intializes the LSA encryption key
        //

        if (Revision >= LSAP_DB_REVISION_1_5)
        {
            Status = LsapDbGetSyskeyFromWinlogon();
            if (!NT_SUCCESS(Status))
            {
                goto InitializeServerError;
            }
        }

        //
        // Initialize privilege object related code
        //

        Status = LsapDbInitializePrivilegeObject();

        if (!NT_SUCCESS(Status)) {
            goto InitializeServerError;
        }

        //
        // Perform initialization for the Replicator.  Replications
        // are still disabled at this point.
        //

        Status = LsapDbInitializeReplication();
        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Initialize the data for the new APIs (user rights)
        //

        Status = LsapDbInitializeRights();
        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

    } else if (Pass == 2) {

        BOOLEAN ExpectTrue;
        OSVERSIONINFOEX OsVersionInfoEx = { 0 };

        //
        // Perform the second stage of database initialization.
        // This is the initialization that depends on the product type.
        // First, get the product type.  Note that the Product Type may
        // have already been retrieved from a number of routines that
        // may be called during early installation, including
        // LsarSetInformationPolicy() and LsarCreateTrustedDomain().
        //

        ExpectTrue = RtlGetNtProductType(&LsapProductType);
        ASSERT( ExpectTrue == TRUE );


        //
        // find out the product suite mask.
        // this is used later to determine if we are running
        // on a specific product suite such the small business server
        //
        OsVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        ExpectTrue = (BOOLEAN) GetVersionEx((OSVERSIONINFO*) &OsVersionInfoEx);
        ASSERT( ExpectTrue == TRUE );
        LsapProductSuiteMask = OsVersionInfoEx.wSuiteMask;


        //
        // If necessary, install the rest of our database.
        //

        if (LsapDatabaseSetupPerformed == TRUE) {

            Status = LsapDbInstallLsaDatabase(2);

            if (!NT_SUCCESS(Status)) {
                goto InitializeServerError;
            }
        }

        //
        // If this is a Win Nt product, set the SAM Accounts Domain
        // Name equal to the Computer Name, which may have been changed
        // since the last boot.
        //

        //
        // If this is setup, do nothing, since we've set it elsewhere..
        // If this is safe mode mode, don't set it either
        //
        if ( !LsaISetupWasRun() ) {
            if ( ((LsapProductType == NtProductWinNt) ||
                (LsapProductType == NtProductServer)) &&
                !LsaISafeMode() ) {

                Status = LsarQueryInformationPolicy(
                             LsapPolicyHandle,
                             PolicyAccountDomainInformation,
                             (PLSAPR_POLICY_INFORMATION *) &PolicyAccountDomainInfo
                             );

                if (!NT_SUCCESS(Status)) {
                    goto InitializeServerError;
                }

                Length = (ULONG) 0;

                ComputerName.Buffer = UNICODE_NULL;
                FreeComputerName = FALSE;

                BooleanStatus = GetComputerNameW(
                                    (LPWSTR) ComputerName.Buffer,
                                    (LPDWORD) &Length
                                    );

                WinStatus = GetLastError();

                if (WinStatus != ERROR_BUFFER_OVERFLOW) {

                    KdPrint(("LsapDbInitializeServer: Failed to get Computer Name Length\n"
                         "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                    Length = (ULONG) ComputerName.Length;

                } else if (Length <= 1) {

                    KdPrint(("LsapDbInitializeServer: Null Computer Name\n"
                         "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                    Length = (ULONG) ComputerName.Length;


                } else {

                    ComputerName.Length = (USHORT) ((Length - 1) * sizeof (WCHAR));
                    ComputerName.MaximumLength = (USHORT) (Length * sizeof(WCHAR));
                    ComputerName.Buffer = MIDL_user_allocate( ComputerName.MaximumLength );

                    if ( ComputerName.Buffer == NULL ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        goto InitializeServerError;
                    }

                    FreeComputerName = TRUE;
                }

                if (!GetComputerNameW(
                        (LPWSTR) ComputerName.Buffer,
                        (LPDWORD) &Length
                        )) {

                    KdPrint(("LsapDbInitializeServer: Failed to get Computer Name\n"
                             "Using default MACHINENAME instead\n"));

                    RtlInitUnicodeString( &ComputerName, LSAP_DB_DEFAULT_COMPUTER_NAME );
                }

                PolicyAccountDomainInfo->DomainName = *((PLSAPR_UNICODE_STRING) &ComputerName);

                Status = LsarSetInformationPolicy(
                             LsapPolicyHandle,
                             PolicyAccountDomainInformation,
                             (PLSAPR_POLICY_INFORMATION) PolicyAccountDomainInfo
                             );

                if ( FreeComputerName ) {

                    MIDL_user_free( ComputerName.Buffer );
                }

                if (!NT_SUCCESS(Status)) {

                    goto InitializeServerError;
                }
            }

            Status = RpcMgmtEnableIdleCleanup();

            if ( !NT_SUCCESS( Status )) {

                goto InitializeServerError;
            }

        } else {

            Status = LsapSetupInitialize();
            if (!NT_SUCCESS(Status)) {

                goto InitializeServerError;
            }
        }

        // Perform initialization for Lookup Sids and Names, including
        // initialization of the Trusted Domain List.
        //

        Status = LsapDbLookupInitialize();

        if (!NT_SUCCESS(Status)) {

            goto InitializeServerError;
        }

        //
        // Load the object caches.  Any that fail to load have caching
        // permanently turned off.
        //

        IgnoreStatus = LsapDbBuildObjectCaches();

        //
        // Find out if this machine is a DC in a root domain
        //

        Status = LsapDbQueryInformationPolicy(
                     LsapPolicyHandle,
                     PolicyDnsDomainInformation,
                     ( PLSAPR_POLICY_INFORMATION * )&PolicyDnsDomainInfo
                     );

        if ( !NT_SUCCESS( Status )) {

            goto InitializeServerError;
        }

        if ( DnsNameCompareEqual == DnsNameCompareEx_W(
                                        PolicyDnsDomainInfo->DnsDomainName.Buffer,
                                        PolicyDnsDomainInfo->DnsForestName.Buffer,
                                        0 )) {

            DcInRootDomain = TRUE;

        } else {

            DcInRootDomain = FALSE;
        }

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            ( PLSAPR_POLICY_INFORMATION )PolicyDnsDomainInfo
            );

        //
        // Mark the Server as being completely initialized.
        //

        LsapDbState.DbServerInitialized = TRUE;

        //
        // Enable Replicator Notifications on DCs only.
        //

        // if (LsapProductType == NtProductLanManNt) {
            LsapDbEnableReplicatorNotification();
        // }
    }

InitializeServerFinish:

    return(Status);

InitializeServerError:

    goto InitializeServerFinish;
}



NTSTATUS
LsapDbUpgradeRevision(
    IN BOOLEAN SyskeyUpgrade,
    IN BOOLEAN GenerateNewSyskey
    )

/*++

Routine Description:

    This function brings the LSA policy database up to date if necessary.

Arguments:

    SyskeyUpgrade -- This paramter is set to true when this function is called a second
                     time around when upgrading NT4 or Win2K B3 machines from LsaIHealthCheck

    GenerateNewSyskey -- This parameter is set to true when this function is called a second
                         time around when upgrading NT4 or Win2k B3 machines from LsaIHealthCheck
                         and the system is not already syskey'd

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;

    ULONG Revision = LSAP_DB_REVISION_1_0, RevisionLength = sizeof( ULONG );

    LSAP_DB_ATTRIBUTE Attributes[20];

    PLSAP_DB_ATTRIBUTE NextAttribute;

    ULONG AttributeCount = 0;
    BOOLEAN PolRevisionWritten = FALSE;

    NextAttribute = Attributes;

    //
    // Read the Revision Info from the PolRevision attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolRevision],
                 (PVOID) &Revision,
                 &RevisionLength
                 );

    if ( !NT_SUCCESS(Status) ) {
        Revision = LSAP_DB_REVISION_1_0;
        if (Status == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // attribute doesn't exist.
            // This means the database is an NT1.0 format.
            // Upgrade it to the current revision.
            //

            Status = STATUS_SUCCESS;
        }
    }



    //
    // Revison 1_1 created the ModifiedIdAtLastPromotion attribute on the policy object.
    // This attribute is no longer used for anything so don't create it.
    //

    //
    // Revision 1_2 corresponded to an encryption of secrets that shipped with NT4 that was
    // incompatible with NT5. Therefore skip this revision level. The incompatible encryption
    // of secrets would be handled by revision number update
    //



    //
    // Update the security descriptor to revision 1.3
    //

    if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_3) ) {

        Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_3 );

        if ( NT_SUCCESS( Status ) ) {

            Revision = LSAP_DB_REVISION_1_3;

            if ( !PolRevisionWritten ) {

                LsapDbInitializeAttribute(
                    NextAttribute,
                    &LsapDbNames[PolRevision],
                    &Revision,
                    sizeof (ULONG),
                    FALSE
                    );

                NextAttribute++;
                AttributeCount++;
                PolRevisionWritten = TRUE;

                ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );

            }

        } else {

            Status = STATUS_SUCCESS;
        }
    }


    if ( NT_SUCCESS( Status )  && (Revision < LSAP_DB_REVISION_1_5) && (SyskeyUpgrade)) {

        BOOLEAN                IsUpgrade = FALSE;
        PVOID                  Syskey = NULL;
        ULONG                  SyskeyLength = 0;
        LSAP_DB_ENCRYPTION_KEY NewEncryptionKey;



        //
        // NT4 SP4 shipped with an encryption of secret's that is incompatible with
        // NT5 if the syskey'd setting was turned on.
        // Therefore we walk over all secrets and patch them back. It is not necessary
        // that we have all the key's setup at this point. The way this works is we attempt,
        // to patch back all the secrets, and if we did not have the right key to decrypt them
        // we will error out. In Syskey'd machines , SAM will have the right key and will call back
        // into LSA when it has obtained the key. During SAM's callback this routine will be executed
        // again and we will call upgrade all secrets.
        //

        // This upgrade involves a secret upgrade only.  We simply have to read them and
        // write them back out and everything will be kosher...
        // Note if the secret upgrade fails for any reason, we will not update the database revision.
        //

        //
        // First obtain the syskey from the SAM hive. Admittedly and ahsamedly this does read the SAM
        // hive directly
        //


        //
        // If we are a syskey'd machine the syskey should have been passed to us by now.
        //

        ASSERT((NULL!=LsapDbSysKey) || (GenerateNewSyskey));

        //
        // Initialize the key for secret encryption
        //

        Status = LsapDbGenerateNewKey(
                    &NewEncryptionKey
                    );

        if (NT_SUCCESS(Status))
        {

            if (GenerateNewSyskey)
            {
                ULONG SyskeyLength = sizeof(SyskeyBuffer);

                // Boot option is WxStored.
                NewEncryptionKey.BootType = WxStored;

                //
                // A new syskey is being generated
                //

                Status =  LsapDbSetupInitialSyskey(
                                &SyskeyLength,
                                &LsapDbSysKey
                                );


            }
            else
            {
                //
                // Since we are upgrading from a syskey'd machine, get the boot option from SAM
                // SAM is initialized enough at this point as it makes the callout to LSA supplying it with
                // the syskey. It is O.K to pass in a value of 0, because then the default account domain
                // is used.
                //

                Status = SamIGetBootKeyInformation(
                                (SAMPR_HANDLE) 0,
                                 (SAMPR_BOOT_TYPE*)&NewEncryptionKey.BootType
                                 );
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Setup the secret cipher key
            // Ordinarily, the key used for reading equals the key used for writing
            //

            LsapDbInitializeSecretCipherKeyRead( &NewEncryptionKey );
            LsapDbInitializeSecretCipherKeyWrite( &NewEncryptionKey );

            //
            // Encrypt the key with syskey
            //

            LsapDbEncryptKeyWithSyskey(
                        &NewEncryptionKey,
                        LsapDbSysKey,
                        LSAP_SYSKEY_SIZE
                        );

            LsapDbInitializeAttribute(
                NextAttribute,
                &LsapDbNames[PolSecretEncryptionKey],
                &NewEncryptionKey,
                sizeof (NewEncryptionKey),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;
        }

        //
        // The secret upgrade is executed only during GUI setup upgrade of a workstation, or a DC being upgraded
        // from NT4. In all other cases we simply patch the revision number up to the correct value.
        //

        if ((NT_SUCCESS(Status)) && ( (SamIIsDownlevelDcUpgrade()) ||
             ((LsapProductType != NtProductLanManNt) && (SamIIsSetupInProgress(&IsUpgrade)) && (IsUpgrade))))
        {
            //
            // Ignore the return code below, we still want to move the revision
            // level to 1.5, and this code will not be retried anyways
            //

            LsapDbUpgradeSecretForKeyChange();
        }

        if ( NT_SUCCESS( Status ) ) {

            Revision = LSAP_DB_REVISION_1_5;

            if ( !PolRevisionWritten ) {

                LsapDbInitializeAttribute(
                    NextAttribute,
                    &LsapDbNames[PolRevision],
                    &Revision,
                    sizeof (ULONG),
                    FALSE
                    );

                NextAttribute++;
                AttributeCount++;
                PolRevisionWritten = TRUE;

                //
                // Revision is now 1.5
                //

                ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            }
        }
    }



    //
    // Only upgrade past revision 1.5 if we've upgraded to revison 1.5.
    //
    // We don't upgrade to revision 1.5 in the mainline LSA initialization code.
    // Rather, we upgrade to revision 1.5 in a callback from SAM.  If then we moved on
    // to revisions greater than 1.5 during LSA initialization, we'd never have a chance to
    // do the revision 1.5 upgrade code.
    //

    if ( Revision >= LSAP_DB_REVISION_1_5 ) {

        //
        // Update the security descriptor to revision 1.6
        //

        if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_6) ) {

            Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_6 );
            if ( NT_SUCCESS( Status ) ) {

                Revision = LSAP_DB_REVISION_1_6;

                if ( !PolRevisionWritten ) {

                    LsapDbInitializeAttribute(
                        NextAttribute,
                        &LsapDbNames[PolRevision],
                        &Revision,
                        sizeof (ULONG),
                        FALSE
                        );

                    NextAttribute++;
                    AttributeCount++;
                    PolRevisionWritten = TRUE;

                    //
                    // Revision is now 1.6
                    //

                    ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );

                }

            } else {

                Status = STATUS_SUCCESS;
            }
        }

        //
        // Update the security descriptor to revision 1.7
        //

        if ( NT_SUCCESS( Status ) && (Revision < LSAP_DB_REVISION_1_7) ) {

            Status = LsapUpdateDatabaseProtection( LSAP_DB_REVISION_1_7 );
            if ( NT_SUCCESS( Status ) ) {

                Revision = LSAP_DB_REVISION_1_7;

                if ( !PolRevisionWritten ) {

                    LsapDbInitializeAttribute(
                        NextAttribute,
                        &LsapDbNames[PolRevision],
                        &Revision,
                        sizeof (ULONG),
                        FALSE
                        );

                    NextAttribute++;
                    AttributeCount++;
                    PolRevisionWritten = TRUE;

                    //
                    // Revision is now 1.7
                    //

                    ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );

                }

            } else {

                Status = STATUS_SUCCESS;
            }
        }


        //
        // In the future, revision updates can be made
        // by adding "if" blocks similar to the one above.
        //
        // Remember, however, that the attributes are pointing
        // to values in local variables.  Any local variable
        // value changed before the attribute is written out
        // will cause that attribute value to be changed.
        //
        //
    }


    //
    // Now write out all attributes that have been added (if any)
    //

    if (AttributeCount > 0) {

        Status = LsapDbReferenceObject(
                    LsapDbHandle,
                    0,
                    PolicyObject,
                    PolicyObject,
                    LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                    );

        if (NT_SUCCESS(Status)) {

            ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            Status = LsapDbWriteAttributesObject(
                         LsapDbHandle,
                         Attributes,
                         AttributeCount
                         );

            //
            // No attributes are replicatable.
            //  (That's good, too, since SAM hasn't told Netlogon our role yet.)

            Status = LsapDbDereferenceObject(
                         &LsapDbHandle,
                         PolicyObject,
                         PolicyObject,
                         (LSAP_DB_LOCK |
                            LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_OMIT_REPLICATOR_NOTIFICATION ),
                         SecurityDbChange,
                         Status
                         );
        }
    }

    return( Status );
}


NTSTATUS
LsapDbBuildObjectCaches(
    )

/*++

Routine Description:

    This function builds caches for Lsa objects.  These caches contain a
    subset of the information for some object types.

Arguments:

    None

Return Values:

    NTSTATUS - Standard Nt Result Code.

--*/

{
    NTSTATUS IgnoreStatus;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    //
    // Initialize all the caches.
    //

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId <= SecretObject;
         ObjectTypeId++) {

        IgnoreStatus = LsapDbRebuildCache( ObjectTypeId );
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapDbInitializeObjectTypes(
    )

/*++

Routine Description:

    This function initializes the information pertinent to each object
    type in the LSA Database.  This information includes the following:

    o Generic Mapping Arrays

    The Generic Mapping array for each object defines the list of
    object-type-specific access types that correspond to the generic
    access types GENERIC_READ, GENERIC_WRITE, GENERIC_EXECUTE and
    GENERIC_ALL for the object type.

    o Object Count Information

    The Object Count Information includes a count of the number of objects
    that exist for each type, the upper limit on this number (if any) for
    each object type, and the error code to return when that limit is
    reached.

    o Write Operation Masks

    These specify which access types are update operations

    o Default accesses granted to World and Admin aliases

    o Invalid access masks for each object type

    These masks specify the bits in an access mask that are invalid for
    a given object type.

    o Initial owners of each object type

    o Object caching supported for each object type.



Arguments:

    None. The Generic Mapping arrays are held the LsapDbState structure.

Return Value:

    NTSTATUS - Standard Nt Result Code.  Currently, there are no error
        situations in this code, so STATUS_SUCCESS is always returned.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PGENERIC_MAPPING GenericMapping;
    PLSAP_DB_OBJECT_TYPE ObjectType;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    //
    // Initialize the Generic Mapping Array for the PolicyObject Object Type
    // Note that there is only one object of this type and objects of this
    // type can neither be created nor destroyed.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[PolicyObject].GenericMapping;
    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        POLICY_VIEW_AUDIT_INFORMATION |
        POLICY_GET_PRIVATE_INFORMATION;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        POLICY_TRUST_ADMIN |
        POLICY_CREATE_ACCOUNT |
        POLICY_CREATE_SECRET |
        POLICY_CREATE_PRIVILEGE |
        POLICY_SET_DEFAULT_QUOTA_LIMITS |
        POLICY_SET_AUDIT_REQUIREMENTS |
        POLICY_AUDIT_LOG_ADMIN |
        POLICY_SERVER_ADMIN;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE |
        POLICY_VIEW_LOCAL_INFORMATION |
        POLICY_LOOKUP_NAMES;

    GenericMapping->GenericAll = POLICY_ALL_ACCESS | POLICY_NOTIFICATION;

    //
    // Initialize the Generic Mapping Array for the Account Object Type
    // Note that Account Objects can be created and destroyed.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[AccountObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        ACCOUNT_VIEW;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        ACCOUNT_ADJUST_PRIVILEGES |
        ACCOUNT_ADJUST_QUOTAS |
        ACCOUNT_ADJUST_SYSTEM_ACCESS;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE;

    GenericMapping->GenericAll = ACCOUNT_ALL_ACCESS;

    //
    // Initialize the Generic Mapping Array for the TrustedDomain Object
    // Type.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[TrustedDomainObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        TRUSTED_QUERY_DOMAIN_NAME;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        TRUSTED_SET_CONTROLLERS |
        TRUSTED_SET_POSIX;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE |
        TRUSTED_QUERY_CONTROLLERS |
        TRUSTED_QUERY_POSIX;

    GenericMapping->GenericAll = TRUSTED_ALL_ACCESS;

    //
    // Initialize the Generic Mapping Array for the Secret Object
    // Type.
    //

    GenericMapping =
        &LsapDbState.DbObjectTypes[SecretObject].GenericMapping;

    GenericMapping->GenericRead =
        STANDARD_RIGHTS_READ |
        SECRET_QUERY_VALUE;

    GenericMapping->GenericWrite =
        STANDARD_RIGHTS_WRITE |
        SECRET_SET_VALUE;

    GenericMapping->GenericExecute =
        STANDARD_RIGHTS_EXECUTE;

    GenericMapping->GenericAll = SECRET_ALL_ACCESS;

    //
    // Initialize the Object Count Information to defaults
    //

    ObjectType = &(LsapDbState.DbObjectTypes[PolicyObject]);

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        ObjectType->ObjectCount = 0;
        ObjectType->ObjectCountLimited = FALSE;
        ObjectType->ObjectCountError = STATUS_SUCCESS;
        ObjectType->MaximumObjectCount = 0;
    }

    //
    // Set specific limits for Secret Object Type.  This is the only
    // object type so far to have limits.
    //

    ObjectType = &(LsapDbState.DbObjectTypes[SecretObject]);
    ObjectType->ObjectCountLimited = TRUE;
    ObjectType->ObjectCountError = STATUS_TOO_MANY_SECRETS;
    ObjectType->MaximumObjectCount = LSA_SECRET_MAXIMUM_COUNT;

    //
    // Initialize the write operations for each object type
    //

    LsapDbState.DbObjectTypes[PolicyObject].WriteOperations = LSAP_POLICY_WRITE_OPS;
    LsapDbState.DbObjectTypes[TrustedDomainObject].WriteOperations = LSAP_TRUSTED_WRITE_OPS;
    LsapDbState.DbObjectTypes[AccountObject].WriteOperations = LSAP_ACCOUNT_WRITE_OPS;
    LsapDbState.DbObjectTypes[SecretObject].WriteOperations = LSAP_SECRET_WRITE_OPS;

    //
    // Initialize the default accesses granted to Domain Admins alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].AliasAdminsAccess = GENERIC_ALL;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AliasAdminsAccess = GENERIC_ALL | DELETE;
    LsapDbState.DbObjectTypes[AccountObject].AliasAdminsAccess = GENERIC_ALL | DELETE;
    LsapDbState.DbObjectTypes[SecretObject].AliasAdminsAccess = GENERIC_ALL | DELETE;

    //
    // Initialize the default accesses granted to World alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[AccountObject].WorldAccess = GENERIC_EXECUTE;
    LsapDbState.DbObjectTypes[SecretObject].WorldAccess = GENERIC_EXECUTE;

    //
    // Initialize the default accesses granted to AnonymousLogon alias
    //

    LsapDbState.DbObjectTypes[PolicyObject].AnonymousLogonAccess = POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AnonymousLogonAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].AnonymousLogonAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].AnonymousLogonAccess = 0;

    //
    // Initialize the default accesses granted to LocalService and NetworkService
    //

    LsapDbState.DbObjectTypes[PolicyObject].LocalServiceAccess = POLICY_NOTIFICATION;
    LsapDbState.DbObjectTypes[TrustedDomainObject].LocalServiceAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].LocalServiceAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].LocalServiceAccess = 0;

    LsapDbState.DbObjectTypes[PolicyObject].NetworkServiceAccess = POLICY_NOTIFICATION;
    LsapDbState.DbObjectTypes[TrustedDomainObject].NetworkServiceAccess = 0;
    LsapDbState.DbObjectTypes[AccountObject].NetworkServiceAccess = 0;
    LsapDbState.DbObjectTypes[SecretObject].NetworkServiceAccess = 0;


    //
    // Initialize the Invalid Access masks for each object type
    //

    LsapDbState.DbObjectTypes[PolicyObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(POLICY_ALL_ACCESS | POLICY_NOTIFICATION | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[TrustedDomainObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(TRUSTED_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[AccountObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(ACCOUNT_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));
    LsapDbState.DbObjectTypes[SecretObject].InvalidMappedAccess =
         ((ACCESS_MASK)(~(SECRET_ALL_ACCESS | ACCESS_SYSTEM_SECURITY | MAXIMUM_ALLOWED)));

    //
    // Initialize the Initial Owners for new objects of each type
    //

    LsapDbState.DbObjectTypes[PolicyObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[TrustedDomainObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[AccountObject].InitialOwnerSid = LsapAliasAdminsSid;
    LsapDbState.DbObjectTypes[SecretObject].InitialOwnerSid = LsapAliasAdminsSid;

    //
    // Specify method of access to objects of the type.  Currently, all objects
    // of a given type are accessed in the same way, either by Sid or by Name
    // but not both.
    //

    LsapDbState.DbObjectTypes[PolicyObject].AccessedByName = TRUE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AccessedByName = FALSE;
    LsapDbState.DbObjectTypes[AccountObject].AccessedByName = FALSE;
    LsapDbState.DbObjectTypes[SecretObject].AccessedByName = TRUE;

    LsapDbState.DbObjectTypes[PolicyObject].AccessedBySid = FALSE;
    LsapDbState.DbObjectTypes[TrustedDomainObject].AccessedBySid = TRUE;
    LsapDbState.DbObjectTypes[AccountObject].AccessedBySid = TRUE;
    LsapDbState.DbObjectTypes[SecretObject].AccessedBySid = FALSE;

    //
    // Specify the object types for which caching is supported (in full
    // or in part) and turn caching off initially for all object types.
    // Object types for which caching is supported have ther caches set
    // to the "Invalid" state.  Automatic restore is allowed for caches
    // in this state.  Object types for which caching is not supported
    // are set to the "Not supported" state.  Note that a cache is
    // also placed in the "not supported" state if an attempt to restore
    // it fails.
    //

    LsapDbMakeCacheInvalid( PolicyObject );
    LsapDbMakeCacheInvalid( TrustedDomainObject );
    LsapDbMakeCacheInvalid( AccountObject );
    LsapDbMakeCacheUnsupported( SecretObject );


    return(Status);
}


NTSTATUS
LsapDbInitializeUnicodeNames()

/*++

Routine Description:

    This function initializes two arrays of Unicode Strings.  The
    LsapDbNames array contains Unicode Strings for all of the constant
    names in the Lsa Database.  The LsapDbObjectTypeNames is indexed
    by Object Type Id and contains the Unicode Strings for all of the
    LSA Database object types.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_NAMES Index;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    PCWSTR UnicodeNames[DummyLastName + 1] = {

        L"SecDesc",
        L"Privilgs",
        L"Sid",
        L"Name",
        L"AdminMod",
        L"OperMode",
        L"QuotaLim",
        L"DefQuota",
        L"QuAbsMin",
        L"QuAbsMax",
        L"AdtLog",
        L"AdtEvent",
        L"PrDomain",
        L"EnPasswd",
        L"Policy",
        L"Accounts",
        L"Domains",
        L"Secrets",
        L"CurrVal",
        L"OldVal",
        L"CupdTime",
        L"OupdTime",
        L"WkstaMgr",
        L"PolAdtLg",
        L"PolAdtEv",
        L"PolAcDmN",
        L"PolAcDmS",
        L"PolDnDDN",
        L"PolDnTrN",
        L"PolDnDmG",
        L"PolEfDat",
        L"PolPrDmN",
        L"PolPrDmS",
        L"PolPdAcN",
        L"PolRepSc",
        L"PolRepAc",
        L"PolRevision",
        L"PolDefQu",
        L"PolMod",
        L"PolAdtFL",
        L"PolState",
        L"PolNxPxf",
        L"ActSysAc",
        L"TrDmName",
        L"TrDmTrPN",    // Netbios name of trust partner
        L"TrDmSid",
        L"TrDmAcN",
        L"TrDmCtN",
        L"TrDmPxOf",
        L"TrDmCtEn",
        NULL,           // TrDmTrTy
        NULL,           // TrDmTrDi
        L"TrDmTrLA",    // TrDmTrLA
        L"TrDmTrPr",    // Trust partner
        L"TrDmTrRt",    // Root partner
        L"TrDmSAI",     // Incoming auth. info
        L"TrDmSAO",     // Outgoing auth. info
        L"TrDmForT",    // Forest trust info
        L"AcMaPCF",
        L"PolIPSec",    // IPSec object reference
        L"PolDIPSec",   // Domain wide IPSec object reference
        L"PolLoc",      // Policy location,
        L"PolPubK",     // Public key policy
        L"KerOpts",     // Kerberos authentication options
        L"KerMinT",     // Kerberos Minimum ticket age
        L"KerMaxT",     // Kerberos maximum ticket age
        L"KerMaxR",     // Kerberos maximum renewal age
        L"KerProxy",    // Kerberos proxy lifetime
        L"KerLogoff",   // Kerberos force logoff duration
        L"DmLDur",      // Domain lockout duration
        L"DmLObWin",    // Lockout observation window
        L"DmLThrs",     // Lockout threshold
        L"DmPMinL",     // Minimum password length
        L"DmPHisL",     // Password history length
        L"DmPProp",     // Password properties
        L"DmPMinA",     // Minimum password age
        L"DmPMaxA",     // Maximum password age
        L"BhvrVers",    // Behavior-Version
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Eventlog\\Security",
        L"MaxSize",
        L"Retention",
        L"PseudoSystemCritical",
        L"PolSecretEncryptionKey",
        L"XRefDnsRoot",
        L"XRefNetbiosName",
        L"DummyLastName"
    };

    PCWSTR UnicodeObjectTypeNames[DummyLastObject] = {

        L"NullObject",
        L"PolicyObject",
        L"TrustedDomainObject",
        L"UserAccountObject",
        L"SecretObject",
        L"AllObject",
        L"NewTrustedDomainObject"
    };

    //
    // Referenced by LsapDbDsAttInfo
    //
    static LSAP_DB_DS_INFO StaticLsapDbDsAttInfo[DummyLastName + 1]  = {
        {ATT_NT_SECURITY_DESCRIPTOR,    LsapDbAttribSecDesc, LsapDsLocDs}, // Security Descriptor
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown }, // Privileges
        {ATT_SECURITY_IDENTIFIER,       LsapDbAttribSid,     LsapDsLocDs},     // Sid
        {0,                             LsapDbAttribUnknown, LsapDsLocDs}, // Name
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // AdminMod
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // OperMode
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // QuotaLim
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // DefQuota
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // QuAbsMin
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // QuAbsMax
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // AdtLog
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // AdtEvent
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PrDomain
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // EnPasswd
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Policy
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Accounts
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Domains
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Secrets
        {ATT_CURRENT_VALUE,             LsapDbAttribPByte,   LsapDsLocDs},   // CurrVal
        {ATT_PRIOR_VALUE,               LsapDbAttribPByte,   LsapDsLocDs},   // OldVal
        {ATT_LAST_SET_TIME,             LsapDbAttribPByte,   LsapDsLocDs},   // CupdTime
        {ATT_PRIOR_SET_TIME,            LsapDbAttribPByte,   LsapDsLocDs},   // OupdTime
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // WkstaMgr
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolAdtLg
        {ATT_AUDITING_POLICY,           LsapDbAttribPByte,   LsapDsLocRegistry}, // PolAdtEv
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolAcDmN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolAcDmS
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnDDN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnTrN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolDnDmG
        {ATT_EFSPOLICY,                 LsapDbAttribPByte,   LsapDsLocRegistry}, // PolEfDat
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPrDmN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPrDmS
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolPdAcN
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolRepSc
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolRepAc
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolRevision
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolDefQu
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolMod
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolAdtFL
        {0,                             LsapDbAttribUnknown, LsapDsLocRegistry}, // PolState
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // PolNxPxF
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // ActSysAc
        {ATT_TRUST_PARTNER,             LsapDbAttribUnicode, LsapDsLocDs}, // TrDmName
        {ATT_FLAT_NAME,                 LsapDbAttribUnicode, LsapDsLocDs}, // TrDmTrPN
        {ATT_SECURITY_IDENTIFIER,       LsapDbAttribSid,     LsapDsLocDs},     // TrDmSid
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // TrDmAcN
        {0,                             LsapDbAttribUnicode, LsapDsLocRegistry}, // TrDmCtN
        {ATT_TRUST_POSIX_OFFSET,        LsapDbAttribULong,   LsapDsLocDs},   // TrDmPxOf
        {0,                             LsapDbAttribUnicode, LsapDsLocRegistry}, // TrDmCtEn
        {ATT_TRUST_TYPE,                LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrTy
        {ATT_TRUST_DIRECTION,           LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrDi
        {ATT_TRUST_ATTRIBUTES,          LsapDbAttribULong,   LsapDsLocDs},   // TrDmTrLA
        {ATT_DOMAIN_CROSS_REF,          LsapDbAttribDsName,  LsapDsLocDs},  // TrDmTrPr
        {ATT_ROOT_TRUST,                LsapDbAttribDsName,  LsapDsLocDs},  // TrDmTrRt
        {ATT_TRUST_AUTH_INCOMING,       LsapDbAttribPByte,   LsapDsLocDs},   // TrDmSAI
        {ATT_TRUST_AUTH_OUTGOING,       LsapDbAttribPByte,   LsapDsLocDs},   // TrDmSAO
        {ATT_MS_DS_TRUST_FOREST_TRUST_INFO, LsapDbAttribPByte, LsapDsLocDs}, // TrDmForT
        {ATT_MACHINE_PASSWORD_CHANGE_INTERVAL, LsapDbAttribPByte,   LsapDsLocDsLocalPolObj}, // AcMaPCF
        {ATT_IPSEC_POLICY_REFERENCE,    LsapDbAttribDsNameAsUnicode,   LsapDsLocDsLocalPolObj}, // PolIPSec,
        {ATT_IPSEC_POLICY_REFERENCE,    LsapDbAttribDsNameAsUnicode,   LsapDsLocDsDomainPolObj}, // PolDIPSec,
        {0,                             LsapDbAttribULong,   LsapDsLocRegistry},      // PolLoc,
        {ATT_PUBLIC_KEY_POLICY,         LsapDbAttribPByte,   LsapDsLocRegistry}, // PolPubK,
        {ATT_AUTHENTICATION_OPTIONS,    LsapDbAttribULong,   LsapDsLocRegistry}, // KerOpts,
        {ATT_MIN_TICKET_AGE,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMinT,
        {ATT_MAX_TICKET_AGE,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMaxT,
        {ATT_MAX_RENEW_AGE,             LsapDbAttribPByte,   LsapDsLocRegistry}, // KerMaxR,
        {ATT_PROXY_LIFETIME,            LsapDbAttribPByte,   LsapDsLocRegistry}, // KerProxy,
        {ATT_FORCE_LOGOFF,              LsapDbAttribPByte,   LsapDsLocRegistry}, // KerLogoff
        {ATT_LOCKOUT_DURATION,          LsapDbAttribPByte,   LsapDsLocRegistry}, // DmLDur
        {ATT_LOCK_OUT_OBSERVATION_WINDOW,LsapDbAttribPByte,  LsapDsLocRegistry}, // DmLObWin
        {ATT_LOCKOUT_THRESHOLD,         LsapDbAttribUShortAsULong,   LsapDsLocRegistry}, // DmLThrs
        {ATT_MIN_PWD_LENGTH,            LsapDbAttribUShortAsULong,   LsapDsLocRegistry}, // DmPMinL
        {ATT_PWD_HISTORY_LENGTH,        LsapDbAttribUShortAsULong,   LsapDsLocRegistry}, // DmPHisL
        {ATT_PWD_PROPERTIES,            LsapDbAttribULong,   LsapDsLocRegistry}, // DmPProp
        {ATT_MIN_PWD_AGE,               LsapDbAttribPByte,   LsapDsLocRegistry}, // DmPMinA
        {ATT_MAX_PWD_AGE,               LsapDbAttribPByte,   LsapDsLocRegistry}, // DmPMaxA
        {ATT_MS_DS_BEHAVIOR_VERSION,    LsapDbAttribULong,   LsapDsLocDs},       // BhvrVers
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit log
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit log size
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}, // Audit Recored Retention Period
        {ATT_IS_CRITICAL_SYSTEM_OBJECT, LsapDbAttribULong,   LsapDsLocDs}, // system critical component.
        {0,                             LsapDbAttribPByte,   LsapDsLocRegistry},//PolSecretEncryptionKey
        {ATT_DNS_ROOT,                  LsapDbAttribUnicode, LsapDsLocDs}, // DNS name of cross-ref
        {ATT_NETBIOS_NAME,              LsapDbAttribUnicode, LsapDsLocDs}, // Netbios domain of cross-ref
        {0,                             LsapDbAttribUnknown, LsapDsLocUnknown}  // Dummy Last Name
    };

    //
    // Initialize general array of Unicode Names
    //

    for (Index = SecDesc; Index < DummyLastName; Index++) {

        RtlInitUnicodeString( &LsapDbNames[Index], UnicodeNames[Index] );
    }

    //
    // Initialize array of Unicode Names for Lsa Database Object Types
    //

    for (ObjectTypeId = NullObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        RtlInitUnicodeString(
            &LsapDbObjectTypeNames[ObjectTypeId],
            UnicodeObjectTypeNames[ObjectTypeId]
            );
    }

    LsapDbDsAttInfo = StaticLsapDbDsAttInfo;
    return(Status);
}


NTSTATUS
LsapDbInitializeContainingDirs()

/*++

Routine Description:

    This function initializes Unicode strings for the names of the Containing
    directories for each object type.  The Containing Directory is the
    Registry Key under which all objects of the given type are created and is
    relative to the LSA Database root.  Note that objects of a given type all
    exist under a single Registry node, that is, the type of an object
    uniquely determines the name of its containing directory.

    NOTE:  Containing Directories are used to produce Physical Object Names
           from Logical Object Names.  The Physical Object Name is simply
           the Logical Object Name prepended with the Containing Directory
           Name and a "\".

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_TYPE_ID ObjectTypeId;

    PWSTR ContainingDirectories[DummyLastObject] = {

        L"",
        L"",
        L"Domains",
        L"Accounts",
        L"Secrets"
    };

    //
    // Initialize the array of Unicode Strings indexed by object type setting
    // the Containing Directory name for each object type.
    //

    for (ObjectTypeId = PolicyObject;
         ObjectTypeId < DummyLastObject;
         ObjectTypeId++) {

        RtlInitUnicodeString(
            &LsapDbContDirs[ObjectTypeId],
            ContainingDirectories[ ObjectTypeId ]
            );
    }

    return(Status);
}


NTSTATUS
LsapDbInitializeDefaultQuotaLimits(
    )

/*++

Routine Description:

    This function initializes three different sets of Quota Limits in
    global data.

    o The System Installation Default Quota Limits.  These are read from
      the Policy Object's "DefQuota" attribute.
    o The Absolute Minimum quota limit values that may be set
    o The Absolute Maximum quota limit values that may be set

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    ULONG QuotaLimitsLength = sizeof (QUOTA_LIMITS);

    //
    // Read the installed System Default Quotas from the DefQuota attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[DefQuota],
                 (PVOID) &LsapDbInstalledQuotaLimits,
                 &QuotaLimitsLength
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapDbInitializeDefaultQuotaLimits: Read DefQuota Attribute returned 0x%lx\n",
            Status
            );

        goto InitializeDefaultQuotaLimitsError;
    }

    //
    // Read the System Abs Min Quotas from the QuAbsMin attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[QuAbsMin],
                 (PVOID) &LsapDbAbsMinQuotaLimits,
                 &QuotaLimitsLength
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapDbInitializeDefaultQuotaLimits: Read QuAbsMin Attribute returned 0x%lx\n",
            Status
            );

        goto InitializeDefaultQuotaLimitsError;
    }

    //
    // Read the System Abs Max Quotas from the QuAbsMax attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[QuAbsMax],
                 (PVOID) &LsapDbAbsMaxQuotaLimits,
                 &QuotaLimitsLength
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError(
            "LsapDbInitializeDefaultQuotaLimits: Read QuAbsMax Attribute returned 0x%lx\n",
            Status
            );

        goto InitializeDefaultQuotaLimitsError;
    }

InitializeDefaultQuotaLimitsFinish:

    return(Status);

InitializeDefaultQuotaLimitsError:

    goto InitializeDefaultQuotaLimitsFinish;
}


NTSTATUS
LsapDbInitializeReplication(
    )

/*++

Routine Description:

    This function performes LSA initialization for replication and turns
    on notification of LSA Database updates to the LSA Database Replicator.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    ULONG PolicyModificationInfoLength  = sizeof (POLICY_MODIFICATION_INFO);
    ULONG PolicyLsaServerRoleInfoLength = sizeof(POLICY_LSA_SERVER_ROLE_INFO);
    ULONG LargeIntegerLength            = sizeof( LARGE_INTEGER );

    //
    // Read the Policy Modification Info from the PolMod attribute
    // of the Policy object in the LSA Database.
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolMod],
                 (PVOID) &LsapDbState.PolicyModificationInfo,
                 &PolicyModificationInfoLength
                 );

    if (!NT_SUCCESS(Status)) {
        goto InitializeReplicationError;
    }

InitializeReplicationFinish:

     return(Status);

InitializeReplicationError:

     goto InitializeReplicationFinish;
}


NTSTATUS
LsapDbInitializeCipherKey(
    IN PUNICODE_STRING CipherSeed,
    IN PLSAP_CR_CIPHER_KEY *CipherKey
    )

/*++

Routine Description:

    This function initializes the LSA Database Cipher Key.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    LSAP_CR_CLEAR_VALUE ClearCipherKey;
    PLSAP_CR_CIPHER_VALUE CipherCipherKey;

    *CipherKey = NULL;

    //
    // Initialize the Cipher key to a hardwired constant
    // encrypted with itself.
    //
    LsapCrUnicodeToClearValue( CipherSeed, &ClearCipherKey);

    Status = LsapCrEncryptValue(
                 &ClearCipherKey,
                 (PLSAP_CR_CIPHER_KEY) &ClearCipherKey,
                 &CipherCipherKey
                 );

    if (!NT_SUCCESS(Status)) {

        LsapLogError( "LsapDbInitializeReplication: NtQuerySystemTime returned 0x%lx\n",
                      Status );

    } else {

        *CipherKey = ( PLSAP_CR_CIPHER_KEY )CipherCipherKey;
    }

    return(Status);

}


NTSTATUS
LsapDbOpenRootRegistryKey(
    )

/*++

Routine Description:

    This function opens the LSA Database Root Registry Key.  This has
    the fixed name \Registry\Machine\Security.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    UNICODE_STRING DbRootRegKeyNameU;
    OBJECT_ATTRIBUTES DbAttributes;

    RtlInitUnicodeString( &DbRootRegKeyNameU, LSAP_DB_ROOT_REG_KEY_NAME );

    InitializeObjectAttributes(
        &DbAttributes,
        &DbRootRegKeyNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = RtlpNtOpenKey(
                 (PHANDLE) &LsapDbState.DbRootRegKeyHandle,
                 (KEY_READ | KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | WRITE_DAC),
                 &DbAttributes,
                 0
                 );


    if (!NT_SUCCESS(Status)) {
        LsapLogError(
            "LsapDbOpenRootRegistryKey: Open Root Key for LSA Policy Database returned 0x%lx\n",
            Status
            );
        goto OpenRootRegistryKeyError;
    }


    //
    // If there are no sub-keys, then we are in system-install.
    // Assign the initial protection of this hive.
    //

    Status = LsapAssignInitialHiveProtection( LsapDbState.DbRootRegKeyHandle );

    if (!NT_SUCCESS(Status)) {
        LsapLogError(
            "LsapDbOpenRootRegistryKey: Couldn't assign initial hive protection 0x%lx\n",
            Status
            );
        goto OpenRootRegistryKeyError;
    }



OpenRootRegistryKeyFinish:

    return(Status);

OpenRootRegistryKeyError:

    goto OpenRootRegistryKeyFinish;
}


NTSTATUS
LsapAssignInitialHiveProtection(
    HANDLE HiveRoot
    )


/*++

Routine Description:

    This function assigns inheritable protection to the hive root key.
    It will only do this if the hive root has no sub-keys.
    This condition will only exist during system installation.

    WARNING -

    THIS ROUTINE IS TAILORED TO OPERATE ON THE \REGISTRY\SECURITY HIVE.
    As such, it expects the Root key to have exactly one sub-key (a
    link to the SAM hive) if the the database has NOT been initialized.
    Otherwise, it expects the LSA policy database keys to be present.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Everything went fine.  No indication of whether
        protection was necessarily assigned or not.

    All other status values are generated by called routines.

--*/

{
    NTSTATUS
        Status;

    KEY_BASIC_INFORMATION
        DummyBuffer;

    ULONG
        IgnoreRequiredLength;

    SECURITY_DESCRIPTOR
        Sd;


    //
    // See if the hive has more than 1 sub-keys.
    //
    //

    Status = NtEnumerateKey(
                 HiveRoot,
                 1,                     // Index - 0 is the SAM link, 1 is LSA policy database stuff
                 KeyBasicInformation,   // Name of key
                 &DummyBuffer,
                 sizeof(DummyBuffer),
                 &IgnoreRequiredLength
                 );

    if (Status == STATUS_NO_MORE_ENTRIES) {

        //
        // We are initializing the system...
        // Apply a reasonable ACL to the hive root.
        //

        Status = LsapCreateDatabaseProtection( &Sd );

        if (NT_SUCCESS(Status)) {
            Status = NtSetSecurityObject(
                         HiveRoot,                  // Object to apply to
                         DACL_SECURITY_INFORMATION, // Information to set
                         (PSECURITY_DESCRIPTOR)&Sd   // Descriptor
                         );
        }
    } else {

        Status = STATUS_SUCCESS;
    }

    return(Status);

}



NTSTATUS
LsapCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    )


/*++

Routine Description:

    This function allocates and initializes protection to assign to
    the SAM database.

    Upon return, any non-zero pointers in the security descriptors
    point to memory allocated from process heap.  It is the caller's
    responsibility to free this memory.


    Protection is:

                        System: All Access
                        Admin:  ReadControl | WriteDac

Arguments:

    Sd - Address of a security descriptor to initialize.

Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/


{
    NTSTATUS
        Status;

    ULONG
        Length;

    USHORT
        i;

    PACL
        Dacl;

    PACE_HEADER
        Ace;


    //
    // Initialize the security descriptor.
    // This call should not fail.
    //

    Status = RtlCreateSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION1 );
    ASSERT(NT_SUCCESS(Status));

    Length = (ULONG)sizeof(ACL) +
                 (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                 RtlLengthSid( LsapLocalSystemSid ) +
                 RtlLengthSid( LsapAliasAdminsSid ) +
                 8; // The 8 is just for good measure


    Dacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

    if (Dacl == NULL) {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlCreateAcl (Dacl, Length, ACL_REVISION2 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Add ACEs to the ACL...
    // These calls should not be able to fail.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (GENERIC_ALL),
                 LsapLocalSystemSid
                 );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (READ_CONTROL | WRITE_DAC),
                 LsapAliasAdminsSid
                 );
    ASSERT(NT_SUCCESS(Status));


    //
    // Now mark the ACEs as inheritable...
    //

    for ( i=0; i<Dacl->AceCount; i++) {

        //
        // Get the address of the next ACE
        // (Shouldn't fail)
        //

        Status = RtlGetAce( Dacl, (ULONG)i, &Ace );
        ASSERT(NT_SUCCESS(Status));

        Ace->AceFlags |= (CONTAINER_INHERIT_ACE);

    }


    //
    // And add the ACL to the security descriptor.
    // This call should not fail.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 Sd,
                 TRUE,              // DaclPresent
                 Dacl,              // Dacl OPTIONAL
                 FALSE              // DaclDefaulted OPTIONAL
                 );
    ASSERT(NT_SUCCESS(Status));



    return(STATUS_SUCCESS);

}



NTSTATUS
LsapUpdateDatabaseProtection(
    IN ULONG Revision
    )


/*++

Routine Description:

    This function allocates and updates protection to assign to
    the LSA database.

Arguments:

    Revision  - New database revision level
        LSAP_DB_REVISION_1_3 -- grant POLICY_NOTIFICATION access to Administrators
        LSAP_DB_REVISION_1_6 -- grant POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES to AnonymousLogonSid
        LSAP_DB_REVISION_1_7 -- grant POLICY_NOTIFICATION to LocalService/NetworkService


Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/


{
    NTSTATUS Status;
    NTSTATUS TempStatus;
    PSECURITY_DESCRIPTOR CurrentSd = NULL;
    PSECURITY_DESCRIPTOR RelativeSd = NULL;
    ULONG RelativeSdLength;
    PSECURITY_DESCRIPTOR NewSd;
    SECURITY_DESCRIPTOR NewSdBuffer;
    USHORT i;
    PACL Dacl, NewDacl = NULL, TempAcl;
    PACE_HEADER Ace;
    PSID AceSid;
    BOOLEAN AdminAceFound = FALSE;
    BOOLEAN UpdatedSd = FALSE;

    //
    // First, read the initial security descriptor...
    //
    Status = LsapRegReadObjectSD( LsapPolicyHandle,
                                  &CurrentSd );


    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    ASSERT( Revision == LSAP_DB_REVISION_1_3
             ||
            Revision == LSAP_DB_REVISION_1_6
             ||
            Revision == LSAP_DB_REVISION_1_7 );

    NewSd = CurrentSd;

    if ( Revision == LSAP_DB_REVISION_1_3
          ||
         Revision == LSAP_DB_REVISION_1_6
          ||
         Revision == LSAP_DB_REVISION_1_7 )
    {
        Dacl = RtlpDaclAddrSecurityDescriptor( ( PISECURITY_DESCRIPTOR )CurrentSd );

        if ( Dacl ) {

            //
            // We'll have to find the ace for local system
            //
            Ace = ( PACE_HEADER )FirstAce( Dacl );
            for(i = 0; i < Dacl->AceCount; i++, Ace = ( PACE_HEADER )NextAce( Ace ) ) {



                if ( IsObjectAceType( Ace ) ) {

                    AceSid = RtlObjectAceSid( Ace );

                } else {

                    AceSid = &( ( PKNOWN_ACE )Ace )->SidStart;
                }

                //
                // When upgrading to revision 1_3, update the administrators ACE
                //

                if ( Revision == LSAP_DB_REVISION_1_3 &&
                     RtlEqualSid( AceSid, LsapAliasAdminsSid ) ) {

                    //
                    // Get the access mask and or in our new bit
                    //
                    if ( IsObjectAceType( Ace ) ) {

                        if (( ((PKNOWN_OBJECT_ACE)Ace)->Mask & POLICY_NOTIFICATION ) == 0 ) {

                            ((PKNOWN_OBJECT_ACE)Ace)->Mask |= POLICY_NOTIFICATION;
                            UpdatedSd = TRUE;
                        }

                    } else {

                        if (( ((PKNOWN_ACE)Ace)->Mask & POLICY_NOTIFICATION ) == 0 ) {

                            ((PKNOWN_ACE)Ace)->Mask |= POLICY_NOTIFICATION;
                            UpdatedSd = TRUE;
                        }

                    }

                    AdminAceFound = TRUE;

                }
            }
        }

        //
        // If we didn't find an ACE to update, make sure to add it...
        //
        if ( !AdminAceFound )
        {
            ULONG NewDaclLength;


            UpdatedSd = TRUE;

            NewDaclLength = Dacl ? Dacl->AclSize : 0;

            if ( Revision == LSAP_DB_REVISION_1_3 )
            {
                NewDaclLength += ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapAliasAdminsSid );
            }
            else if ( Revision == LSAP_DB_REVISION_1_6 )
            {
                NewDaclLength += ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapAnonymousSid );
            }
            else
            {
                ASSERT( Revision == LSAP_DB_REVISION_1_7 );

                NewDaclLength += 2 * ( ULONG )sizeof( ACCESS_ALLOWED_ACE ) +
                          RtlLengthSid( LsapLocalServiceSid ) +
                          RtlLengthSid( LsapNetworkServiceSid );
            }

            NewDacl = LsapAllocateLsaHeap( NewDaclLength );

            if ( NewDacl == NULL ) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            if ( Dacl ) {

                RtlCopyMemory( NewDacl, Dacl, Dacl->AclSize );
                NewDacl->AclSize = ( USHORT )NewDaclLength;

            } else {

                Status = RtlCreateAcl ( NewDacl, NewDaclLength, ACL_REVISION2 );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // For version 1.3, grant administrators All access and Policy notification access
            //
            if ( Revision == LSAP_DB_REVISION_1_3 ) {

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_ALL_ACCESS |
                                                        POLICY_NOTIFICATION,
                                                 LsapAliasAdminsSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

            //
            // For version 1.6, grant anonymous logon View Local and Lookup names access.
            //

            } else if ( Revision == LSAP_DB_REVISION_1_6) {

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_VIEW_LOCAL_INFORMATION |
                                                        POLICY_LOOKUP_NAMES,
                                                 LsapAnonymousSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

            //
            // For version 1.7, grant Policy notification access to LocalService
            // and NetworkService
            //

            } else {

                ASSERT( Revision == LSAP_DB_REVISION_1_7 );

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_NOTIFICATION,
                                                 LsapLocalServiceSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }

                Status = RtlAddAccessAllowedAce( NewDacl,
                                                 ACL_REVISION2,
                                                 POLICY_NOTIFICATION,
                                                 LsapNetworkServiceSid );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }
            }

            //
            // If the current security descriptor is self relative,
            //  convert it to absolute so I can set the DACL on it.
            //
            if ( RtlpAreControlBitsSet( ( PISECURITY_DESCRIPTOR )CurrentSd,
                                        SE_SELF_RELATIVE ) ) {

                NewSd = &NewSdBuffer;

                Status = RtlCreateSecurityDescriptor( NewSd,
                                                      SECURITY_DESCRIPTOR_REVISION );

                if ( !NT_SUCCESS(Status) ) {
                    goto Cleanup;
                }


                ((PISECURITY_DESCRIPTOR)NewSd)->Control =
                    ((PISECURITY_DESCRIPTOR)CurrentSd)->Control;


                AceSid = RtlpOwnerAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( AceSid ) {

                    ( (PISECURITY_DESCRIPTOR)NewSd )->Owner = AceSid;
                }

                AceSid = RtlpGroupAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( AceSid ) {

                    ( ( PISECURITY_DESCRIPTOR )NewSd )->Group = AceSid;
                }

                TempAcl = RtlpSaclAddrSecurityDescriptor(
                                            ( PISECURITY_DESCRIPTOR )CurrentSd );

                if ( TempAcl ) {

                    ( ( PISECURITY_DESCRIPTOR )NewSd )->Sacl = TempAcl;
                }

                RtlpClearControlBits( ( PISECURITY_DESCRIPTOR )NewSd,
                                       SE_SELF_RELATIVE );


            }



            //
            // Put the computed DACL onto the SD.
            //
            Status = RtlSetDaclSecurityDescriptor( NewSd,
                                                   TRUE,
                                                   NewDacl,
                                                   FALSE );
            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            //
            // Convert the SD to self relative before writing it to the database.
            //

            RelativeSdLength = 0;
            Status = RtlMakeSelfRelativeSD( NewSd,
                                            NULL,
                                            &RelativeSdLength );

            if (Status != STATUS_BUFFER_TOO_SMALL) {    // This is the expected case
                if ( NT_SUCCESS(Status) ) {
                    Status = STATUS_INTERNAL_ERROR;
                }
                goto Cleanup;
            }

            RelativeSd = LsapAllocateLsaHeap( RelativeSdLength );

            if ( RelativeSd == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Status = RtlMakeSelfRelativeSD( NewSd,
                                            RelativeSd,
                                            &RelativeSdLength );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }

            NewSd = RelativeSd;
        }
    }


    if ( UpdatedSd ) {
        ULONG NewSdLength;

        //
        // Set the security descriptor back on the object
        //
        NewSdLength = RtlLengthSecurityDescriptor( NewSd );

        //
        // Add a Registry transaction to write the Security Descriptor as the
        // value of the new object's SecDesc subkey.
        //

        Status = LsapDbReferenceObject(
                    LsapDbHandle,
                    0,
                    PolicyObject,
                    PolicyObject,
                    LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                    );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        Status = LsapDbWriteAttributeObject( LsapPolicyHandle,
                                             &LsapDbNames[ SecDesc ],
                                             NewSd,
                                             NewSdLength );


        TempStatus = LsapDbDereferenceObject(
                     &LsapDbHandle,
                     PolicyObject,
                     PolicyObject,
                     (LSAP_DB_LOCK |
                      LSAP_DB_OMIT_REPLICATOR_NOTIFICATION | // Each BDC should upgrade its own database
                      LSAP_DB_FINISH_TRANSACTION),
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status );

        if ( !NT_SUCCESS(TempStatus) ) {
            if (NT_SUCCESS(Status) ) {
                Status = TempStatus;
            }
        }

    }


Cleanup:

    //
    // Free the security descriptor
    //
    LsapFreeLsaHeap( CurrentSd );
    LsapFreeLsaHeap( RelativeSd );
    LsapFreeLsaHeap( NewDacl );

    return( Status );

}


NTSTATUS
LsapDbInitializeLock(
    )

/*++

Routine Description:

    This function initializes the LSA Database Lock.  It is called once
    only, during LSA Database initialization.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.

--*/

{
    NTSTATUS Status;

    Status = SafeInitializeCriticalSection( &LsapDbState.AccountLock, ( DWORD )ACCOUNT_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.PolicyLock, ( DWORD )POLICY_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.SecretLock, ( DWORD )SECRET_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.RegistryLock, ( DWORD )REGISTRY_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    Status = SafeInitializeCriticalSection( &LsapDbState.HandleTableLock, ( DWORD )HANDLE_TABLE_LOCK_ENUM );
    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    try
    {
        SafeInitializeResource( &LsapDbState.PolicyCacheLock, ( DWORD )POLICY_CACHE_LOCK_ENUM );
        Status = STATUS_SUCCESS;
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Initialize the Resource for the Trusted Domain List.
    //

    InitializeListHead( &LsapDbTrustedDomainList.ListHead );
    LsapDbTrustedDomainList.TrustedDomainCount = 0;
    LsapDbTrustedDomainList.CurrentSequenceNumber = 0;
    LsapDbMakeCacheInvalid( TrustedDomainObject );

    try
    {
        SafeInitializeResource( &LsapDbTrustedDomainList.Resource, ( DWORD )TRUST_LOCK_ENUM );
        Status = STATUS_SUCCESS ;
    }
    except (EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    if ( !NT_SUCCESS( Status ) ) {

        goto Cleanup;
    }

    try
    {
        //
        // do not use the safelock library for ScePolicyLock
        // because it is usually acquired on one thread and
        // released on another
        //
        RtlInitializeResource( &LsapDbState.ScePolicyLock );
        Status = STATUS_SUCCESS ;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }
    if (!NT_SUCCESS( Status )) {
        goto Cleanup;
    }

    LsapDbState.SceSyncEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( LsapDbState.SceSyncEvent == NULL ) {
        Status = GetLastError();
        goto Cleanup;
    }

#if DBG
    try
    {
        SafeInitializeResource( &LsapDsThreadInfoListResource, ( DWORD )THREAD_INFO_LIST_LOCK_ENUM );
        Status = STATUS_SUCCESS ;
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }
    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }
    RtlZeroMemory( &LsapDsThreadInfoList, sizeof( LSADS_THREAD_INFO_NODE ) * LSAP_THREAD_INFO_LIST_MAX );
#endif
    Status = STATUS_SUCCESS;

Cleanup:
    return( Status );
}


NTSTATUS
LsapDbInitializeWellKnownValues(
    )

/*++

Routine Description:

    This function initializes the well-known values used by LSA.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status;
    BOOLEAN b;

    //
    // Initialize the Well Known Sids
    //

    b = LsaIInitializeWellKnownSids( &WellKnownSids );

    if (!b ) {

        Status = STATUS_UNSUCCESSFUL;
        goto InitializeWellKnownValuesError;
    }

    //
    // Initialize the well known privilege values
    //

    Status = LsapDbInitializeWellKnownPrivs();

    if (!NT_SUCCESS(Status)) {

        goto InitializeWellKnownValuesError;
    }

InitializeWellKnownValuesFinish:

    return(Status);

InitializeWellKnownValuesError:

    goto InitializeWellKnownValuesFinish;
}


NTSTATUS
LsapDbInitializeWellKnownPrivs(
    )

/*++

Routine Description:

    This function initializes the well-known privilege values.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        Currently, only STATUS_SUCCESS is returned.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    LsapCreateTokenPrivilege =
        RtlConvertLongToLuid(SE_CREATE_TOKEN_PRIVILEGE);
    LsapAssignPrimaryTokenPrivilege =
        RtlConvertLongToLuid(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE);
    LsapLockMemoryPrivilege =
        RtlConvertLongToLuid(SE_LOCK_MEMORY_PRIVILEGE);
    LsapIncreaseQuotaPrivilege =
        RtlConvertLongToLuid(SE_INCREASE_QUOTA_PRIVILEGE);
    LsapUnsolicitedInputPrivilege =
        RtlConvertLongToLuid(SE_UNSOLICITED_INPUT_PRIVILEGE);
    LsapTcbPrivilege =
        RtlConvertLongToLuid(SE_TCB_PRIVILEGE);
    LsapSecurityPrivilege =
        RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
    LsapTakeOwnershipPrivilege =
        RtlConvertLongToLuid(SE_TAKE_OWNERSHIP_PRIVILEGE);

    return(Status);
}


BOOLEAN
LsaIInitializeWellKnownSids(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY *WellKnownSids
    )

/*++

Routine Description:

    This function initializes the Well-Known Sids

Arguments:

    WellKnownSids - Receives a pointer to a newly created table of
        the Well Known Sids.

Return Value:

    BOOLEAN - TRUE if successful, else FALSE.

--*/

{
    NTSTATUS Status;
    BOOLEAN BooleanStatus = TRUE;
    LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex;
    ULONG SubAuthorities[LSAP_WELL_KNOWN_MAX_SUBAUTH_LEVEL];
    ULONG OutputWellKnownSidsLength;
    PLSAP_WELL_KNOWN_SID_ENTRY OutputWellKnownSids = NULL;
    UNICODE_STRING SidName, NtAuthorityName, UsersName;
    HMODULE StringsResource;
    SID_IDENTIFIER_AUTHORITY InternetSiteAuthority
                                            = SECURITY_INTERNETSITE_AUTHORITY;

    //
    // Get the message resource we need to get the SID names from
    //

    StringsResource = (HMODULE) LoadLibrary( L"LSASRV.DLL" );
    if (StringsResource == NULL) {
        return(FALSE);
    }


    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NT_AUTHORITY,
                &NtAuthorityName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));
    //
    // Allocate memory for the table of Sids.
    //

    OutputWellKnownSidsLength =
        LsapDummyLastSidIndex * sizeof(LSAP_WELL_KNOWN_SID_ENTRY);

    OutputWellKnownSids = RtlAllocateHeap(
                              RtlProcessHeap(),
                              0,
                              OutputWellKnownSidsLength
                              );

    if (OutputWellKnownSids == NULL) {

        goto InitializeWellKnownSidsError;
    }

    //
    //  Allocate and initialize the universal SIDs
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NULL,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NULL_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNullSidIndex,
            &LsapNullSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_WORLD,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_WORLD_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapWorldSidIndex,
            &LsapWorldSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_LOCAL,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalSidIndex,
            &LsapLocalSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_OWNER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_OWNER_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorOwnerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_GROUP,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_GROUP_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorGroupSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_OWNER_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_OWNER_SERVER_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorOwnerServerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }
    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_CREATOR_GROUP_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_CREATOR_GROUP_SERVER_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapCreatorGroupServerSidIndex,
            &LsapCreatorSidAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            L"",
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }


    //
    // Initialize the Nt well-known Sids
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NT_DOMAIN,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNtAuthoritySidIndex,
            &LsapNtAuthority,
            0,
            NULL,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }



    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_DIALUP,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_DIALUP_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapDialupSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NETWORK,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NETWORK_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNetworkSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_BATCH,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_BATCH_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapBatchSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_INTERACTIVE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_INTERACTIVE_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapInteractiveSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_REMOTE_INTERACTIVE,
                &SidName,
                0,
                NULL); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_REMOTE_LOGON_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapRemoteInteractiveSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_TERMINAL_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_TERMINAL_SERVER_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapTerminalServerSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));
    SubAuthorities[0] = SECURITY_SERVICE_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }


    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_ANONYMOUS,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_ANONYMOUS_LOGON_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAnonymousSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }


    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_PROXY,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_PROXY_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapProxySidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }



    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SERVER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_SERVER_LOGON_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapServerSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SELF,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_PRINCIPAL_SELF_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapSelfSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_AUTHENTICATED_USER,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_AUTHENTICATED_USER_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAuthenticatedUserSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    //
    // Add any Logon Id well known sids here.
    //

    SubAuthorities[0] = SECURITY_LOGON_IDS_RID;
    SubAuthorities[1] = 0;
    SubAuthorities[2] = 0;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLogonSidIndex,
            &LsapNtAuthority,
            3,
            SubAuthorities,
            L"",
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_SYSTEM,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_SYSTEM_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalSystemSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_LOCALSERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_LOCAL_SERVICE_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapLocalServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_NETWORKSERVICE,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_NETWORK_SERVICE_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapNetworkServiceSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_RESTRICTED,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_RESTRICTED_CODE_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapRestrictedSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            SidName.Buffer,
            NtAuthorityName.Buffer,
            SidTypeWellKnownGroup
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_INTERNET,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapInternetDomainIndex,
            &InternetSiteAuthority,
            0,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }


    //
    // Initialize SIDs from the BUILTIN domain.  Leave the Name
    // field blank for the aliases as they can be renamed while
    // the system is running (and the lookup code will fall
    // through to SAM for these).
    //

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_BUILTIN,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));

    SubAuthorities[0] = SECURITY_BUILTIN_DOMAIN_RID;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapBuiltInDomainSidIndex,
            &LsapNtAuthority,
            1,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeDomain
            )) {

        goto InitializeWellKnownSidsError;
    }

    SubAuthorities[1] = DOMAIN_ALIAS_RID_USERS;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAliasUsersSidIndex,
            &LsapNtAuthority,
            2,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeAlias
            )) {

        goto InitializeWellKnownSidsError;
    }

    SubAuthorities[1] = DOMAIN_ALIAS_RID_ADMINS;

    if (!LsaIInitializeWellKnownSid(
            OutputWellKnownSids,
            LsapAliasAdminsSidIndex,
            &LsapNtAuthority,
            2,
            SubAuthorities,
            L"",
            SidName.Buffer,
            SidTypeAlias
            )) {

        goto InitializeWellKnownSidsError;
    }

    Status = LsapGetMessageStrings(
                StringsResource,
                LSAP_SID_NAME_USERS,
                &SidName,
                0,
                NULL
                ); ASSERT(NT_SUCCESS(Status));


    //
    // Check if all Sids initialized.
    //

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("\nLSA (dbinit): Displaying all well known sids...\n\n");
#endif //LSAP_DEBUG_MESSAGE_STRINGS

    for (WellKnownSidIndex = LsapNullSidIndex;
         WellKnownSidIndex < LsapDummyLastSidIndex;
         WellKnownSidIndex++) {

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                *%wZ* : *%wZ*\n",
            &OutputWellKnownSids[WellKnownSidIndex].DomainName,
            &OutputWellKnownSids[WellKnownSidIndex].Name);
#endif //LSAP_DEBUG_MESSAGE_STRINGS

        if (OutputWellKnownSids[WellKnownSidIndex].Sid == NULL) {

#if DBG
            DbgPrint(
                "Well Known Sid Index %d not initialized\n",
                WellKnownSidIndex
                );
#endif //DBG

        }
    }

    *WellKnownSids = OutputWellKnownSids;

    return(TRUE);

InitializeWellKnownSidsError:

    return(FALSE);
}


BOOLEAN
LsaIInitializeWellKnownSid(
    OUT PLSAP_WELL_KNOWN_SID_ENTRY WellKnownSids,
    IN LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN UCHAR SubAuthorityCount,
    IN PULONG SubAuthorities,
    IN PWSTR Name,
    IN PWSTR DomainName,
    IN SID_NAME_USE Use
    )

/*++

Routine Description:

    This function initializes an entry in the specified well-known Sid table.
    The entry contains the well known Sid and its name.

Arguments:

    WellKnownSids - Pointer to the first entry in the Well Known Sid table.

    WellKnownSidIndex - Index into table of Well Known Sids.

    Sid - Receives a pointer to a Sid with the correct size for the
       number of subauthorities specified.

    IdentifierAuthority - Pointer to Identifier authority.

    SubAuthorityCount - Count of SubAuthorities

    SubAuthorities - Array of SubAuthorities.

    Name - Pointer to Unicode Name buffer containing the Sid's Name

    DomainName - Pointer to Unicode Name buffer containing the
        Sids Domain Name (if any) or descriptive text, such as
        "Well Known Group" for Sids of Well Known Groups

    SidNameUse - Specifies code for Sid's Use.  The following values
        may be specified:

        SidTypeUser
        SidTypeGroup
        SidTypeDomain
        SidTypeAlias
        SidTypeWellKnownGroup
        SidTypeDeletedAccount
        SidTypeInvalid
        SidTypeUnknown

Return Value:

    BOOLEAN - TRUE if Sid initialized, else FALSE.

--*/

{
    PLSAP_WELL_KNOWN_SID_ENTRY
        WellKnownSidEntry = &WellKnownSids[WellKnownSidIndex];

    PSID OutputSid = NULL;

    OutputSid = RtlAllocateHeap(
                    RtlProcessHeap(),
                    0,
                    RtlLengthRequiredSid(SubAuthorityCount)
                    );

    if (OutputSid == NULL) {

        goto InitializeWellKnownSidError;
    }

    RtlInitializeSid( OutputSid, IdentifierAuthority, SubAuthorityCount);

    if (SubAuthorityCount != 0) {

        RtlCopyMemory(
            RtlSubAuthoritySid( OutputSid, 0 ),
            SubAuthorities,
            SubAuthorityCount * sizeof(ULONG)
            );
    }

    WellKnownSidEntry->Sid = OutputSid;

    //
    // Fill in the Domain Name
    //

    RtlInitUnicodeString(
        &WellKnownSidEntry->DomainName,
        DomainName
        );

    //
    // Fill in the Use and Name.
    //

    WellKnownSidEntry->Use = Use;
    RtlInitUnicodeString(
        &WellKnownSidEntry->Name,
        Name
        );

    return(TRUE);

InitializeWellKnownSidError:

#if DBG

    DbgPrint("LSA Initialization of Well Known Sids Failed\n");
    DbgPrint("Insufficient memory resources\n");

#endif // DBG

    return(FALSE);
}


NTSTATUS
LsapGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    )


/*++

Routine Description:

    This gets 1 or 2 message strings values from a resource message table.
    The string buffers are allocated and the strings initialized properly.

    The strings will be NULL terminated.

    The string buffers must be freed using LocalFree() when no longer needed.

Arguments:

    Resource - points to the resource table.

    Index1 - Index of first message to retrieve.

    String1 - Points to a UNICODE_STRING structure to receive the first
        message string.  The string will be null terminated.

    Index2 - Index of second message to retrieve.

    String2 - Points to a UNICODE_STRING structure to receive the first
        message string.  If this parameter is NULL, then only one message
        string is retrieved.  The string will be null terminated.

Return Value:

    None.

--*/


{

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("LSA (dbinit): String 1 -\n");
    DbgPrint("                           Index: 0x%lx\n", Index1);
#endif //LSAP_DEBUG_MESSAGE_STRINGS


    String1->Buffer    = NULL;

    String1->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index1,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String1->Buffer),
                                          0,
                                          NULL
                                          );

    if (String1->Buffer == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  However, we do need to null terminate our string
        // so we will convert the 0x0d into a null terminator.
        //
        // Also note that FormatMessage() returns a character count,
        // not a byte count.  So, we have to do some adjusting to make
        // the string lengths correct.
        //

        ASSERT(String1->MaximumLength >= 2);    // We always expect cr/lf on our strings

        //
        // Adjust character count
        //

        String1->MaximumLength -=  1; // For the lf - we'll convert the cr.

        //
        // Set null terminator
        //

        String1->Buffer[String1->MaximumLength - 1] = 0;

        //
        // Change lengths to byte count instead of character count
        //

        String1->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String1->Length = String1->MaximumLength - sizeof(WCHAR);

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                          String: %wZ\n", String1);
    DbgPrint("                             Max: (0x%lx)\n", String1->MaximumLength);
    DbgPrint("                             Cur: (0x%lx)\n", String1->Length);
    DbgPrint("                             ");
    {
        ULONG i;
        for (i=0; i<String1->MaximumLength; i++) {
            DbgPrint("%2x ", (*((PUCHAR)String1->Buffer)+i));
        }
        DbgPrint("\n");
    }
#endif //LSAP_DEBUG_MESSAGE_STRINGS
    }


    if (!ARGUMENT_PRESENT(String2)) {
        return(STATUS_SUCCESS);
    }

    String2->Buffer = NULL;
    String2->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index2,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String2->Buffer),
                                          0,
                                          NULL
                                          );

    if (String2->Buffer == NULL) {
        LocalFree( String1->Buffer );
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  However, we do need to null terminate our string
        // so we will convert the 0x0d into a null terminator.
        //
        // Also note that FormatMessage() returns a character count,
        // not a byte count.  So, we have to do some adjusting to make
        // the string lengths correct.
        //

        ASSERT(String2->MaximumLength >= 2);    // We always expect cr/lf on our strings

        //
        // Adjust character count
        //

        String2->MaximumLength -=  1; // For the lf - we'll convert the cr.

        //
        // Set null terminator
        //

        String2->Buffer[String2->MaximumLength - 1] = 0;

        //
        // Change lengths to byte count instead of character count
        //

        String2->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String2->Length = String2->MaximumLength - sizeof(WCHAR);

#ifdef LSAP_DEBUG_MESSAGE_STRINGS
    DbgPrint("                          String: %wZ\n", String2);
    DbgPrint("                             Max: (0x%lx)\n", String2->MaximumLength);
    DbgPrint("                             Cur: (0x%lx)\n", String2->Length);
    DbgPrint("                             ");
    {
        ULONG i;
        for (i=0; i<String2->MaximumLength; i++) {
            DbgPrint("%2x ", (*((PUCHAR)String2->Buffer)+i));
        }
        DbgPrint("\n");
    }
#endif //LSAP_DEBUG_MESSAGE_STRINGS
    }



    return(STATUS_SUCCESS);

}


#if defined(REMOTE_BOOT)
VOID
LsapDbInitializeRemoteBootState(
    )

/*++

Routine Description:

    This function initializes the remote boot state used by LSA.

Arguments:

    None.

Return Value:

    NTSTATUS - Standard Nt Result Code

        All Result Codes are generated by called routines.
--*/

{
    NTSTATUS Status ;
    HANDLE RdrDevice ;
    UNICODE_STRING String ;
    OBJECT_ATTRIBUTES ObjA ;
    IO_STATUS_BLOCK IoStatus ;

    //
    // This is the default if anything goes wrong.
    //

    LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_NO_NOTIFICATION;

    //
    // Open the redirector device.
    //

    RtlInitUnicodeString( &String, DD_NFS_DEVICE_NAME_U );

    InitializeObjectAttributes( &ObjA,
                                &String,
                                0,
                                0,
                                0);

    Status = NtOpenFile( &RdrDevice,
                         GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                         &ObjA,
                         &IoStatus,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0 );

    if ( !NT_SUCCESS( Status ) )
    {
        DebugLog(( DEB_TRACE, "FAILED to open %ws, status %x\n",
                        String.Buffer, Status ));
        return;
    }

    Status = NtFsControlFile(
                    RdrDevice,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatus,
                    FSCTL_LMMR_RI_IS_PASSWORD_SETTABLE,
                    NULL,
                    0,
                    NULL,
                    0 );

    if ( Status == STATUS_SUCCESS )
    {
        LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_NOTIFY;
    }
    else if ( Status == STATUS_UNSUCCESSFUL )
    {
        LsapDbState.RemoteBootState = LSAP_DB_REMOTE_BOOT_CANT_NOTIFY;
    }

    NtClose(RdrDevice);

}
#endif // defined(REMOTE_BOOT)




NTSTATUS
LsapGenerateRandomDomainSid(
    OUT PSID NewDomainSid
    )
/*++

Routine Description:

    This function will generate a random sid to be used for the new account domain sid during
    setup.

Arguments:

    NewDomainSid - Where the new domain sid is returned.  Freed via RtlFreeSid()


Return Values:

    STATUS_SUCCESS -- Success.
    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status;
    LARGE_INTEGER Time;
    KERNEL_USER_TIMES KernelUserTimes;
    ULONG Seed, SubAuth1, SubAuth2, SubAuth3;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;

    //
    // Generate 3 pseudo-random numbers using current tick count, the
    // system time, and the user-mode execution time of this process as
    // random number generator seeds.
    //
    Status = NtQuerySystemTime(&Time);

    if ( NT_SUCCESS( Status ) ) {

        Status = NtQueryInformationThread( NtCurrentThread(),
                                           ThreadTimes,
                                           &KernelUserTimes,
                                           sizeof(KernelUserTimes),
                                           NULL );
        if ( NT_SUCCESS( Status ) ) {

            Seed = GetTickCount() | GetCurrentTime();
            SubAuth1 = RtlRandom( &Seed );

            Seed = Time.LowPart;
            SubAuth2 = RtlRandom( &Seed );

            Seed = KernelUserTimes.UserTime.LowPart;
            SubAuth3 = RtlRandom( &Seed );

            Status = RtlAllocateAndInitializeSid( &IdentifierAuthority,
                                                  4,
                                                  0x15,
                                                  SubAuth1,
                                                  SubAuth2,
                                                  SubAuth3,
                                                  0,
                                                  0,
                                                  0,
                                                  0,
                                                  NewDomainSid );
        }
    }


    return( Status );
}



NTSTATUS
LsapSetupInitialize(
    VOID
    )
/*++

Routine Description:

    This function will generate a random sid to be used for the new account domain sid during
    setup.

Arguments:

    NewDomainSid - Where the new domain sid is returned.  Freed via RtlFreeSid()


Return Values:

    STATUS_SUCCESS -- Success.
    STATUS_INSUFFICIENT_RESOURCES -- A memory allocation failed

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSID NewDomainSid = NULL;
    HMODULE StringsResource;
    LSAPR_POLICY_ACCOUNT_DOM_INFO AccountDomainInfo;

    Status = LsapGenerateRandomDomainSid( &NewDomainSid );


    if ( NT_SUCCESS( Status ) ) {

        //
        // We can use GetModuleHandle, since we are getting it on ourselves.
        //
        StringsResource = (HMODULE) GetModuleHandle( L"LSASRV.DLL" );

        ASSERT( StringsResource );

        Status = LsapGetMessageStrings( StringsResource,
                                        LSAP_DEFAULT_DOMAIN_NAME,
                                        ( PUNICODE_STRING )&AccountDomainInfo.DomainName,
                                        0,
                                        NULL );
    }

    //
    // Ok, if  we got this far, then we can initialize the account domain
    //
    if ( NT_SUCCESS( Status ) ) {

        AccountDomainInfo.DomainSid = NewDomainSid;
        Status = LsarSetInformationPolicy( LsapPolicyHandle,
                                           PolicyAccountDomainInformation,
                                           ( PLSAPR_POLICY_INFORMATION )&AccountDomainInfo );

        LocalFree( AccountDomainInfo.DomainName.Buffer );
    }


    if ( NewDomainSid ) {

        RtlFreeSid( NewDomainSid );
    }


    return( Status );
}

static GUID LsapDbPasswordAuthenticator = {0xf0ce3a80,0x155f,0x11d3,0xb7,0xe6,0x00,0x80,0x5f,0x48,0xca,0xeb};

NTSTATUS
LsapDbGenerateNewKey(
    IN LSAP_DB_ENCRYPTION_KEY * NewEncryptionKey
    )
/*++

  Routine Description

    This routine generates a new Encryption key that can be used for
    encrypting secrets.

  Parameters

    NewEncryptionKey -- Pointer to a structure that contains the new key

  Return Values

    STATUS_SUCCESS
    STATUS_UNSUCCESSFUL
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // generate a random number for the key
    //

    if (!RtlGenRandom(NewEncryptionKey->Key,sizeof(NewEncryptionKey->Key)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Copy in the GUID for the authenticator
    //

    NewEncryptionKey->Authenticator = LsapDbPasswordAuthenticator;


    //
    // Set the version #
    //

    NewEncryptionKey->Revision = LSAP_DB_ENCRYPTION_KEY_VERSION ;
    NewEncryptionKey->Flags = 0;

    //
    // Generate a Salt
    //

    if (!RtlGenRandom(NewEncryptionKey->Salt,sizeof(NewEncryptionKey->Salt)))
    {
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // Generate a random value for the old syskey
    //

    if (!RtlGenRandom(NewEncryptionKey->OldSyskey,sizeof(NewEncryptionKey->OldSyskey)))
    {
        return(STATUS_UNSUCCESSFUL);
    }


    //
    // Set the boot type
    //

    NewEncryptionKey->BootType = WxStored;


    return(STATUS_SUCCESS);
}

VOID
LsapDbEncryptKeyWithSyskey(
    OUT LSAP_DB_ENCRYPTION_KEY * KeyToEncrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    )
/*++

  This routine encrypts the KeyToEncrypt parameter with
  the syskey passed in

  Arguments

    KeyToEncrypt -- the key to encrypt
    Syskey       -- The syskey passed in
    SyskeyLength -- The length of the syskey

  Return Values

    None, void function
--*/
{
    MD5_CTX Md5Context;
    struct RC4_KEYSTRUCT Rc4Key;
    ULONG  i;

    //
    // Create an MD5 hash of the key and salt
    //

    MD5Init(&Md5Context);

    MD5Update(
        &Md5Context,
        Syskey,
        SyskeyLength
        );
    //
    // Hash in the salt many many times. This slows down
    // attackers employing a brute force approach to attack
    //

    for (i=0;i<1000;i++)
    {
        MD5Update(
            &Md5Context,
            KeyToEncrypt->Salt,
            sizeof(KeyToEncrypt->Salt)
            );
    }

    MD5Final(
        &Md5Context
        );

    //
    // Initialize the RC4 key sequence.
    //

    rc4_key(
        &Rc4Key,
        MD5DIGESTLEN,
        Md5Context.digest
        );



    rc4(
        &Rc4Key,
        sizeof(KeyToEncrypt->Key)+ sizeof(KeyToEncrypt->Authenticator)+sizeof(KeyToEncrypt->OldSyskey),
        (PUCHAR) &KeyToEncrypt->Authenticator

        );

}



NTSTATUS
LsapDbDecryptKeyWithSyskey(
    IN LSAP_DB_ENCRYPTION_KEY * KeyToDecrypt,
    IN PVOID                    Syskey,
    IN ULONG                    SyskeyLength
    )
/*++

  This function provides a decryption using the syskey. Since RC4 is symmetric
  encryption algorithm, this function simply calls the previous encrypt routine

   Arguments

    KeyToDecrypt -- the key to dencrypt
    Syskey       -- The syskey passed in
    SyskeyLength -- The length of the syskey

  Return Values

    STATUS_SUCCESS , on successful decryption
    STATUS_WRONG_PASSWORD on unsuccessful decryption

--*/
{

    LsapDbEncryptKeyWithSyskey(KeyToDecrypt,Syskey,SyskeyLength);

    if (!RtlEqualMemory(&KeyToDecrypt->Authenticator,&LsapDbPasswordAuthenticator,sizeof(GUID)))
    {
        return(STATUS_WRONG_PASSWORD);
    }

    return(STATUS_SUCCESS);
}


NTSTATUS
LsapDbSetupInitialSyskey(
    OUT PULONG  SyskeyLength,
    OUT PVOID   *Syskey
    )
/*++

    This generates a new syskey and changes the winlogon state such that
    winlogon recognizes the new syskey and the boot option of system saves
    syskey.

    Arguments

        SyskeyLength -- The length of the syskey is returned in here
        Syskey       -- The syskey itself is returned in here

    Return Values

        STATUS_SUCCESS
        Other resource error codes
--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;


    *Syskey = LsapAllocateLsaHeap(LSAP_SYSKEY_SIZE );
    if (NULL==*Syskey)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    *SyskeyLength = LSAP_SYSKEY_SIZE;

    //
    // Generate the syskey
    //

    if (!RtlGenRandom( *Syskey, *SyskeyLength))
    {
        NtStatus = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    //
    // Save the syskey in the registry
    // If this operation fails, then no state is changed, machine remains
    // un syskey-d till next boot
    //

    NtStatus = WxSaveSysKey(*SyskeyLength, *Syskey);


    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Set the boot option in the registry
    // If this operation fails, still no problem. Machine remains unsyskey'd
    // and the boot key that has been saved will be reset on next boot.
    //

    NtStatus = WxSaveBootOption(WxStored);
    if (!NT_SUCCESS(NtStatus))
        goto Error;


Error:

    if (!NT_SUCCESS(NtStatus))
    {
        *SyskeyLength = 0;
        if (NULL!=*Syskey)
        {
            MIDL_user_free(*Syskey);
        }
    }

    return(NtStatus);

}




NTSTATUS
LsapDbGetSyskeyFromWinlogon()
/*++

    Routine Description

        This routine obtains the syskey from winlogon and decrypts the
        Password encryption key in the LSA policy database. The global variable
        LsapDbSecretCipherKey is set with the password encryption key and the
        the global variable LsapDbSyskey is set with the syskey. This value is
        then queried by SAM/DS to decrypt their respective password encryption keys
        and then cleared before the end of SamIInitialize.

        The special case handled inside this routine is of the case of a fresh install.
        In this particular case winlogon is not yet setup to expect a query of syskey
        from the lsass process. However since the LSA install code has been called just
        moments, before, that code sets the winlogon state and also fills the global
        LsapDbSyskey. Therefore if LsapDbSyskey is not NULL then this would be the
        fresh install case.

    Arguments

        None

    Return Values

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL

 --*/
{
    NTSTATUS       Status = STATUS_SUCCESS;
    NTSTATUS       DecryptStatus = STATUS_SUCCESS;
    ULONG          DecryptionKeyLength = 0;
    HANDLE         WinlogonHandle=NULL;
    ULONG          Tries = 0;
    LSAP_DB_ENCRYPTION_KEY  StoredEncryptionKeyData;
    ULONG          StoredEncryptionKeyDataLength = sizeof( LSAP_DB_ENCRYPTION_KEY );
    ULONG          SyskeyLen=LSAP_SYSKEY_SIZE;
    BOOLEAN        FreshInstall=FALSE;


    //
    // Read the attribute information in the LSA policy database
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolSecretEncryptionKey],
                 (PVOID) &StoredEncryptionKeyData,
                 &StoredEncryptionKeyDataLength
                 );

    if ( !NT_SUCCESS(Status) ) {
       goto Cleanup;
    }

    if (NULL!=LsapDbSysKey)
    {
        //
        // In the fresh install case , code in dbinstal.c already
        // sets LsapDbSyskey to the syskey value.
        //

        FreshInstall = TRUE;
        Status = LsapDbDecryptKeyWithSyskey(
                            &StoredEncryptionKeyData ,
                            LsapDbSysKey,
                            LSAP_SYSKEY_SIZE
                            );
    }
    else
    {
        //
        // because LsapDbDecryptKeyWithSyskey() is an in-place
        // operation, so we'd better save the Encrypted Syskey first
        //

        LSAP_DB_ENCRYPTION_KEY  TempStoredEncryptionKeyData;

        TempStoredEncryptionKeyData = StoredEncryptionKeyData;

        //
        // Call Winlogon to obtain the key information.
        //

        Status = WxConnect(
                    &WinlogonHandle
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Winlogon may fail if secret encryption is not enabled. In those
            // cases continue. Else Fail the boot
            //
            if (WxNone==StoredEncryptionKeyData.BootType)
            {
                Status = STATUS_SUCCESS;
            }

            goto Cleanup;
        }


        for (Tries = 0; Tries < LSAP_BOOT_KEY_RETRY_COUNT ; Tries++ )
        {

            //
            // restore the data which need to be decrypted.
            //

            StoredEncryptionKeyData = TempStoredEncryptionKeyData;

            //
            // Retry this RETRY_COUNT_TIMES, this allows the user a chance
            // to correct himself, in case he entered a wrong boot password
            //

            if (WxNone!=StoredEncryptionKeyData.BootType)
            {
                //
                // Get the key to be used to decrypt the PEK list
                //

                Status = WxGetKeyData(
                            WinlogonHandle,
                            StoredEncryptionKeyData.BootType,
                            LSAP_SYSKEY_SIZE,
                            SyskeyBuffer,
                            &SyskeyLen
                            );

                if (!NT_SUCCESS(Status)) {
                    goto Cleanup;
                }

                ASSERT(SyskeyLen==LSAP_SYSKEY_SIZE);


                //
                // Decrypt the Blob passed in with the key supplied by winlogon
                //

                Status =    LsapDbDecryptKeyWithSyskey(
                                    &StoredEncryptionKeyData ,
                                    SyskeyBuffer,
                                    LSAP_SYSKEY_SIZE
                                    );

                if (!NT_SUCCESS(Status))
                {
                    DecryptStatus = STATUS_WRONG_PASSWORD;
                }
                else
                {
                    //
                    // We successfully decrypted, break out of the loop
                    //

                    DecryptStatus = STATUS_SUCCESS;
                    break;
                }
            }
            else
            {
                break;
            }
        }

        //
        // Tell winlogon regarding success or failure of the scheme
        //

        Status = WxReportResults(
                    WinlogonHandle,
                    DecryptStatus
                    );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        Status = DecryptStatus;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Initialize the new secret cipher key
        // The keys used for reading and writing secrets are ordinarily the same
        //

        LsapDbInitializeSecretCipherKeyRead( &StoredEncryptionKeyData );
        LsapDbInitializeSecretCipherKeyWrite( &StoredEncryptionKeyData );

        if (!FreshInstall)
        {
            //
            // Set the global variable LsapDBSysKey
            //
            LsapDbSysKey = SyskeyBuffer;
 
 
            //
            // Set up the old syskey for recovery cases
            // by SAM and LSA
            //
 
            RtlCopyMemory(
                OldSyskeyBuffer,
                StoredEncryptionKeyData.OldSyskey,
                sizeof(StoredEncryptionKeyData.OldSyskey)
                );
 
            LsapDbOldSysKey = OldSyskeyBuffer;
        }
    }

Cleanup:

    if (WinlogonHandle != NULL) {
        NtClose(WinlogonHandle);
    }

    return(Status);
}


VOID
LsapDbInitializeSecretCipherKeyRead(
    PLSAP_DB_ENCRYPTION_KEY PassedInEncryptionKeyData
    )
/*++

    Routine Description

       Given a pointer to the encryption key ( as in the struct ), this routine
       initializes a CipherKey structure that can be used by the LSA's secret encryption
       and decryption routines.

    Arguments

        PassedInEncryptionKeyData -- The struct representing the key

    Return Values

        Void function
--*/
{
    static         LSAP_DB_ENCRYPTION_KEY  StaticEncryptionKeyData;
    static         LSAP_CR_CIPHER_KEY   DecryptedSecretCipherKey;

    RtlCopyMemory(&StaticEncryptionKeyData,PassedInEncryptionKeyData,sizeof(LSAP_DB_ENCRYPTION_KEY));

    DecryptedSecretCipherKey.Buffer = StaticEncryptionKeyData.Key;
    DecryptedSecretCipherKey.Length = DecryptedSecretCipherKey.MaximumLength
            = sizeof(StaticEncryptionKeyData.Key);
    LsapDbSecretCipherKeyRead = &DecryptedSecretCipherKey;
}


VOID
LsapDbInitializeSecretCipherKeyWrite(
    PLSAP_DB_ENCRYPTION_KEY PassedInEncryptionKeyData
    )
/*++

    Routine Description

       Given a pointer to the encryption key ( as in the struct ), this routine
       initializes a CipherKey structure that can be used by the LSA's secret encryption
       and decryption routines.

    Arguments

        PassedInEncryptionKeyData -- The struct representing the key
        CipherKey                 -- The structure that needs to be initialzed with the
                                     key for LSA's secret encryption

    Return Values

        Void function
--*/
{
    static         LSAP_DB_ENCRYPTION_KEY  StaticEncryptionKeyData;
    static         LSAP_CR_CIPHER_KEY   DecryptedSecretCipherKey;

    RtlCopyMemory(&StaticEncryptionKeyData,PassedInEncryptionKeyData,sizeof(LSAP_DB_ENCRYPTION_KEY));

    DecryptedSecretCipherKey.Buffer = StaticEncryptionKeyData.Key;
    DecryptedSecretCipherKey.Length = DecryptedSecretCipherKey.MaximumLength
            = sizeof(StaticEncryptionKeyData.Key);
    LsapDbSecretCipherKeyWrite = &DecryptedSecretCipherKey;
}


VOID
LsapDbSetSyskey(
    PVOID Syskey,
    ULONG SyskeyLength
    )
/*++

    This function sets the syskey in the global syskey buffer

--*/
{
    ASSERT(LSAP_SYSKEY_SIZE==SyskeyLength);
    RtlCopyMemory(SyskeyBuffer,Syskey,SyskeyLength);
    LsapDbSysKey = SyskeyBuffer;
}

NTSTATUS
LsaISetBootOption(
   IN ULONG BootOption,
   IN PVOID OldKey,
   IN ULONG OldKeyLength,
   IN PVOID NewKey,
   IN ULONG NewKeyLength
   )
/*++

    This function is used to change the syskey value in the LSA, or change
    the boot option type.

    Arguments

        BootOption    -- New Boot Option
        OldKey        -- Old key, used to verify value
        OldKeyLength  -- Length of old key
        NewKey        -- New key, LSA's password encryption key is encrypted using
                         this value
        NewKeyLength  -- Length of new key

    Return Values

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG          StoredEncryptionKeyDataLength = sizeof( LSAP_DB_ENCRYPTION_KEY );
    LSAP_DB_ENCRYPTION_KEY  StoredEncryptionKeyData;
    ULONG          SyskeyLen=0;
    LSAP_DB_ATTRIBUTE Attributes[20];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;

    NextAttribute = Attributes;


    //
    // Validate Some parameters
    //

    if ((NewKeyLength != LSAP_SYSKEY_SIZE ) || (OldKeyLength != LSAP_SYSKEY_SIZE))
    {
        return (STATUS_INVALID_PARAMETER);
    }

    if ((NULL==NewKey) || (NULL==OldKey))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    //
    // Read the attribute information in the LSA policy database
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolSecretEncryptionKey],
                 (PVOID) &StoredEncryptionKeyData,
                 &StoredEncryptionKeyDataLength
                 );

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }


    //
    // Decrypt the data
    //

    Status =  LsapDbDecryptKeyWithSyskey(
                &StoredEncryptionKeyData,
                OldKey,
                OldKeyLength
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Change the boot option
    //

    StoredEncryptionKeyData.BootType = BootOption;

    //
    // Save the old key  ( for recovery )
    //

    ASSERT(sizeof(StoredEncryptionKeyData.OldSyskey) == OldKeyLength);

    RtlCopyMemory(
        &StoredEncryptionKeyData.OldSyskey,
        OldKey,
        OldKeyLength
        );

    //
    // Re-encrypt the data using the new key
    //

    LsapDbEncryptKeyWithSyskey(
                &StoredEncryptionKeyData,
                NewKey,
                NewKeyLength
                );


    LsapDbInitializeAttribute(
        NextAttribute,
        &LsapDbNames[PolSecretEncryptionKey],
        &StoredEncryptionKeyData,
        sizeof (StoredEncryptionKeyData),
        FALSE
        );

    NextAttribute++;
    AttributeCount++;

    //
    // Now write out all attributes that have been added (if any)
    //

    if (AttributeCount > 0) {

        Status = LsapDbReferenceObject(
                    LsapDbHandle,
                    0,
                    PolicyObject,
                    PolicyObject,
                    LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                    );

        if (NT_SUCCESS(Status)) {

            ASSERT( AttributeCount < ( sizeof( Attributes ) / sizeof( LSAP_DB_ATTRIBUTE ) ) );
            Status = LsapDbWriteAttributesObject(
                         LsapDbHandle,
                         Attributes,
                         AttributeCount
                         );

            //
            // No attributes are replicatable.
            //  (That's good, too, since SAM hasn't told Netlogon our role yet.)

            Status = LsapDbDereferenceObject(
                         &LsapDbHandle,
                         PolicyObject,
                         PolicyObject,
                         (LSAP_DB_LOCK |
                            LSAP_DB_FINISH_TRANSACTION |
                            LSAP_DB_OMIT_REPLICATOR_NOTIFICATION ),
                         SecurityDbChange,
                         Status
                         );
        }
    }

Cleanup:


    return(Status);

}

NTSTATUS
LsaIGetBootOption(
   OUT PULONG BootOption
   )
/*++

    This function is used to obtain the boot option from LSA

    Arguments

        BootOption    -- New Boot is passed in here

    Return Values

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG          StoredEncryptionKeyDataLength = sizeof( LSAP_DB_ENCRYPTION_KEY );
    LSAP_DB_ENCRYPTION_KEY  StoredEncryptionKeyData;


    //
    // Read the attribute information in the LSA policy database
    //

    Status = LsapDbReadAttributeObject(
                 LsapDbHandle,
                 &LsapDbNames[PolSecretEncryptionKey],
                 (PVOID) &StoredEncryptionKeyData,
                 &StoredEncryptionKeyDataLength
                 );

    if (!NT_SUCCESS(Status) ) {

        goto Cleanup;
    }

    *BootOption = StoredEncryptionKeyData.BootType;

Cleanup:


    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbdomain.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbdomain.c

Abstract:

    LSA Database - Trusted Domain Object Private API Workers

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.

Author:

    Scott Birrell       (ScottBi)      January 13, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <dns.h>
#include <dnsapi.h>
#include <names.h>
#include <malloc.h>
#include "lsawmi.h"
#include <logonmsv.h>

LSAP_DB_TRUSTED_DOMAIN_LIST LsapDbTrustedDomainList;
BOOLEAN LsapDbReturnAuthData;

//
// Local function prototypes
//
VOID
LsapDbBuildTrustInfoExForTrustInfo(
    IN PLSAPR_UNICODE_STRING Domain,
    IN PLSAPR_SID Sid,
    IN OUT PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx
    )
/*++

Routine Description:

    This takes the equivalent of a TRUST_INFORMATION structure and converts
    it to a TRUSTED_DOMAIN_INFORMATION_EX structure

Arguments:

    Domain -- Domain name

    Sid -- Domain sid

    TrustInfoEx -- Pointer to a structure to initialize

--*/
{
    RtlCopyMemory( &TrustInfoEx->Name,
                   Domain,
                   sizeof( UNICODE_STRING ) );
    RtlCopyMemory( &TrustInfoEx->FlatName,
                   Domain,
                   sizeof( UNICODE_STRING ) );
    TrustInfoEx->Sid = Sid;
    TrustInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
    TrustInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
    TrustInfoEx->TrustAttributes = 0;


}

NTSTATUS
LsapNotifyNetlogonOfTrustChange(
    IN  PSID pChangeSid,
    IN  SECURITY_DB_DELTA_TYPE ChangeType
    )
/*++

Routine Description:

    This function will notify netlogon when a trusted domain object comes or
    goes into or out of existence


Arguments:

    pChangeSid - The sid of the trusted domain object that changed

    IsDeletion - Indicates whether the trusted domain was added or removed

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo = NULL;

    //
    // Get our domain sid
    //
    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyPrimaryDomainInformation,
                 (PLSAPR_POLICY_INFORMATION *) &PolicyPrimaryDomainInfo
                 );

    if ( NT_SUCCESS(Status) ) {

        Status = I_NetNotifyTrustedDomain ( PolicyPrimaryDomainInfo->Sid,
                                            pChangeSid,
                                            ( BOOLEAN )(ChangeType == SecurityDbDelete ?
                                                                                TRUE : FALSE ));

        LsaIFree_LSAPR_POLICY_INFORMATION( PolicyPrimaryDomainInformation,
                                           (PLSAPR_POLICY_INFORMATION)PolicyPrimaryDomainInfo );
    }


    if ( LsapKerberosTrustNotificationFunction ) {

        LsaIRegisterNotification( ( SEC_THREAD_START )LsapKerberosTrustNotificationFunction,
                                  ( PVOID ) ChangeType,
                                  NOTIFIER_TYPE_IMMEDIATE,
                                  0,
                                  NOTIFIER_FLAG_ONE_SHOT,
                                  0,
                                  0 );
    }


    return(Status);
}





NTSTATUS
LsarCreateTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUST_INFORMATION TrustedDomainInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateTrustedDomain API.

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAPR_TRUSTED_DOMAIN_INFORMATION_EX ExInfo;

    LsarpReturnCheckSetup();

    LsapDbBuildTrustInfoExForTrustInfo( &TrustedDomainInformation->Name,
                                        TrustedDomainInformation->Sid,
                                        &ExInfo );

    Status = LsapCreateTrustedDomain2( PolicyHandle, &ExInfo, NULL,
                                       DesiredAccess,
                                       TrustedDomainHandle );

    LsarpReturnPrologue();

    return( Status );
}



NTSTATUS
LsapCreateTrustedDomain2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )
/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaCreateTrustedDomain API.

    The LsaCreateTrustedDomain API creates a new TrustedDomain object.  The
    caller must have POLICY_TRUST_ADMIN access to the Policy Object.

    Note that NO verification is done to check that the given domain name
    matches the given SID or that the SID or name represent an actual domain.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to structure containing the name and
        SID of the new Trusted Domain.

    DesiredAccess - Specifies the accesses to be granted for the newly
        created object.

    TrustedDomainHandle - receives a handle referencing the newly created
        object.  This handle is used on subsequent accesses to the object.

        The returned handle has a reference to the passed in PolicyHandle. So,
        when the TrustedDomainHandle is closed, either call LsapCloseHandle or at least
        call LsapDbDereferenceObject passing in LSAP_DB_DEREFERENCE_CONTR.

Returns:

    STATUS_SUCCESS - Success

    STATUS_DIRECTORY_SERVICE_REQUIRED - An attempt was made to create a trusted domain
        object on a non-DC

    STATUS_INVALID_SID - An invalid sid was specified

    STATUS_UNSUCCESSFUL - Unable to obtain the product type

    STATUS_CURRENT_DOMAIN_NOT_ALLOWED - Can not add the current domain to the trusted domain list

    STATUS_INVALID_DOMAIN_STATE - Forest transitive bit can not be specified on this DC

--*/
{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus = STATUS_SUCCESS;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    UNICODE_STRING LogicalNameU;
    BOOLEAN AcquiredListWriteLock = FALSE;
    DNS_STATUS DnsStatus;
    BOOLEAN AllLocksLocked = FALSE;
    BOOLEAN ClientPolicyHandleReferenced = FALSE;
    BOOLEAN AttributeBuffersAllocated = FALSE;
    PSID DomainSid;
    ULONG AttributeCount = 0;
    LSAP_DB_HANDLE InternalTrustedDomainHandle = NULL;
    PVOID TrustedDomainNameAttributeValue = NULL;
    ULONG TrustedDomainPosixOffset;
    BOOLEAN TrustCreated = FALSE;
    PLSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthHalf;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;
    ULONG   CriticalValue = 0;
    PPOLICY_DNS_DOMAIN_INFO PolicyDnsDomainInfo = NULL;

    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsapCreateTrustedDomain2" );

    LogicalNameU.Length = 0;

    if (LsapProductSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        Status = STATUS_NOT_SUPPORTED_ON_SBS;
        goto CreateTrustedDomainError;
    }

    if (!ARGUMENT_PRESENT( TrustedDomainInformation )) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateTrustedDomainError;
    }

    //
    // Creating a trust with the forest transitive bit set is not legal
    // outside of the root domain of the forest
    //

    if ( !LsapDbDcInRootDomain() &&
         ( TrustedDomainInformation->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto CreateTrustedDomainError;
    }

    //
    // Creating a trust with the forest transitive bit set is not legal
    // until all domains are upgraded to Whistler
    //

    if ( !LsapDbNoMoreWin2K() &&
         ( TrustedDomainInformation->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

        Status = STATUS_INVALID_DOMAIN_STATE;
        goto CreateTrustedDomainError;
    }

    //
    // If this is not a Dc, then return an error.  Creating trust on a client is
    // not supported
    //

    //
    // We allow this API to be called before we're completely initialized
    // for installation reasons.  However, it is the responsibility of the
    // installation program to not call it before the Product Type is
    // obtainable from the Registry.
    //
    if (!LsapDbIsServerInitialized()) {

        if ( !RtlGetNtProductType(&LsapProductType) ) {

            Status = STATUS_UNSUCCESSFUL;
            goto CreateTrustedDomainError;
        }
    }

    if ( !LsaDsStateInfo.UseDs ) {

        Status = STATUS_DIRECTORY_SERVICE_REQUIRED;
        goto CreateTrustedDomainError;
    }

    //
    // Validate the input argument formats
    //
    
    if ( !LsapValidateLsaUnicodeString( &TrustedDomainInformation->Name ) ||
         !LsapValidateLsaUnicodeString( &TrustedDomainInformation->FlatName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto CreateTrustedDomainError;
    }

    //
    // Fix the name to ensure that it doesn't have a trailing period
    //
    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        if ( TrustedDomainInformation->Name.Length == 0 ||
                                        TrustedDomainInformation->Name.Buffer == NULL ) {

            Status = STATUS_INVALID_PARAMETER;
            goto CreateTrustedDomainError;
        }

        if ( TrustedDomainInformation->Name.Buffer[
                    (TrustedDomainInformation->Name.Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainInformation->Name.Buffer[
                    (TrustedDomainInformation->Name.Length - 1) / sizeof(WCHAR)] = UNICODE_NULL;
            TrustedDomainInformation->Name.Length -= sizeof(WCHAR);

        }
    }

    //
    // Check to make sure the flat name is actually valid
    //

    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL ||
         TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        BOOLEAN Valid;

        Status = LsapValidateNetbiosName(
                     ( UNICODE_STRING * )&TrustedDomainInformation->FlatName,
                     &Valid
                     );

        if ( NT_SUCCESS( Status ) && !Valid ) {

            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if ( !NT_SUCCESS( Status )) {

            goto CreateTrustedDomainError;
        }
    }

    //
    // Now, do the same for the domain name
    //

    if ( TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) {

        BOOLEAN Valid;

        Status = LsapValidateDnsName(
                     ( UNICODE_STRING * )&TrustedDomainInformation->Name,
                     &Valid
                     );

        if ( NT_SUCCESS( Status ) && !Valid ) {

            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if ( !NT_SUCCESS( Status )) {

            goto CreateTrustedDomainError;
        }
    }

    //
    // Validate the Trusted Domain Sid.
    //

    DomainSid = TrustedDomainInformation->Sid;

    if ( DomainSid && !RtlValidSid( DomainSid ) ) {

        Status = STATUS_INVALID_SID;
        goto CreateTrustedDomainError;
    }

    if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted && DomainSid == NULL &&
         ( TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL ||
           TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL ) ) {

        Status = STATUS_INVALID_SID;
        goto CreateTrustedDomainError;
    }

    //
    // Guard against adding self to the trusted domain list
    //

    Status = LsapDbQueryInformationPolicy(
                 LsapPolicyHandle,
                 PolicyDnsDomainInformation,
                 ( PLSAPR_POLICY_INFORMATION *)&PolicyDnsDomainInfo );

    if ( !NT_SUCCESS( Status ) ) {

        goto CreateTrustedDomainError;
    }

    //
    // Catch attempts to create a TDO with the same SID as the SID of this domain
    //

    if ( DomainSid != NULL && PolicyDnsDomainInfo->Sid != NULL &&
         RtlEqualSid( DomainSid, PolicyDnsDomainInfo->Sid ) ) {

        Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
        goto CreateTrustedDomainError;
    }

    //
    // Catch attempts to create a TDO with the same name as this domain
    //

    if ( TrustedDomainInformation->Name.Buffer != NULL ) {

        if ( PolicyDnsDomainInfo->Name.Buffer != NULL &&
             RtlEqualUnicodeString(
                 ( PUNICODE_STRING )&TrustedDomainInformation->Name,
                 ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;

        } else if ( PolicyDnsDomainInfo->DnsDomainName.Buffer != NULL &&
                    RtlEqualUnicodeString(
                        ( PUNICODE_STRING )&TrustedDomainInformation->Name,
                        ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsDomainName, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;
        }
    }

    if ( TrustedDomainInformation->FlatName.Buffer != NULL ) {

        if ( PolicyDnsDomainInfo->Name.Buffer != NULL &&
             RtlEqualUnicodeString(
                 ( PUNICODE_STRING )&TrustedDomainInformation->FlatName,
                 ( PUNICODE_STRING )&PolicyDnsDomainInfo->Name, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;

        } else if ( PolicyDnsDomainInfo->DnsDomainName.Buffer != NULL &&
                    RtlEqualUnicodeString(
                        ( PUNICODE_STRING )&TrustedDomainInformation->FlatName,
                        ( PUNICODE_STRING )&PolicyDnsDomainInfo->DnsDomainName, TRUE ) ) {

            Status = STATUS_CURRENT_DOMAIN_NOT_ALLOWED;
            goto CreateTrustedDomainError;
        }
    }

    //
    // Grab all of the locks.
    //
    // There are code paths where we lock Policy, secret, trusted domain and
    // registry locks, there is no convenient order.  So grab them all.
    //

    LsapDbAcquireLockEx( AllObject, 0 );

    AllLocksLocked = TRUE;

    //
    // Verify that the PolicyHandle is valid.
    // Reference the Policy Object handle (as container object).
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK );

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    ClientPolicyHandleReferenced = TRUE;

    //
    // Validate whether the name/flat name is not already in use
    //
    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {
        goto CreateTrustedDomainError;
    }

    RtlCopyMemory(&InputTrustInformation.Name,&TrustedDomainInformation->Name,sizeof(UNICODE_STRING));
    InputTrustInformation.Sid = NULL;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (STATUS_SUCCESS==Status)
    {
        LsapDbReleaseLockTrustedDomainList();
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto CreateTrustedDomainError;
    }

    RtlCopyMemory(&InputTrustInformation.Name,&TrustedDomainInformation->FlatName,sizeof(UNICODE_STRING));
    InputTrustInformation.Sid = NULL;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );
    LsapDbReleaseLockTrustedDomainList();

    if (STATUS_SUCCESS==Status)
    {
        Status = STATUS_OBJECT_NAME_COLLISION;
        goto CreateTrustedDomainError;
    }

    //
    // Construct the Trusted Domain Name attribute info.
    //

    NextAttribute = Attributes;

    Status = LsapDbMakeUnicodeAttributeDs(
                     (PUNICODE_STRING) &TrustedDomainInformation->Name,
                     TrDmName,
                     NextAttribute );

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    AttributeBuffersAllocated = TRUE;


    NextAttribute++;
    AttributeCount++;

    //
    // Construct the Trusted Domain Sid attribute info
    //

    if ( DomainSid ) {

        Status = LsapDbMakeSidAttributeDs(
                     DomainSid,
                     Sid,
                     NextAttribute
                     );
        if (!NT_SUCCESS(Status)) {

            goto CreateTrustedDomainError;
        }

        NextAttribute++;
        AttributeCount++;
    }

    //
    // Set critical system object for the trusted domain
    //

    CriticalValue = 1;
    LsapDbInitializeAttributeDs( NextAttribute,
                                 PseudoSystemCritical,
                                 &CriticalValue,
                                 sizeof( ULONG ),
                                 FALSE );
    NextAttribute++;
    AttributeCount++;

    //
    // Set the Posix Offset for this Trusted Domain.
    //
    // The rules are as follows:
    //
    // For a PDC, set the Posix Offset to the value.
    //
    // For a BDC, set the Posix Offset to the null Posix offset.  It will be
    // set on the PDC when the TDO is replicated there.
    //

    TrustedDomainPosixOffset = SE_NULL_POSIX_OFFSET;

    if ( LsapNeedPosixOffset( TrustedDomainInformation->TrustDirection,
                              TrustedDomainInformation->TrustType ) ) {
        DOMAIN_SERVER_ROLE ServerRole = DomainServerRolePrimary;

        //
        // Query the server role, PDC/BDC
        //

        Status = SamIQueryServerRole(
                    LsapAccountDomainHandle,
                    &ServerRole
                    );


        if (!NT_SUCCESS(Status)) {
            goto CreateTrustedDomainError;
        }

        if ( ServerRole == DomainServerRolePrimary ) {

            //
            // Need to grab the TDL write lock while allocating a Posix Offset
            //

            Status = LsapDbAcquireWriteLockTrustedDomainList();

            if ( !NT_SUCCESS(Status)) {
                goto CreateTrustedDomainError;
            }

            AcquiredListWriteLock = TRUE;


            //
            // Allocate the next available Posix Offset.
            //

            Status = LsapDbAllocatePosixOffsetTrustedDomainList(
                         &TrustedDomainPosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto CreateTrustedDomainError;
            }
        }

    }

    //
    // Add a transaction to write the Posix Offset to the Trusted Domain
    // object when it is created.
    //

    LsapDbInitializeAttributeDs(
        NextAttribute,
        TrDmPxOf,
        &TrustedDomainPosixOffset,
        sizeof(TrustedDomainPosixOffset),
        FALSE
        );

    NextAttribute++;
    AttributeCount++;

    //
    // Construct the Logical Name (Internal LSA Database Name) of the
    // Trusted Domain object.
    //

    if ( LsapDsWriteDs ) {


        //
        // Create the object name as the domain name.  There will be another mechanism in
        // place to ensure that the object name is kept in synch with the Dns domain Name
        //
        RtlCopyMemory( &LogicalNameU,
                       (PUNICODE_STRING) &TrustedDomainInformation->Name,
                       sizeof( UNICODE_STRING ) );

    } else {

        // The Logical Name is constructed from the Domain Sid by converting it into
        // a Unicode Sstring
        Status = LsapDbSidToLogicalNameObject( DomainSid, &LogicalNameU );

    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    //
    // Fill in the ObjectInformation structure.  Initialize the
    // embedded Object Attributes with the PolicyHandle as the
    // Root Directory (Container Object) handle and the Logical Name (Rid)
    // of the Trusted Domain. Store the types of the object and its container.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,
        NULL
        );

    ObjectInformation.ObjectTypeId = TrustedDomainObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = DomainSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;



    if ( LsapDsWriteDs ) {

        ULONG TrustAttributesValue;
        PBYTE AuthBuffer;
        ULONG AuthSize;

        //
        // Set the Netbios domain name
        //
        Status = LsapDbMakeUnicodeAttributeDs(
                     (PUNICODE_STRING) &TrustedDomainInformation->FlatName,
                     TrDmTrPN,
                     NextAttribute
                     );
        if ( !NT_SUCCESS( Status ) ) {

            goto CreateTrustedDomainError;
        }

        NextAttribute++;
        AttributeCount++;


        //
        // Set the trust type and direction
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainInformation->TrustType,
            sizeof( TrustedDomainInformation->TrustType ),
            FALSE
            );
        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainInformation->TrustDirection,
            sizeof( TrustedDomainInformation->TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainInformation->TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Authentication data
        //
        AuthHalf = LsapDsAuthHalfFromAuthInfo( AuthenticationInformation, TRUE );

        Status = LsapDsBuildAuthInfoAttribute( PolicyHandle,
                                               AuthHalf,
                                               NULL,
                                               &AuthBuffer,
                                               &AuthSize );

        if ( NT_SUCCESS( Status ) ) {

            if ( AuthBuffer != NULL ) {

                LsapDbInitializeAttributeDs(
                    NextAttribute,
                    TrDmSAI,
                    AuthBuffer,
                    AuthSize,
                    TRUE );

                NextAttribute++;
                AttributeCount++;
            }

        }

        if ( NT_SUCCESS( Status ) ) {

            AuthHalf = LsapDsAuthHalfFromAuthInfo( AuthenticationInformation, FALSE );

            Status = LsapDsBuildAuthInfoAttribute( PolicyHandle,
                                                   AuthHalf,
                                                   NULL,
                                                   &AuthBuffer,
                                                   &AuthSize );

            if ( NT_SUCCESS( Status ) ) {


                if ( AuthBuffer ) {

                    LsapDbInitializeAttributeDs(
                        NextAttribute,
                        TrDmSAO,
                        AuthBuffer,
                        AuthSize,
                        TRUE );

                    NextAttribute++;
                    AttributeCount++;

                }

            }

        }

    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }


    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    // Save a copy of the trust direction for the fixup routines
    //
    //  The DS does two fixup notifications.  One for the DirAddEntry and
    //  one for the DirModifyEntry.  If the second one didn't exist (or was otherwise
    //  distinguishable from a LsarSetInformationTrustedDomain), then we wouldn't
    //  need to save the OldTrustDirection here.
    //

    {
        PLSADS_PER_THREAD_INFO CurrentThreadInfo;

        CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

        ASSERT( CurrentThreadInfo != NULL );

        if ( CurrentThreadInfo != NULL ) {
            CurrentThreadInfo->OldTrustDirection = TrustedDomainInformation->TrustDirection;
            CurrentThreadInfo->OldTrustType = TrustedDomainInformation->TrustType;
        }
    }


    //
    // Create the Trusted Domain Object.  We fail if the object already exists.
    // Note that the object create routine performs a Database transaction.
    //

    Status = LsapDbCreateObject(
                 &ObjectInformation,
                 DesiredAccess,
                 LSAP_DB_OBJECT_CREATE,
                 0,
                 Attributes,
                 AttributeCount,
                 TrustedDomainHandle
                 );

    InternalTrustedDomainHandle = (LSAP_DB_HANDLE) *TrustedDomainHandle;

    //
    // If object creation failed, dereference the container object.
    //
    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    TrustCreated = TRUE;

    //
    // Create the interdomain trust account, if required
    //

    if ( NT_SUCCESS( Status ) &&
         FLAG_ON( TrustedDomainInformation->TrustDirection, TRUST_DIRECTION_INBOUND ) &&
         ((TrustedDomainInformation->TrustType == TRUST_TYPE_UPLEVEL) ||
          (TrustedDomainInformation->TrustType == TRUST_TYPE_DOWNLEVEL)) &&
         !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE ) ) {

         Status = LsapDsCreateInterdomainTrustAccount( *TrustedDomainHandle );

         if ( !NT_SUCCESS( Status ) ) {

             goto CreateTrustedDomainError;
         }
    }

    //
    // Add the Trusted Domain to the Trusted Domain List, unless we're doing an upgrade
    //

    if ( !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE  ) ) {

        LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainInformation2;

        RtlCopyMemory(
            &TrustedDomainInformation2,
            TrustedDomainInformation,
            sizeof( LSAPR_TRUSTED_DOMAIN_INFORMATION_EX )
            );

        //
        // New domains are always created without forest trust information
        //

        TrustedDomainInformation2.ForestTrustLength = 0;
        TrustedDomainInformation2.ForestTrustInfo = NULL;

        Status = LsapDbAcquireWriteLockTrustedDomainList();

        if ( NT_SUCCESS( Status )) {

            Status = LsapDbInsertTrustedDomainList(
                         &TrustedDomainInformation2,
                         TrustedDomainPosixOffset
                         );

            LsapDbReleaseLockTrustedDomainList();
        }
    }

    if (!NT_SUCCESS(Status)) {

        goto CreateTrustedDomainError;
    }

    if (LsapAdtAuditingPolicyChanges()) {

        (void) LsapAdtTrustedDomainAdd(
                   EVENTLOG_AUDIT_SUCCESS,
                   (PUNICODE_STRING) &TrustedDomainInformation->Name,
                   TrustedDomainInformation->Sid,
                   TrustedDomainInformation->TrustType,
                   TrustedDomainInformation->TrustDirection,
                   TrustedDomainInformation->TrustAttributes
                   );

    }


    //
    // If necessary, release the LSA Database lock.  Note that we don't
    // call LsapDbDereferenceObject() because we want to leave the
    // reference count incremented by default in this success case.
    // In the error case, we call LsapDbDereferenceObject().
    //

    if (ClientPolicyHandleReferenced) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( TrustedDomainObject,
                             0 );

        ClientPolicyHandleReferenced = FALSE;

    }

CreateTrustedDomainFinish:

    //
    // If necessary, free the Policy DNS Domain Information
    //

    if (PolicyDnsDomainInfo != NULL) {

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            (PLSAPR_POLICY_INFORMATION) PolicyDnsDomainInfo
            );

        PolicyDnsDomainInfo = NULL;
    }

    //
    // If we locked all of the locks,
    //  drop them now.
    //

    if ( AllLocksLocked ) {

        LsapDbReleaseLockEx( AllObject, 0 );
    }

    //
    // Free any Attribute Value buffers allocated.
    //

    if (AttributeBuffersAllocated) {

        SecondaryStatus = LsapDbFreeAttributes( AttributeCount, Attributes );

        AttributeBuffersAllocated = FALSE;

        if (!NT_SUCCESS(SecondaryStatus)) {

            goto CreateTrustedDomainError;
        }
    }

    //
    // If necessary, free the Unicode String buffer allocated for the
    // Logical Name.
    //

    if ( !LsapDsWriteDs && LogicalNameU.Length > 0 ) {

        RtlFreeUnicodeString(&LogicalNameU);
        LogicalNameU.Length = 0;
    }

    //
    // If necessary, release the Trusted Domain List Write Lock.
    //

    if (AcquiredListWriteLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredListWriteLock = FALSE;
    }

    LsapExitFunc( "LsapCreateTrustedDomain2", Status );
    LsarpReturnPrologue();

    return(Status);

CreateTrustedDomainError:

    //
    // If necessary, dereference the client Policy Handle and release the
    // LSA Database lock.
    //

    LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

    if (ClientPolicyHandleReferenced) {

        Status = LsapDbDereferenceObject(
                     &PolicyHandle,
                     PolicyObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );

        ClientPolicyHandleReferenced = FALSE;
    }

    //
    // If necessary, delete the trusted domain object
    //
    if ( TrustCreated ) {

        LsarDeleteObject( TrustedDomainHandle );
    }

    goto CreateTrustedDomainFinish;
}


NTSTATUS
LsarOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_SID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_OpenTrustedDomain);

    //
    // Call the internal routine.  Caller is not trusted and the Database
    // lock needs to be acquired.
    //

    Status = LsapDbOpenTrustedDomain(
                 PolicyHandle,
                 (PSID) TrustedDomainSid,
                 DesiredAccess,
                 TrustedDomainHandle,
                 LSAP_DB_LOCK |
                    LSAP_DB_READ_ONLY_TRANSACTION   |
                    LSAP_DB_DS_OP_TRANSACTION
                 );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_OpenTrustedDomain);
    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsapDbOpenTrustedDomain(
    IN LSAPR_HANDLE PolicyHandle,
    IN PSID TrustedDomainSid,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG Options
    )

/*++

Routine Description:

    This function opens a Trusted Domain Object, optionally with
    trusted access.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainSid - Pointer to the account's Sid.

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

    Options - Specifies option flags

        LSAP_DB_LOCK - Acquire the Lsa Database lock for the
           duration of the open operation.

        LSAP_DB_TRUSTED - Always generate a Trusted Handle to the opened
            object.  If not specified, the trust status of the returned
            handle is inherited from the PolicyHandle as container object.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified AccountSid.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    UNICODE_STRING LogicalNameU;
    BOOLEAN ContainerReferenced = FALSE;
    BOOLEAN AcquiredLock = FALSE;
    ULONG DerefOptions = 0;

    RtlZeroMemory(&LogicalNameU,sizeof(UNICODE_STRING));

    //
    // Validate that the Ds is up and running.  If it isn't, there aren't any trusted domains
    //
    if ( !LsaDsStateInfo.UseDs &&
         !FLAG_ON( ( ( LSAP_DB_HANDLE )PolicyHandle )->Options, LSAP_DB_HANDLE_UPGRADE ) ) {

        Status = STATUS_DIRECTORY_SERVICE_REQUIRED;
        goto OpenTrustedDomainError;
    }

    //
    // Validate the Trusted Domain Sid.
    //


    if (!RtlValidSid( TrustedDomainSid )) {
        Status = STATUS_INVALID_PARAMETER;
        goto OpenTrustedDomainError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle
    // (container object handle) is valid, and is of the expected type.
    // Reference the container object handle.  This reference remains in
    // effect until the child object handle is closed.
    //
    DerefOptions |= Options;

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 Options
                 );

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

    ContainerReferenced =TRUE;

    if (Options & LSAP_DB_LOCK) {

        DerefOptions |= LSAP_DB_LOCK;
        AcquiredLock = TRUE;
    }

    //
    // Setup Object Information prior to calling the Object
    // Open routine.  The Object Type, Container Object Type and
    // Logical Name (derived from the Sid) need to be filled in.
    //

    ObjectInformation.ObjectTypeId = TrustedDomainObject;
    ObjectInformation.ContainerTypeId = PolicyObject;
    ObjectInformation.Sid = TrustedDomainSid;
    ObjectInformation.ObjectAttributeNameOnly = FALSE;
    ObjectInformation.DesiredObjectAccess = DesiredAccess;

    //
    // Construct the Logical Name of the Trusted Domain object.  The Logical
    // Name is constructed from the Trusted Domain Sid by extracting the
    // Relative Id (lowest subauthority) and converting it to an 8-digit
    // numeric Unicode String in which leading zeros are added if needed.
    //

    if ( LsapDsWriteDs ) {

        LSAPR_TRUST_INFORMATION InputTrustInformation;
        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;


        //
        // Lookup the cache to find the domain
        //
        Status = LsapDbAcquireReadLockTrustedDomainList();

        if (!NT_SUCCESS(Status)) {
            goto OpenTrustedDomainError;
        }

        RtlZeroMemory(&InputTrustInformation.Name,sizeof(UNICODE_STRING));
        InputTrustInformation.Sid = TrustedDomainSid;

        Status = LsapDbLookupEntryTrustedDomainList(
                    &InputTrustInformation,
                    &TrustEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            LsapDbReleaseLockTrustedDomainList();
            goto OpenTrustedDomainError;
        }

        LogicalNameU.Buffer = LsapAllocateLsaHeap(TrustEntry->TrustInfoEx.Name.MaximumLength);
        if (NULL==LogicalNameU.Buffer)
        {
            LsapDbReleaseLockTrustedDomainList();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto OpenTrustedDomainError;
        }

        LogicalNameU.Length = TrustEntry->TrustInfoEx.Name.Length;
        LogicalNameU.MaximumLength = TrustEntry->TrustInfoEx.Name.MaximumLength;
        RtlCopyMemory(LogicalNameU.Buffer,TrustEntry->TrustInfoEx.Name.Buffer,LogicalNameU.Length);
        LsapDbReleaseLockTrustedDomainList();

    } else {

        Status = LsapDbSidToLogicalNameObject( TrustedDomainSid, &LogicalNameU );

    }

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

    //
    // Initialize the Object Attributes.  The Container Object Handle and
    // Logical Name (Internal Name) of the object must be set up.
    //

    InitializeObjectAttributes(
        &ObjectInformation.ObjectAttributes,
        &LogicalNameU,
        0,
        PolicyHandle,
        NULL
        );

    //
    // Open the specific Trusted Domain object.  Note that the
    // handle returned is an RPC Context Handle.
    //

    Status = LsapDbOpenObject(
                 &ObjectInformation,
                 DesiredAccess,
                 Options,
                 TrustedDomainHandle
                 );

    RtlFreeUnicodeString( &LogicalNameU );

    if (!NT_SUCCESS(Status)) {

        goto OpenTrustedDomainError;
    }

OpenTrustedDomainFinish:

    //
    // If necessary, release the LSA Database lock. Note that object
    // remains referenced unless we came here via error.
    //

    if (AcquiredLock) {

        LsapDbApplyTransaction( PolicyHandle,
                                LSAP_DB_DS_OP_TRANSACTION |
                                    LSAP_DB_READ_ONLY_TRANSACTION,
                                (SECURITY_DB_DELTA_TYPE) 0 );

        LsapDbReleaseLockEx( TrustedDomainObject,
                             DerefOptions );
    }

    return( Status );

OpenTrustedDomainError:

    //
    // If necessary, dereference the Container Object handle.  Note that
    // this is only done in the error case.  In the non-error case, the
    // Container handle stays referenced until the TrustedDomain object is
    // closed.
    //

    if ( ContainerReferenced ) {

        *TrustedDomainHandle = NULL;

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              DerefOptions,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        if ( FLAG_ON( Options, LSAP_DB_LOCK ) ) {

            DerefOptions &= ~LSAP_DB_LOCK;
            DerefOptions |= LSAP_DB_NO_LOCK;
        }

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );
    }

    goto OpenTrustedDomainFinish;
}


NTSTATUS
LsarQueryInfoTrustedDomain(
    IN LSAPR_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *Buffer
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaQueryInfoTrustedDomain API.

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedDomainNameInformation      TRUSTED_QUERY_ACCOUNT_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixInformation           TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status, ReadAttributesStatus;

    PTRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo;
    PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx;
    PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo;
    PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo;
    PTRUSTED_DOMAIN_FULL_INFORMATION2 TrustedDomainFullInfo2;
    LSAPR_TRUST_DOMAIN_AUTH_INFO_HALF AuthInfoHalf;

    BOOLEAN ObjectReferenced = FALSE;

    ACCESS_MASK DesiredAccess;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber = 0;
    PVOID InformationBuffer = NULL;
    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    BOOLEAN InfoBufferInAttributeArray = TRUE;
    ULONG TrustedPosixOffset = 0, TrustDirection = 0, TrustType = 0, TrustAttributes = 0;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarQueryInfoTrustedDomain\n" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryInfoTrustedDomain);

    //
    // Validate the Information Class and determine the access required to
    // query this Trusted Domain Information Class.
    //

    Status = LsapDbVerifyInfoQueryTrustedDomain(
                 InformationClass,
                 FALSE,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    //
    // We don't currently allow querying of the auth data, so there's no need
    //  to support returning encrypted auth data.
    //
    if ( InformationClass == TrustedDomainAuthInformationInternal ||
         InformationClass == TrustedDomainFullInformationInternal ) {
        Status = STATUS_INVALID_INFO_CLASS;
        goto QueryInfoTrustedDomainError;
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is a valid
    // handle to a TrustedDomain object and has the necessary access granted.
    // Reference the handle.
    //

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( !FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                     LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        Status = LsapDbReferenceObject(
                     TrustedDomainHandle,
                     DesiredAccess,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                         LSAP_DB_READ_ONLY_TRANSACTION |
                         LSAP_DB_DS_OP_TRANSACTION );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        ObjectReferenced = TRUE;
    }


    //
    // Compile a list of the attributes that hold the Trusted Domain Information of
    // the specified class.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        //
        // Request read of the Trusted Account Name Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrPN,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        break;

    case TrustedPosixOffsetInformation:

        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        AttributeCount++;
        break;

    case TrustedDomainInformationEx:

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );
        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );
            NextAttribute++;
            AttributeCount++;


            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

        }
        break;

    case TrustedDomainAuthInformation:

        //
        // Only allow query of AuthInformation by trusted client.
        //
        //  (And global not set for debugging purposes.)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            Status = STATUS_INVALID_INFO_CLASS;
            goto QueryInfoTrustedDomainError;
        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );
        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;
        break;

    case TrustedDomainFullInformation:
        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );

        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }
        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );
            NextAttribute++;
            AttributeCount++;


            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );
        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );
        AttributeCount++;
        NextAttribute++;
        break;

    case TrustedDomainFullInformation2Internal:

        //
        // Request read of the Trusted Posix Offset Information.
        //

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Request just about everything...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmName,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmTrPN : TrDmName,
            NULL,
            0,
            FALSE
            );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            LsapDsIsWriteDs( TrustedDomainHandle ) ? TrDmSid : Sid,
            NULL,
            0,
            FALSE
            );

        //
        // In the DS, it is possible to have an entry with a NULL sid.  If FULL info is
        // being collected, make sure to allow the read to happen if a NULL is encountered
        //
        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            NextAttribute->CanDefaultToZero = TRUE;
        }

        AttributeCount++;
        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrTy,
                &TrustType,
                sizeof( TrustType ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrDi,
                &TrustDirection,
                sizeof( TrustDirection ),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmTrLA,
                &TrustAttributes,
                sizeof( TrustAttributes ),
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            NextAttribute++;
            AttributeCount++;

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            LsapDbAttributeCanNotExist( NextAttribute );

            AttributeCount++;
            NextAttribute++;
        }

        //
        // Get the auth info...
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAI,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );

        AttributeCount++;
        NextAttribute++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmSAO,
            NULL,
            0,
            FALSE
            );

        LsapDbAttributeCanNotExist( NextAttribute );

        AttributeCount++;
        NextAttribute++;

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );

    //
    //
    // Read the attributes corresponding to the given Policy Information
    // Class.  Memory will be allocated where required via MIDL_user_allocate
    // for attribute values.
    //

    Status = LsapDbReadAttributesObject(
                 TrustedDomainHandle,
                 0,
                 Attributes,
                 AttributeCount
                 );

    ReadAttributesStatus = Status;

    if (!NT_SUCCESS(Status)) {

        //
        // If the error was that one or more of the attributes holding
        // the information of the given class was not found, continue.
        // Otherwise, return an error.
        //
        goto QueryInfoTrustedDomainError;
    }

#ifdef XFOREST_CIRCUMVENT

    //
    // Mask off the forest transitive bit if the backdoor
    // is open for allowing "before-whistler" cross-forest trust
    //

    if ( !LsapDbNoMoreWin2K()) {

        TrustAttributes &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
    }

#endif

    //
    // Now copy the information read to the output.  For certain information
    // classes where the information is stored as the value of a single
    // attribute of the Policy object and is in the form required by the
    // caller, we can just return the pointer to this buffer.  For all
    // other cases, an output buffer structure tree of the form desired
    // must be allocated via MIDL_user_allocate() and the information read from the attribute(s) of
    // the Policy object must be copied in.  These buffers must then be freed
    // by this routine before exit.  The array of attribute information
    // filled in by LsapDbReadAttributes() has MemoryAllocated = TRUE
    // in all cases.  We reset this flag to FALSE in the simple cases where
    // we can use the buffer as is.  The Finish section of the routine
    // will free up any buffers referenced by the AttributeValue pointer
    // in the attribute array where MemoryAllocated is still TRUE.  If
    // we go to error, the error processing is responsible for freeing
    // those buffers which would be passed to the calling RPC server stub
    // in the non-error case.
    //

    NextAttribute = Attributes;

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        //
        // Allocate memory for output buffer top-level structure.
        //

        TrustedDomainNameInfo =
            MIDL_user_allocate(sizeof(TRUSTED_DOMAIN_NAME_INFO));

        if (TrustedDomainNameInfo == NULL) {

            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainNameInfo->Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        InformationBuffer = TrustedDomainNameInfo;
        NextAttribute++;
        break;

    case TrustedPosixOffsetInformation:

        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        Status = STATUS_INSUFFICIENT_RESOURCES;

        TrustedPosixOffsetInfo = MIDL_user_allocate(sizeof(TRUSTED_POSIX_OFFSET_INFO));

        if (TrustedPosixOffsetInfo == NULL) {

            break;
        }

        Status = STATUS_SUCCESS;

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedPosixOffsetInfo->Offset = TrustedPosixOffset;

        InformationBuffer = TrustedPosixOffsetInfo;
        break;

    case TrustedDomainInformationEx:

        //
        // Allocate memory for output buffer top-level structure.
        //

        TrustedDomainInfoEx =
            MIDL_user_allocate( sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        if (TrustedDomainInfoEx == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainInfoEx->Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainInfoEx );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainInfoEx->FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainInfoEx->Name.Buffer );
            MIDL_user_free( TrustedDomainInfoEx );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainInfoEx->Sid = MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainInfoEx->Sid == NULL ) {

                MIDL_user_free( TrustedDomainInfoEx->Name.Buffer );
                MIDL_user_free( TrustedDomainInfoEx->FlatName.Buffer );
                MIDL_user_free( TrustedDomainInfoEx );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainInfoEx->Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );

        } else {

            TrustedDomainInfoEx->Sid = NULL;
        }

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainInfoEx->TrustDirection = TrustDirection;
            TrustedDomainInfoEx->TrustType = TrustType;
            TrustedDomainInfoEx->TrustAttributes = TrustAttributes;

        } else {

            TrustedDomainInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainInfoEx->TrustAttributes = 0;
        }

        InformationBuffer = TrustedDomainInfoEx;
        NextAttribute++;
        break;

    case TrustedDomainAuthInformation:

        TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION)
                            MIDL_user_allocate( sizeof( TRUSTED_DOMAIN_AUTH_INFORMATION ) );

        if ( TrustedDomainAuthInfo == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                   NextAttribute->AttributeValue,
                                                   NextAttribute->AttributeValueLength,
                                                   &AuthInfoHalf );

        if ( NT_SUCCESS( Status ) ) {

            RtlCopyMemory( TrustedDomainAuthInfo, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

            NextAttribute++;

            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                TrustedDomainAuthInfo->OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                TrustedDomainAuthInfo->OutgoingAuthenticationInformation =
                         (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                TrustedDomainAuthInfo->OutgoingPreviousAuthenticationInformation =
                         (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

            } else {

                LsapDsFreeUnmarshaledAuthInfo(
                    TrustedDomainAuthInfo->IncomingAuthInfos,
                    (PLSAPR_AUTH_INFORMATION)TrustedDomainAuthInfo->
                                                IncomingAuthenticationInformation );

            }

        }

        if ( !NT_SUCCESS( Status ) ) {

            MIDL_user_free( TrustedDomainAuthInfo );
            goto QueryInfoTrustedDomainError;
        }

        InformationBuffer = TrustedDomainAuthInfo;

        break;

    case TrustedDomainFullInformation:


        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        TrustedDomainFullInfo = MIDL_user_allocate(sizeof( TRUSTED_DOMAIN_FULL_INFORMATION ));

        if (TrustedDomainFullInfo == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedDomainFullInfo->PosixOffset.Offset = TrustedPosixOffset;
        NextAttribute++;

        InformationBuffer = TrustedDomainFullInfo;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo->Information.Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo->Information.FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainFullInfo->Information.Sid =
                                        MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainFullInfo->Information.Sid == NULL ) {

                MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.FlatName.Buffer );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainFullInfo->Information.Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );
        } else {

            TrustedDomainFullInfo->Information.Sid = NULL;
        }

        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainFullInfo->Information.TrustDirection = TrustDirection;
            NextAttribute++;
            TrustedDomainFullInfo->Information.TrustType = TrustType;
            NextAttribute++;
            TrustedDomainFullInfo->Information.TrustAttributes = TrustAttributes;
            NextAttribute++;

        } else {

            TrustedDomainFullInfo->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainFullInfo->Information.TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainFullInfo->Information.TrustAttributes = 0;
        }

        //
        // Only return Auth data to trusted client.
        //  (or if we're debugging auth data)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            RtlZeroMemory( &TrustedDomainFullInfo->AuthInformation,
                           sizeof( TrustedDomainFullInfo->AuthInformation ) );

        } else {

            //
            // Finally, the AuthInfo...
            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                RtlCopyMemory( &TrustedDomainFullInfo->AuthInformation, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

                NextAttribute++;

                Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                           NextAttribute->AttributeValue,
                                                           NextAttribute->AttributeValueLength,
                                                           &AuthInfoHalf );

                if ( NT_SUCCESS( Status ) ) {

                    TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                    TrustedDomainFullInfo->AuthInformation.OutgoingAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                    TrustedDomainFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

                } else {

                    LsapDsFreeUnmarshaledAuthInfo(
                        TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos,
                        (PLSAPR_AUTH_INFORMATION)TrustedDomainFullInfo->AuthInformation.
                                                               IncomingAuthenticationInformation );

                }
            }

            if ( !NT_SUCCESS ( Status ) ) {

                MIDL_user_free( TrustedDomainFullInfo->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.FlatName.Buffer );
                MIDL_user_free( TrustedDomainFullInfo->Information.Sid );
            }
        }

        break;

    case TrustedDomainFullInformation2Internal:

        //
        // Allocate memory for top-level output buffer.
        //

        InformationBuffer = NextAttribute->AttributeValue;

        TrustedDomainFullInfo2 = MIDL_user_allocate(sizeof( TRUSTED_DOMAIN_FULL_INFORMATION2 ));

        if ( TrustedDomainFullInfo2 == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto QueryInfoTrustedDomainError;
        }

        InfoBufferInAttributeArray = FALSE;

        //
        // Copy Posix Offset value to output.
        //

        TrustedDomainFullInfo2->PosixOffset.Offset = TrustedPosixOffset;
        NextAttribute++;

        InformationBuffer = TrustedDomainFullInfo2;

        //
        // Copy the Unicode Name field to the output. Original buffer will
        // be freed in Finish section.
        //

        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo2->Information.Name,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        //
        // Netbios name
        //
        Status = LsapDbCopyUnicodeAttribute(
                     &TrustedDomainFullInfo2->Information.FlatName,
                     NextAttribute,
                     TRUE
                     );

        if (!NT_SUCCESS(Status)) {

            MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
            goto QueryInfoTrustedDomainError;
        }

        NextAttribute++;

        if ( NextAttribute->AttributeValueLength != 0 ) {

            TrustedDomainFullInfo2->Information.Sid =
                                        MIDL_user_allocate( NextAttribute->AttributeValueLength );

            if ( TrustedDomainFullInfo2->Information.Sid == NULL ) {

                MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto QueryInfoTrustedDomainError;
            }

            RtlCopyMemory( TrustedDomainFullInfo2->Information.Sid, NextAttribute->AttributeValue,
                           NextAttribute->AttributeValueLength );
        } else {

            TrustedDomainFullInfo2->Information.Sid = NULL;
        }

        NextAttribute++;

        if ( LsapDsIsWriteDs( TrustedDomainHandle ) ) {

            TrustedDomainFullInfo2->Information.TrustDirection = TrustDirection;
            NextAttribute++;
            TrustedDomainFullInfo2->Information.TrustType = TrustType;
            NextAttribute++;
            TrustedDomainFullInfo2->Information.TrustAttributes = TrustAttributes;
            NextAttribute++;

            if ( NextAttribute->AttributeValueLength != 0 ) {

                TrustedDomainFullInfo2->Information.ForestTrustLength = NextAttribute->AttributeValueLength;
                TrustedDomainFullInfo2->Information.ForestTrustInfo =
                    MIDL_user_allocate( NextAttribute->AttributeValueLength );

                if ( TrustedDomainFullInfo2->Information.ForestTrustInfo == NULL ) {

                    MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                    MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                    MIDL_user_free( TrustedDomainFullInfo2->Information.Sid );

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto QueryInfoTrustedDomainError;
                }

                RtlCopyMemory(
                    TrustedDomainFullInfo2->Information.ForestTrustInfo,
                    NextAttribute->AttributeValue,
                    NextAttribute->AttributeValueLength
                    );

            } else {

                TrustedDomainFullInfo2->Information.ForestTrustLength = 0;
                TrustedDomainFullInfo2->Information.ForestTrustInfo = NULL;
            }

            NextAttribute++;

        } else {

            TrustedDomainFullInfo2->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustedDomainFullInfo2->Information.TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustedDomainFullInfo2->Information.TrustAttributes = 0;
            TrustedDomainFullInfo2->Information.ForestTrustLength = 0;
            TrustedDomainFullInfo2->Information.ForestTrustInfo = NULL;
        }

        //
        // Only return Auth data to trusted client.
        //  (or if we're debugging auth data)
        //

        if ( !((LSAP_DB_HANDLE)TrustedDomainHandle)->Trusted &&
             !LsapDbReturnAuthData ) {

            RtlZeroMemory( &TrustedDomainFullInfo2->AuthInformation,
                           sizeof( TrustedDomainFullInfo2->AuthInformation ) );

        } else {

            //
            // Finally, the AuthInfo...
            Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                       NextAttribute->AttributeValue,
                                                       NextAttribute->AttributeValueLength,
                                                       &AuthInfoHalf );

            if ( NT_SUCCESS( Status ) ) {

                RtlCopyMemory( &TrustedDomainFullInfo2->AuthInformation, &AuthInfoHalf, sizeof( AuthInfoHalf ) );

                NextAttribute++;

                Status = LsapDsBuildAuthInfoFromAttribute( TrustedDomainHandle,
                                                           NextAttribute->AttributeValue,
                                                           NextAttribute->AttributeValueLength,
                                                           &AuthInfoHalf );

                if ( NT_SUCCESS( Status ) ) {

                    TrustedDomainFullInfo2->AuthInformation.OutgoingAuthInfos = AuthInfoHalf.AuthInfos;
                    TrustedDomainFullInfo2->AuthInformation.OutgoingAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.AuthenticationInformation;
                    TrustedDomainFullInfo2->AuthInformation.OutgoingPreviousAuthenticationInformation =
                             (PLSA_AUTH_INFORMATION)AuthInfoHalf.PreviousAuthenticationInformation;

                } else {

                    LsapDsFreeUnmarshaledAuthInfo(
                        TrustedDomainFullInfo2->AuthInformation.IncomingAuthInfos,
                        (PLSAPR_AUTH_INFORMATION)TrustedDomainFullInfo2->AuthInformation.
                                                               IncomingAuthenticationInformation );
                }
            }

            if ( !NT_SUCCESS ( Status ) ) {

                MIDL_user_free( TrustedDomainFullInfo2->Information.ForestTrustInfo );
                MIDL_user_free( TrustedDomainFullInfo2->Information.Name.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.FlatName.Buffer );
                MIDL_user_free( TrustedDomainFullInfo2->Information.Sid );
            }
        }

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        break;
    }

    if (!NT_SUCCESS(Status)) {

        goto QueryInfoTrustedDomainError;
    }

    //
    // Verify that the returned Trusted Domain Information is valid.  If not,
    // the Policy Database is corrupt.
    //

    if (!LsapDbValidInfoTrustedDomain(InformationClass, InformationBuffer)) {

        Status = STATUS_INTERNAL_DB_CORRUPTION;
    }

    //
    // Return a pointer to the output buffer to the caller
    //

    *Buffer = (PLSAPR_TRUSTED_DOMAIN_INFO) InformationBuffer;

QueryInfoTrustedDomainFinish:

    //
    // Free any unwanted buffers that were allocated by
    // LsapDbReadAttributesObject() and that are not being returned to the
    // caller server stub.  The server stub will free the buffers that we
    // do return after copying them to the return RPC transmit buffer.
    //

    for (NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        //
        // If buffer holding attribute is marked as allocated, it is
        // to be freed here.
        //

        if (NextAttribute->MemoryAllocated) {

            if (NextAttribute->AttributeValue != NULL) {

                MIDL_user_free(NextAttribute->AttributeValue);
                NextAttribute->AttributeValue = NULL;
                NextAttribute->MemoryAllocated = FALSE;
            }
        }
    }

    //
    // If necessary, dereference the Trusted Domain Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &TrustedDomainHandle,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     LSAP_DB_LOCK |
                        LSAP_DB_READ_ONLY_TRANSACTION |
                        LSAP_DB_DS_OP_TRANSACTION |
                        LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryInfoTrustedDomain);
    LsapExitFunc( "LsarQueryInfoTrustedDomain", Status );
    LsarpReturnPrologue();

    return(Status);

QueryInfoTrustedDomainError:

    //
    // If necessary, free the memory allocated for the output buffer.
    // We only do this free if the buffer is not referenced by the
    // attribute array, since all buffers so referenced will be freed
    // here or in the Finish section.
    //

    if ((InformationBuffer != NULL) && !InfoBufferInAttributeArray) {

        MIDL_user_free(InformationBuffer);
        InformationBuffer = NULL;
    }

    goto QueryInfoTrustedDomainFinish;
}



NTSTATUS
LsarSetInformationTrustedDomain(
    IN LSAPR_HANDLE TrustedDomainHandle,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaSetInfoTrustedDomain API.

    The LsaSetInformationTrustedDomain API modifies information in the Trusted
    Domain Object.  The caller must have access appropriate to the
    information to be changed in the Policy Object, see the InformationClass
    parameter.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the type of information being changed.
        The information types and accesses required to change them are as
        follows:

        TrustedDomainNameInformation          ( Cannot be set )
        TrustedControllersInformation     TRUSTED_SET_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_POSIX_INFORMATION

    Buffer - Points to a structure containing the information appropriate
        to the InformationClass parameter.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        Others TBS
--*/

{
    NTSTATUS Status;
    ACCESS_MASK DesiredAccess;

    BOOLEAN ObjectReferenced = FALSE;
    BOOLEAN AcquiredListWriteLock = FALSE;
    PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInfoEx = NULL;
    PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo;
    PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedDomainAuthInfoInternal;
    PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo;
    PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedDomainFullInfoInternal;
    PTRUSTED_DOMAIN_FULL_INFORMATION2 CurrentTrustedDomainFullInfo2 = NULL;
    TRUSTED_DOMAIN_INFORMATION_EX2 UpdateInfoEx2 = { 0 };

    TRUSTED_DOMAIN_AUTH_INFORMATION DecryptedTrustedDomainAuthInfo;
    TRUSTED_DOMAIN_FULL_INFORMATION DecryptedTrustedDomainFullInfo;

    LSAP_DB_ATTRIBUTE Attributes[LSAP_DB_ATTRS_INFO_CLASS_DOMAIN];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    ULONG AttributeNumber;

    BOOLEAN CreateInterdomainTrustAccount = FALSE;
    BOOLEAN UpdateTrustedDomainList = FALSE;
    PULONG UpdatePosixOffset = NULL;
    ULONG TrustedDomainPosixOffset = 0;

    PBYTE IncomingAuth = NULL, OutgoingAuth = NULL;
    ULONG IncomingSize = 0, OutgoingSize = 0;
    ULONG ReferenceOptions = LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION;
    ULONG DereferenceOptions = LSAP_DB_LOCK | LSAP_DB_FINISH_TRANSACTION;
    BOOLEAN HandleReferenced = FALSE;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;
    ULONG TrustAttributesValue;


    BOOLEAN SavedTrusted;
    LSAP_DB_HANDLE InternalTdoHandle = (LSAP_DB_HANDLE) TrustedDomainHandle;

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetInformationTrustedDomain);

    //
    // Initialization
    //

    RtlZeroMemory( &DecryptedTrustedDomainAuthInfo, sizeof(DecryptedTrustedDomainAuthInfo) );
    RtlZeroMemory( &DecryptedTrustedDomainFullInfo, sizeof(DecryptedTrustedDomainFullInfo) );

    //
    // Validate the Information Class and Trusted Domain Information provided and
    // if valid, return the mask of accesses required to update this
    // class of Trusted Domain information.
    //

    Status = LsapDbVerifyInfoSetTrustedDomain(
                 InformationClass,
                 TrustedDomainInformation,
                 FALSE,
                 &DesiredAccess
                 );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Verify the handle before using it.
    //

    Status =  LsapDbVerifyHandle( TrustedDomainHandle, 0, TrustedDomainObject, TRUE );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    HandleReferenced = TRUE;

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                    LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        ReferenceOptions &= ~LSAP_DB_START_TRANSACTION;
        DereferenceOptions &= ~LSAP_DB_FINISH_TRANSACTION;
    }

    //
    // Get the session key.
    //
    // Do this before grabbing any locks.  Getting the session key is a kernel call.
    // The kernel will call back up to the LSA in another thread to get the key.
    // That thread may need locks this thread has locked.
    //

    if ( InformationClass == TrustedDomainAuthInformationInternal ||
         InformationClass == TrustedDomainFullInformationInternal ) {

        Status = LsapCrServerGetSessionKeySafe(
                    LsapDbContainerFromHandle( TrustedDomainHandle ),
                    PolicyObject,
                    &SessionKey );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }
    }

    //
    // Acquire the Lsa Database lock.  Verify that the handle is
    // valid, is a handle to a TrustedDomain Object and has the necessary accesses
    // granted.  Reference the handle and start an Lsa Database transaction.
    //

    //
    // If this is the open handle to a trusted domain object being treated as a secret object,
    // we already have a transaction going, so don't start one here.
    //
    if ( !FLAG_ON( ((LSAP_DB_HANDLE)TrustedDomainHandle)->Options,
                     LSAP_DB_DS_TRUSTED_DOMAIN_AS_SECRET )) {

        Status = LsapDbReferenceObject(
                     TrustedDomainHandle,
                     DesiredAccess,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     ReferenceOptions
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        ObjectReferenced = TRUE;
    }

    //
    // Update the specified information in the Policy Object.
    //

    NextAttribute = Attributes;


    //
    // Grab a copy of the current information on the object.
    //

    SavedTrusted = ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted;

    ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted = TRUE;

    Status = LsarQueryInfoTrustedDomain( TrustedDomainHandle,
                                         TrustedDomainFullInformation2Internal,
                                         (PLSAPR_TRUSTED_DOMAIN_INFO *)
                                                &CurrentTrustedDomainFullInfo2 );

    ((LSAP_DB_HANDLE) TrustedDomainHandle)->Trusted = SavedTrusted;

    if ( !NT_SUCCESS( Status ) ) {
        goto Cleanup;
    }

    RtlCopyMemory( &UpdateInfoEx2, &CurrentTrustedDomainFullInfo2->Information, sizeof( TRUSTED_DOMAIN_INFORMATION_EX2 ) );

    //
    // Save a copy of the trust direction for the fixup routines
    //

    {
        PLSADS_PER_THREAD_INFO CurrentThreadInfo;

        CurrentThreadInfo = TlsGetValue( LsapDsThreadState );

        ASSERT( CurrentThreadInfo != NULL );

        if ( CurrentThreadInfo != NULL ) {
            CurrentThreadInfo->OldTrustDirection = CurrentTrustedDomainFullInfo2->Information.TrustDirection;
            CurrentThreadInfo->OldTrustType = CurrentTrustedDomainFullInfo2->Information.TrustType;
        }
    }

    //
    // If we have a Ds object, we might be coming from the *ByName functions, which have a
    // cobbled handle that doesn't include the sid.  As such, we'll go ahead and read it here.
    //

    if ( LsapDsWriteDs ) {

        if ( ((LSAP_DB_HANDLE) TrustedDomainHandle)->Sid == NULL ) {

            if ( CurrentTrustedDomainFullInfo2->Information.Sid ) {
                ULONG SidLength;

                SidLength = RtlLengthSid( CurrentTrustedDomainFullInfo2->Information.Sid );

                ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid = LsapAllocateLsaHeap( SidLength );

                if (((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid == NULL) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;

                }

                RtlCopySid( SidLength,
                            ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid,
                            CurrentTrustedDomainFullInfo2->Information.Sid );

            }

        }

    }

    switch (InformationClass) {

    case TrustedDomainNameInformation:

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;

    case TrustedControllersInformation:

        //
        // Obsolete info level.  Do nothing
        //
        break;

    case TrustedPosixOffsetInformation:

        TrustedPosixOffsetInfo = (PTRUSTED_POSIX_OFFSET_INFO) TrustedDomainInformation;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedPosixOffsetInfo->Offset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Update the cache, too.
        //

        UpdatePosixOffset = &TrustedPosixOffsetInfo->Offset;
        break;

    case TrustedDomainInformationBasic:
        Status = STATUS_INVALID_INFO_CLASS;
        goto Cleanup;

    case TrustedDomainInformationEx:

        TrustedDomainInfoEx = (PTRUSTED_DOMAIN_INFORMATION_EX)TrustedDomainInformation;

        RtlCopyMemory( &UpdateInfoEx2,
                       TrustedDomainInfoEx,
                       sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        UpdateInfoEx2.ForestTrustLength = CurrentTrustedDomainFullInfo2->Information.ForestTrustLength;
        UpdateInfoEx2.ForestTrustInfo = CurrentTrustedDomainFullInfo2->Information.ForestTrustInfo;

        //
        // If the client attempts to set the forest transitive bit,
        // verify that this is a domain in the root DC and that all
        // domains have been upgraded to Whistler before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
              FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
             ( !LsapDbDcInRootDomain() ||
               !LsapDbNoMoreWin2K())) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        UpdateTrustedDomainList = TRUE;

        //
        // Can't set domain names via this interface
        //

        //
        // Set the trust type and direction
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainInfoEx->TrustType,
            sizeof( TrustedDomainInfoEx->TrustType ),
            FALSE
            );
        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainInfoEx->TrustDirection,
            sizeof( TrustedDomainInfoEx->TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // For outbound up- and down-level TDO's, only allow the operation if either
        //    -- either a SID is specified as part of TrustedDomainInfoEx or
        //    -- a SID is specified as part of
        //

        if ( ( TrustedDomainInfoEx->TrustType == TRUST_TYPE_DOWNLEVEL ||
               TrustedDomainInfoEx->TrustType == TRUST_TYPE_UPLEVEL ) &&
             FLAG_ON( TrustedDomainInfoEx->TrustDirection, TRUST_DIRECTION_OUTBOUND ) &&
             TrustedDomainInfoEx->Sid == NULL &&
             CurrentTrustedDomainFullInfo2->Information.Sid == NULL ) {

                Status = STATUS_INVALID_SID;
                goto Cleanup;
        }

        //
        // If a SID was provided as part of TrustedDomainInfoEx, use it
        //

        if ( TrustedDomainInfoEx->Sid != NULL ) {

            Status = LsapDbMakeSidAttributeDs(
                         TrustedDomainInfoEx->Sid,
                         TrDmSid,
                         NextAttribute );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            NextAttribute++;
            AttributeCount++;
        }

        //
        // Create the interdomain trust account for inbound TDOs
        //

        if ( FLAG_ON( TrustedDomainInfoEx->TrustDirection, TRUST_DIRECTION_INBOUND )) {

            CreateInterdomainTrustAccount = TRUE;
        }

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainInfoEx->TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // If the forest trust bit is being cleared,
        // remove forest trust information from the TDO
        //

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
            !FLAG_ON( TrustedDomainInfoEx->TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            UpdateInfoEx2.ForestTrustLength = 0;
            UpdateInfoEx2.ForestTrustInfo = NULL;

            LsapDsDebugOut(( DEB_FTINFO, "Removing forest trust information because forest trust bit is being cleared\n" ));
        }

        break;

    case TrustedDomainAuthInformationInternal:
        TrustedDomainAuthInfoInternal = (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL)TrustedDomainInformation;

        //
        // Build a decrypted Auth Info structure.
        //

        Status = LsapDecryptAuthDataWithSessionKey(
                            SessionKey,
                            TrustedDomainAuthInfoInternal,
                            &DecryptedTrustedDomainAuthInfo );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Use the decrypted information as though cleartext was passed from the caller.
        //

        TrustedDomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &DecryptedTrustedDomainAuthInfo;

        /* Drop through */

    case TrustedDomainAuthInformation:

        TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION)TrustedDomainInformation;


        //
        // Incoming...
        //  Use zero AuthInfos as our hint to not change the auth info.
        //
        if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 ) {


            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( InformationClass == TrustedDomainAuthInformation &&
                 !InternalTdoHandle->Trusted &&
                 TrustedDomainAuthInfo->IncomingAuthInfos > 1 ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            TrustedDomainAuthInfo, TRUE ),
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &CurrentTrustedDomainFullInfo2->AuthInformation, TRUE ),
                                                   &IncomingAuth,
                                                   &IncomingSize );

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }
        }

        //
        // Same thing with the outgoing
        //

        if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( !InternalTdoHandle->Trusted &&
                 TrustedDomainAuthInfo->OutgoingAuthInfos > 1 ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                               LsapDsAuthHalfFromAuthInfo(
                                                        TrustedDomainAuthInfo, FALSE ),
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &CurrentTrustedDomainFullInfo2->AuthInformation, FALSE ),
                                               &OutgoingAuth,
                                               &OutgoingSize );

            if ( !NT_SUCCESS( Status ) ) {
                goto Cleanup;
            }
        }



        if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAI,
                IncomingAuth,
                IncomingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAO,
                OutgoingAuth,
                OutgoingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustDirection, TRUST_DIRECTION_INBOUND ) ) {

            CreateInterdomainTrustAccount = TRUE;
        }

        break;

    case TrustedDomainFullInformationInternal:
        TrustedDomainFullInfoInternal = (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL)TrustedDomainInformation;

        //
        // Build a decrypted Auth Info structure.
        //

        Status = LsapDecryptAuthDataWithSessionKey(
                            SessionKey,
                            &TrustedDomainFullInfoInternal->AuthInformation,
                            &DecryptedTrustedDomainFullInfo.AuthInformation );

        if ( !NT_SUCCESS(Status) ) {
            goto Cleanup;
        }

        //
        // Copy over the other fields into a single structure
        //

        DecryptedTrustedDomainFullInfo.Information = *((PTRUSTED_DOMAIN_INFORMATION_EX)&(TrustedDomainFullInfoInternal->Information));
        DecryptedTrustedDomainFullInfo.PosixOffset = TrustedDomainFullInfoInternal->PosixOffset;

        //
        // Use the decrypted information as though cleartext was passed from the caller.
        //

        TrustedDomainInformation = (PLSAPR_TRUSTED_DOMAIN_INFO) &DecryptedTrustedDomainFullInfo;

        /* Drop through */

    case TrustedDomainFullInformation:

        TrustedDomainFullInfo = ( PTRUSTED_DOMAIN_FULL_INFORMATION )TrustedDomainInformation;

        RtlCopyMemory( &UpdateInfoEx2,
                       &TrustedDomainFullInfo->Information,
                       sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

        UpdateInfoEx2.ForestTrustLength = CurrentTrustedDomainFullInfo2->Information.ForestTrustLength;
        UpdateInfoEx2.ForestTrustInfo = CurrentTrustedDomainFullInfo2->Information.ForestTrustInfo;

        //
        // If the client attempts to set the forest transitive bit,
        // verify that this is a domain in the root DC and that all
        // domains have been upgraded to Whistler before allowing the operation
        //

        if ( !FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
              FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                       TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
             ( !LsapDbDcInRootDomain() ||
               !LsapDbNoMoreWin2K())) {

            Status = STATUS_INVALID_DOMAIN_STATE;
            goto Cleanup;
        }

        UpdateTrustedDomainList = TRUE;

        //
        // Update the Posix Offset in the cache, too.
        //

        UpdatePosixOffset = &TrustedDomainFullInfo->PosixOffset.Offset;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmPxOf,
            &TrustedDomainFullInfo->PosixOffset.Offset,
            sizeof(ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Can't set domain names via this interface
        //

        //
        // Set the trust type and direction
        //
        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrTy,
            &TrustedDomainFullInfo->Information.TrustType,
            sizeof( TrustedDomainFullInfo->Information.TrustType ),
            FALSE
            );
        NextAttribute++;
        AttributeCount++;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrDi,
            &TrustedDomainFullInfo->Information.TrustDirection,
            sizeof( TrustedDomainFullInfo->Information.TrustDirection ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // For outbound up- and down-level TDO's, only allow the operation if either
        //    -- either a SID is specified as part of TrustedDomainInfoEx or
        //    -- a SID is specified as part of
        //

        if ( ( TrustedDomainFullInfo->Information.TrustType == TRUST_TYPE_DOWNLEVEL ||
               TrustedDomainFullInfo->Information.TrustType == TRUST_TYPE_UPLEVEL ) &&
             FLAG_ON( TrustedDomainFullInfo->Information.TrustDirection, TRUST_DIRECTION_OUTBOUND ) &&
             TrustedDomainFullInfo->Information.Sid == NULL &&
             CurrentTrustedDomainFullInfo2->Information.Sid == NULL ) {

            Status = STATUS_INVALID_SID;
            goto Cleanup;
        }

        //
        // If a SID was provided as part of TrustedDomainFullInfo->Information, use it
        //

        if ( TrustedDomainFullInfo->Information.Sid != NULL ) {

            Status = LsapDbMakeSidAttributeDs(
                         TrustedDomainFullInfo->Information.Sid,
                         TrDmSid,
                         NextAttribute );

            if ( !NT_SUCCESS( Status )) {

                goto Cleanup;
            }

            NextAttribute++;
            AttributeCount++;
        }

        //
        // Create the interdomain trust account for inbound TDOs
        //

        if ( FLAG_ON( TrustedDomainFullInfo->Information.TrustDirection, TRUST_DIRECTION_INBOUND )) {

            CreateInterdomainTrustAccount = TRUE;
        }

        //
        // When setting trust attributes, mask off all but the supported bits
        //

        TrustAttributesValue =
            TrustedDomainFullInfo->Information.TrustAttributes & TRUST_ATTRIBUTES_VALID;

        LsapDbInitializeAttributeDs(
            NextAttribute,
            TrDmTrLA,
            &TrustAttributesValue,
            sizeof( TrustAttributesValue ),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;


        //
        // Incoming...
        //  Use zero AuthInfos as our hint to not change the auth info.
        //
        if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( InformationClass == TrustedDomainFullInformation &&
                 !InternalTdoHandle->Trusted &&
                 TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos > 1 ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &TrustedDomainFullInfo->AuthInformation, TRUE ),
                                                   LsapDsAuthHalfFromAuthInfo(
                                                            &CurrentTrustedDomainFullInfo2->AuthInformation, TRUE ),
                                                   &IncomingAuth,
                                                   &IncomingSize );

            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }

        //
        // Same thing with the outgoing
        //

        if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 ) {

            //
            // There's a bug in the idl definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
            //  it doesn't allow more than one auth info to be passed over the wire.
            //  So, short circuit it here.
            //

            if ( !InternalTdoHandle->Trusted &&
                 TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos > 1 ) {
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            Status = LsapDsBuildAuthInfoAttribute( TrustedDomainHandle,
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &TrustedDomainFullInfo->AuthInformation, FALSE ),
                                               LsapDsAuthHalfFromAuthInfo(
                                                        &CurrentTrustedDomainFullInfo2->AuthInformation, FALSE ),
                                               &OutgoingAuth,
                                               &OutgoingSize );
            if ( !NT_SUCCESS(Status) ) {
                goto Cleanup;
            }
        }


        if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAI,
                IncomingAuth,
                IncomingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 ) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmSAO,
                OutgoingAuth,
                OutgoingSize,
                FALSE);

            NextAttribute++;
            AttributeCount++;
        }

        //
        // If the forest trust bit is being cleared,
        // remove forest trust information from the TDO
        //

#ifdef XFOREST_CIRCUMVENT

        //
        // If the backdoor for not-all-whistler cross-forest trust support
        // is open, but is turned off, do not change the forest trust info
        //

        if ( LsapDbNoMoreWin2K()) {
#endif

        if ( FLAG_ON( CurrentTrustedDomainFullInfo2->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) &&
            !FLAG_ON( TrustedDomainFullInfo->Information.TrustAttributes,
                      TRUST_ATTRIBUTE_FOREST_TRANSITIVE )) {

            LsapDbInitializeAttributeDs(
                NextAttribute,
                TrDmForT,
                NULL,
                0,
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            UpdateInfoEx2.ForestTrustLength = 0;
            UpdateInfoEx2.ForestTrustInfo = NULL;

            LsapDsDebugOut(( DEB_FTINFO, "Removing forest trust information because forest trust bit is being cleared\n" ));
        }

#ifdef XFOREST_CIRCUMVENT
        }
#endif

        break;

    default:

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ASSERT( AttributeCount <= LSAP_DB_ATTRS_INFO_CLASS_DOMAIN );


    //
    // Update the TrustedDomain Object attributes
    //
    if ( AttributeCount > 0 ) {

        //
        // If we're might be changing trust direction or type,
        //  or we're changing the Posix Offset,
        //  check if we need to compute the Posix Offset.
        //

        if ( UpdateTrustedDomainList || UpdatePosixOffset != NULL ) {
            DOMAIN_SERVER_ROLE ServerRole;

            //
            // Only change the Posix Offset on the PDC.
            //  (Changes made on BDCs will have their Posix offset updated
            //  when the change is replicated onto the PDC.)
            //

            Status = SamIQueryServerRole(
                        LsapAccountDomainHandle,
                        &ServerRole
                        );


            if (!NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            //
            // Only allocate a Posix offset on the PDC.
            //

            if ( ServerRole == DomainServerRolePrimary ) {
                ULONG CurrentPosixOffset;
                BOOLEAN PosixOffsetChanged = FALSE;


                //
                // Get the current PosixOffset
                //

                if ( UpdatePosixOffset == NULL ) {
                    CurrentPosixOffset = CurrentTrustedDomainFullInfo2->PosixOffset.Offset;
                } else {
                    CurrentPosixOffset = *UpdatePosixOffset;
                }

                //
                // If we should have a Posix Offset,
                //  ensure we have one.
                //

                if ( LsapNeedPosixOffset( UpdateInfoEx2.TrustDirection,
                                          UpdateInfoEx2.TrustType ) ) {


                    if ( CurrentPosixOffset == 0 ) {

                       //
                       // Need to grab the TDL write lock while allocating a Posix Offset
                       //

                       Status = LsapDbAcquireWriteLockTrustedDomainList();

                       if ( !NT_SUCCESS(Status)) {
                           goto Cleanup;
                       }

                       AcquiredListWriteLock = TRUE;


                       //
                       // Allocate the next available Posix Offset.
                       //

                       Status = LsapDbAllocatePosixOffsetTrustedDomainList(
                                    &TrustedDomainPosixOffset );

                       if ( !NT_SUCCESS(Status)) {
                           goto Cleanup;
                       }

                       PosixOffsetChanged = TRUE;
                    }
                //
                // If we shouldn't have a Posix Offset,
                //  ensure we don't have one.
                //

                } else {
                    if ( CurrentPosixOffset != 0 ) {
                        TrustedDomainPosixOffset = 0;
                        PosixOffsetChanged = TRUE;
                    }
                }

                //
                // If we're forcing the Posix Offset to change,
                //  do it now.
                //

                if ( PosixOffsetChanged ) {

                    //
                    // If we're already writing the Posix Offset to the DS,
                    //  simply put the new value in that location.
                    //

                    if ( UpdatePosixOffset != NULL ) {
                        *UpdatePosixOffset = TrustedDomainPosixOffset;

                    //
                    // Otherwise, add it to the list of attributes to write.
                    //
                    } else {
                        UpdatePosixOffset = &TrustedDomainPosixOffset;

                        LsapDbInitializeAttributeDs(
                            NextAttribute,
                            TrDmPxOf,
                            UpdatePosixOffset,
                            sizeof(ULONG),
                            FALSE
                            );

                        NextAttribute++;
                        AttributeCount++;
                    }
                }
            }
        }


        //
        // Write the attributes to the DS.
        //

        Status = LsapDbWriteAttributesObject(
                     TrustedDomainHandle,
                     Attributes,
                     AttributeCount
                     );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // If we need it, create the interdomain trust account
        //
        if ( CreateInterdomainTrustAccount ) {

            Status = LsapDsCreateInterdomainTrustAccount( TrustedDomainHandle );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }
        }


        //
        // Finally, update the trust info in the trusted domain list
        //

        if ( UpdateTrustedDomainList ) {

            Status = LsapDbFixupTrustedDomainListEntry(
                        CurrentTrustedDomainFullInfo2->Information.Sid,
                        ( PLSAPR_UNICODE_STRING )&CurrentTrustedDomainFullInfo2->Information.Name,
                        ( PLSAPR_UNICODE_STRING )&CurrentTrustedDomainFullInfo2->Information.FlatName,
                        ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 )&UpdateInfoEx2,
                        UpdatePosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        } else if ( UpdatePosixOffset != NULL ) {

            Status = LsapDbFixupTrustedDomainListEntry(
                        ((LSAP_DB_HANDLE)TrustedDomainHandle)->Sid,
                        NULL,
                        NULL,
                        NULL,   // No other trust info to update
                        UpdatePosixOffset );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

        }
    }

    Status = STATUS_SUCCESS;


Cleanup:

    if ( NT_SUCCESS(Status) && LsapAdtAuditingPolicyChanges() ) {

        (void) LsapAdtTrustedDomainMod(
                   EVENTLOG_AUDIT_SUCCESS,
                   CurrentTrustedDomainFullInfo2->Information.Sid,

                   &CurrentTrustedDomainFullInfo2->Information.Name,
                   CurrentTrustedDomainFullInfo2->Information.TrustType,
                   CurrentTrustedDomainFullInfo2->Information.TrustDirection,
                   CurrentTrustedDomainFullInfo2->Information.TrustAttributes,

                   &UpdateInfoEx2.Name,
                   UpdateInfoEx2.TrustType,
                   UpdateInfoEx2.TrustDirection,
                   UpdateInfoEx2.TrustAttributes
                   );
    }

    if ( HandleReferenced ) {
        LsapDbDereferenceHandle( TrustedDomainHandle );
    }
    if ( SessionKey != NULL ) {
        MIDL_user_free( SessionKey );
    }


    //
    // Free memory allocated by this routine for attribute buffers.
    // These have MemoryAllocated = TRUE in their attribute information.
    // Leave alone buffers allocated by calling RPC stub.
    //

    for( NextAttribute = Attributes, AttributeNumber = 0;
         AttributeNumber < AttributeCount;
         NextAttribute++, AttributeNumber++) {

        if (NextAttribute->MemoryAllocated) {

            ASSERT(NextAttribute->AttributeValue != NULL);
            MIDL_user_free(NextAttribute->AttributeValue);
        }
    }

    //
    // If necessary, dereference the Trusted Domain Object, release the LSA Database lock and
    // return.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &TrustedDomainHandle,
                     TrustedDomainObject,
                     TrustedDomainObject,
                     DereferenceOptions,
                     SecurityDbChange,
                     Status
                     );
    }

    if ( CurrentTrustedDomainFullInfo2 != NULL ) {
        LsaIFree_LSAPR_TRUSTED_DOMAIN_INFO(
            TrustedDomainFullInformation2Internal,
            (PLSAPR_TRUSTED_DOMAIN_INFO) CurrentTrustedDomainFullInfo2 );
    }


    //
    // If necessary, release the Trusted Domain List Write Lock.
    //

    if (AcquiredListWriteLock) {

        LsapDbReleaseLockTrustedDomainList();
        AcquiredListWriteLock = FALSE;
    }



    //
    // Free the auth info we might have allocated
    //
    if ( IncomingAuth ) {

        LsapFreeLsaHeap( IncomingAuth );
    }

    if ( OutgoingAuth ) {

        LsapFreeLsaHeap( OutgoingAuth );
    }

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, FALSE ) );

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainFullInfo.AuthInformation, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainFullInfo.AuthInformation, FALSE ) );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetInformationTrustedDomain);
    LsarpReturnPrologue();

    return(Status);

}


NTSTATUS
LsarEnumerateTrustedDomains(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.
            Some entries may have been returned.
            The caller need not call again.

        STATUS_MORE_ENTRIES - The call completed successfully.
            Some entries have been returned.  The caller should call again to
            get additional entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status;
    PLSA_TRUST_INFORMATION XrefDomainTrustList = NULL;
    ULONG XrefEntriesReturned;
    ULONG XrefDomainTrustListLength;
    ULONG XrefDomainTrustCount = 0;
    PLSAPR_POLICY_INFORMATION PolicyAccountDomainInfo = NULL;

    // PSID *Sids = NULL;
    // LSAPR_HANDLE TrustedDomainHandle = NULL;
    // ULONG MaxLength;

    ULONG XrefIndex;
    ULONG CurrentIndex;

    LIST_ENTRY RootList, TrustList;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY NextEntry;
    BOOLEAN TdosEnumerated = FALSE;
    // BOOLEAN SomeTdosReturned = FALSE;

    PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC FullTrustedDomainList = NULL;
    ULONG FullTrustedDomainCount = 0 ;
    ULONG i;

#define LSAP_XREF_ENUMERATION_CONTEXT 0x80000000

    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_EnumerateTrustedDomains);

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if (!ARGUMENT_PRESENT(EnumerationBuffer)) {
        Status = STATUS_INVALID_PARAMETER;
        goto FunctionReturn;
    }

    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;

    InitializeListHead( &RootList );
    InitializeListHead( &TrustList );

    if ( PreferedMaximumLength == 0 ) {
        PreferedMaximumLength = 1;
    }


    //
    // If the enumeration context indicates we've already progress past the TDOs,
    //  skip them
    //

    if ( (*EnumerationContext & LSAP_XREF_ENUMERATION_CONTEXT) == 0 ) {

        //
        // Call the worker routine that's shared with the Ex version.
        //

        Status = LsapEnumerateTrustedDomainsEx(
                         PolicyHandle,
                         EnumerationContext,
                         TrustedDomainInformationBasic,
                         (PLSAPR_TRUSTED_DOMAIN_INFO *)&(EnumerationBuffer->Information),
                         PreferedMaximumLength,
                         &EnumerationBuffer->EntriesRead,
                         LSAP_DB_ENUMERATE_AS_NT4 );

        //
        // If we're not done with the TDOs,
        //  return to the caller.
        //
        if ( Status != STATUS_SUCCESS && Status != STATUS_NO_MORE_ENTRIES ) {
            goto Cleanup;
        }

        //
        // Indicate that we're just starting to enumerate the XREF objects.
        //
        *EnumerationContext = LSAP_XREF_ENUMERATION_CONTEXT;
    } else {
        Status = STATUS_NO_MORE_ENTRIES;
    }

    //
    // On native mode domains,
    //  return all of the domains in the forest.
    //
    // This ensures that downlevel clients see the indirectly trusted domains.
    // The downlevel client can then authenticate using accounts in such domains
    // using NTLM transitive trust.
    //

    //
    // If we're not hosting a DS,
    //  or this is a mixed domain,
    //  we're done enumerating.
    //
    // The only trusted called of this is replication to an NT 4 BDC.
    // It only wants the directly trusted domains.
    //

    if ( !LsapDsWriteDs ||
         ((LSAP_DB_HANDLE)PolicyHandle)->Trusted ||
         SamIMixedDomain( LsapAccountDomainHandle ) ) {
        *EnumerationContext = 0xFFFFFFFF;

        // Status is already set.
        goto Cleanup;
    }

    //
    // Enumerate the XREF objects
    //

    Status = LsapBuildForestTrustInfoLists(
                        NULL,   // Use global policy handle
                        &TrustList );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Loop through the XREFS determining how many we should return to the caller.
    //
    // Assert: at this point RootList is empty and TrustList contains all XREFs
    //
    // This loop will move a subset of the XREFs to the RootList.  Those XREFs
    //  represent the ones to be returned to the caller.
    //

    XrefIndex = (*EnumerationContext) & ~LSAP_XREF_ENUMERATION_CONTEXT;
    CurrentIndex = 0;
    XrefEntriesReturned = 0;

    for ( ListEntry = TrustList.Flink ;
          ListEntry != &TrustList ;
          ListEntry = NextEntry ) {

        PLSAPDS_FOREST_TRUST_BLOB TrustBlob;

        NextEntry = ListEntry->Flink;

        TrustBlob = CONTAINING_RECORD( ListEntry,
                                       LSAPDS_FOREST_TRUST_BLOB,
                                       Next );

        //
        // Only consider entries greater or equal to our current enumeration context.
        //

        if ( CurrentIndex >= XrefIndex ) {

            //
            // Ignore entries without a DomainSid.
            //

            if ( TrustBlob->DomainSid != NULL &&
                 TrustBlob->FlatName.Length != 0 ) {

                BOOLEAN AlreadyDone;

                //
                // If we haven't yet read a complete list of all the TDOs we've
                //  returned to the caller in the past,
                //  do so now.
                //

                if ( !TdosEnumerated ) {
                    LSA_ENUMERATION_HANDLE LocalEnumHandle = 0;

                    //
                    // Get to complete trusted domain list.
                    //  Use global handle to avoid list length limitations.
                    //

                    Status = LsapEnumerateTrustedDomainsEx(
                                     LsapPolicyHandle,
                                     &LocalEnumHandle,
                                     TrustedDomainInformationBasic,
                                     (PLSAPR_TRUSTED_DOMAIN_INFO *)&FullTrustedDomainList,
                                     0xFFFFFFFF,
                                     &FullTrustedDomainCount,
                                     LSAP_DB_ENUMERATE_AS_NT4 );

                    // Handle the zero trusted domain case
                    if ( Status == STATUS_NO_MORE_ENTRIES ) {
                        Status = STATUS_SUCCESS;
                        FullTrustedDomainCount = 0;
                        FullTrustedDomainList = NULL;
                    }

                    if ( Status != STATUS_SUCCESS ) {
                        if ( Status == STATUS_MORE_ENTRIES ) {
                            Status = STATUS_INTERNAL_DB_CORRUPTION;
                        }
                        goto Cleanup;
                    }

                    //
                    // Get the Sid of this domain, too
                    //

                    Status = LsapDbQueryInformationPolicy(
                                    LsapPolicyHandle,
                                    PolicyAccountDomainInformation,
                                    &PolicyAccountDomainInfo );

                    if ( !NT_SUCCESS(Status) ) {
                        goto Cleanup;
                    }

                    TdosEnumerated = TRUE;

                }

                //
                // Check if this is the XREF for this domain.
                //

                AlreadyDone = FALSE;
                if ( RtlEqualSid( PolicyAccountDomainInfo->PolicyAccountDomainInfo.DomainSid,
                             TrustBlob->DomainSid ) ) {
                    AlreadyDone = TRUE;
                }

                //
                // Determine if the XREF object matches one of the TDOs.
                //

                if ( !AlreadyDone ) {
                    for ( i=0; i<FullTrustedDomainCount; i++ ) {
                        if ( FullTrustedDomainList[i].Sid != NULL &&
                             RtlEqualSid( FullTrustedDomainList[i].Sid,
                                          TrustBlob->DomainSid ) ) {
                            AlreadyDone = TRUE;
                            break;
                        }
                    }
                }

                //
                // If the XREF object doesn't match any of the TDOs,
                //  return it to the caller.
                //

                if ( !AlreadyDone ) {

                    //
                    // Add the entry to the list of entries to return to the caller
                    //

                    RemoveEntryList( ListEntry );
                    InsertTailList( &RootList, ListEntry );

                    XrefEntriesReturned++;

                }

            }
        }


        //
        // Account for the entry
        //

        CurrentIndex++;
    }

    XrefIndex = CurrentIndex | LSAP_XREF_ENUMERATION_CONTEXT;

    //
    // If the passed in enumeration context was too large,
    //  tell the caller.
    //

    XrefDomainTrustListLength = (XrefEntriesReturned + EnumerationBuffer->EntriesRead) * sizeof(LSA_TRUST_INFORMATION);

    if ( XrefDomainTrustListLength == 0 ) {
        if ( *EnumerationContext == 0 ) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_NO_MORE_ENTRIES;
        }
        goto Cleanup;
    }


    //
    // Allocate a buffer to returned to the caller.
    //


    XrefDomainTrustList = MIDL_user_allocate( XrefDomainTrustListLength );

    if ( XrefDomainTrustList == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlZeroMemory ( XrefDomainTrustList, XrefDomainTrustListLength );

    //
    // If there were any TDOs returned on this call,
    //  copy them over now.
    //

    XrefDomainTrustCount = 0;
    if ( EnumerationBuffer->EntriesRead != 0 ) {

        //
        // Indicate where the first XREF will be returned.
        //
        XrefDomainTrustCount = EnumerationBuffer->EntriesRead;

        RtlCopyMemory( XrefDomainTrustList,
                       EnumerationBuffer->Information,
                       EnumerationBuffer->EntriesRead * sizeof(LSA_TRUST_INFORMATION) );

        //
        // Free the old buffer since it is no longer needed.
        //

        MIDL_user_free( EnumerationBuffer->Information );
        EnumerationBuffer->Information = NULL;
        EnumerationBuffer->EntriesRead = 0;

    }


    //
    // Loop through the XREFS returning them
    //
    // Assert: at this point RootList contains the entries to return and
    //  TrustList contain the other XREFs
    //

    // XrefEntriesReturned = 0;

    for ( ListEntry = RootList.Flink ;
          ListEntry != &RootList ;
          ListEntry = ListEntry->Flink ) {

        PLSAPDS_FOREST_TRUST_BLOB TrustBlob;

        TrustBlob = CONTAINING_RECORD( ListEntry,
                                       LSAPDS_FOREST_TRUST_BLOB,
                                       Next );


        //
        // Copy the Name.
        //

        Status = LsapRpcCopyUnicodeString(
                     NULL,
                     (PUNICODE_STRING) &XrefDomainTrustList[XrefDomainTrustCount].Name,
                     &TrustBlob->FlatName );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Copy the Sid.
        //

        Status = LsapRpcCopySid(
                     NULL,
                     (PSID) &XrefDomainTrustList[XrefDomainTrustCount].Sid,
                     TrustBlob->DomainSid );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        XrefDomainTrustCount ++;
    }

    *EnumerationContext = XrefIndex;
    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION)XrefDomainTrustList;
    EnumerationBuffer->EntriesRead = XrefDomainTrustCount;
    XrefDomainTrustList = NULL;

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // Delete the trust lists
    //
    LsapDsForestFreeTrustBlobList( &TrustList );
    LsapDsForestFreeTrustBlobList( &RootList );

    if ( PolicyAccountDomainInfo != NULL ) {
        LsaIFree_LSAPR_POLICY_INFORMATION ( PolicyAccountDomainInformation,
                                            PolicyAccountDomainInfo );
    }

    if ( FullTrustedDomainList != NULL ) {
        LsapFreeTrustedDomainsEx( TrustedDomainInformationBasic,
                                  (PLSAPR_TRUSTED_DOMAIN_INFO)FullTrustedDomainList,
                                  FullTrustedDomainCount );
    }

    if ( XrefDomainTrustList != NULL ) {
        LsapFreeTrustedDomainsEx( TrustedDomainInformationBasic,
                                  (PLSAPR_TRUSTED_DOMAIN_INFO)XrefDomainTrustList,
                                  XrefDomainTrustCount );
    }

FunctionReturn:
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_EnumerateTrustedDomains);
    LsarpReturnPrologue();

    return(Status);
}


NTSTATUS
LsapDbSlowEnumerateTrustedDomains(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function performs the same actions as LsarEnumerateTrustedDomains()
    except that the Trusted Domain List is not used.

    This routine is called internally by the LSA only.  Since there
    may be more information than can be returned in a single call of the
    routine, multiple calls can be made to get all of the information.  To
    support this feature, the caller is provided with a handle that can
    be used across calls to the API.  On the initial call, EnumerationContext
    should point to a variable that has been initialized to 0.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    InfoClass - The class of information to return
        Must be TrustedDomainInformationEx, TrustedDomainInformatinBasic or
        TrustedDomainInformationEx2Internal

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            one or more objects may be enumerated on a call that returns this
            reply.
--*/

{
    NTSTATUS Status;
    LSAP_DB_SID_ENUMERATION_BUFFER DbEnumerationBuffer;
    PVOID AllocatedBuffer = NULL;
    //PLSA_TRUST_INFORMATION DomainTrustInfo = NULL;
    LSAP_DB_ATTRIBUTE DomainNameAttribute;
    ULONG DomainTrustInfoLength;
    LSAPR_HANDLE TrustedDomainHandle = NULL;
    ULONG EntriesRead = 0;
    ULONG Index;

    ASSERT( InfoClass == TrustedDomainInformationEx ||
            InfoClass == TrustedDomainInformationEx2Internal ||
            InfoClass == TrustedDomainInformationBasic );

    //
    // Initialization.
    //

    DbEnumerationBuffer.EntriesRead = 0;
    DbEnumerationBuffer.Sids = NULL;
    EnumerationBuffer->EntriesRead = 0;
    EnumerationBuffer->Information = NULL;
    DomainNameAttribute.AttributeValue = NULL;

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if (!ARGUMENT_PRESENT(EnumerationBuffer)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Call general Sid enumeration routine.  This will return an array
    // of pointers to Sids of Trusted Domains referenced from the
    // Enumeration Buffer.
    //

    Status = LsapDbEnumerateSids(
                 PolicyHandle,
                 TrustedDomainObject,
                 EnumerationContext,
                 &DbEnumerationBuffer,
                 PreferedMaximumLength
                 );

    if ((Status != STATUS_NO_MORE_ENTRIES) && !NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    //
    // Return the number of entries read.  Note that the Enumeration Buffer
    // returned from LsapDbEnumerateSids is expected to be non-null
    // in all non-error cases.
    //

    EntriesRead = DbEnumerationBuffer.EntriesRead;

    if (EntriesRead == 0) {
        goto Cleanup;
    }


    //
    // Allocate a buffer to return to our caller
    //

    switch (InfoClass ) {
    case TrustedDomainInformationBasic:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC);
        break;

    case TrustedDomainInformationEx:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX);
        break;

    case TrustedDomainInformationEx2Internal:
        DomainTrustInfoLength = EntriesRead * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2);
        break;

    default:
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;

    }

    AllocatedBuffer = MIDL_user_allocate( DomainTrustInfoLength );

    if ( AllocatedBuffer == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Initialize all pointers to Sids and Unicode buffers in the
    // DomainTrustInfo array to zero.  The error path of this routine
    // assumes that a non-zero value of a Sid or Unicode buffer indicates
    // that memory is to be freed.
    //

    RtlZeroMemory( AllocatedBuffer, DomainTrustInfoLength );

    //
    // Loop through the trusted domains returning the information the caller
    //  requested.
    //

    for ( Index=0; Index<EntriesRead; Index++ ) {


        //
        // Grab the Sid of the trusted domain.
        //


        //
        // Open the Trusted Domain object.  This call is trusted, i.e.
        // no access validation or impersonation is required.  Also,
        // the Lsa Database is already locked so we do not need to
        // lock it again.
        //

        Status = LsapDbOpenTrustedDomain(
                     PolicyHandle,
                     DbEnumerationBuffer.Sids[Index],
                     (ACCESS_MASK) 0,
                     &TrustedDomainHandle,
                     LSAP_DB_TRUSTED );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        //
        // Read the Domain Name
        //

        LsapDbInitializeAttributeDs(
            &DomainNameAttribute,
            TrDmName,
            NULL,
            0L,
            FALSE
            );

        Status = LsapDbReadAttribute(TrustedDomainHandle, &DomainNameAttribute);

        (VOID) LsapDbCloseObject(
                   &TrustedDomainHandle,
                   LSAP_DB_DEREFERENCE_CONTR,
                   Status
                   );

        if (!NT_SUCCESS(Status)) {

#if DBG
            DbgPrint( "LsarEnumerateTrustedDomains - Reading Domain Name\n" );

            DbgPrint( "    failed.  Error 0x%lx reading Trusted Domain Name attribute\n",
                Status);
#endif //DBG

            goto Cleanup;
        }

        //
        // Return the information to the caller.
        //
        switch (InfoClass ) {
        case TrustedDomainInformationBasic:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC DomainTrust;

            DomainTrust = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC)AllocatedBuffer)[Index];

            // Grab the Sid
            DomainTrust->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&DomainTrust->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            break;
        }

        case TrustedDomainInformationEx2Internal:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;

            TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)AllocatedBuffer)[Index];

            // Grab the Sid
            TrustInfoEx2->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx2->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Grab the Flat Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx2->FlatName,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Fill in the constant info
            TrustInfoEx2->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustInfoEx2->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustInfoEx2->TrustAttributes = 0;
            TrustInfoEx2->ForestTrustLength = 0;
            TrustInfoEx2->ForestTrustInfo = NULL;

            break;
        }

        case TrustedDomainInformationEx:
        {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx;

            TrustInfoEx = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)AllocatedBuffer)[Index];

            // Grab the Sid
            TrustInfoEx->Sid = DbEnumerationBuffer.Sids[Index];
            DbEnumerationBuffer.Sids[Index] = NULL;

            // Grab the Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx->Name,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Grab the Flat Domain Name
            Status = LsapDbCopyUnicodeAttribute(
                         (PUNICODE_STRING)&TrustInfoEx->FlatName,
                         &DomainNameAttribute,
                         TRUE );

            if ( !NT_SUCCESS(Status)) {
                goto Cleanup;
            }

            // Fill in the constant info
            TrustInfoEx->TrustDirection = TRUST_DIRECTION_OUTBOUND;
            TrustInfoEx->TrustType = TRUST_TYPE_DOWNLEVEL;
            TrustInfoEx->TrustAttributes = 0;

            break;
        }
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // On error,
    //  free any buffer we allocated.
    //

    if ( !NT_SUCCESS(Status) ) {
        if (AllocatedBuffer != NULL) {
            for ( Index=0; Index<EntriesRead; Index++ ) {
                switch (InfoClass ) {
                case TrustedDomainInformationBasic:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC DomainTrust;

                    DomainTrust = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC)AllocatedBuffer)[Index];

                    if ( DomainTrust->Sid != NULL ) {
                        MIDL_user_free( DomainTrust->Sid );
                    }

                    if ( DomainTrust->Name.Buffer != NULL ) {
                        MIDL_user_free( DomainTrust->Name.Buffer );
                    }

                    break;
                }

                case TrustedDomainInformationEx:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustInfoEx;

                    TrustInfoEx = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)AllocatedBuffer)[Index];

                    if ( TrustInfoEx->Sid != NULL ) {
                        MIDL_user_free( TrustInfoEx->Sid );
                    }

                    if ( TrustInfoEx->Name.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx->Name.Buffer );
                    }

                    if ( TrustInfoEx->FlatName.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx->FlatName.Buffer );
                    }

                    break;
                }


                case TrustedDomainInformationEx2Internal:
                {
                    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;

                    TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)AllocatedBuffer)[Index];

                    if ( TrustInfoEx2->Sid != NULL ) {
                        MIDL_user_free( TrustInfoEx2->Sid );
                    }

                    if ( TrustInfoEx2->Name.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx2->Name.Buffer );
                    }

                    if ( TrustInfoEx2->FlatName.Buffer != NULL ) {
                        MIDL_user_free( TrustInfoEx2->FlatName.Buffer );
                    }

                    break;
                }

                }
            }
            MIDL_user_free( AllocatedBuffer );
            AllocatedBuffer = NULL;
            DbEnumerationBuffer.EntriesRead = 0;
        }
    }

    //
    // Fill in returned Enumeration Structure, returning 0 or NULL for
    // fields in the error case.
    //

    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION) AllocatedBuffer;
    EnumerationBuffer->EntriesRead = DbEnumerationBuffer.EntriesRead;

    //
    // If necessary, free the Domain Name Attribute Value buffer which
    // holds a self relative Unicode String.
    //

    if (DomainNameAttribute.AttributeValue != NULL) {

        MIDL_user_free( DomainNameAttribute.AttributeValue );
        DomainNameAttribute.AttributeValue = NULL;
    }

    //
    // Free the SID enumeration buffer.
    //

    if ( DbEnumerationBuffer.Sids != NULL ) {
        for ( Index=0; Index<EntriesRead; Index++ ) {
            if ( DbEnumerationBuffer.Sids[Index] != NULL ) {
                MIDL_user_free( DbEnumerationBuffer.Sids[Index] );
            }
        }
        MIDL_user_free( DbEnumerationBuffer.Sids );

    }

    return(Status);

}


NTSTATUS
LsapDbVerifyInfoQueryTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class.  If valid, a mask
    of the accesses required to set the TrustedDomain Information of the class is
    returned.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    Trusted - TRUE if client is trusted, else FALSE.  A trusted client
        is allowed to query TrustedDomain for all Information Classes, whereas
        a non-trusted client is restricted.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to query the given class of TrustedDomain Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The TrustedDomain Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            TrustedDomain  Information not valid for the class
--*/

{
    if (LsapDbValidInfoTrustedDomain( InformationClass, NULL)) {

        *RequiredAccess = LsapDbRequiredAccessQueryTrustedDomain[InformationClass];
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);

    //
    // Currently, all TrustedDomain information classes may be queried
    // by non-trusted callers, so the Trusted parameter is not accessed.
    //

    UNREFERENCED_PARAMETER(Trusted);
}


NTSTATUS
LsapDbVerifyInfoSetTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN BOOLEAN Trusted,
    OUT PACCESS_MASK RequiredAccess
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class and verifies
    that the provided TrustedDomain Information is valid for the class.
    If valid, a mask of the accesses required to set the TrustedDomain
    Information of the class is returned.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    TrustedDomainInformation - Points to TrustedDomain Information to be set.

    Trusted - TRUE if client is trusted, else FALSE.  A trusted client
        is allowed to set TrustedDomain for all Information Classes, whereas
        a non-trusted client is restricted.

    RequiredAccess - Points to variable that will receive a mask of the
        accesses required to set the given class of TrustedDomain Information.
        If an error is returned, this value is cleared to 0.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The TrustedDomain Information Class provided is
            valid and the information provided is consistent with this
            class.

        STATUS_INVALID_PARAMETER - Invalid parameter:

            Information Class is invalid
            Information Class is invalid for non-trusted clients
            TrustedDomain Information not valid for the class
--*/

{
    //
    // Verify that the information class is valid and that the TrustedDomain
    // Information provided is valid for the class.
    //

    if (LsapDbValidInfoTrustedDomain( InformationClass, TrustedDomainInformation)) {

        //
        // Non-trusted callers are not allowed to set the
        // TrustedDomainNameInformation information class.
        //

        if (!Trusted) {

            if (InformationClass == TrustedDomainNameInformation) {

                return(STATUS_INVALID_PARAMETER);
            }
        }

//        ASSERT( InformationClass <=
//                   sizeof( LsapDbRequiredAccessSetTrustedDomain ) / sizeof( ACCESS_MASK ) + 1);

        *RequiredAccess = LsapDbRequiredAccessSetTrustedDomain[InformationClass];
        return(STATUS_SUCCESS);
    }

    return(STATUS_INVALID_PARAMETER);
}


BOOLEAN
LsapDbValidInfoTrustedDomain(
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation
    )

/*++

Routine Description:

    This function validates a TrustedDomain Information Class and optionally verifies
    that provided TrustedDomain Information is valid for the class.

Arguments:

    InformationClass - Specifies a TrustedDomain Information Class.

    TrustedDomainInformation - Optionally points to TrustedDomain Information.  If
        NULL is specified, no TrustedDomain Information checking takes place.

Return Values:

    BOOLEAN - TRUE if the TrustedDomain information class provided is
        valid, else FALSE.
--*/

{
    BOOLEAN BooleanStatus = FALSE;

    //
    // Validate the Information Class
    //

    if ((InformationClass >= TrustedDomainNameInformation) &&
        (InformationClass <= TrustedDomainFullInformation2Internal)) {

        if (TrustedDomainInformation == NULL) {

            return(TRUE);
        }

        switch (InformationClass) {

        case TrustedDomainNameInformation: {
            PTRUSTED_DOMAIN_NAME_INFO TrustedDomainNameInfo = (PTRUSTED_DOMAIN_NAME_INFO) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainNameInfo->Name )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedPosixOffsetInformation: {
            PTRUSTED_POSIX_OFFSET_INFO TrustedPosixOffsetInfo = (PTRUSTED_POSIX_OFFSET_INFO) TrustedDomainInformation;

            BooleanStatus = TRUE;
            break;
        }


        case TrustedPasswordInformation: {
            PLSAPR_TRUSTED_PASSWORD_INFO TrustedPasswordInfo =  (PLSAPR_TRUSTED_PASSWORD_INFO) TrustedDomainInformation;      TrustedPasswordInfo;
            if ( TrustedPasswordInfo->Password != NULL &&
                 !LsapValidateLsaCipherValue( TrustedPasswordInfo->Password )) {
                break;
            }
            if ( TrustedPasswordInfo->OldPassword != NULL &&
                 !LsapValidateLsaCipherValue( TrustedPasswordInfo->OldPassword )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationBasic: {
            PTRUSTED_DOMAIN_INFORMATION_BASIC TrustedDomainBasicInfo = (PTRUSTED_DOMAIN_INFORMATION_BASIC) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainBasicInfo->Name )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationEx: {
            PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainExInfo = (PTRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo->Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo->FlatName )) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainAuthInformation: {
            PTRUSTED_DOMAIN_AUTH_INFORMATION TrustedDomainAuthInfo = (PTRUSTED_DOMAIN_AUTH_INFORMATION) TrustedDomainInformation;

            if ( TrustedDomainAuthInfo->IncomingAuthInfos != 0 &&
                 TrustedDomainAuthInfo->IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainAuthInfo->OutgoingAuthInfos != 0 &&
                 TrustedDomainAuthInfo->OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformation: {
            PTRUSTED_DOMAIN_FULL_INFORMATION TrustedDomainFullInfo = (PTRUSTED_DOMAIN_FULL_INFORMATION) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.IncomingAuthInfos != 0 &&
                 TrustedDomainFullInfo->AuthInformation.IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.OutgoingAuthInfos != 0 &&
                 TrustedDomainFullInfo->AuthInformation.OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainAuthInformationInternal: {
            PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL TrustedDomainAuthInfo = (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL) TrustedDomainInformation;

            if ( TrustedDomainAuthInfo->AuthBlob.AuthSize != 0 &&
                 TrustedDomainAuthInfo->AuthBlob.AuthBlob == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformationInternal: {
            PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL TrustedDomainFullInfo = (PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION_INTERNAL) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo->AuthInformation.AuthBlob.AuthSize != 0 &&
                 TrustedDomainFullInfo->AuthInformation.AuthBlob.AuthBlob == NULL ) {
                break;
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainInformationEx2Internal: {
            PTRUSTED_DOMAIN_INFORMATION_EX2 TrustedDomainExInfo2 = (PTRUSTED_DOMAIN_INFORMATION_EX2) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo2->Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainExInfo2->FlatName )) {
                break;
            }
            if ( TrustedDomainExInfo2->ForestTrustLength == 0 ||
                 TrustedDomainExInfo2->ForestTrustInfo == NULL ) {

                if ( TrustedDomainExInfo2->ForestTrustLength != 0 ||
                     TrustedDomainExInfo2->ForestTrustInfo != NULL ) {

                    break;
                }
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedDomainFullInformation2Internal: {
            PTRUSTED_DOMAIN_FULL_INFORMATION2 TrustedDomainFullInfo2 = (PTRUSTED_DOMAIN_FULL_INFORMATION2) TrustedDomainInformation;
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo2->Information.Name )) {
                break;
            }
            if ( !LsapValidateLsaUnicodeString( &TrustedDomainFullInfo2->Information.FlatName )) {
                break;
            }

            if ( TrustedDomainFullInfo2->AuthInformation.IncomingAuthInfos != 0 &&
                 TrustedDomainFullInfo2->AuthInformation.IncomingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo2->AuthInformation.OutgoingAuthInfos != 0 &&
                 TrustedDomainFullInfo2->AuthInformation.OutgoingAuthenticationInformation == NULL ) {
                break;
            }

            if ( TrustedDomainFullInfo2->Information.ForestTrustLength == 0 ||
                 TrustedDomainFullInfo2->Information.ForestTrustInfo == NULL ) {

                if ( TrustedDomainFullInfo2->Information.ForestTrustLength != 0 ||
                     TrustedDomainFullInfo2->Information.ForestTrustInfo != NULL ) {

                    break;
                }
            }

            BooleanStatus = TRUE;
            break;
        }

        case TrustedControllersInformation: // No longer supported
        default:

            BooleanStatus = FALSE;
            break;
        }
    }

    return(BooleanStatus);
}


NTSTATUS
LsapDbLookupSidTrustedDomainList(
    IN PLSAPR_SID DomainSid,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Sid in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainSid - Pointer to a Sid that will be compared with the list of
        Sids of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain specified by DomainSid
        within the Trusted Domain List.

        NOTE: The trust information returned will always be the trusted
        domain objects domain name.  Not the flat name.  That means that
        for uplevel trusts, a DNS domain name will be returned.

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    //
    // Don't try to lookup by sid if we don't have a sid
    //
    if ( DomainSid == NULL ) {

        Status = STATUS_NO_SUCH_DOMAIN;
        goto LookupSidTrustedDomainListError;

    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupSidTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = DomainSid;
    InputTrustInformation.Name.Buffer = NULL;
    InputTrustInformation.Name.Length = 0;
    InputTrustInformation.Name.MaximumLength = 0;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustInformation = &TrustEntry->ConstructedTrustInfo;

LookupSidTrustedDomainListFinish:

    return(Status);

LookupSidTrustedDomainListError:

    *TrustInformation = NULL;
    goto LookupSidTrustedDomainListFinish;
}


NTSTATUS
LsapDbLookupNameTrustedDomainList(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainName - Pointer to a Unicode Name that will be compared with the
        list of Names of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupNameTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = NULL;
    InputTrustInformation.Name = *DomainName;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNameTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustInformation = &TrustEntry->ConstructedTrustInfo;

LookupNameTrustedDomainListFinish:

    return(Status);

LookupNameTrustedDomainListError:

    *TrustInformation = NULL;
    goto LookupNameTrustedDomainListFinish;
}

NTSTATUS
LsapDbLookupSidTrustedDomainListEx(
    IN PSID DomainSid,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainSid - sid of the domain to lookup

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupSidTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = DomainSid;
    RtlInitUnicodeString( (UNICODE_STRING*)&InputTrustInformation.Name, NULL );

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto LookupSidTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustedDomainListEntry = TrustEntry;

LookupSidTrustedDomainListFinish:

    return(Status);

LookupSidTrustedDomainListError:

    *TrustedDomainListEntry = NULL;
    goto LookupSidTrustedDomainListFinish;
}



NTSTATUS
LsapDbLookupNameTrustedDomainListEx(
    IN PLSAPR_UNICODE_STRING DomainName,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Description:

    This function looks up a given Trusted Domain Name in the Trusted
    Domain List and returns Trust Information consisting of its
    Sid and Name.

Arguments:

    DomainName - Pointer to a Unicode Name that will be compared with the
        list of Names of Trusted Domains.

    TrustInformation - Receives the a pointer to the Trust Information
        (Sid and Name) of the Trusted Domain described by DomainName
        within the Trusted Domain List.

        NOTE: This name will be looked up as both the trusted domain objects
        domain name and the flat name

        NOTE: This routine assumes that the Trusted Domain List
        will not be updated while any Lookup operations are pending.
        Thus, the pointer returned for TrustInformation will remain
        valid.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SectionIndex;
    LSAPR_TRUST_INFORMATION InputTrustInformation;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto LookupNameTrustedDomainListError;
        }
    }

    InputTrustInformation.Sid = NULL;
    InputTrustInformation.Name = *DomainName;

    Status = LsapDbLookupEntryTrustedDomainList(
                 &InputTrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto LookupNameTrustedDomainListError;
    }

    //
    // Return pointer to Trust Information
    //

    *TrustedDomainListEntry = TrustEntry;

LookupNameTrustedDomainListFinish:

    return(Status);

LookupNameTrustedDomainListError:

    *TrustedDomainListEntry = NULL;
    goto LookupNameTrustedDomainListFinish;
}




NTSTATUS
LsapDbLookupEntryTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainListEntry
    )

/*++

Routine Decsription:

    This function locates an entry for a Trusted Domain in the Trusted
    Domain List, given Trust Information containing either a Domain Sid
    or a Domain Name.

Arguments:

    TrustInformation - Points to the Sid and Name of a Trusted Domain.

    TrustedDomainListEntry - Receives pointer to the trusted domain list
        entry that statisfies the request

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The domain was found.

        STATUS_NO_SUCH_DOMAIN - The domain was not found.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLIST_ENTRY ListEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY PossibleMatch = NULL, BestMatch = NULL, Current;

    ULONG ScanSectionIndex;

    BOOLEAN LookupSid = TRUE;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            *TrustedDomainListEntry = NULL;
            goto Cleanup;
        }
    }

    //
    // Decide if we're to lookup a Domain Sid or a Domain Name.
    //

    if (TrustInformation->Sid == NULL) {

        LookupSid = FALSE;
    }

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // Find the best match.  Note that if we find an entry without a SID, we'll mark it
        // as a possible match, but see if we can do better.
        if (LookupSid) {

            if ( Current->TrustInfoEx.Sid &&
                 RtlEqualSid( ( PSID )TrustInformation->Sid,
                              ( PSID )Current->TrustInfoEx.Sid ) ) {

                BestMatch = Current;
                break;
            }

        } else {

            //
            // Check domain name first
            //
            if ( RtlEqualDomainName( ( PUNICODE_STRING )&TrustInformation->Name,
                                     ( PUNICODE_STRING )&Current->TrustInfoEx.Name ) ||

                 RtlEqualDomainName( ( PUNICODE_STRING )&TrustInformation->Name,
                                     ( PUNICODE_STRING )&Current->TrustInfoEx.FlatName ) ) {

                //
                // If we have a full domain object, just return the info.  Otherwise,
                // we'll see if we don't have a better match down the line
                //
                if ( Current->TrustInfoEx.Sid ) {

                    BestMatch = Current;
                    break;

                } else {

                    //
                    // There might be duplicate objects in the DS
                    // The best we can do is pick one
                    //

                    PossibleMatch = Current;
                }
            }
        }
    }

    //
    // Now, see what to return
    //
    if ( BestMatch == NULL ) {

        BestMatch = PossibleMatch;
    }

    if ( BestMatch ) {

        *TrustedDomainListEntry = BestMatch;

    } else {

        *TrustedDomainListEntry = NULL;
        Status = STATUS_NO_SUCH_DOMAIN;

    }

Cleanup:

    return(Status);
}


NTSTATUS
LsapDbInitializeTrustedDomainListEntry(
    IN PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustListEntry,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    )
/*++

Routine Description:

    This function will initialize a trusted domain list entry to the
    information contained in the TRUSTED_DOMAIN_INFORMATION_EX structure

Arguments:

    TrustListEntry - The TRUSTED_DOMAIN_LIST_ENTRY node to initialize

    DomainInfo - Points to a LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
        structure which contains information on the trusted domain.

    PosixOffset - Posix offset for this trusted domain

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Intialize the Trust List entry first to all 0's
    //

    RtlZeroMemory(TrustListEntry,sizeof(LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));

    //
    // Copy the information over
    //
    Status = LsapRpcCopyUnicodeString( NULL,
                                       ( PUNICODE_STRING )&TrustListEntry->TrustInfoEx.Name,
                                       ( PUNICODE_STRING )&DomainInfo->Name );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsapRpcCopyUnicodeString( NULL,
                                           ( PUNICODE_STRING )&TrustListEntry->TrustInfoEx.FlatName,
                                           ( PUNICODE_STRING )&DomainInfo->FlatName );

        if ( NT_SUCCESS( Status ) && DomainInfo->Sid ) {

            Status = LsapRpcCopySid( NULL,
                                     ( PSID )&TrustListEntry->TrustInfoEx.Sid,
                                     ( PSID )DomainInfo->Sid );

        } else {

            TrustListEntry->TrustInfoEx.Sid = NULL;
        }
    }

    //
    // See if this entry contains forest trust information, and if so, insert it
    //
    if ( NT_SUCCESS( Status ) &&
         LsapHavingForestTrustMakesSense(
             DomainInfo->TrustDirection,
             DomainInfo->TrustType,
             DomainInfo->TrustAttributes
             ) &&
         DomainInfo->ForestTrustInfo != NULL &&
         DomainInfo->ForestTrustLength > 0 ) {

        LSA_FOREST_TRUST_INFORMATION ForestTrustInfo;

        Status = LsapForestTrustUnmarshalBlob(
                     DomainInfo->ForestTrustLength,
                     DomainInfo->ForestTrustInfo,
                     ForestTrustRecordTypeLast,
                     &ForestTrustInfo
                     );

        if ( NT_SUCCESS( Status )) {

            Status = LsapForestTrustCacheInsert(
                         ( PUNICODE_STRING )&DomainInfo->Name,
                         ( PSID )DomainInfo->Sid,
                         &ForestTrustInfo,
                         FALSE
                         );

            LsapFreeForestTrustInfo( &ForestTrustInfo );
        }
    }

    if ( NT_SUCCESS( Status ) ) {

        TrustListEntry->TrustInfoEx.TrustAttributes = DomainInfo->TrustAttributes;
        TrustListEntry->TrustInfoEx.TrustDirection = DomainInfo->TrustDirection;
        TrustListEntry->TrustInfoEx.TrustType = DomainInfo->TrustType;
        TrustListEntry->PosixOffset = PosixOffset;

        //
        // Construct the TRUST_INFO that most of the lookup routines return
        //
        TrustListEntry->ConstructedTrustInfo.Sid = TrustListEntry->TrustInfoEx.Sid;
        RtlCopyMemory( &TrustListEntry->ConstructedTrustInfo.Name,
                       &TrustListEntry->TrustInfoEx.FlatName,
                       sizeof( UNICODE_STRING ) );

    } else {

        //
        // Something failed... clean up
        //

        MIDL_user_free( TrustListEntry->TrustInfoEx.Sid );
        MIDL_user_free( TrustListEntry->TrustInfoEx.Name.Buffer );
        MIDL_user_free( TrustListEntry->TrustInfoEx.FlatName.Buffer );

        RtlZeroMemory(TrustListEntry,sizeof(LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));
    }

    return( Status );
}

NTSTATUS
LsapDbReconcileDuplicateTrusts(
    IN PUNICODE_STRING   Name,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *WinningEntry
    )
/*++

  Routine Description

    This function searches the DS for the occurance of any duplicates
    and using appropriate criteria chooses a winner. The object guid
    of the winner is stamped on the winning entry

  Arguments:

    ExistingEntry
    NewEntry

  Return Values

    STATUS_SUCCESS
    Other error codes to indicate resource failures

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL SearchAttrVal;
    ATTR   AttrToMatch = {ATT_TRUST_PARTNER, {1,&SearchAttrVal}};
    DSNAME *WinningObject = NULL;
    WCHAR szRDN[MAX_RDN_SIZE+1];
    ULONG Rdnlength = MAX_RDN_SIZE;
    ATTRTYP RDNtype;
    ULONG i,j;
    BOOLEAN CloseTransaction = FALSE;
    BOOLEAN ActiveThreadState = FALSE;
    PDSNAME  * FoundNames = NULL;
    ULONG   cFoundNames=0;


    //
    // Duplicates can occur legally in DS mode only
    //


    *WinningEntry = NULL;

    if (!LsaDsStateInfo.UseDs)
    {
        ASSERT(FALSE && "Duplicate Trust in Registry Mode");
        return(STATUS_SUCCESS);
    }

    //
    // At this point we cannot say whether we are in a transaction
    // therefore handle both cases
    //



    if (!SampExistsDsTransaction())
    {
        //
        // Begin a Transaction
        //

        Status = LsapDsInitAllocAsNeededEx(
                        LSAP_DB_NO_LOCK,
                        TrustedDomainObject,
                        &CloseTransaction
                        );

        if (!NT_SUCCESS(Status))
            goto Error;

        ActiveThreadState = TRUE;
    }


    SearchAttrVal.valLen = Name->Length;
    SearchAttrVal.pVal = (PVOID) Name->Buffer;

    Status = LsapDsSearchNonUnique(
                0,
                LsaDsStateInfo.DsSystemContainer,
                &AttrToMatch,
                1, // num attrs to match
                &FoundNames,
                &cFoundNames
                );

    if(!NT_SUCCESS(Status))
    {
        goto Error;
    }

    for (i=0;i<cFoundNames;i++)
    {


        //
        // Get the RDN
        //

        if (0!=GetRDNInfoExternal(
                    FoundNames[i],
                    szRDN,
                    &Rdnlength,
                    &RDNtype
                    ))
        {
            Status = STATUS_OBJECT_NAME_INVALID;
            goto Error;
        }


        //
        // Test if mangled
        //

        if (!IsMangledRDNExternal(szRDN,Rdnlength,NULL))
        {
            WinningObject = FoundNames[i];
            break;
        }
    }


    if (NULL!=WinningObject)
    {
         ATTRBLOCK Read, Results;
         UNICODE_STRING FlatName;
         ULONG TrustType = 0,TrustDirection=0,TrustAttributes = 0;
         ULONG ForestTrustLength = 0;
         PBYTE ForestTrustInfo = NULL;
         ULONG PosixOffset = 0;
         PSID TrustedDomainSid = NULL;
         LSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo;

        //
        // Winning object can legally be null here as the above logic is not necessarily in
        // the same transaction
        //

        RtlZeroMemory(&FlatName,sizeof(UNICODE_STRING));
        RtlZeroMemory(&NewTrustInfo, sizeof(NewTrustInfo));


        Read.attrCount = LsapDsTrustedDomainFixupAttributeCount;
        Read.pAttr = LsapDsTrustedDomainFixupAttributes;
        Status = LsapDsReadByDsName( WinningObject,
                                 0,
                                 &Read,
                                 &Results );


        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        //
        // Walk the results
        //

         for ( j = 0; j < Results.attrCount; j++ ) {

            switch ( Results.pAttr[ j ].attrTyp ) {

                case ATT_TRUST_TYPE:

                        TrustType = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_DIRECTION:

                        TrustDirection = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_ATTRIBUTES:

                        TrustAttributes = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[ j ] );
                        break;

                case ATT_TRUST_POSIX_OFFSET:
                    PosixOffset = LSAP_DS_GET_DS_ATTRIBUTE_AS_ULONG( &Results.pAttr[j] );
                    break;

                case ATT_FLAT_NAME:

                        FlatName.Length = ( USHORT) LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                        FlatName.MaximumLength =  FlatName.Length;
                        FlatName.Buffer =  LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR( &Results.pAttr[ j ] );
                        break;

                case ATT_SECURITY_IDENTIFIER:

                        TrustedDomainSid = (PSID)LSAP_DS_GET_DS_ATTRIBUTE_AS_PWSTR(&Results.pAttr[j]);
                        break;

                case ATT_MS_DS_TRUST_FOREST_TRUST_INFO:

                        ForestTrustLength = ( ULONG )LSAP_DS_GET_DS_ATTRIBUTE_LENGTH( &Results.pAttr[ j ] );
                        ForestTrustInfo = LSAP_DS_GET_DS_ATTRIBUTE_AS_PBYTE( &Results.pAttr[ j ] );
                        break;
            }
        }


        RtlCopyMemory(&NewTrustInfo.Name,Name, sizeof(UNICODE_STRING));

        RtlCopyMemory(&NewTrustInfo.FlatName,&FlatName,sizeof(UNICODE_STRING));

        NewTrustInfo.Sid = TrustedDomainSid;
        NewTrustInfo.TrustType = TrustType;
        NewTrustInfo.TrustDirection = TrustDirection;
        NewTrustInfo.TrustAttributes = TrustAttributes;
        NewTrustInfo.ForestTrustLength = ForestTrustLength;
        NewTrustInfo.ForestTrustInfo = ForestTrustInfo;

        *WinningEntry = MIDL_user_allocate( sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ) );

        if ( *WinningEntry == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlZeroMemory(*WinningEntry,sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY));

        Status = LsapDbInitializeTrustedDomainListEntry( *WinningEntry,
                                                         &NewTrustInfo,
                                                         PosixOffset );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }


        //
        // Set the GUID on the object
        //

        RtlCopyMemory(&(*WinningEntry)->ObjectGuidInDs,&WinningObject->Guid,sizeof(GUID));

    }
    else
    {
        //
        // Its O.K to find no entry for the name
        //

        Status = STATUS_SUCCESS;
    }

Error:

    if (ActiveThreadState)
    {

        LsapDsDeleteAllocAsNeededEx2(
            LSAP_DB_NO_LOCK,
            TrustedDomainObject,
            CloseTransaction,
            FALSE // rollback transaction
            );

        ASSERT(!SampExistsDsTransaction());


    }

    if (!NT_SUCCESS(Status))
    {
        if (NULL!=*WinningEntry)
        {
             _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
                              ( PLSAPR_TRUSTED_DOMAIN_INFO )&(*WinningEntry)->TrustInfoEx,
                               TrustedDomainInformationEx
                               );

            MIDL_user_free( *WinningEntry );
            *WinningEntry = NULL;
        }
    }

    if(NULL!=FoundNames)
    {
        //
        // Search non unique allocates only one big chunk,
        // so no need to free individual members
        //

        LsapFreeLsaHeap(FoundNames);
    }

    return(Status);
}



NTSTATUS
LsapDbInsertTrustedDomainList(
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 DomainInfo,
    IN ULONG PosixOffset
    )
/*++

Routine Description:

    This function inserts a Trusted Domain in the Trusted Domain List.
    It is called when a Trusted Domain object is created in the Lsa
    Policy Database.  The List will not be altered while it is active.

Arguments:

    DomainInfo - Points to a LSAPR_TRUSTED_DOMAIN_INFORMATION_EX
        structure which contains information on the trusted domain.

    ObjectGuidInDs - Indicates the ObjectGuid in the DS.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY NewEntry = NULL;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ExistingEntry = NULL;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY EntryToFree = NULL;

    //
    // If we are actually upgrading from NT4, do not touch any in memory structures
    //

    if ( LsaDsStateInfo.Nt4UpgradeInProgress ) {

        return STATUS_SUCCESS;
    }

    if ( DomainInfo == NULL ) {

        return STATUS_SUCCESS;
    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If the Trusted Domain List is not valid, attempt to rebuild the cache
    // One exception: the cache is being built just now, then no need to rebuild
    //

    if ( !LsapDbIsValidTrustedDomainList()) {

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto InsertTrustedDomainListError;
        }
    }

    //
    // Check for Duplicates. Duplicates can legally occur in a multi master system
    //

    Status = LsapDbLookupNameTrustedDomainListEx(
                 &DomainInfo->Name,
                 &ExistingEntry
                 );

    if ( STATUS_NO_SUCH_DOMAIN == Status ) {

        //
        // Good ! There are no duplicates. Simply insert into the list
        //

        //
        // The Trusted Domain List is referenced by us, but otherwise inactive
        // so we can update it.  Create a new Trusted Domain List section for
        // all of the Trusted Domains to be added to the list.
        //

        NewEntry = MIDL_user_allocate( sizeof( LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY ));

        if ( NewEntry == NULL ) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto InsertTrustedDomainListError;
        }

        Status = LsapDbInitializeTrustedDomainListEntry(
                     NewEntry,
                     DomainInfo,
                     PosixOffset
                     );

        if ( Status == STATUS_INVALID_PARAMETER ) {

            SpmpReportEventU(
                EVENTLOG_ERROR_TYPE,
                LSA_TRUST_INSERT_ERROR,
                0,
                sizeof( ULONG ),
                &Status,
                1,
                &NewEntry->TrustInfoEx.Name
                );

            _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
                ( PLSAPR_TRUSTED_DOMAIN_INFO )&NewEntry->TrustInfoEx,
                TrustedDomainInformationEx
                );

            MIDL_user_free( NewEntry );

            NewEntry = NULL;

        } else if ( !NT_SUCCESS( Status )) {

            EntryToFree = NewEntry;
            goto InsertTrustedDomainListError;

        } else {

            //
            // Remember a sequence number for this trusted domain
            //

            LsapDbTrustedDomainList.TrustedDomainCount++;
            LsapDbTrustedDomainList.CurrentSequenceNumber++;
            NewEntry->SequenceNumber = LsapDbTrustedDomainList.CurrentSequenceNumber;

            InsertTailList(
                &LsapDbTrustedDomainList.ListHead,
                &NewEntry->NextEntry
                );
        }

        Status = STATUS_SUCCESS;

    } else if ( STATUS_SUCCESS == Status ) {

        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY WinningEntry = NULL;

        //
        // We found an entry already in the trusted domain list
        // we now need to reconcile and make only one of the 2 entries win.
        // Our reconciliation logic is very simple

        //
        // 1. We handle only duplicates via name.
        // 2. We assume that both duplicates are identical in terms of domain
        //    SID, trust type, trust attributes etc. This covers us for the case
        //    where a duplicate has been created inverdantly by an admin who ended
        //    up creating the same trust on different DC's
        //


        Status = LsapDbReconcileDuplicateTrusts(
                     ( PUNICODE_STRING )&DomainInfo->Name,
                     &WinningEntry
                     );

         if ( !NT_SUCCESS( Status )) {

             goto InsertTrustedDomainListError;
         }

         RemoveEntryList( &ExistingEntry->NextEntry );
         LsapDbTrustedDomainList.TrustedDomainCount--;
         EntryToFree = ExistingEntry;

         if ( NULL != WinningEntry ) {

            //
            // It is legal to expect WinningEntry to be NULL, this
            // can occur if out of band all duplicates were deleted
            //

            //
            // Remember a sequence number for this trusted domain
            //

            LsapDbTrustedDomainList.TrustedDomainCount++;
            LsapDbTrustedDomainList.CurrentSequenceNumber++;
            WinningEntry->SequenceNumber = LsapDbTrustedDomainList.CurrentSequenceNumber;

            InsertTailList(
                &LsapDbTrustedDomainList.ListHead,
                &WinningEntry->NextEntry
                );
         }
    }

InsertTrustedDomainListFinish:

    if ( NULL != EntryToFree ) {

        NTSTATUS Ignore;

        Ignore = LsapForestTrustCacheRemove(( UNICODE_STRING * )&EntryToFree->TrustInfoEx.Name );

        ASSERT( Ignore == STATUS_SUCCESS ||
                Ignore == STATUS_NOT_FOUND );

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO (
            ( PLSAPR_TRUSTED_DOMAIN_INFO )&EntryToFree->TrustInfoEx,
            TrustedDomainInformationEx
            );

        MIDL_user_free( EntryToFree );
    }

    return Status;

InsertTrustedDomainListError:

    goto InsertTrustedDomainListFinish;
}


NTSTATUS
LsapDbDeleteTrustedDomainList(
    IN PLSAPR_TRUST_INFORMATION TrustInformation
    )

/*++

Routine Description:

    This function deletes a Trusted Domain from the Trusted Domain List
    if that list is marked as valid.  The Trusted Domain List will not
    be altered while there are Lookup operations pending.

Arguments:

    TrustInformation - Points to the Sid and Name of a Trusted Domain.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS Ignore;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If the Trusted Domain List is not valid, quit and do nothing.
    //

    if (!LsapDbIsValidTrustedDomainList()) {

        goto DeleteTrustedDomainListFinish;
    }

    //
    // The Trusted Domain List is referenced by us, but otherwise inactive.
    // Update the List.  First, we need to locate the entry to be deleted.
    //

    Status = LsapDbLookupEntryTrustedDomainList(
                 TrustInformation,
                 &TrustEntry );

    if (!NT_SUCCESS(Status)) {

        goto DeleteTrustedDomainListError;
    }

    RemoveEntryList( &TrustEntry->NextEntry );
    LsapDbTrustedDomainList.TrustedDomainCount--;

    Ignore = LsapForestTrustCacheRemove(( UNICODE_STRING * )&TrustEntry->TrustInfoEx.Name );

    ASSERT( Ignore == STATUS_SUCCESS ||
            Ignore == STATUS_NOT_FOUND );

    _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( ( PLSAPR_TRUSTED_DOMAIN_INFO )&TrustEntry->TrustInfoEx,
                                      TrustedDomainInformationEx );

    MIDL_user_free( TrustEntry );

DeleteTrustedDomainListFinish:

    return(Status);

DeleteTrustedDomainListError:

    goto DeleteTrustedDomainListFinish;
}



NTSTATUS
LsapDbFixupTrustedDomainListEntry(
    IN OPTIONAL PSID TrustedDomainSid,
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    IN OPTIONAL PLSAPR_UNICODE_STRING FlatName,
    IN OPTIONAL PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 NewTrustInfo,
    IN OPTIONAL PULONG PosixOffset
    )
/*++

Routine Description:

    This function will update the information in the trusted domain list that
    corresponds to the given trust item.  This is mostly useful for SetTrustedDomainInformation
    calls

Arguments:

    TrustedDomainSid - If specified, is used to identify which TDL entry to update.
        In not specified, NewTrustInfo is used.

    NewTrustInfo - Points to the full information regarding the trusted domain
        If specified, TDL entry is updated to reflect this information.

    PosixOffset - Points to the Posix Offset to set on the entry
        If not specified, the Posix Offset will not be changed.

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;
    LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TempTrustEntry;
    BOOLEAN AcquiredListWriteLock = FALSE;
    LSAPR_TRUST_INFORMATION TrustInformation;

    //
    // If we are upgrading from NT4, then do nothing
    //

    if  (LsaDsStateInfo.Nt4UpgradeInProgress)
    {
        return ( STATUS_SUCCESS);
    }

    //
    // Acquire exclusive write lock for the Trusted Domain List.
    //

    Status = LsapDbAcquireWriteLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    //
    // If the Trusted Domain List is not marked
    // as a valid cache, do nothing.
    //

    if (!LsapDbIsCacheValid(TrustedDomainObject)) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // If the Trusted Domain List is not valid, quit and do nothing.
    //

    if (!LsapDbIsValidTrustedDomainList()) {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Find the TDL entry using trusted domain sid.
    //

    if ( TrustedDomainSid != NULL || Name != NULL || FlatName != NULL ) {

        RtlZeroMemory( &TrustInformation, sizeof( TrustInformation ));

        TrustInformation.Sid = TrustedDomainSid;

        if ( Name != NULL ) {

            TrustInformation.Name = *Name;
        }

        Status = LsapDbLookupEntryTrustedDomainList( &TrustInformation,
                                                     &TrustEntry );

        if ( Status == STATUS_NO_SUCH_DOMAIN &&
             FlatName != NULL ) {

            TrustInformation.Name = *FlatName;

            Status = LsapDbLookupEntryTrustedDomainList( &TrustInformation,
                                                         &TrustEntry );
        }

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ASSERT( TrustEntry );

    //
    // If new trust info is to be updated,
    //  update it.
    //

    if ( NewTrustInfo != NULL ) {

        UNICODE_STRING * RemovingFtInfo = NULL;

        if ( NewTrustInfo->ForestTrustInfo == NULL ) {

            RemovingFtInfo = ( UNICODE_STRING * )&TrustEntry->TrustInfoEx.Name;
        }

        //
        // Use a temp variable for the entry (so if we fail to initialize it,
        // we won't have trashed our current data)
        //

        Status = LsapDbInitializeTrustedDomainListEntry( &TempTrustEntry,
                                                         NewTrustInfo,
                                                         0 );   // Ignore Posix Offset

        if ( NT_SUCCESS( Status ) ) {

            if ( RemovingFtInfo ) {

                NTSTATUS Ignore;

                Ignore = LsapForestTrustCacheRemove( RemovingFtInfo );

                ASSERT( Ignore == STATUS_SUCCESS ||
                        Ignore == STATUS_NOT_FOUND );
            }

            //
            // Delete the contents of the current item...
            //

            _fgu__LSAPR_TRUSTED_DOMAIN_INFO ( ( PLSAPR_TRUSTED_DOMAIN_INFO )&TrustEntry->TrustInfoEx,
                                              TrustedDomainInformationEx );
            //
            // Copy in the fields that need updating
            //

            RtlCopyMemory( &TrustEntry->TrustInfoEx, &TempTrustEntry.TrustInfoEx, sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX) );
            RtlCopyMemory(&TrustEntry->ConstructedTrustInfo, &TempTrustEntry.ConstructedTrustInfo,sizeof(LSAPR_TRUST_INFORMATION));
        }
    }

    //
    // If Posix offset is to be updated,
    //  update it.
    //

    if ( PosixOffset != NULL ) {
        TrustEntry->PosixOffset = *PosixOffset;
    }


Cleanup:

    LsapDbReleaseLockTrustedDomainList();

    return(Status);

}



NTSTATUS
LsapDbTraverseTrustedDomainList(
    IN OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT OPTIONAL PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    This function is used to traverse the Trusted Domain List.  Each call
    yields a pointer to the Trust Information for the next Trusted Domain
    on the list.

Arguments:

    TrustedDomainEntry - A pointer to the relevant trusted domain entry.  Prior to the
        first call to the routine, this location must be initialized to
        NULL.

    TrustInformation - If specified, receives a pointer to the Trust
        Information for the next Trusted Domain, or NULL if there are no more.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - This is returned when the final entry is being
            returned.

        STATUS_MORE_ENTRIES - There are more entries in the list, so call
            again.

        STATUS_NO_MORE_ENTRIES - There are no more entries after the
            one returned.

        STATUS_INVALID_PARAMETER -- An invalid TrustedDomainEntry pointer was given

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustEntry = NULL;

    ASSERT( TrustedDomainEntry );

    if ( TrustedDomainEntry == NULL ) {

        return( STATUS_INVALID_PARAMETER );
    }

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // If there is a present section selected, examine it.
    //
    if ( *TrustedDomainEntry == NULL ) {

        //
        // Handle the empty list case first...
        //
        if ( IsListEmpty( &LsapDbTrustedDomainList.ListHead ) ) {

            Status = STATUS_NO_MORE_ENTRIES;

            TrustEntry = NULL;

        } else {

            TrustEntry = CONTAINING_RECORD( LsapDbTrustedDomainList.ListHead.Flink,
                                            LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );
            ASSERT( TrustEntry );
        }

    } else {

        TrustEntry = *TrustedDomainEntry;

        if ( TrustEntry->NextEntry.Flink == &LsapDbTrustedDomainList.ListHead ) {

            Status = STATUS_NO_MORE_ENTRIES;

            TrustEntry = NULL;

        } else {

            TrustEntry = CONTAINING_RECORD( TrustEntry->NextEntry.Flink,
                                            LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );
            ASSERT( TrustEntry );

        }
    }

    //
    // Set our return status
    //
    if ( Status == STATUS_SUCCESS ) {

        ASSERT( TrustEntry );
        if ( TrustEntry->NextEntry.Flink == &LsapDbTrustedDomainList.ListHead ) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_MORE_ENTRIES;
        }
    }

    //
    // Return the trust information
    //
    if ( TrustEntry != NULL && TrustInformation != NULL ) {

        *TrustInformation = &TrustEntry->ConstructedTrustInfo;
    }

    *TrustedDomainEntry = TrustEntry;


    return(Status);

}


NTSTATUS
LsapDbEnumerateTrustedDomainList(
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER EnumerationBuffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG InfoLevel,
    IN BOOLEAN AllowNullSids
    )

/*++

Routine Description:

    This function enumerates zero or more Trusted Domains on the
    Trusted Domain List.  Since there may be more information than can be
    returned in a single call of the routine, multiple calls can be made to
    get all of the information.  To support this feature, the caller is
    provided with a handle that can be used across calls to the API.  On the
    initial call, EnumerationContext should point to a variable that has
    been initialized to 0.

Arguments:

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.



Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_MORE_ENTRIES - The call completed successfully.  There
            are more entries so call again.  This is a success status.

        STATUS_NO_MORE_ENTRIES - No entries have been returned because there
            are no more entries in the list.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, EnumerationStatus = STATUS_SUCCESS;
    NTSTATUS InitialEnumerationStatus = STATUS_SUCCESS;
    ULONG LengthEnumeratedInfo = 0;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustedDomainEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY StartingEntry;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;
    ULONG EntriesRead, DomainTrustInfoLength, ValidEntries, ValidInserted;
    PLSAPR_TRUST_INFORMATION TrustInformation = NULL;
    PLSAPR_TRUST_INFORMATION StartingTrustInformation = NULL;
    PLSAPR_TRUST_INFORMATION DomainTrustInfo = NULL;
    PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX   DomainTrustInfoEx = NULL;

    LsapEnterFunc( "LsapDbEnumerateTrustedDomainList" );

    EntriesRead = 0;
    ValidEntries = 0;

    //
    // Always allow us to return at least one object.
    //
    if ( PreferedMaximumLength == 0 ) {
        PreferedMaximumLength = 1;
    }

    //
    // Acquire the Read Lock for the Trusted Domain List
    //

    Status = LsapDbAcquireReadLockTrustedDomainList();

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto EnumerateTrustedDomainListError;
        }
    }

    //
    // Find the starting point using the Enumeration Context Variable.
    // This variable specifies an unsigned integer, which is the
    // number of the entry in the list at which to begin the enumeration.
    //

    Status = LsapDbLocateEntryNumberTrustedDomainList(
                 *EnumerationContext,
                 &StartingEntry,
                 &StartingTrustInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto EnumerateTrustedDomainListError;
    }

    InitialEnumerationStatus = Status;

    //
    // Now scan the Trusted Domain List to calculate how many
    // entries we can return and the length of the buffer required.
    // We use the PreferedMaximumLength value as a guide by accumulating
    // the actual length of Trust Information structures and their
    // contents until we either reach the end of the Trusted Domain List
    // or until we first exceed the PreferedMaximumLength value.  Thus,
    // the amount of information returned typically exceeds the
    // PreferedmaximumLength value by a smail amount, namely the
    // size of the Trust Information for a single domain.
    //
    TrustedDomainEntry = StartingEntry;
    TrustInformation = StartingTrustInformation;

    EnumerationStatus = InitialEnumerationStatus;

    for (;;) {

        //
        // Add in the length of the data to be returned for this
        // Domain's Trust Information.  We count the length of the
        // Trust Information structure plus the length of the unicode
        // Domain Name and Sid within it.
        //
        if ( InfoLevel == TrustedDomainInformationEx ) {

            if ( TrustedDomainEntry->TrustInfoEx.Sid ) {

                LengthEnumeratedInfo += sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) +
                                      RtlLengthSid(( PSID )TrustedDomainEntry->TrustInfoEx.Sid ) +
                                      TrustedDomainEntry->TrustInfoEx.Name.MaximumLength +
                                      TrustedDomainEntry->TrustInfoEx.FlatName.MaximumLength;

                ValidEntries++;

            } else if ( AllowNullSids ) {

                LengthEnumeratedInfo += sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) +
                                      TrustedDomainEntry->TrustInfoEx.Name.MaximumLength +
                                      TrustedDomainEntry->TrustInfoEx.FlatName.MaximumLength;

                ValidEntries++;
            }

        } else {

            //
            // If it's an incoming only trust, don't return it...
            //
            if ( FLAG_ON( TrustedDomainEntry->TrustInfoEx.TrustDirection,
                          TRUST_DIRECTION_OUTBOUND ) &&
                 NULL != TrustInformation->Sid ) {

                LengthEnumeratedInfo += sizeof(LSA_TRUST_INFORMATION) +
                                            RtlLengthSid(( PSID )TrustInformation->Sid ) +
                                            TrustInformation->Name.MaximumLength;

                ValidEntries++;
            }
        }

        EntriesRead++;

        //
        // If we've returned all of the entries the caller wants,
        //  quit.
        //

        if (LengthEnumeratedInfo >= PreferedMaximumLength) {
            break;
        }

        //
        // If there are no more entries to enumerate, quit.
        //

        if (EnumerationStatus != STATUS_MORE_ENTRIES) {

            break;
        }


        //
        // Point at the next entry in the Trusted Domain List
        //

        Status = LsapDbTraverseTrustedDomainList(
                     &TrustedDomainEntry,
                     &TrustInformation
                     );

        EnumerationStatus = Status;

        if (!NT_SUCCESS(Status)) {
            goto EnumerateTrustedDomainListError;
        }

    }


    //
    // Allocate memory for the array of TrustInformation entries to be
    // returned.
    //

    if ( InfoLevel == TrustedDomainInformationEx ) {

        DomainTrustInfoLength = ValidEntries * sizeof(LSAPR_TRUSTED_DOMAIN_INFORMATION_EX);

    } else {

        DomainTrustInfoLength = ValidEntries * sizeof(LSA_TRUST_INFORMATION);

    }

    //
    // Now construct the information to be returned to the caller.  We
    // first need to allocate an array of structures of type
    // LSA_TRUST_INFORMATION each entry of which will be filled in with
    // the Sid of the domain and its Unicode Name.
    //

    DomainTrustInfo = (( DomainTrustInfoLength > 0 ) ? MIDL_user_allocate( DomainTrustInfoLength ) : 0);

    if ( DomainTrustInfo == NULL && DomainTrustInfoLength > 0 ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto EnumerateTrustedDomainListError;

    } else if ( DomainTrustInfo != NULL ) {

        RtlZeroMemory ( DomainTrustInfo, DomainTrustInfoLength );
    }

    DomainTrustInfoEx = ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )DomainTrustInfo;

    //
    // Now read through the Trusted Domains again to copy the output
    // information.
    //

    TrustedDomainEntry = StartingEntry;
    TrustInformation = StartingTrustInformation;

    EnumerationStatus = InitialEnumerationStatus;
    ValidInserted = 0;

    for (;;) {

        //
        // Copy in the Trust Information.
        //

        if ( InfoLevel == TrustedDomainInformationEx ) {

            if ( TrustedDomainEntry->TrustInfoEx.Sid || AllowNullSids ) {

                Status = LsapRpcCopyTrustInformationEx(
                             NULL,
                         ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )&DomainTrustInfoEx[ ValidInserted ],
                             &TrustedDomainEntry->TrustInfoEx );

                if (!NT_SUCCESS(Status)) {
                    goto EnumerateTrustedDomainListError;
                }

                ValidInserted++;
                *EnumerationContext = TrustedDomainEntry->SequenceNumber;

                //
                // If we've returned all of the entries the caller wants,
                //  quit.
                //

                if (ValidInserted >= ValidEntries) {
                    break;
                }
            }

        } else {

            //
            // If it's an incoming only trust, don't return it...
            //
            if ( FLAG_ON( TrustedDomainEntry->TrustInfoEx.TrustDirection,
                          TRUST_DIRECTION_OUTBOUND ) &&
                 NULL != TrustInformation->Sid ) {

                Status = LsapRpcCopyTrustInformation( NULL,
                                                      &DomainTrustInfo[ ValidInserted ],
                                                      TrustInformation );

                if (!NT_SUCCESS(Status)) {
                    goto EnumerateTrustedDomainListError;
                }

                ValidInserted++;
                *EnumerationContext = TrustedDomainEntry->SequenceNumber;

                //
                // If we've returned all of the entries the caller wants,
                //  quit.
                //

                if (ValidInserted >= ValidEntries) {
                    break;
                }
            }
        }

        //
        // If there are no more entries to enumerate, quit.
        //

        if (EnumerationStatus != STATUS_MORE_ENTRIES) {
            break;
        }

        //
        // Point at the next entry in the Trusted Domain List
        //
        Status = LsapDbTraverseTrustedDomainList(
                     &TrustedDomainEntry,
                     &TrustInformation );

        EnumerationStatus = Status;

        if (!NT_SUCCESS(Status)) {
            goto EnumerateTrustedDomainListError;
        }

    }

    //
    // Make sure that we are actually returning something...
    //
    if ( EntriesRead == 0 || ValidEntries == 0 ) {

        Status = STATUS_NO_MORE_ENTRIES;
        goto EnumerateTrustedDomainListError;

    } else {

        Status = EnumerationStatus;

    }

EnumerateTrustedDomainListFinish:

    LsapDbReleaseLockTrustedDomainList();

    //
    // Fill in returned Enumeration Structure, returning 0 or NULL for
    // fields in the error case.
    //

    EnumerationBuffer->Information = (PLSAPR_TRUST_INFORMATION) DomainTrustInfo;
    EnumerationBuffer->EntriesRead = ValidEntries;

    LsapExitFunc( "LsapDbEnumerateTrustedDomainList", Status );

    return(Status);

EnumerateTrustedDomainListError:

    //
    // If necessary, free the DomainTrustInfo array and all of its entries.
    //

    if (DomainTrustInfo != NULL) {


        if ( InfoLevel == TrustedDomainInformationEx ) {

            LSAPR_TRUSTED_ENUM_BUFFER_EX FreeEnum;

            FreeEnum.EnumerationBuffer = ( PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX )DomainTrustInfo;
            FreeEnum.EntriesRead = ValidEntries;

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER_EX ( &FreeEnum );

        } else {

            LSAPR_TRUSTED_ENUM_BUFFER FreeEnum;

            FreeEnum.Information = ( PLSAPR_TRUST_INFORMATION )DomainTrustInfo;
            FreeEnum.EntriesRead = ValidEntries;

            LsaIFree_LSAPR_TRUSTED_ENUM_BUFFER ( &FreeEnum );

        }

        DomainTrustInfo = NULL;
        EntriesRead = (ULONG) 0;
    }

    goto EnumerateTrustedDomainListFinish;
}


NTSTATUS
LsapDbLocateEntryNumberTrustedDomainList(
    IN ULONG EntryNumber,
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustedDomainEntry,
    OUT PLSAPR_TRUST_INFORMATION *TrustInformation
    )

/*++

Routine Description:

    Given an Entry Number n, this function obtains the pointer to the nth
    entry (if any) in a Trusted Domain List.  The first entry in the
    list is entry number 0.

    Given an Entry Number n, this function obtains a pointer to the
        first entry with a sequence number greater than n.
        0: returns the first entry.

    WARNING:  The caller of this function must hold a lock for the
        Trusted Domain List.  The valditiy of the returned pointers
        is guaranteed only while that lock is held.

Arguments:

    EntryNumber - Specifies the sequence number. The returned entry will
        be the first entry with a sequence number greater than this.
        0: returns the first entry.

    TrustedDomainEntry - Receives a pointer to the Trusted
        Domain entry.  If no such entry exists, NULL is returned.

    TrustInformation - Receives a pointer to the Trust
        Information for the entry being returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - Call completed successfully and there are no
            entries beyond the entry returned.

        STATUS_MORE_ENTRIES - Call completed successfully and there are
            more entries beyond the entry returned.

        STATUS_NO_MORE_ENTRIES - There is no entry to return.
--*/

{
    NTSTATUS Status;
    PLIST_ENTRY ListEntry;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current = NULL;

    //
    // Initialization
    //

    *TrustInformation = NULL;
    *TrustedDomainEntry = NULL;

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            return Status;
        }
    }

    //
    // Find the first entry with a sequence number greater than the
    //  specified number.
    //

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // See if we have the entry we require
        //
        if ( EntryNumber < Current->SequenceNumber ) {

            if ( ListEntry->Flink != &LsapDbTrustedDomainList.ListHead ) {
                Status = STATUS_MORE_ENTRIES;
            } else {
                Status = STATUS_SUCCESS;
            }

            *TrustInformation = &Current->ConstructedTrustInfo;
            *TrustedDomainEntry  = Current;

            return Status;
        }
    }

    //
    // If no entry was found,
    //  return an error to the caller.
    //

    return STATUS_NO_MORE_ENTRIES;

}

BYTE LdapSwapBitTable[256] = {
    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff,
};

ULONG
LdapSwapBits(
    ULONG Bits
)
/*++

Routine Description:

    Swaps the bits of a ULONG end to end.

    That is, the LSB becomes the MSB, etc.

Arguments:

    Bits - bits to swap

Return Value:

    ULONG with bits swapped.

--*/
{
    ULONG ReturnBits = 0;
    LPBYTE BitPtr = (LPBYTE)&Bits;

    return (LdapSwapBitTable[BitPtr[3]] << 0) |
           (LdapSwapBitTable[BitPtr[2]] << 8) |
           (LdapSwapBitTable[BitPtr[1]] << 16) |
           (LdapSwapBitTable[BitPtr[0]] << 24);


}



ULONG
__cdecl
CompareUlongs(
    const void * Param1,
    const void * Param2
    )

/*++

Routine Description:

    Qsort comparison routine for sorting ULONGs

--*/
{
    return *((PULONG)Param1) - *((PULONG)Param2);
}



NTSTATUS
LsapDbAllocatePosixOffsetTrustedDomainList(
    OUT PULONG PosixOffset
    )

/*++

Routine Description:

    This function return the next available PosixOffset based on the
    current Posix Offsets in the trusted domain list.

    Posix offsets are allocated on the PDC.  Each outbound trust has one.  A TDO
    is given a Posix Offset as it becomes an outbound trust.  If that happens on a
    BDC, the TDO is given a Posix Offset when the TDO is replicated to the PDC.

    This routine must be entered with the trusted domain list write locked.

Arguments:

    PosixOffset - On STATUS_SUCCESS, returns the next available Posix Offset

Return Value:

    NTSTATUS - Standard Nt Result Code
--*/

{
    NTSTATUS Status;

    PULONG SwappedPosixOffsets = NULL;
    ULONG SwappedPosixOffsetCount;
    ULONG TargetSwappedPosixOffset;

    PLIST_ENTRY ListEntry;
    ULONG i;

    //
    // If the Trusted Domain List is not valid, rebuild it before continuing
    //

    ASSERT( LsapDbIsLockedTrustedDomainList());

    if ( !LsapDbIsValidTrustedDomainList()) {

        LsapDbConvertReadLockTrustedDomainListToExclusive();

        Status = LsapDbBuildTrustedDomainCache();

        if ( !NT_SUCCESS( Status )) {

            goto Cleanup;
        }
    }

    //
    // Build an array of all the existing Posix Offsets.
    //

    SwappedPosixOffsets = LsapAllocateLsaHeap( LsapDbTrustedDomainList.TrustedDomainCount * sizeof(ULONG) );

    if ( SwappedPosixOffsets == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Walk the list filling in the array.
    //

    SwappedPosixOffsetCount = 0;

    for ( ListEntry = LsapDbTrustedDomainList.ListHead.Flink;
          ListEntry != &LsapDbTrustedDomainList.ListHead;
          ListEntry = ListEntry->Flink ) {

        PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current;

        Current = CONTAINING_RECORD( ListEntry, LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        //
        // Only grab the Posix Offset from those TDOs that need one.
        //
        if ( LsapNeedPosixOffset( Current->TrustInfoEx.TrustDirection, Current->TrustInfoEx.TrustType ) ) {
            SwappedPosixOffsets[SwappedPosixOffsetCount] = LdapSwapBits( Current->PosixOffset );
            SwappedPosixOffsetCount++;
        }

    }

    //
    // Sort the list.
    //

    qsort( SwappedPosixOffsets,
           SwappedPosixOffsetCount,
           sizeof(ULONG),
           CompareUlongs );

    //
    // Walk the list finding the first free entry.
    //


#define SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET          ((ULONG) 0x4000)
#define SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET           ((ULONG) 0xC000)
#define SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET           ((ULONG) 0x0800)

    ASSERT( SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_BUILT_IN_DOMAIN_POSIX_OFFSET ) );
    ASSERT( SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_ACCOUNT_DOMAIN_POSIX_OFFSET ) );
    ASSERT( SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET == LdapSwapBits( SE_PRIMARY_DOMAIN_POSIX_OFFSET ) );

    TargetSwappedPosixOffset = 1;
    for ( i=0; i<SwappedPosixOffsetCount; i++ ) {

        //
        // If the target is free,
        //  we've found the free Posix Offset.
        //

        if ( SwappedPosixOffsets[i] > TargetSwappedPosixOffset ) {
            break;

        //
        // If the current entry is the target,
        //  move the target.
        //

        } else if ( SwappedPosixOffsets[i] == TargetSwappedPosixOffset ) {

            //
            // Loop avoiding well known Posix Offsets.
            //
            while ( TRUE ) {
                TargetSwappedPosixOffset++;

                if ( TargetSwappedPosixOffset != SE_PRIMARY_DOMAIN_SWAPPED_POSIX_OFFSET &&
                     TargetSwappedPosixOffset != SE_ACCOUNT_DOMAIN_SWAPPED_POSIX_OFFSET &&
                     TargetSwappedPosixOffset != SE_BUILT_IN_DOMAIN_SWAPPED_POSIX_OFFSET ) {
                    break;
                }
            }
        }

    }

    //
    // Return the first free Posix Offset to the caller.
    //

    *PosixOffset = LdapSwapBits( TargetSwappedPosixOffset );
    Status = STATUS_SUCCESS;

Cleanup:

    if ( SwappedPosixOffsets != NULL ) {
        LsapFreeLsaHeap( SwappedPosixOffsets );
    }

    return Status;

}


NTSTATUS
LsapDbBuildTrustedDomainCache(
    )

/*++

Routine Description:

    This function initializes a Trusted Domain List by enumerating all
    of the Trusted Domain objects in the specified target system's
    Policy Database.  For a Windows Nt system (Workstation) the list
    contains only the Primary Domain.  For a LanManNt system (DC), the
    list contains zero or more Trusted Domain objects.  Note that the
    list contains only those domains for which Trusted Domain objects
    exist in the local LSA Policy Database.  If for example, a DC
    trusted Domain A which in turn trusts Domain B, the list will not
    contain an entry for Domain B unless there is a direct relationship.

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS EnumerationStatus = STATUS_SUCCESS;
    LSAPR_TRUSTED_ENUM_BUFFER TrustedDomains;
    ULONG EnumerationContext = 0, i;
    BOOLEAN LookupDs = LsapDsWriteDs;
    BOOLEAN CloseTransaction = FALSE;

    LsapEnterFunc( "LsapDbBuildTrustedDomainCache" );

    ASSERT( LsapDbIsLockedTrustedDomainList());
    ASSERT( !LsapDbIsValidTrustedDomainList());

    //
    // Verify input parameters
    //

    if ( LsapDsWriteDs ) {

        Status = LsapDsInitAllocAsNeededEx(
                     LSAP_DB_DS_OP_TRANSACTION |
                        LSAP_DB_NO_LOCK,
                     TrustedDomainObject,
                     &CloseTransaction
                     );

        if ( !NT_SUCCESS( Status ) ) {

            return Status;
        }
    }

    LsapDbMakeCacheBuilding( TrustedDomainObject );

    //
    // Initialize the Trusted Domain List to the empty state.
    //

    LsapDbPurgeTrustedDomainCache();

    //
    // DCs in the root domain must not allow other forests to claim SIDs
    // and namespaces that conflict with their own forest
    // For that, the information about the current forest is inserted
    // into the forest trust cache as just another (though special) entry
    //

    if ( LsapDbDcInRootDomain()) {

        Status = LsapForestTrustInsertLocalInfo();

        if ( !NT_SUCCESS( Status )) {

            goto BuildTrustedDomainListError;
        }
    }

    //
    // Loop round, enumerating groups of Trusted Domain objects.
    //

    do {

        //
        // Enumerate the next group of Trusted Domains
        //

        if ( LookupDs ) {

            EnumerationStatus = Status = LsapDsEnumerateTrustedDomainsEx(
                                             &EnumerationContext,
                                             TrustedDomainFullInformation2Internal,
                                             (PLSAPR_TRUSTED_DOMAIN_INFO *)&(TrustedDomains.Information),
                                             LSAP_DB_ENUM_DOMAIN_LENGTH * 100,
                                             &TrustedDomains.EntriesRead,
                                             LSAP_DB_ENUMERATE_NO_OPTIONS
                                             );

        } else {

            EnumerationStatus = Status = LsapDbSlowEnumerateTrustedDomains(
                                             LsapPolicyHandle,
                                             &EnumerationContext,
                                             TrustedDomainInformationEx2Internal,
                                             &TrustedDomains,
                                             LSAP_DB_ENUM_DOMAIN_LENGTH
                                             );
        }

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_NO_MORE_ENTRIES) {

                break;
            }

            Status = STATUS_SUCCESS;
        }

        //
        // If the number of entries returned was zero, quit.
        //

        if (TrustedDomains.EntriesRead == (ULONG) 0) {

            break;
        }

        //
        // Otherwise, add them to our list
        //
        for ( i = 0; i < TrustedDomains.EntriesRead && NT_SUCCESS( Status ); i++ ) {
            PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2 TrustInfoEx2;
            ULONG PosixOffset;

            if ( LookupDs ) {
                PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2 TrustFullInfo2;
                TrustFullInfo2 = &((PLSAPR_TRUSTED_DOMAIN_FULL_INFORMATION2)TrustedDomains.Information)[i];
                TrustInfoEx2 = &TrustFullInfo2->Information;
                PosixOffset = TrustFullInfo2->PosixOffset.Offset;
            } else {
                TrustInfoEx2 = &((PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX2)TrustedDomains.Information)[i];

                //
                // This is only used during upgrade.  This Posix Offset will be recomputed.
                PosixOffset = 0;
            }

            //
            // Now, add it to the list
            //
            Status = LsapDbInsertTrustedDomainList(
                         TrustInfoEx2,
                         PosixOffset
                         );
        }


    } while ( NT_SUCCESS( Status ) && EnumerationStatus != STATUS_NO_MORE_ENTRIES );



    if (!NT_SUCCESS(Status)) {

        //
        // If STATUS_NO_MORE_ENTRIES was returned, there are no more
        // trusted domains.  Discard this status.
        //

        if (Status != STATUS_NO_MORE_ENTRIES) {

            goto BuildTrustedDomainListError;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Mark the Trusted Domain List as valid.
    //

    LsapDbMakeCacheValid( TrustedDomainObject );

    if ( LsapDbDcInRootDomain()) {

        LsapForestTrustCacheSetValid();

    } else if ( SamIAmIGC()) {

        LsapRebuildFtCacheGC();
    }

BuildTrustedDomainListFinish:

    if ( LsapDsWriteDs ) {

        LsapDsDeleteAllocAsNeededEx(
            LSAP_DB_DS_OP_TRANSACTION |
               LSAP_DB_NO_LOCK,
            TrustedDomainObject,
            CloseTransaction
            );
    }

    LsapExitFunc( "LsapEnumerateTrustedDomainsEx", Status );

    return(Status);

BuildTrustedDomainListError:

    LsapDbMakeCacheInvalid( TrustedDomainObject );
    LsapDbPurgeTrustedDomainCache();

    goto BuildTrustedDomainListFinish;
}


VOID
LsapDbPurgeTrustedDomainCache(
    )

/*++

Routine Description:

    This function is the opposite of LsapDbBuildTrustedDomainCache().

Arguments:

    None

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

--*/

{
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY Current;

    //
    // Caller must already have the trusted domain list locked
    // Convert the read lock to exclusive to be sure
    //

    ASSERT( LsapDbIsLockedTrustedDomainList());

    //
    // Purge the forest trust cache
    //

    LsapForestTrustCacheSetInvalid();

    while( !IsListEmpty( &LsapDbTrustedDomainList.ListHead ) ) {

        Current = CONTAINING_RECORD( LsapDbTrustedDomainList.ListHead.Flink,
                                     LSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY, NextEntry );

        RemoveEntryList( &Current->NextEntry );
        LsapDbTrustedDomainList.TrustedDomainCount--;

        _fgu__LSAPR_TRUSTED_DOMAIN_INFO( ( PLSAPR_TRUSTED_DOMAIN_INFO )&Current->TrustInfoEx,
                                         TrustedDomainInformationEx );

        MIDL_user_free( Current );
    }

    //
    // Initialize the Trusted Domain List to the empty state.
    //

    InitializeListHead( &LsapDbTrustedDomainList.ListHead );
    LsapDbTrustedDomainList.TrustedDomainCount = 0;
    LsapDbTrustedDomainList.CurrentSequenceNumber = 0;

    if ( !LsapDbIsCacheBuilding( TrustedDomainObject )) {

        LsapDbMakeCacheInvalid( TrustedDomainObject );
    }

    return;
}

#ifdef DBG // this is a macro in FRE builds

BOOLEAN
LsapDbIsValidTrustedDomainList(
    )

/*++

Routine Description:

    This function checks if the Trusted Domain List is valid.

Arguments:

    None

Return Values:

    BOOLEAN - TRUE if the list is valid, else FALSE

--*/

{
    ASSERT( LsapDbIsLockedTrustedDomainList());

    return( LsapDbIsCacheValid( TrustedDomainObject ) ||
             LsapDbIsCacheBuilding( TrustedDomainObject ));
}
#endif


NTSTATUS
LsarEnumerateTrustedDomainsEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAPR_TRUSTED_ENUM_BUFFER_EX TrustedDomainInformation,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    EnumerationBuffer - Pointer to an enumeration structure that will receive
        a count of the Trusted Domains enumerated on this call and a pointer to
        an array of entries containing information for each enumerated
        Trusted Domain.

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.
            Some entries may have been returned.
            The caller need not call again.

        STATUS_MORE_ENTRIES - The call completed successfully.
            Some entries have been returned.  The caller should call again to
            get additional entries.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status;
    ULONG Items = 0;
    PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomInfo;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_EnumerateTrustedDomainsEx);

    Status = LsapEnumerateTrustedDomainsEx( PolicyHandle,
                                                EnumerationContext,
                                                TrustedDomainInformationEx,
                                                &TrustedDomInfo,
                                                PreferedMaximumLength,
                                                &Items,
                                                LSAP_DB_ENUMERATE_NO_OPTIONS |
                                                    LSAP_DB_ENUMERATE_NULL_SIDS );


    if ( NT_SUCCESS( Status ) || Status == STATUS_NO_MORE_ENTRIES ) {

        TrustedDomainInformation->EntriesRead = Items;
        TrustedDomainInformation->EnumerationBuffer =
                                            (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX)TrustedDomInfo;
    }


    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_EnumerateTrustedDomainsEx);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsapEnumerateTrustedDomainsEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned,
    IN ULONG EnumerationFlags
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaEnumerateTrustedDomains API.

    The LsaEnumerateTrustedDomains API returns information about
    TrustedDomain objects.  This call requires POLICY_VIEW_LOCAL_INFORMATION
    access to the Policy object.  Since there may be more information than
    can be returned in a single call of the routine, multiple calls can be
    made to get all of the information.  To support this feature, the caller
    is provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a variable that has
    been initialized to 0.  On each subsequent call, the value returned by
    the preceding call should be passed in unchanged.  The enumeration is
    complete when the warning STATUS_NO_MORE_ENTRIES is returned.

Arguments:

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    InfoClass - The class of information to return
        Must be TrustedDomainInformationEx or TrustedDomainInformatinBasic

    TrustedDomainInformation - Returns a pointer to an array of entries
        containing information for each enumerated Trusted Domain.

        Free using LsapFreeTrustedDomainsEx()

    PreferedMaximumLength - Prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Number of elements returned in TrustedDomainInformation

    EnumerationFlags -- Controls how the enumeration is done.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if no objects have been enumerated because the
            EnumerationContext value is too high.

--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG MaxLength, i;
    BOOLEAN ObjectReferenced = FALSE, CloseTransaction = FALSE;

    LsapEnterFunc( "LsapEnumerateTrustedDomainsEx" );

    ASSERT( InfoClass == TrustedDomainInformationEx ||
            InfoClass == TrustedDomainInformationBasic );
    *TrustedDomainInformation = NULL;
    *CountReturned = 0;

    //
    // If no Enumeration Structure is provided, return an error.
    //

    if ( !ARGUMENT_PRESENT(TrustedDomainInformation) ||
                                    !ARGUMENT_PRESENT( EnumerationContext ) ) {

        LsapExitFunc( "LsapEnumerateTrustedDomainsEx", STATUS_INVALID_PARAMETER );
        return( STATUS_INVALID_PARAMETER );

    }

    //
    // Acquire the Lsa Database lock.  Verify that the connection handle is
    // valid, is of the expected type and has all of the desired accesses
    // granted.  Reference the handle.
    //

    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 POLICY_VIEW_LOCAL_INFORMATION,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK |
                   LSAP_DB_READ_ONLY_TRANSACTION |
                   LSAP_DB_DS_OP_TRANSACTION );

    if ( NT_SUCCESS( Status ) ) {

        ObjectReferenced = TRUE;


       //
       // Limit the enumeration length except for trusted callers
       //

       if ( !((LSAP_DB_HANDLE)PolicyHandle)->Trusted   &&
                   (PreferedMaximumLength > LSA_MAXIMUM_ENUMERATION_LENGTH) ) {

            MaxLength = LSA_MAXIMUM_ENUMERATION_LENGTH;

        } else {

            MaxLength = PreferedMaximumLength;

        }


        //
        // If the data is cached,
        //  use the cache.
        //

        if (LsapDbIsCacheValid(TrustedDomainObject)) {
            LSAPR_TRUSTED_ENUM_BUFFER CacheEnum;

            Status = LsapDbEnumerateTrustedDomainList(
                            EnumerationContext,
                            &CacheEnum,
                            PreferedMaximumLength,
                            InfoClass,
                            (BOOLEAN)(FLAG_ON( EnumerationFlags, LSAP_DB_ENUMERATE_NULL_SIDS ) ?
                                TRUE :
                                FALSE) );

            if ( NT_SUCCESS( Status ) ) {
                *CountReturned = CacheEnum.EntriesRead;
                *TrustedDomainInformation = ( PLSAPR_TRUSTED_DOMAIN_INFO )CacheEnum.Information;
            }

        //
        // If the data is in the registry,
        //  enumerate it from there.
        //
        } else if ( !LsapDsWriteDs ) {
            LSAPR_TRUSTED_ENUM_BUFFER RegEnum;

            //
            // Use slow method of enumeration, by accessing backing storage.
            // Later, we'll implement rebuilding of the cache.

            Status = LsapDbSlowEnumerateTrustedDomains(
                         PolicyHandle,
                         EnumerationContext,
                         InfoClass,
                         &RegEnum,
                         PreferedMaximumLength );

            if ( NT_SUCCESS( Status ) ) {
                *CountReturned = RegEnum.EntriesRead;
                *TrustedDomainInformation = ( PLSAPR_TRUSTED_DOMAIN_INFO )RegEnum.Information;
            }

        //
        // If the data is in the DS,
        //  enumerate it from there.
        //
        } else {

            //
            // LsapDsEnumerateTrustedDomainsEx increments the EnumerationContext as necessary
            //
            Status = LsapDsEnumerateTrustedDomainsEx( EnumerationContext,
                                                      InfoClass,
                                                      TrustedDomainInformation,
                                                      MaxLength,
                                                      CountReturned,
                                                      EnumerationFlags );
        }

    }

    if ( ObjectReferenced == TRUE ) {

        //
        // Don't lose the results of the Enumeration
        //
        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_LOCK |
                                 LSAP_DB_READ_ONLY_TRANSACTION |
                                 LSAP_DB_DS_OP_TRANSACTION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

    }

    //
    // Deallocate any memory if we failed
    //
    if ( !NT_SUCCESS( Status ) && Status != STATUS_NO_MORE_ENTRIES ) {

        //
        // Free it up.
        //
        LsapFreeTrustedDomainsEx( InfoClass,
                                  *TrustedDomainInformation,
                                  *CountReturned );

        *TrustedDomainInformation = NULL;
        *CountReturned = 0;
    }

    //
    // Map the status into what LsarEnumerateTrustedDomains normally returns...
    //
    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {
        Status = STATUS_NO_MORE_ENTRIES;
    }


    LsapExitFunc( "LsapEnumerateTrustedDomainsEx", Status );

    return( Status );
}

VOID
LsapFreeTrustedDomainsEx(
    IN TRUSTED_INFORMATION_CLASS InfoClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation,
    IN ULONG TrustedDomainCount
    )

/*++

Routine Description:

    This function frees a buffer returned from LsapEnumerateTrustedDomainsEx

Arguments:

    InfoClass - The class of information in the buffer.
        Must be TrustedDomainInformationEx or TrustedDomainInformatinBasic

    TrustedDomainInformation - A pointer to an array of entries
        containing information for each enumerated Trusted Domain.

    TrustedDomainCount - Number of elements in TrustedDomainInformation

Return Values:

    None.

--*/

{
    switch ( InfoClass ) {
    case TrustedDomainInformationEx:
        {
            LSAPR_TRUSTED_ENUM_BUFFER_EX TrustedDomainInfoEx;


            TrustedDomainInfoEx.EntriesRead = TrustedDomainCount;
            TrustedDomainInfoEx.EnumerationBuffer =
                (PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX) TrustedDomainInformation;

            _fgs__LSAPR_TRUSTED_ENUM_BUFFER_EX( &TrustedDomainInfoEx );
            break;
        }

    case TrustedDomainInformationBasic:
        {
            LSAPR_TRUSTED_ENUM_BUFFER TrustedDomainInfoBasic;


            TrustedDomainInfoBasic.EntriesRead = TrustedDomainCount;
            TrustedDomainInfoBasic.Information =
                (PLSAPR_TRUSTED_DOMAIN_INFORMATION_BASIC) TrustedDomainInformation;

            _fgs__LSAPR_TRUSTED_ENUM_BUFFER( &TrustedDomainInfoBasic );
            break;
        }
    default:
        ASSERT( FALSE );
        break;
    }
}



NTSTATUS
LsarQueryTrustedDomainInfoByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    OUT PLSAPR_TRUSTED_DOMAIN_INFO *TrustedDomainInformation
    )

/*++

Routine Description:

    This function is the LSA server RPC worker routine for the
    LsaQueryInfoTrustedDomain API.

    The LsaQueryInfoTrustedDomain API obtains information from a
    TrustedDomain object.  The caller must have access appropriate to the
    information being requested (see InformationClass parameter).

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    InformationClass - Specifies the information to be returned.  The
        Information Classes and accesses required are  as follows:

        Information Class                 Required Access Type

        TrustedDomainNameInformation      TRUSTED_QUERY_DOMAIN_NAME
        TrustedControllersInformation     TRUSTED_QUERY_CONTROLLERS
        TrustedPosixOffsetInformation     TRUSTED_QUERY_POSIX

    Buffer - Receives a pointer to the buffer returned comtaining the
        requested information.  This buffer is allocated by this service
        and must be freed when no longer needed by passing the returned
        value to LsaFreeMemory().

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate
            access to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources,
            such as memory, to complete the call.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle;
    BOOLEAN ObjectReferenced = FALSE;
    PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY TrustInfoForName;
    PUNICODE_STRING ActualTDName = ( PUNICODE_STRING )TrustedDomainName;
    ACCESS_MASK DesiredAccess;
    BOOLEAN AcquiredTrustedDomainListReadLock = FALSE;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarQueryTrustedDomainInfoByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_QueryTrustedDomainInfoByName);

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( TrustedDomainName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto GetInfoByNameError;
    }

    //
    // Validate the Information Class and determine the access required to
    // query this Trusted Domain Information Class.
    //

    Status = LsapDbVerifyInfoQueryTrustedDomain(
                 InformationClass,
                 (BOOLEAN)(((LSAP_DB_HANDLE)PolicyHandle)->Options & LSAP_DB_TRUSTED),
                 &DesiredAccess );

    if (!NT_SUCCESS(Status)) {

        goto GetInfoByNameError;
    }




    Status = LsapDbReferenceObject( PolicyHandle,
                                    0,
                                    PolicyObject,
                                    TrustedDomainObject,
                                    LSAP_DB_LOCK |
                                        LSAP_DB_READ_ONLY_TRANSACTION   |
                                        LSAP_DB_DS_OP_TRANSACTION );


    if ( NT_SUCCESS( Status ) ) {

        ObjectReferenced = TRUE;


        //
        // Acquire the Read Lock for the Trusted Domain List
        //

        Status = LsapDbAcquireReadLockTrustedDomainList();

        if (!NT_SUCCESS(Status)) {
            goto GetInfoByNameError;
        }

        AcquiredTrustedDomainListReadLock = TRUE;

        //
        // Get the right name
        //
        Status = LsapDbLookupNameTrustedDomainListEx( TrustedDomainName,
                                                      &TrustInfoForName );

        if ( NT_SUCCESS( Status ) ) {

            ActualTDName = ( PUNICODE_STRING )&TrustInfoForName->TrustInfoEx.Name;

        } else {

            LsapDsDebugOut(( DEB_ERROR,
                         "No trust entry found for %wZ: 0x%lx\n",
                         ( PUNICODE_STRING )TrustedDomainName,
                         Status ));
            Status = STATUS_SUCCESS;
        }

        //
        // Build a temporary handle
        //
        RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
        ObjInfo.ObjectTypeId = TrustedDomainObject;
        ObjInfo.ContainerTypeId = 0;
        ObjInfo.Sid = NULL;
        ObjInfo.DesiredObjectAccess = DesiredAccess;

        InitializeObjectAttributes( &ObjInfo.ObjectAttributes,
                                    ActualTDName,
                                    0L,
                                    PolicyHandle,
                                    NULL );


        //
        // Get a handle to the TDO
        //

        Status = LsapDbOpenObject( &ObjInfo,
                                   DesiredAccess,
                                   0,
                                   &TrustedDomainHandle );

        if ( AcquiredTrustedDomainListReadLock ) {
            LsapDbReleaseLockTrustedDomainList();
            AcquiredTrustedDomainListReadLock = FALSE;
        }


        if ( NT_SUCCESS( Status ) ) {

            Status = LsarQueryInfoTrustedDomain( TrustedDomainHandle,
                                                 InformationClass,
                                                 TrustedDomainInformation );

            LsapDbCloseObject( &TrustedDomainHandle,
                               0,
                               Status );
        }

    }


    //
    // If we got a DNS name to lookup and it wasn't found and it was an absolute DNS name
    // try hacking off the trailing period and trying it again...
    //
    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( TrustedDomainName->Length == 0 || TrustedDomainName->Buffer == NULL ) {

            goto GetInfoByNameError;
        }

        if ( TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] =
                                                                                     UNICODE_NULL;
            TrustedDomainName->Length -= sizeof(WCHAR);

            if ( TrustedDomainName->Length > 0 &&
                 TrustedDomainName->Buffer[ ( TrustedDomainName->Length - 1) / sizeof(WCHAR)] !=
                                                                                             L'.') {

                LsapDsDebugOut(( DEB_WARN,
                                 "GetTrustedDomainInfoByName tried with absolute DNS name.  "
                                 "Retrying with %wZ\n",
                                 TrustedDomainName ));

                Status = LsarQueryTrustedDomainInfoByName( PolicyHandle,
                                                           TrustedDomainName,
                                                           InformationClass,
                                                           TrustedDomainInformation );

            }

        }
    }

GetInfoByNameError:
    if ( AcquiredTrustedDomainListReadLock ) {
        LsapDbReleaseLockTrustedDomainList();
    }

    //
    // Dereference the object
    //
    if ( ObjectReferenced ) {

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_LOCK |
                                LSAP_DB_READ_ONLY_TRANSACTION   |
                                LSAP_DB_DS_OP_TRANSACTION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status );


    }



    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_QueryTrustedDomainInfoByName);
    LsapExitFunc( "LsarQueryTrustedDomainInfoByName", Status );
    LsarpReturnPrologue();


    return( Status );
}



NTSTATUS
LsarSetTrustedDomainInfoByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN TRUSTED_INFORMATION_CLASS InformationClass,
    IN PLSAPR_TRUSTED_DOMAIN_INFO TrustedDomainInformation)
{
    NTSTATUS Status, SecondaryStatus;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    LSAPR_HANDLE TrustedDomainHandle;
    ACCESS_MASK DesiredAccess;


    LsarpReturnCheckSetup();
    LsapEnterFunc( "LsarSetTrustedDomainInfoByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_SetTrustedDomainInfoByName);

    //
    // Validate the input buffer
    //
    if ( !LsapValidateLsaUnicodeString( TrustedDomainName ) ) {

        Status = STATUS_INVALID_PARAMETER;
        goto SetInfoByNameError;
    }

    //
    // Validate the Information Class and Trusted Domain Information provided and
    // if valid, return the mask of accesses required to update this
    // class of Trusted Domain information.
    //

    Status = LsapDbVerifyInfoSetTrustedDomain(
                 InformationClass,
                 TrustedDomainInformation,
                 (BOOLEAN)(((LSAP_DB_HANDLE)PolicyHandle)->Options & LSAP_DB_TRUSTED),
                 &DesiredAccess );

    if (!NT_SUCCESS(Status)) {

        goto SetInfoByNameError;
    }


    //
    // Build a temporary handle
    //
    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = 0;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = DesiredAccess;

    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        (UNICODE_STRING *)TrustedDomainName,
        0L,
        PolicyHandle,
        NULL
        );


    Status = LsapDbReferenceObject(
                 PolicyHandle,
                 0,
                 PolicyObject,
                 TrustedDomainObject,
                 LSAP_DB_LOCK
                 );

    if ( NT_SUCCESS( Status ) ) {

        //
        // Get a handle to the TDO
        //

        Status = LsapDbOpenObject( &ObjInfo,
                                   DesiredAccess,
                                   0,
                                   &TrustedDomainHandle );

        //
        // Unlock the lock.
        //
        // We can't enter LsarSetInformationTrustedDomain with any locks locked since
        //  it goes out of process to get the session key.
        //
        // We can't dereference the PolicyHandle since this reference also
        //  serves as the ContainerHandle reference.
        //

        LsapDbReleaseLockEx( TrustedDomainObject,
                             0 );

        //
        // Set the info on the TDO.
        //

        if ( NT_SUCCESS( Status ) ) {

            Status = LsarSetInformationTrustedDomain(
                         TrustedDomainHandle,
                         InformationClass,
                         TrustedDomainInformation );

            LsapDbCloseObject( &TrustedDomainHandle,
                               0,
                               Status );
        }


        //
        // Dereference the object.
        //

        SecondaryStatus = LsapDbDereferenceObject(
                              &PolicyHandle,
                              PolicyObject,
                              TrustedDomainObject,
                              LSAP_DB_OMIT_REPLICATOR_NOTIFICATION,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

        LsapDbSetStatusFromSecondary( Status, SecondaryStatus );

    }

    //
    // If we got a DNS name to lookup and it wasn't found and it was an absolute DNS name
    // try hacking off the trailing period and trying it again...
    //
    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND ) {

        if ( TrustedDomainName->Length == 0 || TrustedDomainName->Buffer == NULL ) {

            goto SetInfoByNameError;
        }

        if ( TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] == L'.' ) {

            TrustedDomainName->Buffer[ (TrustedDomainName->Length - 1) / sizeof(WCHAR)] =
                                                                                     UNICODE_NULL;
            TrustedDomainName->Length -= sizeof(WCHAR);

            if ( TrustedDomainName->Length > 0 &&
                 TrustedDomainName->Buffer[ ( TrustedDomainName->Length - 1) / sizeof(WCHAR)] !=
                                                                                             L'.') {

                LsapDsDebugOut(( DEB_WARN,
                                 "SetTrustedDomainInfoByName tried with absolute DNS name.  "
                                 "Retrying with %wZ\n",
                                 TrustedDomainName ));

                Status = LsarSetTrustedDomainInfoByName( PolicyHandle,
                                                         TrustedDomainName,
                                                         InformationClass,
                                                         TrustedDomainInformation );

            }

        }
    }

SetInfoByNameError:
    LsapExitFunc( "LsarSetTrustedDomainInfoByName", Status );
    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_SetTrustedDomainInfoByName);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsarCreateTrustedDomainEx(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaCreateTrustedDomainEx function creates a new TrustedDomain object.

Arguments:

    PolicyHandle - Handle from an LsaOpenPolicy call.

    TrustedDomainInformation - Pointer to a TRUSTED_DOMAIN_INFORMATION_EX structure
        containing the name and SID of the new trusted domain.

    AuthenticationInformation - Pointer to a TRUSTED_DOMAIN_AUTH_INFORMATION
        structure containing authentication information for the new trusted domain.

    DesiredAccess  - An ACCESS_MASK structure that specifies the accesses to
        be granted for the new trusted domain.

    TrustedDomainHandle  - Receives the LSA policy handle of the remote
        trusted domain. You can use pass this handle into LSA function calls
        in order to query and/or manage the LSA policy of the remote machine.

        When your application no longer needs this handle, it should call
        LsaClose to delete the handle.


Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_CreateTrustedDomainEx);

    //
    // Former LSA implementations didn't enforce TRUSTED_SET_AUTH.
    //  So some callers were lured into a false sense of security and didn't
    //  ask for it.  Ask here.
    //

    DesiredAccess |= TRUSTED_SET_AUTH;

    //
    // There's a bug in the definition LSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION where
    //  it doesn't allow more than one auth info to be passed over the wire.
    //  So, short circuit it here.
    //
    // We could let trusted callers thru, but we haven't validated the handle yet.
    //

    if ( AuthenticationInformation->IncomingAuthInfos > 1 ||
         AuthenticationInformation->OutgoingAuthInfos > 1 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Call the worker routine to do the job.
    //

    Status = LsapCreateTrustedDomain2( PolicyHandle,
                                       TrustedDomainInformation,
                                       AuthenticationInformation,
                                       DesiredAccess,
                                       TrustedDomainHandle );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_CreateTrustedDomainEx);
    LsarpReturnPrologue();

    return( Status );
}

NTSTATUS
LsarCreateTrustedDomainEx2(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_TRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    IN PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION_INTERNAL AuthenticationInformation,
    IN ACCESS_MASK DesiredAccess,
    OUT LSAPR_HANDLE *TrustedDomainHandle
    )

/*++

Routine Description:

    Same as LsarCreateTrustedDomainEx except the AuthenticationInformation is
        encrypted on the wire.

Arguments:

    Same as LsarCreateTrustedDomainEx except the AuthenticationInformation is
        encrypted on the wire.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/
{
    NTSTATUS Status;
    TRUSTED_DOMAIN_AUTH_INFORMATION DecryptedTrustedDomainAuthInfo;
    PLSAP_CR_CIPHER_KEY SessionKey = NULL;

    LsarpReturnCheckSetup();
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_CreateTrustedDomainEx);
    RtlZeroMemory( &DecryptedTrustedDomainAuthInfo, sizeof(DecryptedTrustedDomainAuthInfo) );

    //
    // Get the session key.
    //

    Status = LsapCrServerGetSessionKeySafe( PolicyHandle,
                                            PolicyObject,
                                            &SessionKey );

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }


    //
    // Build a decrypted Auth Info structure.
    //

    Status = LsapDecryptAuthDataWithSessionKey(
                        SessionKey,
                        AuthenticationInformation,
                        &DecryptedTrustedDomainAuthInfo );

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    //
    // Former LSA implementations didn't enforce TRUSTED_SET_AUTH.
    //  So some callers were lured into a false sense of security and didn't
    //  ask for it.  Ask here.
    //

    DesiredAccess |= TRUSTED_SET_AUTH;

    //
    // Call the worker routine to do the job.
    //

    Status = LsapCreateTrustedDomain2( PolicyHandle,
                                       TrustedDomainInformation,
                                       (PLSAPR_TRUSTED_DOMAIN_AUTH_INFORMATION)&DecryptedTrustedDomainAuthInfo,
                                       DesiredAccess,
                                       TrustedDomainHandle );

Cleanup:

    if ( SessionKey != NULL ) {
        MIDL_user_free( SessionKey );
    }

    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, TRUE ) );
    LsapDsFreeUnmarshalAuthInfoHalf( LsapDsAuthHalfFromAuthInfo( &DecryptedTrustedDomainAuthInfo, FALSE ) );

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_CreateTrustedDomainEx);
    LsarpReturnPrologue();

    return( Status );
}


NTSTATUS
LsapDbOpenTrustedDomainByName(
    IN OPTIONAL LSAPR_HANDLE PolicyHandle,
    IN PUNICODE_STRING TrustedDomainName,
    OUT PLSAPR_HANDLE TrustedDomainHandle,
    IN ULONG AccessMask,
    IN ULONG Options,
    IN BOOLEAN Trusted
    )
/*++

Routine Description:

    This function opens a Trusted Domain Object by the name.  This name can be either the
    DomainName or FlatName
Arguments:

    PolicyHandle - Policy handle.
        If NULL, the LSA's global policy handle will be used.

    TrustedDomainName - Pointer to the domains name

    TrustedDomainHandle - Receives a handle to be used in future requests.

    AccessMask - Access mask to open the object with

    Options - Specifies option flags

        LSAP_DB_LOCK - Acquire the Lsa Database lock for the
           duration of the open operation.

        LSAP_DB_START_TRANSACTION -- Begin a transaction before access the database
            Ignored if LSAP_DB_LOCK isn't specified.

    Trusted - If TRUE, the open request is coming from a trusted client

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_OBJECT_NAME_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified Name.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PDSNAME FoundTrustObject = NULL;
    LSAP_DB_OBJECT_INFORMATION ObjInfo;
    UNICODE_STRING ObjectName;
    BOOLEAN DbLocked = FALSE;
    BOOLEAN HandleReferenced = FALSE;
    ULONG DereferenceOptions = 0, ReferenceOptions = 0, i;
    LSAPR_HANDLE PolicyHandleToUse;

    LsapEnterFunc( "LsapDbOpenTrustedDomainByName" );

    if ((NULL==TrustedDomainName) || (NULL==TrustedDomainName->Buffer))
    {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validate the Policy Handle
    //
    // Don't both verifying the global handle (it's fine).
    // Increment the reference count.  We'll be using this reference as the ContainerHandle on
    //  the open trusted domain handle.
    //
    // This mechanism for ref counting the ContainerHandle is bogus throughout the code.
    // The code that does the reference (LsapDbCreateHandle) to the ContainerHandle should
    // increment the ref count.  The code that removes the reference (???) should decrement
    // the ref count.
    //

    if ( PolicyHandle == NULL ) {
        PolicyHandleToUse = LsapPolicyHandle;

    } else {
        PolicyHandleToUse = PolicyHandle;

        Status =  LsapDbVerifyHandle( PolicyHandle, 0, PolicyObject, TRUE );

        if (!NT_SUCCESS(Status)) {
            goto Cleanup;
        }

        HandleReferenced = TRUE;
    }

    //
    // Do our opens as needed
    //
    if ( FLAG_ON( Options, LSAP_DB_LOCK ) ) {

        ReferenceOptions |= LSAP_DB_LOCK;
        DereferenceOptions |= LSAP_DB_LOCK;

        if ( FLAG_ON( Options, LSAP_DB_START_TRANSACTION ) ) {

            ReferenceOptions |= LSAP_DB_START_TRANSACTION;
            DereferenceOptions |= LSAP_DB_FINISH_TRANSACTION;
        }


        Status = LsapDbReferenceObject( PolicyHandleToUse,
                                        (ACCESS_MASK) 0,
                                        PolicyObject,
                                        TrustedDomainObject,
                                        Trusted ? ReferenceOptions | LSAP_DB_TRUSTED :
                                                  ReferenceOptions );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        DbLocked = TRUE;
    }

    RtlZeroMemory( &ObjInfo, sizeof( ObjInfo ) );
    ObjInfo.ObjectTypeId = TrustedDomainObject;
    ObjInfo.ContainerTypeId = PolicyObject;
    ObjInfo.Sid = NULL;
    ObjInfo.DesiredObjectAccess = AccessMask;


    InitializeObjectAttributes(
        &ObjInfo.ObjectAttributes,
        TrustedDomainName,
        OBJ_CASE_INSENSITIVE,
        PolicyHandle,   // If NULL, we simply won't have a container handle.
        NULL
        );



    Status = LsapDbOpenObject( &ObjInfo,
                             AccessMask,
                             Trusted ? LSAP_DB_TRUSTED : 0,
                             TrustedDomainHandle );


Cleanup:
    if (DbLocked) {


         Status = LsapDbDereferenceObject(
                              &PolicyHandleToUse,
                              PolicyObject,
                              TrustedDomainObject,
                              DereferenceOptions,
                              (SECURITY_DB_DELTA_TYPE) 0,
                              Status
                              );

    }


    if ( !NT_SUCCESS(Status) ) {
        //
        // On Success, the reference to the Policy object is used as the ContainerHandle reference.
        //
        if ( HandleReferenced ) {
            LsapDbDereferenceHandle( PolicyHandle );
        }
    }


    LsapExitFunc( "LsapDbOpenTrustedDomainByName", Status );

    return( Status );
}




NTSTATUS
LsarOpenTrustedDomainByName(
    IN LSAPR_HANDLE PolicyHandle,
    IN PLSAPR_UNICODE_STRING TrustedDomainName,
    IN ACCESS_MASK DesiredAccess,
    OUT PLSAPR_HANDLE TrustedDomainHandle
    )

/*++

Routine Description:

    The LsaOpenTrustedDomain API opens an existing TrustedDomain object
    using the SID as the primary key value.

Arguments:

    PolicyHandle - An open handle to a Policy object.

    TrustedDomainName - Name of the trusted domain object

    DesiredAccess - This is an access mask indicating accesses being
        requested to the target object.

    TrustedDomainHandle - Receives a handle to be used in future requests.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_TRUSTED_DOMAIN_NOT_FOUND - There is no TrustedDomain object in the
            target system's LSA Database having the specified TrustedDomainName

--*/

{
    NTSTATUS Status;

    LsarpReturnCheckSetup();

    LsapEnterFunc( "LsarOpenTrustedDomainByName" );
    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_OpenTrustedDomainByName);

    //
    // Call the internal routine.  Caller is not trusted and the Database
    // lock needs to be acquired.
    //
    Status = LsapDbOpenTrustedDomainByName( PolicyHandle,
                                            (PUNICODE_STRING)TrustedDomainName,
                                            TrustedDomainHandle,
                                            DesiredAccess,
                                            LSAP_DB_LOCK,
                                            FALSE );    // Untrusted

    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_OpenTrustedDomainByName);
    LsapExitFunc( "LsarOpenTrustedDomainByName", Status );
    LsarpReturnPrologue();

    return(Status);
}

NTSTATUS
LsapSidOnFtInfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PSID Sid
    )

/*++

Routine description:

    Determines whether the specified SID is on the FTINFO structure for the specified
    TDO.

Arguments:

    TrustedDomainName - Netbios name or DNS name of the trusted domain.

    Sid - SID to test

Return values:

    STATUS_SUCCESS              Match was found - SID is on the FTINFO

    STATUS_NO_MATCH             Match was not found - SID is not on the FTINFO

    STATUS_INVALID_DOMAIN_STATE Machine must be a GC or a DC in the root domain

    STATUS_INVALID_PARAMETER    Check the inputs

    STATUS_INTERNAL_ERROR       Cache is internally inconsistent

    STATUS_INSUFFICIENT_RESOURCES  Out of memory
--*/

{
    NTSTATUS Status;
    UNICODE_STRING MatchingDomain;

    //
    // Find the TDO that maps to this SID.
    //

    RtlInitUnicodeString( &MatchingDomain, NULL );

    Status = LsaIForestTrustFindMatch(
                    RoutingMatchDomainSid,
                    Sid,
                    &MatchingDomain );

    if ( Status != STATUS_SUCCESS ) {
        return Status;
    }

    //
    // If that TDO is not the named TDO,
    //  indicate that there was no match.
    //

    if ( !RtlEqualUnicodeString( TrustedDomainName,
                                 &MatchingDomain,
                                 TRUE ) ) {
        Status = STATUS_NO_MATCH;
    }


    LsaIFree_LSAPR_UNICODE_STRING_BUFFER( (PLSAPR_UNICODE_STRING) &MatchingDomain );

    return Status;

}




NTSTATUS
LsaIFilterSids(
    IN PUNICODE_STRING TrustedDomainName,
    IN ULONG TrustDirection,
    IN ULONG TrustType,
    IN ULONG TrustAttributes,
    IN PSID Sid,
    IN NETLOGON_VALIDATION_INFO_CLASS InfoClass,
    IN OUT PVOID SamInfo
    )

/*++

Routine description:

    The LsaIFilterSids function performs validation and filtering of the
    Netlogon validation SAM info structure for quarantined domains and inter
    forest trusts.

Arguments:

    TrustedDomainName   DNS name of the trusted domain.

    TrustDirection      Trust direction associated with the TDO.
                        TRUST_DIRECTION_OUTBOUND bit must be set

    TrustType           Trust type associated with the TDO
                        If trust type is not one of TRUST_TYPE_UPLEVEL or
                        TRUST_TYPE_DOWNLEVEL, STATUS_SUCCESS is returned.

    TrustAttributes     Ttrust attributes associated with the TDO
                        Filtering is only performed if TRUST_ATTRIBUTE_FILTER_SIDS bit or
                        TRUST_ATTRIBUTE_FOREST_TRANSITIVE bit is set or

    Sid                 SID of the TDO, must not be NULL or
                        STATUS_INVALID_PARAMETER will be returned

    InfoClass           Identifies the format of the SamInfo structure
                        must be one of NetlogonValidationSamInfo,
                        NetlogonValidationSamInfo2, or NetlogonValidationSamInfo4

    SamInfo             Depending on the value of InfoClass, points to a
                        NETLOGON_VALIDATION_SAM_INFO, NETLOGON_VALIDATION_SAM_INFO2 or
                        NETLOGON_VALIDATION_SAM_INFO4 structure,

                        (NETLOGON_VALIDATION_SAM_INFO3 structures must be
                             camouflaged as NETLOGON_VALIDATION_SAM_INFO2)

                NOTE: SamInfo must have allocate-all-nodes semantics

Return values:

    STATUS_SUCCESS

                        Filtering was perfomed successfully, OK to proceed

    STATUS_INVALID_PARAMETER

                        One of the following has occurred:
                        TrustDirection does not include TRUST_DIRECTION_OUTBOUND bit
                        InfoClass is not one of the two allowed values

    STATUS_DOMAIN_TRUST_INCONSISTENT
                        LogonDomainId member of SamInfo is not of valid filtered.
                        For quarantined domains, LogonDomainId must equal the SID of the TDO.
                        For inter forest trust, LogonDomainId must be one of the non-filtered SIDS.
                        
--*/

{
    NTSTATUS Status;
    NETLOGON_VALIDATION_SAM_INFO * NetlogonValidation;
    UNICODE_STRING CanonTrustedDomainName;

    ASSERT( SamInfo );

    //
    // Validate parameters first
    //

    if ( Sid == NULL ||
         ( 0 == ( TrustDirection & TRUST_DIRECTION_OUTBOUND )) ||
         ( InfoClass != NetlogonValidationSamInfo4 &&
           InfoClass != NetlogonValidationSamInfo2 &&
           InfoClass != NetlogonValidationSamInfo )) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Only act on uplevel and downlevel trusts
    //

    if ( TrustType != TRUST_TYPE_UPLEVEL &&
         TrustType != TRUST_TYPE_DOWNLEVEL ) {

        return STATUS_SUCCESS;
    }

#ifdef XFOREST_CIRCUMVENT
    //
    // If the back door for cross-forest trust support is open
    // but is presently turned off, behave as if the forest transitive
    // bit did not exist
    //

    if ( !LsapDbNoMoreWin2K()) {

        TrustAttributes &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
    }
#endif

    //
    // If no filtering is to be performed, nothing left for us to do
    //

    if ( (TrustAttributes & (TRUST_ATTRIBUTE_FILTER_SIDS|TRUST_ATTRIBUTE_FOREST_TRANSITIVE) ) == 0 ) {

        return STATUS_SUCCESS;
    }

    //
    // Canonicalize the TrustedDomainName
    //

    if ( TrustedDomainName == NULL ) {
        RtlInitUnicodeString( &CanonTrustedDomainName, NULL );
    } else {
        CanonTrustedDomainName = *TrustedDomainName;
        LsapRemoveTrailingDot( &CanonTrustedDomainName, TRUE );
    }

    //
    // Code is cleaner if we can assume (and we can) that
    // NETLOGON_VALIDATION_SAM_INFO2 is a superset of NETLOGON_VALIDATION_SAM_INFO
    //

    ASSERT( FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO, LogonDomainId ) ==
            FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO2, LogonDomainId ));

    ASSERT( FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO, LogonDomainId ) ==
            FIELD_OFFSET( NETLOGON_VALIDATION_SAM_INFO4, LogonDomainId ));

    NetlogonValidation = (NETLOGON_VALIDATION_SAM_INFO *)SamInfo;

    //
    // If the trusted domain is quarantined,
    //  the logon domain ID of SamInfo must match the TDO SID
    //

    ASSERT( RtlValidSid( Sid ));
    ASSERT( RtlValidSid( NetlogonValidation->LogonDomainId ));

    if ( TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS) {
        if ( !RtlEqualSid( NetlogonValidation->LogonDomainId, Sid )) {

            return STATUS_DOMAIN_TRUST_INCONSISTENT;
        }
    }

    //
    // If this is an interforest trust,
    //  the logon domain ID must be one of the SIDs on the FTINFO.
    //

    if ( TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {
        ASSERT( TrustedDomainName != NULL );

        Status = LsapSidOnFtInfo( &CanonTrustedDomainName, NetlogonValidation->LogonDomainId );

        if ( !NT_SUCCESS(Status) ) {
            if ( Status == STATUS_NO_MATCH ) {
                Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
            }
            return Status;
        }
    }

    //
    // Finally, for NetlogonValidationSamInfo2 (and 4) filter the ExtraSids array
    // leaving only those SIDs that prefix-match the non-filtered SIDs for the TDO.
    //

    if ( InfoClass == NetlogonValidationSamInfo4 ||
         InfoClass == NetlogonValidationSamInfo2 ) {

        NETLOGON_VALIDATION_SAM_INFO2 * NetlogonValidation2;
        ULONG i;
        ULONG ValidSids = 0;

        NetlogonValidation2 = (NETLOGON_VALIDATION_SAM_INFO2 *)SamInfo;

        for ( i = 0; i < NetlogonValidation2->SidCount; i++ ) {

            BOOLEAN SidIsBad = FALSE;

            ASSERT( RtlValidSid( NetlogonValidation2->ExtraSids[i].Sid ));

            //
            // If the trusted domain is quarantined,
            //  the SID prefix of the current sid must match the TDO sid.
            //

            if ( TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS) {

                BOOL Equal = FALSE;

                if ( RtlEqualSid(
                         LsapServerSid,
                         NetlogonValidation2->ExtraSids[i].Sid )) {

                    //
                    // Bug 330993: the server logon SID is special -- filtering
                    //             it out would result in broken DC replication
                    //             so leave it out for external trusts
                    //
                    // An inexpensive way to find out if a trusted domain is in
                    // our forest is by calling LsapForestTrustFindMatch.  If it
                    // returns 'IsLocal', the then this domain is in our forest
                    // and the sid should be allowed in.
                    // Otherwise, this is an external trust and the SID will
                    // be filtered out.
                    //

                    LSA_UNICODE_STRING MatchingName;
                    BOOLEAN IsLocal;

                    Status = LsapForestTrustFindMatch(
                                 RoutingMatchDomainName,
                                 TrustedDomainName,
                                 &MatchingName,
                                 &IsLocal
                                 );

                    if ( NT_SUCCESS( Status )) {

                        LsaIFree_LSAPR_UNICODE_STRING_BUFFER(
                            ( LSAPR_UNICODE_STRING * )&MatchingName
                            );

                        SidIsBad = !IsLocal;

                    } else if ( Status == STATUS_NO_MATCH ) {

                        Status = STATUS_SUCCESS;
                        SidIsBad = FALSE;

                    } else {

                        ASSERT( !NT_SUCCESS( Status ));
                        return Status;
                    }

                } else if ( !EqualDomainSid( NetlogonValidation2->ExtraSids[i].Sid, Sid, &Equal )) {

                    DWORD ErrorCode = GetLastError();

                    switch ( ErrorCode ) {

                    case ERROR_NON_DOMAIN_SID:
                        return STATUS_INVALID_SID;

                    case ERROR_REVISION_MISMATCH:
                        return STATUS_REVISION_MISMATCH;

                    case ERROR_INVALID_PARAMETER:
                        return STATUS_INVALID_PARAMETER;

                    case ERROR_INVALID_SID:
                        return STATUS_INVALID_SID;

                    default:
                        ASSERT( FALSE ); // add mapping
                        return STATUS_UNSUCCESSFUL;
                    }

                } else if ( !Equal ) {
                    SidIsBad = TRUE;
                }
            }

            //
            // If this is an interforest trust,
            //  the SID prefix of the current SID must be one of the SIDs on the FTINFO.
            //

            if ( SidIsBad == FALSE &&
                 TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ) {

                ASSERT( TrustedDomainName != NULL );

                if ( RtlEqualSid(
                         LsapServerSid,
                         NetlogonValidation2->ExtraSids[i].Sid )) {

                    //
                    // Bug 330993: the server logon SID is special -- while
                    //             being filtered out, it's not going to
                    //             be on FtInfo, and LsapSidOnFtInfo is
                    //             going to fail with invalid parameter
                    //             because it is not a valid domain SID
                    //

                    Status = STATUS_NO_MATCH;

                } else {

                    Status = LsapSidOnFtInfo( &CanonTrustedDomainName, NetlogonValidation2->ExtraSids[i].Sid );
                }

                if ( Status == STATUS_NO_MATCH ) {
                    SidIsBad = TRUE;
                } else if ( !NT_SUCCESS( Status )) {
                    return Status;
                }
            }

            //
            // If the Sid was found on one of the OK lists,
            //  keep it.
            //

            if ( !SidIsBad ) {
                NetlogonValidation2->ExtraSids[ValidSids++] = NetlogonValidation2->ExtraSids[i];
            }
        }

        NetlogonValidation2->SidCount = ValidSids;
    }

    return STATUS_SUCCESS;
}

#ifdef TESTING_MATCHING_ROUTINE

#include <sddl.h> // ConvertStringSidToSidW



NTSTATUS
LsarForestTrustFindMatch(
    IN LSA_HANDLE PolicyHandle,
    IN ULONG Type,
    IN PLSA_UNICODE_STRING Name,
    OUT PLSA_UNICODE_STRING * Match
    )
{
    NTSTATUS Status;
    PLSA_UNICODE_STRING _Match = MIDL_user_allocate( sizeof( LSA_UNICODE_STRING ));
    PVOID Data;

    UNREFERENCED_PARAMETER( PolicyHandle );

    if ( _Match == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if ( Type == RoutingMatchDomainSid ) {

        if ( FALSE == ConvertStringSidToSidW(
                         Name->Buffer,
                         &Data )) {

            Data = NULL;
        }

    } else {

        Data = Name;
    }

    if ( Data != NULL ) {

        Status = LsaIForestTrustFindMatch(
                     ( LSA_ROUTING_MATCH_TYPE )Type,
                     Data,
                     _Match
                     );

        if ( NT_SUCCESS( Status )) {

            *Match = _Match;

        } else {

            *Match = NULL;
        }

    } else {

        Status = STATUS_INVALID_PARAMETER;
    }

    if ( Type == RoutingMatchDomainSid ) {

        LocalFree( Data );
    }

    return Status;
}

#endif



NTSTATUS NTAPI
LsaIForestTrustFindMatch(
    IN LSA_ROUTING_MATCH_TYPE Type,
    IN PVOID Data,
    OUT PLSA_UNICODE_STRING Match
    )
/*++

Routine Description:

    Finds match for given data in the cache

Arguments:

    Type                        Type of Data parameter

    Data                        Data to match

    Match                       Used to return the match, if found.
                                Caller must use LsaIFree_LSAPR_UNICODE_STRING_BUFFER

Returns:

    STATUS_SUCCESS              Match was found

    STATUS_NO_MATCH             Match was not found

    STATUS_INVALID_DOMAIN_STATE Machine must be a GC or a DC in the root domain

    STATUS_INVALID_PARAMETER    Check the inputs

    STATUS_INTERNAL_ERROR       Cache is internally inconsistent

    STATUS_INSUFFICIENT_RESOURCES  Out of memory

--*/
{
    NTSTATUS Status;
    BOOLEAN IsLocal;

    Status = LsapForestTrustFindMatch( Type, Data, Match, &IsLocal );

    if ( NT_SUCCESS( Status ) && IsLocal ) {

        //
        // Local match is the same as no match
        //

        Status = STATUS_NO_MATCH;
    }

    return Status;
}




VOID
LsaIFree_LSA_FOREST_TRUST_INFORMATION(
    IN PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    )
/*++

Routine Description:

    Frees up a structure pointed to by ForestTrustInfo

Arguments:

    ForestTrustInfo         structure to free

Returns:

    Nothing

--*/
{
    if ( ForestTrustInfo ) {

        LsapFreeForestTrustInfo( *ForestTrustInfo );
        MIDL_user_free( *ForestTrustInfo );
        *ForestTrustInfo = NULL;
    }

}




VOID
LsaIFree_LSA_FOREST_TRUST_COLLISION_INFORMATION(
    IN PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    )
/*++

Routine Description:

    Frees up a structure pointed to by CollisionInfo

Arguments:

    CollisionInfo         structure to free

Returns:

    Nothing

--*/
{
    if ( CollisionInfo ) {

        LsapFreeCollisionInfo( CollisionInfo );
    }
}


BOOLEAN
LsapDbDcInRootDomain()
/*++

Routine Description:

    Tells if the system is running as a domain controller
    in the root domain of the forest

Arguments:

    None

Returns:

    TRUE or FALSE

--*/
{
    //
    // The determination is done at startup time and
    // the results are assumed to remain constant for
    // as long as the server stays up.
    //

    return DcInRootDomain;
}



BOOLEAN
LsapDbNoMoreWin2K()
/*++

Routine Description:

    Determines whether all domain controllers in the forest have been upgraded
    to Whistler (a requirement for forest trust operation) by querying
    the msDS-Behavior-Version attribute from the Partitions container in the DS

    Additionally, if XFOREST_CIRCUMVENT is defined, the backdoor is opened
    through which the functionality may be allowed though the behavior-version is 0

Arguments:

    None

Returns:

    TRUE or FALSE

NOTE:

    Currently, there is no requirement for this routine to be fast.
    The assumption is that once the system is in native mode, it
    remains in native mode forever.  Hence the static local variable.

--*/
{
    static BOOLEAN Result = FALSE;
    NTSTATUS Status;
    LSAP_DB_ATTRIBUTE Attribute;

    //
    // Once true - always true
    //

    if ( Result == TRUE ) {

        return TRUE;
    }

    //
    // Make sure the DS is installed
    //

    if ( !LsaDsStateInfo.UseDs ) {

        return FALSE;
    }

    //
    // Read the msDS-Behavior-Version attribute from the Partitions container
    //

    LsapDbInitializeAttributeDs(
        &Attribute,
        BhvrVers,
        NULL,
        0,
        FALSE
        );

    Status = LsapDsReadAttributesByDsName(
                 LsaDsStateInfo.DsPartitionsContainer,
                 LSAPDS_OP_NO_LOCK,
                 &Attribute,
                 1
                 );

    if ( !NT_SUCCESS( Status )) {

       LsapDsDebugOut(( DEB_ERROR,
                        "LsapDbNoMoreWin2K: LsapDsReadAttributesByDsName failed: 0x%lx\n",
                        Status ));
       return FALSE;
    }

    if ( *( PULONG )Attribute.AttributeValue >= DS_BEHAVIOR_WHISTLER ) {

        Result = TRUE;

#ifdef XFOREST_CIRCUMVENT

    } else {

        Status = LsapDbLookupEnableXForestSwitch( &Result );

        if( !NT_SUCCESS( Status )) {

            Result = FALSE;
        }
#endif
    }

    MIDL_user_free( Attribute.AttributeValue );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbinstal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dbinstal.c

Abstract:

    LSA Protected Subsystem - Database Installation.

    This module contains code which will create an initial LSA Database
    if none exists.  Temporarily, this code is executed from within
    LSA Initialization.  This code will form part of the Security
    Installation applet when implemented.

    WARNING!  THE CODE IN THIS MODULE IS TEMPORARY.  IT WILL BE REPLACED
    BY SYSTEM INSTALLATION FUNCTIONALITY.

Author:

    Scott Birrell       (ScottBi)       August 2, 1991

Environment:

    User mode - Does not depend on Windows.

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"



VOID
LsapDbSetDomainInfo(
    IN PLSAP_DB_ATTRIBUTE *NextAttribute,
    IN ULONG              *AttributeCount
    );


NTSTATUS
LsapDbGetNextValueToken(
    IN PUNICODE_STRING Value,
    IN OUT PULONG ParseContext,
    OUT PUNICODE_STRING *ReturnString
    );


NTSTATUS
LsapDbInstallLsaDatabase(
    ULONG Pass
    )

/*++

Routine Description:

    This function installs an initial LSA Database.  Any existing database
    will be reset to have its initial attributes.

Arguments:

    Pass - Either 1 or 2.  During pass 1 all information that is
        not product type-specific is initialized.  In pass 2,
        the product type-specific stuff is initialized.

Return Value:

    NTSTATUS - Standard Nt Result Code

--*/

{
    NTSTATUS Status;

    //
    // Install the LSA Database Policy Object.
    //

    Status = LsapDbInstallPolicyObject(Pass);

    return(Status);
}


NTSTATUS
LsapDbInstallPolicyObject(
    IN ULONG Pass
    )

/*++

Routine Description:

    This function installs the LSA Database Policy Object, setting its attributes
    to the default state.  It is called as part of the LSA Database
    Installation Procedure.

Arguments:

    Pass - Either 1 or 2.  During pass 1 all information that is
        not product type-specific is initialized.  In pass 2,
        the product type-specific stuff is initialized.

Return Value:

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_OBJECT_INFORMATION ObjectInformation;
    LSAP_DB_HANDLE Handle;
    POLICY_LSA_SERVER_ROLE ServerRole;
    LSAP_DB_POLICY_PRIVATE_DATA PolicyPrivateData;
    LSARM_POLICY_AUDIT_EVENTS_INFO InitialAuditEventInformation;
    POLICY_AUDIT_LOG_INFO InitialAuditLogInformation;
    LSAP_DB_ATTRIBUTE Attributes[21];
    PLSAP_DB_ATTRIBUTE NextAttribute;
    ULONG AttributeCount = 0;
    BOOLEAN ObjectReferenced = FALSE;
    ULONG Revision;
    LSAP_DB_ENCRYPTION_KEY NewEncryptionKey;
    ULONG                  SyskeyLength;
    PVOID                  Syskey;


    NextAttribute = Attributes;


    LsapDiagPrint( DB_INIT,
                   ("LSA (init): Performing pass %d of LSA Policy Initialization\n",
                    Pass ) );

    if (Pass == 1) {

        //
        // Set up the Object Information for creating the Policy Object.
        // Note that we put NULL for Security Quality Of Service since this
        // open does not involve impersonation.
        //

        ObjectInformation.ObjectTypeId = PolicyObject;
        ObjectInformation.Sid = NULL;
        ObjectInformation.ObjectAttributeNameOnly = FALSE;

        InitializeObjectAttributes(
            &ObjectInformation.ObjectAttributes,
            &LsapDbNames[Policy],
            0L,
            NULL,
            NULL
        );

        Handle = LsapDbHandle;



        //
        // Create the revision attribute
        //

        Revision = LSAP_DB_REVISION_1_7;
        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolRevision],
            &Revision,
            sizeof (ULONG),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the absolute minimum quota limit values for use in range
        // checking done by LsaSetInformationPolicy() API.  These values are
        // hard-coded.
        //

        LsapDbAbsMinQuotaLimits.PagedPoolLimit = LSAP_DB_ABS_MIN_PAGED_POOL;
        LsapDbAbsMinQuotaLimits.NonPagedPoolLimit = LSAP_DB_ABS_MIN_NON_PAGED_POOL;
        LsapDbAbsMinQuotaLimits.MinimumWorkingSetSize =
            LSAP_DB_ABS_MIN_MIN_WORKING_SET;
        LsapDbAbsMinQuotaLimits.MaximumWorkingSetSize =
            LSAP_DB_ABS_MIN_MAX_WORKING_SET;
        LsapDbAbsMinQuotaLimits.PagefileLimit =
            LSAP_DB_ABS_MIN_PAGEFILE;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[QuAbsMin],
            &LsapDbAbsMinQuotaLimits,
            sizeof (QUOTA_LIMITS),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the Abs Max Quota Limits.
        //

        LsapDbAbsMaxQuotaLimits.PagedPoolLimit = LSAP_DB_ABS_MAX_PAGED_POOL;
        LsapDbAbsMaxQuotaLimits.NonPagedPoolLimit = LSAP_DB_ABS_MAX_NON_PAGED_POOL;
        LsapDbAbsMaxQuotaLimits.MinimumWorkingSetSize =
            LSAP_DB_ABS_MAX_MIN_WORKING_SET;
        LsapDbAbsMaxQuotaLimits.MaximumWorkingSetSize =
            LSAP_DB_ABS_MAX_MAX_WORKING_SET;
        LsapDbAbsMaxQuotaLimits.PagefileLimit =
             LSAP_DB_ABS_MAX_PAGEFILE;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[QuAbsMax],
            &LsapDbAbsMaxQuotaLimits,
            sizeof (QUOTA_LIMITS),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Install initial Private Data.  For now, just one ULONG is stored
        // so that the Replication Code can call LsaIGetPrivateData and
        // LsaISetPrivateData successfully.
        //

        PolicyPrivateData.NoneDefinedYet = 0;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolState],
            &PolicyPrivateData,
            sizeof (LSAP_DB_POLICY_PRIVATE_DATA),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the Policy Modification Info.  Set the Modification
        // Id to 1 and set the Database Creation Time to the current time.
        //

        LsapDbState.PolicyModificationInfo.ModifiedId =
            RtlConvertUlongToLargeInteger( (ULONG) 1 );

        Status = NtQuerySystemTime(
                     &LsapDbState.PolicyModificationInfo.DatabaseCreationTime
                     );

        if (!NT_SUCCESS(Status)) {
            goto InstallPolicyObjectError;
        }

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolMod],
            &LsapDbState.PolicyModificationInfo,
            sizeof (POLICY_MODIFICATION_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize Default Event Auditing Options.  No auditing is specified
        // for any event type.  These will be set in the Policy Database later
        // when the Policy Object is created.
        //

        Status = LsapAdtInitializeDefaultAuditing(
                     (ULONG) 0,
                     &InitialAuditEventInformation
                     );

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolAdtEv],
            &InitialAuditEventInformation,
            sizeof (LSARM_POLICY_AUDIT_EVENTS_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;


        //
        // Create the Containing Directory "Accounts" for the user and group
        // accounts objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Accounts],
            NULL,
            0L,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Create the Containing Directory "Domains" for the Trusted Domain
        // objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Domains],
            NULL,
            0L,
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Create the Containing Directory "Secrets" for the Secret objects.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[Secrets],
            NULL,
            0L,
            FALSE
            );

        //
        // Create the Lsa Database Policy Object, opening the existing one if
        // it exists.
        //

        NextAttribute++;
        AttributeCount++;


        //////////////////////////////////////////////////
        //                                              //
        // ATTRIBUTES BELOW THIS POINT ARE INITIALIZED  //
        // IN PASS 1, BUT MAY BE CHANGED IN PASS 2.     //
        // IN GENERAL, THINGS ARE SET FOR A WIN-NT PROD //
        // AND CHANGED IN PASS 2 IF NECESSARY.          //
        //                                              //
        //////////////////////////////////////////////////

        //
        // Initialize the default installed quota limit values
        //

        LsapDbInstalledQuotaLimits.PagedPoolLimit =
            LSAP_DB_WINNT_PAGED_POOL;
        LsapDbInstalledQuotaLimits.NonPagedPoolLimit =
            LSAP_DB_WINNT_NON_PAGED_POOL;
        LsapDbInstalledQuotaLimits.MinimumWorkingSetSize =
            LSAP_DB_WINNT_MIN_WORKING_SET;
        LsapDbInstalledQuotaLimits.MaximumWorkingSetSize =
            LSAP_DB_WINNT_MAX_WORKING_SET;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[DefQuota],
            &LsapDbInstalledQuotaLimits,
            sizeof (QUOTA_LIMITS),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the audit log information.
        //

        InitialAuditLogInformation.MaximumLogSize = 8*1024;
        InitialAuditLogInformation.AuditLogPercentFull = 0;
        InitialAuditLogInformation.AuditRetentionPeriod.LowPart = 0x823543;
        InitialAuditLogInformation.AuditRetentionPeriod.HighPart = 0;
        InitialAuditLogInformation.AuditLogFullShutdownInProgress = FALSE;
        InitialAuditLogInformation.TimeToShutdown.LowPart = 0x46656;
        InitialAuditLogInformation.TimeToShutdown.HighPart = 0;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolAdtLg],
            &InitialAuditLogInformation,
            sizeof (POLICY_AUDIT_LOG_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Set the default Audit Log Full Information.  The Audit Log
        // is not FULL and ShutDownOnFull is disabled.
        //

        LsapAdtLogFullInformation.LogIsFull = FALSE;
        LsapAdtLogFullInformation.ShutDownOnFull = FALSE;

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolAdtFL],
            &LsapAdtLogFullInformation,
            sizeof (POLICY_AUDIT_FULL_QUERY_INFO),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;

        //
        // Initialize the syskey
        //

        Status =  LsapDbSetupInitialSyskey(
                        &SyskeyLength,
                        &Syskey
                        );

         if (!NT_SUCCESS(Status)) {
            LsapLogError(
                "LsapDbInstallPolicyObject: Syskey setup failed 0x%lx\n",
                 Status
                );

            goto InstallPolicyObjectError;
        }


        //
        // Initialize the key for secret encryption
        //

        Status = LsapDbGenerateNewKey(
                    &NewEncryptionKey
                    );

        if (!NT_SUCCESS(Status)) {
            LsapLogError(
                "LsapDbInstallPolicyObject: New key generation failed 0x%lx\n",
                Status
                );

            goto InstallPolicyObjectError;
        }

        //
        // Encrypt the key with syskey
        //

        LsapDbEncryptKeyWithSyskey(
                &NewEncryptionKey,
                Syskey,
                SyskeyLength
                );

        //
        // Set the global variable LsapDbSyskey to reflect this value
        //

        LsapDbSysKey = Syskey;

        //
        // Add the attribute for the list of attributes to be added to the database.
        //

        LsapDbInitializeAttribute(
            NextAttribute,
            &LsapDbNames[PolSecretEncryptionKey],
            &NewEncryptionKey,
            sizeof (NewEncryptionKey),
            FALSE
            );

        NextAttribute++;
        AttributeCount++;


        Status = LsapDbCreateObject(
                     &ObjectInformation,
                     GENERIC_ALL,
                     LSAP_DB_OBJECT_OPEN_IF,
                     LSAP_DB_TRUSTED,
                     Attributes,
                     AttributeCount,
                     &LsapDbHandle
                     );

        if (!NT_SUCCESS(Status)) {

            LsapLogError(
                "LsapDbInstallPolicyObject: Create Policy object failed 0x%lx\n",
                Status
                );

            LsapDiagPrint( DB_INIT,
                           ("LSA (init): Attributes passed to CreateObject call:\n\n"
                            "                      Count: %d\n"
                            "              Array Address: 0x%lx",
                            AttributeCount, Attributes) );

            ASSERT(NT_SUCCESS(Status));     // Provide a debug opportunity

            goto InstallPolicyObjectError;
        }


    } else if (Pass == 2) {

        //
        // Set up the account objects necessary to implement the default
        // Microsoft Policy for privilege assignment and system access
        // capabilities.
        //

        Status = LsapDbInstallAccountObjects();

        if (!NT_SUCCESS(Status)) {

            KdPrint(("LSA DB INSTALL: Installation of account objects failed.\n"
                    "               Status: 0x%lx\n", Status));
            goto InstallPolicyObjectError;
        }

        //
        // Set up the account domain and primary domain information
        // ONLY if the real setup wasn't run.  In that case, we are
        // doing a pseudo setup as part of a developer's first boot.
        //

        if (!LsapSetupWasRun) {

            LsapDbSetDomainInfo( &NextAttribute, &AttributeCount );
        }

        if (LsapProductType == NtProductLanManNt) {

            //
            // quota limits were set for WinNt in pass 1.
            // Change if necessary in this pass.
            //

            LsapDbInstalledQuotaLimits.PagedPoolLimit =
                LSAP_DB_LANMANNT_PAGED_POOL;
            LsapDbInstalledQuotaLimits.NonPagedPoolLimit =
                LSAP_DB_LANMANNT_NON_PAGED_POOL;
            LsapDbInstalledQuotaLimits.MinimumWorkingSetSize =
                LSAP_DB_LANMANNT_MIN_WORKING_SET;
            LsapDbInstalledQuotaLimits.MaximumWorkingSetSize =
                LSAP_DB_LANMANNT_MAX_WORKING_SET;

            LsapDbInitializeAttribute(
                NextAttribute,
                &LsapDbNames[DefQuota],
                &LsapDbInstalledQuotaLimits,
                sizeof (QUOTA_LIMITS),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;

            //
            // Audit log information was set for WinNt product
            // in pass 1.  Change if necessary in this pass.
            //

            InitialAuditLogInformation.MaximumLogSize = 20*1024;
            InitialAuditLogInformation.AuditLogPercentFull = 0;
            InitialAuditLogInformation.AuditRetentionPeriod.LowPart = 0x823543;
            InitialAuditLogInformation.AuditRetentionPeriod.HighPart = 0;
            InitialAuditLogInformation.AuditLogFullShutdownInProgress = FALSE;
            InitialAuditLogInformation.TimeToShutdown.LowPart = 0x46656;
            InitialAuditLogInformation.TimeToShutdown.HighPart = 0;

            LsapDbInitializeAttribute(
                NextAttribute,
                &LsapDbNames[PolAdtLg],
                &InitialAuditLogInformation,
                sizeof (POLICY_AUDIT_LOG_INFO),
                FALSE
                );

            NextAttribute++;
            AttributeCount++;
        }

        if (AttributeCount > 0) {

            Status = LsapDbReferenceObject(
                        LsapDbHandle,
                        0,
                        PolicyObject,
                        PolicyObject,
                        LSAP_DB_LOCK | LSAP_DB_START_TRANSACTION
                        );

            if (!NT_SUCCESS(Status)) {

                LsapDiagPrint( DB_INIT,
                               ("LSA (init): Internal reference of Policy object failed.\n"
                                "            Status of LsapDbReferenceObject == 0x%lx\n",
                                Status) );
                goto InstallPolicyObjectError;
            }

            ObjectReferenced = TRUE;

            Status = LsapDbWriteAttributesObject(
                         LsapDbHandle,
                         Attributes,
                         AttributeCount
                         );

            if (!NT_SUCCESS(Status)) {

                LsapDiagPrint( DB_INIT,
                               ("LSA (init): Update of Policy attributes failed.\n"
                                "            Attributes:\n\n"
                                "                      Count: %d\n"
                                "              Array Address: 0x%lx",
                                AttributeCount, Attributes) );
                goto InstallPolicyObjectError;
            }

            Status = LsapDbDereferenceObject(
                         &LsapDbHandle,
                         PolicyObject,
                         PolicyObject,
                         (LSAP_DB_LOCK |
                         LSAP_DB_FINISH_TRANSACTION),
                         (SECURITY_DB_DELTA_TYPE) 0,
                         STATUS_SUCCESS
                         );

            if (!NT_SUCCESS(Status)) {

                LsapLogError(
                    "LsapDbInstallPolicyObject: Pass 2 DB init failed. 0x%lx\n",
                    Status
                    );

                goto InstallPolicyObjectError;
            }

            ObjectReferenced = FALSE;
        }
    }

InstallPolicyObjectFinish:

    //
    // If necessary, dereference the Policy Object.
    //

    if (ObjectReferenced) {

        Status = LsapDbDereferenceObject(
                     &LsapDbHandle,
                     PolicyObject,
                     PolicyObject,
                     (LSAP_DB_LOCK |
                     LSAP_DB_FINISH_TRANSACTION),
                     (SECURITY_DB_DELTA_TYPE) 0,
                     Status
                     );
    }

    return(Status);

InstallPolicyObjectError:

    if (Pass == 1) {

        LsapLogError(
            "LsapDbInstallPolicyObject: Pass 1 DB init failed. 0x%lx\n",
            Status
            );

    } else {

        LsapLogError(
            "LsapDbInstallPolicyObject: Pass 2 DB init failed. 0x%lx\n",
            Status
            );
    }

    goto InstallPolicyObjectFinish;
}



NTSTATUS
LsapDbGetConfig (
    IN HANDLE KeyHandle,
    IN PWSTR Name,
    OUT PUNICODE_STRING Value
    )

/*++

Routine Description:

    This routine obtains configuration information from the registry.

Arguments:

    KeyHandle - handle to registry key node containing value.

    Name - The name of a value under the specifed key node.

    Value - Fills in the string with the value of the parameter.  The
        returned string is zero terminated.  The buffer is allocated in
        Process Heap and should be deallocated by the caller.

Return Value:

    STATUS_SUCCESS - If the operation was successful.

    STATUS_NO_MEMORY - There wasn't enough memory to allocate a buffer
        to contain the returned information.

    STATUS_OBJECT_NAME_NOT_FOUND - The specifed section or the specified
        keyword could not be found.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING ValueName;
    ULONG Length, ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    RtlInitUnicodeString( &ValueName, Name );
    Length = 512;
    KeyValueInformation = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    if (KeyValueInformation == NULL) {
        Status = STATUS_NO_MEMORY;
    } else {
        Status = NtQueryValueKey( KeyHandle,
                                  &ValueName,
                                  KeyValuePartialInformation,
                                  KeyValueInformation,
                                  Length,
                                  &ResultLength
                                );
        if (NT_SUCCESS( Status )) {
            if (KeyValueInformation->Type != REG_SZ) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }
        }
    }

    if (NT_SUCCESS( Status )) {
        Value->MaximumLength = (USHORT)(KeyValueInformation->DataLength);
        if (Value->MaximumLength >= sizeof(UNICODE_NULL)) {
            Value->Length = (USHORT)KeyValueInformation->DataLength -
                             sizeof( UNICODE_NULL);
        } else {
            Value->Length = 0;
        }
        Value->Buffer = (PWSTR)KeyValueInformation;
        RtlMoveMemory( Value->Buffer,
                       KeyValueInformation->Data,
                       Value->Length
                     );
        Value->Buffer[ Value->Length / sizeof( WCHAR ) ] = UNICODE_NULL;
        KeyValueInformation = NULL;
    } else {
#if DEVL
        DbgPrint( "LSA DB INSTALL: No '%wZ' value in registry - Status == %x\n", &ValueName, Status);
#endif //DEVL
    }

    if ( KeyValueInformation != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, KeyValueInformation );
    }

    return Status;
}



NTSTATUS
LsapDbGetNextValueToken(
    IN PUNICODE_STRING Value,
    IN OUT PULONG ParseContext,
    OUT PUNICODE_STRING *ReturnString
    )

/*++

Routine Description:

    This routine is used to isolate the next token in a registry value.

    The token is returned in a single heap buffer containing both the
    STRING and the Buffer of that string containing the token.  The
    caller of this routine is responsible for deallocating the buffer
    when it is no longer needed.

    The string, although counted, will also be null terminated.

Arguments:

    Value - Supplies the value line being parsed.

    ParseContext - Is a pointer to a context state value.
        The first time this routine is called for a particular
        Value line, the value pointed to should be zero.  Thereafter,
        the value returned from the previous call should be passed.

    ReturnString - Returns a pointer to the allocated string.


Return Value:

    STATUS_SUCCESS - indicates the next token has been isolated.

    STATUS_INVALID_PARAMTER_1 - Indicates there were no more tokens in
            the Value line.

    STATUS_NO_MEMORY - memory could not be allocated for the token.

--*/

{
    ULONG i, j;
    ULONG TokenLength;
    ULONG AllocSize;


    //
    // Get to the beginning of the next token
    //

    for ( i = *ParseContext;
          i < (Value->Length/sizeof(WCHAR)) &&
            (Value->Buffer[i] == L' ' || Value->Buffer[i] == L'\t');
          i++ )
        ;


    //
    // see if we ran off the end of the string..
    //

    if (i >= (Value->Length/sizeof(WCHAR))) {
        return STATUS_INVALID_PARAMETER_1;
    }


    //
    // Now search for the end of the token
    //

    for ( j = i + 1;
          j < (Value->Length/sizeof(WCHAR)) &&
            Value->Buffer[j] != L' ' && Value->Buffer[j] != L'\t';
          j++ )
        ;

    *ParseContext = j;

    //
    // We've either reached the end of the string, or found the end of the
    // token.
    //

    //
    // If the caller actually wants the string returned,
    //  allocate and copy it.
    //

    if ( ARGUMENT_PRESENT( ReturnString ) ) {
        UNICODE_STRING SourceString;
        PUNICODE_STRING LocalString;

        TokenLength = (j-i) * sizeof(WCHAR);
        AllocSize = sizeof(UNICODE_STRING) + (TokenLength + sizeof( UNICODE_NULL ) + 4);

        LocalString = RtlAllocateHeap( RtlProcessHeap(), 0, AllocSize );
        if ( LocalString == NULL ) {
            DbgPrint("LSA DB INSTALL: LsapDbGetNextValueToken: Not enough memory %ld\n",
                AllocSize);
            return STATUS_NO_MEMORY;
        }
        LocalString->MaximumLength = (USHORT)(TokenLength + sizeof( UNICODE_NULL ));
        LocalString->Length = (USHORT)TokenLength;
        LocalString->Buffer = (PWCHAR)(LocalString + 1);


        //
        // Now copy the token
        //

        SourceString.MaximumLength = LocalString->Length;
        SourceString.Length = LocalString->Length;
        SourceString.Buffer = &Value->Buffer[i];

        RtlCopyUnicodeString( LocalString, &SourceString );

        //
        // Add a null terminator
        //

        LocalString->Buffer[LocalString->Length / sizeof( UNICODE_NULL )] = UNICODE_NULL;
        *ReturnString = LocalString;
    }

    return STATUS_SUCCESS;

}



VOID
LsapDbSetDomainInfo(
    IN PLSAP_DB_ATTRIBUTE *NextAttribute,
    IN ULONG              *AttributeCount
    )

/*

    This routine is only used for the pseudo setup for internal
    developer's use.  In a real product installation/setup
    situation, The functionality performed by this routine is
    performed by the text-mode setup supplemented by the network
    setup.

    This routine must establish values for the AccountDomain and
    PrimaryDomain attributes of the Policy object.  These
    attributes must be configured as follows:


    I.   Standalone Win-NT product

            AccountDomainName = "Account"
            AccountDomainSid  = (value assigned by user)
            PrimaryDomainName = Name of domain to use for browsing
                                (this is optional in this case)
            PrimaryDomainSid  = (None)


    II.  Non-Standalone Win-NT product

            AccountDomainName = "Account"
            AccountDomainSid  = (value assigned by user)
            PrimaryDomainName = (Primary domain's name)
            PrimaryDomainSid  = (Primary domain's SID)


    III. LanMan-NT product

            AccountDomainName = (Primary domain's name)
            AccountDomainSid  = (Primary domain's SID)
            PrimaryDomainName = (Primary domain's name)
            PrimaryDomainSid  = (Primary domain's SID)


    This routine only does (II) and (III).  The real setup must
    be capable of doing (I) as well.

*/

{
    NTSTATUS Status;
    NT_PRODUCT_TYPE ProductType;
    BOOLEAN ProductExplicitlySpecified;

    UNICODE_STRING PrimaryDomainName, AccountDomainName;
    PSID PrimaryDomainSid, AccountDomainSid;

    HANDLE KeyHandle = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING KeyName;
    ULONG TempULong = 0 ;

    SID_IDENTIFIER_AUTHORITY TmppAuthority;
    ULONG DomainSubAuthorities[SID_MAX_SUB_AUTHORITIES];
    UCHAR DomainSubAuthorityCount = 0;

    ULONG i;
    ULONG Context = 0;
    PUNICODE_STRING Rid;
    ULONG Size;

    UNICODE_STRING DomainId;

    PrimaryDomainSid = NULL;
    AccountDomainSid = NULL;

    PrimaryDomainName.Buffer = NULL;
    DomainId.Buffer = NULL;

    //
    // Get the product type
    //

    ProductExplicitlySpecified =
        RtlGetNtProductType( &ProductType );

#if DBG
if (ProductType == NtProductLanManNt) {
    DbgPrint("LSA DB INSTALL:  Configuring LSA database for LanManNt system.\n");
} else {
    DbgPrint("LSA DB INSTALL:  Configuring LSA database for WinNt or Dedicated Server product.\n");
}
#endif //DBG

    //
    // Open a handle to the registry key node that contains the
    // interesting domain values (name, id, and account id)
    //

    RtlInitUnicodeString( &KeyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters" );

    InitializeObjectAttributes(
                            &ObjectAttributes,
                            &KeyName,
                            OBJ_CASE_INSENSITIVE,
                            NULL,
                            NULL);

    Status = NtOpenKey( &KeyHandle, KEY_READ, &ObjectAttributes );

    if (!NT_SUCCESS( Status )) {
#if DEVL
        DbgPrint( "LSA DB INSTALL: Unable to access registry key (%wZ) - Status == %x\n", &KeyName, Status );
#endif // DBG
        goto Exit;
    }

    //
    // Get the primary domain name from the registry
    //

    Status = LsapDbGetConfig(KeyHandle,
                           L"Domain",
                           &PrimaryDomainName);

    if ( !NT_SUCCESS( Status ) ) {
        goto Exit;
    }

    //
    // get the primary domain's SID
    //

    Status = LsapDbGetConfig(KeyHandle,
                           L"DomainId",
                           &DomainId );

    if ( !NT_SUCCESS( Status ) ) {
        goto Exit;
    }

    //
    // Get the Authority ID from the registry
    //

    for (i=0; i < sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]); i++ ) {

        Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );

        if (NT_SUCCESS( Status )) {
            Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
            RtlFreeHeap( RtlProcessHeap(), 0, Rid );
        }

        if ( !NT_SUCCESS( Status ) ) {
#if DBG
            DbgPrint("LSA DB INSTALL: domainid - must have at least %ld subauthorities\n",
                     sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]));
#endif //DBG

            goto Exit;
        }

        TmppAuthority.Value[i] = (UCHAR)TempULong;
    }

    //
    // Get some subauthorities from the registry
    //

    for (i=0; ; i++ ) {

        Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );

        if (NT_SUCCESS( Status )) {
            Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
            RtlFreeHeap( RtlProcessHeap(), 0, Rid );
        }

        if ( Status == STATUS_INVALID_PARAMETER_1 ) {
            break;
        }

        if ( !NT_SUCCESS( Status )) {
            goto Exit;
        }

        if ( i >= sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]) ) {
#if DBG
            DbgPrint("LSA DB INSTALL: domainid - "
              "Too many Domain subauthorities specified (%ld maximum).\n",
              sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]));
#endif //DBG

            goto Exit;
        }

        DomainSubAuthorities[i] = TempULong;
        DomainSubAuthorityCount ++;
    }

    //
    // Allocate memory to put the domain id in.
    //

    Size = RtlLengthRequiredSid( DomainSubAuthorityCount );

    PrimaryDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

    if (PrimaryDomainSid == NULL) {
        goto Exit;
    }

    Status = RtlInitializeSid( PrimaryDomainSid,
                              &TmppAuthority,
                               DomainSubAuthorityCount );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    for ( i=0; i < (ULONG) DomainSubAuthorityCount; i++ ) {
        *(RtlSubAuthoritySid(PrimaryDomainSid, i)) =
            DomainSubAuthorities[i];
    }

    if (ProductType != NtProductLanManNt) {

        DomainSubAuthorityCount = 0;
        Context = 0;

        //
        //  if the system is a WinNt product, then get the account domain
        //  SID from the registry info and set a well known name ("ACCOUNT").
        //

        RtlInitUnicodeString(&AccountDomainName,L"Account");

        //
        //  Free old DomainId data if it has been allocated previously
        //

        if (DomainId.Buffer != NULL) {
            RtlFreeHeap( RtlProcessHeap(), 0, DomainId.Buffer );
            DomainId.Buffer = NULL;
        }

        Status = LsapDbGetConfig(KeyHandle,
                               L"AccountDomainId",
                               &DomainId );

        if ( !NT_SUCCESS( Status ) ) {
            goto Exit;
        }

        //
        // Get the Authority ID from the registry
        //

        for (i=0; i<sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]); i++ ) {

            Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );
            if (NT_SUCCESS( Status )) {
                Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
                RtlFreeHeap( RtlProcessHeap(), 0, Rid );
            }

            if ( !NT_SUCCESS( Status ) ) {
#if DBG
                DbgPrint("LSA DB INSTALL: AccountDomainId - must have at least %ld subauthorities\n",
                    sizeof(TmppAuthority.Value)/sizeof(TmppAuthority.Value[0]));
#endif //DBG
                goto Exit;
            }

            TmppAuthority.Value[i] = (UCHAR)TempULong;
        }

        //
        // Get some subauthorities from the registry
        //

        for (i=0; ; i++ ) {

            Status = LsapDbGetNextValueToken( &DomainId, &Context, &Rid );
            if (NT_SUCCESS( Status )) {
                Status = RtlUnicodeStringToInteger(Rid, 10, &TempULong );
                RtlFreeHeap( RtlProcessHeap(), 0, Rid );
            }

            if ( Status == STATUS_INVALID_PARAMETER_1 ) {
                break;
            }

            if ( !NT_SUCCESS( Status )) {
                goto Exit;
            }

            if ( i >=
                sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]) ) {
#if DBG
                DbgPrint("MsV1_0: NT.CFG: domainid - Too many Domain subauthorities specified (%ld maximum).\n",
                  sizeof(DomainSubAuthorities)/sizeof(DomainSubAuthorities[0]));
#endif //DBG
                goto Exit;
            }

            DomainSubAuthorities[i] = TempULong;
            DomainSubAuthorityCount ++;
        }

        //
        // Allocate memory to put the domain id in.
        //

        Size = RtlLengthRequiredSid( DomainSubAuthorityCount );

        AccountDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

        if (AccountDomainSid == NULL) {
            goto Exit;
        }

        RtlInitializeSid( AccountDomainSid,
                          &TmppAuthority,
                          DomainSubAuthorityCount );

        for ( i=0; i < (ULONG) DomainSubAuthorityCount; i++ ) {
            *(RtlSubAuthoritySid(AccountDomainSid, i)) =
                DomainSubAuthorities[i];
        }

    } else {

        //
        // Otherwise, the account domain is set up just like the
        // primary domain
        //

        AccountDomainName = PrimaryDomainName;

        Size = RtlLengthSid(PrimaryDomainSid);

        AccountDomainSid = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

        if (AccountDomainSid == NULL) {
            goto Exit;
        }

        Status = RtlCopySid(
            Size,
            AccountDomainSid,
            PrimaryDomainSid);

        if ( !NT_SUCCESS( Status ) ) {
            goto Exit;
        }
    }

    //
    // Now add the attributes to be initialized in the policy object...
    //

    //
    // Primary domain name/sid
    //

    Status = LsapDbMakeUnicodeAttribute(
                 &PrimaryDomainName,
                 &LsapDbNames[PolPrDmN],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    (*NextAttribute)++;
    (*AttributeCount)++;

    Status = LsapDbMakeSidAttribute(
                 PrimaryDomainSid,
                 &LsapDbNames[PolPrDmS],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    PrimaryDomainSid = NULL;

    (*NextAttribute)++;
    (*AttributeCount)++;

    //
    // Account domain name/sid
    //

    Status = LsapDbMakeUnicodeAttribute(
                 &AccountDomainName,
                 &LsapDbNames[PolAcDmN],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    (*NextAttribute)++;
    (*AttributeCount)++;

    Status = LsapDbMakeSidAttribute(
                 AccountDomainSid,
                 &LsapDbNames[PolAcDmS],
                 (*NextAttribute)
                 );

    if ( !NT_SUCCESS( Status )) {
        goto Exit;
    }

    AccountDomainSid = NULL;

    (*NextAttribute)++;
    (*AttributeCount)++;

Exit:
    if (KeyHandle != NULL) {
        NtClose(KeyHandle);
    }

    if (DomainId.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, DomainId.Buffer );
    }

    if (PrimaryDomainName.Buffer != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, PrimaryDomainName.Buffer);
    }

    if (PrimaryDomainSid != NULL) {
        RtlFreeHeap (RtlProcessHeap(), 0, PrimaryDomainSid);
    }

    if (AccountDomainSid != NULL) {
        RtlFreeHeap (RtlProcessHeap(), 0, AccountDomainSid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\base\lsa\server\dspolicy\dbluname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    dblookup.c

Abstract:

    LSA Database - Lookup Sid and Name routines

    NOTE:  This module should remain as portable code that is independent
           of the implementation of the LSA Database.  As such, it is
           permitted to use only the exported LSA Database interfaces
           contained in db.h and NOT the private implementation
           dependent functions in dbp.h.
           
Author:

    Scott Birrell       (ScottBi)      November 27, 1992

Environment:

Revision History:

--*/

#include <lsapch2.h>
#include "dbp.h"
#include <sidcache.h>
#include <bndcache.h>
#include <malloc.h>

#include <ntdsa.h>
#include <ntdsapi.h>
#include <ntdsapip.h>
#include "lsawmi.h"
#include <samisrv.h>

#include <lmapibuf.h>
#include <dsgetdc.h>


//
// Local function prototypes
//
#define LOOKUP_MATCH_NONE         0
#define LOOKUP_MATCH_LOCALIZED    1
#define LOOKUP_MATCH_HARDCODED    2
#define LOOKUP_MATCH_BOTH         3

BOOLEAN
LsapDbLookupIndexWellKnownName(
    IN OPTIONAL PLSAPR_UNICODE_STRING Name,
    OUT PLSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex,
    IN DWORD dwMatchType
    );

//
// Hardcoded english strings for LocalService, NetworkService,
// and LocalSystem since the account names may come from the
// registry (which isn't localized).
//

#define  LOCALSERVICE_NAME    L"LocalService"
#define  NETWORKSERVICE_NAME  L"NetworkService"
#define  SYSTEM_NAME          L"SYSTEM"
#define  NTAUTHORITY_NAME     L"NT AUTHORITY"

struct {
    UNICODE_STRING  KnownName;
    LSAP_WELL_KNOWN_SID_INDEX LookupIndex;
} LsapHardcodedNameLookupList[] = {
    { { sizeof(LOCALSERVICE_NAME) - 2, sizeof(LOCALSERVICE_NAME), LOCALSERVICE_NAME },
        LsapLocalServiceSidIndex },
    { { sizeof(NETWORKSERVICE_NAME) - 2, sizeof(NETWORKSERVICE_NAME), NETWORKSERVICE_NAME },
        LsapNetworkServiceSidIndex },
    { { sizeof(SYSTEM_NAME) - 2, sizeof(SYSTEM_NAME), SYSTEM_NAME },
        LsapLocalSystemSidIndex }
};

//
// Handy macros for iterating over static arrays
//
#define NELEMENTS(x) (sizeof(x)/sizeof(x[0]))

NTSTATUS
LsapDbLookupNamesInTrustedForests(
    IN ULONG LookupOptions,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapDbLookupNamesInTrustedForestsWorker(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    OUT BOOLEAN* fAllocateAllNodes,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    OUT NTSTATUS *NonFatalStatus
    );

NTSTATUS
LsapLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    );

NTSTATUS
LsapDomainHasForestTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

NTSTATUS
LsapDomainHasTransitiveTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    OUT LSA_TRUST_INFORMATION *TrustInfo OPTIONAL
    );

NTSTATUS
LsapDomainHasDirectExternalTrust(
    IN PUNICODE_STRING DomainName, OPTIONAL
    IN PSID            DomainSid,  OPTIONAL
    IN OUT  BOOLEAN   *fTDLLock,   OPTIONAL
    OUT PLSAP_DB_TRUSTED_DOMAIN_LIST_ENTRY *TrustEntryOut OPTIONAL
    );

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Lsa Lookup Name Routines                                             //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

NTSTATUS
LsarLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount
    )
/*++

Routine Description:

    See LsapLookupNames.
    
    Note that in Extended Sid Mode, requests to this API are denied since
    only the RID is returned.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Size;
    LSAPR_TRANSLATED_SIDS_EX2 TranslatedSidsEx2 = {0, NULL};

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    //
    // Open SAM
    //
    Status = LsapOpenSam();
    ASSERT(NT_SUCCESS(Status));
    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    if (SamIIsExtendedSidMode(LsapAccountDomainHandle)) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( Count > 1000 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {
        MIDL_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

    //
    // Allocate the TranslatedName buffer to return
    //
    TranslatedSids->Entries = 0;
    Size = Count * sizeof(LSA_TRANSLATED_SID);
    TranslatedSids->Sids = midl_user_allocate( Size );
    if ( !TranslatedSids->Sids ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory( TranslatedSids->Sids, Size );
    TranslatedSids->Entries = Count;

    Status = LsapLookupNames( PolicyHandle,
                               Count,
                               Names,
                               ReferencedDomains,
                               (PLSAPR_TRANSLATED_SIDS_EX2) &TranslatedSidsEx2,
                               LookupLevel,
                               MappedCount,
                               0,  // no options
                               LSA_CLIENT_PRE_NT5 );

    if ( TranslatedSidsEx2.Sids != NULL ) {

        //
        // Map the new data structure back to the old one
        //
        ULONG i;

        ASSERT( TranslatedSidsEx2.Entries == TranslatedSids->Entries );

        for (i = 0; i < TranslatedSidsEx2.Entries; i++ ) {

            PSID Sid = TranslatedSidsEx2.Sids[i].Sid;
            ULONG Rid = 0;

            if ( SidTypeDomain == TranslatedSidsEx2.Sids[i].Use ) {

                Rid = LSA_UNKNOWN_ID;

            } else if ( NULL != Sid ) {

                ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(Sid);
                Rid = *RtlSubAuthoritySid(Sid, (SubAuthCount - 1));

            }

            TranslatedSids->Sids[i].Use = TranslatedSidsEx2.Sids[i].Use;
            TranslatedSids->Sids[i].RelativeId = Rid;
            TranslatedSids->Sids[i].DomainIndex = TranslatedSidsEx2.Sids[i].DomainIndex;

            if (TranslatedSidsEx2.Sids[i].Sid) {
                // N.B.  The SID is not an embedded field server side
                midl_user_free(TranslatedSidsEx2.Sids[i].Sid);
                TranslatedSidsEx2.Sids[i].Sid = NULL;
            }

        }

        //
        // Free the Ex structure
        //
        midl_user_free( TranslatedSidsEx2.Sids );

    } else {

        TranslatedSids->Entries = 0;
        midl_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

Cleanup:

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;

}


NTSTATUS
LsarLookupNames2(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames.
    
    Note that in Extended Sid Mode, requests to this API are denied since
    only the RID is returned.


--*/
{

    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Size;
    LSAPR_TRANSLATED_SIDS_EX2 TranslatedSidsEx2 = {0, NULL};

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames2(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    //
    // Open SAM
    //
    Status = LsapOpenSam();
    ASSERT(NT_SUCCESS(Status));
    if ( !NT_SUCCESS( Status ) ) {

        return( Status );
    }

    if (SamIIsExtendedSidMode(LsapAccountDomainHandle)) {
        return STATUS_NOT_SUPPORTED;
    }

    if ( Count > 1000 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {
        MIDL_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;
    }

    //
    // Allocate the TranslatedName buffer to return
    //
    TranslatedSids->Entries = 0;
    Size = Count * sizeof(LSA_TRANSLATED_SID_EX);
    TranslatedSids->Sids = midl_user_allocate( Size );
    if ( !TranslatedSids->Sids ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RtlZeroMemory( TranslatedSids->Sids, Size );
    TranslatedSids->Entries = Count;

    Status = LsapLookupNames( PolicyHandle,
                               Count,
                               Names,
                               ReferencedDomains,
                               (PLSAPR_TRANSLATED_SIDS_EX2) &TranslatedSidsEx2,
                               LookupLevel,
                               MappedCount,
                               0,  // no options
                               LSA_CLIENT_NT5 );

    if ( TranslatedSidsEx2.Sids != NULL ) {

        //
        // Map the new data structure back to the old one
        //
        ULONG i;

        ASSERT( TranslatedSidsEx2.Entries == TranslatedSids->Entries );

        for (i = 0; i < TranslatedSidsEx2.Entries; i++ ) {

            PSID Sid = TranslatedSidsEx2.Sids[i].Sid;
            ULONG Rid = 0;

            if ( SidTypeDomain == TranslatedSidsEx2.Sids[i].Use ) {

                Rid = LSA_UNKNOWN_ID;

            } else if ( NULL != Sid ) {

                ULONG SubAuthCount = (ULONG) *RtlSubAuthorityCountSid(Sid);
                Rid = *RtlSubAuthoritySid(Sid, (SubAuthCount - 1));

            }

            TranslatedSids->Sids[i].Use = TranslatedSidsEx2.Sids[i].Use;
            TranslatedSids->Sids[i].RelativeId = Rid;
            TranslatedSids->Sids[i].DomainIndex = TranslatedSidsEx2.Sids[i].DomainIndex;
            TranslatedSids->Sids[i].Flags = TranslatedSidsEx2.Sids[i].Flags;

            if (TranslatedSidsEx2.Sids[i].Sid) {
                // N.B.  The SID is not an embedded field server side
                midl_user_free(TranslatedSidsEx2.Sids[i].Sid);
                TranslatedSidsEx2.Sids[i].Sid = NULL;
            }
        }

        //
        // Free the Ex structure
        //
        midl_user_free( TranslatedSidsEx2.Sids );

    } else {

        TranslatedSids->Entries = 0;
        midl_user_free( TranslatedSids->Sids );
        TranslatedSids->Sids = NULL;

    }

Cleanup:

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames2(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}



NTSTATUS
LsarLookupNames3(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames
    
    This function does not take an LSA RPC Context handle.  The access check
    performed is that the caller is NETLOGON.
    
--*/
{
    //
    // Access check is performed in LsarLookupNames3 when a NULL is passed in.
    //
    NTSTATUS Status;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames3(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupNames (PolicyHandle,
                              Count,
                              Names,
                              ReferencedDomains,
                              TranslatedSids,
                              LookupLevel,
                              MappedCount,
                              LookupOptions,
                              ClientRevision );


    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames3(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}


NTSTATUS
LsarLookupNames4(
    IN handle_t RpcHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )
/*++

Routine Description:

    See LsapLookupNames
    
    This function does not take an LSA RPC Context handle.  The access check
    performed is that the caller is NETLOGON.
    
--*/
{
    //
    // Access check is performed in LsarLookupNames3 when a NULL is passed in.
    //
    NTSTATUS Status;

    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames4(%ws) start\n", LsapDbLookupGetLevel(LookupLevel)) );

    Status = LsapLookupNames(NULL,
                             Count,
                             Names,
                             ReferencedDomains,
                             TranslatedSids,
                             LookupLevel,
                             MappedCount,
                             LookupOptions,
                             ClientRevision );


    LsapDiagPrint( DB_LOOKUP_WORK_LIST, ("LSA: LsarLookupNames4(%ws) end (0x%x)\n", LsapDbLookupGetLevel(LookupLevel), Status) );

    return Status;
}


NTSTATUS
LsapLookupNames(
    IN LSAPR_HANDLE PolicyHandle,
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    OUT PLSAPR_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN LSAP_LOOKUP_LEVEL LookupLevel,
    IN OUT PULONG MappedCount,
    IN ULONG LookupOptions,
    IN ULONG ClientRevision
    )

/*++

Routine Description:

    This function is the LSA server worker routine for the LsaLookupNames
    API.

    The LsaLookupNames API attempts to translate names of domains, users,
    groups or aliases to Sids.  The caller must have POLICY_LOOKUP_NAMES
    access to the Policy object.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.
       /
    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    This function is the LSA server RPC worker routine for the
    LsaLookupNames API.

    PolicyHandle -  Handle from an LsaOpenPolicy call.

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    ReferencedDomains - Receives a pointer to a structure describing the
        domains used for the translation.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for
        each translated name, this structure will only contain one
        component for each domain utilized in the translation.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    TranslatedSids - Pointer to a structure which will (or already) references an array of
        records describing each translated Sid.  The nth entry in this array
        provides a translation for the nth element in the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    LookupLevel - Specifies the Level of Lookup to be performed on this
        machine.  Values of this field are are follows:

        LsapLookupWksta - First Level Lookup performed on a workstation
            normally configured for Windows-Nt.   The lookup searches the
            Well-Known Sids/Names, and the Built-in Domain and Account Domain
            in the local SAM Database.  If not all Sids or Names are
            identified, performs a "handoff" of a Second level Lookup to the
            LSA running on a Controller for the workstation's Primary Domain
            (if any).

        LsapLookupPDC - Second Level Lookup performed on a Primary Domain
            Controller.  The lookup searches the Account Domain of the
            SAM Database on the controller.  If not all Sids or Names are
            found, the Trusted Domain List (TDL) is obtained from the
            LSA's Policy Database and Third Level lookups are performed
            via "handoff" to each Trusted Domain in the List.

        LsapLookupTDL - Third Level Lookup performed on a controller
            for a Trusted Domain.  The lookup searches the Account Domain of
            the SAM Database on the controller only.

     MappedCount - Pointer to location that contains a count of the Names
         mapped so far. On exit, this will be updated.
         

     LookupOptions -- 
     
            LSA_LOOKUP_ISOLATED_AS_LOCAL
            
            This flags controls the lookup API's such that isolated names, including
            UPN's are not searched for off the machine.  Composite names 
            (domain\username) are still sent off machine if necessary.

     
     ClientRevision -- the revision, wrt to lookup code, of the client

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_SUCCESS - The call completed successfully and all Names have
            been translated to Sids.

        STATUS_SOME_NOT_MAPPED - At least one of the names provided was
            trasnlated to a Sid, but not all names could be translated. This
            is a success status.

        STATUS_NONE_MAPPED - None of the names provided could be translated
            to Sids.  This is an error status, but output is returned.  Such
            output includes partial translations of names whose domain could
            be identified.

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS, SecondaryStatus = STATUS_SUCCESS;
    NTSTATUS TempStatus;
    ULONG DomainIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    LSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation;
    LSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation;
    LSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation;
    ULONG NullNameCount = 0;
    ULONG NameIndex;
    PLSAPR_TRANSLATED_SID_EX2 OutputSids;
    PLSAPR_TRUST_INFORMATION Domains = NULL;
    ULONG OutputSidsLength;
    ULONG CompletelyUnmappedCount = Count;
    ULONG LocalDomainsToSearch = 0;

    PLSAPR_UNICODE_STRING PrefixNames = NULL;
    PLSAPR_UNICODE_STRING SuffixNames = NULL;
    LSAPR_UNICODE_STRING BackSlash;
    BOOLEAN fDownlevelSecureChannel = FALSE;

    ULONG DomainLookupScope = 0;
    ULONG PreviousMappedCount = 0;


    LsarpReturnCheckSetup();

    LsapTraceEvent(EVENT_TRACE_TYPE_START, LsaTraceEvent_LookupNames);

    BuiltInDomainTrustInformation.Name.Buffer = NULL;
    BuiltInDomainTrustInformation.Sid = NULL;

    AccountDomainTrustInformation.DomainName.Buffer = NULL;
    AccountDomainTrustInformation.FlatName.Buffer = NULL;
    AccountDomainTrustInformation.Sid = NULL;

    PrimaryDomainTrustInformation.DomainName.Buffer = NULL;
    PrimaryDomainTrustInformation.FlatName.Buffer = NULL;
    PrimaryDomainTrustInformation.Sid = NULL;

    ASSERT( Count < 1000 );

    //
    // If there are no completely unmapped Names remaining, return.
    //

    if (CompletelyUnmappedCount == (ULONG) 0) {

        goto LookupNamesFinish;
    }

    if ((LookupOptions & LSA_LOOKUP_ISOLATED_AS_LOCAL) != 0
     &&  LookupLevel != LsapLookupWksta  ) {

        //
        // LSA_LOOKUP_ISOLATED_AS_LOCAL is only valid on workstation lookups 
        //
        Status = STATUS_INVALID_PARAMETER;
        goto LookupNamesFinish;
    }


    //
    // Validate that all of the names are valid.  Unfortunately, we must do it here, since
    // we actually process each of the entries before we loop through them below.
    //
    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        if ( !LsapValidateLsaUnicodeString( &Names[ NameIndex ] ) ) {

            Status = STATUS_INVALID_PARAMETER;
            goto LookupNamesError;
        }
    }

    //
    // Perform an access check
    //
    Status =  LsapDbLookupAccessCheck( PolicyHandle );
    if (!NT_SUCCESS(Status)) {
        goto LookupNamesError;
    }


    //
    // Determine what scope of resolution to use
    //
    DomainLookupScope = LsapGetDomainLookupScope(LookupLevel,
                                                 ClientRevision);


    //
    // Names provided are either Isolated, consisting of a single
    // component, or composite, having the form
    //
    // <DomainName>\<SuffixName>
    //
    // Split the list of names into two separate arrays, one containing
    // the Domain Prefixes (or NULL strings) and the other array
    // containing the Terminal Names.  Both arrays are the same size
    // as the original.  First, allocate memory for the output arrays
    // of UNICODE_STRING structures.
    //

    Status = STATUS_INSUFFICIENT_RESOURCES;

    PrefixNames = MIDL_user_allocate( Count * sizeof( UNICODE_STRING ));

    if (PrefixNames == NULL) {

        goto LookupNamesError;
    }

    SuffixNames = MIDL_user_allocate( Count * sizeof( UNICODE_STRING ));

    if (SuffixNames == NULL) {

        goto LookupNamesError;
    }

    RtlInitUnicodeString( (PUNICODE_STRING) &BackSlash, L"\\" );

    LsapRtlSplitNames(
        (PUNICODE_STRING) Names,
        Count,
        (PUNICODE_STRING) &BackSlash,
        (PUNICODE_STRING) PrefixNames,
        (PUNICODE_STRING) SuffixNames
        );

    //
    // Note that due to the IN/OUT nature of TranslatedSids, it is
    // possible that a client can pass something into the Sids field.
    // However, NT clients do not so it is safe, and correct to free
    // any values at this point.  Not doing so would mean a malicious
    // client could cause starve the server.
    //
    if ( TranslatedSids->Sids ) {

        MIDL_user_free( TranslatedSids->Sids );
    }

    TranslatedSids->Sids = NULL;
    TranslatedSids->Entries = 0;
    *ReferencedDomains = NULL;

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupTDL)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestReferral)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // Now that parameter checks have been done, fork off if this
    // is an XForest request
    //
    if (LookupLevel == LsapLookupXForestReferral) {

        BOOLEAN fAllocateAllNodes = FALSE;
        NTSTATUS Status2;

        //
        // Note that LsapDbLookupNamesInTrustedForestsWorker will allocate
        // the OUT parameters
        //
        *MappedCount = 0;

        Status = LsapDbLookupNamesInTrustedForestsWorker(Count,
                                                         Names,
                                                         PrefixNames,
                                                         SuffixNames,
                                                         ReferencedDomains,
                                                         TranslatedSids,
                                                         &fAllocateAllNodes,
                                                         MappedCount,
                                                         LookupOptions,
                                                         &SecondaryStatus);

        if (fAllocateAllNodes) {

            //
            // Reallocate the memory in a form the server can return to RPC
            //
            Status2 = LsapLookupReallocateTranslations((PLSA_REFERENCED_DOMAIN_LIST *)ReferencedDomains,
                                                       Count,
                                                       NULL,
                                                       (PLSA_TRANSLATED_SID_EX2 * ) &TranslatedSids->Sids);
            if (!NT_SUCCESS(Status2)) {
                //
                // This is a fatal resource error - free the memory that 
                // was returned to us by the chaining call
                //
                if (*ReferencedDomains) {
                    midl_user_free(*ReferencedDomains);
                    *ReferencedDomains = NULL;
                }
                if (TranslatedSids->Sids) {
                    midl_user_free(TranslatedSids->Sids);
                    TranslatedSids->Sids = NULL;
                    TranslatedSids->Entries = 0;
                }
                Status = Status2;
            }
        }

        //
        // There is nothing more to do
        //
        goto LookupNamesFinish;
    }


    //
    // Allocate Output Sids array buffer.
    //

    OutputSidsLength = Count * sizeof(LSA_TRANSLATED_SID_EX2);
    OutputSids = MIDL_user_allocate(OutputSidsLength);

    if (OutputSids == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto LookupNamesError;
    }

    TranslatedSids->Entries = Count;
    TranslatedSids->Sids = OutputSids;

    //
    // Initialize the Output Sids array.  Zeroise all fields, then
    // Mark all of the Output Sids as being unknown initially and
    // set the DomainIndex fields to a negative number meaning
    // "no domain"
    //

    RtlZeroMemory( OutputSids, OutputSidsLength);

    for (NameIndex = 0; NameIndex < Count; NameIndex++) {

        OutputSids[NameIndex].Use = SidTypeUnknown;
        OutputSids[NameIndex].DomainIndex = LSA_UNKNOWN_INDEX;
    }

    //
    // Create an empty Referenced Domain List.
    //

    Status = LsapDbLookupCreateListReferencedDomains( ReferencedDomains, 0 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }

    //
    // Obtain the Trust Information for the
    // Built-in, Account and Primary Domains.
    //

    Status = LsapDbLookupLocalDomains(
                 &BuiltInDomainTrustInformation,
                 &AccountDomainTrustInformation,
                 &PrimaryDomainTrustInformation
                 );

    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }

    if ( ((DomainLookupScope & LSAP_LOOKUP_DNS_SUPPORT) == 0)
      && (LookupLevel == LsapLookupPDC)  ) {
        //
        // We don't want to expose dns names to downlevel
        // clients
        //
        RtlInitUnicodeString( (UNICODE_STRING*) &AccountDomainTrustInformation.DomainName, NULL );
        RtlInitUnicodeString( (UNICODE_STRING*) &PrimaryDomainTrustInformation.DomainName, NULL );

    }

    //
    // The local domains to be searched always include the Accounts
    // domain.  For initial lookup targets only, the BUILT_IN domain is
    // also searched.
    //

    LocalDomainsToSearch = LSAP_DB_SEARCH_ACCOUNT_DOMAIN;

    if (LookupLevel == LsapLookupWksta) {


        LocalDomainsToSearch |= LSAP_DB_SEARCH_BUILT_IN_DOMAIN;

        //
        // This is the lowest Lookup Level, normally targeted at a
        // Workstation.
        //

    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupTDL)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestResolve) );

    Status = LsapDbLookupSimpleNames(
                 Count,
                 LookupLevel,
                 Names,
                 PrefixNames,
                 SuffixNames,
                 &BuiltInDomainTrustInformation,
                 &AccountDomainTrustInformation,
                 &PrimaryDomainTrustInformation,
                 *ReferencedDomains,
                 TranslatedSids,
                 MappedCount,
                 &CompletelyUnmappedCount
                 );
    
    if (!NT_SUCCESS(Status)) {

        goto LookupNamesError;
    }


    //
    // If all Names are now mapped or partially mapped, or only zero
    // length names remain, finish.
    //

    NullNameCount = 0;

    for( NameIndex = 0; NameIndex < Count; NameIndex++) {

        if (Names[NameIndex].Length == 0) {

            NullNameCount++;
        }
    }

    if (CompletelyUnmappedCount == NullNameCount) {

        goto LookupNamesFinish;
    }

    //
    // There are some remaining unmapped Names.  They may belong to a
    // local SAM Domain.  Currently, there are two such domains, the
    // Built-in Domain and the Accounts Domain.  Search these
    // domains now, excluding the BUILT_IN domain from higher level
    // searches.
    //

    if ( LookupLevel != LsapLookupGC ) {

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupTDL)
             || (LookupLevel == LsapLookupXForestResolve) );
        
        Status = LsapDbLookupNamesInLocalDomains(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     &BuiltInDomainTrustInformation,
                     &AccountDomainTrustInformation,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     LocalDomainsToSearch
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesError;
        }
    }

    //
    // If all Names apart from NULL names are now mapped, finish.
    //

    if (CompletelyUnmappedCount == NullNameCount) {

        goto LookupNamesFinish;
    }

    //
    // Not all of the Names have been identified in the local domain(s).
    // The next step in the search depends on the level of this lookup
    // and how we are configured as follows:
    //
    // Lookup Level         Configuration       Lookup search next
    //
    // LsapLookupWksta      Win Nt              Primary Domain
    //                      LanMan Nt           Trusted Domains
    //
    // LsapLookupPDC        Win Nt              error
    //                      LanMan Nt           Trusted Domains
    //
    // LsaLookupTDL         Win Nt              error
    //                      LanMan Nt           none
    //

    if (LookupLevel == LsapLookupWksta) {

        if (LsapProductType != NtProductLanManNt) {

            ULONG MappedByCache = *MappedCount;
            
            //
            // Try the cache first
            //
            Status = LsapDbMapCachedNames(
                        LookupOptions,
                        (PUNICODE_STRING) SuffixNames,
                        (PUNICODE_STRING) PrefixNames,
                        Count,
                        FALSE,          // don't use old entries
                        *ReferencedDomains,
                        TranslatedSids,
                        MappedCount
                        );
            if (!NT_SUCCESS(Status)) {
                goto LookupNamesError;
            }
            
            MappedByCache = *MappedCount - MappedByCache;
            CompletelyUnmappedCount -= MappedByCache;
            
            if (*MappedCount == Count) {
                goto LookupNamesFinish;
            }
            
            //
            // If there is no Primary Domain as in the case of a WORKGROUP,
            // just finish up.  Set a default result code STATUS_SUCCESS.
            //
            Status = STATUS_SUCCESS;
            if (PrimaryDomainTrustInformation.Sid == NULL) {
            
                goto LookupNamesFinish;
            }
            
            //
            // There is a Primary Domain.  Search it for Names.  Since a
            // Primary Domain is also a Trusted Domain, we use the
            // Trusted Domain search routine.  This routine will "hand off"
            // the search to a Domain Controller's LSA.
            //
            Status = LsapDbLookupNamesInPrimaryDomain(
                         LookupOptions,
                         Count,
                         Names,
                         PrefixNames,
                         SuffixNames,
                         &PrimaryDomainTrustInformation,
                         *ReferencedDomains,
                         TranslatedSids,
                         LsapLookupPDC,
                         MappedCount,
                         &CompletelyUnmappedCount,
                         &fDownlevelSecureChannel,
                         &TempStatus
                         );
            
            if (!NT_SUCCESS(Status)) {
            
                goto LookupNamesError;
            }
            
            if (TempStatus == STATUS_TRUSTED_RELATIONSHIP_FAILURE) {
            
                //
                // We could not talk to a DC -- Hit the cache again
                // looking for non-expired entries
                //
                MappedByCache = *MappedCount;
            
                Status = LsapDbMapCachedNames(LookupOptions,
                                              (PUNICODE_STRING) SuffixNames,
                                              (PUNICODE_STRING) PrefixNames,
                                              Count,
                                              TRUE,               // Use old entries
                                             *ReferencedDomains,
                                              TranslatedSids,
                                              MappedCount);
            
                if (!NT_SUCCESS(Status)) {
                    //
                    // This is a fatal resource error
                    //
                    goto LookupNamesError;
            
                }
            
                MappedByCache = *MappedCount - MappedByCache;
                CompletelyUnmappedCount -= MappedByCache;
            
            }
            
            if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
                SecondaryStatus = TempStatus;
            }
            
            
            //
            // If we are talking to a downlevel server and we are in an 
            // nt5 domain, then attempt to resolve the unresolved names at a GC
            //
            if ( fDownlevelSecureChannel
              && PrimaryDomainTrustInformation.DomainName.Length > 0  ) {
            
                Status = LsapDbLookupNamesInGlobalCatalogWks(
                             LookupOptions,
                             Count,
                             Names,
                             PrefixNames,
                             SuffixNames,
                             *ReferencedDomains,
                             TranslatedSids,
                             MappedCount,
                             &CompletelyUnmappedCount,
                             &TempStatus
                             );
            
                if (!NT_SUCCESS(Status)) {
            
                    goto LookupNamesError;
                }
            
                if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
                    SecondaryStatus = TempStatus;
                }
                
            }

            goto LookupNamesFinish;
        }
    }

    //
    // We reach here in two cases:
    //
    // * Initial Level lookups targeted at DC's
    // * Higher Level Lookups (must be targeted at DC's)
    //
    // For the highest level lookup, that on an individual TDC, there
    // is no more searching to do, since we have already searched the
    // Accounts Domain and we do not follow trust relationships on DC's
    // beyond one level.
    //

    if (LookupLevel == LsapLookupTDL) {

        goto LookupNamesFinish;
    }

    ASSERT( (LookupLevel == LsapLookupWksta)
         || (LookupLevel == LsapLookupPDC)
         || (LookupLevel == LsapLookupGC)
         || (LookupLevel == LsapLookupXForestResolve) );

    //
    // We are either the initial target of the lookup but not configured
    // as a workstation, or we are the target of a Primary Domain
    // level lookup.  In either case, we must be configured as a DC.
    //

    if (LsapProductType != NtProductLanManNt) {

        Status = STATUS_DOMAIN_CTRLR_CONFIG_ERROR;
        goto LookupNamesError;
    }


    if (DomainLookupScope & LSAP_LOOKUP_RESOLVE_ISOLATED_DOMAINS) {

        //
        // Check for isolated domain names
        //
    
        PreviousMappedCount = *MappedCount;
        Status =  LsapDbLookupNamesAsDomainNames(DomainLookupScope,
                                                 Count,
                                                 Names,
                                                 PrefixNames,
                                                 SuffixNames,
                                                 *ReferencedDomains,
                                                 TranslatedSids,
                                                 MappedCount);
        
        if (!NT_SUCCESS(Status)) {
            goto LookupNamesError;
        }
        CompletelyUnmappedCount -= (*MappedCount - PreviousMappedCount);
    
        //
        // If all of the Names have now been mapped, finish.
        //
    
        if (*MappedCount == Count) {
    
            goto LookupNamesFinish;
        }
    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE) {
        
        //
        // Search in a global catalog for names that belong to post nt4 domains
        //
        Status = LsapDbLookupNamesInGlobalCatalog(
                     LookupOptions,
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );
    
        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_FOREST) {

        ASSERT( (LookupLevel == LsapLookupWksta)
             || (LookupLevel == LsapLookupPDC)
             || (LookupLevel == LsapLookupGC));

        Status = LsapDbLookupNamesInTrustedForests(
                     LookupOptions,
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }

    }

    if (DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_DIRECT) {

        ASSERT((LookupLevel == LsapLookupWksta)
            || (LookupLevel == LsapLookupPDC));

        //
        // Search all of the Trusted Domains
        //
        Status = LsapDbLookupNamesInTrustedDomains(
                     LookupOptions,
                     Count,
                     !(DomainLookupScope & LSAP_LOOKUP_TRUSTED_DOMAIN_TRANSITIVE), 
                                          // if we didn't go the GC, then 
                                          // include intraforest trusts
                     Names,
                     PrefixNames,
                     SuffixNames,
                     *ReferencedDomains,
                     TranslatedSids,
                     LsapLookupTDL,
                     MappedCount,
                     &CompletelyUnmappedCount,
                     &TempStatus
                     );

        if (!NT_SUCCESS(Status)) {
    
            goto LookupNamesError;
        }
    
        if ( !NT_SUCCESS( TempStatus ) && NT_SUCCESS( SecondaryStatus ) ) {
            SecondaryStatus = TempStatus;
        }
    }

LookupNamesFinish:

    //
    // If some but not all Names were mapped, return informational status
    // STATUS_SOME_NOT_MAPPED.  If no Names were mapped, return error
    // STATUS_NONE_MAPPED. Note that we expect and STATUS_NONE_MAPPED
    // errors returned by called routines to have been suppressed before
    // we get here.  The reason for this is that we need to calculate
    // the return Status based on the whole set of Names, not some subset
    //

    if (NT_SUCCESS(Status)) {

        if (*MappedCount < Count) {

            Status = STATUS_SOME_NOT_MAPPED;

            if (*MappedCount == 0) {

                Status = STATUS_NONE_MAPPED;
            }
        }
    }

    //
    // If no names could be mapped it is likely due to the
    // secondary status
    //
    if (  (STATUS_NONE_MAPPED == Status)
       && (STATUS_NONE_MAPPED != SecondaryStatus)
       && LsapRevisionCanHandleNewErrorCodes( ClientRevision )
       && !NT_SUCCESS( SecondaryStatus ) ) {

        Status = SecondaryStatus;
        goto LookupNamesError;
    }


    //
    // If necessary, free the arrays of PrefixNames and SuffixNames
    //

    if (PrefixNames != NULL) {

        MIDL_user_free(PrefixNames);
    }

    if (SuffixNames != NULL) {

        MIDL_user_free(SuffixNames);
    }


    LsapTraceEvent(EVENT_TRACE_TYPE_END, LsaTraceEvent_LookupNames);
    LsarpReturnPrologue();

    return(Status);

LookupNamesError:

    //
    // If the LookupLevel is the lowest (Workstation Level) free up
    // the Sids and Referenced Domains arrays.
    //

    if (LookupLevel == LsapLookupWksta) {

        //
        // If necessary, free the Sids array.
        //

        if (TranslatedSids->Sids != NULL) {

            ULONG i;
            for (i = 0; i < TranslatedSids->Entries; i++) {
                if (TranslatedSids->Sids[i].Sid) {
                    // N.B.  The SID is not an embedded field server side
                    MIDL_user_free(TranslatedSids->Sids[i].Sid);
                    TranslatedSids->Sids[i].Sid = NULL;
                }
            }
            MIDL_user_free( TranslatedSids->Sids );
            TranslatedSids->Sids = NULL;
        }

        //
        // If necessary, free the Referenced Domain List.
        //

        if (*ReferencedDomains != NULL) {

            Domains = (*ReferencedDomains)->Domains;

            if (Domains != NULL) {

                for (DomainIndex = 0;
                     DomainIndex < (*ReferencedDomains)->Entries;
                     DomainIndex++) {

                    if (Domains[ DomainIndex ].Name.Buffer != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Name.Buffer );
                        Domains[ DomainIndex ].Name.Buffer = NULL;
                    }

                    if (Domains[ DomainIndex ].Sid != NULL) {

                        MIDL_user_free( Domains[ DomainIndex ].Sid );
                        Domains[ DomainIndex ].Sid = NULL;
                    }
                }

                MIDL_user_free( ( *ReferencedDomains)->Domains );

            }

            MIDL_user_free( *ReferencedDomains );
            *ReferencedDomains = NULL;
        }
    }

    //
    // If the primary status was a success code, but the secondary
    // status was an error, propagate the secondary status.
    //

    if ((!NT_SUCCESS(SecondaryStatus)) && NT_SUCCESS(Status)) {

        Status = SecondaryStatus;
    }

    goto LookupNamesFinish;
}


NTSTATUS
LsapDbEnumerateNames(
    IN LSAPR_HANDLE ContainerHandle,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    OUT PLSAP_DB_NAME_ENUMERATION_BUFFER DbEnumerationBuffer,
    IN ULONG PreferedMaximumLength
    )

/*++

Routine Description:

    This function enumerates Names of objects of a given type within a container
    object.  Since there may be more information than can be returned in a
    single call of the routine, multiple calls can be made to get all of the
    information.  To support this feature, the caller is provided with a
    handle that can be used across calls.  On the initial call,
    EnumerationContext should point to a variable that has been initialized
    to 0.

Arguments:

    ContainerHandle -  Handle to a container object.

    ObjectTypeId - Type of object to be enumerated.  The type must be one
        for which all objects have Names.

    EnumerationContext - API-specific handle to allow multiple calls
        (see Routine Description above).

    DbEnumerationBuffer - Receives a pointer to a structure that will receive
        the count of entries returned in an enumeration information array, and
        a pointer to the array.  Currently, the only information returned is
        the object Names.  These Names may be used together with object type to
        open the objects and obtain any further information available.

    PreferedMaximumLength - prefered maximum length of returned data (in 8-bit
        bytes).  This is not a hard upper limit, but serves as a guide.  Due to
        data conversion between systems with different natural data sizes, the
        actual amount of data returned may be greater than this value.

    CountReturned - Pointer to variable which will receive a count of the
        entries returned.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_NO_MORE_ENTRIES - There are no more entries.  This warning
            is returned if there are no more objects to enumerate.  Note that
            zero or more objects may be enumerated on a call that returns this
            reply.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    LSAP_DB_ENUMERATION_ELEMENT LastElement;
    PLSAP_DB_ENUMERATION_ELEMENT FirstElement, NextElement = NULL, FreeElement;
    ULONG DataLengthUsed;
    ULONG ThisBufferLength;
    PUNICODE_STRING Names = NULL;
    BOOLEAN PreferedMaximumReached = FALSE;
    ULONG EntriesRead;
    ULONG Index, EnumerationIndex;
    BOOLEAN TrustedClient = ((LSAP_DB_HANDLE) ContainerHandle)->Trusted;

    LastElement.Next = NULL;
    FirstElement = &LastElement;

    //
    // If no enumeration buffer provided, return an error.
    //

    if ( (!ARGUMENT_PRESENT(DbEnumerationBuffer)) ||
         (!ARGUMENT_PRESENT(EnumerationContext ))  ) {

        return(STATUS_INVALID_PARAMETER);
    }


    //
    // Enumerate objects, stopping when the length of data to be returned
    // reaches or exceeds the Prefered Maximum Length, or reaches the
    // absolute maximum allowed for LSA object enumerations.  We allow
    // the last object enumerated to bring the total amount of data to
    // be returned beyond the Prefered Maximum Length, but not beyond the
    // absolute maximum length.
    //

    EnumerationIndex = *EnumerationContext;

    for(DataLengthUsed = 0, EntriesRead = 0;
        DataLengthUsed < PreferedMaximumLength;
        DataLengthUsed += ThisBufferLength, EntriesRead++) {

        //
        // If the absolute maximum length has been exceeded, back off
        // the last object enumerated.
        //

        if ((DataLengthUsed > LSA_MAXIMUM_ENUMERATION_LENGTH) &&
            (!TrustedClient)) {

            //
            // If PrefMaxLength is zero, NextElement may be NULL.
            //

            if (NextElement != NULL) {
                FirstElement = NextElement->Next;
                MIDL_user_free(NextElement);
            }
            break;
        }

        //
        // Allocate memory for next enumeration element.  Set the Name
        // field to NULL for cleanup purposes.
        //

        NextElement = MIDL_user_allocate(sizeof (LSAP_DB_ENUMERATION_ELEMENT));

        if (NextElement == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        //
        // Find the next object's Name, and fill in its object information.
        // Note that memory will be allocated via MIDL_user_allocate
        // and must be freed when no longer required.
        //

        Status = LsapDbFindNextName(
                     ContainerHandle,
                     &EnumerationIndex,
                     ObjectTypeId,
                     (PLSAPR_UNICODE_STRING) &NextElement->Name
                     );

        //
        // Stop the enumeration if any error or warning occurs.  Note
        // that the warning STATUS_NO_MORE_ENTRIES will be returned when
        // we've gone beyond the last index.
        //

        if (Status != STATUS_SUCCESS) {

            break;
        }

        //
        // Get the length of the data allocated for the object's Name
        //

        ThisBufferLength = NextElement->Name.Length;

        //
        // Link the object just found to the front of the enumeration list
        //

        NextElement->Next = FirstElement;
        FirstElement = NextElement;
    }

    //
    // If an error other than STATUS_NO_MORE_ENTRIES occurred, return it.
    //

    if ((Status != STATUS_NO_MORE_ENTRIES) && !NT_SUCCESS(Status)) {

        goto EnumerateNamesError;
    }

    //
    // The enumeration is complete or has terminated because of return
    // buffer limitations.  If no entries were read, return.
    //

    if (EntriesRead != 0) {


        //
        // Some entries were read, allocate an information buffer for returning
        // them.
        //

        Names = MIDL_user_allocate( sizeof (UNICODE_STRING) * EntriesRead );

        if (Names == NULL) {

            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto EnumerateNamesError;
        }

        //
        // Memory was successfully allocated for the return buffer.
        // Copy in the enumerated Names.
        //

        for (NextElement = FirstElement, Index = 0;
            NextElement != &LastElement;
            NextElement = NextElement->Next, Index++) {

            ASSERT(Index < EntriesRead);

            Names[Index] = NextElement->Name;
        }

        Status = STATUS_SUCCESS;

    } else {

        //
        // No entries available this call.
        //

        Status = STATUS_NO_MORE_ENTRIES;

    }

EnumerateNamesFinish:

    //
    // Free the enumeration element structures (if any).
    //

    for (NextElement = FirstElement; NextElement != &LastElement;) {

        //
        // If an error has occurred, dispose of memory allocated
        // for any Names.
        //

        if (!(NT_SUCCESS(Status) || (Status == STATUS_NO_MORE_ENTRIES))) {

            if (NextElement->Name.Buffer != NULL) {

                MIDL_user_free(NextElement->Name.Buffer);
            }
        }

        //
        // Free the memory allocated for the enumeration element.
        //

        FreeElement = NextElement;
        NextElement = NextElement->Next;

        MIDL_user_free(FreeElement);
    }

    //
    // Fill in return enumeration structure (0 and NULL in error case).
    //

    DbEnumerationBuffer->EntriesRead = EntriesRead;
    DbEnumerationBuffer->Names = Names;
    *EnumerationContext = EnumerationIndex;

    return(Status);

EnumerateNamesError:

    //
    // If necessary, free memory allocated for returning the Names.
    //

    if (Names != NULL) {

        MIDL_user_free( Names );
        Names = NULL;
    }

    goto EnumerateNamesFinish;
}


VOID
LsapDbUpdateCountCompUnmappedNames(
    OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function updates the count of completely unmapped names in a
    name lookup operation.  A name is completely unmapped if its domain
    is unknown.

Arguments:

    TranslatedSids - Pointer to a structure which will be initialized to
        reference an array of records describing each translated Sid.  The
        nth entry in this array provides a translation for the nth element in
        the Names parameter.

        When this information is no longer needed, it must be released
        by passing the returned pointer to LsaFreeMemory().

    CompletelyUnmappedCount - Pointer to location that will receive
        a count of completely unmapped Sids.  A Name is completely unmapped
        if it is isolated and unknown, or is composite and its Domain Prefix
        component is not recognized as a Domain Name.

Return Values:

    None

--*/

{
    ULONG Count = TranslatedSids->Entries;
    ULONG SidIndex;
    ULONG UpdatedCompletelyUnmappedCount = 0;

    for (SidIndex = 0; SidIndex < Count; SidIndex++) {

        if (TranslatedSids->Sids[SidIndex].DomainIndex == LSA_UNKNOWN_INDEX) {

            UpdatedCompletelyUnmappedCount++;
        }
    }

    ASSERT(UpdatedCompletelyUnmappedCount <= *CompletelyUnmappedCount);
    *CompletelyUnmappedCount = UpdatedCompletelyUnmappedCount;
}


NTSTATUS
LsapDbFindNextName(
    IN LSAPR_HANDLE ContainerHandle,
    IN OUT PLSA_ENUMERATION_HANDLE EnumerationContext,
    IN LSAP_DB_OBJECT_TYPE_ID ObjectTypeId,
    OUT PLSAPR_UNICODE_STRING NextName
    )

/*++

Routine Description:

    This function finds the next Name of object of a given type within a
    container object.  The given object type must be one where objects
    have Names.  The Names returned can be used on subsequent open calls to
    access the objects.

Arguments:

    ContainerHandle - Handle to container object.

    EnumerationContext - Pointer to a variable containing the index of
        the object to be found.  A zero value indicates that the first
        object is to be found.

    ObjectTypeId - Type of the objects whose Names are being enumerated.
        Ccurrently, this is restricted to objects (such as Secret Objects)
        that are accessed by Name only.

    NextName - Pointer to Unicode String that will be initialized to
        reference the next Name found.

Return Value:

    NTSTATUS - Standard Nt Result Code

        STATUS_INVALID_HANDLE - Invalid ContainerHandle specified

        STATUS_NO_MORE_ENTRIES - Warning that no more entries exist.
--*/

{
    NTSTATUS Status, SecondaryStatus;
    ULONG NameKeyValueLength = 0;
    LSAPR_UNICODE_STRING SubKeyNameU;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE ContDirKeyHandle = NULL;


    //
    // Setup object attributes for opening the appropriate Containing
    // Directory.  For example, if we're looking for Account objects,
    // the containing Directory is "Accounts".  The Unicode strings for
    // containing Directories are set up during Lsa Initialization.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &LsapDbContDirs[ObjectTypeId],
        OBJ_CASE_INSENSITIVE,
        ((LSAP_DB_HANDLE) ContainerHandle)->KeyHandle,
        NULL
        );

    //
    // If the object type is not accessed by Name only, return an error.
    // Currently, only Secret objects have this property.
    //


    if (ObjectTypeId != SecretObject) {
        return(STATUS_INVALID_PARAMETER);
    }

    Status = RtlpNtOpenKey(
                 &ContDirKeyHandle,
                 KEY_READ,
                 &ObjectAttributes,
                 0
                 );

    if (NT_SUCCESS(Status)) {

        //
        // Initialize the Unicode String in which the next object's Logical Name
        // will be returned.  The Logical Name of an object equals its Registry
        // Key relative to its Containing Directory, and is also equal to
        // the Relative Id of the object represented in character form as an
        // 8-digit number with leading zeros.
        //
        // NOTE: The size of buffer allocated for the Logical Name must be
        // calculated dynamically when the Registry supports long names, because
        // it is possible that the Logical Name of an object will be equal to a
        // character representation of the full Name, not just the Relative Id
        // part.
        //

        SubKeyNameU.MaximumLength = (USHORT) LSAP_DB_LOGICAL_NAME_MAX_LENGTH;
        SubKeyNameU.Length = 0;
        SubKeyNameU.Buffer = MIDL_user_allocate(SubKeyNameU.MaximumLength);

        if (SubKeyNameU.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            //
            // Now enumerate the next subkey.
            //

            Status = RtlpNtEnumerateSubKey(
                         ContDirKeyHandle,
                         (PUNICODE_STRING) &SubKeyNameU,
                         *EnumerationContext,
                         NULL
                         );

            if (NT_SUCCESS(Status)) {

                (*EnumerationContext)++;

                //
                // Return the Name.
                //

                *NextName = SubKeyNameU;

            } else {

                //
                // Not successful - free the subkey name buffer
                // Note that STATUS_NO_MORE_ENTRIES is a warning
                // (not a success) code.
                //

                MIDL_user_free( SubKeyNameU.Buffer );

                //
                // Set the out parameter so RPC doesn't try
                // to return anything.
                //

                NextName->Length = NextName->MaximumLength = 0;
                NextName->Buffer = NULL;

            }

        }

        //
        // Close the containing directory handle
        //

        SecondaryStatus = NtClose(ContDirKeyHandle);
        ASSERT(NT_SUCCESS(SecondaryStatus));
    }

    return(Status);

}


NTSTATUS
LsapDbLookupSimpleNames(
    IN ULONG Count,
    IN ULONG LookupLevel,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN PLSAPR_TRUST_INFORMATION BuiltInDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX AccountDomainTrustInformation,
    IN PLSAPR_TRUST_INFORMATION_EX PrimaryDomainTrustInformation,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify isolated names as the names of well known
    Sids or Domains present on the Lookup Path.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.

    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.

Return Values:

    NTSTATUS - Standard Nt Result Code

        STATUS_ACCESS_DENIED - Caller does not have the appropriate access
            to complete the operation.

        STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
            to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;


    //
    // First, lookup any Well Known Names
    //
    if ( LookupLevel == LsapLookupWksta ) {

        //
        // This lookup should only be done once and be done at the first
        // level
        //
        Status = LsapDbLookupWellKnownNames(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSimpleNamesError;
        }

        //
        // If all of the Names have now been mapped, finish.
        //

        if (*MappedCount == Count) {

            goto LookupSimpleNamesFinish;
        }
    }


    //
    // Next, attempt to identify Isolated Names as Domain Names
    //
    if (  (LookupLevel == LsapLookupWksta)
       || (LookupLevel == LsapLookupPDC) ) {

        //
        // This step should be done once at the first level to findstr
        // local domain names (ie local accounts at a workstation) and
        // then again at second level to find trusted domain names
        //

        Status = LsapDbLookupIsolatedDomainNames(
                     Count,
                     Names,
                     PrefixNames,
                     SuffixNames,
                     BuiltInDomainTrustInformation,
                     AccountDomainTrustInformation,
                     PrimaryDomainTrustInformation,
                     ReferencedDomains,
                     TranslatedSids,
                     MappedCount,
                     CompletelyUnmappedCount
                     );

        if (!NT_SUCCESS(Status)) {

            goto LookupSimpleNamesError;
        }
    }

LookupSimpleNamesFinish:

    return(Status);

LookupSimpleNamesError:

    goto LookupSimpleNamesFinish;
}


NTSTATUS
LsapDbLookupWellKnownNames(
    IN ULONG Count,
    IN PLSAPR_UNICODE_STRING Names,
    IN PLSAPR_UNICODE_STRING PrefixNames,
    IN PLSAPR_UNICODE_STRING SuffixNames,
    IN OUT PLSAPR_REFERENCED_DOMAIN_LIST ReferencedDomains,
    IN OUT PLSAPR_TRANSLATED_SIDS_EX2 TranslatedSids,
    IN OUT PULONG MappedCount,
    IN OUT PULONG CompletelyUnmappedCount
    )

/*++

Routine Description:

    This function attempts to identify names as the names of well known Sids.

    Names may be either isolated (e.g. JohnH) or composite names containing
    both the domain name and account name.  Composite names must include a
    backslash character separating the domain name from the account name
    (e.g. Acctg\JohnH).  An isolated name may be either an account name
    (user, group, or alias) or a domain name.

    Translation of isolated names introduces the possibility of name
    collisions (since the same name may be used in multiple domains).  An
    isolated name will be translated using the following algorithm:

    If the name is a well-known name (e.g. Local or Interactive), then the
    corresponding well-known Sid is returned.

    If the name is the Built-in Domain's name, then that domain's Sid
    will be returned.

    If the name is the Account Domain's name, then that domain's Sid
    will be returned.

    If the name is the Primary Domain's name, then that domain's Sid will
    be returned.

    If the name is the name of one of the Primary Domain's Trusted Domains,
    then that domain's Sid will be returned.

    If the name is a user, group, or alias in the Built-in Domain, then the
    Sid of that account is returned.

    If the name is a user, group, or alias in the Primary Domain, then the
    Sid of that account is returned.

    Otherwise, the name is not translated.

    NOTE: Proxy, Machine, and Trust user accounts are not referenced
    for name translation.  Only normal user accounts are used for ID
    translation.  If translation of other account types is needed, then
    SAM services should be used directly.

Arguments:

    Count - Specifies the number of names to be translated.
    
    Names - Pointer to an array of Count Unicode String structures
        specifying the names to be looked up and mapped to Sids.
        The strings may be names of User, Group or Alias accounts or
        domains.

    PrefixNames - Pointer to an array of Count Unicode String structures
        containing the Prefix portions of the Names.  Names having no
        Prefix are called Isolated Names.  For these, the Unicode String
        structure is set to contain a zero Length.

    SuffixNames - Pointer to an array of Count Unicode String structures
        containing the Suffix portions of the Names.

    ReferencedDomains - Pointer to a structure in which the list of domains
        used in the translation is maintained.  The entries in this structure
        are referenced by the structure returned via the Sids parameter.
        Unlike the Sids parameter, which contains an array entry for each
        translated name, this structure will only contain one component for
        each domain utilized in the translation.

    TranslatedSids - Pointer to a structure in which the translations to Sids
        corresponding to the Names specified on Names is maintained.  The
        nth entry in this array provides a translation (where known) for the
        nth element in the Names parameter.

    MappedCount - Pointer to location in which a count of the Names that
        have been completely translated is maintained.

    CompletelyUnmappedCount - Pointer to a location in which a count of the
        Names that have not been translated (either partially, by identification
        of a Domain Prefix, or completely) is maintained.
        
Return Values:

    NTSTATUS - Standard Nt Result Code

    STATUS_SUCCESS - The call completed successfully.  Note that some
        or all of the Names may remain partially or completely unmapped.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate access
        to complete the operation.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient system resources
        to complete the call.
--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG UpdatedMappedCount;
    ULONG NameNumber;
    ULONG UnmappedNamesRemaining;
    PLSAPR_TRANSLATED_SID_EX2 OutputSids;
    LSAP_WELL_KNOWN_SID_INDEX WellKnownSidIndex;
    LSAPR_TRUST_INFORMATION TrustInformation;
    UCHAR SubAuthorityCount;
    PLSAPR_SID Sid = NULL;
    PLSAPR_SID PrefixSid = NULL;
    ULONG PrefixSidLength;
    ULONG RelativeId;
    OutputSids = TranslatedSids->Sids;

    //
    // Initialize output parameters.
    //

    *MappedCount = UpdatedMappedCount = 0;
    UnmappedNamesRemaining = Count - UpdatedMappedCount;

    //
    // Attempt to identify Names as Well Known Isolated Names
    //

    for (NameNumber = 0;
         (NameNumber < Count) && (UnmappedNamesRemaining > 0);
         NameNumber++) {

        //
        // Examine the next entry in the Names array.  If the corresponding
        // translated Sid entry has SidTypeUnknown for its Use field, the
        // name has not been translated.
        //

        if (OutputSids[NameNumber].Use == SidTypeUnknown) {

            //
            // Attempt to identify the name as the name of a Well Known Sid
            // by using the Well Known Sids table.  We skip entries in the
            // table for Sids that are also in the Built In domain.  For
            // those, we drop through to the Built in Domain search.  Note
            // that only one of these, the Administrators alias is currently
            // present in the table.
            //

            DWORD   dwMatchType = LOOKUP_MATCH_NONE;

            UNICODE_STRING  NTAuthorityName = { sizeof(NTAUTHORITY_NAME) - 2,
                                                sizeof(NTAUTHORITY_NAME),
                                                NTAUTHORITY_NAME };

            if (PrefixNames[NameNumber].Length == 0)
            {
                dwMatchType = LOOKUP_MATCH_BOTH;
            }
            else if (RtlEqualUnicodeString( (PUNICODE_STRING) &PrefixNames[NameNumber],
                                             &WellKnownSids[LsapLocalSystemSidIndex].DomainName,
                                             TRUE) )
            {
                dwMatchType = LOOKUP_MATCH_LOCALIZED;
            }


            if (RtlEqualUnicodeString( (PUNICODE_STRING) &PrefixNames[NameNumber],
                                       &NTAuthorityName,
                                       TRUE) )
            {
                if (dwMatchType == LOOKUP_MATCH_NONE)
                {
                    dwMatchType = LOOKUP_MATCH_HARDCODED;
                }
                else
                {
                    ASSERT(dwMatchType == LOOKUP_MATCH_LOCALIZED);
                    dwMatchType = LOOKUP_MATCH_BOTH;
                }
            }


            //
            // Ignore SIDs from the BUILTIN domain since their names may
            // change (i.e., we always want SAM to resolve those with the
            // most up-to-date information).
            //

            if ((dwMatchType != LOOKUP_MATCH_NONE)
                 &&
                LsapDbLookupIndexWellKnownName(
                    &SuffixNames[NameNumber],
                    &WellKnownSidIndex,
                    dwMatchType)
                 &&
                !SID_IS_RESOLVED_BY_SAM(WellKnownSidIndex))
            {
                //
                // Name is identified.  Obtain its Sid.  If the
                // SubAuthorityCount for the Sid is positive, extract the
                // Relative Id and place in the translated Sid entry,
                // otherwise store LSA_UNKNOWN_INDEX there.
                //

                Sid = LsapDbWellKnownSid(WellKnownSidIndex);

                SubAuthorityCount = *RtlSubAuthorityCountSid((PSID) Sid);

                RelativeId = LSA_UNKNOWN_ID;

                PrefixSid = NULL;

                //
                // Get the Sid's Use.
                //

                OutputSids[NameNumber].Use =
                    LsapDbWellKnownSidNameUse(WellKnownSidIndex);

                //
                // If the Sid is a Domain Sid, store pointer to
                // it in the Trust Information.
                //

                if (OutputSids[NameNumber].Use == SidTypeDomain) {

                    TrustInformation.Sid = Sid;

                } else {

                    //
                    // The Sid is not a domain Sid.  Construct the Relative Id
                    // and Prefix Sid.  This is equal to the original Sid
                    // excluding the lowest subauthority (Relative id).
                    //

                    if (SubAuthorityCount > 0) {

                        RelativeId = *RtlSubAuthoritySid((PSID) Sid, SubAuthorityCount - 1);
                    }

                    PrefixSidLength = RtlLengthRequiredSid(
                                          SubAuthorityCount - 1
                                          );


                    PrefixSid = MIDL_user_allocate( PrefixSidLength );

                    if (PrefixSid == NULL) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }


                    RtlCopyMemory( PrefixSid, Sid, PrefixSidLength );

                    (*RtlSubAuthorityCountSid( (PSID) PrefixSid ))--;

                    TrustInformation.Sid = PrefixSid;
                }

                //
                // Set the Relative Id.  For a Domain Sid this is set to the
                // Unknown Value.
                //
                Status = LsapRpcCopySid(NULL,
                                       &OutputSids[NameNumber].Sid,
                                        Sid);
                if (!NT_SUCCESS(Status)) {
                    break;
                }

                //
                // Lookup this Domain Sid or Prefix Sid in the Referenced Domain
                // List.  If it is already there, return the DomainIndex for the
                // existing entry and free up the memory allocated for the
                // Prefix Sid (if any).
                //

                if (LsapDbLookupListReferencedDomains(
                   