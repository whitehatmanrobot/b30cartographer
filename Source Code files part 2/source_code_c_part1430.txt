_PING_BEHAVIOR);
}

LONG RWP_Shutdown_Behavior(HRESULT* hr) {
	*hr = S_OK;

	//
	//Not shutting down, period
	//
	if (RWP_Get_Behavior(RWP_SHUTDOWN_BEHAVIOR) == RWP_SHUTDOWN_NOT_OBEY) {
		DBGPRINTF((DBG_CONTEXT, "Rogue: Not shutting down\n"));
	}
	
	//
	//Sleeping for lTimeToSleep * 4 seconds before continuing on
	//
	if (RWP_Get_Behavior(RWP_SHUTDOWN_BEHAVIOR) == RWP_SHUTDOWN_DELAY) {
		LONG lTimeToSleep = RWP_Get_Behavior_Time_Limit(RWP_SHUTDOWN_BEHAVIOR);
		RWP_Sleep_For(lTimeToSleep, "Rogue: Not shutting down for");

		//return 0 so that we'll keep going (this is a delay, not fail)
		return (RWP_NO_MISBEHAVE);
	}
	
	return (RWP_SHUTDOWN_BEHAVIOR);
}

LONG RWP_Startup_Behavior(ULONG* rc, WP_CONTEXT* wpContext) {
	//
	//modify rc accordingly
	//
	*rc = NO_ERROR;
	
	//
	//Quit after registering with UL
	//
	if (RWP_Get_Behavior(RWP_STARTUP_BEHAVIOR) == RWP_STARTUP_NOT_OBEY) {
		DBGPRINTF((DBG_CONTEXT, "Rogue: Not starting up(registered)... shutting down\n"));
		
		wpContext->IndicateShutdown(SHUTDOWN_REASON_ADMIN);
		
		//return 0 so that it enters (and subsequently exits) the thread loop
		return (RWP_NO_MISBEHAVE);
	}

	//
	//Delay starting up the thread message loop
	//
	if (RWP_Get_Behavior(RWP_STARTUP_BEHAVIOR) == RWP_STARTUP_DELAY) {
		LONG lTimeToSleep = RWP_Get_Behavior_Time_Limit(RWP_STARTUP_BEHAVIOR);
		RWP_Sleep_For(lTimeToSleep, "Rogue: Not starting up for");

		//return 0 so that we'll keep going (this is a delay, not fail)
		return (RWP_NO_MISBEHAVE);
	}

	//
	//Quit before registering with UL
	//
	if (RWP_Get_Behavior(RWP_STARTUP_BEHAVIOR) == RWP_STARTUP_NOT_REGISTER_FAIL) {
		DBGPRINTF((DBG_CONTEXT, "Rogue: Not starting up (unregistered)... shutting down\n"));
		
		wpContext->IndicateShutdown(SHUTDOWN_REASON_ADMIN);
		
		//return 0 so that it enters (and subsequently exits) the thread loop
		return (RWP_NO_MISBEHAVE);
	}
	//
	//It looks like the place to modify is in wpcontext.cxx, 
	//when it tries to initialize IPM if requested
	//

	return (RWP_NO_MISBEHAVE);
}

/*
LONG RWP_Health_Behavior() {
}

LONG RWP_Recycle_Behavior() {
}

*/

LONG RWP_Get_Behavior_Time_Limit(LONG lBehavior) {
	//
	//Return the bits masked by RWP_TIMER_MASK as a LONG
	//
	return ((LONG)(lBehavior & RWP_TIMER_MASK));
}

LONG RWP_Get_Behavior(LONG lBehavior) {
	//
	//Return the bits NOT masked by RWP_TIMER_MASK as a LONG
	//
	return ((LONG)(lBehavior & ~RWP_TIMER_MASK));
}

void RWP_Sleep_For(LONG lTime, char* szMessage) {
	//
	//First display to debug what we are doing...
	//
	RWP_Output_String_And_LONG(lTime, szMessage);

	SleepEx(
		(DWORD)lTime * 4000,		//sleep for lTimeToSleep * 4000 milliseconds (4 second increments)
		FALSE);						// not alertable

	DBGPRINTF((DBG_CONTEXT, "Done sleeping \n"));
}

void RWP_Output_String_And_LONG(LONG lLong, char* szString) {
	//
	//Generic way to DBGPRINTF "<szString> <lLong> <szEnding>"
	//
	
	/*
	char szEnding[] = "seconds.\n";
	char szTimeToSleep[20];			//buffer overflow?
	char buffer[255];				//buffer overflow?
	buffer[strlen(szString) + strlen(szTimeToSleep) + strlen(szEnding) + 2] = NULL;

	_ltoa(lLong * 4, szTimeToSleep, 10);	//radix 10

	strcpy(buffer, szString);
	buffer[strlen(szString)] = ' ';			//get rid of NULL
	strcpy(buffer + strlen(szString) + 1, szTimeToSleep);
	buffer[strlen(szString) + strlen(szTimeToSleep) + 1] = ' ';	//get rid of NULL
	strcpy(buffer + strlen(szString) + strlen(szTimeToSleep) + 2, szEnding);
	*/
	
	//DBGPRINTF((DBG_CONTEXT, buffer));
	DBGPRINTF((DBG_CONTEXT, "%s %d seconds\n", szString, lLong * 4));
}

void RWP_Display_Behavior() {
	//char szBuffer[32];

	LONG pingBehavior = RWP_Get_Behavior(RWP_PING_BEHAVIOR);
	LONG shutdownBehavior = RWP_Get_Behavior(RWP_SHUTDOWN_BEHAVIOR);
	LONG startupBehavior = RWP_Get_Behavior(RWP_STARTUP_BEHAVIOR);
	LONG healthBehavior = RWP_Get_Behavior(RWP_HEALTH_BEHAVIOR);
	LONG recycleBehavior = RWP_Get_Behavior(RWP_RECYCLE_BEHAVIOR);

	/*
	DBGPRINTF((DBG_CONTEXT, _ltoa(pingBehavior, szBuffer, 10)));
	DBGPRINTF((DBG_CONTEXT, _ltoa(shutdownBehavior, szBuffer, 10)));
	DBGPRINTF((DBG_CONTEXT, _ltoa(startupBehavior, szBuffer, 10)));
	*/
	
	DBGPRINTF((DBG_CONTEXT, "Rogue Behavior Status\n"));

	if (pingBehavior == RWP_NO_MISBEHAVE)			DBGPRINTF((DBG_CONTEXT, RWP_NO_PING_MISBEHAVE_MSG));
	if (shutdownBehavior == RWP_NO_MISBEHAVE)		DBGPRINTF((DBG_CONTEXT, RWP_NO_SHUTDOWN_MISBEHAVE_MSG));
	if (startupBehavior == RWP_NO_MISBEHAVE)		DBGPRINTF((DBG_CONTEXT, RWP_NO_STARTUP_MISBEHAVE_MSG));
	if (healthBehavior == RWP_NO_MISBEHAVE)			DBGPRINTF((DBG_CONTEXT, RWP_NO_HEALTH_MISBEHAVE_MSG));
	if (recycleBehavior == RWP_NO_MISBEHAVE)		DBGPRINTF((DBG_CONTEXT, RWP_NO_RECYCLE_MISBEHAVE_MSG));
		
	if (pingBehavior == RWP_PING_NO_ANSWER)			DBGPRINTF((DBG_CONTEXT, RWP_PING_NO_ANSWER_MSG));
	if (pingBehavior == RWP_PING_MULTI_ANSWER)		DBGPRINTF((DBG_CONTEXT, "%s %d", RWP_PING_MULTI_ANSWER_MSG, RWP_Get_Behavior_Time_Limit(RWP_PING_BEHAVIOR)));
	if (pingBehavior == RWP_PING_DELAY_ANSWER)		RWP_Output_String_And_LONG(RWP_Get_Behavior_Time_Limit(RWP_PING_BEHAVIOR), (char*)RWP_PING_DELAY_ANSWER_MSG);
	
	if (shutdownBehavior == RWP_SHUTDOWN_NOT_OBEY)	DBGPRINTF((DBG_CONTEXT, RWP_SHUTDOWN_NOT_OBEY_MSG));
	if (shutdownBehavior == RWP_SHUTDOWN_DELAY)		RWP_Output_String_And_LONG(RWP_Get_Behavior_Time_Limit(RWP_SHUTDOWN_BEHAVIOR), (char*)RWP_SHUTDOWN_DELAY_MSG);

	if (startupBehavior == RWP_STARTUP_NOT_OBEY)			DBGPRINTF((DBG_CONTEXT, RWP_STARTUP_NOT_OBEY_MSG));
	if (startupBehavior == RWP_STARTUP_DELAY)				RWP_Output_String_And_LONG(RWP_Get_Behavior_Time_Limit(RWP_STARTUP_BEHAVIOR), (char*)RWP_STARTUP_DELAY_MSG);
	if (startupBehavior == RWP_STARTUP_NOT_REGISTER_FAIL)	DBGPRINTF((DBG_CONTEXT, RWP_STARTUP_NOT_REGISTER_FAIL_MSG));
	
	if (healthBehavior == RWP_HEALTH_OK)				DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_OK_MSG));
	if (healthBehavior == RWP_HEALTH_NOT_OK)			DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_NOT_OK_MSG));
	if (healthBehavior == RWP_HEALTH_TERMINALLY_ILL)	DBGPRINTF((DBG_CONTEXT, RWP_HEALTH_TERMINALLY_ILL_MSG));
	
	if (recycleBehavior == RWP_RECYCLE_NOT_OBEY)		DBGPRINTF((DBG_CONTEXT, RWP_RECYCLE_NOT_OBEY_MSG));
	if (recycleBehavior == RWP_RECYCLE_DELAY)			RWP_Output_String_And_LONG(RWP_Get_Behavior_Time_Limit(RWP_RECYCLE_BEHAVIOR), (char*)RWP_RECYCLE_DELAY_MSG);
}

void RWP_Write_LONG_to_Registry(HKEY hkey, const WCHAR* szSubKey, LONG lValue) {
	LONG lResult;

	lResult = RegSetValueEx(
		hkey,
		szSubKey,
		0,
		REG_DWORD,
		(LPBYTE)&lValue,
		sizeof(lValue));
	
	ASSERT(lResult == ERROR_SUCCESS);
	if (lResult != ERROR_SUCCESS)
		return;
}

void RWP_Read_LONG_from_Registry(HKEY hkey, const WCHAR* szSubKey, LONG* lValue) {
	LONG lResult;
	DWORD dwType;
	DWORD len = sizeof(lValue);
	HKEY myKey;

	lResult = RegQueryValueEx(
		hkey,
		szSubKey,
		0,
		&dwType,
		(LPBYTE)lValue,
		&len);

	if (lResult != ERROR_SUCCESS) {		//sets default = 0 (no misbehave)
		*lValue = RWP_NO_MISBEHAVE;
		/*
		//key does not exist -- try to create it
		lResult = RegCreateKeyEx(
			hkey,
			szSubKey,
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS,
			NULL,
			&myKey,
			&dwType);
		*/
	}
}

BOOL RWP_Read_Config(const WCHAR* szRegKey) {
	BOOL bSuccess = FALSE;
	HKEY hkMyKey;
	LONG lResult;
	DWORD dwDisp;

	//
	//First cut "bad" behavior = don't answer pings
	//
	RWP_PING_BEHAVIOR = RWP_PING_NO_ANSWER;
	RWP_SHUTDOWN_BEHAVIOR = RWP_NO_MISBEHAVE;
	RWP_STARTUP_BEHAVIOR = RWP_NO_MISBEHAVE;
	RWP_HEALTH_BEHAVIOR = RWP_NO_MISBEHAVE;
	RWP_RECYCLE_BEHAVIOR = RWP_NO_MISBEHAVE;
	RWP_EXTRA_DEBUG = RWP_DEBUG_OFF;
	
	lResult = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,	//root key
		szRegKey,			//sub key
		0,					//reserved - must be 0
		KEY_ALL_ACCESS,		//SAM
		&hkMyKey);			//my pointer to HKEY

	if (lResult != ERROR_SUCCESS) {		//can't open my key
		lResult = RegCreateKeyEx(
			HKEY_LOCAL_MACHINE,
			szRegKey,
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS,
			NULL,
			&hkMyKey,
			&dwDisp);

		if (lResult != ERROR_SUCCESS)	//can't create my key
			DBGPRINTF((DBG_CONTEXT, "Unable to create configuration key\n"));
		else {
			DBGPRINTF((DBG_CONTEXT, "Created configuration key\n"));
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_PING_BEHAVIOR, RWP_PING_BEHAVIOR);
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_SHUTDOWN_BEHAVIOR, RWP_SHUTDOWN_BEHAVIOR);
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_STARTUP_BEHAVIOR, RWP_STARTUP_BEHAVIOR);
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_HEALTH_BEHAVIOR, RWP_HEALTH_BEHAVIOR);
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_RECYCLE_BEHAVIOR, RWP_RECYCLE_BEHAVIOR);
			RWP_Write_LONG_to_Registry(hkMyKey, RWP_CONFIG_EXTRA_DEBUG, RWP_EXTRA_DEBUG);
		}
	} else {							//my key exists.  Read in config info and validate
		DBGPRINTF((DBG_CONTEXT, "Key exists\n"));
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_PING_BEHAVIOR, &RWP_PING_BEHAVIOR);
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_SHUTDOWN_BEHAVIOR, &RWP_SHUTDOWN_BEHAVIOR);
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_STARTUP_BEHAVIOR, &RWP_STARTUP_BEHAVIOR);
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_HEALTH_BEHAVIOR, &RWP_HEALTH_BEHAVIOR);
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_RECYCLE_BEHAVIOR, &RWP_RECYCLE_BEHAVIOR);
		RWP_Read_LONG_from_Registry(hkMyKey, RWP_CONFIG_EXTRA_DEBUG, &RWP_EXTRA_DEBUG);
	}
	
	bSuccess = TRUE;

	RegCloseKey(hkMyKey);

	//
	//Declare our intentions
	//
	RWP_Display_Behavior();
	DBGPRINTF((DBG_CONTEXT, "Finished Configurations\n"));

	//TODO: Display PID and command line info...
	
	return (bSuccess);
}

/*
Methods modified:
iiswp.cxx
wpipm.cxx (3 places - handleping, handleshutdown, pipedisconnected)
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\wpcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     wpcontext.cxx

   Abstract:
     This module defines the member functions of the WP_CONTEXT.
     The WP_CONTEXT object embodies an instance of the Worker process
     object. It contains a completion port, pool of worker threads,
     pool of worker requests, a data channel for the worker process, etc.
     It is responsible for setting up the context for processing requests
     and handles delegating the processing of requests.

     NYI: In the future we should be able to run WP_CONTEXT object as
     a COM+ object and be run standalone using a hosting exe.

   Author:

       Murali R. Krishnan    ( MuraliK )     17-Nov-1998

   Project:

       IIS Worker Process

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include <stdio.h>
# include <conio.h>
# include <io.h>


/**
 *  IdleTimeCheckCallback()
 *  Callback function provided for TimerQueue
 *  This function is called by NT thread pool every minute.
 *  Calls the timer's IncrementTick method.
 *
 *  pvContext                   PVOID to WP_CONTEXT
 *  BOOLEAN                     not used.
 *
 */
VOID
WINAPI
IdleTimeCheckCallback(
    void *   pvContext,
    BOOLEAN
    )
{
    WP_IDLE_TIMER  *pTimer = (WP_IDLE_TIMER *)pvContext;

    DBGPRINTF((DBG_CONTEXT, "Check Idle Time Callback.\n"));
    DBG_ASSERT( pTimer );

    pTimer->IncrementTick();
}

/**
 *  WP_IDLE_TIMER constructor
 *
 */
WP_IDLE_TIMER::WP_IDLE_TIMER(
    ULONG       IdleTime,
    WP_CONTEXT* pContext
    )
:   m_BusySignal(0),
    m_CurrentIdleTick(0),
    m_IdleTime(IdleTime),
    m_hIdleTimeExpiredTimer((HANDLE)NULL),
    m_pContext(pContext)
{
}

/**
 *  WP_IDLE_TIMER destructor
 *  Delete the timer from TimerQueue.
 *
 */
WP_IDLE_TIMER::~WP_IDLE_TIMER(
    void
    )
{
    // Cancel IdleTimeExpiredTimer
    if (m_hIdleTimeExpiredTimer)
    {
        StopTimer();

    }
}

/**
 *  WP_IDLE_TIMER Initialize routine
 *  Create timer for idle time check.
 *  The timer will wake up every minutes, see IdleTimeCheckCallback for detail.
 */
ULONG  WP_IDLE_TIMER::Initialize(void)
{
    BOOL    fRet;
    ULONG   rc = NOERROR;

    // IdleTime is stored as in minutes, 1 min = 60*1000 milliseconds.
    fRet = CreateTimerQueueTimer(
            &m_hIdleTimeExpiredTimer,               // handle to the Timer
            NULL,                                   // Default Timer Queue
            IdleTimeCheckCallback,                  // Callback function
            this,                                   // Context.
            60000,                                  // Due Time
            60000,                                  // Signal every minute
            WT_EXECUTEINIOTHREAD
            );

    if (!fRet)
    {
        rc = GetLastError();
        DBGPRINTF((DBG_CONTEXT,
            "Failed to create idle time expired timer. err %d\n", rc));
    }

    return rc;
}

/**
 *  WP_IDLE_TIMER IncrementTick
 *
 *  Gets called every minute. If we've been idle too long, signal
 *  the admin process.
 */
VOID
WP_IDLE_TIMER::IncrementTick(void)
{
    ULONG   BusySignal = m_BusySignal;
    InterlockedIncrement((PLONG)&m_CurrentIdleTick);
    m_BusySignal = 0;

    if (!BusySignal && m_CurrentIdleTick >= m_IdleTime) {
        SignalIdleTimeReached();
    }
}

/**
 *  SignalIdleTimeReached
 *  Sends a message to admin process.
 */
HRESULT WP_IDLE_TIMER::SignalIdleTimeReached(void)
{
    DBGPRINTF((DBG_CONTEXT,
        "Idle time reached, sent shutdown message to admin process.\n"));

    return m_pContext->SendMsgToAdminProcess(IPM_WP_IDLE_TIME_REACHED);
}

/**
 *  StopTimer
 *  Stops the idle timer.
 */
 VOID WP_IDLE_TIMER::StopTimer(void)
 {
    BOOL fRet;

    DBG_ASSERT( m_hIdleTimeExpiredTimer );

    fRet = DeleteTimerQueueTimer(NULL,
                m_hIdleTimeExpiredTimer,
                (HANDLE)-1
                );

    if (!fRet)
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to delete Timer queue %08x\n",
            GetLastError()));
    }
    m_hIdleTimeExpiredTimer = NULL;
 }


/**
 *  OverlappedCompletionRoutine()
 *  Callback function provided in BindIoCompletionCallback.
 *  This function is called by NT thread pool.
 *
 *  dwErrorCode                 Error Code
 *  dwNumberOfBytesTransfered   Number of Bytes Transfered
 *  lpOverlapped                Overlapped structure
 */
VOID
WINAPI
OverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    UL_NATIVE_REQUEST *pRequest = NULL;

    if (lpOverlapped != NULL)
    {
        pRequest = CONTAINING_RECORD(lpOverlapped,
                                    UL_NATIVE_REQUEST,
                                    m_overlapped);
    }
    if ( pRequest != NULL)
    {
        pRequest->DoWork(
            dwNumberOfBytesTransfered,
            // BUGBUG: hack to work around thread
            // pool nonsense.
            RtlNtStatusToDosError(dwErrorCode),
            lpOverlapped
            );
    }

    return;
}

/************************************************************
 *    Functions
 ************************************************************/


WP_CONTEXT::WP_CONTEXT(void)
    : m_hDoneEvent  ( NULL),
      m_ulAppPool   (),
      m_nreqpool    (),
      m_pConfigInfo ( NULL),
      m_fShutdown   ( FALSE),
      m_pIdleTimer  ( NULL)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Initialized WP_CONTEXT(%08x)\n", this));
    }

} // WP_CONTEXT::WP_CONTEXT()


WP_CONTEXT::~WP_CONTEXT(void)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Destroying WP_CONTEXT(%08x)\n", this));
    }

    //Cleanup();

} // WP_CONTEXT::WP_CONTEXT()



/********************************************************************++

Routine Description:
    Initializes the global state for the request processor.
    The function initializes all the following components:
    - Data Channel for UL
    - Thread pool for

Arguments:
    ConfigInfo - configuration information for this Worker process.

Returns:
    ULONG

    NYI: There are several other configuration paramaters that are important.
    However at the present point, not all config parameters
    are allowed in here.

--********************************************************************/

ULONG
WP_CONTEXT::Initialize(IN WP_CONFIG * pConfigInfo)
{
    ULONG       rc = NO_ERROR;
    LPCWSTR     pwszAppPoolName;
    HRESULT     hr = S_OK;

    m_pConfigInfo = pConfigInfo;

    pwszAppPoolName = m_pConfigInfo->QueryAppPoolName();

    rc = m_ulAppPool.Initialize(pwszAppPoolName);

    if (NO_ERROR != rc)
    {
        IF_DEBUG( ERROR)
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "Failed to initialize AppPool\n"));
        }
        return (rc);
    }

    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT, "AppPool Initialized\n"));
    }

    //
    // Initialize of the shutdown event
    //

    m_hDoneEvent = IIS_CREATE_EVENT(
                       "WP_CONTEXT::m_hDoneEvent",  // name
                       &m_hDoneEvent,               // address of storage loc
                       TRUE,                        // manual reset
                       FALSE                        // Initial State
                       );

    if (m_hDoneEvent == NULL)
    {
        rc = GetLastError();

        IF_DEBUG(ERROR)
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "Failed to create DoneEvent.\n"
                      ));
        }

        return (rc);
    }


    if (0 != m_pConfigInfo->QueryIdleTime())
        {
            m_pIdleTimer = new WP_IDLE_TIMER(m_pConfigInfo->QueryIdleTime(), this);

            if (m_pIdleTimer)
            {
                rc = m_pIdleTimer->Initialize();
            }
            else
            {
                rc = ERROR_OUTOFMEMORY;
            }

        }
    //
    //  Associate data channel and the WP_CONTEXT object with completion port
    //

    rc = BindIoCompletionCallback(
                        m_ulAppPool.GetHandle(),        // UL handle
                        OverlappedCompletionRoutine,
                        0 );

    if (!rc)
    {
        rc = GetLastError();
        IF_DEBUG(ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Failed to add App Pool handle to completion port. Error=0x%08x\n",
                 rc
                 ));
        }

        return (rc);
    }


    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT, "Added Data channel to CP context\n"));
    }

    //
    // Initialize IPM if requested to
    //
    if ( m_pConfigInfo->FRegisterWithWAS())
    {
        rc = m_WpIpm.Initialize(this);

        if (NO_ERROR != rc)
        {
            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize IPM. Error=0x%08x\n", rc
                    ));
            }

            return (rc);

        }
        else
        {
            IF_DEBUG( TRACE)
            {
                DBGPRINTF(( DBG_CONTEXT, "Initialized IPM\n"));
            }

        }
    }

    //
    // Create a pool of worker requests
    // NYI: Allow the worker requests limit to be configurable.
    //

    UL_NATIVE_REQUEST::SetRestartCount(m_pConfigInfo->QueryRestartCount());

    rc = m_nreqpool.AddPoolItems( this,
                                  (m_pConfigInfo->QueryRestartCount() == 0 ||
                                   (m_pConfigInfo->QueryRestartCount() >=
                                    NUM_INITIAL_REQUEST_POOL_ITEMS)) ?
                                    NUM_INITIAL_REQUEST_POOL_ITEMS :
                                    m_pConfigInfo->QueryRestartCount()
                                  );
    if (NO_ERROR != rc)
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Failed to add pool of worker requests. Error=%08x\n", rc
                ));
        }

        return (rc);
    }


    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT, "Created UL_NATIVE_REQUEST pool\n"));
    }

    //
    // Set the window title to something nice when we're running
    // under the debugger.
    //

    if (IsDebuggerPresent())
    {
        STRU strTitle;
        HRESULT hr = NO_ERROR;
        WCHAR buffer[sizeof("iiswp[1234567890] - ")];
        WCHAR buffer2[sizeof(" - wp1234567890 - mm/dd hh:mm:ss")];

        wsprintf( buffer, L"iiswp[%lu] - ", GetCurrentProcessId() );
        hr = strTitle.Append( buffer );

        if (SUCCEEDED(hr))
        {
            hr = strTitle.Append( m_pConfigInfo->QueryAppPoolName() );
        }

        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER sysTime;
            LARGE_INTEGER localTime;
            TIME_FIELDS fields;

            NtQuerySystemTime( &sysTime );
            RtlSystemTimeToLocalTime( &sysTime, &localTime );
            RtlTimeToTimeFields( &localTime, &fields );

            wsprintf(
                buffer2,
                L" - wp%lu  - %02u/%02u %02u:%02u:%02u",
                m_pConfigInfo->QueryNamedPipeId(),
                fields.Month,
                fields.Day,
                fields.Hour,
                fields.Minute,
                fields.Second
                );

            hr = strTitle.Append( buffer2 );
        }

        if (SUCCEEDED(hr))
        {
            SetConsoleTitleW( strTitle.QueryStr() );
        }
    }

    return (rc);

} // WP_CONTEXT::Initialize()

/********************************************************************++

Routine Description:
  This function cleans up the sub-objects inside WP_CONTEXT.
  It first forces a close of the handle and then waits for all
    the objects to drain out.

  NYI: Do two-phase shutdown logic

Arguments:
    None

Returns:
    WIn32 Error

--********************************************************************/

BOOL
WP_CONTEXT::IndicateShutdown(SHUTDOWN_REASON    reason)
{
    m_ShutdownReason = reason;

    if (FALSE == InterlockedCompareExchange((LONG *)&m_fShutdown, TRUE, FALSE))
    {
        return SetEvent(m_hDoneEvent);
    }
    else
    {
        return TRUE;
    }
}

/********************************************************************++

Routine Description:
  This function cleans up the sub-objects inside WP_CONTEXT.
  It first forces a close of the handle and then waits for all
    the objects to drain out.

  NYI: Do two-phase shutdown logic

Arguments:
    None

Returns:
    WIn32 Error

--********************************************************************/

ULONG
WP_CONTEXT::Shutdown(void)
{
    ULONG rc = NOERROR;


    if (m_pIdleTimer)
    {
        delete m_pIdleTimer;
        m_pIdleTimer = NULL;
    }

   //
   // Cleanup the IPM.
   //

   if ( m_pConfigInfo->FRegisterWithWAS())
   {
        rc = m_WpIpm.Terminate();

        if (NO_ERROR != rc)
        {
            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Counldn't shut down IPM. Error=0x%08x\n", rc
                    ));
            }
        }
    }

    return rc;

}

/********************************************************************++

Routine Description:
  This function cleans up the sub-objects inside WP_CONTEXT.
  It first forces a close of the handle and then waits for all
    the objects to drain out.

  NYI: Do two-phase shutdown logic

Arguments:
    None

Returns:
    Win32 Error

--********************************************************************/

ULONG
WP_CONTEXT::Cleanup(void)
{
    ULONG rc;

    rc = m_ulAppPool.Cleanup();

    if (NO_ERROR != rc)
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed in UL_APP_POOL::CloseHandle(). Error=%08x\n",
                        rc));
        }

        return (rc);
    }


    rc = m_nreqpool.ReleaseAllWorkerRequests();

    if (NO_ERROR != rc)
    {
        IF_DEBUG(ERROR)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Cleanup Global State for Worker Requests failed; Error=%08x\n",
                       rc));
        }
        return (rc);
    }


    //
    // Cleanup the Shutdown Event.
    //

    CloseHandle(m_hDoneEvent);
    m_hDoneEvent = FALSE;


    return rc;

} // WP_CONTEXT::Cleanup()

/********************************************************************++

Routine Description:

Arguments:
  None

Returns:
  Win32 Error
--********************************************************************/

ULONG
WP_CONTEXT::RunMainThreadLoop(void)
{
    do
    {
        DWORD result;

        result = WaitForSingleObject( m_hDoneEvent, INFINITE );
        DBG_ASSERT( result == WAIT_OBJECT_0 );

    } while ( !m_fShutdown);

    //
    // NYI: cleanup happens after we return from this function.
    //

    return (NO_ERROR);

} // WP_CONTEXT::RunMainThreadLoop()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\wpipm.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wpipm.cxx

Abstract:

    Contains the WPIPM class that handles communication with
    the admin service. WPIPM responds to pings, and tells
    the process when to shut down.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include <precomp.hxx>
#include "ipm.hxx"
#include "wpipm.hxx"
#include "ipm_io_c.hxx"

#ifdef TEST
#include "RWP_Func.hxx"
#endif
/**
 *
 *   Routine Description:
 *
 *   Initializes WPIPM.
 *   
 *   Arguments:
 *
 *   pWpContext - pointer to the wp context (so we can tell it to shutdown)
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Initialize(
    WP_CONTEXT * pWpContext
    )
{
    HRESULT        hr           = S_OK;
    IO_FACTORY_C * pFactory;
    STRU           strPipeName;
    MESSAGE_PIPE * pPipe        = NULL;

    m_pWpContext      = pWpContext;
    m_pMessageGlobal  = NULL;
    m_pPipe           = NULL;
    m_hTerminateEvent = NULL;

    //
    // create MESSAGE_GLOBAL
    //
    pFactory = new IO_FACTORY_C();
    if (pFactory) {
        m_pMessageGlobal = new MESSAGE_GLOBAL(pFactory);

        if (m_pMessageGlobal) {
            hr = m_pMessageGlobal->InitializeMessageGlobal();
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // create connect event
    //
    if (SUCCEEDED(hr)) {
        m_hConnectEvent = CreateEvent(
                                NULL,   // default security
                                TRUE,   // manual reset
                                FALSE,  // initial state
                                NULL    // unnamed event
                                );

        if (m_hConnectEvent) {
            hr = m_pMessageGlobal->CreateMessagePipe(
                        this,
                        &pPipe
                        );
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
                                

    //
    // create the MESSAGE_PIPE and termination event
    //
    if (SUCCEEDED(hr)) {
        m_hTerminateEvent = CreateEvent(
                                NULL,  // default security
                                TRUE,  // manual reset
                                FALSE, // initial state
                                NULL   // unnamed
                                );

        if (m_hTerminateEvent) {
            hr = m_pMessageGlobal->CreateMessagePipe(
                        this,
                        &pPipe
                        );
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // connect the MESSAGE_PIPE
    //
    if (SUCCEEDED(hr)) {
        hr = strPipeName.Copy(IPM_NAMED_PIPE_NAME);

        if (SUCCEEDED(hr)) {
            hr = m_pMessageGlobal->ConnectMessagePipe(
                        strPipeName,
                        pWpContext->m_pConfigInfo->QueryNamedPipeId(),
                        pPipe
                        );
        }
    }

    if (SUCCEEDED(hr)) {
        m_pPipe = pPipe;
    } else {
        // pipe takes care of itself
        
        Terminate();
    }

    return hr;
}


/**
 *
 * Routine Description:
 *
 *   Terminates WPIPM.
 *
 *   If the message pipe is open this function will disconnect it
 *   and wait for the pipe's disconnection callback.
 *   
 *  Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::Terminate(
    VOID
    )
{
    HRESULT hr = S_OK;
    HRESULT hrGlobalTerminate;
    DWORD   dwWaitResult;

    if (m_pMessageGlobal) {
        if (m_pPipe) {
            hr = m_pMessageGlobal->DisconnectMessagePipe(m_pPipe);
            m_pPipe = NULL;
            // pipe deletes itself

            if (SUCCEEDED(hr)) {
                dwWaitResult = WaitForSingleObject(
                                    m_hTerminateEvent,
                                    INFINITE
                                    );

            }
        }

        hrGlobalTerminate = m_pMessageGlobal->TerminateMessageGlobal();

        if (SUCCEEDED(hr)) {
            hr = hrGlobalTerminate;
        }

        m_pMessageGlobal = NULL;
    }

    m_pWpContext = NULL;

    if (m_hTerminateEvent) {
        CloseHandle(m_hTerminateEvent);
        m_hTerminateEvent = NULL;
    }

    if (m_hConnectEvent) {
        CloseHandle(m_hConnectEvent);
        m_hConnectEvent = NULL;
    }

    return hr;
}


/**
 *
 *
 *  Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has received a message.
 *   
 *   We decode the message and respond appropriately.
 *   
 *   Arguments:
 *
 *   pPipeMessage - the message that we received
 *   
 *   Return Value:
 *
 *   HRESULT
 *
 */
HRESULT
WP_IPM::AcceptMessage(
    IN const MESSAGE * pPipeMessage
    )
{
    HRESULT hr;

    switch (pPipeMessage->GetOpcode()) {
    case IPM_OP_PING:
        hr = HandlePing();
        break;

    case IPM_OP_SHUTDOWN:
        hr = HandleShutdown();
        break;

    default:
        DBG_ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }

    return hr;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been connected and is ready for use.
 *   
 * Arguments:
 *
 *   None.
 *   
 * Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::PipeConnected(
    VOID
    )
{
    DBG_ASSERT(m_hConnectEvent);

    DBG_REQUIRE( SetEvent(m_hConnectEvent) );
    return S_OK;
}


/**
 *
 * Routine Description:
 *
 *   This is a callback from the message pipe that means
 *   the pipe has been disconnected and you won't be receiving
 *   any more messages.
 *   
 *   Tells WPIPM::Terminate that it's ok to exit now.
 *   
 * Arguments:
 *
 *   hr - the error code associated with the pipe disconnection
 *   
 * Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::PipeDisconnected(
    IN HRESULT hr
    )
{
    //
    // CODEWORK: should we do something with the parameter?
    //
    if (FAILED(hr))
    {
        WpTrace(WPIPM, (DBG_CONTEXT, "PipeDisconnected with hr ( %d).\n", hr));
    }
    //
    // If the pipe disappears out from under us, assume the WAS has
    // gone bad, and initiate clean shutdown of this worker process.
    //

#ifdef TEST
	//
	// All sorts of miscreat shutdown behaviors (for testing)
	//
	if (RWP_BEHAVIOR_EXHIBITED = RWP_Shutdown_Behavior(&hr))
		return (hr);
#endif
    m_pWpContext->IndicateShutdown(SHUTDOWN_REASON_ADMIN);


    if (SetEvent(m_hTerminateEvent)) {
        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}

/**
 *
 *  Routine Description:
 *
 *   Handles the ping message. Sends the ping response message.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandlePing(
    VOID
    )
{
    HRESULT hr;

#ifdef TEST
	//
	// All sorts of miscreat ping response behaviors (for testing)
	//
	if (RWP_BEHAVIOR_EXHIBITED = RWP_Ping_Behavior(&hr, m_pPipe))
		return (hr);
#endif
    WpTrace(WPIPM, (DBG_CONTEXT, "Handle Ping\n\n"));
    hr = m_pPipe->WriteMessage(
                IPM_OP_PING_REPLY,  // ping reply opcode
                0,                  // no data to send
                NULL                // pointer to no data
                );

    return hr;
}


/**
 *
 * Routine Description: 
 *
 *
 *   Handles the shutdown message. Shuts down the process
 *   
 *  Arguments:
 *
 *   None.
 *  
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::HandleShutdown(
    VOID
    )
{
    HRESULT hr = S_OK;

    //
    // BUGBUG: Surely this is not the right way out!
    //
    // ExitProcess(NO_ERROR);
#ifdef TEST
	//
	// All sorts of miscreat shutdown behaviors (for testing)
	//
	if (RWP_BEHAVIOR_EXHIBITED = RWP_Shutdown_Behavior(&hr))
		return (hr);
#endif
	WpTrace(WPIPM, (DBG_CONTEXT, "Handle ******************** Shutdown\n\n"));
    m_pWpContext->IndicateShutdown(SHUTDOWN_REASON_ADMIN);

	return hr;
}



/**
 *
 *  Routine Description:
 *
 *   Sends the message to indicate the worker process has reach certain state.
 *   Main use is in shutdown.  See IPM_WP_SHUTDOWN_MSG for reasons.
 *   
 *   Arguments:
 *
 *   None.
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
WP_IPM::SendMsgToAdminProcess(
    IPM_WP_SHUTDOWN_MSG reason
    )
{
    HRESULT hr;

    //
    // wait for connect
    //
    WaitForSingleObject(m_hConnectEvent, INFINITE);    

    //
    // really send the message
    //
    hr = m_pPipe->WriteMessage(
                IPM_OP_WORKER_REQUESTS_SHUTDOWN,  // sends message indicate shutdown
                sizeof(reason),                   // no data to send
                (BYTE *)&reason                   // pointer to no data
                );

    return hr;
}
//
// end of wpipm.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\wpconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     WpConfig.cxx

   Abstract:
     Module implementing the Worker Process Configuration Data structure.
     WP_CONFIG object encapsulates configuration supplied from the commandline
     as well as remotely supplied from the admin process.

   Author:

       Murali R. Krishnan    ( MuraliK )     21-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"

#include "CatMeta.h"


/*
Usage: \bin\iisrearc\inetsrv\iiswp [options] APN
        APN -- AppPool Name
        -d <URL List> -- Indicates that the process should register the given
                namespace itself. This mode is for running worker process in
                stand alone mode (for debugging)
        -l  -- Log errors that stop the worker process into the eventlog
        -ld -- Disables logging the errors of worker process to eventlog
                (default is not write to eventlog)
        -a  -- Look for web admin service and register with the same
                (default is look for web admin service)
        -ad -- Do not look for web admin service and do registration
        -r <n> -- Restart the worker process after n requests.
        -t <n> -- Shutdown the worker process if idle for n milliseconds.
        -h <path> -- Assume the default site is rooted at this path.
        <URL List> uses the syntax: {http[s]://IP:port/URL | http[s]://hostname:port/URL }+
                with space as separator
                 eg: -d http://localhost:80/  => listen for all HTTP requests on port 80
                 eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81

 */

const CHAR g_rgchUsage[] =
"Usage: %ws [options] APN\n"
"\tAPN -- AppPool Name\n"
"\t-d <URL List> -- Indicates that the process should register the given \n"
"\t\tnamespace itself. This mode is for running worker process in\n"
"\t\tstand alone mode (for debugging)\n"
"\t-l  -- Log errors that stop the worker process into the eventlog\n"
"\t-ld -- Disables logging the errors of worker process to eventlog\n"
"\t\t(default is not write to eventlog)\n"
"\t-a  -- Look for web admin service and register with the same\n"
"\t\t(default is look for web admin service)\n"
"\t-ad -- Do not look for web admin service and do registration\n"
"\t-r <n> -- Restart the worker process after n requests\n"
"\t-t <n> -- Shutdown the worker process if idle for n milliseconds\n"
"\t-h <path> -- Assume the default site is rooted at this path\n"
"\t-p  -- Tell COR to add IceCAP instrumentation\n"
"\t<URL List> uses the syntax: {http[s]://IP:port/URL | http[s]://hostname:port/URL }+\n"
"\t\twith space as separator\n"
"\t\t eg: -d http://*:80/  => listen for all HTTP requests on port 80\n"
"\t\t eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81\n"
;




/************************************************************
 * Convert a DWORD to a hex string.  The incoming buffer must
 * be big enough to hold "12345678" (including the null
 * teriminator).
 ************************************************************/

static const WCHAR hexDigits[] = L"0123456789ABCDEF";

// Convert a 32-bit DWORD to a hex string.  The incoming buffer must
// be big enough to hold "12345678" (including the null terminator).
void DwordToHexString(DWORD dword, WCHAR wszHexDword[])
{
    const int DWORDHEXDIGITS = sizeof(DWORD) * 2;

    WCHAR* p = wszHexDword;

    unsigned shift = (sizeof(DWORD) * 8) - 4;
    DWORD mask = 0xFu << shift;
    int i;
    for (i = 0; i < DWORDHEXDIGITS; ++i, mask >>= 4, shift -= 4)
    {
        unsigned digit = (dword & mask) >> shift;
        p[i] = hexDigits[digit];
    }
    p[i] = L'\0';
}


HMODULE LoadXSP()
{
    // Load xspisapi.dll.  We find this DLL by inspecting
    // HKLM/Software/Microsoft/XSP and it's InstallDir value.
    HKEY hkeyXSP = NULL;
    HMODULE hMod = NULL;

    __try
    {
        long rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               L"Software\\Microsoft\\XSP",
                               0, // reserved
                               KEY_READ,
                               &hkeyXSP);
        if (rc != ERROR_SUCCESS)
        {
            IF_DEBUG( TRACE)
            {
                DBGPRINTF((DBG_CONTEXT, "XSP is not installed\n"));
            }

            __leave;
        }

        WCHAR path[MAX_PATH + 1];
        DWORD valueType = 0;
        DWORD len = MAX_PATH;
        rc = RegQueryValueEx(hkeyXSP,
                             L"InstallDir",
                             NULL, // reserved
                             &valueType,
                             reinterpret_cast<BYTE*>(path),
                             &len);
        if (rc != ERROR_SUCCESS || (valueType != REG_SZ && valueType != REG_EXPAND_SZ))
        {
            IF_DEBUG( TRACE)
            {
                DBGPRINTF((DBG_CONTEXT, "XSP is not installed\n"));
            }

            __leave;
        }

        len /= sizeof path[0]; // Convert to characters

        // I now have a path something like "d:\winnt\xspdt", so just
        // append the DLL name.
        wcscat(path + len - 1, L"\\xspisapi.dll");

        hMod = LoadLibraryEx(path, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    __finally
    {
        if (hkeyXSP != NULL)
            RegCloseKey(hkeyXSP);
    }

    return hMod;
}



/************************************************************
 *     Stupid pointer class.
 ************************************************************/

template <class T>
class StupidComPointer
{
public:
    StupidComPointer()
        : _ptr(NULL)
    {
    }

    ~StupidComPointer()
    {
        if (_ptr != NULL)
            _ptr->Release();
    }

    operator T*()
    {
        return (T*)_ptr;
    }

    T* operator->()
    {
        return (T*)_ptr;
    }

    T** operator&()
    {
        return (T**)&_ptr;
    }

    T& operator*()
    {
        return *(T*)_ptr;
    }

private:
    IUnknown* _ptr;
};


/************************************************************
 *     Member functions of WP_CONFIG
 ************************************************************/

WP_CONFIG::WP_CONFIG(void)
    : m_pwszAppPoolName     (AP_NAME),
      m_fSetupControlChannel(false),
      m_fLogErrorsToEventLog(false),
      m_fRegisterWithWAS    (true),
      m_RestartCount    (0),
      m_NamedPipeId     (0),
      m_IdleTime        (0),
      m_homeDirectory   (NULL),
      m_istDispenser    (NULL),
      m_catFile         (NULL),
      m_xspisapiDLL     (NULL),
      _AppDomainGetObject(NULL),
      _AppDomainUninitFactory(NULL)
{
    lstrcpy( m_pwszProgram,  L"WP");
    InitializeCriticalSection(&m_workerTableGuard);
}

WP_CONFIG::~WP_CONFIG()
{
    DeleteCriticalSection(&m_workerTableGuard);

    m_ulcc.Cleanup();

    free(m_homeDirectory);
    free(m_catFile);

    if (m_istDispenser != NULL)
        m_istDispenser->Release();
}


void
WP_CONFIG::PrintUsage() const
{
    DBGPRINTF((DBG_CONTEXT, g_rgchUsage, m_pwszProgram));
}

/********************************************************************++

Routine Description:
    Parses the command line to read in all configuration supplied.
    This function updates the state variables inside WP_CONFIG for use
    in starting up the Worker process.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:
    argc - count of arguments supplied
    argv - pointer to strings containing the arguments.

Returns:
    Boolean

--********************************************************************/
bool
WP_CONFIG::ParseCommandLine(int argc, PWSTR  argv[])
{
    bool    fRet = true;
    int     iArg;

    lstrcpyn( m_pwszProgram, argv[0], sizeof m_pwszProgram / sizeof m_pwszProgram[0]);

    if ( argc < 2)
    {
        DBGPRINTF((DBG_CONTEXT, "Invalid number of parameters (%d)\n", argc));
        PrintUsage();
        return (false);
    }

    for( iArg = 1; iArg < argc; iArg++)
    {
        if ( (argv[iArg][0] == L'-') || (argv[iArg][0] == L'/'))
        {
            switch (argv[iArg][1])
            {

            case L'c': case L'C':
                DBGPRINTF((DBG_CONTEXT, "-C: obsolete\n"));
                break;

            case L'd': case L'D':

                m_fSetupControlChannel = true;
                iArg++;

                while ( (iArg < argc-1) &&
                        (argv[iArg][0] != L'-') && (argv[iArg][0] != L'/'))
                {
                    if ( !InsertURLIntoList(argv[iArg]) )
                    {
                        DBGPRINTF((DBG_CONTEXT, "Invalid URL: %ws\n", argv[iArg]));
                    }

                    iArg++;
                }

                iArg--;
                break;

            case L'a': case L'A':
                if ( (L'd' == argv[iArg][2]) || (L'D' == argv[iArg][2]))
                {
                    m_fRegisterWithWAS = false;
                }
                else
                {
                    // -a NamedPipeId
                    if (L'\0' == argv[iArg][2])
                    {
                        iArg++;
                    }

                    m_NamedPipeId = wcstoul(argv[iArg], NULL, 0);
                    DBGPRINTF((DBG_CONTEXT, "NamedPipe Id, %lu\n", m_NamedPipeId));

                    if (0 == m_NamedPipeId)
                    {
                        DBGPRINTF((DBG_CONTEXT, "Invalid NamedPipe Id, %ws\n",
                            argv[iArg]));
                        fRet = false;
                    }
                }
                break;

            case L'l': case L'L':
                DBGPRINTF((DBG_CONTEXT, "Warning: This option is not supported presently\n"));
                if (L' ' == argv[iArg][0])
                {
                    m_fLogErrorsToEventLog = true;
                }
                break;

            case L'r': case L'R':
                m_RestartCount = wcstoul(argv[++iArg], NULL, 0);

                if (m_RestartCount == 0)
                {
                    DBGPRINTF((DBG_CONTEXT, "Invalid maximum requests %ws\n", argv[iArg]));
                    return false;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "Maximum requests is %lu\n", m_RestartCount));
                }
                break;

            case L't': case L'T':
                m_IdleTime  = wcstoul(argv[++iArg], NULL, 0);

                if (m_IdleTime == 0)
                {
                    DBGPRINTF((DBG_CONTEXT, "Invalid idle time %ws\n", argv[iArg]));
                    return false;
                }
                else
                {
                    DBGPRINTF((DBG_CONTEXT, "The idle time value is %lu\n", m_IdleTime));
                }
                break;

            case L'h': case L'H':
                m_homeDirectory = _wcsdup(argv[++iArg]);
                if (m_homeDirectory == NULL)
                    return false;
                break;

            case L'p': case L'P':
                SetEnvironmentVariable(L"CORDBG_ENABLE", L"0x20");
                SetEnvironmentVariable(L"COR_PROFILER", L"\"ComPlusIcecapProfile.CorIcecapProfiler\"");
                SetEnvironmentVariable(L"PROF_CONFIG", L"/callcap");

                break;

            default:
            case L'?':
                fRet = false;
                break;
            } // switch
        }
        else
        {
            //
            // Take the next item as the NSG name and bail out here
            //
            m_pwszAppPoolName = argv[iArg];

            if ( iArg != (argc - 1))
            {
                //
                // this is not the last argument => unwanted parameters exist
                // give warning and ignore
                //
                DBGPRINTF((DBG_CONTEXT, "Warning: Too many arguments supplied\n"));
            }

            break; // get out of here.
        }
    }

    if (!m_fRegisterWithWAS)
    {
        m_RestartCount  = 0;
        m_IdleTime      = 0;
    }

    if (!fRet)
    {
        PrintUsage();
    }

    return ( fRet);

} // WP_CONFIG::ParseCommandLine()


/********************************************************************++

Routine Description:
    Sets up the control channel for processing requests. It uses
    the configuration parameters supplied for initializing the
    UL_CONTROL_CHANNEL.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:

Returns:
    Win32 error

--********************************************************************/

ULONG
WP_CONFIG::SetupControlChannel(void)
{

    //
    // Setup a control channel for our local use now. Used mainly for
    // the purpose of debugging.
    // In general control channel work is done by the AdminProces.
    //

    return m_ulcc.Initialize( m_mszURLList, m_pwszAppPoolName);

} // WP_CONFIG::SetupControlChannel()

/********************************************************************++
--********************************************************************/

bool
WP_CONFIG::InsertURLIntoList( LPCWSTR pwszURL  )
{
    LPCWSTR pwszOriginalURL = pwszURL;

    //
    // Minimum length: 11 (http://*:1/). Begins with http
    //

    if ( ( wcslen(pwszURL) < 11 ) || ( 0 != _wcsnicmp(pwszURL, L"http", 4)) )
    {
        return false;
    }

    pwszURL += 4;

    //
    // https
    //

    if ((L's' == *pwszURL) || (L'S' == *pwszURL))
    {
        pwszURL++;
    }

    //
    // ://
    //

    if ( (L':' != *pwszURL) || (L'/' != *(pwszURL+1)) || (L'/' != *(pwszURL+2)) )
    {
        return false;
    }

    pwszURL += 3;

    //
    // Skip host name or Ip Address
    //

    while ( (0 != *pwszURL) && ( L':' != *pwszURL))
    {
        pwszURL++;
    }

    //
    // Check port # exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // Check port number is numeric
    //

    pwszURL++;

    while ( (0 != *pwszURL) && ( L'/' != *pwszURL) )
    {
        if (( L'0' > *pwszURL) || ( L'9' < *pwszURL))
        {
            return false;
        }

        pwszURL++;
    }

    //
    // Check / after port number exists
    //

    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // URL is good.
    //

    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Inserting URL '%ws' into Config Group List\n",
                    pwszOriginalURL
                    ));
    }
    return ( TRUE == m_mszURLList.Append( pwszOriginalURL));

} // WP_CONFIG::InsertURLIntoList()



/********************************************************************++

Routine Description:
    Determine the path of the duct-tape root directory.  This is where
    the global config file and the System.IIS.dll must reside.  We find
    this by inspecting the registry key:
        HKLM/Software/Microsoft/Catalog42/URT
    under the value "Dll".

Arguments:

Returns:
    S_OK if successful, failure code if not.

--********************************************************************/

HRESULT
WP_CONFIG::GetDuctTapeRoot(WCHAR path[MAX_PATH+1], size_t* pathLength)
{
    long rc;
    HKEY hkeyCat42 = NULL;
    HRESULT hr = S_OK;

    __try
    {
        rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          L"Software\\Microsoft\\Catalog42\\URT",
                          0, // reserved
                          KEY_READ,
                          &hkeyCat42);
        if (rc != ERROR_SUCCESS)
        {
            IF_DEBUG( TRACE)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Catalog42 is not installed\n"
                            ));
            }

            hr = HRESULT_FROM_WIN32(rc);
            __leave;
        }

        DWORD valueType = 0;
        DWORD len = MAX_PATH;
        rc = RegQueryValueEx(hkeyCat42,
                             L"Dll",
                             NULL, // reserved
                             &valueType,
                             reinterpret_cast<BYTE*>(path),
                             &len);
        if (rc != ERROR_SUCCESS || (valueType != REG_SZ && valueType != REG_EXPAND_SZ))
        {
            IF_DEBUG( TRACE)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Catalog42 is not installed\n"
                            ));
            }

            hr = HRESULT_FROM_WIN32(rc);
            __leave;
        }

        *pathLength = len / sizeof path[0]; // Convert to characters

        // I now have a path something like "d:\winnt\xspdt\catalog42.dll".
        // The cooked-down catalog is in the same directory
        // ("d:\winnt\xspdt") in a file called "WASMB.CLB".
        WCHAR* lastWhack = wcsrchr(path, L'\\');
        if (lastWhack == NULL)
        {
            // This should never happen, but if it does, just let the
            // string be empty and let the world fall to pieces if
            // it's not found in the current directory.
            *pathLength = 0;
            path[0] = L'\0';
        }
        else
        {
            // Chop off the dll name, but leave the trailing slash.
            *pathLength -= *pathLength - (lastWhack - path) - 1;
            path[*pathLength] = L'\0';
        }
    }
    __finally
    {
        if (hkeyCat42 != NULL)
            RegCloseKey(hkeyCat42);
    }

    return hr;
}



/********************************************************************++

Routine Description:
    Prepares the catalog, and also prepares the app domain factory.

Arguments:

Returns:
    S_OK if successful, failure code if not.

--********************************************************************/

HRESULT
WP_CONFIG::InitConfiguration()
{
    static const WCHAR cookedCatalogName[] = L"WASMB.CLB";
    HRESULT hr = S_OK;

    // Get the duct-tape root directory.
    WCHAR path[MAX_PATH + 1];
    size_t pathLength = MAX_PATH;
    hr = GetDuctTapeRoot(path, &pathLength);
    if (FAILED(hr))
        return hr;

    // Construct the catalog name by appending to the duct-tape root.
    wcscat(path + pathLength, cookedCatalogName);

    m_catFile = _wcsdup(path);
    if (m_catFile == NULL)
        return E_OUTOFMEMORY;

    // Construct the query cells used in subsequent queries.
    m_queryCell[0].pData = (void*)m_catFile;
    m_queryCell[0].eOperator = eST_OP_EQUAL;
    m_queryCell[0].iCell = iST_CELL_FILE;
    m_queryCell[0].dbType = DBTYPE_WSTR;
    m_queryCell[0].cbSize = (pathLength * sizeof m_catFile[0]) + sizeof cookedCatalogName;

    // Get the SimpleTable dispenser
    hr = GetSimpleTableDispenser(WSZ_PRODUCT_URT, 0, &m_istDispenser);
    if (m_istDispenser == NULL)
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Could not get simple table dispenser for %S, hr=0x%x\n",
                        WSZ_PRODUCT_URT, hr
                        ));
        }

        return hr;
    }

    // Initialize our xspisapi imports.
    m_xspisapiDLL = LoadXSP();
    if (m_xspisapiDLL == NULL)
        return HRESULT_FROM_WIN32(GetLastError());

    APP_DOMAIN_INIT_FACTORY* AppDomainInitFactory;

    AppDomainInitFactory = (APP_DOMAIN_INIT_FACTORY*)GetProcAddress(m_xspisapiDLL,
                                                                    "AppDomainInitFactory");
    _AppDomainUninitFactory = (APP_DOMAIN_UNINIT_FACTORY*)GetProcAddress(m_xspisapiDLL,
                                                                  "AppDomainUninitFactory");
    _AppDomainGetObject = (APP_DOMAIN_GET_OBJECT*)GetProcAddress(m_xspisapiDLL,
                                                                 "AppDomainGetObject");

    // Initialize XSP's app domain factory.
    path[pathLength] = L'\0';
    wcscat(path + pathLength, L"System.IIS.dll");

    hr = AppDomainInitFactory(path, L"System.IIS.Hosting.ULManagedWorker");
    if (FAILED(hr))
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Could not initialize the app domain factory, hr=0x%x\n",
                        hr
                        ));
        }
    }

    return hr;
} // WP_CONFIG::InitConfiguration()


HRESULT
WP_CONFIG::UnInitConfiguration()
{
    HRESULT hr = _AppDomainUninitFactory();

    FreeLibrary(m_xspisapiDLL);

    return hr;
}


xspmrt::_ULManagedWorker*
WP_CONFIG::ChooseWorker(void* pvRequest)
{
    UL_HTTP_REQUEST* request = (UL_HTTP_REQUEST*)pvRequest;

    // Get the UrlContext, which is actually the AppID.
    UL_URL_CONTEXT urlContext = request->UrlContext;

    xspmrt::_ULManagedWorker* worker = NULL;
    WCHAR* appPath = NULL;
    WCHAR* rootDirectory = NULL;
    DWORD siteID = 0;
    HRESULT hr = S_OK;
    FILETIME ftCreateTime;
    LARGE_INTEGER liCreateTime;

    WCHAR appID[sizeof "12345678"];
    DwordToHexString((DWORD)urlContext, appID);

    __try
    {
        EnterCriticalSection(&m_workerTableGuard);

        // Look for an existing worker in an existing app domain.
        hr = _AppDomainGetObject(appID, NULL, (IUnknown**)&worker);
        if (FAILED(hr))
            __leave;

        if (hr == S_FALSE)
        {
            // The worker is new, so we need to initialize it.

            if (m_mszURLList.First() != NULL)
            {
                // We're launching this from the command line.  The
                // root directory is given in m_homeDirectory, and
                // we're going to hard-code the application as "/".

                if (m_homeDirectory == NULL)
                {
                    // Kludge
                    WCHAR defaultHome[] = L"%SystemDrive%\\InetPub\\DtRoot";
                    WCHAR buf[MAX_PATH + 1];
                    size_t len = ExpandEnvironmentStrings(defaultHome, buf, MAX_PATH);
                    if (len == 0)
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        __leave;
                    }

                    m_homeDirectory = _wcsdup(buf);
                    if (m_homeDirectory == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        __leave;
                    }
                }

                rootDirectory = _wcsdup(m_homeDirectory);
                appPath = _wcsdup(L"/");
                if (rootDirectory == NULL || appPath == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    __leave;
                }
            }
            else
            {
                // Find the Application info we need:  the corresponding site ID,
                // and the application path.
                hr = GetAppInfo(urlContext, &appPath, &siteID);
                if (FAILED(hr))
                    __leave;

                // Get the useful information about the corresponding site: it's
                // home directory.
                hr = GetSiteInfo(siteID, &rootDirectory);
                if (FAILED(hr))
                    __leave;
            }

            // BUGBUG! For now, form the physical app path by concatenating
            // the
            WCHAR appPhysPath[MAX_PATH+1];
            wcscpy(appPhysPath, rootDirectory);
            wcscat(appPhysPath, appPath);
            // Find any "/" and turn them to "\".
            for (WCHAR* p = appPhysPath; *p != L'\0'; ++p)
            {
                if (*p == L'/')
                    *p = L'\\';
            }

            hr = _AppDomainGetObject(appID, appPhysPath, (IUnknown**)&worker);
            if (FAILED(hr))
                __leave;

            //
            // Get the current filetime.  This timestamp for appdomain
            // creation will be used in generating lame ETags for now
            //

            GetSystemTimeAsFileTime( &ftCreateTime );
            liCreateTime.LowPart = ftCreateTime.dwLowDateTime;
            liCreateTime.HighPart = ftCreateTime.dwHighDateTime;

            hr = worker->Initialize(m_pwszAppPoolName,
                                    rootDirectory,
                                    appPath,
                                    liCreateTime.QuadPart);
            if (FAILED(hr))
            {
                worker->Release();
                worker = NULL;
                __leave;
            }
        }
    }
    __finally
    {
        LeaveCriticalSection(&m_workerTableGuard);

        free(appPath);
        free(rootDirectory);
    }

    return worker;
}

HRESULT
WP_CONFIG::GetTable(const WCHAR* tableID, ISimpleTableRead2** pIst)
{
    *pIst = NULL;

    unsigned long numCells = sizeof m_queryCell / sizeof m_queryCell[0];

    HRESULT hr = m_istDispenser->GetTable(wszDATABASE_URTGLOBAL,
                                          tableID,
                                          &m_queryCell,
                                          &numCells,
                                          eST_QUERYFORMAT_CELLS,
                                          0, // fServiceRequests
                                          reinterpret_cast<void**>(pIst));
    if (FAILED(hr) || pIst == NULL)
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Could not get %S table from dispenser\n",
                       tableID));
        }

        *pIst = NULL;
    }

    return hr;
}

HRESULT
WP_CONFIG::GetAppInfo(UL_URL_CONTEXT urlContext, WCHAR** pAppPath, DWORD* pSiteID)
{
    HRESULT hr = S_OK;
    StupidComPointer<ISimpleTableRead2> istApplications;

    *pAppPath = NULL;
    *pSiteID = 0;

    DWORD appID = urlContext;

    m_queryCell[1].eOperator = eST_OP_EQUAL;
    m_queryCell[1].iCell = iAPPS_AppID;
    m_queryCell[1].dbType = DBTYPE_I4;
    m_queryCell[1].cbSize = sizeof appID;
    m_queryCell[1].pData = &appID;

    hr = GetTable(wszTABLE_APPS, &istApplications);
    if (FAILED(hr))
        return hr;

    static ULONG appColumns[] = {
        iAPPS_AppURL,
        iAPPS_SiteID
    };
    static const size_t numAppColumns = sizeof appColumns / sizeof appColumns[0];

    void* appValues[cAPPS_NumberOfColumns];
    hr = istApplications->GetColumnValues(0,
                                          numAppColumns,
                                          appColumns,
                                          NULL,
                                          appValues);
    if (FAILED(hr))
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Could not get Application row (AppID=%UI64) from dispenser\n",
                       urlContext));
        }
        return hr;
    }

    *pSiteID = *(DWORD*)appValues[iAPPS_SiteID];
    *pAppPath = _wcsdup((WCHAR*)appValues[iAPPS_AppURL]);
    if (*pAppPath == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT
WP_CONFIG::GetSiteInfo(DWORD siteID, WCHAR** pHomeDirectory)
{
    HRESULT hr = S_OK;
    StupidComPointer<ISimpleTableRead2> istSites;

    *pHomeDirectory = NULL;

    m_queryCell[1].eOperator = eST_OP_EQUAL;
    m_queryCell[1].iCell = iSITES_SiteID;
    m_queryCell[1].dbType = DBTYPE_I4;
    m_queryCell[1].cbSize = sizeof siteID;
    m_queryCell[1].pData = &siteID;

    hr = GetTable(wszTABLE_SITES, &istSites);
    if (FAILED(hr))
        return hr;

    static ULONG siteColumns[] = {
        iSITES_HomeDirectory,
        iSITES_Bindings
    };
    static const size_t numSiteColumns = sizeof siteColumns / sizeof siteColumns[0];

    void* siteValues[cSITES_NumberOfColumns];
    hr = istSites->GetColumnValues(0,
                                   numSiteColumns,
                                   siteColumns,
                                   NULL,
                                   siteValues);
    if (FAILED(hr))
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Error reading Sites row.\n"));
        }
        return hr;
    }

    // Expand any environment variables in the root directory.
    WCHAR rootDirectory[MAX_PATH+1];
    size_t rootDirLen = ExpandEnvironmentStrings((WCHAR*)siteValues[iSITES_HomeDirectory],
                                                 rootDirectory,
                                                 MAX_PATH);
    if (rootDirLen == 0)
    {
        IF_DEBUG( TRACE)
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Error while expanding environment strings.\n"));
        }
        return HRESULT_FROM_WIN32(GetLastError());
    }

    *pHomeDirectory = _wcsdup(rootDirectory);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\test\rwp_gui\place.inc ===
C_DEFINES = $(C_DEFINES) /DUNICODE /D_UNICODE

RWPBIN=$(BASEDIR)\private\inet\iisrearc\core\iiswp\test\rwp_gui\bin
NEW_JVC=$(RWPBIN)\jvc.exe /x-
NEW_JVCWARNINGLEVEL=/w4
NEW_JVCFLAGS=/nologo /nomessage $(NEW_JVCWARNINGLEVEL)

!if "$(NTDEBUG)" != ""
NEW_JVCFLAGS = $(NEW_JVCFLAGS) /D DBG /g /O-
!else
NEW_JVCFLAGS = $(NEW_JVCFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\adminmonitor.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    adminmonitor.h

        Declarations for using the IISAdmin Monitor.
*/

#ifndef _ADMINMONITOR_H_
#define _ADMINMONITOR_H_

enum INETINFO_CRASH_ACTION
{
    NotifyAfterInetinfoCrash = 0,
    ShutdownAfterInetinfoCrash,
    RehookAfterInetinfoCrash
};

typedef HRESULT (*PFN_IISAdminNotify)(INETINFO_CRASH_ACTION);

HRESULT
StartIISAdminMonitor(
    PFN_IISAdminNotify pfnNotifyIISAdminCrash
    );

VOID
StopIISAdminMonitor(
    );
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\iiswp\test\rwp_gui\makefile.inc ===
#
# Defines build rules for targets that makefile.def
# won't build. !include this file in your makefile.inc
#

####################################
# JAVA COMPILER SPECIFIC
####################################

NEW_JVCCOMMAND=$(NEW_JVC) $(NEW_JVCFLAGS) /cp $(JAVA_CLASS_PATH) /d $(O)

!if "$(JAVACLS)" != ""
$(JAVACLS) : $(JAVASOURCES)
    $(NEW_JVCCOMMAND) $(JAVASOURCES)
        COPY $(JAVARES) $(O)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\irtldbg.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  define IRTLDEBUG
# endif

# ifdef IRTLDEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>
#   define IRTLASSERT(f) DBG_ASSERT(f)
#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\hashfn.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKRhash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


#ifndef __HASHFN_NO_NAMESPACE__
namespace HashFn {
#endif // !__HASHFN_NO_NAMESPACE__

// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKRhash applies this internally
// to all hash signatures for exactly this reason.

inline DWORD
HashScramble(DWORD dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const DWORD RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const DWORD RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Faster scrambling function suggested by Eric Jacobsen

inline DWORD
HashRandomizeBits(DWORD dw)
{
	return (((dw * 1103515245 + 12345) >> 16)
            | ((dw * 69069 + 1) & 0xffff0000));
}


// Small prime number used as a multiplier in the supplied hash functions
const DWORD HASH_MULTIPLIER = 101;

#undef HASH_SHIFT_MULTIPLY

#ifdef HASH_SHIFT_MULTIPLY
# define HASH_MULTIPLY(dw)   (((dw) << 7) - (dw))
#else
# define HASH_MULTIPLY(dw)   ((dw) * HASH_MULTIPLIER)
#endif

// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKRhash.

inline DWORD
HashString(
    const char* psz,
    DWORD       dwHash = 0)
{
    // force compiler to use unsigned arithmetic
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *upsz;

    return dwHash;
}


// Unicode version of above

inline DWORD
HashString(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKRhash.
// Note: this is not really adequate for MBCS strings.

inline DWORD
HashStringNoCase(
    const char* psz,
    DWORD       dwHash = 0)
{
    const unsigned char* upsz = (const unsigned char*) psz;

    for (  ;  *upsz;  ++upsz)
        dwHash = HASH_MULTIPLY(dwHash)
                     +  (*upsz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

inline DWORD
HashStringNoCase(
    const wchar_t* pwsz,
    DWORD          dwHash = 0)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = HASH_MULTIPLY(dwHash)  +  (*pwsz & 0xFFDF);

    return dwHash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
// 
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
// 
//     inline DWORD Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
// 
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     DWORD Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           HASH_MULTIPLIER * Hash(rFoo.m_ch)
//                               +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKRhash.

inline DWORD
HashBlob(
    const void* pv,
    size_t      cb,
    DWORD       dwHash = 0)
{
    LPBYTE pb = static_cast<LPBYTE>(const_cast<void*>(pv));

    while (cb-- > 0)
        dwHash = HASH_MULTIPLY(dwHash)  +  *pb++;

    return dwHash;
}



//
// Overloaded hash functions for all the major builtin types.
// Again, apply HashScramble to result if using with something other than
// LKRhash.
//

inline DWORD Hash(const char* psz)
{ return HashString(psz); }

inline DWORD Hash(const unsigned char* pusz)
{ return HashString(reinterpret_cast<const char*>(pusz)); }

inline DWORD Hash(const signed char* pssz)
{ return HashString(reinterpret_cast<const char*>(pssz)); }

inline DWORD Hash(const wchar_t* pwsz)
{ return HashString(pwsz); }

inline DWORD
Hash(
    const GUID* pguid,
    DWORD       dwHash = 0)
{
    
    return * reinterpret_cast<DWORD*>(const_cast<GUID*>(pguid)) + dwHash;
}

// Identity hash functions: scalar values map to themselves
inline DWORD Hash(char c)
{ return c; }

inline DWORD Hash(unsigned char uc)
{ return uc; }

inline DWORD Hash(signed char sc)
{ return sc; }

inline DWORD Hash(short sh)
{ return sh; }

inline DWORD Hash(unsigned short ush)
{ return ush; }

inline DWORD Hash(int i)
{ return i; }

inline DWORD Hash(unsigned int u)
{ return u; }

inline DWORD Hash(long l)
{ return l; }

inline DWORD Hash(unsigned long ul)
{ return ul; }

inline DWORD Hash(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        DWORD dw;
    } u;
    u.f = f;
    return u.dw;
}

inline DWORD Hash(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        DWORD  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * HASH_MULTIPLIER  +  u.dw[1];
}

#ifndef __HASHFN_NO_NAMESPACE__
}
#endif // !__HASHFN_NO_NAMESPACE__

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\irtltoken.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtltoken.h

   Abstract:
       IISUtil token goo

   Author:
       Wade A. Hilmo (wadeh)    5-Dec-2000

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

// token acl utilities
HRESULT
WINAPI
GrantWpgAccessToToken(
    HANDLE  hToken
    );

HRESULT
WINAPI
AddWpgToTokenDefaultDacl(
    HANDLE  hToken
    );

// token dup tool
BOOL 
DupTokenWithSameImpersonationLevel
( 
    HANDLE     hExistingToken,
    DWORD      dwDesiredAccess,
    TOKEN_TYPE TokenType,
    PHANDLE    phNewToken
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisUtil.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisUtil.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// Heap routines
    
// Private IIS heap
HANDLE
WINAPI 
IisHeap();

// Allocate dwBytes
LPVOID
WINAPI
IisMalloc(
    IN SIZE_T dwBytes);

// Allocate dwBytes. Memory is zeroed
LPVOID
WINAPI
IisCalloc(
    IN SIZE_T dwBytes);

// Reallocate lpMem to dwBytes
LPVOID
WINAPI
IisReAlloc(
    IN LPVOID lpMem,
    IN SIZE_T dwBytes);

// Free lpMem
BOOL
WINAPI
IisFree(
    IN LPVOID lpMem);

// additional IISUtil initialization
BOOL
WINAPI 
InitializeIISUtil();

// call before unloading IISUtil
void
WINAPI 
TerminateIISUtil();

// case-insensitive strstr
IRTL_DLLEXP const char* stristr(const char* pszString, const char* pszSubString);

// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\lkrhash.h ===
/*++

   Copyright    (c) 1998-2001    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Services Rearchitecture Core Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#define LKR_STL_ITERATORS 1
// #define LKR_DEPRECATED_ITERATORS
#define LKR_APPLY_IF
#undef  LKR_COUNTDOWN

#define __HASHFN_NO_NAMESPACE__
#define __LKRHASH_NO_NAMESPACE__

#ifndef LKR_TABLE_LOCK
# define LKR_TABLE_LOCK  CReaderWriterLock3
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifdef LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock3
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CSmallSpinLock
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Provide support for multiple, identical keys. Needed for EqualRange,
//   hash_multiset, and hash_multimap.
// * Provide implementations of the STL collection classes: hash_map,
//   hash_set, hash_multimap, and hash_multiset.
// * Make exception-safe.
// * Use auto_ptrs.
// * Add some kind of auto object for readlocking or writelocking a table,
//   so that the table automatically gets unlocked by auto-obj's destructor.
// * Provide a C API wrapper
// * Port to kernel mode (will require different locks, at the very least)
// * Port to managed code (Chris Tracy has started on this)
// * Typedef hash signatures (currently DWORDs)
// * Make available as a static library as well as a DLL
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifndef __LSTENTRY_H__
# include <lstentry.h>
#endif

#ifndef __HASHFN_H__
# include <hashfn.h>
#endif

#include <limits.h>


#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <utility>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS


// Used to initialize and destroy custom allocators
extern "C" bool LKRHashTableInit();
extern "C" void LKRHashTableUninit();


enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};


// Default values for the hashtable constructors
enum {
#ifndef _WIN64
    LK_DFLT_MAXLOAD=     6, // Default upperbound on average chain length.
#else // _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#endif // _WIN64
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


// obsolete build fix hack
// enum {
//     DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
//     DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
//     DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
// };


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


#ifdef LKR_APPLY_IF

//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};

#endif // LKR_APPLY_IF

#if defined(LKR_DEPRECATED_ITERATORS) || defined(LKR_APPLY_IF)
//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};

#endif // LKR_DEPRECATED_ITERATORS || LKR_APPLY_IF



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes.  It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



// Use types defined in recent versions of the Platform SDK in basetsd.h.
#ifndef _W64
typedef DWORD DWORD_PTR;   // integral type big enough to hold a pointer
#endif

//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

#ifdef LKR_APPLY_IF
// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);
#endif // LKR_APPLY_IF



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#ifndef LKR_NO_ALLOCATORS
# define LKRHASH_ACACHE 1
// # define LKRHASH_MANODEL 1
// # define LKRHASH_MADEL 1
// # define LKRHASH_ROCKALL_FAST 1

// # define LKRHASH_MEM_DEFAULT_ALIGN 32
#endif // !LKR_NO_ALLOCATORS

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif // !LKRHASH_MEM_DEFAULT_ALIGN

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("LKRhash:" #C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
public:
    FastHeap(
        SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T m_cb;
};

  typedef FastHeap  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new FastHeap(sizeof(C));

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend class CLKRLinearHashTable;                       \
        friend bool LKRHashTableInit();                         \
        friend void LKRHashTableUninit();                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
            IRTLASSERT(s == sizeof(C));                         \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            IRTLASSERT(C::sm_palloc == NULL);                   \
            LKRHASH_ALLOCATOR_NEW(C, N);                        \
            f = (C::sm_palloc != NULL);                         \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        if (C::sm_palloc != NULL)                               \
        {                                                       \
            delete C::sm_palloc;                                \
            C::sm_palloc = NULL;                                \
        }                                                       \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;



// Class for nodes on a bucket chain.  Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly.  It also reduces memory fragmentation and memory
// allocator overhead.  It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful.  In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators.  Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or
    // two) cache lines.  3 ==> 32 bytes, 7 ==> 64 bytes
    // Note: the default max load factor is 6.0, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
        BUCKET_BYTE_SIZE = 64,
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(CNodeClump*),
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
    };

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
#ifndef LKR_COUNTDOWN
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
        // for (int x = 0;  x < NODES_PER_CLUMP;  ++x) ...
#else // LKR_COUNTDOWN
        NODE_BEGIN = NODES_PER_CLUMP-1,
        NODE_END   = -1,
        NODE_STEP  = -1,
        // for (int x = NODES_PER_CLUMP;  --x >= 0;  ) ...
#endif // LKR_COUNTDOWN
    };

    enum {
        // No number in 0..2^31-1 maps to this number after it has been
        // scrambled by HashFn::HashRandomizeBits
        HASH_INVALID_SIGNATURE = 31678523,
    };

    DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
    CNodeClump* m_pncNext;               // next node clump on the chain
    const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

    CNodeClump()
    {
        Clear();
    }

    void
    Clear()
    {
        m_pncNext = NULL;  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0; )
        {
            m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            m_pvNode[i] = NULL;
        }
    }

    bool
    InvalidSignature(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_pvNode[i] == NULL);
    }

    bool
    IsEmptyAndInvalid(
        int i) const
    {
        return IsEmptyNode(i) && InvalidSignature(i);
    }

    bool
    IsEmptySlot(
        int i) const
    {
        return InvalidSignature(i);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    // Don't want overhead of calls to dtor in retail build
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0;  )
            IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
}; // class CNodeClump



// Class for bucket chains of the hash table.  Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
private:
    typedef LKR_BUCKET_LOCK BucketLock;
    mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "B%06x", 0xFFFFFF & l);
        return s_szName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= 64);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

    void  WriteLock()           { m_Lock.WriteLock(); }
    void  ReadLock() const      { m_Lock.ReadLock(); }
    void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
    void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
    bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSmallSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment


// Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
class CSmallSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =            3,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
    };

    // Hack: assumes immediately after CSegment::m_bktSlots, with no
    // padding. The STATIC_ASSERT in _AllocateSegment should cause a
    // compile-time error if this assumption is false.
    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CSmallSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
}; // class CSmallSegment


// Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
class CMediumSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            6,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 2 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CMediumSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
}; // class CMediumSegment


// Large-sized segments contain 2^9 = 512 buckets => ~32Kb
class CLargeSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            9,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 4 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CLargeSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
}; // class CLargeSegment



// A directory keeps track of the segments comprising the hash table.
// The directory is just a variable-sized array of pointers to
// segments (CDirEntrys).
class CDirEntry
{
public:
    // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
    // of anything else.  Should be powers of two.
    enum {
        MIN_DIRSIZE =  (1<<3),   // minimum directory size
        MAX_DIRSIZE = (1<<20),   // maximum directory size
    };

    CSegment* m_pseg;

    CDirEntry()
        : m_pseg(NULL)
    {}

    ~CDirEntry()
    { delete m_pseg; }
}; // class CDirEntry



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    CLKRLinearHashTable* m_plht;        // which linear hash table?
    CNodeClump*          m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    short                m_iNode;       // offset within m_pnc

    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN      = CNodeClump::NODE_BEGIN,
        NODE_END        = CNodeClump::NODE_END,
        NODE_STEP       = CNodeClump::NODE_STEP,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        CNodeClump*          pnc,
        DWORD                dwBucketAddr,
        short                iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }

    inline void _AddRef(
        int nIncr) const;

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }

    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(+1);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(+1);
        this->_AddRef(-1);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(-1);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_pvNode[m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;

protected:
    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    short                           m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        short          ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these
    // methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {

        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
            fValid = (m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE            = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE            = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE              = 16,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };


private:

    //
    // Miscellaneous helper functions
    //

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask0); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        IRTLASSERT(m_pfnAddRefRecord != NULL);
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const
    { return m_Lock.ReadOrWriteLock(); }

    void _ReadOrWriteUnlock(bool fReadLocked) const
    { m_Lock.ReadOrWriteUnlock(fReadLocked); }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const char*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static char s_szName[CLockStatistics::L_NAMELEN];
        wsprintf(s_szName, "LH%05x", 0xFFFFF & l);
        return s_szName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    const bool    m_fMultiKeys;     // Allow multiple identical keys?

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite
#ifdef LKR_STL_ITERATORS
                             , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                               );
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRLinearHashTable(const CLKRLinearHashTable&)
        : m_dwSignature(SIGNATURE_FREE)
#ifdef LOCK_INSTRUMENTATION
        , m_Lock(NULL)
#endif // LOCK_INSTRUMENTATION
        , m_nTableLockType(0),
          m_nBucketLockType(0),
          m_fMultiKeys(false),
          m_phtParent(NULL)
    {*(BYTE*)NULL;}

    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&)
    {return *(CLKRLinearHashTable*)NULL;}

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
        );

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    int                NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return false;
        // return m_fMultiKeys;     // TODO: implement
    }

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
        if (!IsUsable())
            return m_lkrcState;

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }


#ifdef LKR_APPLY_IF
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF


    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount() const
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    //
    // Lock manipulators
    //

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive() const
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);


#ifdef LKR_DEPRECATED_ITERATORS

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature, Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in table
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    int nIncr) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (nIncr == -1 ||  nIncr == +1));
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
        IRTLASSERT(pvRecord != NULL);
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        m_plht->_AddRefRecord(pvRecord, nIncr);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

    friend class CLKRLinearHashTable;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

    enum {
        MAX_SUBTABLES = 64,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    int            m_nSubTableMask;

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // Must provide a (bad) implementation because we export instantiations.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&)             {*(BYTE*)NULL;}
    CLKRHashTable& operator=(const CLKRHashTable&)  {return *(CLKRHashTable*)NULL;}


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    int          _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
    );

    static bool
    _FreeSubTable(
        SubTable* plht);


public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    int                NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_APPLY_IF
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive() const;
    void        ConvertExclusiveToShared() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&)             {*(BYTE*)NULL;}
        CIterator& operator=(const CIterator&)  {return *(CIterator*)NULL;}

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------

#define LKRHASH_HACKY_CAST(T, pv)  ((T) (UINT_PTR) (pv))

template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_APPLY_IF
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        _Key           key  = static_cast<_Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here, but the stupid
        // Win64 compiler thinks it knows better than I do.
        return (const DWORD_PTR) (key);
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        _Key key = LKRHASH_HACKY_CAST(_Key, pnKey);
        return _Derived::CalcKeyHash(key);
    }

    static bool WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        _Key key1 = LKRHASH_HACKY_CAST(_Key, pnKey1);
        _Key key2 = LKRHASH_HACKY_CAST(_Key, pnKey2);
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls,
                            fMultiKeys)
    {}

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    {
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::DeleteKey(pnKey);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        _BaseHashTable::Iterator            m_iter;

        iterator(
            _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        reference operator*() const
        {
            void* pvRecord = const_cast<void*>(m_iter.Record());
            return reinterpret_cast<reference>(pvRecord);
        }

        pointer   operator->() const  { return &(operator*()); }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter == rhs.m_iter;
        }

        bool operator!=(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator!=, this=%p, rhs=%p\n"),
                           this, &rhs);
            return m_iter != rhs.m_iter;
        }

        _Record*  Record() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Record, this=%p\n"), this);
            return reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record()));
        }

        _Key      Key() const
        {
            LKR_ITER_TRACE(_TEXT("Typed::Key, this=%p\n"), this);
            return reinterpret_cast<_Key>(
                        reinterpret_cast<void*>(m_iter.Key()));
        }
    }; // class iterator

    // Return iterator pointing to first item in table
    iterator begin()
    {
        LKR_ITER_TRACE(_TEXT("Typed::begin()\n"));
        return iterator(_BaseHashTable::Begin());
    }

    // Return a one-past-the-end iterator. Always empty.
    iterator end()
    {
        LKR_ITER_TRACE(_TEXT("Typed::end()\n"));
        return iterator(_BaseHashTable::End());
    }

    template <class _InputIterator>
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        _InputIterator f,                     // first element in range
        _InputIterator l,                     // one-beyond-last element
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                         _AddRefRecord, maxload, initsize, num_subtbls,
                         fMultiKeys)
    {
        insert(f, l);
    }

    template <class _InputIterator>
    void insert(_InputIterator f, _InputIterator l)
    {
        for ( ;  f != l;  ++f)
            InsertRecord(&(*f));
    }

    bool
    Insert(
        const _Record* pRecord,
        iterator& riterResult,
        bool fOverwrite=false)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Insert\n"));
        return _BaseHashTable::Insert(pRecord, riterResult.m_iter, fOverwrite);
    }

    bool
    Erase(
        iterator& riter)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase\n"));
        return _BaseHashTable::Erase(riter.m_iter);
    }

    bool
    Erase(
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Erase2\n"));
        return _BaseHashTable::Erase(riterFirst.m_iter, riterLast.m_iter);
    }

    bool
    Find(
        const _Key key,
        iterator& riterResult)
    {
        LKR_ITER_TRACE(_TEXT("Typed::Find\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::Find(pnKey, riterResult.m_iter);
    }

    bool
    EqualRange(
        const _Key key,
        iterator& riterFirst,
        iterator& riterLast)
    {
        LKR_ITER_TRACE(_TEXT("Typed::EqualRange\n"));
        const void* pvKey = reinterpret_cast<const void*>((DWORD_PTR)(key));
        DWORD_PTR   pnKey = reinterpret_cast<DWORD_PTR>(pvKey);
        return _BaseHashTable::EqualRange(pnKey, riterFirst.m_iter,
                                          riterLast.m_iter);
    }

    // The iterator functions for an STL hash_(|multi)_(set|map)
    //
    // Value type of a Pair-Associative Container is
    //     pair<const key_type, mapped_type>
    //
    // pair<iterator,bool> insert(const value_type& x);
    //
    // void erase(iterator pos);
    // void erase(iterator f, iterator l);
    //
    // iterator find(const key_type& k) [const];
    // const_iterator find(const key_type& k) const;
    //
    // pair<iterator,iterator> equal_range(const key_type& k) [const];
    // pair<const_iterator,const_iterator> equal_range(const key_type& k) const


#endif // LKR_STL_ITERATORS
};



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__


#endif // __LKRHASH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\mb_notify.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    mb_notify.h

Abstract:

    Type definitions for handling metabase change notifications.

Author:

    Taylor Weiss (TaylorW)       26-Jan-1999

Revision History:

--*/

#ifndef _MB_NOTIFY_H_
#define _MB_NOTIFY_H_

/************************************************************
 *  Include Headers
 ************************************************************/


/************************************************************
 *  Type Definitions  
 ************************************************************/

/*++

class MB_BASE_NOTIFICATION_SINK

    Base class that implements a COM object that will
    register and listen for metabase change notifications.
    It provides no useful implementation of the IMSAdminBaseSink
    methods.

    Currently the only client of this in the worker process
    is the W3_SERVER.

--*/

class MB_BASE_NOTIFICATION_SINK
    : public IMSAdminBaseSink
    
{
public:

    // Contruction and Destruction

    dllexp MB_BASE_NOTIFICATION_SINK();

    virtual dllexp 
    ~MB_BASE_NOTIFICATION_SINK();

    // IUnknown

    dllexp STDMETHOD_(ULONG, AddRef)();

    dllexp STDMETHOD_(ULONG, Release)();

    dllexp STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject);

    
    // IMSAdminBaseSink

    dllexp STDMETHOD( ShutdownNotify )();
    
    dllexp STDMETHOD( SinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        ) ;

    //
    // SynchronizedShutdownNotify() and SynchronizedSinkNotify() are 
    // synchronized versions of ShutdownNotify() and SinkNotify().
    // 
    // SinkNotify() calls SynchronizedSinkNotify() in critical section
    // SynchronizedSinkNotify() will never be called after StopListening() 
    // call returned. StopListening() will also wait till last callback 
    // to SynchronizedSinkNotify() completed.
    // Thus caller of StopListening() has guarantee 
    // that resources used by SynchronizedSinkNotify() 
    // can be freed without worries
    //
    
    dllexp STDMETHOD( SynchronizedShutdownNotify )();
    
    // Clients must provide some useful implementation of this
    STDMETHOD( SynchronizedSinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        ) = 0;


    // Public methods

    dllexp
    HRESULT
    StartListening( IUnknown * pUnkAdminBase );

    dllexp
    HRESULT
    StopListening( IUnknown * pUnkAdminBase );

protected:

    LONG                m_Refs;
    DWORD               m_SinkCookie;
    CRITICAL_SECTION    m_csListener;
    BOOL                m_fInitCsListener;
    BOOL                m_fStartedListening;

};

#endif // _MB_NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\perfcount.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    perfcount.h

Abstract:

    Counter Block definitions for sets of
    counters that are supported by IIS 6.

    These counter blocks contain the PERF_COUNTER_BLOCK
    object as well as an entry for each counter.

Author:

    Emily Kruglick (EmilyK)  7-Sept-2000

Revision History:

--*/


#ifndef _PERFCOUNT_H_
#define _PERFCOUNT_H_

//
// Used by the perflib to do the offsets for 
// the counters in the counter definitions.
// Used by WAS to put counters work with counters
// stored in the shared memory.
//

//
// Note:  These structures should be 8-byte aligned.
//        so if you add a counter and it throws this
//        of you will need to add another bogus DWORD
//        to make sure it stays aligned.
//

typedef struct _W3_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK  PerfCounterBlock;

    ULONGLONG           BytesSent;
    ULONGLONG           BytesReceived;
    ULONGLONG           BytesTotal;

    DWORD               FilesSent;
    DWORD               FilesReceived;
    DWORD               FilesTotal;

    DWORD               CurrentAnonymous;
    DWORD               CurrentNonAnonymous;
    DWORD               TotalAnonymous;
    DWORD               TotalNonAnonymous;

    DWORD               MaxAnonymous;
    DWORD               MaxNonAnonymous;
    DWORD               CurrentConnections;
    DWORD               MaxConnections;

    DWORD               ConnectionAttempts;
    DWORD               LogonAttempts;
    DWORD               TotalOptions;
    DWORD               TotalGets;

    DWORD               TotalPosts;
    DWORD               TotalHeads;
    DWORD               TotalPuts;
    DWORD               TotalDeletes;

    DWORD               TotalTraces;
    DWORD               TotalMove;
    DWORD               TotalCopy;
    DWORD               TotalMkcol;

    DWORD               TotalPropfind;
    DWORD               TotalProppatch;
    DWORD               TotalSearch;
    DWORD               TotalLock;

    DWORD               TotalUnlock;
    DWORD               TotalOthers;
    DWORD               TotalRequests;
    DWORD               TotalCGIRequests;

    DWORD               TotalBGIRequests;
    DWORD               TotalNotFoundErrors;
    DWORD               TotalLockedErrors;
    DWORD               CurrentCGIRequests;

    DWORD               CurrentBGIRequests;
    DWORD               MaxCGIRequests;
    DWORD               MaxBGIRequests;
    DWORD               CurrentCalAuth;

    DWORD               MaxCalAuth;
    DWORD               TotalFailedCalAuth;
    DWORD               CurrentCalSsl;
    DWORD               MaxCalSsl;

    DWORD               TotalFailedCalSsl;
    DWORD               BlockedRequests;
    DWORD               AllowedRequests;
    DWORD               RejectedRequests;

    DWORD               CurrentBlockedRequests;
    DWORD               MeasuredBandwidth;
    DWORD               TotalBlockedBandwidthBytes;
    DWORD               CurrentBlockedBandwidthBytes;

    DWORD               ServiceUptime;
    DWORD               BogusAlignmentDWORD;

} W3_COUNTER_BLOCK, * PW3_COUNTER_BLOCK;

typedef struct _W3_GLOBAL_COUNTER_BLOCK {
    PERF_COUNTER_BLOCK  PerfCounterBlock;

    DWORD CurrentFilesCached;
    DWORD TotalFilesCached;
    DWORD FileCacheHits;

    ULONGLONG CurrentFileCacheMemoryUsage;
    ULONGLONG MaxFileCacheMemoryUsage;

    DWORD FileCacheMisses;
    DWORD FileCacheHitRatio;
    DWORD FileCacheFlushes;
    DWORD ActiveFlushedFiles;

    DWORD TotalFlushedFiles;
    DWORD CurrentUrisCached;
    DWORD TotalUrisCached;
    DWORD UriCacheHits;

    DWORD UriCacheMisses;
    DWORD UriCacheHitRatio;
    DWORD UriCacheFlushes;
    DWORD TotalFlushedUris;

    DWORD CurrentBlobsCached;
    DWORD TotalBlobsCached;
    DWORD BlobCacheHits;
    DWORD BlobCacheMisses;

    DWORD BlobCacheHitRatio;
    DWORD BlobCacheFlushes;
    DWORD TotalFlushedBlobs;
    DWORD UlCurrentUrisCached;

    DWORD UlTotalUrisCached;
    DWORD UlUriCacheHits; 
    DWORD UlUriCacheMisses; 
    DWORD UlUriCacheHitRatio; 

    DWORD UlUriCacheFlushes;
    DWORD UlTotalFlushedUris;

} W3_GLOBAL_COUNTER_BLOCK, * PW3_GLOBAL_COUNTER_BLOCK;

#endif  // _PERFCOUNT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\perf_sm.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_sm.h

Abstract:

    Owns all shared memory operations used to 
    support performance counters.

Classes:

    PERF_SM_MANAGER
    PERF_SM_READER  (nested class of the Manager)
    PERF_SM_WRITER  (nested class of the Manager)

Author:

    Emily Kruglick (EmilyK)        6-Sept-2000

Revision History:

--*/


#ifndef _PERF_SM_H_
#define _PERF_SM_H_

//
// typdefs, structs, enums...
//

// 
// Structure of all the global data
// stored at the first piece of the 
// shared memory.
//
typedef struct _COUNTER_GLOBAL_STRUCT
{
    DWORD NumInstances;
    DWORD SizeData;
} COUNTER_GLOBAL_STRUCT;

//
// Structure for controlling each
// set of counters.
//
typedef struct _COUNTER_CONTROL_BLOCK
{
    DWORD Version;
    BOOL ActivePageIsA;
} COUNTER_CONTROL_BLOCK;

//
// For every valid counter set you
// must declare an entry in 
// g_CounterSetPrefixNames in the
// shared memory module.
//
typedef enum _COUNTER_SET_ENUM
{
    SITE_COUNTER_SET = 0,
    GLOBAL_COUNTER_SET,
    APPPOOL_COUNTER_SET,

    MAX_COUNTER_SET_DEFINES
} COUNTER_SET_ENUM;

//
// Information stored in the control manager
// about the different counter sets and the 
// counter memory in general.
//
typedef struct _MANAGER_BLOCK
{
    DWORD InitializedCode;
    DWORD WASProcessId;
    DWORD LastUpdatedTickCount;
    COUNTER_CONTROL_BLOCK ControlArray[MAX_COUNTER_SET_DEFINES];
} MANAGER_BLOCK;


//
// Describes the counters in the form they are passed
// to the client library in.
//
typedef struct _PROP_DISPLAY_DESC
{
    ULONG offset;
    ULONG size;
} PROP_DISPLAY_DESC;


//
// common #defines
//

#define PERF_SM_WRITER_SIGNATURE        CREATE_SIGNATURE( 'SMWC' )
#define PERF_SM_WRITER_SIGNATURE_FREED  CREATE_SIGNATURE( 'smwX' )

#define PERF_SM_READER_SIGNATURE        CREATE_SIGNATURE( 'SMRC' )
#define PERF_SM_READER_SIGNATURE_FREED  CREATE_SIGNATURE( 'smrX' )

#define PERF_SM_MANAGER_SIGNATURE            CREATE_SIGNATURE( 'SMMC' )
#define PERF_SM_MANAGER_SIGNATURE_FREED      CREATE_SIGNATURE( 'smmX' )

#define PERF_COUNTER_INITIALIZED_CODE   CREATE_SIGNATURE( 'IPCI' )
#define PERF_COUNTER_UN_INITIALIZED_CODE   CREATE_SIGNATURE( 'ipcX' )

//
// Maximum length that an instance name can be.
// Issue-09/10/2000-EmilyK MAX_INSTANCE_NAME hard coded.
// 1)  Need to use the ServerComment for the instance name.
// 2)  Need to figure out the appropriate max for the instance name.
// 3)  Need to decide what to do if ServerComment is larger than max.
//
// Issue is on work item list.
//
#define MAX_INSTANCE_NAME  100

//
// Event name used to signal when a refresh of counter
// information is needed.
//
#define COUNTER_EVENT_A "Global\\WASPerfCount-c40da922-9c0a-4def-8aba-cd0bb5f093e1"
#define COUNTER_EVENT_W L"Global\\WASPerfCount-c40da922-9c0a-4def-8aba-cd0bb5f093e1"

//
// prototypes
//

//
// Hooks up to the shared memory that exposes
// which file the actual counter values (for each
// set of counters) are stored in.
//
class PERF_SM_MANAGER
{
public:
    
    PERF_SM_MANAGER(
        );

    virtual
    ~PERF_SM_MANAGER(
        );

    DWORD 
    Initialize(
        IN BOOL WriteAccess
        );

    VOID
    StopPublishing(
        );

    DWORD
    CreateNewCounterSet(
        IN COUNTER_SET_ENUM CounterSetId
        );

    HRESULT
    ReallocSharedMemIfNeccessary(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD NumInstances
            );

    VOID
    CopyInstanceInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN LPCWSTR              InstanceName,
        IN ULONG                MemoryOffset,
        IN LPVOID               pCounters,
        IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
        IN DWORD                cDisplayPropDesc,
        IN BOOL                 StructChanged,
        OUT ULONG*              pNewMemoryOffset
        );

    VOID
    PublishCounters(
        );

    VOID
    UpdateTotalServiceTime(
        IN DWORD  ServiceUptime
        );


    DWORD 
    GetCounterInfo(
        IN COUNTER_SET_ENUM CounterSetId,
        OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
        OUT LPVOID* ppData
        );

    DWORD 
    GetSNMPCounterInfo(
        OUT LPBYTE*  ppCounterBlock
        );

    VOID 
    PingWASToRefreshCounters(
        );

    //
    // Functions used by PERF_SM_WRITER and 
    // PERF_SM_READER to make sure they are using the 
    // most current memory.  These functions are not 
    // used by WAS or the Perflib.
    //
    VOID 
    GetActiveInformation(
        IN  COUNTER_SET_ENUM CounterSetId,
        OUT DWORD*           pVersion,
        OUT BOOL*            pActivePageIsA
        );
        
    VOID 
    SetActiveInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD            Version,
        IN BOOL             ActivePageIsA
        );

    BOOL 
    HasWriteAccess(
        );

    BOOL 
    ReleaseIsNeeded(
        );

    HANDLE
    GetWASProcessHandle(
        );

    BOOL 
    EvaluateIfCountersAreFresh(
        );

private:

    DWORD
    GetLastUpdatedTickCount(
        );

    VOID 
    ResetWaitFreshCounterValues(
        );

    //
    // Private definition of the PERF_SM_WRITER for use under
    // the covers in updating the counters from WAS.
    //
    class PERF_SM_WRITER
    {
    public:

        PERF_SM_WRITER( 
            );

        virtual
        ~PERF_SM_WRITER(
            );

        DWORD
        Initialize(
            IN PERF_SM_MANAGER* pSharedManager,
            IN COUNTER_SET_ENUM CounterSetId
            );

        HRESULT
        ReallocSharedMemIfNeccessary(
            IN DWORD NumInstances
            );

        VOID
        CopyInstanceInformation(
            IN LPCWSTR              InstanceName,
            IN ULONG                MemoryOffset,
            IN LPVOID               pCounters,
            IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
            IN DWORD                cDisplayPropDesc,
            IN BOOL                 StructChanged,
            OUT ULONG*              pNewMemoryOffset
            );

        VOID
        AggregateTotal(
            IN LPVOID               pCounters,
            IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
            IN DWORD                cDisplayPropDesc
            );

        VOID
        PublishCounterPage(
            );

        VOID
        UpdateTotalServiceTime(
            IN DWORD  ServiceUptime
            );

    private:

        PERF_COUNTER_BLOCK* 
        GetCounterBlockPtr(
            IN ULONG MemoryOffset
            );

        LPVOID 
        GetActiveMemory(
            );

        PERF_INSTANCE_DEFINITION* 
        GetInstanceInformationPtr(
            IN ULONG MemoryOffset
            );

        HRESULT
        MapSetOfCounterFiles(
            );

        DWORD m_Signature;

        DWORD m_Initialized;

        //
        // Pointer to the class that
        // controls the viewing of this
        // memory.
        //
        PERF_SM_MANAGER* m_pSharedManager;

        //
        // Idenitfies the set of counters
        // that this class is supporting.
        //
        COUNTER_SET_ENUM m_CounterSetId;

        //
        // Number of current instances
        // that this memory chunk represents
        //
        DWORD m_NumInstances;

        //
        // Size of all the memory needed
        // to transfer this information to 
        // the performance library
        //
        DWORD m_SizeOfMemory;

        //
        // The version of memory that we
        // are linked to.
        //
        DWORD m_MemoryVersionNumber;

        // 
        // Which page of memory we are 
        // currently writting to.  This
        // is the opposite of what the
        // manager will tell the reader.
        //
        BOOL m_ActiveMemoryIsA;

        //
        // If we have updated the page that
        // we are working on, but not the other
        // page, this is set.  Then when we 
        // switch pieces to update, we copy the
        // old page into this page, so we have
        // a valid memory page to work with.
        //
        BOOL m_UpdateNeeded;

        // 
        // Handles and pointers to the memory
        // pages.  We hold two open copies of the
        // counters page so we can swap what the 
        // user is looking at in a clean manner.
        //
        LPVOID m_pMemoryA;
        LPVOID m_pMemoryB;
        HANDLE m_hMemoryA;
        HANDLE m_hMemoryB;

    };  // class PERF_SM_WRITER

    //
    // Private PERF_SM_READER definition for use
    // by the PERF_SM_MANAGER in giving out perf
    // counter information.
    //
    // Note: It returns Win32 error codes
    // because that is what the pdh expects
    // from the exported functions.
    //
    class PERF_SM_READER
    {
    public:
        
        PERF_SM_READER(
            );
    
        virtual
        ~PERF_SM_READER(
            );

        DWORD 
        Initialize(
            IN PERF_SM_MANAGER*  pSharedManager,
            IN COUNTER_SET_ENUM  CounterSetId
            );

        DWORD 
        GetCounterInfo(
            OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
            OUT LPVOID* ppData
            );

        DWORD 
        GetSNMPCounterInfo(
            OUT LPBYTE*  ppCounterBlock
            );

    private:
  
        VOID 
        ConnectToActiveMemory(
            );
    
        LPVOID 
        GetActiveMemory(
            );

        DWORD m_Signature;

        DWORD m_Initialized;

        //
        // Controls what piece of memory 
        // the reader should read from.
        //
        PERF_SM_MANAGER* m_pSharedManager;

        //
        // Identifies which set of counters
        // we are looking at.
        //
        COUNTER_SET_ENUM m_CounterSetId;

        //
        // Identifies which memory is active
        // in the eyes of the reader.
        //
        BOOL m_ActiveMemoryIsA;

        //
        // Identifies which version is current
        // in the eyes of the reader.
        //
        DWORD m_MemoryVersionNumber; 

        //
        // Holds the handles and pointers
        // to the data files that represent
        // these counters.
        //
        HANDLE m_hMemoryA;
        LPVOID m_pMemoryA;

        HANDLE m_hMemoryB;
        LPVOID m_pMemoryB;

    };

    //
    // Private member variables of the Manager class 
    //

    DWORD m_Signature;

    BOOL  m_Initialized;

    // 
    // points to the shared memory
    // that controls which piece of
    // shared memory contains valid counters
    // as well as whether the client should
    // release the manager block.
    //
    MANAGER_BLOCK* m_pManagerMemory;

    HANDLE m_hManagerMemory;

    LPVOID m_pSMObjects;

    BOOL m_WriteAccess;

    HANDLE m_hIISSignalCounterRefresh;

    HANDLE m_WASProcessHandle;

    //
    // Used for calculating freshness of counters.
    //
    DWORD m_IIS_MillisecondsCountersAreFresh;

    DWORD m_IIS_MaxNumberTimesToCheckCountersOnRefresh; 

    DWORD m_IIS_MillisecondsToSleepBeforeCheckingForRefresh;

};


#endif  // _PERF_SM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\locks.h ===
/*++

   Copyright    (c)    1998-2000    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CRtlResource        NT's RTL_RESOURCE
//      CShareLock          Michael Parkes's CSharelock
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_RTLRESOURCE,
    LOCK_SHARELOCK,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CRtlResource;
class IRTL_DLLEXP CShareLock;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    char     m_szName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_szName[0] = '\0';
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    char            m_szName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const char* Name() const        {return m_szName;}                      \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(pszName)         \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (pszName == NULL)                            \
        m_szName[0] = '\0';                         \
    else                                            \
        strncpy(m_szName, pszName, sizeof(m_szName))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class IRTL_DLLEXP CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class IRTL_DLLEXP CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const char* pszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD dwSpins)     {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD dwSpins) {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec




//--------------------------------------------------------------------
// RTL_RESOURCE is a multi-reader, single-writer lock provided on NT, but
// not published as part of the Win32 API.  IIS exposes it in <tsres.hxx>.

#include <tsres.hxx>

class IRTL_DLLEXP CRtlResource :
    public CLockBase<LOCK_RTLRESOURCE, LOCK_MRSW,
                       LOCK_RECURSIVE /*??*/, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    RTL_RESOURCE    m_res;

    LOCK_INSTRUMENTATION_DECL();

public:
    CRtlResource()
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CRtlResource(const char*)
    {
        InetInitializeResource(&m_res);
        CCritSec::SetSpinCount(&m_res.CriticalSection, sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CRtlResource()     { InetDeleteResource(&m_res); }

    void WriteLock()    { InetAcquireResourceExclusive(&m_res, TRUE); }
    void ReadLock()     { InetAcquireResourceShared(&m_res, TRUE); }
    bool TryWriteLock() {return !!InetAcquireResourceExclusive(&m_res, FALSE);}
    bool TryReadLock()  { return !!InetAcquireResourceShared(&m_res, FALSE); }
    void WriteUnlock()  { InetReleaseResource(&m_res); }
    void ReadUnlock()   { WriteUnlock(); }

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        InetConvertSharedToExclusive(&m_res);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        InetConvertExclusiveToShared(&m_res);
    }
    
    bool SetSpinCount(WORD wSpins)
    {CCritSec::SetSpinCount(&m_res.CriticalSection, wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CRtlResource";}
}; // CRtlResource




//--------------------------------------------------------------------
// CSharelock is a multi-reader, single-writer lock due to MParkes.

#include <sharelok.h>

class IRTL_DLLEXP CShareLock :
    public CLockBase<LOCK_SHARELOCK, LOCK_MRSW,
                       LOCK_RECURSIVE /* ?? */, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CSharelock      m_sl;

    LOCK_INSTRUMENTATION_DECL();

public:
    CShareLock()
        : m_sl()
    {
    }
#ifdef LOCK_INSTRUMENTATION
    CShareLock(const char*)
        : m_sl()
    {
    }
#endif // LOCK_INSTRUMENTATION

    void WriteLock()    { m_sl.ClaimExclusiveLock(INFINITE); }
    void ReadLock()     { m_sl.ClaimShareLock(INFINITE); }
    bool TryWriteLock() { return !!m_sl.ClaimExclusiveLock(0); }
    bool TryReadLock()  { return !!m_sl.ClaimShareLock(0); }
    void WriteUnlock()  { m_sl.ReleaseExclusiveLock(); }
    void ReadUnlock()   { m_sl.ReleaseShareLock(); }
    
    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return IsWriteUnlocked();}

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        m_sl.ChangeSharedLockToExclusiveLock(INFINITE);
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        m_sl.ChangeExclusiveLockToSharedLock();
    }
    
    bool SetSpinCount(WORD wSpins)
    { m_sl.UpdateMaxSpins(wSpins); return true;}
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const char*   ClassName()  {return "CShareLock";}
};  // CShareLock



//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const char* pszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;    
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const char* pszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchangeAdd(const_cast<LONG*>(&m_lTid), SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        // Give writers priority
        LONG l = m_lRW;
        bool fLocked = (((l & SL_WRITERS_MASK) == 0)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

    LOCK_FORCEINLINE bool _TryReadLockRecursive()
    {
        // Do *not* give writers priority. If the inner call attempts
        // to reacquire the read lock while another thread is waiting on
        // the write lock, we would deadlock if we waited for the queue
        // of writers to empty: the writer(s) can't acquire the lock
        // exclusively, as this thread holds a readlock. The inner call
        // typically releases the lock very quickly, so there is no
        // danger of writer starvation.
        LONG l = m_lRW;
        bool fLocked = (((l & SL_STATE_MASK) != SL_EXCLUSIVE)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const char* pszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(pszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin(SPIN_READ);
    } 

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    inline bool ReadOrWriteLock()
    {
        if (IsWriteLocked())
        {
            WriteLock();
            return false;   // => not read locked
        }
        else
        {
            LOCK_READLOCK_INSTRUMENTATION();
            
            if (!_TryReadLockRecursive())
                _ReadLockSpin(SPIN_READ_RECURSIVE);
            
            return true;   // => is read locked
        }
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
            for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
                 !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
                 l = m_lRW)
            {
                Lock_Yield();
            }
        }
        else
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNew);
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    inline void ReadOrWriteUnlock(bool fIsReadLocked)
    {
        if (fIsReadLocked)
            ReadUnlock();
        else
            WriteUnlock();
    } 

    // Does current thread hold a write lock?
    bool IsWriteLocked() const
    {
        // bool fLocked = ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
        bool fLocked = !((m_lTid ^ GetCurrentThreadId()) & SL_THREAD_MASK);
        IRTLASSERT(!fLocked  || (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                                 &&  ((m_lTid & SL_OWNER_MASK) > 0)));
        return fLocked;
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    // There is no such window when converting from a writelock to a readlock
    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD wSpins)      {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock3");}
}; // CReaderWriterLock3


#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\reftrace.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    Ref count trace logs can be dumped via the !inetdbg.ref command
    in either NTSD or CDB.

Author:

    Keith Moore (keithmo)        01-May-1997

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


#include <tracelog.h>


//
// This is the number of stack backtrace values captured in each
// trace log entry. This value is chosen to make the log entry
// exactly twelve dwords long, making it a bit easier to interpret
// from within the debugger without the debugger extension.
//

#define REF_TRACE_LOG_STACK_DEPTH   9

// No-op value for the Context1,2,3 parameters of WriteRefTraceLogEx
#define REF_TRACE_EMPTY_CONTEXT ((PVOID) -1)


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY {

    LONG NewRefCount;
    PVOID Context;
    PVOID Context1;
    PVOID Context2;
    PVOID Context3;
    DWORD Thread;
    PVOID Stack[REF_TRACE_LOG_STACK_DEPTH];

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG Log
    );

LONG
__cdecl
WriteRefTraceLog(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context
    );

LONG
__cdecl
WriteRefTraceLogEx(
    IN PTRACE_LOG Log,
    IN LONG NewRefCount,
    IN PVOID Context,
    IN PVOID Context1,
    IN PVOID Context2,
    IN PVOID Context3
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\regconst.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    regconst.h

Abstract:

    Common place to put registry strings and keys.

Author:

    EmilyK 4/4/2001 

Revision History:

--*/


#ifndef _REGCONST_H_
#define _REGCONST_H_

//
// Service names
//
#define WEB_ADMIN_SERVICE_NAME_A    "w3svc"

// Generic registry keys
#define REGISTRY_SERVICES_KEY_A \
    "System\\CurrentControlSet\\Services"

//
// Registry key strings for the different services parameter keys.
//
#define REGISTRY_KEY_W3SVC_PARAMETERS_A                   \
            "System\\CurrentControlSet\\Services\\W3SVC\\Parameters"
#define REGISTRY_KEY_W3SVC_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\W3SVC\\Parameters"

#define REGISTRY_KEY_IISADMIN_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\IISAdmin\\Parameters"

#define REGISTRY_KEY_INETINFO_PARAMETERS_A                  \
            "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define REGISTRY_KEY_INETINFO_PARAMETERS_W                  \
            L"System\\CurrentControlSet\\Services\\InetInfo\\Parameters"

#define REGISTRY_KEY_W3SSL_PARAMETERS_W                   \
            L"System\\CurrentControlSet\\Services\\W3SSL\\Parameters"

//
// Registry key strings for the different services performance keys.
//
#define REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_A \
            "System\\CurrentControlSet\\Services\\W3SVC\\Performance"
#define REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W \
            L"System\\CurrentControlSet\\Services\\W3SVC\\Performance"

//
// W3SVC Performance values 
//
#define REGISTRY_VALUE_W3SVC_PERF_FRESH_TIME_FOR_COUNTERS_W   \
            L"FreshTimeForCounters"

#define REGISTRY_VALUE_W3SVC_PERF_CHECK_COUNTERS_EVERY_N_MS_W   \
            L"CheckCountersEveryNMiliseconds"

#define REGISTRY_VALUE_W3SVC_PERF_NUM_TIMES_TO_CHECK_COUNTERS_W   \
            L"NumberOfTimesToCheckCounters"



//
// IISAdmin Parameter values
//
#define REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_SHUTDOWN_AFTER_INETINFO_CRASH_W   \
            L"MillisecondsToWaitForShutdownAfterCrash"

#define REGISTRY_VALUE_IISADMIN_MS_TO_WAIT_FOR_RESTART_AFTER_INETINFO_CRASH_W   \
            L"MillisecondsToWaitForInetinfoRestartAfterCrash"

#define REGISTRY_VALUE_IISADMIN_MS_CHECK_INTERVAL_FOR_INETINFO_TO_RESTART_W   \
            L"MillisecondsCheckIntervalForInetinfoToRestart"


//
// Generic Service Values
//
#define REGISTRY_VALUE_IISSERVICE_DLL_PATH_NAME_A   \
            "IISDllPath"

//
// Inetinfo Parameter values
//

#define REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A   \
            "DispatchEntries"

#define REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A   \
            "PreloadDlls"

//
// W3SVC Parameter values
//
#define REGISTRY_VALUE_W3SVC_PROFILE_WORKER_PROCESSES_W   \
            L"ProfileWorkerProcesses"

#define REGISTRY_VALUE_W3SVC_PERF_COUNT_DISABLED_W         \
            L"PerformanceCountersDisabled"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_STARTUP_W           \
            L"BreakOnStartup"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_FAILURE_CAUSING_SHUTDOWN_W \
            L"BreakOnFailureCausingShutdown"

#define REGISTRY_VALUE_W3SVC_BREAK_ON_WP_ERROR \
            L"BreakOnWPError"

#define REGISTRY_VALUE_W3SVC_BACKWARD_COMPATIBILITY_W     \
            L"BackwardCompatible"

#define REGISTRY_VALUE_W3SVC_FILTER_ALL_DATA_W            \
            L"FilterAllData"

#define REGISTRY_VALUE_W3SVC_USE_TEST_W3WP                \
            L"UseTestW3WP"

#define REGISTRY_VALUE_W3SVC_STARTUP_WAIT_HINT            \
            L"StartupWaitHintInMilliseconds"

//
// W3SSL Parameter values
//

#define REGISTRY_VALUE_W3SSL_STARTUP_WAIT_HINT            \
            L"StartupWaitHintInMilliseconds"

#endif  // _REGCONST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\lstentry.h ===
/*++

   Copyright    (c)    1999-2000    Microsoft Corporation

   Module  Name :
       lstentry.h

   Abstract:
       Declares CListEntry and other intrusive singly- and doubly-linked lists

   Author:
       George V. Reilly      (GeorgeRe)     02-Mar-1999

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LSTENTRY_H__
#define __LSTENTRY_H__

#ifndef __LOCKS_H__
# include <locks.h>
#endif // !__LOCKS_H__

// TODO:
// * Add STL-style iterators: begin(), end(), operator++(), etc
// * Templatize the lists, so that you can avoid the CONTAINING_RECORD goo

//--------------------------------------------------------------------
// CSingleListEntry: a node in a singly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CSingleListEntry
{
public:
    CSingleListEntry* Next;  // forward link
};



//--------------------------------------------------------------------
// A non-threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CSingleList
{
protected:
    CSingleListEntry m_sleHead; // external head node

public:
    CSingleList()
    {
        m_sleHead.Next = NULL;
    }

    ~CSingleList()
    {
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_sleHead.Next == NULL;
    }

    CSingleListEntry* const
    Pop()
    {
        CSingleListEntry* psle = m_sleHead.Next;

        if (psle != NULL)
            m_sleHead.Next = psle->Next;

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        psle->Next     = m_sleHead.Next;
        m_sleHead.Next = psle;
    }
};


//--------------------------------------------------------------------
// A threadsafe singly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedSingleList
{
protected:
    CSpinLock   m_lock;
    CSingleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedSingleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION

    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    CSingleListEntry* const
    Pop()
    {
        Lock();
        CSingleListEntry* const psle = m_list.Pop();
        Unlock();

        return psle;
    }

    void
    Push(
        CSingleListEntry* const psle)
    {
        Lock();
        m_list.Push(psle);
        Unlock();
    }
};



//--------------------------------------------------------------------
// CListEntry: a node in a circular doubly-linked list.  Usually embedded
// within larger structures.
//--------------------------------------------------------------------

class CListEntry
{
public:
    CListEntry* Flink;  // forward link
    CListEntry* Blink;  // backward link
};


//--------------------------------------------------------------------
// A non-threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CDoubleList
{
protected:
    CListEntry  m_leHead; // external head node

public:
    CDoubleList()
    {
        m_leHead.Flink = m_leHead.Blink = &m_leHead;
    }

    ~CDoubleList()
    {
        IRTLASSERT(m_leHead.Flink != NULL  &&  m_leHead.Blink != NULL);
        IRTLASSERT(IsEmpty());
    }

    bool
    IsEmpty() const
    {
        return m_leHead.Flink == &m_leHead;
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        ple->Blink        = &m_leHead;
        ple->Flink        = m_leHead.Flink;
        ple->Flink->Blink = ple;
        m_leHead.Flink    = ple;
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        ple->Flink        = &m_leHead;
        ple->Blink        = m_leHead.Blink;
        ple->Blink->Flink = ple;
        m_leHead.Blink    = ple;
    }

    const CListEntry* const
    HeadNode() const
    {
        return &m_leHead;
    }

    CListEntry* const
    First() const
    {
        return m_leHead.Flink;
    }

    CListEntry* const
    RemoveHead()
    {
        CListEntry* ple = First();
        RemoveEntry(ple);
        return ple;
    }

    CListEntry* const
    Last() const
    {
        return m_leHead.Blink;
    }

    CListEntry* const
    RemoveTail()
    {
        CListEntry* ple = Last();
        RemoveEntry(ple);
        return ple;
    }

    static void
    RemoveEntry(
        CListEntry* const ple)
    {
        CListEntry* const pleOldBlink = ple->Blink;
        IRTLASSERT(pleOldBlink != NULL);
        CListEntry* const pleOldFlink = ple->Flink;
        IRTLASSERT(pleOldFlink != NULL);

        pleOldBlink->Flink = pleOldFlink;
        pleOldFlink->Blink = pleOldBlink;
    }
};


//--------------------------------------------------------------------
// A threadsafe circular doubly linked list
//--------------------------------------------------------------------

class IRTL_DLLEXP CLockedDoubleList
{
protected:
    CSpinLock   m_lock;
    CDoubleList m_list;

public:

#ifdef LOCK_INSTRUMENTATION
    CLockedDoubleList()
        : m_lock(NULL)
    {}
#endif // LOCK_INSTRUMENTATION
    
    void
    Lock()
    {
        m_lock.WriteLock();
    }

    void
    Unlock()
    {
        m_lock.WriteUnlock();
    }

    bool
    IsLocked() const
    {
        return m_lock.IsWriteLocked();
    }
    
    bool
    IsUnlocked() const
    {
        return m_lock.IsWriteUnlocked();
    }
    
    bool
    IsEmpty() const
    {
        return m_list.IsEmpty();
    }

    void
    InsertHead(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertHead(ple);
        Unlock();
    }

    void
    InsertTail(
        CListEntry* const ple)
    {
        Lock();
        m_list.InsertTail(ple);
        Unlock();
    }

    // not threadsafe
    const CListEntry* const
    HeadNode() const
    {
        return m_list.HeadNode();
    }

    // not threadsafe
    CListEntry* const
    First()
    {
        return m_list.First();
    }

    CListEntry* const
    RemoveHead()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveHead();
        Unlock();
        return ple;
    }

    // not threadsafe
    CListEntry* const
    Last()
    {
        return m_list.Last();
    }

    CListEntry* const
    RemoveTail()
    {
        Lock();
        CListEntry* const ple = m_list.RemoveTail();
        Unlock();
        return ple;
    }

    void
    RemoveEntry(
        CListEntry* const ple)
    {
        Lock();
        m_list.RemoveEntry(ple);
        Unlock();
    }
};


#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))

#endif // !CONTAINING_RECORD


#endif // __LSTENTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\secfcns.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    secfcns.hxx

        Declarations for security helper functions.
*/

#ifndef _SECFCNS_H_
#define _SECFCNS_H_

#include <Accctrl.h>

DWORD 
AllocateAndCreateWellKnownSid( 
    WELL_KNOWN_SID_TYPE SidType,
    PSID* ppSid
    );

VOID 
FreeWellKnownSid( 
    PSID* ppSid
    );

DWORD 
AllocateAndCreateWellKnownAcl( 
    WELL_KNOWN_SID_TYPE SidType,
    BOOL  fAccessAllowedAcl,
    PACL* ppAcl,
    DWORD* pcbAcl
    );

VOID 
FreeWellKnownAcl( 
    PACL* ppAcl
    );

VOID 
SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                           DWORD            dwAccessPermissions,
                           ACCESS_MODE      AccessMode,
                           PSID             pSID
    );

class dllexp CSecurityDispenser
{
public:

    CSecurityDispenser();
    ~CSecurityDispenser();

    DWORD GetSID(WELL_KNOWN_SID_TYPE sidId, PSID* ppSid);
    DWORD GetIisWpgSID(PSID* ppSid);

    DWORD GetSecurityAttributesForAllWorkerProcesses(PSECURITY_ATTRIBUTES* ppSa);


private:

    // Commonly used SIDs
    BOOL   m_WpgSIDIsSet;
    BUFFER m_WpgSID;
    PSID m_pLocalSystemSID;
    PSID m_pLocalServiceSID;
    PSID m_pNetworkServiceSID;

    // SA stuff for acling with all access for 
    // the possible worker process identities.
    PACL m_pACLForAllWorkerProcesses;
    PSECURITY_DESCRIPTOR m_pSDForAllWorkerProcesses;
    PSECURITY_ATTRIBUTES m_pSAForAllWorkerProcesses;

};
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\pudebug.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        pudebug.h

   Abstract:

      This module declares the DEBUG_PRINTS object helpful in
       testing the programs

   Author:

      Murali R. Krishnan    ( MuraliK )    14-Dec-1994

   Revision History:
      MuraliK  13-Nov-1998  Ported over to IIS-DuctTape

--*/

#if !defined(BUILD_PUDEBUG)
//
// if we are not using this header for building the pudebug library
//  then better this be used with dbgutil.h
//
  # ifndef _DBGUTIL_H_
  # error Please make sure you included dbgutil.h!
  # error   Do not include pudebug.h directly
  # endif // _DBGUTIL_H_
#endif  

# ifndef _PUDEBUG_H_
# define _PUDEBUG_H_


/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# include <windows.h>

# ifndef dllexp
# define dllexp   __declspec( dllexport)
# endif // dllexp

/***********************************************************
 *    Macros
 ************************************************************/

enum  PRINT_REASONS {
    PrintNone     = 0x0,   // Nothing to be printed
    PrintError    = 0x1,   // An error message
    PrintWarning  = 0x2,   // A  warning message
    PrintLog      = 0x3,   // Just logging. Indicates a trace of where ...
    PrintMsg      = 0x4,   // Echo input message
    PrintCritical = 0x5,   // Print and Exit
    PrintAssertion= 0x6    // Printing for an assertion failure
  };


enum  DEBUG_OUTPUT_FLAGS {
    DbgOutputNone     = 0x0,            // None
    DbgOutputKdb      = 0x1,            // Output to Kernel Debugger
    DbgOutputLogFile  = 0x2,            // Output to LogFile
    DbgOutputTruncate = 0x4,            // Truncate Log File if necessary
    DbgOutputStderr   = 0x8,            // Send output to std error
    DbgOutputBackup   = 0x10,           // Make backup of debug file ?
    DbgOutputMemory   = 0x20,           // Dump to memory buffer
    DbgOutputAll      = 0xFFFFFFFF      // All the bits set.
  };


# define MAX_LABEL_LENGTH                 ( 100)



/*++
  class DEBUG_PRINTS

  This class is responsible for printing messages to log file / kernel debugger

  Currently the class supports only member functions for <ANSI> char.
   ( not unicode-strings).

--*/


typedef struct _DEBUG_PRINTS {

    CHAR         m_rgchLabel[MAX_LABEL_LENGTH];
    CHAR         m_rgchLogFilePath[MAX_PATH];
    CHAR         m_rgchLogFileName[MAX_PATH];
    HANDLE       m_LogFileHandle;
    HANDLE       m_StdErrHandle;
    BOOL         m_fInitialized;
    BOOL         m_fBreakOnAssert;
    DWORD        m_dwOutputFlags;
    VOID        *m_pMemoryLog;
} DEBUG_PRINTS, FAR * LPDEBUG_PRINTS;


LPDEBUG_PRINTS
PuCreateDebugPrintsObject(
   IN const char * pszPrintLabel,
   IN DWORD  dwOutputFlags);

//
// frees the debug prints object and closes any file if necessary.
//  Returns NULL on success or returns pDebugPrints on failure.
//
LPDEBUG_PRINTS
PuDeleteDebugPrintsObject(
   IN OUT LPDEBUG_PRINTS  pDebugPrints);


VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...);                               // arglist

// PuDbgPrintError is similar to PuDbgPrint() but allows 
// one to print error code in friendly manner
VOID
PuDbgPrintError(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN DWORD                dwError,
   IN const char *         pszFormat,
   ...);                               // arglist

/*++
  PuDbgDump() does not do any formatting of output.
  It just dumps the given message onto the debug destinations.
--*/
VOID
PuDbgDump(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszDump
   );

//
// PuDbgAssertFailed() *must* be __cdecl to properly capture the
// thread context at the time of the failure.
//

VOID
__cdecl
PuDbgAssertFailed(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszExpression,
   IN const char *         pszMessage);

VOID
PuDbgCaptureContext (
    OUT PCONTEXT ContextRecord
    );

VOID
PuDbgPrintCurrentTime(
    IN OUT LPDEBUG_PRINTS         pDebugPrints,
    IN const char *               pszFilePath,
    IN int                        nLineNum
    );

VOID
PuSetDbgOutputFlags(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN DWORD                dwFlags);

DWORD
PuGetDbgOutputFlags(
   IN const LPDEBUG_PRINTS       pDebugPrints);


//
// Following functions return Win32 error codes.
// NO_ERROR if success
//

DWORD
PuOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFileName,
   IN const char *         pszPathForFile);

DWORD
PuReOpenDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuCloseDbgPrintFile(
   IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuOpenDbgMemoryLog(
    IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuCloseDbgMemoryLog(
    IN OUT LPDEBUG_PRINTS   pDebugPrints);

DWORD
PuLoadDebugFlagsFromReg(IN HKEY hkey, IN DWORD dwDefault);

DWORD
PuLoadDebugFlagsFromRegStr(IN LPCSTR pszRegKey, IN DWORD dwDefault);

DWORD
PuSaveDebugFlagsInReg(IN HKEY hkey, IN DWORD dwDbg);


# define PuPrintToKdb( pszOutput)    \
                    if ( pszOutput != NULL)   {   \
                        OutputDebugString( pszOutput);  \
                    } else {}



# ifdef __cplusplus
};
# endif // __cplusplus

// begin_user_unmodifiable

# if DBG


/***********************************************************
 *    Macros
 ************************************************************/


extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
DEBUG_PRINTS  *  g_pDebug;        // define a global debug variable


# define DECLARE_DEBUG_PRINTS_OBJECT()          \
         DEBUG_PRINTS  *  g_pDebug = NULL;


//
// Call the following macro as part of your initialization for program
//  planning to use the debugging class.
//
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)  \
        g_pDebug = PuCreateDebugPrintsObject( pszLabel, DEFAULT_OUTPUT_FLAGS);\
         if  ( g_pDebug == NULL) {   \
               OutputDebugStringA( "Unable to Create Debug Print Object \n"); \
         }

//
// Call the following macro once as part of the termination of program
//    which uses the debugging class.
//
# define DELETE_DEBUG_PRINT_OBJECT( )  \
        g_pDebug = PuDeleteDebugPrintsObject( g_pDebug);


# define VALID_DEBUG_PRINT_OBJECT()     \
        ( ( g_pDebug != NULL) && g_pDebug->m_fInitialized)


//
//  Use the DBG_CONTEXT without any surrounding braces.
//  This is used to pass the values for global DebugPrintObject
//     and File/Line information
//
# define DBG_CONTEXT        g_pDebug, __FILE__, __LINE__



# define DBG_CODE(s)          s          /* echoes code in debugging mode */


# define DBG_ASSERT( exp)    if ( !(exp)) { \
                                 PuDbgAssertFailed( DBG_CONTEXT, #exp, NULL); \
                             } else {}

# define DBG_ASSERT_MSG( exp, pszMsg)    \
                             if ( !(exp)) { \
                                  PuDbgAssertFailed( DBG_CONTEXT, #exp, pszMsg); \
                              } else {}

# define DBG_REQUIRE( exp)    DBG_ASSERT( exp)

# define DBG_LOG()            PuDbgPrint( DBG_CONTEXT, "\n")

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)   \
                  PuOpenDbgPrintFile( g_pDebug, (pszFile), (pszPath))

# define DBG_CLOSE_LOG_FILE( )   \
                  PuCloseDbgPrintFile( g_pDebug)

# define DBG_OPEN_MEMORY_LOG()   \
                    PuOpenDbgMemoryLog( g_pDebug )


//
//  DBGPRINTF() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DBGPRINTF( ( DBG_CONTEXT, format-string, arguments for format list));
//
# define DBGPRINTF( args)     PuDbgPrint args

//
//  DPERROR() is printing function ( much like printf) but always called
//    with the DBG_CONTEXT as follows
//   DPERROR( ( DBG_CONTEXT, error, format-string, 
//                      arguments for format list));
//
# define DPERROR( args)       PuDbgPrintError args

# define DBGDUMP( args)       PuDbgDump  args

# define DBGPRINT_CURRENT_TIME()  PuDbgPrintCurrentTime( DBG_CONTEXT)

# else // !DBG


# define DECLARE_DEBUG_PRINTS_OBJECT()           /* Do Nothing */
# define CREATE_DEBUG_PRINT_OBJECT( pszLabel)    ((void)0) /* Do Nothing */
# define DELETE_DEBUG_PRINT_OBJECT( )            ((void)0) /* Do Nothing */
# define VALID_DEBUG_PRINT_OBJECT()              ( TRUE)

# define DBG_CODE(s)                             /* Do Nothing */

# define DBG_ASSERT(exp)                         ((void)0) /* Do Nothing */

# define DBG_ASSERT_MSG(exp, pszMsg)             ((void)0) /* Do Nothing */

# define DBG_REQUIRE( exp)                       ( (void) (exp))

# define DBGPRINTF( args)                        ((void)0) /* Do Nothing */
# define DPERROR( args)                          ((void)0) /* Do Nothin */

# define DBGDUMP( args)                          ((void)0) /* Do nothing */

# define DBG_LOG()                               ((void)0) /* Do Nothing */

# define DBG_OPEN_LOG_FILE( pszFile, pszPath)    ((void)0) /* Do Nothing */

# define DBG_OPEN_MEMORY_LOG()                   ((void)0) /* Do Nothing */

# define DBG_CLOSE_LOG_FILE()                    ((void)0) /* Do Nothing */

# define DBGPRINT_CURRENT_TIME()                 ((void)0) /* Do Nothing */

# endif // !DBG


// end_user_unmodifiable

// begin_user_unmodifiable


#ifdef ASSERT
# undef ASSERT
#endif


# define ASSERT( exp)           DBG_ASSERT( exp)


# if DBG

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
 DWORD  g_dwDebugFlags;           // Debugging Flags

# define DECLARE_DEBUG_VARIABLE()     \
             DWORD  g_dwDebugFlags

# define SET_DEBUG_FLAGS( dwFlags)         g_dwDebugFlags = dwFlags
# define GET_DEBUG_FLAGS()                 ( g_dwDebugFlags)

# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromReg((hkey), (dwDefault))

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  \
             g_dwDebugFlags = PuLoadDebugFlagsFromRegStr((pszRegKey), (dwDefault))

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)  \
               PuSaveDebugFlagsInReg((hkey), (dwDbg))

# define DEBUG_IF( arg, s)     if ( DEBUG_ ## arg & GET_DEBUG_FLAGS()) { \
                                       s \
                                } else {}

# define IF_DEBUG( arg)        if ( DEBUG_## arg & GET_DEBUG_FLAGS())


# else   // !DBG


# define DECLARE_DEBUG_VARIABLE()                /* Do Nothing */
# define SET_DEBUG_FLAGS( dwFlags)               /* Do Nothing */
# define GET_DEBUG_FLAGS()                       ( 0)
# define LOAD_DEBUG_FLAGS_FROM_REG(hkey, dwDefault) /* Do Nothing */

# define LOAD_DEBUG_FLAGS_FROM_REG_STR(pszRegKey, dwDefault)  /* Do Nothing */

# define SAVE_DEBUG_FLAGS_IN_REG(hkey, dwDbg)    /* Do Nothing */

# define DEBUG_IF( arg, s)                       /* Do Nothing */
# define IF_DEBUG( arg)                          if ( 0)

# endif // !DBG

// end_user_unmodifiable

// begin_user_modifiable

//
//  Debugging constants consist of two pieces.
//  All constants in the range 0x0 to 0x8000 are reserved
//  User extensions may include additional constants (bit flags)
//

# define DEBUG_API_ENTRY                  0x00000001L
# define DEBUG_API_EXIT                   0x00000002L
# define DEBUG_INIT_CLEAN                 0x00000004L
# define DEBUG_ERROR                      0x00000008L

                   // End of Reserved Range
# define DEBUG_RESERVED                   0x00000FFFL

// end_user_modifiable

//
// Some helper functions for GUID formatting and printing
// Use as :
//   printf( "The Guid is: " GUID_FORMAT , GUID_EXPAND(&refGuid));
//
# define GUID_FORMAT   "{%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}"

# define GUID_EXPAND(pg) \
  (((GUID *) (pg))->Data1), (((GUID *) (pg))->Data2), (((GUID *) (pg))->Data3), \
  (((GUID *) (pg))->Data4[0]),   (((GUID *) (pg))->Data4[1]), \
  (((GUID *) (pg))->Data4[2]),   (((GUID *) (pg))->Data4[3]), \
  (((GUID *) (pg))->Data4[4]),   (((GUID *) (pg))->Data4[5]), \
  (((GUID *) (pg))->Data4[6]),   (((GUID *) (pg))->Data4[7])



/***********************************************************
 *    Platform Type related variables and macros
 ************************************************************/

//
// Enum for product types
//

typedef enum _PLATFORM_TYPE {

    PtInvalid = 0,                 // Invalid
    PtNtWorkstation = 1,           // NT Workstation
    PtNtServer = 2,                // NT Server
    PtWindows95 = 3,               // Windows 95
    PtWindows9x = 4                // Windows 9x - not implemented

} PLATFORM_TYPE;

//
// IISGetPlatformType is the function used to the platform type
//

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE
IISGetPlatformType(
        VOID
        );

//
// External Macros
//

#define InetIsNtServer( _pt )           ((_pt) == PtNtServer)
#define InetIsNtWksta( _pt )            ((_pt) == PtNtWorkstation)
#define InetIsWindows95( _pt )          ((_pt) == PtWindows95)
#define InetIsValidPT(_pt)              ((_pt) != PtInvalid)

extern
#ifdef __cplusplus
"C"
# endif // _cplusplus
PLATFORM_TYPE    g_PlatformType;


// Use the DECLARE_PLATFORM_TYPE macro to declare the platform type
#define DECLARE_PLATFORM_TYPE()  \
   PLATFORM_TYPE    g_PlatformType = PtInvalid;

// Use the INITIALIZE_PLATFORM_TYPE to init the platform type
// This should typically go inside the DLLInit or equivalent place.
#define INITIALIZE_PLATFORM_TYPE()  \
   g_PlatformType = IISGetPlatformType();

//
// Additional Macros to use the Platform Type
//

#define TsIsNtServer( )         InetIsNtServer(g_PlatformType)
#define TsIsNtWksta( )          InetIsNtWksta(g_PlatformType)
#define TsIsWindows95()         InetIsWindows95(g_PlatformType)
#define IISIsValidPlatform()    InetIsValidPT(g_PlatformType)
#define IISPlatformType()       (g_PlatformType)


/***********************************************************
 *    Some utility functions for Critical Sections
 ************************************************************/

//
// IISSetCriticalSectionSpinCount() provides a thunk for the
// original NT4.0sp3 API SetCriticalSectionSpinCount() for CS with Spin counts
// Users of this function should definitely dynlink with kernel32.dll,
// Otherwise errors will surface to a large extent
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
DWORD
IISSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
);


//
// Macro for the calls to SetCriticalSectionSpinCount()
//
# define SET_CRITICAL_SECTION_SPIN_COUNT( lpCS, dwSpins) \
  IISSetCriticalSectionSpinCount( (lpCS), (dwSpins))

//
// IIS_DEFAULT_CS_SPIN_COUNT is the default value of spins used by
//  Critical sections defined within IIS.
// NYI: We should have to switch the individual values based on experiments!
// Current value is an arbitrary choice
//
# define IIS_DEFAULT_CS_SPIN_COUNT   (1000)

//
// Initializes a critical section and sets its spin count
// to IIS_DEFAULT_CS_SPIN_COUNT.  Equivalent to
// InitializeCriticalSectionAndSpinCount(lpCS, IIS_DEFAULT_CS_SPIN_COUNT),
// but provides a safe thunking layer for older systems that don't provide
// this API.
//
extern
# ifdef __cplusplus
"C"
# endif // _cplusplus
VOID
IISInitializeCriticalSection(
    LPCRITICAL_SECTION lpCriticalSection
);

//
// Macro for the calls to InitializeCriticalSection()
//
# define INITIALIZE_CRITICAL_SECTION(lpCS) IISInitializeCriticalSection(lpCS)

# endif  /* _DEBUG_HXX_ */

//
// The following macros allow the automatic naming of certain Win32 objects.
// See IIS\SVCS\IISRTL\WIN32OBJ.C for details on the naming convention.
//
// Set IIS_NAMED_WIN32_OBJECTS to a non-zero value to enable named events,
// semaphores, and mutexes.
//

#if DBG
#define IIS_NAMED_WIN32_OBJECTS 1
#else
#define IIS_NAMED_WIN32_OBJECTS 0
#endif

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
PuDbgCreateEvent(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL ManualReset,
    IN BOOL InitialState
    );

HANDLE
PuDbgCreateSemaphore(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN LONG InitialCount,
    IN LONG MaximumCount
    );

HANDLE
PuDbgCreateMutex(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN LPSTR MemberName,
    IN PVOID Address,
    IN BOOL InitialOwner
    );

#ifdef __cplusplus
}   // extern "C"
#endif

#if IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    PuDbgCreateEvent(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (manual),                                                           \
        (state)                                                             \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    PuDbgCreateSemaphore(                                                   \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial),                                                          \
        (maximum)                                                           \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    PuDbgCreateMutex(                                                       \
        (LPSTR)__FILE__,                                                    \
        (ULONG)__LINE__,                                                    \
        (membername),                                                       \
        (PVOID)(address),                                                   \
        (initial)                                                           \
        )

#else   // !IIS_NAMED_WIN32_OBJECTS

#define IIS_CREATE_EVENT( membername, address, manual, state )              \
    CreateEventA(                                                           \
        NULL,                                                               \
        (manual),                                                           \
        (state),                                                            \
        NULL                                                                \
        )

#define IIS_CREATE_SEMAPHORE( membername, address, initial, maximum )       \
    CreateSemaphoreA(                                                       \
        NULL,                                                               \
        (initial),                                                          \
        (maximum),                                                          \
        NULL                                                                \
        )

#define IIS_CREATE_MUTEX( membername, address, initial )                     \
    CreateMutexA(                                                           \
        NULL,                                                               \
        (initial),                                                          \
        NULL                                                                \
        )

#endif  // IIS_NAMED_WIN32_OBJECTS


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\useracl.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2000                **/
/**********************************************************************/

/*
    useracl.hxx

        Declarations for some functions to add permissions to windowstations/
        desktops
*/

#ifndef _USERACL_H_
#define _USERACL_H_

BOOL AddTheAceWindowStation(
    HWINSTA hwinsta,         // handle to a windowstation
    PSID    psid             // logon sid of the user
    );

BOOL AddTheAceDesktop(
    HDESK hdesk,             // handle to a desktop
    PSID  psid               // logon sid of the user
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\timer.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Domain Name System (DNS) Server

    Wrap-proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#ifndef _TIMER_INCLUDED_
#define _TIMER_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

VOID
InitializeSecondsTimer(
    VOID
    );


VOID
TerminateSecondsTimer(
    VOID
    );

DWORD
GetCurrentTimeInSeconds(
    VOID
    );


__int64
GetCurrentTimeInMilliseconds(
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif  // _TIMER_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\sharelok.h ===
#ifndef __SHARELOCK_H__
#define __SHARELOCK_H__

//////////////////////////////////////////////////////////////////////
//
//   The standard include files.
//
//   The standard include files setup a consistent environment
//   for all of the modules in a program.  The structure of each
//   header file is as follows:
//      1. Standard include files.
//      2. Include files for inherited classes.
//      3. Constants exported from the class.
//      4. Data structures exported from the class.
//      5. Class specification.
//      6. Inline functions.
//   Sections that are not required are omitted.
//
//////////////////////////////////////////////////////////////////////

// #include "Global.h"
// #include "NewEx.h"
// #include "Standard.h"
// #include "System.h"

#include <irtlmisc.h>

typedef int SBIT32;

//////////////////////////////////////////////////////////////////////
//
//   Sharelock and Semaphore locking.
//
//   This class provides a very conservative locking scheme.
//   The assumption behind the code is that locks will be
//   held for a very short time.  A lock can be obtained in
//   either exclusive mode or shared mode.  If the lock is not
//   available the caller waits by spinning or if that fails
//   by sleeping.
//
//////////////////////////////////////////////////////////////////////

class IRTL_DLLEXP CSharelock
{ 
	private:

		// internally used constants

		enum Internal
		{
			//   The Windows NT kernel requires a maximum wakeup count when
			//   creating a semaphore.
			m_MaxShareLockUsers      = 256
		};

        //
        //   Private data.
        //
        volatile LONG                 m_lExclusive;
        volatile LONG                 m_lTotalUsers;

		SBIT32                        m_lMaxSpins;
		SBIT32                        m_lMaxUsers;
        HANDLE                        m_hSemaphore;
        volatile LONG                 m_lWaiting;

#ifdef _DEBUG

        //
        //   Counters for debugging builds.
        //
        volatile LONG                 m_lTotalExclusiveLocks;
        volatile LONG                 m_lTotalShareLocks;
        volatile LONG                 m_lTotalSleeps;
        volatile LONG                 m_lTotalSpins;
        volatile LONG                 m_lTotalTimeouts;
        volatile LONG                 m_lTotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        CSharelock( SBIT32 lNewMaxSpins = 4096, SBIT32 lNewMaxUsers = 256 );

        inline SBIT32 ActiveUsers( void ) { return (SBIT32) m_lTotalUsers; }

        inline void ChangeExclusiveLockToSharedLock( void );

        inline BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimExclusiveLock( SBIT32 lSleep = INFINITE );

        inline BOOLEAN ClaimShareLock( SBIT32 lSleep = INFINITE );

        inline void ReleaseExclusiveLock( void );

        inline void ReleaseShareLock( void );

        BOOLEAN UpdateMaxSpins( SBIT32 lNewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 lNewMaxUsers );

        ~CSharelock( void );


	private:
        //
        //   Private functions.
        //
        BOOLEAN SleepWaitingForLock( SBIT32 lSleep );

        BOOLEAN WaitForExclusiveLock( SBIT32 lSleep );

        BOOLEAN WaitForShareLock( SBIT32 lSleep );

        void WakeAllSleepers( void );      

    private:
        //
        //   Disabled operations.
        //
        CSharelock( const CSharelock & Copy );

        void operator=( const CSharelock & Copy );
};

/********************************************************************/
/*                                                                  */
/*   Change an exclusive lock to a shread lock.                     */
/*                                                                  */
/*   Downgrade the existing exclusive lock to a shared lock.        */
/*                                                                  */
/********************************************************************/

inline void CSharelock::ChangeExclusiveLockToSharedLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );
    
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif
}

/********************************************************************/
/*                                                                  */
/*   Change a shared lock to an exclusive lock.                     */
/*                                                                  */
/*   Upgrade the existing shared lock to an exclusive lock.         */
/*                                                                  */
/********************************************************************/

inline BOOLEAN CSharelock::ChangeSharedLockToExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
    
	if ( m_lTotalUsers != 1 )
    {
		if ( ! WaitForExclusiveLock( lSleep ) )
        { return FALSE; }
    }
#ifdef _DEBUG
    
	(void) InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif
    
    return TRUE;
}


//////////////////////////////////////////////////////////////////////
//
//   Claim an exclusive lock.
//
//   Claim an exclusive lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimExclusiveLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lExclusive );
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( m_lTotalUsers != 1 )
	{
		if ( ! WaitForExclusiveLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalExclusiveLocks );
#endif

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Claim a shared lock.
//
//   Claim a shared lock if available else wait or exit.
//
//////////////////////////////////////////////////////////////////////

inline BOOLEAN CSharelock::ClaimShareLock( SBIT32 lSleep )
{
	(void) InterlockedIncrement( (LPLONG) & m_lTotalUsers );

	if ( (m_lExclusive > 0) || (m_lTotalUsers > m_lMaxUsers) )
	{
		if ( ! WaitForShareLock( lSleep ) )
		{ 
			return FALSE; 
		}
	}
#ifdef _DEBUG

	InterlockedIncrement( (LPLONG) & m_lTotalShareLocks );
#endif

	return TRUE;
}

//////////////////////////////////////////////////////////////////////
//
//   Release an exclusive lock.
//
//   Release an exclusive lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseExclusiveLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );
	(void) InterlockedDecrement( (LPLONG) & m_lExclusive );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

//////////////////////////////////////////////////////////////////////
//
//   Release a shared lock.
//
//   Release a shared lock and if needed wakeup any sleepers.
//
//////////////////////////////////////////////////////////////////////

inline void CSharelock::ReleaseShareLock( void )
{
	(void) InterlockedDecrement( (LPLONG) & m_lTotalUsers );

    if ( m_lWaiting > 0 )
    { 
		WakeAllSleepers(); 
	}
}

#endif // __SHARELOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\wpif.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    wpif.h

Abstract:

    Defines aspects of the interface to the worker process, needed by the
    web admin service. 

Author:

    Seth Pollack (sethp)        16-Mar-1999

Revision History:

--*/


#ifndef _WPIF_H_
#define _WPIF_H_



//
// The name of the worker process executable.
//

#define WORKER_PROCESS_EXE_NAME L"w3wp.exe"
#define WORKER_PROCESS_TEST_EXE_NAME L"twp.exe"

//
// Event name for signalling the startup of w3core in inetinfo.
//
#define WEB_ADMIN_SERVICE_START_EVENT_W L"Global\\W3SVCStartW3WP-aae415e7-4598-4294-a382-0a435d5b32c5"
#define WEB_ADMIN_SERVICE_START_EVENT_A "Global\\W3SVCStartW3WP-aae415e7-4598-4294-a382-0a435d5b32c5"

//
// The name of the SSL filter channel
//

#define SSL_FILTER_CHANNEL_NAME L"SSLFilterChannel"

//
// Process exit codes for the worker process.
//

// the WAS killed the worker process
#define KILLED_WORKER_PROCESS_EXIT_CODE 0xFFFFFFFD

// the worker process exited ok
#define CLEAN_WORKER_PROCESS_EXIT_CODE  0xFFFFFFFE

// the worker process exited due to a fatal error
#define ERROR_WORKER_PROCESS_EXIT_CODE  0xFFFFFFFF



#endif  // _WPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\tracelog.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)        30-Apr-1997

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG {

    //
    // Signature.
    //

    LONG Signature;

    //
    // The total number of entries available in the log.
    //

    LONG LogSize;

    //
    // The index of the next entry to use.
    //

    LONG NextEntry;

    //
    // The byte size of each entry.
    //

    LONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR LogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((DWORD)'gOlT')
#define TRACE_LOG_SIGNATURE_X ((DWORD)'golX')


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

PTRACE_LOG
CreateTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader,
    IN LONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG Log
    );

LONG
WriteTraceLog(
    IN PTRACE_LOG Log,
    IN PVOID Entry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG Log
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\tmgr\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\ctrsdef\iisctrs.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    iisctrs.cxx

Abstract:

    Module: Definition of counters

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>


#include "iisctrs.h"


BEGIN_COUNTER_BINDING ( CIISCounters )
    BIND_COUNTER ( BytesSentPersec,  BytesSent      )
    BIND_COUNTER ( BytesSent,        BytesSent      )
    BIND_COUNTER ( TotalFilesSent,   TotalFilesSent )
END_COUNTER_BINDING ( CIISCounters )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\treader\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\inc\wasdbgut.h ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

// DEBUG_WEB_ADMIN_SERVICE turns on all the spew.  While 
// the rest of these can be used if you want to turn on 
// just one section of the spew.  This was done this way 
// because WEB_ADMIN_SERVICE was the original flag and the
// rest were broken out later in an attempt to quite the spew.
#define DEBUG_WEB_ADMIN_SERVICE             0x00010000
#define DEBUG_WEB_ADMIN_SERVICE_GENERAL     0x00030000  // Use 0x00020000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_DUMP        0x00050000  // Use 0x00040000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_REFCOUNT    0x00090000  // Use 0x00080000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_TIMER_QUEUE 0x00110000  // Use 0x00100000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_IPM         0x00210000  // Use 0x00200000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_WP          0x00410000  // Use 0x00400000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_LOW_MEM     0x00810000  // Use 0x00800000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_LOGGING     0x01010000  // Use 0x01000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_PERFCOUNT   0x02000000  // Use 0x02000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_CONTROL     0x04010000  // Use 0x04000000 to turn on only
#define DEBUG_WEB_ADMIN_SERVICE_QOS         0x08000000  // Use 0x08000000 to turn on only

// end_user_modifiable


// begin_user_modifiable

//
// Local debugging definitions
//


// check if we are on the main worker thread
#define ON_MAIN_WORKER_THREAD   \
    ( GetCurrentThreadId() == GetWebAdminService()->GetMainWorkerThreadId() )


// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\ctrsdef\iisctrs.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    iisctrs.h

Abstract:

    This is definition of IIS counters.

Author:

    Cezary Marcjan (cezarym)        03-02-2000

Revision History:

--*/


#ifndef _iisctrs_h__
#define _iisctrs_h__


#include "..\..\inc\counters.h"

//
// WMI class name. Must be identical to the class name
// used in the MOF file.
//
#define WMI_PERFORMANCE_CLASS       L"Win32_PerfRawData_IIS_IISCTRS"

//
// CIISCounters -> name of the class that will be declared.
//

BEGIN_CPP_PERFORMACE_CLASS ( CIISCounters )
    QWORD_COUNTER ( BytesSent )       // 64-bit integer
    DWORD_COUNTER ( TotalFilesSent )  // 32-bit integer
END_CPP_PERFORMANCE_CLASS ( CIISCounters )


#endif // _iisctrs_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\tviewer\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\ctrsdef\makefile.inc ===
# CODEWORK hard-coded to binplace from i386 tree

copyfiles:
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(IISBASEDIR)\lib\i386\iisctrs.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\twriter\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\tmgr\tmgr.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    tmgr.cxx

Abstract:

    SMManager sample. For test purposes.

Author:

    Cezary Marcjan (cezarym)        21-Mar-2000

Revision History:

--*/



#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include "..\..\ctrsdef\iisctrs.h"


PCWSTR
GetParam(
    PCWSTR szCmd
    )
{
    PCWSTR p;
    for(p=szCmd; !iswspace(*p) && L'\0'!=*p; p++)
        ;
    for(; iswspace(*p) && L'\0'!=*p; p++)
        ;

    PCWSTR pRet = p;

    if ( L'\0'!=*p)
        for (p=pRet+wcslen(pRet)-1; p>pRet && iswspace(*p); p--)
            *(PWSTR)p = L'\0';

    return pRet;
}


extern "C"
INT
__cdecl
wmain(
    INT,
    PWSTR *
    )
{
    WCHAR szCmd[1024] = { 0 };

    PCWSTR szExecuted = L"";

    CIISCounters Manager;
    
    HRESULT hRes = Manager.Initialize( WMI_PERFORMANCE_CLASS, SM_MANAGER );

    if ( FAILED(hRes) )
    {
        wprintf(L"ERROR: Manager.Initialize() FAILED");
        return hRes;
    }

    for(;;)
    {
        system("cls");

        if ( L'\0' !=szCmd[0] )
            wprintf(L"COMMAND %s\n\n", szExecuted );

        wprintf(L"\nIIS Counters SMManager Tester.\nAvailable commands:\n\n");
        wprintf(L"  add  <instance name>\n");
        wprintf(L"  del  <instance name>\n");
        wprintf(L"  close\n");
        wprintf(L"  end\n");

        wprintf(L"\n> ");
        _getws(szCmd);

        if(0==wcsncmp(szCmd,L"add",3))
        {
            PCWSTR szInst = GetParam(szCmd);
            if ( FAILED(Manager.m_pSM->AddCounterInstance(szInst)) )
                szExecuted = L"add: FAILED";
            else
                szExecuted = L"add: SUCCEEDED";
        }
        else if(0==wcsncmp(szCmd,L"del",3))
        {
            PCWSTR szInst = GetParam(szCmd);
            if ( FAILED(Manager.m_pSM->DelCounterInstance(szInst)) )
                szExecuted = L"del: FAILED";
            else
                szExecuted = L"del: SUCCEEDED";
        }
        else if(0==wcsncmp(szCmd,L"close",5))
        {
            if ( FAILED(Manager.Close()) )
                szExecuted = L"close: FAILED";
            else
                szExecuted = L"close: SUCCEEDED";
        }
        else if(0==wcsncmp(szCmd,L"end",3))
        {
            break;
        }
        else
        {
            szExecuted = L"UNRECOGNIZED\n";
        }
    }

    Manager.Close();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\makefile.inc ===
# CODEWORK hard-coded to binplace from i386 tree

copyfiles:
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $(IISBASEDIR)\lib\i386\wmihpp.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\treader\treader.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    treader.cxx

Abstract:

    SM Test Reader.

Author:

    Cezary Marcjan (cezarym)        24-May-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include "..\..\..\inc\counters.h"


VOID PrintCtrl ( ISMManager * pISMManager );
VOID PrintData ( ISMManager * pISMManager );

extern "C"
INT
__cdecl
wmain(
    INT,
    PWSTR *
    )
{
    PCWSTR const szClassName = L"Win32_PerfRawData_IIS_IISCTRS";

    HRESULT hRes = ::CoInitializeEx(
                        NULL,
                        COINIT_MULTITHREADED     |
                        COINIT_DISABLE_OLE1DDE
                        );

    if ( FAILED(hRes) )
    {
        wprintf(L"ERROR: CoInitialize() FAILED");
        return hRes;
    }

    CComPtr<ISMManager> pMgr;

    hRes = ::CoCreateInstance(
                __uuidof(CSMManager),
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(ISMManager),
                (PVOID*)&pMgr
                );

    if ( FAILED(hRes) )
    {
        wprintf(L"ERROR: CoCreateInstance() FAILED");
        return hRes;
    }

    DWORD dwIdx;
    DWORD dwNumCounters = 0;
    QWORD * pqwCtrVal = NULL;
    PCWSTR * pszCtrNames = NULL;

    for(;;)
    {
        if ( pMgr->IsSMLocked() )
        {
            pMgr->Close ( TRUE );
            delete[] pszCtrNames;
            pszCtrNames = NULL;
            hRes = pMgr->Open ( szClassName, COUNTER_READER );
            if ( FAILED(hRes) )
                continue;
        }
        ::system("cls");
        if ( NULL == pszCtrNames )
        {
            ICounterDef const * pCounterDef = NULL;
            if ( SUCCEEDED(pMgr->GetCountersDef(&pCounterDef)) )
            {
                dwNumCounters = pCounterDef->NumCounters();
            }
            if ( 0 < dwNumCounters )
            {
                pqwCtrVal = new QWORD[dwNumCounters];
                pszCtrNames = new PCWSTR[dwNumCounters];
                for(dwIdx=0; dwIdx<dwNumCounters; dwIdx++)
                {
                    CCounterInfo const * pCtrInfo = pCounterDef->GetCounterInfo(dwIdx);
                    _ASSERTE ( pCtrInfo != NULL );
                    pszCtrNames[dwIdx] = pCtrInfo->CounterName();
                }
            }
        }
        _ASSERTE ( NULL != pszCtrNames );
        if ( NULL == pszCtrNames )
            return 1;

        for(dwIdx=0; ; dwIdx++)
        {
            CSMInstanceDataHeader* pInstanceDataHeader = NULL;
            if ( FAILED(pMgr->InstanceDataHeader(0,dwIdx, &pInstanceDataHeader)) )
                break;
            if ( pInstanceDataHeader->IsEnd() )
                break;
            if ( pInstanceDataHeader->IsUnused()    ||
                 *pInstanceDataHeader->InstanceName() == L'\0'
                 )
                continue;
            if ( FAILED(pMgr->GetCounterValues(dwIdx,pqwCtrVal)) )
                break;

            wprintf(L"Counters Instance: \"%s\"\n",
                pInstanceDataHeader->InstanceName() );
            DWORD i;
            for(i=0; i<dwNumCounters; i++)
            {
                wprintf(L"\t%25s = %10I64u\n", pszCtrNames[i], pqwCtrVal[i]);
            }
        }
        ::Sleep(2000);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\tviewer\tviewer.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    W3SVCSMViewer.cxx

Abstract:

    SM viewer. For test purposes.

Author:

    Cezary Marcjan (cezarym)        21-Mar-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include "..\..\..\inc\counters.h"


VOID PrintCtrl ( ISMManager * pISMManager );
VOID PrintData ( ISMManager * pISMManager );

extern "C"
INT
__cdecl
wmain(
    INT,
    PWSTR *
    )
{
    PCWSTR const szClassName = L"Win32_PerfRawData_IIS_IISCTRS";

    HRESULT hRes = ::CoInitializeEx(
                        NULL,
                        COINIT_MULTITHREADED     |
                        COINIT_DISABLE_OLE1DDE
                        );

    if ( FAILED(hRes) )
    {
        wprintf(L"ERROR: CoInitialize() FAILED");
        return hRes;
    }

    CComPtr<ISMManager> pMgr;

    hRes = ::CoCreateInstance(
                __uuidof(CSMManager),
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(ISMManager),
                (PVOID*)&pMgr
                );

    if ( FAILED(hRes) )
    {
        wprintf(L"ERROR: CoCreateInstance() FAILED");
        return hRes;
    }

    for(;;)
    {
        if ( pMgr->IsSMLocked() )
        {
            pMgr->Close ( TRUE );
            hRes = pMgr->Open ( szClassName, COUNTER_READER );
        }
        if ( SUCCEEDED ( hRes ) )
        {
            ::system("cls");
            PrintCtrl(pMgr);
            PrintData(pMgr);
        }
        ::Sleep(2000);
    }

    return 0;
}


static CSMCtrlMem g_Ctrl; // local copy only


VOID
PrintCtrl(
    ISMManager * pISMManager
    )
{
    //
    // This works ONLY in the debug build
    //

#ifdef _DEBUG

    CSMCtrlMem * pSMCtrlMem = (CSMCtrlMem *)GetSMCtrlBlock(pISMManager);

    if ( NULL == pSMCtrlMem ||
         pISMManager->IsSMLocked() )
    {
        wprintf(L"ERROR: SM not initialized or locked...\n");
        return;
    }
 
    DWORD i;
    
    wprintf(L"======================================================================\n");
    wprintf(L"  SM CTRL BLOCK\n");
    wprintf(L"======================================================================\n");
    wprintf(L"      ClassName = \"%s\"\n", pSMCtrlMem->m_szClassName );
    wprintf(L"     AccessFlag =  %08X\n", pSMCtrlMem->m_dwAccessFlag );
    wprintf(L"NumSMDataBlocks =  %8u\n", pSMCtrlMem->m_dwNumSMDataBlocks );
    wprintf(L"   MaxInstances =  %8u\n", pSMCtrlMem->m_dwMaxInstances );
    wprintf(L"   DataInstSize =  %8u\n", pSMCtrlMem->m_dwDataInstSize );
    wprintf(L"    NumCounters =  %8u\n", pSMCtrlMem->m_dwNumCounters );
    wprintf(L" NumRawCounters =  %8u\n", pSMCtrlMem->m_dwNumRawCounters );

    CCounterInfo * pCtrInfo
        = (CCounterInfo *) ( (PBYTE)pSMCtrlMem + sizeof(CSMCtrlMem) );

    for(i=0; i<pSMCtrlMem->m_dwNumCounters; i++)
    {
        wprintf(L"Size=%u Offset=%u Name=\"%s\"\n",
            pCtrInfo[i].CounterSize(),
            pCtrInfo[i].CounterOffset(),
            pCtrInfo[i].CounterName()
            );
    }
    wprintf(L"======================================================================\n");

    memcpy(&g_Ctrl,pSMCtrlMem,sizeof(g_Ctrl));


#else //_DEBUG

    UNREFERENCED_PARAMETER ( pISMManager );
    wprintf(L"ERROR: This test program works only in debug build\n");

#endif//_DEBUG

}



VOID
PrintData(
    ISMManager * pISMManager
    )
{

#ifdef _DEBUG

    static WCHAR szBuf[1024] = { 0 };
    DWORD dwSMID;

    if ( NULL == pISMManager )
    {
        wprintf(L"ERROR: NULL == pISMManager...\n");
        return;
    }

    ICounterDef const * pCounterDef = 0;
    HRESULT hRes = pISMManager->GetCountersDef(&pCounterDef);

    if ( NULL == pCounterDef || FAILED(hRes) )
    {
        wprintf(L"ERROR: pISMManager->GetCountersDef() FAILED...\n");
        return;
    }

    for(dwSMID=0; dwSMID < pISMManager->NumSMDataBlocks(); dwSMID++)
    {
        CSMInstanceDataHeader * pSMDataMem
            = (CSMInstanceDataHeader *) GetSMDataBlock(dwSMID,pISMManager);

        if ( NULL == pSMDataMem || pISMManager->IsSMLocked() )
        {
            wprintf(L"ERROR: SM not initialized or locked...\n");
            return;
        }
        wprintf(L"     SM DATA BLOCK #%u of class%s\n", dwSMID, g_Ctrl.m_szClassName );
        wprintf(L"======================================================================\n");

        WCHAR szF[1024*10];
        DWORD dwI;
        DWORD dwMaxLen = 0;

        if(0==dwSMID)
        {
            for ( dwI = 0;
                  dwI < g_Ctrl.m_dwMaxInstances;
                  dwI++, pSMDataMem = (CSMInstanceDataHeader *)
                           ( (PBYTE)pSMDataMem + g_Ctrl.m_dwDataInstSize + sizeof(CSMInstanceDataHeader) ) )
            {
                PCWSTR szName = pSMDataMem->InstanceName();
                if ( pSMDataMem->IsCorrupted() )
                    szName = L"*** CORRUPTED ***";
                if ( pSMDataMem->IsUnused() )
                    szName = L"*** UNUSED ***";
                if ( pSMDataMem->IsEnd() )
                    szName = L"*** E N D ***";
                wsprintfW(szF, L"%2d %s", dwI, szName);
                if ( wcslen(szF)>dwMaxLen )
                    dwMaxLen = wcslen(szF);
            }
            wsprintfW(szF,L"%%2d  %%-%ds %%08X ", dwMaxLen);
        }

        pSMDataMem = (CSMInstanceDataHeader *) GetSMDataBlock(dwSMID,pISMManager);

        for ( dwI = 0;
              dwI < g_Ctrl.m_dwMaxInstances;
              dwI++, pSMDataMem = (CSMInstanceDataHeader *)
                       ( (PBYTE)pSMDataMem + g_Ctrl.m_dwDataInstSize + sizeof(CSMInstanceDataHeader) ) )
        {
            PCWSTR szName = pSMDataMem->InstanceName();
            if ( pSMDataMem->IsUnused() )
                szName = L"*** UNUSED ***";
            if ( pSMDataMem->IsEnd() )
                szName = L"*** E N D ***";
            if ( pSMDataMem->IsCorrupted() )
                szName = L"*** CORRUPTED ***";
            wprintf(szF, dwI, szName, pSMDataMem->Mask());
            DWORD dwC;
            PBYTE pData = (PBYTE)pSMDataMem->CounterDataStart();
            for ( dwC = 0; dwC < g_Ctrl.m_dwNumRawCounters; dwC++, pData += sizeof(DWORD) )
            {
                if ( pCounterDef->RawCounterSize(dwC) == sizeof(unsigned __int64) )
                {
                    double dVal = (double) *(__int64*)pData;
                    wprintf(L"%16.0f", dVal );
                    pData += sizeof(DWORD);
                }
                else
                    wprintf(L"%8u", *(DWORD*)pData );
                wprintf(L" ");
            }
            wprintf(L"\n");
        }
        wprintf(L"======================================================================\n");
    }


#else //_DEBUG

    UNREFERENCED_PARAMETER ( pISMManager );
    wprintf(L"ERROR: This test program works only in debug build\n");

#endif//_DEBUG

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\factory.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    factory.cxx

Abstract:

    This is implementation of standard class factory for
    the high performance provider for WMI.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/


#ifndef _factoryimp_h__
#define _factoryimp_h__



#define _WIN32_DCOM
#include <windows.h>

#include "smmgr.h"
#include "factory.h"


extern LONG g_lLocks;


/***********************************************************************++

Routine Description:

    Constructor for the CSMAccessClassFactory class.

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMAccessClassFactory::CSMAccessClassFactory(
    )
{
    m_RefCount = 1;

}   // CSMAccessClassFactory::CSMAccessClassFactory



/***********************************************************************++

Routine Description:

    Destructor for the CSMAccessClassFactory class.

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMAccessClassFactory::~CSMAccessClassFactory(
    )
{
    _ASSERTE ( m_RefCount == 0 );

}   // CSMAccessClassFactory::~CSMAccessClassFactory



/***********************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMAccessClassFactory::QueryInterface(
    REFIID iid,
    PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;


    _ASSERTE ( ppObject != NULL );

    if ( ppObject == NULL )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( iid == IID_IUnknown )
    {
        *ppObject = (PVOID)(IUnknown*) this;
    }
    else if ( iid == IID_IClassFactory )
    {
        *ppObject = (PVOID)(IClassFactory*) this;
    }
    else
    {
        *ppObject = NULL;

        hRes = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();


Exit:

    return hRes;

}   // CSMAccessClassFactory::QueryInterface



/***********************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***********************************************************************/

ULONG
STDMETHODCALLTYPE
CSMAccessClassFactory::AddRef(
    )
{
    LONG lNewCount;

    lNewCount = InterlockedIncrement( &m_RefCount );

    _ASSERTE ( lNewCount > 1 );

    return ( ( ULONG ) lNewCount );

}   // CSMAccessClassFactory::AddRef



/***********************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***********************************************************************/

ULONG
STDMETHODCALLTYPE
CSMAccessClassFactory::Release(
    )
{
    LONG lNewCount = InterlockedDecrement( &m_RefCount );

    _ASSERTE ( lNewCount >= 0 );

    if ( lNewCount == 0 )
    {
        delete this;
    }

    return ( ( ULONG ) lNewCount );

}   // CSMAccessClassFactory::Release



/***********************************************************************++

Routine Description:

    Standard IClassFactory::CreateInstance()

Arguments:

    pUnknownOuter - pointer to the controlling IUnknown interface of the
        aggregate ff the object is being created as part of an aggregate,
        otherwise, pUnkOuter must be NULL.

    iid - Reference to the identifier of the interface to be used to
        communicate with the newly created object. If pUnkOuter is NULL,
        this parameter is frequently the IID of the initializing
        interface; if pUnkOuter is non-NULL, iid must be IID_IUnknown
        (defined in the header as the IID for IUnknown). 

    ppObject - Address of pointer variable that receives the interface
        pointer requested in iid. Upon successful return, *ppObject
        contains the requested interface pointer. If the object does not
        support the interface specified in iid, the implementation sets
        *ppObject to NULL.

Return Value:

    HRESULT -- standard return values E_UNEXPECTED, E_OUTOFMEMORY, and
        E_INVALIDARG, as well as the following: 

        S_OK -- the specified object was created.

        CLASS_E_NOAGGREGATION -- the pUnkOuter parameter was non-NULL and
            the object does not support aggregation. 

        E_NOINTERFACE -- the object that ppObject points to does not
        support the interface identified by iid. 

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMAccessClassFactory::CreateInstance(
    IN IUnknown * pUnknownOuter, 
    IN REFIID iid, 
    OUT PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;
    CSMManager * pSMManager = NULL;

    *ppObject = NULL;

    if ( NULL == ppObject )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( NULL != pUnknownOuter )
    {
        //
        // We do not support aggregation
        //
        hRes = CLASS_E_NOAGGREGATION;

        pUnknownOuter->Release();
        pUnknownOuter = NULL;

        goto Exit;
    }

    pSMManager = new CSMManager;

    if ( NULL == pSMManager )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Retrieve the requested interface
    //
    hRes = pSMManager->QueryInterface(iid, ppObject);
    if ( FAILED ( hRes ) )
    {
        pSMManager->Release();
        goto Exit;
    }

    pSMManager->Release();


Exit:

    return hRes;

}   // CSMAccessClassFactory::CreateInstance



/***********************************************************************++

Routine Description:

    Standard IClassFactory::LockServer()

Arguments:

    fLock - If TRUE, the function increments the lock count;
        if FALSE, decrements.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMAccessClassFactory::LockServer(
    IN BOOL fLock
    )
{
    HRESULT hRes = S_OK;

    LONG lNewCount;

    if ( fLock )
    {
        lNewCount = InterlockedIncrement(&g_lLocks);

        _ASSERTE ( lNewCount > 0 );

        if ( lNewCount <= 0 )
            hRes = E_UNEXPECTED;
    }
    else
    {
        lNewCount = InterlockedDecrement(&g_lLocks);

        _ASSERTE ( lNewCount >= 0 );

        if ( lNewCount < 0 )
        {
            hRes = E_UNEXPECTED;
        }
    }   

    return hRes;

}   // CSMAccessClassFactory::LockServer(


#endif // _factoryimp_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\factory.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    factory.h

Abstract:

    This is definition of the class factory class for
    the shared memory manager.

Author:

    Cezary Marcjan (cezarym)        06-Apr-2000

Revision History:

--*/



#ifndef _factory_h__
#define _factory_h__


/***********************************************************************++

class CSMAccessClassFactory

    Class implements the COM class factory for the SMManager object
    defined in smmgr.h

    Implemented interfaces:

    IUnknown
    IClassFactory

--***********************************************************************/

class CSMAccessClassFactory
    : public IClassFactory
{

public:

    CSMAccessClassFactory();
    ~CSMAccessClassFactory();

    //
    // IUnknown methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    //
    // IClassFactory methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateInstance(
        IN IUnknown * pControllingUnknown,
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    LockServer(
        IN BOOL Lock
        );


private:


    LONG m_RefCount;

};  // class CSMAccessClassFactory



#endif  // _factory_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iisctrs\test\twriter\twriter.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    W3SVCTestWriter.cxx

Abstract:

    CounterWriter sample. For test purposes.

Author:

    Cezary Marcjan (cezarym)        21-Mar-2000

Revision History:

--*/



#define INITGUID
#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include "..\..\..\iisctrs\ctrsdef\iisctrs.h"


extern "C"
INT
__cdecl
wmain(
    INT,
    PWSTR v[]
    )
{
        DWORD dwAffinity = 0;

    PCWSTR szInstanceName = v[1];
    if (!szInstanceName)
    {
        wprintf(L"USAGE: Test_Writer instance_name [affinity]");

        return 1;
    }   

        if ( !!v[2] )
                dwAffinity = (DWORD)_wtol(v[2]);

    system("cls");
    wprintf(L"Test_Writer\n\n");

    if ( !!dwAffinity )
    {
        if ( !::SetProcessAffinityMask(::GetCurrentProcess(),dwAffinity) )
        {
            wprintf(L"FAILED to set process affinity mask to %08X\n", dwAffinity);
            dwAffinity = 0;
        }
    }

    DWORD dwSysAffinity = 0;
    ::GetProcessAffinityMask(::GetCurrentProcess(),&dwAffinity,&dwSysAffinity);
    wprintf(L"ProcessAffinityMask: %08X\n", dwAffinity );
    wprintf(L"SystemAffinityMask:  %08X\n\n", dwSysAffinity );
    wprintf(L"Connecting to instance %s...", szInstanceName);

    //
    // Initialize perf counters (for writing)
    //

    CIISCounters Ctrs;
    HRESULT hRes = Ctrs.Initialize( WMI_PERFORMANCE_CLASS, COUNTER_WRITER );
    if ( FAILED(hRes) )
    {
        wprintf(L"Counters Initialization failed\n");
        return 1;
    }

    while ( FAILED(Ctrs.Connect(szInstanceName)) )
    {
        ::Sleep(1000);
    }

    ::Sleep(0);

    wprintf(L" DONE\n\n");

    wprintf(L"               NumCounters: %d\n", Ctrs.NumCounters() );
    wprintf(L"            NumRawCounters: %d\n", Ctrs.NumRawCounters() );
    wprintf(L"  CountersInstanceDataSize: %d\n", Ctrs.CountersInstanceDataSize() );

    wprintf(L"\n");

    for(;;)
    {
        ::Sleep(100);
        Ctrs.IncrementBytesSent(700);
        Ctrs.IncrementTotalFilesSent();

        wprintf(L"BytesSent=%.0f  ", (double)(__int64)Ctrs.GetBytesSent() );
        wprintf(L"TotalFilesSent=%d\t\t\t\r", Ctrs.GetTotalFilesSent() );
    }

    Ctrs.Close();

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\smctrl.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smctrl.cxx

Abstract:

    This is implementation of CSMCtrl controller of generic shared memory
    manager (SM) used for IIS performance counters.

Author:

    Cezary Marcjan (cezarym)        05-Mar-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>
#include <iisdef.h>

#include "..\inc\counters.h"
#include "smctrl.h"


extern LONG g_lObjects;
extern LONG g_lLocks;


/***********************************************************************++

Routine Description:

    ctor

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMCtrl::CSMCtrl(
    )
{
    m_aRawCounterSize  = NULL;
    m_aCounterInfo     = NULL;
    m_pCSMCtrlMem      = NULL;
    m_hCtrlMap         = NULL;
}



/***********************************************************************++

Routine Description:

    dtor

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMCtrl::~CSMCtrl(
    )
{
    Disconnect();

    m_aRawCounterSize  = NULL;
    m_aCounterInfo     = NULL;
    m_pCSMCtrlMem      = NULL;
    m_hCtrlMap         = NULL;
}



/***********************************************************************++

Routine Description:

    Function connects to the shared memory of the SM controller.

Arguments:

    IN  szClassName        -- controlled class name
    IN  dwNumSMDataBlocks  -- number of data blocks controlled by this
                              instance of CSMCtrl
    IN  fCreate            -- create the memory-mapped file

Return Value:

    HRESULT

    If fCreate==TRUE and the memory-mapped file of the control block for
    the specified class name exists then failure will be returned.

    If we cannot connec/create MMF for this CSMCtrl failure is returned

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMCtrl::Initialize(
    IN  PCWSTR   szClassName,
    IN  DWORD    dwNumSMDataBlocks,
    IN  SMACCESSOR_TYPE     fAccessorType,
    IN  ICounterDef const * pCounterDef
    )
{
    HRESULT hRes = E_FAIL;

    DWORD dwCtrlBlockSize = 0;
    PWSTR szMapObjName = 0;

    PCWSTR const szObjNamePrefix = L"_SMCtrl_";

    if ( NULL != m_pCSMCtrlMem )
    {
        hRes = S_OK;

        goto Exit;
    }

    if ( NULL == szClassName ||
         SM_MANAGER == fAccessorType &&
         ( 0 == dwNumSMDataBlocks || NULL == pCounterDef )
         )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( SM_MANAGER != fAccessorType )
    {
        pCounterDef = NULL;
        m_aCounterInfo = NULL;
    }

    szMapObjName = new WCHAR[ ( ::wcslen(szObjNamePrefix)
                                + ::wcslen(szClassName) + 1 ) * 2 ];

    if ( NULL == szMapObjName )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    ::wcscpy ( szMapObjName, szObjNamePrefix );
    ::wcscat ( szMapObjName, szClassName );


    if ( SM_MANAGER == fAccessorType )
    {
        dwCtrlBlockSize = sizeof(CSMCtrlMem)
             + sizeof(CCounterInfo) * pCounterDef->NumCounters()
             + sizeof(DWORD) * pCounterDef->NumRawCounters();

        hRes = ConnectMMF(
                    szMapObjName,
                    dwCtrlBlockSize,
                    SM_MANAGER == fAccessorType,
                    &m_hCtrlMap,
                    (PVOID*)&m_pCSMCtrlMem
                    );
    
        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        m_aCounterInfo = (CCounterInfo const *)
            ( (PBYTE)m_pCSMCtrlMem + sizeof(CSMCtrlMem) );

        //
        // SM created
        //
        ::wcsncpy(
            m_pCSMCtrlMem->m_szClassName,
            szClassName,
            MAX_NAME_CHARS
            );

        m_pCSMCtrlMem->m_dwAccessFlag = 0;
        m_pCSMCtrlMem->m_dwNumSMDataBlocks = dwNumSMDataBlocks;
        m_pCSMCtrlMem->m_dwMaxInstances = 10;
        m_pCSMCtrlMem->m_dwDataInstSize
            = pCounterDef->CountersInstanceDataSize();
        m_pCSMCtrlMem->m_dwNumCounters = pCounterDef->NumCounters();
        m_pCSMCtrlMem->m_dwNumRawCounters
            = pCounterDef->NumRawCounters();

        m_aRawCounterSize = (DWORD*) ( (PBYTE)m_aCounterInfo
              + sizeof(CCounterInfo) * m_pCSMCtrlMem->m_dwNumCounters );

        DWORD dwCtr;

        //
        // Write raw counter sizes to SM ctrl block
        //

        for ( dwCtr=0; dwCtr < pCounterDef->NumRawCounters(); dwCtr++ )
        {
            m_aRawCounterSize[dwCtr] = pCounterDef->RawCounterSize(dwCtr);
        }

        //
        // Write counter definition to SM ctrl block
        //

        for ( dwCtr=0; dwCtr < pCounterDef->NumCounters(); dwCtr++ )
        {
            CCounterInfo const * pInfo
                = pCounterDef->GetCounterInfo(dwCtr);

            if ( NULL == pInfo )
            {
                hRes = E_FAIL;

                DisconnectMMF(
                    &m_hCtrlMap,
                    (PVOID*)&m_pCSMCtrlMem
                    );

                m_aCounterInfo = NULL;

                goto Exit;
            }

            ::memcpy ( (PVOID)&m_aCounterInfo[dwCtr],
                       pInfo,
                       sizeof(CCounterInfo) );
        }
    }
    else
    {
        //
        // Connect to SM to get number of counters and disconnect
        //

        dwCtrlBlockSize = sizeof(CSMCtrlMem);

        hRes = ConnectMMF(
                    szMapObjName,
                    dwCtrlBlockSize,
                    FALSE,
                    &m_hCtrlMap,
                    (PVOID*)&m_pCSMCtrlMem
                    );
    
        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        dwCtrlBlockSize = sizeof(CSMCtrlMem)
             + sizeof(CCounterInfo) * m_pCSMCtrlMem->m_dwNumCounters;

        hRes = DisconnectMMF ( &m_hCtrlMap, (PVOID*)&m_pCSMCtrlMem );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        hRes = ConnectMMF(
                    szMapObjName,
                    dwCtrlBlockSize,
                    FALSE,
                    &m_hCtrlMap,
                    (PVOID*)&m_pCSMCtrlMem
                    );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        m_aCounterInfo = (CCounterInfo const *)
            ( (PBYTE)m_pCSMCtrlMem + sizeof(CSMCtrlMem) );

        m_aRawCounterSize
            = (DWORD*)&m_aCounterInfo[m_pCSMCtrlMem->m_dwNumCounters];
    }


Exit:

    if ( NULL != szMapObjName )
    {
        delete[] szMapObjName;
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Disconnects from the file-mapping and sets m_pCSMCtrlMem to NULL

Arguments:

    None.

Return Value:

    HRESULT:

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMCtrl::Disconnect(
    )
{
    HRESULT hRes = E_FAIL;

    hRes = DisconnectMMF ( &m_hCtrlMap, (PVOID*)&m_pCSMCtrlMem );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    hRes = S_OK;


Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Static function, connects to memory-mapped file backed with the
    system swap file.

Arguments:

    IN  szMapObjName -- file-mapping object name
    IN  cbSize          -- number of bytes to map
    IN  fCreate         -- if TRUE then create and fail if exists
    OUT phMap       -- address file-mapping object handle
    OUT ppMem    -- address of starting address of the mapped view

Return Value:

    HRESULT:

        E_INVALIDARG -- one of the arguments is invalid

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMCtrl::ConnectMMF(
    IN  PCWSTR   szMapObjName,
    IN  DWORD    cbSize,
    IN  BOOL     fCreate,
    OUT HANDLE * phMap,
    OUT PVOID *  ppMem
    )
{
    HRESULT hRes = E_FAIL;

    if ( NULL == szMapObjName ||
         0    == cbSize       ||
         NULL == phMap        ||
         NULL == ppMem )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    *phMap = ::OpenFileMappingW (
		FILE_MAP_ALL_ACCESS,
		FALSE,
        szMapObjName
        );

    if ( NULL != *phMap )
    {
        if ( fCreate )
        {
            ::CloseHandle ( *phMap );
            hRes = E_FAIL;
            goto Exit;
        }
    }
    else
    {
        if ( !fCreate )
        {
            hRes = E_FAIL;
            goto Exit;
        }

        *phMap = ::CreateFileMappingW (
            INVALID_HANDLE_VALUE,
            NULL,           // security
            PAGE_READWRITE, // protection
            0,              // high-order DWORD of size
            cbSize,         // low-order DWORD of size
            szMapObjName
            );

        if ( NULL == *phMap )
        {
            hRes = HRESULT_FROM_WIN32 ( ::GetLastError() );
            goto Exit;
        }
    }

    *ppMem = (CSMCtrlMem*)::MapViewOfFile (
		*phMap,
		FILE_MAP_ALL_ACCESS, // access mode
		0,                   // high-order 32 bits of file offset
		0,                   // low-order 32 bits of file offset
		cbSize               // number of bytes to map
		);

    if ( NULL == *ppMem )
    {
        hRes = HRESULT_FROM_WIN32 ( ::GetLastError() );
        goto Exit;
    }

    hRes = S_OK;

    if ( fCreate )
    {
        ::ZeroMemory ( *ppMem, cbSize );
    }


Exit:

    if ( FAILED(hRes) )
    {
        if ( NULL != ppMem )
        {
            *ppMem = NULL;
        }
        if ( NULL != phMap )
        {
            *phMap = NULL;
        }
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Static function, unmapps view and closes memory-mapped file.

Arguments:

    IN OUT phMap  -- address file-mapping object handle
    IN OUT ppMem  -- address of starting address of the mapped view

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMCtrl::DisconnectMMF(
    IN OUT HANDLE * phMap,
    IN OUT PVOID * ppMem
    )
{
    HRESULT hRes = E_FAIL;

    if ( NULL != ppMem && NULL != *ppMem )
    {
        if ( !UnmapViewOfFile(*ppMem) )
        {
            hRes = HRESULT_FROM_WIN32 ( ::GetLastError() );
            goto Exit;
        }

        *ppMem = NULL;
    }

    if ( NULL != phMap && NULL != *phMap )
    {
        if ( !::CloseHandle ( *phMap ) )
        {
            hRes = HRESULT_FROM_WIN32 ( ::GetLastError() );
            goto Exit;
        }

        *phMap = NULL;
    }

    hRes = S_OK;


Exit:

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\smctrl.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smctrl.h

Abstract:

    This is definition of classes for controller of generic shared memory
    manager (SM) used for IIS performance counters.

Author:

    Cezary Marcjan (cezarym)        05-Mar-2000

Revision History:

--*/


#ifndef _SMCtrl_h__
#define _SMCtrl_h__


#define MAX_CPUS 32

#define MAX_NAME_CHARS   256


typedef unsigned __int64 QWORD;


enum COUNTER_TYPE
{
    DWORD_TYPE = sizeof(DWORD),
    QWORD_TYPE = sizeof(QWORD),
    UNKNOWN_TYPE = 0
};


#define MAKE_DWORD_SIGN( Value )                                    \
            (                                                       \
                ( ( ( ( DWORD ) Value ) & 0xFF000000 ) >> 24 ) |    \
                ( ( ( ( DWORD ) Value ) & 0x00FF0000 ) >> 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x0000FF00 ) << 8 )  |    \
                ( ( ( ( DWORD ) Value ) & 0x000000FF ) << 24 )      \
            )                                                       \

//
// Types of shared memory accessors
//

enum SMACCESSOR_TYPE
{
    SM_MANAGER      = MAKE_DWORD_SIGN ( 'MNGR' ),
    COUNTER_READER  = MAKE_DWORD_SIGN ( 'READ' ),
    COUNTER_WRITER  = MAKE_DWORD_SIGN ( 'WRIT' ),
    SM_ACC_UNKNOWN  = MAKE_DWORD_SIGN ( 'UNKN' )
};



/***********************************************************************++

SM control access field (see description of the CSMCtrl class).

    The SM access flag is used for determining the state of SM which
    includes locked and unlocked states. The value of this flag is
    initialized with SMMANAGER_STATE_INITIAL value after all of SM is
    created and initialized. This flag's high 8 bits are never set when
    the SM is in the "unlocked" state. When the SMManager wants to lock
    SM it does so by setting the last 8 bits of the access flag to a
    specific value which defines the state of SM. Each time the SM  is
    "unlocked" and some structural changes have been made to SM making it
    incompatible with the SM prior to the change (expanding SM, removing
    counters...) the value of the VERSION is increased by 1 to notify
    users of SM that some structural changes have been made and the
    current "unlocked" state is incompatible with the previous one (for
    example, the data for a specific instance of counters is now in
    a different physical location). For this reason the lower 12 bits of
    the access flag are refered to as SM instance version. If the "SM
    instance version" is different than the current value stored in an
    SM accessor then SM is locked for this specific instance of accessor.
    In this condition the accessor will disconect from SM and then
    reconnect back.

    The CounterReader or CounterWriter can quicky determine if the SM
    is locked or unlocked by comparing ACCESS_FIELD::m_dwAccessFlag
    with the stored value of this field.

    Bits of the access filed:
    ------------------------
    Values are 32 bit values layed out as follows:

    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-------+-------+-------+-------+-------+-------+-------+-------+
   |   S T A T E   |                 V E R S I O N                 |
   +-------+-------+-------+-------+-------+-------+-------+-------+

--***********************************************************************/

//
// Definition of the VERSION sub-field:
//

//
// Smallest value of the VERSION in an "initialized" state.
//
#define SMMANAGER_INITIAL_VERSION                0x00000001

//
// SM not initialized yet
//
#define SMMANAGER_UNINITIALIZED_VERSION          0x00000000

//
// Mask used for reseting the STATE bits
//
#define SMMANAGER_VERSION_MASK                   0x00FFFFFF

//
// Mask used for reseting the VERSION bits
//
#define SMMANAGER_STATE_MASK       ( ~ SMMANAGER_VERSION_MASK )


//
// Definition of the STATE sub-field:
//

//
// Active state, not locked.
//
#define SMMANAGER_STATE_ACTIVE                   0x00000000

//
// SM is being initialized
//
#define SMMANAGER_STATE_INITIALIZING             0x01000000

//
// SM is being expanded to accomodate more instances of counters
//
#define SMMANAGER_STATE_EXPANDING                0x02000000

//
// SM is being shrinked to free space after defragmentation
//
#define SMMANAGER_STATE_SHRINKING                0x04000000

//
// An instance of a counter is being added to SM
//
#define SMMANAGER_STATE_ADDING_INSTANCE          0x08000000

//
// An instance of a counter is being deleted from SM
//
#define SMMANAGER_STATE_DELETIING_INSTANCE       0x10000000

//
// SM is being verified
//
#define SMMANAGER_STATE_VERIFYINGSM              0x20000000

//
// SM is being defragmented
//
#define SMMANAGER_STATE_DEFRAGMENTING            0x40000000

//
// SM states in which SM is considered "locked". In this state the
// CounterReaders and CounterWriters are not allowed to access SM and
// have to reconnect to SM.
//
#define SMMANAGER_STATE_LOCKED   (                  \
            SMMANAGER_STATE_INITIALIZING        |   \
            SMMANAGER_STATE_EXPANDING           |   \
            SMMANAGER_STATE_SHRINKING           |   \
            SMMANAGER_STATE_DELETIING_INSTANCE  |   \
            SMMANAGER_STATE_DEFRAGMENTING       |   \
            0 )
                                    

#define SM_INITIAL_ACCESS_FIELD_VALUE   SMMANAGER_INITIAL_VERSION


/***********************************************************************++

class CCounterInfo

    This class is used for direct mapping of the control MMF block
    of the shared memory. It represents the following fields:

    CounterName CounterType CounterOffset

    It is used in SMManager by casting a proper region of shared memory
    to this class pointer.

    This class is used also for passing counters definition to SMManager.
    In this case it is necesary to derive a class from CCounterInfo
    and set the protected members.

--***********************************************************************/

class CCounterInfo
{
public:

    CCounterInfo(
        PCWSTR szCounterName,
        DWORD  dwCounterOffset,
        DWORD  dwCounterSize
        )
    {
        ::ZeroMemory ( m_szCounterName, sizeof(m_szCounterName) );
        wcsncpy ( m_szCounterName, szCounterName, MAX_NAME_CHARS-1 );
        m_szCounterName[MAX_NAME_CHARS-1] = L'\0';
        m_dwCounterOffset = dwCounterOffset;
        m_dwCounterSize = dwCounterSize;
    }

    CCounterInfo()
    {
        ::ZeroMemory ( m_szCounterName, sizeof(m_szCounterName) );
        m_dwCounterOffset = 0;
        m_dwCounterSize = 0;
    }

    PCWSTR
    CounterName() const
    {
        return m_szCounterName;
    }

    DWORD
    CounterSize() const
    {
        return m_dwCounterSize;
    }

    DWORD
    CounterOffset() const
    {
        return m_dwCounterOffset;
    }

protected:

    WCHAR m_szCounterName[MAX_NAME_CHARS];
    DWORD m_dwCounterOffset;
    DWORD m_dwCounterSize;
};



/***********************************************************************++

class ICounterDef

    This class is used also for passing counters definition to SMManager
    server during the call to ISMManager::Open(). The caller of that
    method must be a SMManager and must provide a pointer to ICounterDef.

--***********************************************************************/


interface __declspec(novtable) ICounterDef
{
    virtual
    DWORD
    NumCounters(
        )
        const = 0;

    virtual
    DWORD
    NumRawCounters(
        )
        const = 0;

    virtual
    DWORD
    CountersInstanceDataSize(
        )
        const = 0;

    virtual
    CCounterInfo const *
    GetCounterInfo(
        DWORD dwCounterIdx
        )
        const = 0;

    virtual
    DWORD
    RawCounterSize(
        DWORD dwRawCounterIdx
        )
        const = 0;

    virtual
    DWORD
    MaxInstances(
        )
        const = 0;
};


//
// Simple implementation of ICounterDef
//

class CCounterDef
    : public ICounterDef
{

public:

    CCounterDef()
    {
        m_dwNumCounters = 0;
        m_dwNumRawCounters = 0;
        m_dwCountersInstanceDataSize = 0;
        m_dwMaxRawNumCounters = 0;
        m_aCounterInfo = NULL;
        m_aRawCounterType = NULL;
    }


    //
    // ICounterDef methods:
    //

    virtual
    DWORD
    NumCounters(
        )
        const
    {
        return m_dwNumCounters;
    }

    virtual
    DWORD
    NumRawCounters(
        )
        const
    {
        return m_dwNumRawCounters;
    }

    virtual
    DWORD
    CountersInstanceDataSize(
        )
        const
    {
        return m_dwCountersInstanceDataSize;
    }

    virtual
    CCounterInfo const *
    GetCounterInfo(
        DWORD dwCounterIdx
        )
        const
    {
        if ( dwCounterIdx >= m_dwNumCounters )
        {
            return NULL;
        }
        _ASSERTE ( NULL != m_aCounterInfo );
        return &m_aCounterInfo[dwCounterIdx];
    }

    virtual
    DWORD
    RawCounterSize(
        DWORD dwRawCounterIdx
        )
        const
    {
        if ( dwRawCounterIdx >= m_dwNumRawCounters )
        {
            return 0;
        }
        _ASSERTE ( NULL != m_aRawCounterType );

        return (DWORD)m_aRawCounterType[dwRawCounterIdx];
    }

    virtual
    DWORD
    MaxInstances(
        )
        const
    {
        return 0;
    }

public:

    DWORD  m_dwNumCounters;

    DWORD  m_dwNumRawCounters;

    DWORD  m_dwCountersInstanceDataSize;

    DWORD  m_dwMaxRawNumCounters;

    CCounterInfo *  m_aCounterInfo;

    COUNTER_TYPE *  m_aRawCounterType;
};


/***********************************************************************++

class CSMCtrl

    This class manages a shared memory block implemented using MMF, which
    is used for controling the data memory blocks (SMData) which can
    shrink and expand.

    This memory is mapped the following way:

    SMCtrl:
    -------
    ClassName
    AccessField
    NumSMDataBlocks
    MaxInstances
    CountersInstanceDataSize
    NumCounters
    NumRawCounters
    CounterName CounterSize CounterOffset
    CounterName CounterSize CounterOffset
    .....................................
    CounterName CounterSize CounterOffset
    RawCounterSize
    RawCounterSize
    ..............
    RawCounterSize


    All fields are 32-bit in size except for the ClassName and
    CounterName, which are 2*MAX_NAME_CHARS bytes in size each.

    The fields:

    CounterName CounterType CounterOffset

    are mapped using the CCounterInfo class.

--***********************************************************************/


class CSMCtrlMem
{
public:

    WCHAR m_szClassName[MAX_NAME_CHARS+1];
    DWORD m_dwAccessFlag;
    DWORD m_dwNumSMDataBlocks;
    DWORD m_dwMaxInstances;
    DWORD m_dwDataInstSize;
    DWORD m_dwNumCounters;
    DWORD m_dwNumRawCounters;

    BOOL
    IsValidSMID(
        DWORD dwSMID
        )
    {
        return dwSMID < m_dwNumSMDataBlocks;
    }
};


class CSMCtrl :
    public ICounterDef
{
public:

    //
    // Construction and initialization
    //

    CSMCtrl(
        );

    ~CSMCtrl(
        );

    HRESULT
    STDMETHODCALLTYPE
    Initialize(
        IN  PCWSTR  szClassName,
        IN  DWORD    dwNumSMDataBlocks = 0, // default when not SMManager
        IN  SMACCESSOR_TYPE     fAccessorType = COUNTER_WRITER,
        IN  ICounterDef const * pCounterDef = 0
        );

    HRESULT
    STDMETHODCALLTYPE
    Disconnect(
        );


    //
    // ICounterDef methods:
    //

    virtual
    DWORD
    NumCounters(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwNumCounters;
    }


    virtual
    DWORD
    NumRawCounters(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwNumRawCounters;
    }


    virtual
    DWORD
    CountersInstanceDataSize(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwDataInstSize;
    }


    CCounterInfo const *
    GetCounterInfo(
        DWORD dwCounterIdx
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        if ( dwCounterIdx < m_pCSMCtrlMem->m_dwNumCounters )
        {
            return &m_aCounterInfo[dwCounterIdx];
        }

        return NULL;
    }


    virtual
    DWORD
    RawCounterSize(
        DWORD dwRawCounterIdx
        )
        const
    {
        _ASSERTE ( NULL != m_aRawCounterSize );

        if ( dwRawCounterIdx < m_pCSMCtrlMem->m_dwNumRawCounters )
        {
            return m_aRawCounterSize[dwRawCounterIdx];
        }
        return 0;
    }


    virtual
    DWORD
    MaxInstances(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwMaxInstances;
    }


    //
    // Read-only access to properties:
    //

    PCWSTR
    ClassName(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_szClassName;
    }


    DWORD
    AccessFlag(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );
        
        return m_pCSMCtrlMem->m_dwAccessFlag;
    }


    DWORD
    NumSMDataBlocks(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwNumSMDataBlocks;
    }


    //
    // Derived read-only methods
    //

    //
    // SM is locked if:
    //    1. Not initialized (m_pCSMCtrlMem==NULL)
    //    2. One of the bits specified by SMMANAGER_STATE_LOCKED is set
    //    3. The expected version is different from expected version
    //    4. SM is not initialized
    //

    BOOL
    IsLocked(
        IN  DWORD dwExpectedVersion
        )
        const
    {
        if ( !IsInitialized() )
        {
            return TRUE;
        }

        DWORD dwA = m_pCSMCtrlMem->m_dwAccessFlag;

        DWORD dwExpVer = ( dwExpectedVersion & SMMANAGER_VERSION_MASK );
        DWORD dwCurVer = ( dwA & SMMANAGER_VERSION_MASK );

        return dwExpVer!=dwCurVer || ( dwA & SMMANAGER_STATE_LOCKED )!=0;
    }


    DWORD
    InstanceVersion(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwAccessFlag & SMMANAGER_VERSION_MASK;
    }


    DWORD
    SMState(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->m_dwAccessFlag & SMMANAGER_STATE_MASK;
    }


    BOOL
    IsState(
        DWORD dwAccessField
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return 0 != ( SMState() & dwAccessField );
    }


    BOOL
    IsStateSet(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return 0 != SMState();
    }


    BOOL
    IsInitialized(
        )
        const
    {
        if ( NULL == m_pCSMCtrlMem )
        {
            return FALSE;
        }

        return InstanceVersion() >= SMMANAGER_INITIAL_VERSION;
    }


    BOOL
    IsValidSMID(
        IN  DWORD dwSMID
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        return m_pCSMCtrlMem->IsValidSMID ( dwSMID );
    }


    ICounterDef const *
    CounterDef(
        )
        const
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );
        _ASSERTE ( NULL != m_aRawCounterSize );

        if ( NULL != m_pCSMCtrlMem && NULL != m_aRawCounterSize )
        {
            return this;
        }
        return 0;
    }


    //
    // Read/Write access:
    //

    // Increment version field, return new version
    DWORD
    IncrementVersion(
        )
    {
        // Only SMMangager does this
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        LONG lVer = (LONG)InstanceVersion();

        _ASSERTE ( ( lVer & SMMANAGER_STATE_MASK ) == 0 );

        lVer++;

        if ( SMMANAGER_VERSION_MASK < lVer )
        {
            lVer = SMMANAGER_INITIAL_VERSION;
        }

        DWORD dwNewA = m_pCSMCtrlMem->m_dwAccessFlag;

        dwNewA = ( dwNewA & SMMANAGER_STATE_MASK ) | lVer;

        ::InterlockedExchange(
            (PLONG)&m_pCSMCtrlMem->m_dwAccessFlag,
            dwNewA
            );

        return (DWORD) lVer;
    }


    // Decrement version field, return new version
    DWORD
    DecrementVersion(
        )
    {
        // Only SMMangager does this
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        LONG lVer = (LONG)InstanceVersion();

        _ASSERTE ( ( lVer & SMMANAGER_STATE_MASK ) == 0 );

        lVer--;

        if ( SMMANAGER_INITIAL_VERSION > lVer )
        {
            lVer = SMMANAGER_VERSION_MASK;
        }

        DWORD dwNewA = m_pCSMCtrlMem->m_dwAccessFlag;

        dwNewA = ( dwNewA & SMMANAGER_STATE_MASK ) | lVer;

        ::InterlockedExchange(
            (PLONG)&m_pCSMCtrlMem->m_dwAccessFlag,
            dwNewA
            );

        return (DWORD) lVer;
    }


    // Set instance version, return the old value.
    DWORD
    SetInstanceVersion(
        IN DWORD dwNewVersion
        )
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        if ( SMMANAGER_INITIAL_VERSION > dwNewVersion ||
             SMMANAGER_VERSION_MASK < dwNewVersion
             )
        {
            dwNewVersion = SMMANAGER_INITIAL_VERSION;
        }

        DWORD dwNewA = m_pCSMCtrlMem->m_dwAccessFlag;

        dwNewA = ( dwNewA & SMMANAGER_STATE_MASK ) | dwNewVersion;

        return ::InterlockedExchange(
                    (PLONG)&m_pCSMCtrlMem->m_dwAccessFlag,
                    dwNewA
                    ) & SMMANAGER_VERSION_MASK;
    }


    // Set state value, return old state value.
    DWORD
    SetState(
        IN DWORD dwState
        )
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );

        dwState &= SMMANAGER_STATE_MASK;

        DWORD dwNewA = m_pCSMCtrlMem->m_dwAccessFlag;

        dwNewA = ( dwNewA & SMMANAGER_VERSION_MASK ) | dwState;

        return ::InterlockedExchange(
                    (PLONG)&m_pCSMCtrlMem->m_dwAccessFlag,
                    dwNewA
                    ) & SMMANAGER_STATE_MASK;
    }


    DWORD
    SetMaxInstances(
        DWORD dwNewMaxInstances
        )
    {
        _ASSERTE ( NULL != m_pCSMCtrlMem );
        _ASSERTE ( 0 != dwNewMaxInstances );

        return ::InterlockedExchange(
                    (PLONG)&m_pCSMCtrlMem->m_dwMaxInstances,
                    dwNewMaxInstances
                    );
    }


    //
    // Static
    //

    static
    HRESULT
    STDMETHODCALLTYPE
    ConnectMMF(
        IN  PCWSTR szSMCtrlObjName,
        IN  DWORD cbSize,
        IN  BOOL fCreate,
        OUT HANDLE * phMap,
        OUT PVOID * ppMem
        );


    static
    HRESULT
    STDMETHODCALLTYPE
    DisconnectMMF(
        IN OUT HANDLE * phMap,
        IN OUT PVOID * ppMem
        );


protected:


    CCounterInfo const * m_aCounterInfo;

    DWORD * m_aRawCounterSize;

    //
    // SM Control block access
    //

    CSMCtrlMem *  m_pCSMCtrlMem;
    HANDLE        m_hCtrlMap;


    #ifdef _DEBUG

    /*******************************************************************++
        For testers -- direct access to shared memory
    --*******************************************************************/

    public:

    PVOID
    GetSMCtrlBlock(
        )
    {
        return (PVOID)m_pCSMCtrlMem;
    }

    #endif // _DEBUG

};


#endif // _SMCtrl_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\smmgr.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smmgr.cxx

Abstract:

    Generic shared memory manager used by IIS performance counters.

Author:

    Cezary Marcjan (cezarym)        06-Apr-2000

Revision History:

--*/


#define INITGUID

#define _WIN32_DCOM
#include <stdio.h>
#include <windows.h>
#include <iisdef.h>

#include "..\inc\counters.h"

#include "smmgr.h"
#include "factory.h"


//
// Growing and shrinking of the smared memory is done using golden ratio.
// (no need for such accuracy but why not...)
//

const
double
GOLDEN_RATIO = 1.618033988749894848204586834365638117720309180;



/***********************************************************************++

    Generic COM server code implementation

--***********************************************************************/

#define IMPLEMENTED_CLSID         __uuidof(CSMManager)
#define SERVER_REGISTRY_COMMENT   L"IIS Shared Memory Inproc COM server"
#define CLASSFACTORY_CLASS        CSMAccessClassFactory

#include "..\inc\serverimp.h"

extern LONG g_lObjects;
extern LONG g_lLocks;


/***********************************************************************++

Routine Description:

    CSMManager ctor

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMManager::CSMManager(
    )
{
    LONG lNewObjects = InterlockedIncrement(&g_lObjects);

    UNREFERENCED_PARAMETER( lNewObjects );

    m_RefCount = 1;

    m_fAccessorType = COUNTER_READER;

    m_dwSMID = 0;

    m_dwSystemAffinityMask = 0;

    m_dwCurrentSMInstanceVersion = SMMANAGER_UNINITIALIZED_VERSION;

    ::ZeroMemory ( m_ahSMData, sizeof(m_ahSMData) );
    ::ZeroMemory ( m_apSMData, sizeof(m_apSMData) );

    m_dwSMDataMapSize = 0;

    m_dwSMCounterInstanceSize = 0;

    ::ZeroMemory ( m_aszSMDataObjName, sizeof(m_aszSMDataObjName) );
}



/***********************************************************************++

Routine Description:

    CSMManager dtor

Arguments:

    None.

Return Value:

    None.

--***********************************************************************/

CSMManager::~CSMManager(
    )
{
    DWORD dwSMID;
    HRESULT hRes = S_OK;

    if ( m_SMCtrl.IsInitialized() )
    {
        _ASSERTE ( m_dwSMID < m_SMCtrl.NumSMDataBlocks() );
        _ASSERTE ( m_SMCtrl.MaxInstances() > 0 );

        for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++)
        {
            if ( NULL != m_aszSMDataObjName[dwSMID] )
            {
                delete[] m_aszSMDataObjName[dwSMID];
                m_aszSMDataObjName[dwSMID] = NULL;
            }

            hRes = m_SMCtrl.DisconnectMMF(
                                &m_ahSMData[dwSMID],
                                &m_apSMData[dwSMID] );

            if ( FAILED(hRes) )
            {
                //
                // Can't do much more than this:
                //
                m_ahSMData[dwSMID] = NULL;
                m_apSMData[dwSMID] = NULL;
            }
        }

        hRes = m_SMCtrl.Disconnect();
    }

    LONG lNewObjects = InterlockedDecrement(&g_lObjects);

    UNREFERENCED_PARAMETER( lNewObjects );

    _ASSERTE( m_RefCount == 0 );
}



/***********************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::QueryInterface(
    IN REFIID iid,
    OUT PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;

    _ASSERTE ( ppObject != NULL );

    if ( NULL == ppObject )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( iid == IID_IUnknown )
    {
        *ppObject = (PVOID)(IUnknown*)(ISMDataAccess*)(ISMManager*)this;
    }
    else if ( iid == __uuidof(ISMManager) )
    {
        *ppObject = (PVOID)(ISMManager*) this;
    }
    else if ( iid == __uuidof(ISMDataAccess) )
    {
        *ppObject = (PVOID)(ISMDataAccess*)(ISMManager*) this;
    }
    else
    {
        *ppObject = NULL;
    
        hRes = E_NOINTERFACE;
        goto Exit;
    }

    AddRef();


Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***********************************************************************/

ULONG
STDMETHODCALLTYPE
CSMManager::AddRef(
    )
{
    LONG lNewCount = InterlockedIncrement( &m_RefCount );

    UNREFERENCED_PARAMETER( lNewCount );

    _ASSERTE ( lNewCount > 1 );

    return ( ( ULONG ) lNewCount );
}



/***********************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***********************************************************************/

ULONG
STDMETHODCALLTYPE
CSMManager::Release(
    )

{
    LONG lNewCount = InterlockedDecrement( &m_RefCount );

    _ASSERTE ( lNewCount >= 0 );

    if ( lNewCount == 0 )
    {
        delete this;
    }

    return ( ( ULONG ) lNewCount );
}



/***********************************************************************++

Routine Description:

    Generate SM MMF object names for specified class name.

Arguments:

    IN  szCountersClassName -- class name of the counters

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::SetSMObjNames(
    IN  PCWSTR  szCountersClassName,
    IN  DWORD   dwSMInstanceVersion
    )
{
    HRESULT hRes = S_OK;
    DWORD dwSMID;

    if ( NULL  == szCountersClassName  ||
         L'\0' == *szCountersClassName
       )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++)
    {
        DWORD dwLen = ::wcslen(szCountersClassName) + 32;
        WCHAR szPrefix[32];
        swprintf ( szPrefix, L"Data%02X-%06X-",
                                  dwSMID, dwSMInstanceVersion );

        if ( NULL != m_aszSMDataObjName[dwSMID] )
        {
            delete[] m_aszSMDataObjName[dwSMID];
        }

        m_aszSMDataObjName[dwSMID] = new WCHAR [ dwLen * sizeof(WCHAR) ];
        if ( NULL == m_aszSMDataObjName[dwSMID] )
        {
            hRes = E_OUTOFMEMORY;
            goto Exit;
        }

        ::wcscpy ( m_aszSMDataObjName[dwSMID], szPrefix );
        ::wcscat ( m_aszSMDataObjName[dwSMID], szCountersClassName );
    }

Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function connects to the shared memory of the SM controller and
    initializes it. There can be only once instance of SMManager so if
    there is another one active this call will fail.

    Function connects also to appropriate SM data blocks depending on the
    accessor type (CounterWriter opens only one MMF specified by the
    affinity of the process).

Arguments:

    IN  szCountersClassName -- counters class name to create/connect to
    IN  fAccessorType       -- accessor type

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::Open(
    IN  PCWSTR               szCountersClassName,
    IN  SMACCESSOR_TYPE      fAccessorType,
    IN  ICounterDef const *  pCounterDef  // must be set if SMManager
    )
{
    HRESULT hRes = S_OK;
    BOOL fLocked = FALSE;

    HANDLE hProcess = 0;
    DWORD dwProcessAffinityMask = 0;
    DWORD dwMask = 0;
    DWORD dwNumCPUs;
    DWORD dwSMID;

    //
    // Check the input parameters
    //

    if ( NULL == szCountersClassName ||
         L'\0' == *szCountersClassName ||
         ( NULL == pCounterDef && SM_MANAGER == fAccessorType ) )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    //
    // Check if already connected
    //

    if ( m_SMCtrl.IsInitialized() )
    {
        Close ( TRUE );
    }
    
    m_fAccessorType = fAccessorType;

    //
    // Calculate m_dwSMID from affinity of the process
    //

    hProcess = ::GetCurrentProcess();

    ::GetProcessAffinityMask(
        hProcess,
        &dwProcessAffinityMask,
        &m_dwSystemAffinityMask
        );

    dwProcessAffinityMask &= m_dwSystemAffinityMask;

    if ( fAccessorType != COUNTER_WRITER ||
         dwProcessAffinityMask == m_dwSystemAffinityMask )
    {
        ::InterlockedExchange ( (PLONG)&m_dwSMID, 0L );
    }
    else
    {
        // Calculate SM ID
        for( dwMask = 1, m_dwSMID = 1;
             dwMask != 0 && 0 == (dwMask & dwProcessAffinityMask);
             dwMask <<= 1, m_dwSMID++ )
                 ;

        if ( 0 == dwMask )
            ::InterlockedExchange((PLONG)&m_dwSMID,0L);
    }

    //
    // Get the number of system CPUs from the affinity mask
    // (for consistency)
    //

	dwMask = 1;
	dwNumCPUs = 0;

    for( ; 0 != dwMask; dwMask <<= 1)
    {
        if ( 0 != ( dwMask & m_dwSystemAffinityMask ) )
            dwNumCPUs++;
    }

    if ( 0 == dwNumCPUs )
    {
        dwNumCPUs = 1;
    }

    _ASSERTE ( dwNumCPUs > 0 && dwNumCPUs <= MAX_CPUS );
    _ASSERTE ( m_dwSMID <= dwNumCPUs );

    //
    // Initialize the control MMF
    //

    hRes = m_SMCtrl.Initialize(
                        szCountersClassName,
                        dwNumCPUs + 1,
                        fAccessorType,
                        pCounterDef );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    if ( fAccessorType == SM_MANAGER )
    {
        hRes = LockSM ( SMMANAGER_STATE_INITIALIZING );
        _ASSERTE ( SUCCEEDED(hRes) );

        fLocked = TRUE;

        m_SMCtrl.SetInstanceVersion ( SM_INITIAL_ACCESS_FIELD_VALUE );
    }

    m_dwCurrentSMInstanceVersion = m_SMCtrl.InstanceVersion();

    // Set the data MMF object names
    hRes = SetSMObjNames(
                szCountersClassName,
                m_dwCurrentSMInstanceVersion
                );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    // Calculate size (in bytes) required per instance incuding
    // instance name and the BEGIN_FLAG.
    m_dwSMCounterInstanceSize = m_SMCtrl.CountersInstanceDataSize()
                                + sizeof(DWORD)
                                + sizeof(WCHAR) * MAX_NAME_CHARS;

    m_dwSMDataMapSize = m_dwSMCounterInstanceSize
                        * m_SMCtrl.MaxInstances();

    if ( fAccessorType == COUNTER_WRITER )
    {
        //
        // A writer accesses only one SM.
        // Open only the SM specified by m_dwSMID.
        //

        dwSMID = m_dwSMID;

        hRes = m_SMCtrl.ConnectMMF(
                    m_aszSMDataObjName[dwSMID],
                    m_dwSMDataMapSize,
                    FALSE, // writer doesn't create
                    &m_ahSMData[dwSMID],
                    &m_apSMData[dwSMID]
                    );
    }
    else
    {
        //
        // If not writer then we connect to all SM objects
        //

        for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
        {
            hRes = m_SMCtrl.ConnectMMF(
                        m_aszSMDataObjName[dwSMID],
                        m_dwSMDataMapSize,
                        fAccessorType == SM_MANAGER,
                        &m_ahSMData[dwSMID],
                        &m_apSMData[dwSMID]
                        );

            if ( FAILED(hRes) )
            {
                break;
            }
            
            if ( SM_MANAGER == m_fAccessorType )
            {
                hRes = InitSMData(m_apSMData[dwSMID]);

                if ( FAILED(hRes) )
                {
                    break;
                }
            }
        }
    }

    if ( FAILED(hRes) )
    {
        //
        // Need to cleanup: DisconnectMMF(for all dwSMID)
        //
        for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
        {
            hRes = m_SMCtrl.DisconnectMMF(
                        &m_ahSMData[dwSMID],
                        &m_apSMData[dwSMID]
                        );
            if ( FAILED(hRes) )
            {
                //
                // if failed, the following may not be set to NULL:
                //
                m_ahSMData[dwSMID] = NULL;
                m_apSMData[dwSMID] = NULL;
            }
        }

        goto Exit;
    }


Exit:

    if ( fLocked )
    {
        HRESULT h = UnlockSM ( SMMANAGER_STATE_ACTIVE );
        UNREFERENCED_PARAMETER( h );
        _ASSERTE ( SUCCEEDED(h) );
    }

    if ( FAILED(hRes) )
    {
        Close ( TRUE );
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function initilizes the SM Data block.

Valid state on entry:

    SMMANAGER_STATE_INITIALIZING
    SMMANAGER_STATE_EXPANDING
    SMMANAGER_STATE_SHRINKING

Arguments:

    IN OUT pSMDataBlock -- pointer to the memory block to be initialized

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::InitSMData(
    IN OUT PVOID pSMDataBlock
    )
{
    HRESULT hRes = S_OK;
    DWORD dwInstanceIdx;

    if ( SM_MANAGER != m_fAccessorType ||
         !m_SMCtrl.IsState(
                        SMMANAGER_STATE_INITIALIZING |
                        SMMANAGER_STATE_EXPANDING    |
                        SMMANAGER_STATE_SHRINKING
                        )
         )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    ::ZeroMemory ( pSMDataBlock, m_dwSMDataMapSize );

    for ( dwInstanceIdx=0;
          dwInstanceIdx < m_SMCtrl.MaxInstances();
          dwInstanceIdx++ )
    {
        CSMInstanceDataHeader * pHeader = (CSMInstanceDataHeader*)
              ( (PBYTE)pSMDataBlock +
                dwInstanceIdx * m_dwSMCounterInstanceSize );

        pHeader->InitializeMasks();
    }

Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Close SM and release all resources related to it.

Arguments:

    None.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::Close(
    BOOL fDisconnectSMCtrl
    )
{
    HRESULT hRes = S_OK;
    DWORD dwSMID;

    if ( m_SMCtrl.IsInitialized() )
    {
        _ASSERTE ( m_dwSMID < m_SMCtrl.NumSMDataBlocks() );

        for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
        {
            hRes = m_SMCtrl.DisconnectMMF(
                        &m_ahSMData[dwSMID],
                        &m_apSMData[dwSMID]
                        );
            if ( FAILED(hRes) )
            {
                goto Exit;
            }
        }

        if ( fDisconnectSMCtrl )
        {
            hRes = m_SMCtrl.Disconnect();

            if ( FAILED(hRes) )
            {
                goto Exit;
            }

            m_dwCurrentSMInstanceVersion
                = SMMANAGER_UNINITIALIZED_VERSION;
        }
    }

Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function locks SM, all accessors will disconnect and connect back
    when unlocked.

Arguments:

    None.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::LockSM(
    IN  DWORD dwNewState,
    OUT DWORD * pdwPreviousState
    )
{
    //
    // can't lock without setting the state:
    //
    _ASSERTE ( 0 != ( SMMANAGER_STATE_MASK & dwNewState) );

    if ( SM_MANAGER != m_fAccessorType )
    {
        return E_FAIL;
    }

    if ( NULL != pdwPreviousState )
    {
        *pdwPreviousState = m_SMCtrl.SetState ( dwNewState );
    }
    else
    {
        m_SMCtrl.SetState ( dwNewState );
    }

    ::Sleep(100);

    return S_OK;
}


/***********************************************************************++

Routine Description:

    Function unlocks SM, all accessors will connect back to SM.

Arguments:

    None.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::UnlockSM(
    IN  DWORD fAccessFlagValueBeforeLocking
    )
{
    if ( m_fAccessorType != SM_MANAGER ||
         !m_SMCtrl.IsStateSet() )
    {
        return E_FAIL;
    }

    m_SMCtrl.SetState ( fAccessFlagValueBeforeLocking );

    return S_OK;
}



/***********************************************************************++

Routine Description:

    Checks if access to SM is locked or not.

Arguments:

    None.

Return Value:

    TRUE  -  SM is not accessible
    FALSE -  SM is accessible (not locked)

--***********************************************************************/

BOOL
STDMETHODCALLTYPE
CSMManager::IsSMLocked(
    )

{
    BOOL fRes = m_SMCtrl.IsLocked ( m_dwCurrentSMInstanceVersion );

    return fRes;
}



/***********************************************************************++

Routine Description:

    Return number of SM data blocks

Arguments:

    None.

Return Value:

    Number of data blocks, 0 if error

--***********************************************************************/

DWORD
STDMETHODCALLTYPE
CSMManager::NumSMDataBlocks(
    )
{
    DWORD dwRes = m_SMCtrl.NumSMDataBlocks();

    return dwRes;
}



/***********************************************************************++

Routine Description:

    Return counters definition structure

Arguments:

    ppCounterDef -- pointer to memory for the counters definition

Return Value:

    TRUE  -  SM is not accessible
    FALSE -  SM is accessible (not locked)

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::GetCountersDef(
    ICounterDef const ** ppCounterDef
    )
{
    HRESULT hRes = S_OK;

    if ( NULL == ppCounterDef )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    *ppCounterDef = m_SMCtrl.CounterDef();

    if ( NULL == *ppCounterDef )
    {
        hRes = E_FAIL;
        goto Exit;
    }

Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Sets the poiters of the ppData array to memory locations of each SM
    data block (for each CPU) for the given instance of the counters.

    Only CounterReader may call this function.

Valid state on entry:

    not SMMANAGER_STATE_LOCKED

Arguments:

    IN  dwInstanceIdx       -- instance index of instance to connect to
    OUT ppData[MAX_CPUS+1]  -- array of pointers to be set. Only first
                               m_SMCtrl.MaxInstances() pointers will be
                               set. If the accessor is CounterWriter only
                               the ppData[m_dwSMID] will be set.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::GetCounterValues(
    IN  DWORD   dwInstanceIdx,
    OUT QWORD * pqwCounterValues
    )
{
    HRESULT hRes = S_OK;
    DWORD dwSMID;
    PBYTE apData[MAX_CPUS+1] = { 0 };

    if ( dwInstanceIdx >= m_SMCtrl.MaxInstances()       ||
         NULL  == pqwCounterValues                      ||
         m_SMCtrl.IsState ( SMMANAGER_STATE_LOCKED )    ||
         COUNTER_READER != m_fAccessorType )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    for ( dwSMID=0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
    {
        CSMInstanceDataHeader * pHeader = NULL;
        hRes = InstanceDataHeader ( dwSMID, dwInstanceIdx, &pHeader );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        apData[dwSMID] = (PBYTE)pHeader->CounterDataStart();
    }

    DWORD dwCtr;
    for ( dwCtr=0; dwCtr < m_SMCtrl.NumCounters(); dwCtr++ )
    {
        pqwCounterValues[dwCtr] = 0;

        CCounterInfo const * pCtrInfo
            = m_SMCtrl.GetCounterInfo ( dwCtr );
        if ( NULL == pCtrInfo )
            continue;

        for ( dwSMID = 0;
              dwSMID < m_SMCtrl.NumSMDataBlocks();
              dwSMID++
              )
        {
            PBYTE pCtr = apData[dwSMID] + pCtrInfo->CounterOffset();

            switch ( pCtrInfo->CounterSize() )
            {
            case sizeof(DWORD):
                pqwCounterValues[dwCtr]
                    += ( (CDWORDCounterReader*)pCtr )->GetValue();
                break;
            case sizeof(QWORD):
                pqwCounterValues[dwCtr]
                    += ( (CQWORDCounterReader*)pCtr )->GetValue();
                break;
            default:
                break;
            }
        }
    }

Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Returns the SM ID value. If the caller is not SMWriter then this
    function failes (only writer uses process affinity).

Arguments:

    OUT pdwSMID -- pointer to DWORD for the SMID value

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::GetSMID(
    OUT DWORD * pdwSMID
    )
{
    if ( NULL == pdwSMID )
        return E_INVALIDARG;

    if ( COUNTER_WRITER != AccessorType() )
        return E_FAIL;

    *pdwSMID = m_dwSMID;

    return S_OK;
}



/***********************************************************************++

Routine Description:

    Returns the InstanceDataHeader pointer of the specified SM and
    coutners instance.

Arguments:

    IN  szInstanceName -- instance name of instance for the header
    IN  dwSMID         -- SM ID to connect to
    OUT pdwInstanceIdx -- (optional) returns the instance index
    OUT ppInstanceDataHeader -- the output value

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::InstanceDataHeader(
    IN  DWORD    dwSMID,
    IN  PCWSTR   szInstanceName,
    OUT DWORD *  pdwInstanceIdx,
    OUT CSMInstanceDataHeader** ppInstanceDataHeader
    )
{
    CSMInstanceDataHeader * pRes = NULL;
    HRESULT hRes = E_FAIL;

    DWORD dwInstanceIdx;

    if ( !m_SMCtrl.IsValidSMID ( dwSMID )   || 
         NULL == szInstanceName             ||
         NULL == ppInstanceDataHeader       ||
         ( SM_MANAGER != m_fAccessorType && IsSMLocked() )
         )
    {
        goto Exit;
    }

    *ppInstanceDataHeader = NULL;

    for ( dwInstanceIdx = 0;
          dwInstanceIdx < m_SMCtrl.MaxInstances();
          dwInstanceIdx++ )
    {
        CSMInstanceDataHeader * pHeader = NULL;
        hRes = InstanceDataHeader ( dwSMID, dwInstanceIdx, &pHeader );

        if ( FAILED(hRes) || NULL == pHeader || pHeader->IsEnd() )
        {
            break;
        }

        if ( pHeader->IsCorrupted() )
        {
            break;
        }

        if ( pHeader->IsUnused() )
        {
            continue;
        }

        if ( 0 == _wcsnicmp ( szInstanceName,
                              pHeader->InstanceName(),
                              MAX_NAME_CHARS ) )
        {
            pRes = pHeader;

            if ( NULL != pdwInstanceIdx )
            {
                *pdwInstanceIdx = dwInstanceIdx;
            }

            if ( COUNTER_WRITER == m_fAccessorType )
            {
                m_dwCurrentSMInstanceVersion
                    = m_SMCtrl.InstanceVersion();
            }

            break;
        }
    }

    if ( NULL == pRes )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    *ppInstanceDataHeader = pRes;
    hRes = S_OK;


Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Returns the InstanceDataHeader pointer of the specified SM and
    coutners instance.

Arguments:

    IN  dwInstanceIdx -- instance index
    IN  dwSMID        -- SM ID to connect to
    OUT ppInstanceDataHeader -- the output value

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::InstanceDataHeader(
    IN  DWORD dwSMID,
    IN  DWORD dwInstanceIdx,
    OUT CSMInstanceDataHeader** ppInstanceDataHeader
    )
{
    HRESULT hRes = E_FAIL;

    if ( !m_SMCtrl.IsValidSMID ( dwSMID )  ||
         NULL == ppInstanceDataHeader      ||
         dwInstanceIdx >= m_SMCtrl.MaxInstances() ||
         ( SM_MANAGER != m_fAccessorType && IsSMLocked() )
         )
    {
        goto Exit;
    }

    if ( NULL == m_apSMData[dwSMID] )
    {
        goto Exit;
    }

    *ppInstanceDataHeader =
        (CSMInstanceDataHeader *) ( (PBYTE)m_apSMData[dwSMID] +
        dwInstanceIdx * m_dwSMCounterInstanceSize );

    hRes = S_OK;


Exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function adds a new instance of a counter to shared memory.

Valid state on entry:

    "initialized"

Arguments:

    IN  szInstanceName -- instance name

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::AddCounterInstance(
    IN  PCWSTR szInstanceName
    )
{
    DWORD   dwEmptyIdx   = 0;
    HRESULT hRes         = E_FAIL;
    BOOL    fSMLocked    = FALSE;
    DWORD   dwPriorState = 0;
    CSMInstanceDataHeader * pHeader = NULL;
    DWORD   dwSMID;

    if ( SM_MANAGER != m_fAccessorType )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    if ( NULL  == szInstanceName ||
         L'\0' == *szInstanceName )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    hRes = LockSM ( SMMANAGER_STATE_ADDING_INSTANCE, &dwPriorState );
    if ( FAILED(hRes) )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    fSMLocked = TRUE;

    hRes = DelCounterInstance ( szInstanceName );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }


    for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
    {
        //
        // Find empty instance block
        //

        pHeader = NULL;

        if ( dwSMID != 0 )
        {
            InstanceDataHeader ( dwSMID, dwEmptyIdx, &pHeader );
        }
        else
        {
            for ( dwEmptyIdx = 0;
                  dwEmptyIdx < m_SMCtrl.MaxInstances();
                  dwEmptyIdx++ )
            {
                InstanceDataHeader ( dwSMID, dwEmptyIdx, &pHeader );

                if ( NULL == pHeader  ||
                     pHeader->IsEnd() ||
                     pHeader->IsUnused() )
                {
                    break;
                }
            }

            if ( dwEmptyIdx >= m_SMCtrl.MaxInstances() )
            {
                hRes = ExpandSM ( GOLDEN_RATIO );

                if( FAILED(hRes) )
                {
                    goto Exit;
                }

                InstanceDataHeader ( dwSMID, dwEmptyIdx, &pHeader );

                _ASSERTE ( NULL != pHeader );
            }
        }

        if ( NULL == pHeader ||
             ( !pHeader->IsEnd() && !pHeader->IsUnused() ) )
        {
            hRes = E_FAIL;
            goto Exit;
        }

        _ASSERTE ( NULL != m_SMCtrl.CounterDef() );

        //
        // We found an empty instance block, initialize it.
        //

        pHeader->ResetCtrBeginMask();

        ::ZeroMemory( (PVOID)pHeader->CounterDataStart(),
               m_SMCtrl.CounterDef()->CountersInstanceDataSize() );

        pHeader->SetInstanceName(szInstanceName);
    }


Exit:

    if ( fSMLocked )
    {
        HRESULT h = UnlockSM ( dwPriorState );
        UNREFERENCED_PARAMETER( h );
        _ASSERTE ( SUCCEEDED(h) );
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function deletes the specified instance of perf counters from SM.

Valid state on entry:

    "initialized"

Arguments:

    IN  szInstanceName -- instance name

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::DelCounterInstance(
    IN  PCWSTR szInstanceName
    )
{
    HRESULT  hRes          = E_FAIL;
    BOOL     fSMLocked     = FALSE;
    DWORD    dwInstanceIdx = 0;
    DWORD    dwPriorState  = 0;
    DWORD    dwSMID;

    CSMInstanceDataHeader * pHeader = NULL;

    if ( NULL  == szInstanceName ||
         L'\0' == *szInstanceName )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( SM_MANAGER != m_fAccessorType )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    hRes = LockSM ( SMMANAGER_STATE_DELETIING_INSTANCE, &dwPriorState );
    if ( FAILED(hRes) )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    fSMLocked = TRUE;

    for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
    {
        VerifyInstances ( dwSMID, TRUE, FALSE );

        pHeader = NULL;

        if ( dwSMID != 0 )
        {
            InstanceDataHeader ( dwSMID, dwInstanceIdx, &pHeader );
        }
        else
        {
            for ( dwInstanceIdx = 0;
                  dwInstanceIdx < m_SMCtrl.MaxInstances();
                  dwInstanceIdx++ )
            {
                InstanceDataHeader ( dwSMID, dwInstanceIdx, &pHeader );

                if ( NULL == pHeader || pHeader->IsEnd() )
                {
                    pHeader = NULL;

                    break;
                }

                if ( pHeader->IsUnused() )
                {
                    continue;
                }

                if ( 0 == ::_wcsnicmp ( pHeader->InstanceName(),
                                        szInstanceName,
                                        MAX_NAME_CHARS ) )
                {
                    //
                    // We've found the instance!
                    //

                    break;
                }
            }

            if ( dwInstanceIdx >= m_SMCtrl.MaxInstances() )
            {
                pHeader = NULL;
            }
        }

        if ( NULL == pHeader )
        {
            hRes = S_OK;
            goto Exit;
        }

        _ASSERTE ( 0 == ::_wcsnicmp ( pHeader->InstanceName(),
                                        szInstanceName,
                                        MAX_NAME_CHARS ) );

        _ASSERTE ( NULL != m_SMCtrl.CounterDef() );

        //
        // We found the specified instance block, reset it.
        //

        pHeader->ResetCtrBeginMask();

        ::ZeroMemory( (PVOID)pHeader->CounterDataStart(),
                       m_SMCtrl.CounterDef()->CountersInstanceDataSize());

        pHeader->SetInstanceName(L"");
        pHeader->MarkInstanceUnused();

        VerifyInstances ( dwSMID, FALSE, TRUE );
    }

    hRes = ExpandSM ( 1.0 );

    if ( FAILED(hRes) )
    {
        hRes = E_FAIL;
        goto Exit;
    }


Exit:

    if ( fSMLocked )
    {
        HRESULT h = UnlockSM ( dwPriorState );
        UNREFERENCED_PARAMETER( h );
        _ASSERTE ( SUCCEEDED(h) );
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function marks all the empty instances from the end of SM data block
    with the DATA_END_MASK_VALUE mask (if fVerifyFromEnd) and checks
    all the instances for corruption (if fVerifyFromBeginning)

Valid state on entry:

    SMMANAGER_STATE_ADDING_INSTANCE
    SMMANAGER_STATE_DELETIING_INSTANCE
    SMMANAGER_STATE_EXPANDING

Arguments:

    IN  dwSMID               -- SM ID of block to verify

    IN  fVerifyFromBeginning -- start with the first instance all the way
                                to the last instance, dont set any
                                end mask to the DATA_END_MASK_VALUE.

    IN  fVerifyFromEnd       -- start with the last instance stop when
                                not corrupt and not unused. Set all the
                                end masks on the way to the
                                DATA_END_MASK_VALUE.

Return Value:

    None.

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::VerifyInstances(
    IN  DWORD dwSMID,
    IN  BOOL fVerifyFromBeginning,
    IN  BOOL fVerifyFromEnd
    )
{
    HRESULT hRes = S_OK;

    CSMInstanceDataHeader * pHeader = NULL;
    BOOL fWasEnd = FALSE;
    INT nInstanceIdx;

    if ( !m_SMCtrl.IsValidSMID(dwSMID) ||
         SM_MANAGER != m_fAccessorType ||
         !IsSMLocked() ||
         !m_SMCtrl.IsState(
                SMMANAGER_STATE_ADDING_INSTANCE     |
                SMMANAGER_STATE_DELETIING_INSTANCE  |
                SMMANAGER_STATE_EXPANDING
                )
         )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    _ASSERTE ( 0 != m_SMCtrl.MaxInstances() );

    if ( !fVerifyFromBeginning )
    {
        goto VerifyFromEnd;
    }


    //
    // Verify and cleanup instances starting from beginning
    //

    for ( nInstanceIdx =  0;
          nInstanceIdx < (int)m_SMCtrl.MaxInstances();
          nInstanceIdx ++ )
    {

        InstanceDataHeader ( dwSMID, (DWORD)nInstanceIdx, &pHeader );

        _ASSERTE ( NULL != pHeader );

        if ( NULL == pHeader )
        {
            break;
        }

        if ( pHeader->IsEnd() )
        {
            //
            // No need to cleanup, check the next instance.
            //

            fWasEnd = TRUE;

            continue;
        }

        _ASSERTE ( !pHeader->IsCorrupted() );

        if ( pHeader->IsCorrupted() || fWasEnd )
        {
            pHeader->ResetCtrBeginMask();

            _ASSERTE ( NULL != m_SMCtrl.CounterDef() );

            if ( NULL != m_SMCtrl.CounterDef() )
            {
                ::ZeroMemory( (PVOID)pHeader->CounterDataStart(),
                    m_SMCtrl.CounterDef()->CountersInstanceDataSize() );
            }

            pHeader->SetInstanceName(L"");

            if ( fWasEnd )
            {
                pHeader->MarkDataEnd();
            }
            else
            {
                pHeader->MarkInstanceUnused();
            }
        }
    }


VerifyFromEnd:


    if ( !fVerifyFromEnd )
    {
        goto Exit;
    }

    //
    // Verify and cleanup instances starting from the end
    //

    for ( nInstanceIdx =  m_SMCtrl.MaxInstances() - 1;
          nInstanceIdx >= 0;
          nInstanceIdx -- )
    {

        BOOL fCleanup = FALSE;

        InstanceDataHeader ( dwSMID, (DWORD)nInstanceIdx, &pHeader );

        _ASSERTE ( NULL != pHeader );

        if ( NULL == pHeader )
        {
            break;
        }

        if ( pHeader->IsEnd() )
        {
            //
            // No need to cleanup, check the previous instance.
            //
            continue;
        }

        _ASSERTE ( !pHeader->IsCorrupted() );

        if ( pHeader->IsUnused() )
        {
            fCleanup = TRUE;
        }
        else if ( pHeader->IsCorrupted() )
        {
            fCleanup = TRUE;
        }
        else
        {
            //
            // Active instance, no need to continue.
            //

            break;
        }

        if ( fCleanup )
        {
            pHeader->ResetCtrBeginMask();

            _ASSERTE ( NULL != m_SMCtrl.CounterDef() );

            if ( NULL != m_SMCtrl.CounterDef() )
            {
                ::ZeroMemory( (PVOID)pHeader->CounterDataStart(),
                    m_SMCtrl.CounterDef()->CountersInstanceDataSize() );
            }

            pHeader->SetInstanceName(L"");
            pHeader->MarkDataEnd();
        }
    }


Exit:

    return hRes;
}


/***********************************************************************++

Routine Description:

    Function verifies all the shared memory.

Arguments:

    None.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::VerifySM(
    )
{
    DWORD dwSMID;
    DWORD dwStateBeforeLocking = 0;
    BOOL  fLocked = FALSE;

    HRESULT hRes = E_FAIL;

    if ( SM_MANAGER != m_fAccessorType )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    hRes = LockSM ( SMMANAGER_STATE_VERIFYINGSM, &dwStateBeforeLocking );

    _ASSERTE ( SUCCEEDED(hRes) );

    fLocked = TRUE;

    for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
    {
        hRes = VerifyInstances ( dwSMID, TRUE, TRUE );

        if ( FAILED(hRes) )
        {
            hRes = E_FAIL;
            goto Exit;
        }
    }


Exit:

    if ( fLocked )
    {
        HRESULT h = UnlockSM ( dwStateBeforeLocking );
        UNREFERENCED_PARAMETER( h );
        _ASSERTE ( SUCCEEDED(h) );
    }

    return hRes;
}



/***********************************************************************++

Routine Description:

    Function expands the shared memory to accomodate more instances of
    performance counters. This function is normally called by the
    AddCounterInstance() method. The new size is GOLDEN_RATIO times
    larger.

Valid states on entry:

    SMMANAGER_STATE_ADDING_INSTANCE

Arguments:

    None.

Return Value:

    HRESULT

--***********************************************************************/

HRESULT
STDMETHODCALLTYPE
CSMManager::ExpandSM(
    double dExpansionCoeff
    )
{
    DWORD dwNewMaxInstances =
        (DWORD) ((double)m_SMCtrl.MaxInstances()*dExpansionCoeff + 0.5);
    DWORD dwOldMaxInstances = 0;

    HANDLE ahSMData = NULL;
    PVOID  apSMData = NULL;
    DWORD  dwSMID;
    DWORD  dwOldDataMapSize = 0;

    DWORD dwAccessBeforeLocking = 0;
    BOOL fLocked = FALSE;

    HRESULT hRes = E_FAIL;
    if ( SM_MANAGER != m_fAccessorType )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    if ( 0.0 >= dExpansionCoeff )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( !m_SMCtrl.IsState (
            SMMANAGER_STATE_ADDING_INSTANCE |
            SMMANAGER_STATE_DELETIING_INSTANCE
            ) )
    {
        hRes = E_FAIL;
        goto Exit;
    }


    hRes = LockSM ( SMMANAGER_STATE_EXPANDING, &dwAccessBeforeLocking );
    _ASSERTE ( SUCCEEDED(hRes) );

    fLocked = TRUE;

    //
    // Counters will be working off of the new MMFs so we need to
    // increment the instance version of SM. All SM accessors in all
    // processes will disconnect from the old MMFs and connect to the
    // new ones.
    //

    m_SMCtrl.IncrementVersion();

    // Set the object names of MMF object names
    hRes = SetSMObjNames(
                m_SMCtrl.ClassName(),
                m_SMCtrl.InstanceVersion()
                );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Store the new value of max instances
    //

    dwOldMaxInstances = m_SMCtrl.SetMaxInstances ( dwNewMaxInstances );

    //
    // m_dwSMCounterInstanceSize is already set but we need to calculate
    // new size of a map, m_dwSMDataMapSize
    //

    m_dwSMDataMapSize = m_dwSMCounterInstanceSize * dwNewMaxInstances;
    dwOldDataMapSize  = m_dwSMCounterInstanceSize * dwOldMaxInstances;

    //
    // Create new MMFs for the data blocks of each affinity and copy
    // the contents of the old ones to the beginning of the newly
    // created MMFs.
    //
    // Open and initialize the MMFs for each SM
    //

    for ( dwSMID = 0; dwSMID < m_SMCtrl.NumSMDataBlocks(); dwSMID++ )
    {
        hRes = m_SMCtrl.ConnectMMF(
                    m_aszSMDataObjName[dwSMID],
                    m_dwSMDataMapSize,
                    SM_MANAGER,
                    &ahSMData,
                    &apSMData
                    );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        hRes = InitSMData(apSMData);

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        //
        // Copy the contents of the old SM data block to the beginning
        // of the new one.
        //

        _ASSERTE ( NULL != m_apSMData[dwSMID] );
        _ASSERTE ( NULL != apSMData );

        ::memcpy ( apSMData, m_apSMData[dwSMID], dwOldDataMapSize );

        m_SMCtrl.DisconnectMMF ( &m_ahSMData[dwSMID], &m_apSMData[dwSMID] );

        m_ahSMData[dwSMID] = ahSMData;
        m_apSMData[dwSMID] = apSMData;
    }


Exit:

    if ( fLocked )
    {
        hRes = UnlockSM ( dwAccessBeforeLocking );
        _ASSERTE ( SUCCEEDED(hRes) );
    }

    if ( FAILED(hRes) )
    {
        Close ( FALSE );
    }

    return hRes;
}



/***********************************************************************++

    SMManager helper methods

--***********************************************************************/

PCWSTR
CSMManager::ClassName(
    )
    const
{
    if ( !m_SMCtrl.IsInitialized() )
        return NULL;
    return m_SMCtrl.ClassName();
}

SMACCESSOR_TYPE
CSMManager::AccessorType(
    )
    const
{
    return m_fAccessorType;
}


#ifdef _DEBUG

/***********************************************************************++
    For testers -- direct access to shared memory
--***********************************************************************/


PVOID
CSMManager::GetSMDataBlock(
    IN  DWORD dwSMID
    )
{
    if ( !m_SMCtrl.IsValidSMID(dwSMID) )
    {
        return NULL;
    }
    return (PVOID)m_apSMData[dwSMID];
}


PVOID
CSMManager::GetSMCtrlBlock(
    )
{
    return m_SMCtrl.GetSMCtrlBlock();
}


__declspec(dllexport)
PVOID
GetSMDataBlock(
    IN  DWORD dwSMID,
    IN  ISMManager * pISMManager
    )
{
    if ( NULL == pISMManager )
    {
        return NULL;
    }

    CSMManager * pSMManager = (CSMManager*)pISMManager;

    return pSMManager->GetSMDataBlock(dwSMID);
}


__declspec(dllexport)
PVOID
GetSMCtrlBlock(
    IN  ISMManager * pISMManager
    )
{
    if ( NULL == pISMManager )
    {
        return NULL;
    }

    CSMManager * pSMManager = (CSMManager*)pISMManager;

    return pSMManager->GetSMCtrlBlock();
}


#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\datasource.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    datasource.cxx

Abstract:

    This is implementation of CPerfDataSource.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

    cezarym   02-Jun-2000           Updated

--*/


#define _WIN32_DCOM
#include <windows.h>
#include <process.h>
#include <time.h>
#include <math.h>

#include "..\inc\counters.h"
#include "provider.h"
#include "datasource.h"


/***************************************************************************++

Routine Description:

    Constructor for the CPerfDataSource class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CPerfDataSource::CPerfDataSource(
    )
{

    m_alProperty = 0;
    m_pMgr = NULL;
    m_pCounterDef = NULL;
    m_pMgr = NULL;
    m_dwNumCounters = 0;
    m_aqwCounterValues = NULL;
    m_afCounterTypes = NULL;

}    // CPerfDataSource::CPerfDataSource



/***************************************************************************++

Routine Description:

    Destructor for the CPerfDataSource class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CPerfDataSource::~CPerfDataSource(
    )
{

    if ( NULL != m_alProperty )
        delete[] m_alProperty;

    if ( NULL != m_aqwCounterValues )
        delete[] m_aqwCounterValues;

    if ( NULL != m_afCounterTypes )
        delete[] m_afCounterTypes;

}    // CPerfDataSource::~CPerfDataSource



/***************************************************************************++

Routine Description:

    Initializes the data source.

    Set the access handles for the properties of the WMI objects.

Arguments:

    szClassName - name of the perf ctrs class
    pAccess     - a template of the class for which handles are required.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CPerfDataSource::Initialize(
    IN PCWSTR szClassName,
    IN IWbemObjectAccess* pAccess
    )
{
    HRESULT hRes = E_FAIL;
    DWORD dwIdx;

    if ( NULL == pAccess )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    hRes = ::CoInitializeEx(
                        NULL,
                        COINIT_MULTITHREADED     |
                        COINIT_DISABLE_OLE1DDE
                        );

    if ( FAILED(hRes) )
    {
        return hRes;
    }

    hRes = ::CoCreateInstance(
                __uuidof(CSMManager),
                NULL,
                CLSCTX_INPROC_SERVER,
                __uuidof(ISMManager),
                (PVOID*)&m_pMgr
                );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    if ( m_pMgr->IsSMLocked() )
    {
        m_pMgr->Close ( TRUE );
    }

    hRes = m_pMgr->Open ( szClassName, COUNTER_READER );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Get the definition of the counters
    //

    hRes = m_pMgr->GetCountersDef ( &m_pCounterDef );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Get the definition of the counters
    //

    m_dwNumCounters = m_pCounterDef->NumCounters();

    if ( NULL == m_alProperty )
    {
        m_alProperty = new LONG[m_dwNumCounters];
        ::ZeroMemory ( m_alProperty, sizeof(LONG) * m_dwNumCounters );

        m_aqwCounterValues = new QWORD[m_dwNumCounters];
        ::ZeroMemory ( m_aqwCounterValues, sizeof(QWORD) * m_dwNumCounters );

        m_afCounterTypes = new DWORD[m_dwNumCounters];
        ::ZeroMemory ( m_afCounterTypes, sizeof(DWORD) * m_dwNumCounters );
    }

    //
    // Set the counter handles -- we don't want to operate on the
    // counter names...
    //

    for ( dwIdx=0; dwIdx < m_dwNumCounters; dwIdx++)
    {
        CCounterInfo const * pCtrInfo = m_pCounterDef->GetCounterInfo(dwIdx);

        _ASSERTE ( pCtrInfo != NULL );

        m_afCounterTypes[dwIdx] = pCtrInfo->CounterSize();

        hRes = pAccess->GetPropertyHandle(
                            pCtrInfo->CounterName(),
                            NULL,
                            &m_alProperty[dwIdx]
                            );
        if ( FAILED(hRes) )
        {
            goto Exit;
        }
    }


Exit:

    if ( FAILED(hRes) )
    {
        m_pCounterDef = NULL;
        m_dwNumCounters = 0;

        delete[] m_alProperty;
        m_alProperty = NULL;

        delete[] m_aqwCounterValues;
        m_aqwCounterValues = NULL;

        delete[] m_afCounterTypes;
        m_afCounterTypes = NULL;

        if ( !!m_pMgr )
        {
            m_pMgr = NULL;
        }

        ::CoUninitialize();
    }

    return hRes;

}    // CPerfDataSource::Initialize



/***************************************************************************++

Routine Description:

    Updates a given instance with the counter values from SM.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CPerfDataSource::UpdateInstance(
    IWbemObjectAccess * pAccess
    )
{
    HRESULT hRes = WBEM_E_INVALID_PARAMETER;

    _ASSERTE ( NULL != m_pCounterDef );
    _ASSERTE ( NULL != m_aqwCounterValues );
    _ASSERTE ( NULL != m_afCounterTypes );

    DWORD dwID = 0;
    DWORD dwCntrIdx;

    BOOL  fReadValues = TRUE;

    if ( NULL == pAccess || NULL == m_pCounterDef )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

	hRes = pAccess->ReadDWORD ( g_hID, &dwID );
	if ( FAILED(hRes) )
    {
        goto Exit;
    }

    if ( m_pMgr->IsSMLocked() )
    {
        m_pMgr->Close ( TRUE );
        if ( FAILED(m_pMgr->Open ( m_pMgr->ClassName(), COUNTER_READER )) )
            fReadValues = FALSE;
    }

    if ( fReadValues )
    {
        //
        // Get the counter values for this instance
        //

        m_pMgr->GetCounterValues ( dwID, m_aqwCounterValues );
    }

    for ( dwCntrIdx = 0;
          dwCntrIdx < m_dwNumCounters;
          dwCntrIdx++ )
    {
        switch ( m_afCounterTypes[dwCntrIdx] )
        {
            case sizeof(DWORD):
                pAccess->WriteDWORD(
                            m_alProperty[dwCntrIdx],
                            (DWORD)m_aqwCounterValues[dwCntrIdx]
                            );
                break;

            case sizeof(QWORD):
                pAccess->WriteQWORD(
                            m_alProperty[dwCntrIdx],
                            m_aqwCounterValues[dwCntrIdx]
                            );
                break;

            default:
                break;
        };
    }


Exit:

    return hRes;

}    // CPerfDataSource::UpdateInstance
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\factory.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    factory.cxx

Abstract:

    This is implementation of standard class factory for
    the WMI highperf provider.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>

#include "..\inc\counters.h"
#include "provider.h"
#include "factory.h"

extern LONG g_lObjects;
extern LONG g_lLocks;



/***************************************************************************++

Routine Description:

    Constructor for the CPerfClassFactory class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CPerfClassFactory::CPerfClassFactory(
    )
{
    m_RefCount = 1;

}   // CPerfClassFactory::CPerfClassFactory



/***************************************************************************++

Routine Description:

    Destructor for the CPerfClassFactory class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CPerfClassFactory::~CPerfClassFactory(
    )
{
    _ASSERTE( m_RefCount == 0 );

}   // CPerfClassFactory::~CPerfClassFactory



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CPerfClassFactory::QueryInterface(
    REFIID iid,
    PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;

    _ASSERTE( ppObject != NULL );

    if ( ppObject == NULL )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( iid == IID_IUnknown )
    {
        *ppObject = (PVOID)(IUnknown*) this;
    }
    else if ( iid == IID_IClassFactory )
    {
        *ppObject = (PVOID)(IClassFactory*) this;
    }
    else
    {
        *ppObject = NULL;
        hRes = E_NOINTERFACE;

        goto Exit;
    }

    AddRef();


Exit:

    return hRes;

}   // CPerfClassFactory::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CPerfClassFactory::AddRef(
    )
{
    LONG lNewCount = InterlockedIncrement( &m_RefCount );

    _ASSERTE( lNewCount > 1 );

    return ( ( ULONG ) lNewCount );

}   // CPerfClassFactory::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CPerfClassFactory::Release(
    )
{
    LONG lNewCount = InterlockedDecrement( &m_RefCount );

    _ASSERTE( lNewCount >= 0 );

    if ( lNewCount == 0 )
    {
        delete this;
    }

    return ( ( ULONG ) lNewCount );

}   // CPerfClassFactory::Release



/***************************************************************************++

Routine Description:

    Standard IClassFactory::CreateInstance()

Arguments:

    pUnknownOuter - pointer to the controlling IUnknown interface of the
        aggregate ff the object is being created as part of an aggregate,
        otherwise, pUnkOuter must be NULL.

    iid - Reference to the identifier of the interface to be used to
        communicate with the newly created object. If pUnkOuter is NULL,
        this parameter is frequently the IID of the initializing interface;
        if pUnkOuter is non-NULL, iid must be IID_IUnknown (defined in the
        header as the IID for IUnknown). 

    ppObject - Address of pointer variable that receives the interface
        pointer requested in iid. Upon successful return, *ppObject
        contains the requested interface pointer. If the object does not
        support the interface specified in iid, the implementation sets
        *ppObject to NULL.

Return Value:

    HRESULT -- standard return values E_UNEXPECTED, E_OUTOFMEMORY, and
        E_INVALIDARG, as well as the following: 

        S_OK -- the specified object was created.

        CLASS_E_NOAGGREGATION -- the pUnkOuter parameter was non-NULL and
            the object does not support aggregation. 

        E_NOINTERFACE -- the object that ppObject points to does not support
            the interface identified by iid. 

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CPerfClassFactory::CreateInstance(
    IN IUnknown * pUnknownOuter, 
    IN REFIID iid, 
    OUT PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;
    CHiPerfProvider * pProvider = NULL;

    *ppObject = NULL;

    if ( ppObject == NULL )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( pUnknownOuter )
    {
        //
        // We do not support aggregation
        //
        hRes = CLASS_E_NOAGGREGATION;

        pUnknownOuter->Release();
        pUnknownOuter = NULL;

        goto Exit;
    }

    pProvider = new CHiPerfProvider;

    if ( !pProvider )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Retrieve the requested interface
    //

    hRes = pProvider->QueryInterface(iid, ppObject);
    if ( FAILED ( hRes ) )
    {
        pProvider->Release();
        goto Exit;
    }

    pProvider->Release();


Exit:

    return hRes;

}   // CPerfClassFactory::CreateInstance



/***************************************************************************++

Routine Description:

    Standard IClassFactory::LockServer()

Arguments:

    fLock - If TRUE, the function increments the lock count;
        if FALSE, decrements.

Return Value:

    HRESULT -- standard return values E_FAIL, E_OUTOFMEMORY, and E_UNEXPECTED,
        as well as the following: 
        S_OK -- the specified object was either locked ( fLock = TRUE) or
            unlocked from memory ( fLock = FALSE).

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CPerfClassFactory::LockServer(
    IN BOOL fLock
    )
{
    HRESULT hRes = S_OK;

    LONG lNewCount;

    if ( fLock )
    {
        lNewCount = InterlockedIncrement(&g_lLocks);

        _ASSERTE( lNewCount > 0 );

        if ( lNewCount <= 0 )
            hRes = E_UNEXPECTED;
    }
    else
    {
        lNewCount = InterlockedDecrement(&g_lLocks);

        _ASSERTE( lNewCount >= 0 );

        if ( lNewCount < 0 )
        {
            hRes = E_UNEXPECTED;
        }
    }   

    return hRes;

}   // CPerfClassFactory::LockServer(
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\datasource.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    datasource.h

Abstract:

    This is definition of the CPerfDataSource class.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/



#ifndef _datasource_h__
#define _datasource_h__


#include "..\inc\counters.h"



class CPerfDataSource
{
public:

    CPerfDataSource();
    ~CPerfDataSource();

    HRESULT
    STDMETHODCALLTYPE
    Initialize(
        IN PCWSTR szClassName,
        IN IWbemObjectAccess* pAccess
        );

    HRESULT
    STDMETHODCALLTYPE
    UpdateInstance(
        IWbemObjectAccess* pAccess
        );

    //
    // Helper functions
    //

    DWORD
    GetNumCounters(
        )
        const
    {
        return m_dwNumCounters;
    }

    ICounterDef const *
    GetCountersDefinition(
        )
        const
    {
        return m_pCounterDef;
    }

    DWORD
    GetMaxInstances(
        )
        const
    {
        _ASSERTE ( NULL != m_pCounterDef );

        if ( NULL != m_pCounterDef )
            return m_pCounterDef->MaxInstances();
        return 0;
    }

    CSMInstanceDataHeader const *
    GetInstanceDataHeader(
        IN  DWORD dwObjectInstance
        )
        const
    {
        CSMInstanceDataHeader * pInstanceDataHeader = NULL;
        _ASSERTE ( !!m_pMgr );

        if ( !m_pMgr ||
             FAILED (m_pMgr->InstanceDataHeader(
                                    0,
                                    dwObjectInstance,
                                    &pInstanceDataHeader
                                    ))
            )
            return 0;
        return pInstanceDataHeader;
    }

protected:

    LONG * m_alProperty; // array of [NumCounters]

    CComPtr<ISMManager>   m_pMgr;
    ICounterDef const *   m_pCounterDef;
    DWORD                 m_dwNumCounters;
    QWORD *               m_aqwCounterValues;
    DWORD *               m_afCounterTypes;
};


#endif // _datasource_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\inc\serverimp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    serverimp.h

Abstract:

    Generic COM server code implementation.

    Define the following before including this file (replace ....'s):

#define IMPLEMENTED_CLSID           __uuidof(....)
#define SERVER_REGISTRY_COMMENT     L"...."
#define CLASSFACTORY_CLASS          ....

    You have to include a DEF file that includes at least this:

LIBRARY			.....dll
EXPORTS
    DllRegisterServer	@1 PRIVATE
    DllUnregisterServer	@2 PRIVATE
    DllGetClassObject	@3 PRIVATE
    DllCanUnloadNow	    @4 PRIVATE


Author:

    Cezary Marcjan (cezarym)        05-Apr-2000

Revision History:

--*/


#pragma once


#include <stdio.h>


LONG g_lObjects = 0;
LONG g_lLocks = 0;
HMODULE g_hInstance = NULL;



/***********************************************************************++

Routine Description:

    The dll entry point. Used to set up debug libraries, etc.

Arguments:

    hDll - The dll module handle for this dll. Does not need to be
    closed.

    dwReason  - The dll notification reason.

    pReserved - Reserved, not used.

Return Value:

    BOOL

--***********************************************************************/

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID pReserved
    )
{
    HRESULT hRes = S_OK;
    BOOL fSuccess = TRUE;

    UNREFERENCED_PARAMETER( pReserved );


    switch ( dwReason )
    {

    case DLL_PROCESS_ATTACH:

        g_hInstance = hDll;

        fSuccess = DisableThreadLibraryCalls( hDll );

        if ( !fSuccess )
        {
            hRes = HRESULT_FROM_WIN32( GetLastError() );
            goto exit;
        }

        break;

    case DLL_PROCESS_DETACH:

        break;

    default:

        break;

    }


exit:

    return SUCCEEDED ( hRes );

}   // ::DllMain



/***********************************************************************++

Routine Description:

    Standard COM In-Process Server entry point to return a class factory
    instance.

Arguments:

    rclsid - CLSID that will associate the correct data and code. 

    riid   - Reference to the identifier of the interface that the caller
             is to use to communicate with the class object. Usually,
             this is IID_IClassFactory (defined in the COM headers as the
             interface identifier for IClassFactory).

    ppv    - Address of pointer variable that receives the interface
             pointer requested in riid. Upon successful return, *ppv
             contains the requested interface pointer. If an error occurs,
             the interface pointer is NULL.

Return Value:

    S_OK                Success
    E_NOINTERFACE       Other than IClassFactory interface was asked for
    E_OUTOFMEMORY
    E_FAILED            Initialization failed

--***********************************************************************/

STDAPI
DllGetClassObject(
    IN  REFCLSID rclsid,
    IN  REFIID riid,
    OUT PVOID * ppv
    )
{
    CLASSFACTORY_CLASS * pClassFactory;

    HRESULT hRes = S_OK;

    //
    //  Verify the caller is asking for our type of object
    //

    if ( IMPLEMENTED_CLSID != rclsid) 
    {
        hRes = CLASS_E_CLASSNOTAVAILABLE;
        goto exit;
    }

    //
    // Create the class factory
    //

    pClassFactory = new CLASSFACTORY_CLASS;

    if ( !pClassFactory )
    {
        hRes = E_OUTOFMEMORY;
        goto exit;
    }
    
    hRes = pClassFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes) )
    {
        pClassFactory->Release();
        goto exit;
    }

    pClassFactory->Release();


exit:

    return hRes;
}



/***********************************************************************++

Routine Description:

    Standard COM entry point for server shutdown request. Allows shutdown
    only if no outstanding objects or locks are present.

Arguments:

    None.

Return Value:

    S_OK     - May unload now.
    S_FALSE  - May not.

--***********************************************************************/

STDAPI
DllCanUnloadNow(
    )
{
    HRESULT hRes = S_FALSE;

    if ( 0 == g_lLocks && 0 == g_lObjects )
        hRes = S_OK;

    return hRes;
}



/***********************************************************************++

Routine Description:

    Standard COM entry point for registering the server.

Arguments:

    None.

Return Value:

    S_OK        Registration was successful
    E_FAIL      Registration failed.

--***********************************************************************/

STDAPI
DllRegisterServer(
    )
{
    WCHAR szPath[MAX_PATH];
    WCHAR * pGuidStr = 0;
    WCHAR szKeyPath[MAX_PATH];

    //
    // Get the dll's filename
    //

    GetModuleFileNameW(g_hInstance, szPath, MAX_PATH);

    //
    // Convert CLSID to string.
    //

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(szKeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    //
    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    //

    HKEY hKey;

    HRESULT hRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, szKeyPath, &hKey);
    if ( FAILED(hRes) )
    {
        hRes = E_FAIL;
    }
    else
    {
        WCHAR * szName = SERVER_REGISTRY_COMMENT; 
        RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) szName, wcslen(szName) * 2 + 2);

        HKEY hSubkey;

        hRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);
        if ( FAILED(hRes) )
        {
            hRes = E_FAIL;
        }
        else
        {
            RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) szPath, wcslen(szPath) * 2 + 2);
            RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

            RegCloseKey(hSubkey);
        }

        RegCloseKey(hKey);
    }

    CoTaskMemFree(pGuidStr);

    return hRes;
}

/***********************************************************************++

Routine Description:

    Standard COM entry point for unregistering the server.

Arguments:

    None.

Return Value:

    S_OK        Unregistration was successful
    E_FAIL      Unregistration failed.

--***********************************************************************/

STDAPI
DllUnregisterServer(
    )
{
    WCHAR * pGuidStr = 0;
    HKEY hKey;
    WCHAR szKeyPath[MAX_PATH];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(szKeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    //
    // Delete InProcServer32 subkey.
    //

    HRESULT hRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, szKeyPath, &hKey);
    if ( FAILED(hRes) )
    {
        hRes = E_FAIL;
    }
    else
    {
        RegDeleteKeyW(hKey, L"InprocServer32");
        RegCloseKey(hKey);

        //
        // Delete CLSID GUID key.
        //

        hRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
        if ( FAILED(hRes) )
        {
            hRes = E_FAIL;
        }
        else
        {
            RegDeleteKeyW(hKey, pGuidStr);
            RegCloseKey(hKey);
        }
    }

    CoTaskMemFree(pGuidStr);

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\iissmm\smmgr.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    smmgr.h

Abstract:

    This is definition of classes for generic shared memory
    manager (SM) used for IIS performance counters

Author:

    Cezary Marcjan (cezarym)        06-Mar-2000

Revision History:

--*/


#ifndef _smmgr_h__
#define _smmgr_h__


#define UNUSED_MASK_VALUE      0xAABBAABB
#define DATA_END_MASK_VALUE    0xEDEDEDED
#define CTRBEGIN_MASK_VALUE    0xBEBEBEBE


#include <cguid.h>
#include <Atlbase.h>
#include "smctrl.h"



/***********************************************************************++

class CSMInstanceDataHeader

    This class is used for direct mapping of the counter instance data 
    of the MMF data block.

    It is used in SMManager by casting a proper region of shared memory
    to this class pointer.

--***********************************************************************/

class CSMInstanceDataHeader
{
protected:

    WCHAR m_szInstanceName[MAX_NAME_CHARS];
    DWORD m_dwCtrBeginMask;

public:

    //
    // Read-only methods:
    //

    PCWSTR
    InstanceName(
        )
        const
    {
        return m_szInstanceName;
    }


    DWORD
    Mask(
        )
        const
    {
        return m_dwCtrBeginMask;
    }


    BOOL
    IsUnused(
        )
        const
    {
        return UNUSED_MASK_VALUE == *(DWORD*)this;
    }


    BOOL
    IsEnd(
        )
        const
    {
        return DATA_END_MASK_VALUE == *(DWORD*)this;
    }


    BOOL
    IsCorrupted(
        )
        const
    {
        return m_dwCtrBeginMask != CTRBEGIN_MASK_VALUE;
    }


    PBYTE
    CounterDataStart(
        )
        const
    {
        return (PBYTE) &(&m_dwCtrBeginMask)[1];
    }


    //
    // Read/Write methods:
    //

    VOID
    InitializeMasks(
        )
    {
        ResetCtrBeginMask();
        MarkDataEnd();
    }


    VOID
    ResetCtrBeginMask(
        )
    {
        ::InterlockedExchange(
            (PLONG)&m_dwCtrBeginMask,
            CTRBEGIN_MASK_VALUE );
    }


    VOID
    MarkDataEnd(
        )
    {
         // NOTE: this mask is ALWAYS 32bit
        ::InterlockedExchange( (PLONG)this, DATA_END_MASK_VALUE );
    }


    VOID
    MarkInstanceUnused(
        )
    {
         // NOTE: this mask is ALWAYS 32bit
        ::InterlockedExchange( (PLONG)this, UNUSED_MASK_VALUE );
    }


    VOID
    SetInstanceName(
        PCWSTR szNewName
        )
    {
        if ( NULL == szNewName )
        {
            szNewName = L"_UNKNOWN_";
        }
        ::ZeroMemory(m_szInstanceName,sizeof(m_szInstanceName));
        ::wcsncpy(m_szInstanceName, szNewName, MAX_NAME_CHARS-1);
    }
};



/***********************************************************************++

    Interfaces of the SMManager object

    ISMDataAccess
    ISMManager

--***********************************************************************/



interface
__declspec(uuid("FB75ABA8-DAB3-4c9d-8506-3A550D989EDB"))
__declspec(novtable)
ISMDataAccess
    : public IUnknown
{
    virtual
    HRESULT
    STDMETHODCALLTYPE
    Open(
        IN  PCWSTR              szCountersClassName,
        IN  SMACCESSOR_TYPE     fAccessorType,
        IN  ICounterDef const * pCounterDef = NULL  // set if SMManager
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    Close(
        BOOL fDisconnectSMCtrl
        ) = 0;

    virtual
    BOOL
    STDMETHODCALLTYPE
    IsSMLocked(
        ) = 0;

    virtual
    DWORD
    STDMETHODCALLTYPE
    NumSMDataBlocks(
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetCountersDef(
        ICounterDef const ** ppCounterDef
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetCounterValues(
        IN  DWORD   dwInstanceIdx,
        OUT QWORD * pqwCounterValues
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetSMID(
        OUT DWORD * pdwSMID
        ) = 0;
};



interface
__declspec(uuid("F727FFD5-19FB-4c72-80B1-E783CC0F68B3"))
__declspec(novtable)
ISMManager
    : public ISMDataAccess
{
    virtual
    HRESULT
    STDMETHODCALLTYPE
    AddCounterInstance(
        PCWSTR szInstanceName
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    DelCounterInstance(
        PCWSTR szInstanceName
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    VerifySM(
        ) = 0;

    //
    // Helper methods:
    //

    virtual
    PCWSTR
    ClassName(
        )
        const = 0;

    virtual
    SMACCESSOR_TYPE
    AccessorType(
        )
        const = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    InstanceDataHeader(
        IN  DWORD   dwSMID,
        IN  PCWSTR  szInstanceName,
        OUT DWORD * pdwInstanceIdx,
        OUT CSMInstanceDataHeader** ppInstanceDataHeader
        ) = 0;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    InstanceDataHeader(
        IN  DWORD dwSMID,
        IN  DWORD dwInstanceIdx,
        OUT CSMInstanceDataHeader** ppInstanceDataHeader
        ) = 0;
};



/***********************************************************************++

class CSMManager

    Class implements the inproc COM server of the SMManager.

    Implemented interfaces:

    ISMDataAccess
    ISMManager
    IUnknown

--***********************************************************************/

class
__declspec(uuid("4D1F853C-6168-4802-93EA-FC0C22D0321D"))
CSMManager
    : public ISMManager
{

public:

    CSMManager();
    ~CSMManager();

    //
    // IUnknown methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    //
    // ISMDataAccess methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    Open(
        IN  PCWSTR              szCountersClassName,
        IN  SMACCESSOR_TYPE     fAccessorType,
        IN  ICounterDef const * pCounterDef = NULL  // set if SMManager
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    Close(
        BOOL fDisconnectSMCtrl
        );

    virtual
    BOOL
    STDMETHODCALLTYPE
    IsSMLocked(
        );

    virtual
    DWORD
    STDMETHODCALLTYPE
    NumSMDataBlocks(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetCountersDef(
        ICounterDef const ** ppCounterDef
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetCounterValues(
        IN  DWORD   dwInstanceIdx,
        OUT QWORD * pqwCounterValues
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetSMID(
        OUT DWORD * pdwSMID
        );

    //
    // ISMManager methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    AddCounterInstance(
        IN  PCWSTR szInstanceName
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    DelCounterInstance(
        IN  PCWSTR szInstanceName
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    VerifySM(
        );

    virtual
    PCWSTR
    ClassName(
        )
        const;

    virtual
    SMACCESSOR_TYPE
    AccessorType(
        )
        const;

    virtual
    HRESULT
    STDMETHODCALLTYPE
    InstanceDataHeader(
        IN  DWORD   dwSMID,
        IN  PCWSTR  szInstanceName,
        OUT DWORD * pdwInstanceIdx,
        OUT CSMInstanceDataHeader** ppInstanceDataHeader
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    InstanceDataHeader(
        IN  DWORD dwSMID,
        IN  DWORD dwInstanceIdx,
        OUT CSMInstanceDataHeader** ppInstanceDataHeader
        );


protected:

    //
    // Internal functions
    //

    HRESULT
    STDMETHODCALLTYPE
    SetSMObjNames(
        IN  PCWSTR   szCountersClassName,
        IN  DWORD    dwSMInstanceVersion
        );

    HRESULT
    STDMETHODCALLTYPE
    InitSMData(
        IN OUT PVOID pSMDataBlock
        );

    HRESULT
    STDMETHODCALLTYPE
    ExpandSM(
        double dExpansionCoeff
        );

    HRESULT
    STDMETHODCALLTYPE
    LockSM(
        IN  DWORD dwNewState,
        OUT DWORD * pdwPreviousState = 0
        );

    HRESULT
    STDMETHODCALLTYPE
    UnlockSM(
        IN  DWORD fAccessFlagValueBeforeLocking
        );

    HRESULT
    STDMETHODCALLTYPE
    VerifyInstances(
        DWORD dwSMID,
        BOOL fVerifyFromBeginning,
        BOOL fVerifyFromEnd
        );

    //
    // Member variables
    //

    CSMCtrl          m_SMCtrl;

    LONG             m_RefCount;

    SMACCESSOR_TYPE  m_fAccessorType;

    DWORD            m_dwSMID;

    DWORD            m_dwSystemAffinityMask;

    //
    // SM Data blocks access/info
    //

    HANDLE m_ahSMData[MAX_CPUS+1]; // file maping handles SMs
    PVOID  m_apSMData[MAX_CPUS+1]; // View of the SM data for all SMs

    DWORD  m_dwSMDataMapSize;
    DWORD  m_dwSMCounterInstanceSize;

    // SM Data mapped object names
    PWSTR  m_aszSMDataObjName[MAX_CPUS+1];

    //
    // SM Locking
    //

    DWORD  m_dwCurrentSMInstanceVersion;

    friend class CCounterDef_IISCtrs;


#ifdef _DEBUG

    /*******************************************************************++
        For testers -- direct access to shared memory
    --*******************************************************************/

    public:

    PVOID
    GetSMDataBlock(
        IN  DWORD dwSMID
        );

    PVOID
    GetSMCtrlBlock(
        );

#endif // _DEBUG

};


#ifdef _DEBUG

/*******************************************************************++
    For testers -- direct access to shared memory
--*******************************************************************/

__declspec(dllexport)
PVOID
GetSMDataBlock(
    IN  DWORD dwSMID,
    IN  ISMManager * pISMManager
    );


__declspec(dllexport)
PVOID
GetSMCtrlBlock(
    IN  ISMManager * pISMManager
    );

#endif // _DEBUG


#endif // _smmgr_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\inc\perfdbg.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perfdbg.h

Abstract:

    These are definitions of debug utilities.

Author:

    Cezary Marcjan (cezarym)        03-Mar-2000

Revision History:

--*/


#ifndef _perfdbg_h__
#define _perfdbg_h__


#if defined( DEBUG ) || defined( _DEBUG )
#define DBG 1
#endif

#define _DBGUTIL_H_

#ifndef DEFAULT_OUTPUT_FLAGS
#define DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )
#endif//DEFAULT_OUTPUT_FLAGS

#include <comdef.h>
#include <pudebug.h>

//
// wide char implementation of stuff in pudebug.h
//

#ifdef DBG

# define DBG_WCONTEXT  DBG_CONTEXT


#define PERFDBG_ERROR1          0x00001000
#define PERFDBG_ERROR2          0x00002000
#define PERFDBG_ERROR3          0x00004000
#define PERFDBG_ERROR4          0x00008000

#define PERFDBG_WARNING1        0x00010000
#define PERFDBG_WARNING2        0x00020000
#define PERFDBG_WARNING3        0x00040000
#define PERFDBG_WARNING4        0x00080000

#define PERFDBG_REF_COUNTING1   0x00100000
#define PERFDBG_REF_COUNTING2   0x00200000
#define PERFDBG_REF_COUNTING3   0x00400000
#define PERFDBG_REF_COUNTING4   0x00800000

#define PERFDBG_FUNCTION_SCOPE1 0x01000000
#define PERFDBG_FUNCTION_SCOPE2 0x02000000
#define PERFDBG_FUNCTION_SCOPE3 0x04000000
#define PERFDBG_FUNCTION_SCOPE4 0x08000000

#define PERFDBG_MESSAGE1        0x10000000
#define PERFDBG_MESSAGE2        0x20000000
#define PERFDBG_MESSAGE3        0x40000000
#define PERFDBG_MESSAGE4        0x80000000


extern DWORD g_dwDbgPrintFlags;


#define DBGMSG_E1( args ) \
    if ( ( PERFDBG_ERROR1 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrintError args ; } \

#define DBGMSG_E2( args ) \
    if ( ( PERFDBG_ERROR2 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrintError args ; } \

#define DBGMSG_E3( args ) \
    if ( ( PERFDBG_ERROR3 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrintError args ; } \

#define DBGMSG_E4( args ) \
    if ( ( PERFDBG_ERROR4 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrintError args ; } \


#define DBGMSG_W1( args ) \
    if ( ( PERFDBG_WARNING1 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_W2( args ) \
    if ( ( PERFDBG_WARNING2 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_W3( args ) \
    if ( ( PERFDBG_WARNING3& g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_W4( args ) \
    if ( ( PERFDBG_WARNING4 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \


#define DBGMSG_RC1( args ) \
    if ( ( PERFDBG_REF_COUNTING1 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_RC2( args ) \
    if ( ( PERFDBG_REF_COUNTING2 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_RC3( args ) \
    if ( ( PERFDBG_REF_COUNTING3 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_RC4( args ) \
    if ( ( PERFDBG_REF_COUNTING4 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \


# define DBGMSG_FS1( args ) \
    if ( ( PERFDBG_FUNCTION_SCOPE1 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_FS2( args ) \
    if ( ( PERFDBG_FUNCTION_SCOPE2 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_FS3( args ) \
    if ( ( PERFDBG_FUNCTION_SCOPE3 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG_FS4( args ) \
    if ( ( PERFDBG_FUNCTION_SCOPE4 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \


#define DBGMSG1( args ) \
    if ( ( PERFDBG_MESSAGE1 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG2( args ) \
    if ( ( PERFDBG_MESSAGE2 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG3( args ) \
    if ( ( PERFDBG_MESSAGE3 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \

#define DBGMSG4( args ) \
    if ( ( PERFDBG_MESSAGE4 & g_dwDbgPrintFlags ) != 0 ) \
        { PuDbgPrint args ; } \



#else // DBG


#define DECLARE_DEBUG_PRINT_FLAGS ( args ) ((void)0)

#define DBGMSG_E1( args ) ((void)0)
#define DBGMSG_E2( args ) ((void)0)
#define DBGMSG_E3( args ) ((void)0)
#define DBGMSG_E4( args ) ((void)0)

#define DBGMSG_W1( args ) ((void)0)
#define DBGMSG_W2( args ) ((void)0)
#define DBGMSG_W3( args ) ((void)0)
#define DBGMSG_W4( args ) ((void)0)

#define DBGMSG_RC1( args ) ((void)0)
#define DBGMSG_RC2( args ) ((void)0)
#define DBGMSG_RC3( args ) ((void)0)
#define DBGMSG_RC4( args ) ((void)0)

#define DBGMSG_FS1( args ) ((void)0)
#define DBGMSG_FS2( args ) ((void)0)
#define DBGMSG_FS3( args ) ((void)0)
#define DBGMSG_FS4( args ) ((void)0)

#define DBGMSG1( args ) ((void)0)
#define DBGMSG2( args ) ((void)0)
#define DBGMSG3( args ) ((void)0)
#define DBGMSG4( args ) ((void)0)


#endif //  // DBG


#endif // _perfdbg_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\inc\counters.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    counters.h

Abstract:

    This is definition of classes for generic perf counters
    shared memory (SM) shared memory access and manipulation.

Author:

    Cezary Marcjan (cezarym)        03-Mar-2000

Revision History:

    cezarym     24-May-2000
        Added Win64 support for 64bit counters

    cezarym     02-Jun-2000     Minor updates

--*/


#ifndef _counters_h__
#define _counters_h__

#ifndef _WIN32_DCOM
#error Define _WIN32_DCOM before including windows.h and counters.h
#endif//_WIN32_DCOM

#include "..\iissmm\smmgr.h"


class CDWORDCounterWriter;
class CQWORDCounterWriter;



/***********************************************************************++

    Main counter access class

--***********************************************************************/

class CCounterDef_IISCtrs 
{

public:

    CCounterDef_IISCtrs(
        );

    ~CCounterDef_IISCtrs(
        );


    HRESULT
    STDMETHODCALLTYPE
    Initialize(
        IN  PCWSTR           szClassName,
        IN  SMACCESSOR_TYPE  fAccessorType
        );


    BOOL
    IsInitialized(
        )
        const;


    HRESULT
    STDMETHODCALLTYPE
    Close(
        );


    //
    // Helper methods
    //

    ICounterDef const &
    CounterDef(
        ) const
    {
        return *(ICounterDef*)&m_CounterDef;
    }

    DWORD
    NumCounters(
        )
        const
    {
        return m_CounterDef.NumCounters();
    }

    DWORD
    NumRawCounters(
        )
        const
    {
        return m_CounterDef.NumRawCounters();
    }

    DWORD
    CountersInstanceDataSize(
        )
        const
    {
        return m_CounterDef.CountersInstanceDataSize();
    }

    CCounterInfo const *
    GetCounterInfo(
        DWORD dwCounterIdx
        )
        const
    {
        return m_CounterDef.GetCounterInfo ( dwCounterIdx );
    }

    DWORD
    RawCounterSize(
        DWORD dwRawCounterIdx
        )
        const
    {
        return m_CounterDef.RawCounterSize ( dwRawCounterIdx );
    }


protected:

    static
    VOID
    AddNewCounter(
        IN  PVOID          pCounter,
        IN  COUNTER_TYPE   fCounterType
        );


    HRESULT
    STDMETHODCALLTYPE
    ConnectData(
        IN      PCWSTR szInstanceName,
        IN OUT  PVOID * ppData
        );


    friend class CQWORDAccessorHelper;
    friend class CDWORDCounterReader;

protected:

    static WCHAR  m_szClassName[MAX_NAME_CHARS+1];

    static SMACCESSOR_TYPE  m_fAccessorType;

    static CCounterDef m_CounterDef;

    static PBYTE  m_pDataStart; // pointer to first counter

public:

    static CComPtr<ISMManager>  m_pSM;
};



/***********************************************************************++

  64-bit integer access helper class. It is important to use this class
  on the 32-bit platforms to avoid race conditions.

--***********************************************************************/


class CQWORDAccessorHelper
{

public:

    DWORD
    LoPart(
        )
        const
    {
        return * LoPartPtr();
    }


    DWORD
    HiPart(
        )
        const
    {
        return * HiPartPtr();
    }


    QWORD
    Set(
        IN  QWORD qwVal
        )
    {
        // this function doesn't have to be thread safe
        QWORD qwRet = m_qwCtr;
        m_qwCtr = qwVal;
        return qwRet;
    }


    QWORD
    InterlockedExchangeAdd64(
        IN  DWORD dwIncrement
        )
    {
#ifdef _WIN64
        return (QWORD)::_InterlockedExchangeAdd64(
                                    (__int64*)&m_qwCtr,
                                    (__int64)dwIncrement
                                    );
#else
        LARGE_INTEGER li;
        li.HighPart = HiPart();
        li.LowPart = LoPart();
        ::InterlockedExchangeAdd ( (PLONG)LoPartPtr(), dwIncrement );
        if ( LoPart() < li.LowPart )
        {
            li.HighPart++;
            InterlockedExchange ( (PLONG)HiPartPtr(), li.HighPart );
        }
        return li.QuadPart;
#endif//_WIN64
    }


    QWORD
    InterlockedExchangeAdd64(
        IN  CQWORDAccessorHelper* pIncrement
        )
    {
        // This is not called normally (only after initialization)
#ifdef _WIN64
        return (QWORD)::_InterlockedExchangeAdd64(
                                    (__int64*)&m_qwCtr,
                                    (__int64)pIncrement->m_qwCtr
                                    );
#else
        if ( NULL != pIncrement )
            m_qwCtr += pIncrement->m_qwCtr;
        return m_qwCtr;
#endif//_WIN64
    }


    QWORD
    InterlockedIncrement64(
        )
    {
#ifdef _WIN64
        return (QWORD)::_InterlockedIncrement64( (__int64*)&m_qwCtr );
#else
        LARGE_INTEGER li;
        li.HighPart = HiPart();
        li.LowPart = LoPart();
        ::InterlockedIncrement ( (PLONG)LoPartPtr() );
        if ( LoPart() < li.LowPart )
        {
            li.HighPart++;
            InterlockedExchange ( (PLONG)HiPartPtr(), li.HighPart );
        }
        return li.QuadPart;
#endif//_WIN64
    }


    QWORD
    InterlockedGetInt64(
        )
        const
    {
#ifdef _WIN64
        return m_qwCtr;
#else
        LARGE_INTEGER liTmp;
        liTmp.HighPart = HiPart();
        liTmp.LowPart = LoPart();
        if ( LoPart() < liTmp.LowPart )
            liTmp.HighPart++;
        return liTmp.QuadPart;
#endif//_WIN64
    }


protected:

    CQWORDAccessorHelper(
        )
    {
        m_qwCtr = 0;
        CCounterDef_IISCtrs::AddNewCounter ( this, QWORD_TYPE );
    }


    DWORD *
    LoPartPtr(
        )
        const
    {
        return (DWORD*)(PVOID)&m_qwCtr;
    }


    DWORD *
    HiPartPtr(
        )
        const
    {
        return ((DWORD*)(PVOID)&m_qwCtr) + 1;
    }

    QWORD m_qwCtr;
};
 


/***********************************************************************++

  CounterReader

--***********************************************************************/

class CDWORDCounterReader
{

public:

    DWORD
    GetValue(
        )
        const
    {
        return m_dwCtr;
    }


    operator
    DWORD(
        )
        const
    {
        return GetValue();
    }


protected:

    CDWORDCounterReader()
    {
        m_dwCtr = 0;
        CCounterDef_IISCtrs::AddNewCounter ( this, DWORD_TYPE );
    }

    DWORD m_dwCtr;
};



class CQWORDCounterReader
    : public CQWORDAccessorHelper
{

public:

    QWORD
    GetValue(
        )
        const
    {
        return InterlockedGetInt64();
    }


    operator
    QWORD(
        )
        const
    {
        return GetValue();
    }
};



/***********************************************************************++

  CounterWriter

--***********************************************************************/


class CDWORDCounterWriter
    : public CDWORDCounterReader
{

public:

    DWORD
    Increment(
        )
    {
        return ::InterlockedIncrement ( (PLONG) &m_dwCtr );
    }


    DWORD
    Decrement(
        )
    {
        return ::InterlockedDecrement ( (PLONG) &m_dwCtr );
    }


    DWORD
    Add(
        IN  LONG lVal
        )
    {
        return ::InterlockedExchangeAdd ( (PLONG) &m_dwCtr, lVal );
    }


    DWORD
    Set(
        IN  DWORD dwVal
        )
    {
        return ::InterlockedExchange ( (PLONG) &m_dwCtr, dwVal );
    }


    CDWORDCounterWriter&
    operator++(
        )
    {
        Increment();
        return *this;
    }


    CDWORDCounterWriter&
    operator++(
        int
        )
    {
        Increment();
        return *this;
    }


    CDWORDCounterWriter&
    operator+=(
        IN  LONG lVal
        )
    {
        Add(lVal);
        return *this;
    }


    CDWORDCounterWriter&
    operator--(
        )
    {
        Decrement();
        return *this;
    }


    CDWORDCounterWriter&
    operator--(
        int
        )
    {
        Decrement();
        return *this;
    }


    CDWORDCounterWriter&
    operator-=(
        IN  LONG lVal
        )
    {
        Add(-lVal);
        return *this;
    }
};



class CQWORDCounterWriter :
    public CQWORDCounterReader
{

public:

    QWORD
    Increment(
        )
    {
        return InterlockedIncrement64();
    }


    QWORD
    Add(
        IN  DWORD dwVal
        )
    {
        return InterlockedExchangeAdd64(dwVal);
    }


    CQWORDCounterWriter&
    operator++(
        )
    {
        Increment();
        return *this;
    }


    CQWORDCounterWriter&
    operator++(
        int
        )
    {
        Increment();
        return *this;
    }


    CQWORDCounterWriter&
    operator+=(
        IN  DWORD dwVal
        )
    {
        Add(dwVal);
        return *this;
    }
};



/***********************************************************************++

  Inline implementation

--***********************************************************************/


inline
CCounterDef_IISCtrs::CCounterDef_IISCtrs(
    )
{
    ::ZeroMemory ( m_szClassName, sizeof(m_szClassName) );
    m_fAccessorType = SM_ACC_UNKNOWN;
}


inline
BOOL
CCounterDef_IISCtrs::IsInitialized(
    )
    const
{
    return  NULL != m_CounterDef.m_aCounterInfo &&
            SM_ACC_UNKNOWN != m_fAccessorType;
}


inline
HRESULT
STDMETHODCALLTYPE
CCounterDef_IISCtrs::Initialize(
    IN  PCWSTR szClassName,
    IN  SMACCESSOR_TYPE fAccessorType
    )
{
    HRESULT hRes = E_FAIL;

    if ( SM_ACC_UNKNOWN == fAccessorType    ||
         NULL == szClassName                ||
         L'\0' == *szClassName
         )
        return E_INVALIDARG;

    if ( IsInitialized() )
        Close();

    _ASSERTE ( NULL != m_CounterDef.m_aRawCounterType );

    m_fAccessorType = fAccessorType;
    wcsncpy ( m_szClassName, szClassName, MAX_NAME_CHARS-1 );
    m_szClassName[MAX_NAME_CHARS-1] = L'\0';

    hRes = ::CoInitializeEx(
                NULL,
                COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE
                );
    _ASSERTE ( SUCCEEDED(hRes) );

    if ( !m_pSM && SUCCEEDED(hRes) )
        hRes = ::CoCreateInstance(
                    __uuidof(CSMManager),
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    __uuidof(ISMManager),
                    (PVOID*)&m_pSM
                    );

    if ( SUCCEEDED(hRes) )
        hRes = m_pSM->Open(
                        m_szClassName,
                        m_fAccessorType,
                        &m_CounterDef
                        );
    if ( FAILED(hRes) )
        Close();
    return hRes;
}


inline
CCounterDef_IISCtrs::~CCounterDef_IISCtrs(
    )
{
    if ( NULL != m_CounterDef.m_aRawCounterType )
    {
        delete[] m_CounterDef.m_aRawCounterType;
        m_CounterDef.m_aRawCounterType = NULL;
    }
}


inline
HRESULT
STDMETHODCALLTYPE
CCounterDef_IISCtrs::ConnectData(
    IN  PCWSTR szInstanceName,
    IN OUT PVOID * ppData
    )
{
    HRESULT hRes = S_OK;
    CSMInstanceDataHeader * pHeader = 0;
    DWORD dwSMID = 0;

    if ( !IsInitialized()       ||
         NULL == ppData         ||
         NULL == szInstanceName ||
         m_pSM->IsSMLocked()    ||
         FAILED ( m_pSM->GetSMID(&dwSMID) )
         )
    {
        hRes = E_FAIL;
        goto Exit;
    }

    *ppData = NULL;

    hRes = ((CSMManager*)(ISMManager*)m_pSM)->InstanceDataHeader(
                    dwSMID,
                    szInstanceName,
                    NULL, // NULL for SM version update
                    &pHeader
                    );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    *ppData = pHeader->CounterDataStart();


Exit:

    if ( FAILED(hRes) )
    {
        *ppData = this;
    }

    return hRes;
}


inline
HRESULT
STDMETHODCALLTYPE
CCounterDef_IISCtrs::Close(
    )
{
    if ( !!m_pSM )
    {
        m_pSM->Close ( TRUE );
    }
    m_fAccessorType = SM_ACC_UNKNOWN;
    ::ZeroMemory ( m_szClassName, sizeof(m_szClassName) );
    return S_OK;
}


inline
VOID
CCounterDef_IISCtrs::AddNewCounter(
    IN  PVOID          pCounter,
    IN  COUNTER_TYPE   fCounterType
    )
{
    if ( NULL != m_CounterDef.m_aCounterInfo )
    {
        // All counters were already added!
        return;
    }
    if ( 0 == m_CounterDef.m_dwNumRawCounters )
    {
        m_pDataStart = (PBYTE)pCounter;
        m_CounterDef.m_dwCountersInstanceDataSize = 0;
    }
    m_CounterDef.m_dwNumRawCounters++;
    m_CounterDef.m_dwCountersInstanceDataSize += fCounterType;

    if ( m_CounterDef.m_dwMaxRawNumCounters <
         m_CounterDef.m_dwNumRawCounters )
    {
        DWORD dwC = m_CounterDef.m_dwMaxRawNumCounters << 1;
        if ( 128 > dwC )
            dwC = 128;
        COUNTER_TYPE * aCT = new COUNTER_TYPE[dwC];
        _ASSERTE ( NULL != aCT );
        if ( NULL != aCT && NULL != m_CounterDef.m_aRawCounterType )
        {
            memcpy(
                aCT,
                m_CounterDef.m_aRawCounterType,
                sizeof(COUNTER_TYPE) * m_CounterDef.m_dwMaxRawNumCounters
                );
            delete[] m_CounterDef.m_aRawCounterType;
        }
        m_CounterDef.m_dwMaxRawNumCounters = dwC;
        m_CounterDef.m_aRawCounterType = aCT;
    }
    m_CounterDef.m_aRawCounterType[m_CounterDef.m_dwNumRawCounters-1]
        = fCounterType;
}



/***********************************************************************++

  Macros used for defining counter classes

--***********************************************************************/


#define BEGIN_CPP_PERFORMACE_CLASS(cperfclass)                          \
class cperfclass :                                                      \
    public CCounterDef_IISCtrs                                          \
{                                                                       \
public: cperfclass();                                                   \



#define DWORD_COUNTER(ctr)                                              \
public:                                                                 \
    CDWORDCounterWriter ctr ## ;                                        \
    DWORD Increment ## ctr ( LONG lIncrVal=1 )                          \
    {                                                                   \
        _ASSERTE ( IsInitialized() );                                   \
        _ASSERTE ( !!m_pSM );                                           \
        if ( this == m_pCounters )                                      \
        {                                                               \
            HRESULT hr = Connect();                                     \
            if ( FAILED(hr) )                                           \
                return ctr ## .Add ( lIncrVal );                        \
            lIncrVal += ctr ## .Set(0);                                 \
        }                                                               \
        if ( m_pSM->IsSMLocked() )                                      \
        {                                                               \
            m_pCounters = this;                                         \
            m_pSM->Close(FALSE);                                        \
        }                                                               \
        return m_pCounters-> ## ctr.Add ( lIncrVal );                   \
    }                                                                   \
    DWORD Get ## ctr ()                                                 \
        { return Increment ## ctr (0); }                                \



#define QWORD_COUNTER(ctr)                                              \
public:                                                                 \
    CQWORDCounterWriter ctr ## ;                                        \
    QWORD Increment ## ctr ( DWORD dwIncrVal=1 )                        \
    {                                                                   \
        _ASSERTE ( IsInitialized() );                                   \
        _ASSERTE ( !!m_pSM );                                           \
        if ( this == m_pCounters )                                      \
        {                                                               \
            HRESULT hr = Connect();                                     \
            if ( FAILED(hr) )                                           \
                return ctr ## .Add ( dwIncrVal );                       \
            dwIncrVal += (DWORD)ctr ## .Set(0);                         \
        }                                                               \
        if ( m_pSM->IsSMLocked() )                                      \
        {                                                               \
            m_pCounters = this;                                         \
            m_pSM->Close(FALSE);                                        \
        }                                                               \
        return m_pCounters-> ## ctr.Add ( dwIncrVal );                  \
    }                                                                   \
    QWORD Get ## ctr ()                                                 \
        { return Increment ## ctr (0); }                                \



#define END_CPP_PERFORMANCE_CLASS(cperfclass)                           \
public:                                                                 \
    VOID Release() { delete this; }                                     \
    ~cperfclass()                                                       \
    {                                                                   \
        if ( !!m_pSM )                                                  \
            m_pSM->Close(TRUE);                                         \
    }                                                                   \
    HRESULT STDMETHODCALLTYPE Connect( IN PCWSTR szInstanceName )       \
    {                                                                   \
        ::wcsncpy( m_szInstanceName, szInstanceName, MAX_NAME_CHARS );  \
        m_szInstanceName[MAX_NAME_CHARS-1] = L'\0';                     \
        HRESULT hr = ConnectData(                                       \
                         szInstanceName, (PVOID*)&m_pCounters );        \
        if ( FAILED(hr) )                                               \
        {                                                               \
            m_pCounters = this;                                         \
            m_szInstanceName[0] = L'\0';                                \
        }                                                               \
        else                                                            \
        {                                                               \
            ::wcsncpy(m_szClassName,m_pSM->ClassName(),MAX_NAME_CHARS); \
            m_szClassName[MAX_NAME_CHARS-1] = L'\0';                    \
        }                                                               \
        return hr;                                                      \
    }                                                                   \
protected:                                                              \
    HRESULT STDMETHODCALLTYPE Connect()                                 \
    {                                                                   \
        HRESULT hr =                                                    \
            m_pSM->Open ( m_szClassName, m_pSM->AccessorType() );       \
        if( SUCCEEDED(hr) )                                             \
            hr = ConnectData ( m_szInstanceName, (PVOID*)&m_pCounters );\
        if ( FAILED(hr) )                                               \
        {                                                               \
            m_pCounters = this;                                         \
            m_pSM->Close(FALSE);                                        \
        }                                                               \
        return hr;                                                      \
    }                                                                   \
    static cperfclass *  m_pCounters;                                   \
    WCHAR m_szInstanceName[MAX_NAME_CHARS];                             \
    WCHAR m_szClassName[MAX_NAME_CHARS];                                \
};                                                                      \


// in .cxx file:
#define BEGIN_COUNTER_BINDING(cperfclass)                               \
cperfclass * cperfclass ## ::m_pCounters = NULL;                        \
CCounterDef CCounterDef_IISCtrs::m_CounterDef;                          \
WCHAR CCounterDef_IISCtrs::m_szClassName[MAX_NAME_CHARS+1]={0};         \
PBYTE CCounterDef_IISCtrs::m_pDataStart = NULL;                         \
SMACCESSOR_TYPE CCounterDef_IISCtrs::m_fAccessorType = SM_ACC_UNKNOWN;  \
CComPtr<ISMManager>  CCounterDef_IISCtrs::m_pSM = NULL;                 \
cperfclass ## :: cperfclass ## ()                                       \
{                                                                       \
    ::ZeroMemory ( m_szInstanceName, sizeof(m_szInstanceName) );        \
    ::ZeroMemory ( m_szClassName, sizeof(m_szClassName) );              \
    m_pCounters = this;                                                 \
    static CCounterInfo _s_aBoundCounterDef[] =                         \
    {                                                                   \



#define BIND_COUNTER(BoundCounter, RawCounter)                          \
        CCounterInfo(                                                   \
            L"" L#BoundCounter,                                         \
            ( m_CounterDef.m_dwNumCounters++,                           \
              (DWORD) ( (PBYTE)& ##RawCounter - m_pDataStart )          \
            ),                                                          \
            (COUNTER_TYPE) sizeof( ## RawCounter) ),                    \



#define END_COUNTER_BINDING(cperfclass)                                 \
        CCounterInfo ( L"" , 0, UNKNOWN_TYPE )                          \
    };                                                                  \
    m_CounterDef.m_aCounterInfo = &_s_aBoundCounterDef[0];                           \
}                                                                       \


#endif // _counters_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\factory.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    factory.h

Abstract:

    This is definition of the class factory class for
    the high performance provider for WMI

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/


#ifndef _factory_h__
#define _factory_h__


class CPerfClassFactory
    : public IClassFactory
{

public:

    CPerfClassFactory();
    ~CPerfClassFactory();

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateInstance(
        IN IUnknown * pControllingUnknown,
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    LockServer(
        IN BOOL Lock
        );


private:


    LONG m_RefCount;


};  // class CPerfClassFactory



#endif  // _factory_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\makefile.inc ===
$(O)\wmihpp.res: wmihpp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\provider.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    provider.h

Abstract:

    WMI high performance provider.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/

#ifndef _perfprov_h__
#define _perfprov_h__

#include <comdef.h>
#include <wbemprov.h>

#include "..\inc\counters.h"
#include "factory.h"
#include "refresher.h"
#include "datasource.h"


//
//  This structure defines the properties and types of the counters.
//  It is used for simplicity; actual providers should enumerate
//  the property names and types
//

extern LONG g_hID;
extern LONG g_hInstanceName;


class CPerfDataSource;



//
// CHiPerfProvider
//
//      The provider maintains a single IWbemClassObject to be used 
//      as a template to spawn instances for the Refresher as well
//      as QueryInstances.  It also maintains the static performace
//      data source which provides all data to the instances.
//

class
__declspec(uuid("FA76BCAB-2F60-46db-996B-2E77F4414FDE"))
CHiPerfProvider :
    public IWbemProviderInit,
    public IWbemHiPerfProvider
{

public:

    CHiPerfProvider();
    ~CHiPerfProvider();


    //
    // IUnknown methods
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );


    //
    // IWbemProviderInit methods
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    Initialize( 
        IN LPWSTR szUser,
        IN LONG lFlags,
        IN LPWSTR szNamespace,
        IN LPWSTR szLocale,
        IN IWbemServices * pNamespace,
        IN IWbemContext * pCtx,
        IN IWbemProviderInitSink * pInitSink
        );


    //
    // IWbemHiPerfProvider methods
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInstances( 
        IN IWbemServices * pNamespace,
        IN WCHAR * szClass,
        IN LONG lFlags,
        IN IWbemContext * pCtx,
        IN IWbemObjectSink * pSink
        );
    
    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateRefresher( 
        IN  IWbemServices * pNamespace,
        IN  LONG lFlags,
        OUT IWbemRefresher * * ppRefresher
        );
    
    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateRefreshableObject( 
        IN  IWbemServices * pNamespace,
        IN  IWbemObjectAccess * pTemplate,
        IN  IWbemRefresher * pRefresher,
        IN  LONG lFlags,
        IN  IWbemContext * pContext,
        OUT IWbemObjectAccess * * ppRefreshable,
        OUT LONG * plId
        );
    
    virtual
    HRESULT
    STDMETHODCALLTYPE
    StopRefreshing( 
        IN IWbemRefresher * pRefresher,
        IN LONG lId,
        IN LONG lFlags
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    CreateRefreshableEnum(
        IN  IWbemServices * pNamespace,
        IN  LPCWSTR wszClass,
        IN  IWbemRefresher * pRefresher,
        IN  LONG lFlags,
        IN  IWbemContext * pContext,
        IN  IWbemHiPerfEnum * pHiPerfEnum,
        OUT LONG * plId
        );

    virtual
    HRESULT
    STDMETHODCALLTYPE
    GetObjects(
        IN IWbemServices * pNamespace,
        IN LONG lNumObjects,
        IN IWbemObjectAccess * * apObj, // array of size lNumObjects
        IN LONG lFlags,
        IN IWbemContext * pContext
        );

    //
    // Our methods:
    //

    HRESULT
    STDMETHODCALLTYPE
    UpdateInstance(
        DWORD dwInstID
        );
    
    protected:
    HRESULT
    STDMETHODCALLTYPE
    _Initialize(
        IN PCWSTR szClassName,
        IN IWbemServices * pNamespace,
        IN IWbemContext * pContext
        );

protected:

    LONG m_RefCount;

    IWbemClassObject *    m_pTemplate;

    CRefresher * m_pFirstRefresher;

    CPerfDataSource m_DataSource;

    IWbemObjectAccess * * m_aInstances;  // array of [m_dwMaxInstances] of instances
    DWORD m_dwMaxInstances;

};


#endif // _perfprov_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\wmihpp.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wmihpp.cxx

Abstract:


Author:

    Cezary Marcjan (cezarym)        23-Mar-2000

Revision History:

--*/


#define _WIN32_DCOM
#include <windows.h>
#include <AtlBase.h>
#include "factory.h"
#include "provider.h"


/***********************************************************************++

    Generic COM server code implementation

--***********************************************************************/

//
// WMI class names. Must be identical to the class names
// used in the MOF file.
//
#define IMPLEMENTED_CLSID         __uuidof(CHiPerfProvider)
#define SERVER_REGISTRY_COMMENT   L"IIS WMI hiperf provider COM server"
#define CLASSFACTORY_CLASS        CPerfClassFactory

#include "..\inc\serverimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\provider.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    provider.cxx

Abstract:

    This is implementation of WMI highperf provider.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

    cezarym   02-Jun-2000           Updated

--*/


#define _WIN32_DCOM
#include <windows.h>

#include <stdio.h>
#include <process.h>

#include "..\inc\counters.h"
#include "provider.h"
#include "refresher.h"
#include "datasource.h"


//
// The access handle for the object's ID
//

LONG g_hID = 0;
LONG g_hInstanceName = 0;


//
// The COM object counter (declared in server.cpp)
//

extern LONG g_lObjects;    



/***************************************************************************++

Routine Description:

    Helper functions for generating and checking enumerator IDs. The generator
    returns a unique integer.


--***************************************************************************/


#define REFRESHABLE_ENUMERATOR_MASK 0x40000000
#define REFRESHABLE_OBJECT_MASK 0x20000000


inline
BOOL
IsEnumerator(
    LONG lID
    )
{
    return 0 != ( lID & REFRESHABLE_ENUMERATOR_MASK );
}


inline
LONG
UniqueObjectID(
    )
{
    static LONG s_lUnique = REFRESHABLE_OBJECT_MASK;

    return ::InterlockedIncrement(&s_lUnique);
}


inline
LONG
UniqueEnumeratorID(
    )
{
    static LONG s_lUnique = REFRESHABLE_ENUMERATOR_MASK;

    return ::InterlockedIncrement(&s_lUnique);
}



/***************************************************************************++

Routine Description:

    Constructor for the CHiPerfProvider class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CHiPerfProvider::CHiPerfProvider(
    )
{
    InterlockedIncrement(&g_lObjects);

    m_RefCount = 1;

    m_pTemplate = 0;

    m_pFirstRefresher = 0;

    m_aInstances = 0;

    m_dwMaxInstances = 0;

}   // CHiPerfProvider::CHiPerfProvider



/***************************************************************************++

Routine Description:

    Destructor for the CHiPerfProvider class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CHiPerfProvider::~CHiPerfProvider(
    )
{
    _ASSERTE ( 0 < g_lObjects );

    InterlockedDecrement(&g_lObjects);

    _ASSERTE( m_RefCount == 0 );

    if ( NULL != m_aInstances)
    {
        DWORD i;
        for ( i=0; i<m_dwMaxInstances; i++)
        {
            if ( NULL != m_aInstances[i] )
                m_aInstances[i]->Release();
        }
        delete[] m_aInstances;
        m_aInstances = 0;
    }

	if (NULL != m_pTemplate)
    {
        m_pTemplate->Release();
        m_pTemplate = 0;
    }

}   // CHiPerfProvider::~CHiPerfProvider



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::QueryInterface(
    REFIID iid,
    PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;

    _ASSERTE ( ppObject != NULL );

    if ( ppObject == NULL )
    {
        hRes = E_INVALIDARG;
        goto Exit;
    }

    if ( iid == IID_IUnknown )
    {
        *ppObject = (PVOID)(IUnknown*)(IWbemHiPerfProvider*) this;
    }
    else if ( iid == IID_IWbemProviderInit )
    {
        *ppObject = (PVOID)(IWbemProviderInit*) this;
    }
    else if ( iid == IID_IWbemHiPerfProvider )
    {
        *ppObject = (PVOID)(IWbemHiPerfProvider*) this;
    }
    else
    {
        *ppObject = NULL;
        hRes = E_NOINTERFACE;

        goto Exit;
    }

    AddRef();


Exit:

    return hRes;

}   // CHiPerfProvider::QueryInterface



/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CHiPerfProvider::AddRef(
    )
{
    LONG lNewCount = InterlockedIncrement( &m_RefCount );

    _ASSERTE ( lNewCount > 1 );

    return ( ( ULONG ) lNewCount );

}   // CHiPerfProvider::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CHiPerfProvider::Release(
    )
{
    LONG lNewCount = InterlockedDecrement( &m_RefCount );

    _ASSERTE ( lNewCount >= 0 );

    if ( lNewCount == 0 )
    {
        delete this;
    }

    return ( ( ULONG ) lNewCount );

}   // CHiPerfProvider::Release



/***************************************************************************++

Routine Description:

    Called once during startup for any one-time initialization.  The 
    final call to Release() is for any cleanup.

    Additional initialization is done in the _Initialize() method when
    a perf counters class name is known.

Arguments:

    szUser        - The current user.
    lFlags        - Reserved.
    szNamespace   - The namespace for which we are being activated.
    szLocale      - The locale
    pNamespace    - An active pointer back into the current namespace
                    from which we can retrieve schema objects.
    pContext      - The user's context object.  We simply reuse this
                    during any reentrant operations into WINMGMT.
    pInitSink     - The sink to which we indicate our readiness.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::Initialize(
    IN LPWSTR /* szUser */,
    IN LONG /* lFlags */,
    IN LPWSTR /*szNamespace*/,
    IN LPWSTR /* szLocale */,
    IN IWbemServices * /*pNamespace*/,
    IN IWbemContext * /*pContext*/,
    IN IWbemProviderInitSink * pInitSink
    )
{
    if ( NULL == pInitSink )
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    pInitSink->SetStatus ( WBEM_S_INITIALIZED, 0 );

    return WBEM_NO_ERROR;
}


/***************************************************************************++

Routine Description:

    Called by CHiPerfProvider::QueryInstances() to initialize the provider.
    This mechanism is necessary since the class name is unknown when the
    CHiPerfProvider::Initialize() is called. We obtain the class name from
    WMI and this class name may be used to access the shared memory for the
    counters for this class.

Arguments:

    IN szClassName  - Class name for the perf counters that we're initializing
    IN pNamespace   - An active pointer back into the current namespace
                      from which we can retrieve schema objects.
    pContext        - The user's context object.  We simply reuse this
                      during any reentrant operations into WINMGMT.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::_Initialize(
    IN PCWSTR szClassName,
    IN IWbemServices * pNamespace,
    IN IWbemContext * pContext
    )
{
    HRESULT hRes = WBEM_NO_ERROR;
    IWbemObjectAccess * pAccess = NULL;
    BSTR bstrWmiPerfClass = NULL;

    if ( NULL == szClassName || NULL == pNamespace )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Get the class object for initialization purposes
    //

    bstrWmiPerfClass = ::SysAllocString ( szClassName );

    hRes = pNamespace->GetObject(
                            bstrWmiPerfClass,
                            0,
                            pContext,
                            &m_pTemplate,
                            NULL
                            );

    ::SysFreeString ( bstrWmiPerfClass );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Get the IWbemObjectAccess interface to the object
    //

    hRes = m_pTemplate->QueryInterface(
                                IID_IWbemObjectAccess,
                                (PVOID*)&pAccess
                                );

    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Initialize the data source
    //

    hRes = m_DataSource.Initialize ( szClassName, pAccess );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    //
    // Initialize the global access handle for the object ID.  
    // If it is not null, then it has already been setup.
    //

    if ( 0 == g_hID )
    {
        //
        // Get the name property access handle
        //

        hRes = pAccess->GetPropertyHandle ( L"ID", 0, &g_hID );

        if ( SUCCEEDED(hRes) )
        {
            hRes = pAccess->GetPropertyHandle(
                                L"Name",
                                0,
                                &g_hInstanceName
                                );
        }

        if ( FAILED(hRes) )
        {
            goto Exit;
        }
    }


Exit:

    if ( FAILED(hRes) && NULL != m_pTemplate )
    {
        m_pTemplate->Release();
        m_pTemplate = 0;
    }

    if ( NULL != pAccess )
    {
        pAccess->Release();
    }

    return hRes;

}   // CHiPerfProvider::Initialize



/***************************************************************************++

Routine Description:

    Called whenever a complete, fresh list of instances for a given
    class is required.   The objects are constructed and sent back to the
    caller through the sink.

Arguments:

    pNamespace - A pointer to the relevant namespace.  This
                     should not be AddRef'ed.
    szClass    - The class name for which instances are required.
    lFlags     - Reserved.
    pContext   - The user-supplied context.
    pSink      - The sink to which to deliver the objects.  The objects
                     can be delivered synchronously through the duration
                     of this call or asynchronously (assuming we
                     had a separate thread).  A IWbemObjectSink::SetStatus
                     call is required at the end of the sequence.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::QueryInstances( 
    IN IWbemServices * pNamespace,
    IN WCHAR * szClass,
    IN LONG /* lFlags */,
    IN IWbemContext * pContext,
    IN IWbemObjectSink * pSink
    )
{
    IWbemClassObject *    pFirstObjectCopy = NULL;
    IWbemClassObject *    pObjectCopy = NULL;
    IWbemObjectAccess *   pAccessCopy = NULL;

    HRESULT hRes = WBEM_NO_ERROR;
    DWORD dwObjectInstance = 0;
    BOOL fFirstInstance = TRUE;

    hRes = _Initialize ( szClass, pNamespace, pContext );
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    if ( NULL != pSink )
    {
        pSink->AddRef();
    }

    if ( NULL != m_aInstances )
    {
        for ( dwObjectInstance = 0;
              dwObjectInstance < m_dwMaxInstances;
              dwObjectInstance++ )
        {
            if ( NULL != m_aInstances[dwObjectInstance] )
            {
                m_aInstances[dwObjectInstance]->Release();
            }
        }
        delete[] m_aInstances;
    }

    m_dwMaxInstances = m_DataSource.GetMaxInstances() + 1;

    m_aInstances = new IWbemObjectAccess*[m_dwMaxInstances];

    ::ZeroMemory(
        m_aInstances,
        sizeof(IWbemObjectAccess *) * m_dwMaxInstances
        );

    //
    // Loop through all instances, indicating an updated version
    // to the object sink
    //

    for ( dwObjectInstance=0;
          dwObjectInstance < m_dwMaxInstances;
          dwObjectInstance++ )
    {
        CSMInstanceDataHeader const * pInstanceDataHeader
            = m_DataSource.GetInstanceDataHeader ( dwObjectInstance );

        if ( NULL == pInstanceDataHeader )
        {
            break;
        }
        if ( pInstanceDataHeader->IsEnd() )
        {
            break;
        }
        if ( pInstanceDataHeader->IsUnused()    ||
             *pInstanceDataHeader->InstanceName() == L'\0'
             )
        {
            continue;
        }

        PCWSTR szInstName = pInstanceDataHeader->InstanceName();

        if( fFirstInstance )
        {
            fFirstInstance = FALSE;

            //
            // Create a new instance from the template
            //

            hRes = m_pTemplate->SpawnInstance(0, &pFirstObjectCopy);

            if ( FAILED(hRes) )
            {
                goto Exit;
            }

            pFirstObjectCopy->AddRef();
            pObjectCopy = pFirstObjectCopy;
        }
        else
        {
            //
            // Clone the first instance
            //

            hRes = pFirstObjectCopy->Clone(&pObjectCopy);

            if ( FAILED(hRes) )
            {
                goto Exit;
            }
        }

        //
        // Get the IWbemObjectAccess interface
        //

        hRes = pObjectCopy->QueryInterface(
                                IID_IWbemObjectAccess,
                                (PVOID*)&pAccessCopy
                                );
        if ( FAILED(hRes) )
        {
            pObjectCopy->Release();
            goto Exit;
        }

        //
        // Set the ID and Name
        //

        hRes = pAccessCopy->WriteDWORD ( g_hID, dwObjectInstance );
        if ( FAILED(hRes) )
        {
            pObjectCopy->Release();
            goto Exit;
        }

        hRes = pAccessCopy->WritePropertyValue(
                                g_hInstanceName,
                                wcslen(szInstName)*2+2,
                                (BYTE const*)szInstName
                                );
        if ( FAILED(hRes) )
        {
            pObjectCopy->Release();
            goto Exit;
        }
        
        //
        // Initialize the counters
        //

        pAccessCopy->AddRef();

        m_aInstances[dwObjectInstance] = pAccessCopy;
		hRes = m_DataSource.UpdateInstance(pAccessCopy);
        if ( FAILED(hRes) )
        {
            pObjectCopy->Release();
            goto Exit;
        }

        //
        // Send a copy back to the caller
        //

        if ( NULL != pSink )
        {
            pSink->Indicate(1, &pObjectCopy);
        }
    }

    //
    // Tell WINMGMT we are all finished supplying objects
    //

Exit:

    if ( NULL != pSink )
    {
        pSink->SetStatus(0, hRes, 0, 0);
        pSink->Release();
    }

    if ( NULL != pFirstObjectCopy )
    {
        pFirstObjectCopy->Release();
    }

    return hRes;

}   // CHiPerfProvider::QueryInstances



/***************************************************************************++

Routine Description:

    Called whenever a new refresher is needed by the client.

Arguments:

    pNamespace  - Pointer to the relevant namespace.  Not used.
    lFlags      - Reserved.
    ppRefresher - Receives the requested refresher.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::CreateRefresher( 
     IN  IWbemServices * pNamespace,
     IN  LONG /* lFlags */,
     OUT IWbemRefresher * * ppRefresher )
{
    HRESULT hRes = WBEM_NO_ERROR;

    if ( NULL == ppRefresher )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
    }
    else if ( NULL == pNamespace )
    {
        *ppRefresher = NULL;

        hRes = WBEM_E_INVALID_PARAMETER;
    }
    else
    {
        *ppRefresher = NULL;

        //
        // Construct and initialize a new empty refresher
        //

        CRefresher * pRefresher = new CRefresher ( this, m_pFirstRefresher );
        if ( NULL == pRefresher )
        {
            hRes = E_OUTOFMEMORY;
        }
        else
        {
            m_pFirstRefresher = pRefresher;

            pRefresher->AddRef();
            *ppRefresher = pRefresher;
        }
    }

    return hRes;

}    // CHiPerfProvider::CreateRefresher



/***************************************************************************++

Routine Description:

    Called whenever a user wants to include an object in a refresher.

Arguments:

    pNamespace      - A pointer to the relevant namespace in WINMGMT.
    pTemplate       - A pointer to a copy of the object which is to be
                      added.  This object itself cannot be used, as
                      it not owned locally.        
    pRefresher      - The refresher to which to add the object.
    lFlags          - Not used.
    pContext        - Context of the call
    ppRefreshable   - A pointer to the internal object which was added
                      to the refresher.
    plId            - The Object Id (for identification during removal).        

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::CreateRefreshableObject( 
    IN  IWbemServices * pNamespace,
    IN  IWbemObjectAccess * pTemplate,
    IN  IWbemRefresher * pRefresher,
    IN  LONG /* lFlags */,
    IN  IWbemContext * pContext,
    OUT IWbemObjectAccess * * ppRefreshable,
    OUT LONG * plId
    )
{
    DWORD dwID = 0;
    HRESULT hRes = WBEM_NO_ERROR;
    CRefreshableObject * pRefreshableObject = 0;
    CRefresher *pRshr = 0;

    if ( NULL == pNamespace ||
         NULL == pTemplate  ||
         NULL == pRefresher ||
         NULL == ppRefreshable
         )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    if ( NULL == m_aInstances )
    {
        //
        // Initialize the instances cache
        //

        pTemplate->AddRef();
        m_pTemplate = pTemplate;

        VARIANT vClassName;
        BSTR strClassProp = SysAllocString(L"__CLASS");
        hRes = pTemplate->Get ( strClassProp, 0, &vClassName, 0, 0);
        SysFreeString ( strClassProp );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }

        hRes = QueryInstances(
                    pNamespace,
                    V_BSTR(&vClassName),
                    0,
                    pContext,
                    NULL
                    );

        VariantClear( &vClassName );

        if ( FAILED(hRes) )
        {
            goto Exit;
        }
    }

    //
    // Add the object to the refresher.
    //

    *ppRefreshable = 0;

    pRshr = (CRefresher *) pRefresher;

    hRes = pTemplate->ReadDWORD(g_hID, &dwID);
    if ( FAILED(hRes) )
    {
        goto Exit;
    }

    *ppRefreshable = m_aInstances[dwID];

    if ( NULL == *ppRefreshable )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    *plId = ::UniqueObjectID();

    (*ppRefreshable)->AddRef();

    pRefreshableObject = new CRefreshableObject(
                                        *plId,
                                        dwID,
                                        pRshr->m_pFirstRefreshableObject
                                        );
    if ( !pRefreshableObject )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    pRshr->m_pFirstRefreshableObject = pRefreshableObject;

Exit:

    return hRes;

}   // CHiPerfProvider::CreateRefreshableObject



/***************************************************************************++

Routine Description:

    Called when an enumerator is being added to a refresher.  The 
    enumerator will obtain a fresh set of instances of the specified 
    class every time refresh is called.

Arguments:

    pNamespace  - A pointer to the relevant namespace.  
    szClass     - The class name for the requested enumerator.
    pRefresher  - The refresher object for which we will add 
                  the enumerator
    lFlags      - Reserved.
    pContext    - Not used here.
    pHiPerfEnum - The enumerator to add to the refresher.
    plId        - A provider specified ID for the enumerator.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::CreateRefreshableEnum(
    IN  IWbemServices * pNamespace,
    IN  LPCWSTR szClass,
    IN  IWbemRefresher * pRefresher,
    IN  LONG /* lFlags */,
    IN  IWbemContext * /* pContext */,
    IN  IWbemHiPerfEnum * pHiPerfEnum,
    OUT LONG * plId
    )
{
    HRESULT hRes = WBEM_NO_ERROR;
    CRefreshableEnum * pRefreshableEnum = 0;
    CRefresher * pRshr = 0;

    if ( !pNamespace || !pRefresher || !pHiPerfEnum || !plId )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Add the object to the refresher.
    //

    pRshr = (CRefresher *) pRefresher;

    *plId = UniqueEnumeratorID();

    pRefreshableEnum = new CRefreshableEnum(
                                    *plId,
                                    pHiPerfEnum,
                                    pRshr->m_pFirstRefreshableEnum
                                    );
    if ( !pRefreshableEnum )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    hRes = pRefreshableEnum->AddObjects ( m_aInstances, m_dwMaxInstances );
    if ( FAILED(hRes) )
    {
        delete pRefreshableEnum;
        goto Exit;
    }

    pRshr->m_pFirstRefreshableEnum = pRefreshableEnum;

Exit:

    return hRes;

}   // CHiPerfProvider::CreateRefreshableEnum



/***************************************************************************++

Routine Description:

    Called whenever a user wants to remove an object from a refresher.

Arguments:

    pRefresher  - The refresher object from which we are to 
                  remove the perf object.
    lId         - The ID of the object.
    lFlags      - Not used.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::StopRefreshing( 
    IN IWbemRefresher * pRefresher,
    IN LONG lId,
    IN LONG /* lFlags */
    )
{
    HRESULT hRes = WBEM_NO_ERROR;
    CRefresher * pOurRefresher = 0;

    if ( NULL == pRefresher )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    pOurRefresher = (CRefresher *) pRefresher;

    if ( IsEnumerator(lId) )
    {
        CRefreshableEnum * pR;
        CRefreshableEnum * pRPrev = 0;
        for ( pR=pOurRefresher->m_pFirstRefreshableEnum;
              0 != pR;
              pR = pR->m_pNext )
        {
            if ( pR->RshrID() == lId )
            {
                if ( !pRPrev )
                    pOurRefresher->m_pFirstRefreshableEnum = pR->m_pNext;
                else
                    pRPrev->m_pNext = pR->m_pNext;

                delete pR;
            }
            pRPrev = pR;
        }
    }
    else
    {
        CRefreshableObject * pO;
        CRefreshableObject * pOPrev = 0;
        for ( pO = pOurRefresher->m_pFirstRefreshableObject;
              0 != pO;
              pO = pO->m_pNext )
        {
            if ( pO->RshrID() == lId )
            {
                if ( !pOPrev )
                    pOurRefresher->m_pFirstRefreshableObject = pO->m_pNext;
                else
                    pOPrev->m_pNext = pO->m_pNext;

                delete pO;
            }
            pOPrev = pO;
        }
    }

Exit:

    return hRes;

}   // CHiPerfProvider::StopRefreshing



/***************************************************************************++

Routine Description:

    Called when a request is made to provide all instances currently 
    managed by the provider in the specified namespace.

Arguments:

    pNamespace   - A pointer to the relevant namespace.  
    lNumObjects  - The number of instances being returned.
    apObj        - The array of instances being returned.
    lFlags       - Reserved.
    pContext     - Not used here.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::GetObjects( 
    IN IWbemServices * /* pNamespace */,
    IN LONG lNumObjects,
    IN IWbemObjectAccess * * apObj, // array, lNumObjects
    IN LONG /* lFlags */,
    IN IWbemContext * /* pContext */
    )
{
    HRESULT hRes = WBEM_NO_ERROR;
	DWORD dwID = 0;

    LONG lUpdated = 0;
    LONG i;

    if ( NULL == apObj )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    for ( i=0; i<lNumObjects; i++ )
    {
        IWbemObjectAccess * pAccess = apObj[i];
        if ( !pAccess )
        {
            break;
        }

        hRes = pAccess->ReadDWORD(g_hID, &dwID);
	    if (FAILED(hRes))
        {
		    break;
        }

        if ( dwID >= m_dwMaxInstances )
        {
            break;
        }
        else
        {
            hRes = m_DataSource.UpdateInstance(pAccess);

            if ( FAILED(hRes) )
            {
                break;
            }
            else
            {
                lUpdated++;
            }
        }
    }

    if ( SUCCEEDED(hRes) && lUpdated < lNumObjects )
    {
        hRes = WBEM_E_NOT_FOUND;
    }

Exit:

    return hRes;

}   // CHiPerfProvider::GetObjects



/***************************************************************************++

Routine Description:

    Update specified instance of the counters

Arguments:

    dwInstID - Counter instnace ID

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CHiPerfProvider::UpdateInstance(
    DWORD dwInstID
    )
{
    HRESULT hRes = WBEM_NO_ERROR;

    if ( dwInstID >= m_dwMaxInstances ||
         NULL == m_aInstances         ||
         NULL == m_aInstances[dwInstID] )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    hRes = m_DataSource.UpdateInstance(m_aInstances[dwInstID]);


Exit:

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\refresher.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    refresher.h

Abstract:

    The refresher maintains an object and an enumerator cache.
    When an enumerator is added to the refrehser, it is added 
    to the enumerator cache, and the index of the array is
    passed back as a unique ID.  The refresher creates a cache
    of all instances during its initialization.  When an object 
    is added to the refresher, a mapping to the object is 
    created between the unique ID and the index of the object
    in the cache.  This allows the objects to be reused and 
    facilitates the management of objects that have been added 
    multiple times.

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

--*/



#ifndef _refresher_h__
#define _refresher_h__



class CRefreshableObject
{
public:

    CRefreshableObject(
        LONG lRshrID,
        DWORD dwInstID,
        CRefreshableObject* pNext
        )
    {
        m_lRshrID = lRshrID;
        m_dwInstID = dwInstID;
        m_pNext = pNext;
    }

    LONG
    RshrID(
        ) const
    {
        return m_lRshrID;
    }

    DWORD
    InstID(
        ) const
    {
        return m_dwInstID;
    }

    CRefreshableObject * m_pNext;

protected:

    LONG  m_lRshrID;  // Refreshable object ID maps to the instance ID
    DWORD m_dwInstID; // Instance ID

private:

    CRefreshableObject(){}
};



class CRefreshableEnum
{
public:

    CRefreshableEnum(
        LONG lRshrID,
        IWbemHiPerfEnum * pHiPerfEnum,
        CRefreshableEnum* pNext
        )
    {
        m_lRshrID = lRshrID;
        if ( pHiPerfEnum )
            pHiPerfEnum->AddRef();
        m_pHiPerfEnum = pHiPerfEnum;
        m_pNext = pNext;
    }

    ~CRefreshableEnum(
        )
    {
        if ( m_pHiPerfEnum )
            m_pHiPerfEnum->Release();
    }

    HRESULT
    STDMETHODCALLTYPE
    AddObjects(
        IWbemObjectAccess * * aInstances,
        DWORD dwMaxInstances
        );

    LONG
    RshrID(
        ) const
    {
        return m_lRshrID;
    }

    IWbemHiPerfEnum *
    HiPerfEnum(
        ) const
    {
        return m_pHiPerfEnum;
    }

    CRefreshableEnum * m_pNext;

protected:

    LONG  m_lRshrID;  // Refreshable object ID maps to the instance ID

    IWbemHiPerfEnum * m_pHiPerfEnum;

private:

    CRefreshableEnum(){}
};



class CHiPerfProvider;


class CRefresher
    : public IWbemRefresher
{

public:

    //
    // ctor/dtor/init
    //

    CRefresher ( CHiPerfProvider * pProv, CRefresher * pNext );
    ~CRefresher ( );

    //
    // IUnknown methods
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    QueryInterface(
        IN REFIID iid,
        OUT PVOID * ppObject
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    AddRef(
        );

    virtual
    ULONG
    STDMETHODCALLTYPE
    Release(
        );


    //
    // IWbemRefresher methods:
    //

    virtual
    HRESULT
    STDMETHODCALLTYPE
    Refresh(
        IN LONG lFlags
        );

private:

    friend class CHiPerfProvider; // will add/delete refreshable abjects

    CRefresher *          m_pNext;

    CHiPerfProvider *     m_pProv;

    CRefreshableObject *  m_pFirstRefreshableObject;
    CRefreshableEnum *    m_pFirstRefreshableEnum;

    LONG                  m_RefCount;

};


#endif // _refresher_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\prfshmem\perf_sm.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    perf_sm.cxx

Abstract:

    This file contains three classes.  They control
    all aspects of the shared memory that allows counters
    to be transfered from WAS to the performance library.

Author:

    Emily Kruglick (EmilyK)       6-Sept-2000

Revision History:

--*/



#include "iis.h"
#include "winperf.h"
#include "perfcount.h"
#include "iisdef.h"
#include "wasdbgut.h"
#include "perf_sm.h"
#include <Aclapi.h>
#include <limits.h>
#include <buffer.hxx>
#include <secfcns.h>
#include "regconst.h"

// 
// typedefs, structs, enums ...
//


//
// Used to define information about a 
// counter set.  Used below to define
// all the counter sets.
//
typedef struct _COUNTER_SET_DEFINE
{
    LPCWSTR             pFilePrefix;
    DWORD               SizeOfCounterData;
    BOOL                DefineIncludesInstanceData;
} COUNTER_SET_DEFINE;


//
// common #defines.
// 

//
// Issue-09/29/2000-EmilyK  File Name Sizing
// When we deal with securing shared memory this
// value may change.
//
// Hard coded value used in allocation
// of strings that will contain a shared
// memory file name.
//
#define MAX_FILE_NAME 100

//
// Issue-09/10/2000-EmilyK  Counter Control Block Name
// Need to make this a "safe" name.  It will be handled
// when I work on securing the shared memory.
//
#define IISCounterControlBlock L"Global\\IISCounterControlBlock-46382a23-095e-4559-8d63-6fdeaf552c23"


//
// Number of tick counts that must have passed to make the data old.
//------------------------------------------------------------------
// You can override this value by senting "FreshTimeForCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
#define IIS_DEFAULT_MILLISECONDS_COUNTERS_ARE_FRESH 15000  // 15 seconds in milliseconds

//
// How long to Sleep before each check for new counters
//------------------------------------------------------------------
// You can override this value by senting "CheckCountersEveryNMiliseconds"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
#define IIS_DEFAULT_MILLISECONDS_SLEEP_BEFORE_CHECKING_FOR_NEW_COUNTERS 250 // 1/4 second

//
// Number of times to wait for the time between tickcounts.
//------------------------------------------------------------------
// You can override this value by senting "NumberOfTimesToCheckCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
//
#define IIS_MAX_NUMBER_TIMES_TO_CHECK_IF_COUNTERS_ARE_FRESH 4 

//
// Global Variables
//

//
// Used as a generic instance definition that can be copied
// into the shared memory and altered to represent a specific instance.
//
PERF_INSTANCE_DEFINITION g_PerfInstance = 
{ sizeof(PERF_INSTANCE_DEFINITION) + MAX_INSTANCE_NAME * sizeof(WCHAR)
, 0
, 0
, PERF_NO_UNIQUE_ID
, sizeof(PERF_INSTANCE_DEFINITION)
, 0  // Needs to be reset when initialized.
};


//
// Order must match the COUNTER_SET_ENUM enum in perf_sm.h
// Counter names must be less than ~80 characters.  
// (Based roughly on MAX_FILE_NAME)
//
COUNTER_SET_DEFINE g_CounterSetInfo[] =
{ 
      {
          L"Global\\IISSitesCounters-99c62c38-377d-4a73-af40-6ea7ed1f5896",        // prefix name of shared memory file
          sizeof(W3_COUNTER_BLOCK),   // size of the counters per display
          TRUE                        // Defines instance data
      },
      {
          L"Global\\IISCacheCounters-c205a604-4df5-42b6-8fe9-dbfe18f022a0",                                              
          sizeof(W3_GLOBAL_COUNTER_BLOCK),
          FALSE
      },

      //
      // Issue 09-29-2000-EmilyK  AppPoolCounters
      // Will need to be altered signifigantly when we start gathing 
      // app pool counters.
      //
      {
          L"Global\\IISApppoolCounters-e274c7d9-3443-401b-8b0d-ad7175645315", 
          0,
          TRUE
      },
};

//
// Helper function declarations
//

DWORD 
CreateMemoryFile (
     IN LPCWSTR pFileName,
     IN DWORD SizeOfData,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     );

DWORD
OpenMemoryFile (
     IN LPCWSTR pFileName,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     );

//
// Public PERF_SM_MANAGER functions.
// 

/***************************************************************************++

Routine Description:

    PERF_SM_MANAGER constructor

Arguments:

    None

Return Value:

    None

--***************************************************************************/
PERF_SM_MANAGER::PERF_SM_MANAGER(
    )
{
    m_pManagerMemory = NULL;
    m_hManagerMemory = NULL;

    m_WASProcessHandle = NULL;

    m_pSMObjects = NULL;

    m_hIISSignalCounterRefresh = NULL;

    m_IIS_MillisecondsCountersAreFresh = 
            IIS_DEFAULT_MILLISECONDS_COUNTERS_ARE_FRESH;

    m_IIS_MaxNumberTimesToCheckCountersOnRefresh = 
            IIS_DEFAULT_MILLISECONDS_SLEEP_BEFORE_CHECKING_FOR_NEW_COUNTERS;

    m_IIS_MillisecondsToSleepBeforeCheckingForRefresh = 
            IIS_MAX_NUMBER_TIMES_TO_CHECK_IF_COUNTERS_ARE_FRESH;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_MANAGER_SIGNATURE;
}

/***************************************************************************++

Routine Description:

    PERF_SM_MANAGER destructor

Arguments:

    None

Return Value:

    None

--***************************************************************************/
PERF_SM_MANAGER::~PERF_SM_MANAGER(
    )
{
    DBG_ASSERT( m_Signature == PERF_SM_MANAGER_SIGNATURE );

    m_Signature = PERF_SM_MANAGER_SIGNATURE_FREED;

    if ( m_hIISSignalCounterRefresh )
    {
        CloseHandle ( m_hIISSignalCounterRefresh );
        m_hIISSignalCounterRefresh = NULL;
    }

    if ( m_pSMObjects ) 
    {
        if ( HasWriteAccess() )
        {
            delete[] (PERF_SM_MANAGER::PERF_SM_WRITER*) m_pSMObjects;
        }
        else
        {
            delete[] (PERF_SM_MANAGER::PERF_SM_READER*) m_pSMObjects;
        }

        m_pSMObjects = NULL;
    }


    if ( m_pManagerMemory ) 
    {
        UnmapViewOfFile ( (LPVOID) m_pManagerMemory );
        m_pManagerMemory = NULL;
    }

    if ( m_hManagerMemory ) 
    {
        CloseHandle ( m_hManagerMemory );
        m_hManagerMemory = NULL;
    }

            
    if ( m_WASProcessHandle != NULL )
    {
        CloseHandle ( m_WASProcessHandle );
        m_WASProcessHandle = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Initializer for the manager.  This routine will create the control
    manager shared memory.  If the shared memory all ready exists then it will
    error.  
    
    Note:  We choose to error if we can not create the shared memory for 
           perf counters.  Instead of just hooking up to existent memory.  The
           perf library will let go of the memory when the WAS process dies
           so it will not be the perf library holding the memory open.  

           If it is not the perf library holding open the memory then it is
           an illegal process.  They will be able to provide fake counters back
           to the perf library, however they will need to be able to fake out
           the exact structure that we expect instead of just changing
           a value.  They can also just prevent perf counters from running by 
           holding open the memory.

           This should go through Security Review.

Arguments:

    BOOL WriteAccess  -  Tells if we expect to be using this class
                         as a reader or writer of memory.

Return Value:

    DWORD             -  Win32 Error Code

    Note:  The perf library expects a WIN32 Error code so functions being 
           used from the perf library will return DWORDs instead of hresults.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::Initialize(
        BOOL WriteAccess
        )
{
    DBG_ASSERT ( !m_Initialized && !m_hManagerMemory && !m_pManagerMemory );

    DWORD dwErr = ERROR_SUCCESS;

    //
    // Remember the WriteAccess we are initialized to.
    // This will be used to make sure we don't try and 
    // hook a Writer to a Reader Controller and vica versa.
    //
    m_WriteAccess = WriteAccess;

    if ( m_WriteAccess )
    {
        // 
        // Since we are going to own the memory we need to create
        // it and error if we can not create it.
        // 
        // See note in function comments.
        //
        // The memory should be the correct size to contain 
        // one control block for every counter set we know of.
        //
        dwErr = CreateMemoryFile ( IISCounterControlBlock
                           , sizeof(MANAGER_BLOCK)
                           , &m_hManagerMemory
                           , (LPVOID*) &m_pManagerMemory );

        if ( dwErr != ERROR_SUCCESS )
        {
           
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not create the perf counters control block memory\n"
                ));

            goto exit;
        }

        // 
        // set the process id for the managing process into the memory.
        // this will let the clients monitor the managing process and
        // shutdown if need be.
        //

        m_pManagerMemory->WASProcessId = GetCurrentProcessId();

        //
        // For each counter, establish the default settings.
        //
        for (DWORD i = 0; i < (MAX_COUNTER_SET_DEFINES); i++)
        {
            //
            // Note Version 0 is a warning sign that
            // the memory is not ready for use.
            //
            m_pManagerMemory->ControlArray[i].Version = 0;
            m_pManagerMemory->ControlArray[i].ActivePageIsA = TRUE;

        }

        DBG_ASSERT ( m_pSMObjects == NULL );

        //
        // Allocate enough new objects to support the different
        // counter sets.  This is done dynamically because we don't
        // know at compile time if this will be a reader or a writer class.
        //
        m_pSMObjects = new PERF_SM_WRITER[MAX_COUNTER_SET_DEFINES];

        if ( ! m_pSMObjects )
        {

            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        //
        // Lastly set the appropriate initialized code into 
        // the shared memory, so the reader can tell that the 
        // memory has been completely initialized.
        //
        m_pManagerMemory->InitializedCode = PERF_COUNTER_INITIALIZED_CODE;


    }
    else
    {
        //
        // Check the registry to see if we need to reset the counter
        // waiting values.
        //
        ResetWaitFreshCounterValues();

        //
        // We are not a writer, we are a reader so 
        // do not create the memory, just open it.
        //
        dwErr = OpenMemoryFile ( IISCounterControlBlock
                           , &m_hManagerMemory
                           , (LPVOID*) &m_pManagerMemory );
        if ( dwErr != ERROR_SUCCESS )
        {

            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open the perf counters control block memory\n"
                ));

            goto exit;
        }

        //
        // Validate that the initialized code is correct, so we know
        // that this memory has been created for us by the writer.
        //
        if ( m_pManagerMemory->InitializedCode 
                                != PERF_COUNTER_INITIALIZED_CODE )
        {
            //
            // If the perf counter data is not initialized then we do 
            // not want to hold on to this file.
            //

            dwErr = ERROR_NOT_READY;
            goto exit;
        }

        DBG_ASSERT ( m_pSMObjects == NULL );

        //
        // Create enough reader objects to represent the different types
        // of counters that we are supporting.
        //
        m_pSMObjects = new PERF_SM_READER[MAX_COUNTER_SET_DEFINES];

        if ( ! m_pSMObjects )
        {

            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        //
        // Also open the event that will be used to signal WAS when 
        // counters need to be refreshed.
        //
        m_hIISSignalCounterRefresh = OpenEvent(EVENT_MODIFY_STATE, 
                                               FALSE, 
                                               COUNTER_EVENT_W);
        if ( m_hIISSignalCounterRefresh == NULL )
        {
            dwErr = GetLastError();
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open an event to request counters from WAS\n"
                ));

            goto exit;
        }

        //
        // Grab hold of the WAS process as well, so we will know
        // when WAS goes away.
        //
        m_WASProcessHandle = OpenProcess ( SYNCHRONIZE,   // security
                                           FALSE,         // not inheritable
                                           m_pManagerMemory->WASProcessId);
        if ( m_WASProcessHandle == NULL )
        {
            dwErr = GetLastError();
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not open the WAS Process to wait on it\n"
                ));
            dwErr = ERROR_NOT_READY;
            goto exit;
        }

    }

exit:

    //
    // Assuming that we made it through here without error then we 
    // can mark this object as initialized.  Otherwise the destructor
    // for this object will handle the cleanup.
    //
    if ( dwErr == ERROR_SUCCESS )
    {
        m_Initialized = TRUE;
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Uninitalize the control block's memory and set all counter set info
    to be uninitalized.  This will let the reader know to drop it's current
    memory pages because WAS does not want them held any more.

    Note:  Only a writer can call this function.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/
VOID
PERF_SM_MANAGER::StopPublishing(
    )
{
    DBG_ASSERT( HasWriteAccess() );

    DBG_ASSERT ( m_pManagerMemory );

    //
    // Mark the managing memory as ready for release.
    //
    m_pManagerMemory->InitializedCode = PERF_COUNTER_UN_INITIALIZED_CODE;

    //
    // Mark all sets of counters as uninitalized.
    //
    for ( DWORD i = 0; i < MAX_COUNTER_SET_DEFINES; i++)
    {
        SetActiveInformation((COUNTER_SET_ENUM) i, 0, TRUE);
    }
}

/***************************************************************************++

Routine Description:

    GetActiveInformation returns the information it holds about a
    specific counter set.  It can be used by the Reader or Writer.

Arguments:

    COUNTER_SET_ENUM CounterSetId - Identifies the counter set 
    DWORD*           pVersion     - Returns the current version for the counter set
    CHAR*            pActivePage  - Returns the current page identifier
                                    for the counter set.

Return Value:

    None.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::GetActiveInformation(
        IN COUNTER_SET_ENUM  CounterSetId,
        OUT DWORD*           pVersion,
        OUT BOOL*            pActivePageIsA
        )
{
    DBG_ASSERT( m_Initialized );

    DBG_ASSERT( m_pManagerMemory );

    *pVersion = m_pManagerMemory->ControlArray[CounterSetId].Version;
    *pActivePageIsA = m_pManagerMemory->ControlArray[CounterSetId].ActivePageIsA;
}

/***************************************************************************++

Routine Description:

    SetActiveInformation will record the information passed to it.  Once
    this function has been called the information will be picked up by the 
    reader and it will start using the new memory.

    Note:  Only a writer can call this function.

Arguments:

    COUNTER_SET_ENUM CounterSetId - Identifies the counter set 
    DWORD            Version      - The current version.
    CHAR             ActivePage   - The current page identifier.

Return Value:

    None.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::SetActiveInformation(
        IN COUNTER_SET_ENUM CounterSetId,
        IN DWORD           Version,
        IN BOOL            ActivePageIsA
        )
{
    DBG_ASSERT( m_Initialized );

    DBG_ASSERT( HasWriteAccess() );

    if ( HasWriteAccess() )
    {
        DBG_ASSERT( m_pManagerMemory );

        m_pManagerMemory->ControlArray[CounterSetId].Version = Version;
        m_pManagerMemory->ControlArray[CounterSetId].ActivePageIsA = ActivePageIsA;
    }
}

/***************************************************************************++

Routine Description:

    Creates a new counter set by letting the appropriate counter set
    initialize it's self.

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - counter set to work with

Return Value:

    DWORD.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::CreateNewCounterSet(
    IN COUNTER_SET_ENUM CounterSetId
    )
{
    DBG_ASSERT ( m_pSMObjects );

    if ( HasWriteAccess() )
    {
        return ( reinterpret_cast<PERF_SM_WRITER*>(m_pSMObjects) )
                                [CounterSetId].Initialize(this, CounterSetId);
    }
    else
    {
        return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects ) )
                                [CounterSetId].Initialize(this, CounterSetId);
    }
    
}

/***************************************************************************++

Routine Description:

    Alters the shared memory chunk if needed

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - counter set to work with
    IN DWORD NumInstances - number of instance expected to be published

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT
PERF_SM_MANAGER::ReallocSharedMemIfNeccessary(
    IN COUNTER_SET_ENUM CounterSetId,
    IN DWORD NumInstances
        )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects ))
                     [CounterSetId].ReallocSharedMemIfNeccessary(NumInstances);
}

/***************************************************************************++

Routine Description:

    Copies counter information into the shared memory.

Arguments:

    IN COUNTER_SET_ENUM     CounterSetId - counter set working with
    IN LPCWSTR              InstanceName - instance name 
    IN ULONG                MemoryOffset - the memory offset for this instance
    IN LPVOID               pCounters    - any counter values to be published
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc - description of the publishing counters
    IN DWORD                cDisplayPropDesc - count of the publishing counters
    IN BOOL                 StructChanged    - whether the memory has changed
    OUT ULONG*              pNewMemoryOffset - the next instances memory offset

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::CopyInstanceInformation(
    IN COUNTER_SET_ENUM CounterSetId,
    IN LPCWSTR              InstanceName,
    IN ULONG                MemoryOffset,
    IN LPVOID               pCounters,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc,
    IN BOOL                 StructChanged,
    OUT ULONG*              pNewMemoryOffset
    )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))
                                    [CounterSetId].CopyInstanceInformation(
                                                        InstanceName,
                                                        MemoryOffset,
                                                        pCounters,
                                                        pDisplayPropDesc,
                                                        cDisplayPropDesc,
                                                        StructChanged,
                                                        pNewMemoryOffset);
}

/***************************************************************************++

Routine Description:

    Updates the control block information so the readers will now pick up
    the counter information from the newly published page.

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::PublishCounters(
    )
{
    DBG_ASSERT ( HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))[SITE_COUNTER_SET].PublishCounterPage();

    (reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))[GLOBAL_COUNTER_SET].PublishCounterPage();

    //
    // Now save the system tick count so we know when the data
    // was updated.  Since we collected the counters every five minutes
    // regardless of requests, this tick count will always be in the 
    // current 49.7 days, so we don't need to worry about data that is
    // older than a tick count could relate.
    //
    m_pManagerMemory->LastUpdatedTickCount = GetTickCount();

    IF_DEBUG ( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Updated last update time to = %d \n",
            m_pManagerMemory->LastUpdatedTickCount
            ));
    }

}

/***************************************************************************++

Routine Description:

    Returns the tick count as it was on the last update.

Arguments:

    None

Return Value:

    DWORD.

--***************************************************************************/
DWORD
PERF_SM_MANAGER::GetLastUpdatedTickCount(
    )
{
    DBG_ASSERT ( !HasWriteAccess() );

    DBG_ASSERT ( m_pManagerMemory );

    return m_pManagerMemory->LastUpdatedTickCount;
}


/***************************************************************************++

Routine Description:

    Sets the amount of time the W3SVC has been running into the 
    _Total instances service time.

Arguments:

    IN DWORD  ServiceUptime  - Number of seconds the w3svc has been running.

Return Value:

    VOID.

--***************************************************************************/
VOID
PERF_SM_MANAGER::UpdateTotalServiceTime(
    IN DWORD  ServiceUptime
    )
{
    DBG_ASSERT ( HasWriteAccess() );
    DBG_ASSERT ( m_pSMObjects );

    ( reinterpret_cast<PERF_SM_WRITER*>( m_pSMObjects))
                     [SITE_COUNTER_SET].UpdateTotalServiceTime(ServiceUptime);
}

/***************************************************************************++

Routine Description:

    Retrieves the actual counter information from the reader.

Arguments:

    IN COUNTER_SET_ENUM CounterSetId - which counter set were interested in.
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal - returns the counter set's global info
    OUT LPVOID* ppData - returns the actual counter blob.

Return Value:

    DWORD.

--***************************************************************************/
DWORD 
PERF_SM_MANAGER::GetCounterInfo(
    IN COUNTER_SET_ENUM CounterSetId,
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
    OUT LPVOID* ppData
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects))
                              [CounterSetId].GetCounterInfo(ppGlobal, ppData);
}

/***************************************************************************++

Routine Description:

   Function will check the last update of the counters and if needed
   will ask WAS to gather counters before we provide the counters to
   the public.  If this is the case then this function will block for a 
   period of time, until the counters are updated.

Arguments:

    None.

Return Value:

    BOOL - true if we have fresh counters, 
           false if we had to go with stale counters.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::EvaluateIfCountersAreFresh(
    )
{
    DWORD LastUpdatedTickCount = GetLastUpdatedTickCount();
    DWORD CurrentTickCount = GetTickCount();
    DWORD NumberOfTickCountsPassed = 0;

    if ( CurrentTickCount < LastUpdatedTickCount )
    {
        // We know that we have wrapped around between the tick counts.
        // We must calculate the change appropriately.

        NumberOfTickCountsPassed = ULONG_MAX - LastUpdatedTickCount + CurrentTickCount;
    }
    else
    {
        NumberOfTickCountsPassed = CurrentTickCount - LastUpdatedTickCount;
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Evaluating if we need to refresh counters.  \n"
            "NumberOfTickCountsPassed = %d; \n"
            "LastUpdatedTickCount starts = %d \n"
            "MillisecondsCountersAreFresh = %d; \n"
            "MaxNumberTimesToCheckCountersOnRefresh = %d \n"
            "MillisecondsToSleepBeforeCheckingForRefresh = %d \n\n",
            NumberOfTickCountsPassed,
            LastUpdatedTickCount,
            m_IIS_MillisecondsCountersAreFresh,
            m_IIS_MaxNumberTimesToCheckCountersOnRefresh,
            m_IIS_MillisecondsToSleepBeforeCheckingForRefresh
            ));
    }


    if ( NumberOfTickCountsPassed > m_IIS_MillisecondsCountersAreFresh )
    {
        //
        // Ask WAS to refresh the counters.
        //
        PingWASToRefreshCounters();

        DWORD NumberOfWaits = 0;
        while ( NumberOfWaits < m_IIS_MaxNumberTimesToCheckCountersOnRefresh )
        {
            IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
            {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "Waiting for the %d time  \n"
                    "CurrentTickCount is = %d \n\n",
                    NumberOfWaits,
                    GetTickCount()
                    ));
            }
            
            Sleep ( m_IIS_MillisecondsToSleepBeforeCheckingForRefresh );
            if ( GetLastUpdatedTickCount() != LastUpdatedTickCount)
            {
                IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
                {
                    DBGPRINTF((
                        DBG_CONTEXT,
                        "Finished waiting, tick count is now set to %d \n"
                        "CurrentTickCount is = %d \n\n",
                        GetLastUpdatedTickCount(),
                        GetTickCount()
                        ));
                }

                // We have new counter values.  We can continue.
                break;
            }

            NumberOfWaits++;
        }

        if ( NumberOfWaits == m_IIS_MaxNumberTimesToCheckCountersOnRefresh )
        {
            //
            // We had to go with stale counters.
            //
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************++

Routine Description:

    Retrieves the snmp counter information from the reader.

Arguments:

    OUT W3_COUNTER_BLOCK**  ppCounterBlock

Return Value:

    DWORD.

--***************************************************************************/
DWORD 
PERF_SM_MANAGER::GetSNMPCounterInfo(
    OUT LPBYTE*  ppCounterBlock
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    DBG_ASSERT ( m_pSMObjects );

    return (reinterpret_cast<PERF_SM_READER*>( m_pSMObjects))
                              [SITE_COUNTER_SET].GetSNMPCounterInfo(ppCounterBlock);
}

/***************************************************************************++

Routine Description:

    Pings the event that tells WAS to refresh counters.

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::PingWASToRefreshCounters(
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    if ( m_hIISSignalCounterRefresh != NULL )
    {
        SetEvent ( m_hIISSignalCounterRefresh );
    }
}


/***************************************************************************++

Routine Description:

    Determines if the control block was setup for a writer to work with.

Arguments:

    None

Return Value:

    BOOL.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::HasWriteAccess(
    )
{ 
    DBG_ASSERT ( m_Initialized );

    return m_WriteAccess; 
}

/***************************************************************************++

Routine Description:

    Determines if we should be releasing memory instead of reading from it.

Arguments:

    None

Return Value:

    BOOL.

--***************************************************************************/
BOOL 
PERF_SM_MANAGER::ReleaseIsNeeded(
    )
{ 
    DBG_ASSERT ( ! HasWriteAccess()  );

    DBG_ASSERT ( m_pManagerMemory  );

    return ( m_pManagerMemory->InitializedCode != 
                                             PERF_COUNTER_INITIALIZED_CODE ) ; 
}


/***************************************************************************++

Routine Description:

    Determines if we have configuration data for how we should wait for
    data to be refreshed before delivering counters.  If we do this will
    set the member variables appropriately

Arguments:

    None

Return Value:

    VOID.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::ResetWaitFreshCounterValues(
    )
{ 

    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;

    DWORD size;
    DWORD type;
    DWORD dwRegSettingValue;


    //
    //  Open the HTTP Server service's Performance key.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_W,
                        0,
                        KEY_QUERY_VALUE,
                        &hkey );

    if( err == NO_ERROR)
    {
     
        //
        // Read in wait limit for counters.
        //

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_FRESH_TIME_FOR_COUNTERS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MillisecondsCountersAreFresh = dwRegSettingValue;
            }
        }

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_CHECK_COUNTERS_EVERY_N_MS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MillisecondsToSleepBeforeCheckingForRefresh
                                                        = dwRegSettingValue;
            }
        }

        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               REGISTRY_VALUE_W3SVC_PERF_NUM_TIMES_TO_CHECK_COUNTERS_W,
                               NULL,
                               &type,
                               (LPBYTE)&dwRegSettingValue,
                               &size );
        if( err == NO_ERROR )
        {
            if ( dwRegSettingValue != 0 )
            {
                m_IIS_MaxNumberTimesToCheckCountersOnRefresh = dwRegSettingValue;
            }
        }

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }
    }
}  // end of ResetWaitFreshCounterValues


/***************************************************************************++

Routine Description:

    Returns the was process handle so the reader can monitor if the process
    goes away.

Arguments:

    None

Return Value:

    HANDLE.

--***************************************************************************/
HANDLE
PERF_SM_MANAGER::GetWASProcessHandle(
    )
{
    DBG_ASSERT ( ! HasWriteAccess() );

    return m_WASProcessHandle;
}


//
// Public PERF_SM_WRITER functions.
// 

/***************************************************************************++

Routine Description:

    Constructor for the PERF_SM_WRITER class.

Arguments:

    None

Return Value:

    None.

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_WRITER::PERF_SM_WRITER(
    )
{

    m_NumInstances = 0;

    m_SizeOfMemory = 0;

    //
    // Default to an illegal value.
    //
    m_CounterSetId = MAX_COUNTER_SET_DEFINES;

    m_MemoryVersionNumber = 0;

    m_UpdateNeeded = FALSE;

    m_ActiveMemoryIsA = TRUE;

    m_pSharedManager = NULL;

    m_pMemoryA = NULL;
    m_pMemoryB = NULL;
    m_hMemoryA = NULL;
    m_hMemoryB = NULL;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_WRITER_SIGNATURE;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::PERF_SM_WRITER



/***************************************************************************++

Routine Description:

    Destructor for the PERF_SM_WRITER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_WRITER::~PERF_SM_WRITER(
    )
{

    DBG_ASSERT( m_Signature == PERF_SM_WRITER_SIGNATURE );

    m_Signature = PERF_SM_WRITER_SIGNATURE_FREED;

    if ( m_pMemoryA )
    {
        UnmapViewOfFile(m_pMemoryA);
        m_pMemoryA = NULL;
    }

    if (m_hMemoryA != NULL)
    {
        CloseHandle(m_hMemoryA);
        m_hMemoryA = NULL;
    }
    
    if ( m_pMemoryB )
    {
        UnmapViewOfFile(m_pMemoryB);
        m_pMemoryB = NULL;
    }

    if (m_hMemoryB != NULL)
    {
        CloseHandle(m_hMemoryB);
        m_hMemoryB = NULL;
    }

}   // PERF_SM_MANAGER::PERF_SM_WRITER::~PERF_SM_WRITER


/***************************************************************************++

Routine Description:

    Initialize the class to represent a counter set that we
    are going to be updating and supporting.

Arguments:

    IN PERF_SM_MANAGER* pSharedManager - Pointer to the shared memory controller.
    IN COUNTER_SET_ENUM CounterSetId   - The counter set this class will represent.
    

Return Value:

    DWORD - Win32 Status Code

--***************************************************************************/

DWORD
PERF_SM_MANAGER::PERF_SM_WRITER::Initialize(
        IN PERF_SM_MANAGER* pSharedManager,
        IN COUNTER_SET_ENUM CounterSetId
        )
{


    DBG_ASSERT ( m_Initialized == FALSE );

    DBG_ASSERT ( pSharedManager );

    DBG_ASSERT ( pSharedManager->HasWriteAccess() );

    DBG_ASSERT ( CounterSetId < MAX_COUNTER_SET_DEFINES );

    m_CounterSetId = CounterSetId;

    //
    // The shared manager is not a ref counted object, however since
    // only the shared manager will create these objects and only the
    // same shared manager will delete these objects, means that the shared
    // manager should always be valid while we hold this pointer.
    //
    m_pSharedManager = pSharedManager;

    m_Initialized = TRUE;

    return ERROR_SUCCESS;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::Initialize

/***************************************************************************++

Routine Description:

    Update the shared memory to be a larger piece if the size of memory
    that we currently has does not have enough room to handle the new number
    of instances we have been passed.

Arguments:

    IN DWORD NumInstances    - The number of instances the class currently has.
    

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
PERF_SM_MANAGER::PERF_SM_WRITER::ReallocSharedMemIfNeccessary(
        IN DWORD NumInstances
        )
{

    DBG_ASSERT( m_Initialized );

    HRESULT hr = S_OK;

    // 
    // Verify that the number of instances that we currently
    // have space for is less than the number of instances that
    // we really need space for.  If it is then resize
    // the memory.
    //
    // If we are in the case where there is only one set of counter
    // values (no instances) then we will never resize.  We will go 
    // through this code once on initialization, because the m_NumInstances
    // won't yet be set to PERF_NO_INSTANCES.
    //
    if ( m_NumInstances != PERF_NO_INSTANCES && m_NumInstances < NumInstances )
    {
     
        //
        // Need to caculate the max size for instance definition data.
        // If the counter type does not support multiple instance definitions
        // then there is no space allocated for instance definition.
        //
        DWORD InstanceDefSpace = 0;

        if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
        {
            m_NumInstances = NumInstances;

            //
            // InstanceDefSpace is equal to the size of a instance definition
            // as defined by perf counters, plus the amount of space needed for
            // the instance name (which follows the instance definition).
            //
            InstanceDefSpace = sizeof(PERF_INSTANCE_DEFINITION) 
                                + (sizeof(WCHAR) * MAX_INSTANCE_NAME );
        }
        else
        {
            //
            // Make sure the shared memory ends up showing 
            // that there will be no instances, but still
            // set the NumInstances to 1 so we do make room
            // for a set of counters.
            //

            m_NumInstances = PERF_NO_INSTANCES;
            NumInstances = 1;
        }

        // 
        // Add space for the global information about the counter set.
        // Then for each instance add space for the 
        // size of the instance definition (which includes the size of the
        // instance name) and the actual counter data.
        //
        m_SizeOfMemory =sizeof(COUNTER_GLOBAL_STRUCT)      
                        + (NumInstances 
                            * ( InstanceDefSpace
                                + g_CounterSetInfo[m_CounterSetId].SizeOfCounterData ));

        // 
        // Up the memory version since we are changing the memory.
        // We can also go ahead and work on page A since any client
        // will not be reading the same version that we are working on.
        //
        m_MemoryVersionNumber++; 

        //
        // If it just became zero (wrap around) then we want to skip it and make
        // it at least 1.  Zero is a special case that means we are
        // not ready with any counters.
        //
        if ( m_MemoryVersionNumber == 0 )
        {
            m_MemoryVersionNumber++; 
        }

        //
        // We will only setup the first page, remember that we need
        // to copy the first page to the second when it is time to 
        // update the second page.
        //
        m_UpdateNeeded = TRUE;

        //
        // We will work on page A for now.  Page B will become active
        // when we have finished updating page A.
        //
        m_ActiveMemoryIsA = TRUE;

        //
        // Hook up to the appropriate files.  Note, if files exist
        // this will attempt to up the version and try again, but only
        // to a point.  If it can't create the files it will then fail.
        //
        hr = MapSetOfCounterFiles ();
        if ( FAILED (hr) )
        {
            goto exit;
        }    

        //
        // Since we are initializing we know that the active memory 
        // is the memory pointed to by m_pMemoryA.
        //
        DBG_ASSERT( m_pMemoryA );

        // Set the number of instances and size of data
        //
        ((COUNTER_GLOBAL_STRUCT*) m_pMemoryA)->NumInstances = 
                            m_NumInstances;

        ((COUNTER_GLOBAL_STRUCT*) m_pMemoryA)->SizeData = 
                            m_SizeOfMemory - sizeof(COUNTER_GLOBAL_STRUCT);

    }
exit:

    return hr;

}   // PERF_SM_MANAGER::PERF_SM_WRITER::ReallocSharedMemIfNeccessary


/***************************************************************************++

Routine Description:

    Routine will increment the total counters for the counter set.

Arguments:

    IN LPVOID               pCounterInstance,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::AggregateTotal(
    IN LPVOID               pCounterInstance,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc
    )
{

    DBG_ASSERT( m_Initialized );

    //
    // If we called AggregateTotal on global's by accident this
    // might happen, and we would want to fix that.
    //
    DBG_ASSERT ( pDisplayPropDesc );

    DBG_ASSERT ( pCounterInstance );

    //
    // Get the CounterBlock pointer for the _Total instance.  This
    // instance is always defined as Offset Zero.
    //
    LPVOID pCounterTotal = GetCounterBlockPtr(0);

    DBG_ASSERT ( pCounterTotal );

    //
    // Now loop through all the counters that will go to the client
    // and add them into the total counter record.
    //
    for (  DWORD  PropDisplayId = 0 ; 
            PropDisplayId < cDisplayPropDesc; 
            PropDisplayId++ )
    {
        //
        // Determine the size of the counter so we know how to 
        // increment it.
        //
        if ( pDisplayPropDesc[PropDisplayId].size == sizeof( DWORD ) )
        {
            DWORD* pDWORDToUpdate = (DWORD*) ( (LPBYTE) pCounterTotal 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            DWORD* pDWORDToUpdateWith =  (DWORD*) ( (LPBYTE) pCounterInstance 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not 
            // happen at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pDWORDToUpdate = *pDWORDToUpdate + *pDWORDToUpdateWith;


        }
        else
        {
            DBG_ASSERT ( pDisplayPropDesc[PropDisplayId].size 
                                                        == sizeof( ULONGLONG ) );

            ULONGLONG* pQWORDToUpdate = (ULONGLONG*) ( (LPBYTE) pCounterTotal 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            ULONGLONG* pQWORDToUpdateWith =  (ULONGLONG*) ( (LPBYTE) pCounterInstance 
                                    + pDisplayPropDesc[PropDisplayId].offset );

            //
            // Based on current configuration of the system.  
            // This is happinging on the main thread.
            // which means that more than one can not 
            // happen at the same time so it does not need to be
            // an interlocked exchange.
            //

            *pQWORDToUpdate = *pQWORDToUpdate + *pQWORDToUpdateWith;

        }
            
    }
    
}  // end of PERF_SM_MANAGER::PERF_SM_WRITER::AggregateTotal


/***************************************************************************++

Routine Description:

    This routine will alter a generic instance definition to represent
    a specific instance.  This includes adding the name to the space after
    the instance as well as copying in the counter values if they are provided

Arguments:

    IN LPCWSTR              InstanceName - Name of the instance
    IN ULONG                MemoryOffset - The key to find the instance data's memory.
    IN LPVOID               pCounters    - Counter block to copy in for the instance.
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc - Description of the counter block
    IN DWORD                cDisplayPropDesc - Number of counters in the block
    IN BOOL                 StructChanged    - Whether the memory has changed, if 
                                               it has then we need to recopy the
                                               instance definition information.
    OUT ULONG*              pNewMemoryOffset - What the next memory offset is for
                                               the next instance that wants to provide
                                               counters.
    
Return Value:

    VOID

--***************************************************************************/

VOID
PERF_SM_MANAGER::PERF_SM_WRITER::CopyInstanceInformation( 
    IN LPCWSTR              InstanceName,
    IN ULONG                MemoryOffset,
    IN LPVOID               pCounters,
    IN PROP_DISPLAY_DESC*   pDisplayPropDesc,
    IN DWORD                cDisplayPropDesc,
    IN BOOL                 StructChanged,
    OUT ULONG*              pNewMemoryOffset
  )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Only copy in the instance definition parts if the particular counter
    // set supports separate instances of it's counters.
    //
    if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
    {
        //
        // Find the instance information block
        //
        PERF_INSTANCE_DEFINITION* pInstDef = 
                                GetInstanceInformationPtr( MemoryOffset );
    
        DBG_ASSERT( pInstDef );
    
        //
        // If the structre has changed then we will need to copy in a 
        // fresh copy of the generic instance definition block.
        //
        if ( StructChanged )
        {
            //
            // If the structure changed we better have an instance name.
            //

            DBG_ASSERT ( InstanceName );

            //
            // Copy a generic instance object into the space.
            //
            memcpy ( pInstDef, &g_PerfInstance, sizeof(g_PerfInstance) );
        }

        //
        // If we have been passed an instance name then we need to 
        // copy it into place and set the appropriate information 
        // about it into the instance definition.
        //
        if ( InstanceName )
        {
            //
            // The name length will include the null terminator.
            //
            DWORD len = wcslen(InstanceName) + 1;

            //
            // If the instance name is too long, we truncate it.
            // 
            // Issue-09/10/2000-EmilyK  Instance Name
            // IIS 5 did not bound the instance name, nor did it have the
            // extra space that we are always allocating.  Need to figure out
            // if we can do this in a better way?
            //
            // This issue will be handled when we do dynamic name sizing.
            //
            if ( len > MAX_INSTANCE_NAME )
            {
                len = MAX_INSTANCE_NAME;
            }

            //
            // Set any non generic properties:  
            //      NameLength is the only non-generic property.
            //
            // Remember len contains the trailing null now.
            //
            pInstDef->NameLength = len * sizeof(WCHAR);

            // 
            // Increment the pInstDef one definiton length,
            // this will set it directly at the correct spot
            // for writing in the InstanceName.
            //
            pInstDef++;

            //
            // copy in len characters of the instance name, this will prevent 
            // us from over copying.  However if len == MAX_INSTANCE_NAME 
            // then we will need to terminate as well.
            //
            wcsncpy ( (LPWSTR) pInstDef, InstanceName, len );

            if ( len == MAX_INSTANCE_NAME )
            {
                ((LPWSTR)pInstDef)[len-1] = L'\0';
            }
        }

    } // end of instance information


    //
    // Next get the pointer to the place where any counter values
    // should be copied.  If we actually have values, we can copy them
    // otherwise we will simply zero the counter values.
    //
    PERF_COUNTER_BLOCK* pCounterBlock = GetCounterBlockPtr( MemoryOffset );
    DBG_ASSERT( pCounterBlock );

    //
    // If we are dealing with the Total instance then we will not have
    // counter values to copy over.  In this case just clear the memory
    // and setup the ByteLength correctly.
    //
    if ( pCounters != NULL )
    {
        //
        // Put the counters into there place.
        //
        memcpy ( pCounterBlock, 
                 pCounters, 
                 g_CounterSetInfo[m_CounterSetId].SizeOfCounterData );

        //
        // Assuming that we have different instances, it means we have a _Total
        // so we will need to aggregate the counters into the total.
        //
        if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
        {
            AggregateTotal ( (LPVOID) pCounterBlock,
                             pDisplayPropDesc,
                             cDisplayPropDesc);
        }
    }
    else
    {
        //
        // If we didn't have counters to copy in (we are dealing with setting 
        // up the _Total record), simply zero out the values and setup the 
        // bytelength field.
        //
        memset ( pCounterBlock, 
                 0, 
                 g_CounterSetInfo[m_CounterSetId].SizeOfCounterData );

        pCounterBlock->ByteLength = 
                  g_CounterSetInfo[m_CounterSetId].SizeOfCounterData;
    }

    //
    // Calculate the start of the next memory reference.
    // The counter block is pointing to the beginning of the counters
    // so all we need to do is add in the size of the counter structure
    // and we know where the next instance should start.
    //

    LPBYTE pStartOfNextInstance = ( LPBYTE ) pCounterBlock 
                         + g_CounterSetInfo[m_CounterSetId].SizeOfCounterData;

    //
    // However we want to return the Offset not the actual memory address, 
    // so we can use it with either file.
    //

    *pNewMemoryOffset = 
             DIFF((LPBYTE) pStartOfNextInstance - (LPBYTE) GetActiveMemory());
    
}

/***************************************************************************++

Routine Description:

    This routine will update the total time the Web Service has been
    running. 

    Note:  It is not exactly usual for the shared manager to know about 
           specific counters, but since it is the only one that should be
           writing to the shared memory directly, it is implemented here.

Arguments:

    None.    

Return Value:

    VOID

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::UpdateTotalServiceTime(
    IN DWORD  ServiceUptime
    )
{
    DBG_ASSERT( m_Initialized );

    //
    // Offset Zero is the _Total instance when there are instances.
    //

    W3_COUNTER_BLOCK* pCounterBlock = (W3_COUNTER_BLOCK*) GetCounterBlockPtr( 0 );
    DBG_ASSERT( pCounterBlock );

    pCounterBlock->ServiceUptime = ServiceUptime;

}


/***************************************************************************++

Routine Description:

    This routine will update the shared manager to display the new 
    counter data to the world.  It will also fix up it's own member
    variables so it will update the correct memory next time.

Arguments:

    None.    

Return Value:

    HRESULT

--***************************************************************************/
VOID
PERF_SM_MANAGER::PERF_SM_WRITER::PublishCounterPage(
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // tell the shared manager to update the information.
    // 
    m_pSharedManager->SetActiveInformation(
                              m_CounterSetId
                            , m_MemoryVersionNumber
                            , m_ActiveMemoryIsA);

    // 
    // change (the writers view) of the active page.
    //

    m_ActiveMemoryIsA = !m_ActiveMemoryIsA;

    //
    // if we need to update this page with
    // the structure of the other page then
    // this is the time.  (This only happens
    // after a version change)
    //
    if ( m_UpdateNeeded )
    {
        DBG_ASSERT ( m_pMemoryA && m_pMemoryB );

        if ( m_ActiveMemoryIsA )
        {
            memcpy( m_pMemoryA, m_pMemoryB, m_SizeOfMemory );
        }
        else
        {
            memcpy( m_pMemoryB, m_pMemoryA, m_SizeOfMemory );
        }

        m_UpdateNeeded = FALSE;
    }
}

// 
// Private PERF_SM_WRITER functions
// 

/***************************************************************************++

Routine Description:

    Figures out which page of shared memory is active from 
    the writers point of view.

Arguments:

    None    

Return Value:

    LPVOID

--***************************************************************************/
LPVOID 
PERF_SM_MANAGER::PERF_SM_WRITER::GetActiveMemory()
{
    DBG_ASSERT( m_Initialized );

    //
    // Since this is the writer class it controls
    // which class is set to be "active" in the manager
    // memory.  Thus it can have a member variable that
    // will keep track of the memory that it wants to 
    // work with.  As long as there is only one 
    // writer instance, this works.
    //

    if (m_ActiveMemoryIsA)
        return m_pMemoryA;
    else
        return m_pMemoryB;
}


/***************************************************************************++

Routine Description:

    Looks up a specific instances counter block and 
    returns a pointer to it.

Arguments:

    IN ULONG MemoryOffset  -  Key to find the specific instances
                                 memory chunk to work on.
    

Return Value:

    HRESULT

--***************************************************************************/

PERF_COUNTER_BLOCK* 
PERF_SM_MANAGER::PERF_SM_WRITER::GetCounterBlockPtr(
    IN ULONG MemoryOffset
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Where the counter block is, is dependent upon whether or not
    // we have instance information stored.
    //
    if ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData )
    {
        // 
        // This will determine the active memory page
        // and figure out where the instance information starts.
        //
        LPBYTE pMemory = (LPBYTE) GetInstanceInformationPtr(MemoryOffset);

        //
        // The counter block directly follows the instance definition
        // and the instance name.
        //
        pMemory += sizeof(PERF_INSTANCE_DEFINITION);
        pMemory += MAX_INSTANCE_NAME * sizeof(WCHAR);

        return (PERF_COUNTER_BLOCK*) pMemory;

    }
    else
    {
        //
        // In the case where we don't have instance information
        // the shared memory points almost directly to the counter block.
        //
        LPBYTE pMemory = (LPBYTE) GetActiveMemory();
        
        //
        // Just offset it by the information describing the block of memory.
        //
        pMemory += sizeof( COUNTER_GLOBAL_STRUCT );

        return (PERF_COUNTER_BLOCK*) pMemory;
    }

}


/***************************************************************************++

Routine Description:

    Function maps two pieces of shared memory with matching version numbers.

Arguments:

    None.    

Return Value:

    HRESULT

Note:

    CreateMemoryFile will close any open files it is handed before 
    creating the new files.

--***************************************************************************/

HRESULT 
PERF_SM_MANAGER::PERF_SM_WRITER::MapSetOfCounterFiles(
         )
{
    HRESULT hr = S_OK;
    DWORD dwErr = ERROR_SUCCESS;

    WCHAR FileName[MAX_FILE_NAME];

    DBG_ASSERT( m_Initialized );

    //
    // Determine the name of the file that we expect to be able to 
    // map to.
    //
    wsprintf(FileName
            , L"%ls_%d_%ls"
            , g_CounterSetInfo[m_CounterSetId].pFilePrefix
            , m_MemoryVersionNumber
            , L"A");

    //
    // Attempt to create the "A" file with the current version.
    //
    dwErr = CreateMemoryFile ( FileName
                        , m_SizeOfMemory
                        , &m_hMemoryA
                        , &m_pMemoryA);

    if ( dwErr == ERROR_ALREADY_EXISTS )
    {
        //
        // If it existed, up the version number and 
        // attempt to create it again.
        //
        m_MemoryVersionNumber++;

        //
        // If it just became zero then we want to skip it and make
        // it at least 1.  Zero is a special case that means we are
        // not ready with any counters.
        //
        if ( m_MemoryVersionNumber == 0 )
        {
            m_MemoryVersionNumber++; 
        }

        wsprintf(FileName
                , L"%ls_%d_%ls"
                , g_CounterSetInfo[m_CounterSetId].pFilePrefix
                , m_MemoryVersionNumber
                , L"A");

        dwErr = CreateMemoryFile (FileName
                            , m_SizeOfMemory
                            , &m_hMemoryA
                            , &m_pMemoryA);

        if (  dwErr != ERROR_SUCCESS )
        {
            //
            // Give up, we have tried two versions.
            //
            hr = HRESULT_FROM_WIN32(dwErr);
            goto exit;
        }
    }
    else
    {
        if ( dwErr != ERROR_SUCCESS )
        {
            //
            // Something other than the file all ready existing
            // happened.  Not good, return the error...
            //
            hr = HRESULT_FROM_WIN32(dwErr);
            goto exit;
        }
    }

    //
    // If we get here, then we created the "A" file, so now 
    // let's work on the "B" file.
    //
    wsprintf(FileName
            , L"%ls_%d_%ls"
            , g_CounterSetInfo[m_CounterSetId].pFilePrefix
            , m_MemoryVersionNumber
            , L"B");

    dwErr = CreateMemoryFile (FileName,
                          m_SizeOfMemory,
                          &m_hMemoryB,
                          &m_pMemoryB);

    if ( dwErr == ERROR_ALREADY_EXISTS )
    {

        //
        // If the "B" file existed then we need to 
        // increment the version number and do it again.
        //
        m_MemoryVersionNumber++;

        //
        // If it just became zero then we want to skip it and make
        // it at least 1.  Zero is a special case that means we are
        // not ready with any counters.
        //
        if ( m_MemoryVersionNumber == 0 )
        {
            m_MemoryVersionNumber++; 
        }

        wsprintf(FileName
                , L"%ls_%d_%ls"
                , g_CounterSetInfo[m_CounterSetId].pFilePrefix
                , m_MemoryVersionNumber
                , L"B");

        dwErr = CreateMemoryFile (FileName
                            , m_SizeOfMemory
                            , &m_hMemoryB
                            , &m_pMemoryB);


        if (  dwErr != ERROR_SUCCESS )
        {
            //
            // We have tried atleast 2 version numbers (maybe 3) so give up 
            // and return the error.
            //
            hr = HRESULT_FROM_WIN32(dwErr);
            goto exit;
        }

        // 
        // We were able to create the B file with the new version number
        // so now we need to create the A file with the same version number.
        //
        wsprintf(FileName
            , L"%ls_%d_%ls"
            , g_CounterSetInfo[m_CounterSetId].pFilePrefix
            , m_MemoryVersionNumber
            , L"A");

        dwErr = CreateMemoryFile (FileName
                            , m_SizeOfMemory
                            , &m_hMemoryA
                            , &m_pMemoryA);


        if ( dwErr != ERROR_SUCCESS  )
        {
            //
            // If this fails then give up.
            //
            hr = HRESULT_FROM_WIN32(dwErr);
            goto exit;
        }

    }
    else
    {
        if ( dwErr != ERROR_SUCCESS )
        {
            // 
            // Again failure = give up.
            //
            hr = HRESULT_FROM_WIN32(dwErr);
            goto exit;
        }
    }


exit:

    // If we have failed then we may have some files mapped and others not.
    // However the destructor for this class will clean up what we have not
    // so don't worry about it hear.

    return hr;

}

/***************************************************************************++

Routine Description:

    Returns the specific instances definition pointer.

Arguments:

    ULONG MemoryOffset  - key to find the instance information from.
    

Return Value:

    HRESULT

--***************************************************************************/

PERF_INSTANCE_DEFINITION* 
PERF_SM_MANAGER::PERF_SM_WRITER::GetInstanceInformationPtr(
    IN ULONG MemoryOffset
    )
{
    DBG_ASSERT( m_Initialized );

    //
    // We should never be looking for instance information on a 
    // counter set that does not expose instances.
    //
    DBG_ASSERT ( g_CounterSetInfo[m_CounterSetId].DefineIncludesInstanceData );

    if ( MemoryOffset == 0 ) 
    {
        MemoryOffset = sizeof ( COUNTER_GLOBAL_STRUCT );
    }

    //
    // Make sure we have atleast enough memory left for the 
    // instance that we are attempting to add.
    //
    ULONG SpaceNeeded = ( MemoryOffset +
                              sizeof(PERF_INSTANCE_DEFINITION) +
                              (MAX_INSTANCE_NAME * sizeof(WCHAR)) +
                              g_CounterSetInfo[m_CounterSetId].SizeOfCounterData ) ;

    DBG_ASSERT ( SpaceNeeded <= m_SizeOfMemory );

    //
    // get the active memory pointer.
    //
    return (PERF_INSTANCE_DEFINITION*) ( ( LPBYTE ) GetActiveMemory() 
                                                   + MemoryOffset );

}


// 
// Public PERF_SM_READER Functions
//

/***************************************************************************++

Routine Description:

    Constructor for the PERF_SM_READER class.

Arguments:
    
    None

Return Value:

    None

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_READER::PERF_SM_READER(
    )
{
    
    m_MemoryVersionNumber = 0;

    m_ActiveMemoryIsA = TRUE;

    m_hMemoryA = NULL;
    m_pMemoryA = NULL;

    m_hMemoryB = NULL;
    m_pMemoryB = NULL;

    m_Initialized = FALSE;

    m_Signature = PERF_SM_READER_SIGNATURE; 

}

//
// Destructor for the PERF_SM_READER Class
//
/***************************************************************************++

Routine Description:

    Destructor for the PERF_SM_READER class.

Arguments:

    None    

Return Value:

    None

--***************************************************************************/

PERF_SM_MANAGER::PERF_SM_READER::~PERF_SM_READER()
{
    DBG_ASSERT( m_Signature == PERF_SM_READER_SIGNATURE );

    m_Signature = PERF_SM_READER_SIGNATURE_FREED;

    if ( m_pMemoryA )
    {
        UnmapViewOfFile(m_pMemoryA);
        m_pMemoryA = NULL;
    }

    if (m_hMemoryA != NULL)
    {
        CloseHandle(m_hMemoryA);
        m_hMemoryA = NULL;
    }
    
    if ( m_pMemoryB )
    {
        UnmapViewOfFile(m_pMemoryB);
        m_pMemoryB = NULL;
    }

    if (m_hMemoryB != NULL)
    {
        CloseHandle(m_hMemoryB);
        m_hMemoryB = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Hooks up to the shared memory that contains the data for counters 
    of the specific set that the class is initialized to.

Arguments:

    IN PERF_SM_MANAGER* pSharedManager - Pointer to the controller of memory.
    IN COUNTER_SET_ENUM CounterSetId   - Identifies the counter set this class
                                         will represent.
    

Return Value:

    DWORD  -  Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::Initialize(
    IN PERF_SM_MANAGER* pSharedManager,
    IN COUNTER_SET_ENUM CounterSetId
    )
{

    //
    // Validate that the world looks correctly.
    //
    DBG_ASSERT ( !m_Initialized );
    DBG_ASSERT ( pSharedManager);
    DBG_ASSERT ( !pSharedManager->HasWriteAccess() );
    DBG_ASSERT ( CounterSetId < MAX_COUNTER_SET_DEFINES );

    //
    // Hold on to the shared manager.
    //
    m_pSharedManager = pSharedManager;

    m_CounterSetId = CounterSetId;

    ConnectToActiveMemory();

    m_Initialized = TRUE;

    //
    // For now we do not error from this initializer.
    // This may change in the future.
    //
    return ERROR_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Returns the counter information from the current block
    of shared memory.

    Note:  Do not hold on to this return info for long, the current block
    could change quickly and you don't want stale info.

Arguments:

    OUT COUNTER_GLOBAL_STRUCT** ppGlobal - Pointer to global info about the counters
    OUT LPVOID* ppData                   - Pointer to the counter info.
    

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::GetCounterInfo(
    OUT COUNTER_GLOBAL_STRUCT** ppGlobal,
    OUT LPVOID* ppData
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Get ahold of the active memory.
    //
    LPBYTE pMemory = (LPBYTE) GetActiveMemory();

    if ( pMemory )
    {
        //
        // Set the pointers and return
        //
        *ppGlobal = (COUNTER_GLOBAL_STRUCT*) pMemory;
        *ppData = (LPVOID) (pMemory + sizeof(COUNTER_GLOBAL_STRUCT));

        return ERROR_SUCCESS;
    }
    else
    {
        *ppGlobal = NULL;
        *ppData = NULL;

        return ERROR_FILE_NOT_FOUND;
    }

}

/***************************************************************************++

Routine Description:

    Returns the _Total site information in a W3_COUNTER_BLOCK form.

Arguments:

    OUT W3_COUNTER_BLOCK**  ppCounterBlock

    Note:  the memory is still owned by the reader object.  do not free it.
           also do not hold on to it for any amount of time because the reader
           could free it.
    

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/

DWORD 
PERF_SM_MANAGER::PERF_SM_READER::GetSNMPCounterInfo(
    OUT LPBYTE*  ppCounterBlock
    )
{
    DBG_ASSERT ( m_Initialized );

    //
    // Get ahold of the active memory.
    //
    LPVOID pMemory = GetActiveMemory();
    LPBYTE pCounterInstance =  ( LPBYTE ) pMemory + sizeof(COUNTER_GLOBAL_STRUCT);

    if ( pMemory )
    {
        //
        // Verify we have at least one instance.  
        // This should be the case because we are getting site information
        // and we always have a _Total Site, even if we don't have 
        // other sites.
        // 
        DBG_ASSERT ( ((COUNTER_GLOBAL_STRUCT*)pMemory)->NumInstances >= 1 );

        //
        // Set the pointers and return
        //

        pCounterInstance += sizeof(PERF_INSTANCE_DEFINITION);
        pCounterInstance += MAX_INSTANCE_NAME * sizeof(WCHAR);

        *ppCounterBlock =  pCounterInstance;

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_FILE_NOT_FOUND;
    }

}
//
// Private PERF_SM_READER functions
//

/***************************************************************************++

Routine Description:

    Return figures out if the current memory snapshots are still active and 
    if not it will drop the current snapshots and map the new ones..

Arguments:

    None.    

Return Value:

    None.

    Note after this function is run the memory pointers may or may not
    return NULL.  If they do return NULL then we just don't have counters
    at this specific time.

--***************************************************************************/
VOID 
PERF_SM_MANAGER::PERF_SM_READER::ConnectToActiveMemory()
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD Version;
    WCHAR ActivePage;
    BOOL  ActivePageIsA;

    //
    // We do not check if we are initialized here, because this can happen
    // while we are initializing.
    //

    // 
    // Use this to create the file name that this class should map to.
    // 
    WCHAR FileName[MAX_FILE_NAME];

    //
    // Get the active version and page from the controller and map to them.
    //
    m_pSharedManager->GetActiveInformation(m_CounterSetId, &Version, &ActivePageIsA);

    if ( ActivePageIsA )
    {
        ActivePage = 'A';
    }
    else
    {
        ActivePage = 'B';
    }

    //
    // If the version is set to zero then no memory is ready for the 
    // counters.  We will not map an memory.
    //
    if ( Version == 0 )
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // If these don't match then we need to remap.
    //
    if ( Version != m_MemoryVersionNumber )
    {
        //
        // create the first file name based on the version number.
        //
        wsprintf(FileName, L"%ls_%d_%lc", g_CounterSetInfo[m_CounterSetId].pFilePrefix, Version, L'A');

        //
        // Attempt to open the memory
        //
        dwErr = OpenMemoryFile(FileName, &m_hMemoryA, &m_pMemoryA);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        //
        // Now go after the 'B' file.
        //
        wsprintf(FileName, L"%ls_%d_%lc", g_CounterSetInfo[m_CounterSetId].pFilePrefix, Version, L'B');
        dwErr = OpenMemoryFile(FileName, &m_hMemoryB, &m_pMemoryB);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        m_MemoryVersionNumber = Version;
    }

    m_ActiveMemoryIsA = ActivePageIsA;

exit:

    if ( dwErr != ERROR_SUCCESS )
    {

        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Could not connect to counter information for counter set %d\n",
            m_CounterSetId
            ));

        //
        // Something is not right, reset all
        // so we are on a clean slate to try again.
        //

        if ( m_pMemoryA )
        {
            UnmapViewOfFile(m_pMemoryA);
            m_pMemoryA = NULL;
        }

        if (m_hMemoryA != NULL)
        {
            CloseHandle(m_hMemoryA);
            m_hMemoryA = NULL;
        }

        if ( m_pMemoryB )
        {
            UnmapViewOfFile(m_pMemoryB);
            m_pMemoryB = NULL;
        }

        if (m_hMemoryB != NULL)
        {
            CloseHandle(m_hMemoryB);
            m_hMemoryB = NULL;
        }

        m_ActiveMemoryIsA = TRUE;

        m_MemoryVersionNumber = 0;

    }

}


/***************************************************************************++

Routine Description:

    Return figures out which block of memory is active and hands back
    a pointer to it's memory.

    Note:  Do not hold on to this return info for long, the current block
    could change quickly and you don't want stale info.

Arguments:

    None.    

Return Value:

    LPVOID - pointer to active memory

    Note:  This routine can and will return NULL when neccessary.

--***************************************************************************/
LPVOID 
PERF_SM_MANAGER::PERF_SM_READER::GetActiveMemory()
{
    DBG_ASSERT( m_Initialized );

    ConnectToActiveMemory();

    if ( m_ActiveMemoryIsA )
    {
        return m_pMemoryA;
    }
    else
    {
        return m_pMemoryB;
    }
}

//
// Generic functions 
//
/***************************************************************************++

Routine Description:

    Creates a Memory Mapped file, open for writting.

Arguments:

     IN LPCWSTR pFileName   - Name of the file to create.
     IN DWORD SizeOfData    - Size of the data the file needs to hold.
     OUT HANDLE* phFile     - Handle to the file
     OUT LPVOID* ppFile     - Pointer to the data in the file

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/
DWORD 
CreateMemoryFile (
     IN LPCWSTR pFileName,
     IN DWORD SizeOfData,
     OUT HANDLE* phFile,
     OUT LPVOID* ppFile
     )
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hFile = NULL;
    LPVOID pFile = NULL;

    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    PSID psidPowerUser = NULL;
    PSID psidSystemOperator = NULL;
    PSID psidLocalSystem = NULL;
    PSID psidAdmin = NULL;
    PACL pACL = NULL;


    EXPLICIT_ACCESS ea[4];

    SECURITY_DESCRIPTOR sd = {0};
    SECURITY_ATTRIBUTES sa = {0};


    DBG_ASSERT(ppFile && phFile);

    // 
    // First release any files that these pointers may
    // currently be pointing to.  If we are resizing then
    // it is completely expected that we may have valid
    // pointers sent in that need to be released first.
    // 

    if ( *ppFile != NULL )
    {
        UnmapViewOfFile(*ppFile);
        *ppFile = NULL;
    }

    if ( *phFile != NULL )
    {
        CloseHandle(*phFile);
        *phFile = NULL;
    }


    //
    // Now go ahead and map the file.
    //
    //
    // Prepare the security pieces for the file mapping.
    // These files we allow read access to any Power Users  
    // or administrators and all access to any Local System 
    // processes.
    //
    
    //
    // Get a sid that represents the Administrators group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinAdministratorsSid,
                                        &psidAdmin );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Administrator SID failed\n"
            ));

        goto exit;
    }

    //
    // Get a sid that represents the POWER_USERS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinPowerUsersSid,
                                        &psidPowerUser );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Power User SID failed\n"
            ));

        goto exit;
    }


    //
    // Get a sid that represents the SYSTEM_OPERATORS group.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinBuiltinSystemOperatorsSid, 
                                        &psidSystemOperator );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating System Operators SID failed\n"
            ));

        goto exit;
    }

    
    //
    // Get a sid that represents LOCAL_SYSTEM.
    //
    dwErr = AllocateAndCreateWellKnownSid( WinLocalSystemSid,
                                        &psidLocalSystem );
    if ( dwErr != ERROR_SUCCESS )
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating Local System SID failed\n"
            ));

        goto exit;
    }
    
    // Initialize an EXPLICIT_ACCESS structure for an ACE.
    // The ACE will allow Everyone read access to the key.

    ZeroMemory(&ea, sizeof(ea));

    //
    // Now setup the access structure to allow POWER_USERS
    // read access.
    //
    //
    // Setup POWER_USERS for read access.
    //
    SetExplicitAccessSettings(  &(ea[0]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidPowerUser );

    //
    // Setup Administrators for read access.
    //
    SetExplicitAccessSettings(  &(ea[1]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidAdmin );

    //
    // Setup System Operators for read access.
    //
    SetExplicitAccessSettings(  &(ea[2]), 
                                FILE_MAP_READ,
                                SET_ACCESS,
                                psidSystemOperator );
  
    //
    // Setup Local System for all access.
    //
    SetExplicitAccessSettings(  &(ea[3]), 
                                FILE_MAP_ALL_ACCESS,
                                SET_ACCESS,
                                psidLocalSystem );

    
    //
    // Create a new ACL that contains the new ACEs.
    //
    dwErr = SetEntriesInAcl(sizeof(ea)/sizeof(EXPLICIT_ACCESS), ea, NULL, &pACL);
    if ( dwErr != ERROR_SUCCESS ) 
    {
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting ACE's into ACL failed.\n"
            ));

        goto exit;
    }

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Initializing the security descriptor failed\n"
            ));

        goto exit;
    } 

    if (!SetSecurityDescriptorDacl(&sd, 
            TRUE,     // fDaclPresent flag   
            pACL, 
            FALSE))   // not a default DACL 
    {  
        dwErr = GetLastError();
        DPERROR(( 
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Setting the DACL on the security descriptor failed\n"
            ));

        goto exit;
    } 

    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    hFile = CreateFileMapping(INVALID_HANDLE_VALUE
                                    , &sa   
                                    , PAGE_READWRITE
                                    , 0
                                    , SizeOfData
                                    , pFileName );

    dwErr = GetLastError();
    if ( dwErr != ERROR_SUCCESS ) 
    {
        goto exit;
    }

    //
    // If we got the file, then we need to map the view of the file.
    //
    pFile = MapViewOfFile(hFile
                        , FILE_MAP_ALL_ACCESS
                        , 0
                        , 0
                        , 0 );

    if ( pFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }
exit:

    //
    // Clean up the security handles used.
    //

    //
    // Function will only free if the 
    // variable is set.  And it will set
    // the variable to NULL once it is done.
    //
    FreeWellKnownSid(&psidPowerUser);
    FreeWellKnownSid(&psidSystemOperator);
    FreeWellKnownSid(&psidLocalSystem);
    FreeWellKnownSid(&psidAdmin);

    if (pACL) 
    {
        LocalFree(pACL);
        pACL = NULL;
    }

    if ( dwErr != ERROR_SUCCESS )
    {
        if (pFile != NULL)
        {
            UnmapViewOfFile(pFile);
            pFile = NULL;
        }

        if (hFile != NULL)
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }
    else
    {
        *ppFile = pFile;
        *phFile = hFile;
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Opens a Memory Mapped file, open for reading.

Arguments:

     IN LPCWSTR pFileName   - Name of the file to open.
     OUT HANDLE* phFile     - Handle to the file
     OUT LPVOID* ppFile     - Pointer to the data in the file

Return Value:

    DWORD - Win32 Error Code

--***************************************************************************/
DWORD
OpenMemoryFile(
    IN LPCWSTR pFileName,
    OUT HANDLE* phFile,
    OUT LPVOID* ppFile
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hFile = NULL;
    LPVOID pFile = NULL;

    DBG_ASSERT(ppFile && phFile);

    // 
    // First release any files that these pointers may
    // currently be pointing to.  If we are resizing then
    // it is completely expected that we may have valid
    // pointers sent in that need to be released first.
    // 

    if ( *ppFile != NULL )
    {
        UnmapViewOfFile(*ppFile);
        *ppFile = NULL;
    }

    if ( *phFile != NULL )
    {
        CloseHandle(*phFile);
        *phFile = NULL;
    }

    hFile = OpenFileMapping(FILE_MAP_READ
                            , FALSE
                            , pFileName);

    if ( hFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }

    pFile = MapViewOfFile(hFile
                        , FILE_MAP_READ
                        , 0
                        , 0
                        , 0 );

    if ( pFile == NULL )
    {
        dwErr = GetLastError();

        goto exit;
    }
exit:

    if ( dwErr != ERROR_SUCCESS )
    {
        if (pFile != NULL)
        {
            UnmapViewOfFile(pFile);
            pFile = NULL;
        }

        if (hFile != NULL)
        {
            CloseHandle(hFile);
            hFile = NULL;
        }
    }
    else
    {
        *ppFile = pFile;
        *phFile = hFile;
    }

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\perfctrs\wmihpp\refresher.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    refresher.cxx

Abstract:

    This is implementation of the refresher object
    for high performance provider for WMI

Author:

    Cezary Marcjan (cezarym)        23-Feb-2000

Revision History:

    cezarym   02-Jun-2000           Updated

--*/


#define _WIN32_DCOM
#include <windows.h>

#include "..\inc\counters.h"
#include "provider.h"
#include "refresher.h"
#include "factory.h"
#include "datasource.h"


//
// The access handle for the object's ID
//

extern LONG g_hID;

//
// The COM object counter (declared in server.cpp)
//

extern LONG g_lObjects;



/***************************************************************************++

Routine Description:

    Constructor for the CRefresher class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CRefresher::CRefresher(
    CHiPerfProvider * pProv,
    CRefresher * pNext
    )
{
    InterlockedIncrement(&g_lObjects);

    //
    // Set the initial reference count to 1, in order to represent the
    // reference owned by the creator of this instance.
    //
    m_RefCount = 1;

    m_pNext = pNext;

    m_pProv = pProv;

    if ( NULL != pProv )
    {
        pProv->AddRef();
    }

    m_pFirstRefreshableObject = 0;
    m_pFirstRefreshableEnum = 0;

}   // CRefresher::CRefresher



/***************************************************************************++

Routine Description:

    Destructor for the CRefresher class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CRefresher::~CRefresher(
    )
{
    //
    // Decrement the global COM object counter
    //

    InterlockedDecrement(&g_lObjects);

    CRefreshableObject * pNextObject;
    for ( ; 0 != m_pFirstRefreshableObject;
            m_pFirstRefreshableObject = pNextObject )
    {
        pNextObject = m_pFirstRefreshableObject->m_pNext;
        delete m_pFirstRefreshableObject;
    }

    CRefreshableEnum * pNextEnum;
    for ( ; 0!=m_pFirstRefreshableEnum; m_pFirstRefreshableEnum=pNextEnum )
    {
        pNextEnum = m_pFirstRefreshableEnum->m_pNext;
        delete m_pFirstRefreshableEnum;
    }

    if ( NULL != m_pProv )
    {
        m_pProv->Release();
        m_pProv = 0;
    }

    _ASSERTE ( m_RefCount == 0 );

}   // CRefresher::~CRefresher



/***************************************************************************++

Routine Description:

    Standard IUnknown::QueryInterface.

Arguments:

    iid - The requested interface id.

    ppObject - The returned interface pointer, or NULL on failure.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CRefresher::QueryInterface(
    REFIID iid,
    PVOID * ppObject
    )
{
    HRESULT hRes = S_OK;

    _ASSERTE ( ppObject != NULL );

    if ( NULL == ppObject )
    {
        hRes = E_INVALIDARG;
        goto exit;
    }

    if ( iid == IID_IUnknown )
    {
        *ppObject = (PVOID)(IUnknown*) this;
    }
    else if ( iid == IID_IWbemRefresher )
    {
        *ppObject = (PVOID)(IWbemRefresher*) this;
    }
    else
    {
        *ppObject = NULL;
        hRes = E_NOINTERFACE;

        goto exit;
    }

    AddRef();


exit:

    return hRes;
}

/***************************************************************************++

Routine Description:

    Standard IUnknown::AddRef.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CRefresher::AddRef(
    )
{
    LONG lNewCount = InterlockedIncrement( &m_RefCount );

    _ASSERTE ( lNewCount > 1 );

    return ( ( ULONG ) lNewCount );

}   // CRefresher::AddRef



/***************************************************************************++

Routine Description:

    Standard IUnknown::Release.

Arguments:

    None.

Return Value:

    ULONG - The new reference count.

--***************************************************************************/

ULONG
STDMETHODCALLTYPE
CRefresher::Release(
    )
{
    LONG lNewCount = InterlockedDecrement( &m_RefCount );

    _ASSERTE ( lNewCount >= 0 );

    if ( lNewCount == 0 )
    {
        delete this;
    }

    return ( ( ULONG ) lNewCount );

}   // CRefresher::Release



/***************************************************************************++

Routine Description:

    Executed to refresh a set of instances bound to the particular 
    refresher.

    In most situations the instance data, such as counter values and 
    the set of current instances within any existing enumerators, would 
    be updated whenever Refresh was called.  Since we are 
    using a fixed set of instances, we are not adding or removing anything
    from the enumerator.

Arguments:

    lFlags  - not used

Return Value:

    WBEM_NO_ERROR

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CRefresher::Refresh(
    IN LONG /* lFlags */
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;

    if ( !m_pProv || !m_pProv )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    CRefreshableObject * pR;
    for ( pR=m_pFirstRefreshableObject; NULL != pR; pR=pR->m_pNext )
    {
        m_pProv->UpdateInstance(pR->InstID());
    }

Exit:

    return hRes;
}



/***************************************************************************++

Routine Description:

    Function adds object instances (counter instances) to the high
    performance enumerator (m_pHiPerfEnum).

Arguments:

    aInstances     -- array of instance access pointers. Some entries may be 0
    dwMaxInstances -- max number of instances in the array

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
STDMETHODCALLTYPE
CRefreshableEnum::AddObjects(
    IWbemObjectAccess * * aInstances,
    DWORD dwMaxInstances
    )
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    IWbemObjectAccess * * aActiveInstances = 0;
    LONG * alIDs = 0;
    LONG lInst = 0;
    LONG lActiveInst = 0;

    if ( NULL == aInstances || NULL == m_pHiPerfEnum )
    {
        hRes = WBEM_E_INVALID_PARAMETER;
        goto Exit;
    }

    aActiveInstances = new IWbemObjectAccess * [dwMaxInstances];
    if ( !aActiveInstances )
    {
        hRes = E_OUTOFMEMORY;
        goto Exit;
    }

    alIDs = new LONG[dwMaxInstances];
    if ( !aActiveInstances )
    {
        hRes = E_OUTOFMEMORY;
        delete[] aActiveInstances;

        goto Exit;
    }

    for ( lInst=0, lActiveInst=0; lInst<(LONG)dwMaxInstances; lInst++)
    {
        if ( NULL != aInstances[lInst] )
        {
            aInstances[lInst]->AddRef();
            aActiveInstances[lActiveInst] = aInstances[lInst];

            alIDs[lActiveInst] = lInst;
            lActiveInst++;
        }
    }

    hRes = m_pHiPerfEnum->AddObjects(
                                0L,
                                lActiveInst,
                                alIDs,
                                aActiveInstances
                                );

    delete[] alIDs;
    delete[] aActiveInstances;

Exit:

    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\setup2\makefile.inc ===
copyfiles:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\setup\makefile.inc ===
copyfiles:
        binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) .\setup.bat
        binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) .\update.bat
        binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) .\duct-tape-install.reg
        binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) .\duct-tape-uninstall.reg
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\dll\mib.cxx ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.cxx

   Abstract:

      This defines Auxiliary functions for defining an SNMP Extension Agent
         for collecting and querying Statistical information.

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Feb-1995
       Emily  B. Kruglick    ( EmilyK)       02-Nov-2000  ( converted for IIS 6 )

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  ResolveVarBinding();
     UINT  MibStatisticsWorker();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "mib.h"

#include "wasdbgut.h"

static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  );

static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics
  );


static VOID
PrintAsnObjectIdentifier( IN char * pszOidDescription,
                          IN AsnObjectIdentifier * pAsno)
{

# if DBG

    UINT len = pAsno->idLength;
    UINT i;

    DBG_ASSERT( pAsno != NULL);

    DBGPRINTF( ( DBG_CONTEXT,
                "Printing Oid %s = %08x. Length = %u.\n",
                pszOidDescription,
                pAsno, len));

    for(i = 0; i < len; i++) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "AsnOid[ %u] = %u\n",
                    i, pAsno->ids[i]));
    }

# endif // DBG

    return;
} // PrintAsnObjectIdentifier()



/************************************************************
 *    Functions
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind   * pRfcVarBinding,
   IN BYTE                   pduAction,
   IN LPVOID                 pStatistics,
   IN LPMIB_ENTRIES          pMibEntries
  )
/*++
  Description:
    This function resolves a single variable binding. Modifies the variable
       on a GET or a GET-NEXT.

  Arguments:
     pRfcVarBinding    pointer to RFC Variable Bindings
     pduAction      Protocol Data Unit Action specified.
     pStatistics    pointer to statisitcs data structure containing
                      values of counter data.
     pMibEntries    pointer to MIB_ENTRIES context information
                      which contains prefix, array of MIB_ENTRIES and
                      count of the entries.
  Returns:
    Standard PDU error codes.

  Note:
--*/
{
    AsnObjectIdentifier  AsnTempOid;
    LPMIB_ENTRY  pMibScan;
    UINT         pduResult = SNMP_ERRORSTATUS_NOERROR;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // Search for the variable binding name in the mib.
    //

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding( Var=%08x, Action=%x) called.\n",
                    pRfcVarBinding, pduAction));

        PrintAsnObjectIdentifier( " Variable to Resolve",
                                 &pRfcVarBinding->name);
    }

    for( pMibScan = pMibEntries->prgMibEntry;
        pMibScan < pMibUpperBound;
        pMibScan++) {

        int iCmpResult;

        //
        // Create a fully qualified OID for the current item in the MIB.
        //  and use it for comparing against variable to be resolved.
        //

        SNMP_oidcpy( &AsnTempOid, pMibEntries->pOidPrefix);
        SNMP_oidappend( &AsnTempOid, &pMibScan->asnOid);

        iCmpResult = SNMP_oidcmp( &pRfcVarBinding->name, &AsnTempOid);
        SNMP_oidfree( &AsnTempOid);

        IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Comparing with suffix Oid  %08x yields %d\n",
                        &pMibScan->asnOid, iCmpResult));
            PrintAsnObjectIdentifier( " StatisticsSuffix",
                                      &pMibScan->asnOid);
        }

        if ( iCmpResult == 0) {

            //
            // Found a match. Stop the search and process.
            //

            break;

        } else
          if ( iCmpResult < 0) {

              //
              // This could be the OID of a leaf ( withoug a trailing 0) or
              //  it could contain an invalid OID ( between valid OIDs).
              //

              if ( pduAction == MIB_GETNEXT) {

                  //
                  // Advance the variable binding to next entry
                  //
                  SNMP_oidfree( &pRfcVarBinding->name);
                  SNMP_oidcpy( &pRfcVarBinding->name,
                                pMibEntries->pOidPrefix);
                  SNMP_oidappend( &pRfcVarBinding->name, &pMibScan->asnOid);

                  if ( ( pMibScan->bType != ASN_RFC1155_OPAQUE) &&
                       ( pMibScan->bType != ASN_SEQUENCE)) {

                      pduAction = MIB_GET;
                  }

              } else {

                  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
              }

              //
              // Stop and process the appropriate entry.
              //

              break;
          } // ( iCmpResult < 0)

    } // for


    if ( pMibScan >= pMibUpperBound) {

        pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // A match is found or further processing is required.
        //

        DBG_ASSERT( pMibScan < pMibUpperBound);
        if ( pMibScan->pMibFunc == NULL) {

            //
            // This happens only if the match is for Group OID
            //

            pduResult = ( ( pduAction != MIB_GETNEXT) ?
                       SNMP_ERRORSTATUS_NOSUCHNAME:
                         MibGetNextVar( pRfcVarBinding,
                                       pMibScan,
                                       pMibEntries,
                                       pStatistics));
        } else {

            pduResult = ( pMibScan->pMibFunc) ( pRfcVarBinding,
                                               pduAction,
                                               pMibScan,
                                               pMibEntries,
                                               pStatistics);
        }
    }


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT ) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ResolveVarBinding returns %u.\n",
                    pduResult));
    }

    return ( pduResult);

} // ResolveVarBinding()



UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT   pduResult = SNMP_ERRORSTATUS_NOERROR;
                 // default indicating action to be done at end of switch

    switch( pduAction) {

      case MIB_SET:
      case MIB_GETNEXT:

        // action is performed at the end of switch statement.
        break;


      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  If no statistics do no action.
        //  If this is the header field ( non-leaf) do no action
        //   Otherwise, perform action as if this is the leaf node.
        //

        if ( pStatistics == NULL || pMibeCurrent->lFieldOffset == -1) {

            pduResult = SNMP_ERRORSTATUS_GENERR;
        }

        // Action on this node is performed at the end of the switch statement.
        break;

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch()


    if ( pduResult == SNMP_ERRORSTATUS_NOERROR) {

        //
        // Use the generic leaf function to perform the action specified.
        //
        pduResult = MibLeafFunction( pRfcVarBinding, pduAction, pMibeCurrent,
                                    pMibEntries, pStatistics);
    }

    return ( pduResult);

} // MibStatisticsWorker()


static UINT
MibLeafFunction(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
  )
/*++
  This function resolves the variables assuming that there is statistical
    information ( sequence of counters) in the data passed in pStatistics
    and that this is a leaf node of the MIB tree.
  This is a generic function for leaf nodes.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pduAction     protocol data unit action to be taken.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.


  Returns:
    Standard PDU error codes.

--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;  // default is error value.

    switch( pduAction ) {

      case MIB_GETNEXT:

        //
        //  Determine if we're within the range and not at the end.
        //  If not within the range the above default pduResult == NOSUCHNAME
        //         is the required error message.
        //

        if ( ( pMibeCurrent >= pMibEntries->prgMibEntry) &&
             ( pMibeCurrent <
              ( pMibEntries->prgMibEntry + pMibEntries->cMibEntries))) {

            pduResult = MibGetNextVar( pRfcVarBinding,
                                      pMibeCurrent,
                                      pMibEntries,
                                      pStatistics);
        }

        break;

      case MIB_GETFIRST:
      case MIB_GET:

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //  If the access prohibits from GETting it, report error as
        //    NOSUCHNAME ( default value of pduResult in initialization above)
        //

        if(( pMibeCurrent->uiAccess == MIB_ACCESS_READ ) ||
           ( pMibeCurrent->uiAccess == MIB_ACCESS_READWRITE ) ) {

            DWORD  dwValue;

            //
            //  Setup pRfcVarBinding's return value.
            //

            DBG_ASSERT( pStatistics != NULL);

            pRfcVarBinding->value.asnType = pMibeCurrent->bType;
            dwValue = *( (LPDWORD )((LPBYTE )pStatistics +
                                    pMibeCurrent->lFieldOffset));

            pduResult = SNMP_ERRORSTATUS_NOERROR;  // we found a value.

            switch( pMibeCurrent->bType)  {

              case ASN_RFC1155_GAUGE:
                pRfcVarBinding->value.asnValue.gauge = (AsnGauge ) dwValue;
                break;

              case ASN_RFC1155_COUNTER:
                pRfcVarBinding->value.asnValue.counter = (AsnCounter ) dwValue;
                break;

              case ASN_INTEGER:
                pRfcVarBinding->value.asnValue.number = (AsnInteger ) dwValue;
                break;

              case ASN_RFC1155_IPADDRESS:
              case ASN_OCTETSTRING:
                //
                //  Not supported for this MIB (yet).
                //  Fall through to indicate generic error.
                //

              default:

                //
                // Sorry! Type in Mibe does not suit our purpose.
                //   Indicate generic error.
                //
                pduResult = SNMP_ERRORSTATUS_GENERR;
                break;
            } // innner switch

        } // if ( valid read access)

        break;

      case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //   Fall through for error.
        //

      default:
        pduResult = SNMP_ERRORSTATUS_GENERR;
        break;
    } // switch ( pduAction)


    return ( pduResult);

} // MibLeafFunction()





static UINT
MibGetNextVar(
   IN OUT RFC1157VarBind    *  pRfcVarBinding,
   IN MIB_ENTRY             *  pMibeCurrent,
   IN MIB_ENTRIES           *  pMibEntries,
   IN LPVOID                   pStatistics)
/*++
  Description:
     This function sets the binding variable to iterate to the next variable.

  Arguments:
     pRfcVarBind   pointer to RFC variable binding to be resolved.
     pMibeCurrent  pointer to MIB_ENTRY which is o be used for resolution.
     pMibEntries   pointer to MIB_ENTRIES structure to be used
                     as context for resolving and performing the action.
     pStatistics   pointer to sequence of counters used for data resolution.

  Returns:
     PDU Error Codes.
--*/
{
    UINT  pduResult = SNMP_ERRORSTATUS_NOSUCHNAME;
    LPMIB_ENTRY pMibUpperBound =
      pMibEntries->prgMibEntry + pMibEntries->cMibEntries;

    //
    // If within the range of MIB ENTRIES process.
    //

    if ( pMibeCurrent >= pMibEntries->prgMibEntry) {

        //
        //  Scan through the remaining MIB Entries
        //

        LPMIB_ENTRY  pMibeScan;

        for( pMibeScan = pMibeCurrent+1;
             pMibeScan < pMibUpperBound;
             pMibeScan++ ) {

            //
            // Setup variable bindings for the next MIB variable
            //

            SNMP_oidfree( &pRfcVarBinding->name);
            SNMP_oidcpy( &pRfcVarBinding->name, pMibEntries->pOidPrefix);
            SNMP_oidappend( &pRfcVarBinding->name, &pMibeScan->asnOid);

            //
            //  If the function pointer is not NULL and the type of the MIB
            //  variable is anything but OPAQUE, then call the function to
            //  process the MIB variable.
            //

            if(( pMibeScan->pMibFunc != NULL ) &&
               ( pMibeScan->bType    != ASN_RFC1155_OPAQUE ) ) {

                pduResult = ( pMibeScan->pMibFunc)( pRfcVarBinding,
                                                   MIB_GETFIRST,
                                                   pMibeScan,
                                                   pMibEntries,
                                                   pStatistics);
                break;
            }

            //
            // On failure in the scan, pduResult will have default value
            //    as initialized above in declaration.
            //

        } // for
    }

    return ( pduResult);

} // MibGetNextVar()

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\dll\mib.h ===
/*++  BUILD Version: 001   // Increment this if a change has global effects

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      mib.h

   Abstract:

     Generic Macros and Functions for SNMP Extension Agent for
       gathering statistics information for Internet Services on NT.

   Author:

       Murali R. Krishnan    ( MuraliK )    22-Feb-1995

   Environment:

      User Mode -- Win32

   Project:

      HTTP Server SNMP MIB DLL

   Revision History:

--*/

# ifndef _MIB_H_
# define _MIB_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>


/************************************************************
 *    Symbolic Constants
 ************************************************************/

//
//  MIB function actions.
//

#define MIB_GET         ( ASN_RFC1157_GETREQUEST)
#define MIB_SET         ( ASN_RFC1157_SETREQUEST)
#define MIB_GETNEXT     ( ASN_RFC1157_GETNEXTREQUEST)
#define MIB_GETFIRST    ( ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0 )


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3



/************************************************************
 *   Type Definitions
 ************************************************************/


typedef UINT ( * LPMIBFUNC)(
                            RFC1157VarBind    *  pRfcVarBind,
                            UINT                 Action,
                            struct _MIB_ENTRY *  pMibeCurrent,
                            struct _MIB_ENTRIES* pMibEntries,
                            LPVOID               pStatistics
                            );


typedef struct _MIB_ENTRY  {

    AsnObjectIdentifier   asnOid;       // OID for mib variable
    LONG                  lFieldOffset; // filed offset
    UINT                  uiAccess;     // type of accesss( R, W, R/W, None)
    LPMIBFUNC             pMibFunc;     // ptr to function managing this var.
    BYTE                  bType;        // Type( integer, counter, gauage).

} MIB_ENTRY, FAR * LPMIB_ENTRY;


typedef struct  _MIB_ENTRIES {

    AsnObjectIdentifier  *  pOidPrefix;  // Oid with prefix for MIB ENTRIES
    int                     cMibEntries; // count of MIB_ENTRIES in the array
    LPMIB_ENTRY             prgMibEntry; // ptr to array of MIB_ENTRIES

} MIB_ENTRIES, FAR * LPMIB_ENTRIES;


/************************************************************
 *    Macros convenient for defining above MIB_ENTRY objects
 ************************************************************/

//
// GET_OID_LENGTH( oid)  gets the length of the oid.
//

# define  GET_OID_LENGTH( oid)           ((oid).idLength)

//
//  Macro to determine number of sub-oid's in an array of UINTs.
//

#define OID_SIZEOF( uiArray )      ( sizeof( uiArray) / sizeof(UINT) )

//
// OID_FROM_UINT_ARRAY():  Macro to define OID from an Array of UINTs
//
# define OID_FROM_UINT_ARRAY( uiArray)   { OID_SIZEOF( uiArray), uiArray }


//
// Macros for creating MIB Entries ( as specified in struct _MIB_ENTRY above)
//  MIB_ENTRY_HEADER:  creates a generic MIB_ENTRY for a MIB group header.
//  MIB_ENTRY_ITEM:    creates a generic MIB_ENTRY for a MIB variable.
//  MIB_COUNTER:       creates a counter type MIB_ENTRY
//  MIB_INTEGER:       creates an integer type MIB_ENTRY
//

# define MIB_ENTRY_HEADER( oid)             \
           {   oid,                         \
               -1,                          \
               MIB_NOACCESS,                \
               NULL,                        \
               ASN_RFC1155_OPAQUE,          \
           }

# define MIB_ENTRY_ITEM( oid, offset, access, type, func)  \
           {   oid,            \
               offset,         \
               access,         \
               ( func),        \
               ( type),        \
           }

# define MIB_COUNTER( oid, field, func)    \
     MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_RFC1155_COUNTER, func)

# define MIB_INTEGER( oid, field, func)    \
           MIB_ENTRY_ITEM( oid, field, MIB_ACCESS_READ, ASN_INTEGER, func)



/************************************************************
 *    Function Prototypes
 ************************************************************/

UINT
ResolveVarBinding(
   IN OUT RFC1157VarBind * pRfcVarBinding,
   IN BYTE                 pduAction,
   IN LPVOID               pStatistics,
   IN LPMIB_ENTRIES        pMibEntries
  );


UINT
MibStatisticsWorker(
   IN OUT RFC1157VarBind  * pRfcVarBinding,
   IN UINT                  pduAction,
   IN struct _MIB_ENTRY   * pMibeCurrent,
   IN struct _MIB_ENTRIES * pMibEntries,
   IN LPVOID                pStatistics
   );



# endif // _MIB_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\test\main.cpp ===
#include "iis.h"
#include "stdio.h"

#define g_Usage L"Usage\n"
#define g_NotUsage L"NotUsage\n"

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    HRESULT hr = S_OK;

    if ( ( argc < 4 ) || ( argc > 5 ) )
    {
        wprintf( g_Usage );
        goto exit;
    }
	else
	{
		wprintf( g_NotUsage );
	}


exit:

    return ( INT ) hr;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\dll\main.cxx ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Http Service on Windows NT.

Created:

  MuraliK   22-Feb-1995

Revision History:
  Murali R. Krishnan (MuraliK)  16-Nov-1995 Removed undoc apis

--*/

/************************************************************
 *   Include Headers
 ************************************************************/

# include "wasdbgut.h"
# include "mib.h"
# include "apiutil.h"
# include "regconst.h"


# include "iis64.h"

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

UINT
W3QueryStatisticsFromSharedMemory(
    LPW3_STATISTICS_1  pHttpStatistics
    );


/************************************************************
 *   Variable Definitions
 ************************************************************/

//
// Definition of the MIB objects
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          HttpServer(3)
//                                              HttpStatistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

static UINT   sg_rguiPrefix[] =  { 1, 3, 6, 1, 4, 1, 311, 1, 7, 3};
static AsnObjectIdentifier sg_MibOidPrefix =
                      OID_FROM_UINT_ARRAY( sg_rguiPrefix);

# define HTTP_PREFIX_OID_LENGTH    ( GET_OID_LENGTH( sg_MibOidPrefix))

# define HTTP_STATISTICS_OID_SUFFIX            ( 1)


//
// Following is the global description of all MIB Entries ( Mibe s) for
//   Http Service.
// Definition appears as:
//  Mibe( MIB Entry Name, Index in MIB Block, HttpStatisticsField)
//
//   Incidentally, MIB Entry suffix coincides with the entry name in OID Tree
//
//  Any New MIB should be added here. and dont change use of after this defn.
//

# define ALL_MIB_ENTRIES()    \
Mibe( TotalBytesSent_HighWord,     1,    TotalBytesSent.HighPart)       \
Mibe( TotalBytesSent_LowWord,      2,    TotalBytesSent.LowPart)        \
Mibe( TotalBytesReceived_HighWord, 3,    TotalBytesReceived.HighPart)   \
Mibe( TotalBytesReceived_LowWord,  4,    TotalBytesReceived.LowPart)    \
Mibe( TotalFilesSent,              5,    TotalFilesSent)                \
Mibe( TotalFilesReceived,          6,    TotalFilesReceived)            \
Mibe( CurrentAnonymousUsers,       7,    CurrentAnonymousUsers)         \
Mibe( CurrentNonAnonymousUsers,    8,    CurrentNonAnonymousUsers)      \
Mibe( TotalAnonymousUsers,         9,    TotalAnonymousUsers)           \
Mibe( TotalNonAnonymousUsers,      10,   TotalNonAnonymousUsers)        \
Mibe( MaxAnonymousUsers,           11,   MaxAnonymousUsers)             \
Mibe( MaxNonAnonymousUsers,        12,   MaxNonAnonymousUsers)          \
Mibe( CurrentConnections,          13,   CurrentConnections)            \
Mibe( MaxConnections,              14,   MaxConnections)                \
Mibe( ConnectionAttempts,          15,   ConnectionAttempts)            \
Mibe( LogonAttempts,               16,   LogonAttempts)                 \
Mibe( TotalOptions,                17,   TotalOptions)                  \
Mibe( TotalGets,                   18,   TotalGets)                     \
Mibe( TotalPosts,                  19,   TotalPosts)                    \
Mibe( TotalHeads,                  20,   TotalHeads)                    \
Mibe( TotalPuts ,                  21,   TotalPuts)                     \
Mibe( TotalDeletes ,               22,   TotalDeletes)                  \
Mibe( TotalTraces ,                23,   TotalTraces)                   \
Mibe( TotalMove,                   24,   TotalMove)                     \
Mibe( TotalCopy,                   25,   TotalCopy)                     \
Mibe( TotalMkcol,                  26,   TotalMkcol)                    \
Mibe( TotalPropfind,               27,   TotalPropfind)                 \
Mibe( TotalProppatch,              28,   TotalProppatch)                \
Mibe( TotalSearch,                 29,   TotalSearch)                   \
Mibe( TotalLock,                   30,   TotalLock)                     \
Mibe( TotalUnlock,                 31,   TotalUnlock)                   \
Mibe( TotalOthers,                 32,   TotalOthers)                   \
Mibe( CurrentCGIRequests,          33,   CurrentCGIRequests)            \
Mibe( CurrentBGIRequests,          34,   CurrentBGIRequests)            \
Mibe( TotalCGIRequests,            35,   TotalCGIRequests)              \
Mibe( TotalBGIRequests,            36,   TotalBGIRequests)              \
Mibe( MaxCGIRequests,              37,   MaxCGIRequests)                \
Mibe( MaxBGIRequests,              38,   MaxBGIRequests)                \
Mibe( CurrentBlockedRequests,      39,   CurrentBlockedRequests)        \
Mibe( TotalBlockedRequests,        40,   TotalBlockedRequests)          \
Mibe( TotalAllowedRequests,        41,   TotalAllowedRequests)          \
Mibe( TotalRejectedRequests,       42,   TotalRejectedRequests)         \
Mibe( TotalNotFoundErrors,         43,   TotalNotFoundErrors)           \
Mibe( TotalLockedErrors,           44,   TotalLockedErrors)             \
Mibe( MeasuredBandwidth,           45,   MeasuredBw)                    \
Mibe( CurrentCalAuth,              46,   CurrentCalAuth)                \
Mibe( MaxCalAuth,                  47,   MaxCalAuth)                    \
Mibe( TotalFailedCalAuth,          48,   TotalFailedCalAuth)            \
Mibe( CurrentCalSsl,               49,   CurrentCalSsl)                 \
Mibe( MaxCalSsl,                   50,   MaxCalSsl)                     \
Mibe( TotalFailedCalSsl,           51,   TotalFailedCalSsl)


//
// Individual OID Definitions.
//   All Leaf variables should have a zero appended to their OID to indicate
//   that it is the only instance of this variable and that it exists.
//  Declare just the id's starting from next to the prefix given above.
//


//
// Few Convenience Macros for MIB entries addition.
//

# define MIB_VAR_NAME( NameSuffix)       MIB_ ## NameSuffix

# define DEFINE_MIBOID( NameSuffix, uiArray)   \
           UINT MIB_VAR_NAME( NameSuffix)[] = uiArray

# define DEFINE_MIBOID_LEAF( NameSuffix, NodeNumber) \
           UINT MIB_VAR_NAME( NameSuffix)[] = \
                          { HTTP_STATISTICS_OID_SUFFIX, ( NodeNumber), 0 }

//
// Define all the OIDs. First define the higher level node and then leaves.
//
DEFINE_MIBOID( Statistics,     { HTTP_STATISTICS_OID_SUFFIX} );

//
//  Define the Leaf OIDs.
//
# define Mibe( NameSuffix, Index, FieldName)  \
     DEFINE_MIBOID_LEAF( NameSuffix, Index);

//
// Expand the macro ALL_MIB_ENTRIES to obtain definitions of MIB Leafs.
//
ALL_MIB_ENTRIES()

# undef Mibe


//
//  MIB Variable definition
//

//
// Define Mibe()  to be for variable definitions of counters.
//  Note that the comma is appearing before a new counter name. It is used
//   for structure initialization.
//

# define OFFSET_IN_HTTP_STATISTICS( Field)    \
     FIELD_OFFSET( W3_STATISTICS_1,   Field)

# define Mibe( NameSuffix, Index, Field)        \
     , MIB_COUNTER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( NameSuffix)), \
                    OFFSET_IN_HTTP_STATISTICS(Field),              \
                    MibStatisticsWorker)

static MIB_ENTRY  sg_rgHttpMib[] = {

    //
    // Statistics
    //

    MIB_ENTRY_HEADER( OID_FROM_UINT_ARRAY( MIB_VAR_NAME( Statistics)))
    ALL_MIB_ENTRIES()
};

# undef Mibe




static MIB_ENTRIES  sg_HttpMibs =
  {
    &sg_MibOidPrefix,
    ( sizeof( sg_rgHttpMib) / sizeof( MIB_ENTRY)),
    sg_rgHttpMib
  };



/*
#ifndef _NO_TRACING_
#include <initguid.h>
DEFINE_GUID(IisW3MibGuid, 
0x784d891C, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#else
DECLARE_DEBUG_VARIABLE();
#endif
*/

/************************************************************
 *    Functions
 ************************************************************/


BOOL  WINAPI
DllLibMain(
     IN HINSTANCE hinstDll,
     IN DWORD     fdwReason,
     IN LPVOID    lpvContext OPTIONAL)
/*++

 Routine Description:

   This function DllLibMain() is the main initialization function for
    Http MIB DLL. It initialises local variables and prepares the
    interface for the process to use SNMP Extension Agents for HTTP service.

 Messages            Actions

    ProcessAttach        Initializes winsock and data structures.
                          It fails if winsock has not already been started.

    ProcessDetach        Cleans up local data structures and disconnects from
                         winsock.

 Arguments:

   hinstDll          Instance Handle of the DLL
   fdwReason         Reason why NT called this DLL
   lpvReserved       Reserved parameter for future use.

 Return Value:

    Returns TRUE is successful; otherwise FALSE is returned.

--*/
{
  DWORD Success = ERROR_SUCCESS;

  switch (fdwReason ) {

    case DLL_PROCESS_ATTACH: {

        //
        // Initialize various modules
        //

        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        break;
    } /* case DLL_PROCESS_ATTACH */

    case DLL_PROCESS_DETACH: {

       //
       // Only cleanup when we are called because of a FreeLibrary().
       //  i.e., when lpvContext == NULL
       // If we are called because of a process termination, dont free anything
       //   the system will free resources and memory for us.
       //

       if ( lpvContext == NULL) {

           //
           // Code to be executed on successful termination
           //

           DELETE_DEBUG_PRINT_OBJECT();
       }


       break;
   } /* case DLL_PROCESS_DETACH */

   default:
       break;
  }    /* switch */
exit:

  return ( Success );
}  /* DllLibMain() */





/************************************************************
 *  Entry Points of SNMP Extension DLL For Http Service
 ************************************************************/

//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;




BOOL
SnmpExtensionInit(
    IN  DWORD                 dwTimeZeroReference,
    OUT HANDLE              * phPollForTrapEvent,
    OUT AsnObjectIdentifier * pAsnOidSupportedView
    )
/*++
  Description:
     The Extension Agent DLLs provide this entry point SnmpExtensionInit()
     to co-ordinate the initializations of the extension agent and the
     extendible  agent.
     The Extendible agent provides extension agent with a time zero reference.
     The Extension Agent provides Extendible agent with an Event Handle
         for communicating occurences of traps.
     The Extension Agent also provides Extendible agent with an ObjectId
         representing the root of the MIB structure
         that it (extension) supports.

  Arguments:
     dwTimeZeroReference    DWORD containing the Time Zero Reference for sync.
     phPollForTrapEvent     pointer to handle which on successful return
                             may contain an event handle to be polled for
                             traps.
     pAsnOidSupportedView   pointer to ASN ( Abstract Syntax Notation OID)
                             that contains the oid representing root of the
                             MIB structure.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{


    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *pAsnOidSupportedView = sg_MibOidPrefix; // NOTE!  structure copy

    //
    // Though the following is a handle, dont use INVALID_HANDLE_VALUE ( -1)
    //  because that constant is only for few people ( Win32). But all through
    //  NT invalid handle value is NULL ( 0).
    //

    *phPollForTrapEvent = NULL;

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return ( TRUE);

}   // SnmpExtensionInit()


BOOL
SnmpExtensionTrap(
    OUT AsnObjectIdentifier * pAsnOidEnterprise,
    OUT AsnInteger          * pAsniGenericTrap,
    OUT AsnInteger          * pAsniSpecificTrap,
    OUT AsnTimeticks        * pAsnTimeStamp,
    OUT RFC1157VarBindList  * pRfcVariableBindings
    )
/*++
  Description:
     This function is used to communicate traps to the Extendible Agent.
     The Extendible Agent will invoke this entry point when the trap event
      ( supplied at the initialization time) is asserted, which indicates
      that zero or more traps had occured.
     The Extendible agent will repeatedly query this function till this
      function returns FALSE.

  Arguments:
    pAsnOidEnterprise      pointer to ASN OID for Enterprise, indicating
                             original enterprise generating trap.
    pAsniGenericTrap       pointer to ASN Integer which on return will
                             contain the indication of the generic trap.
    pAsniSpecificTrap      pointer to ASN Integer which on return will
                             contain the specific trap generated.
    pAsnTimeStamp          pointer to ASN containing the received Time-Stamp.
    pRfcVariableBindings   pointer to RFC 1157 compliant variable bindings.


  Returns:
    TRUE if success and there are more traps to be queried.
    FALSE if all traps are answered and work done.

--*/
{

    //
    //  We don't support traps (yet).
    //

    return ( FALSE);

}   // SnmpExtensionTrap()


BOOL
SnmpExtensionQuery(
    IN BYTE                     bRequestType,
    IN OUT RFC1157VarBindList * pRfcVariableBindings,
    OUT AsnInteger         *    pAsniErrorStatus,
    OUT AsnInteger         *    pAsniErrorIndex
    )
/*++
  Description:
    This function is called by Extendible Agent to resolve the SNMP requests
    for queries on MIB Variables in the Extension Agent's supported MIB view.
    ( which was supplied at initialization time).
    The Request Type is GET, GETNEXT, and SET.

  Arguments:
    bRequestType    byte containing the type of request.
                    It can be one of
                     ASN_RFC1157_GETREQUEST
                     ASN_RFC1157_GETNEXTREQUEST
                     ASN_RFC1157_SETREQUEST

    pRfcVariableBindings
                   pointer to RFC 1157 compliant variable bindings.

    pAsniErrorStatus
                   pointer to ASN Integer for Error Status

    pAsniErrorIndex
                  pointer to ASN INteger giving the index for error.

  Returns:
    TRUE on success and FALSE on failure.
--*/

{
    W3_STATISTICS_1    HttpStatistics;
    NET_API_STATUS     Status;



    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //
    Status = W3QueryStatisticsFromSharedMemory(
                             &HttpStatistics );

    //
    //  Status Errors not checked for  here!
    //  Reason:
    //    If the verb is GET_NEXT beyond the block we support,
    //           then there is no need to worry about the error at all.
    //    If the verb is GET within the block, it will get NULL value
    //           ( due the memset() done above).
    //

    _try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        RFC1157VarBind * pVarBinding;

        for( pVarBinding = pRfcVariableBindings->list;
            pVarBinding < ( pRfcVariableBindings->list +
                            pRfcVariableBindings->len);
            pVarBinding++ ) 
       {

            *pAsniErrorStatus = ResolveVarBinding( pVarBinding,
                                                  bRequestType,
                                                  &HttpStatistics,
                                                  &sg_HttpMibs);

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if(( *pAsniErrorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
               ( bRequestType == MIB_GETNEXT ) ) 
            {


                *pAsniErrorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

                SNMP_oidfree( &pVarBinding->name );
                SNMP_oidcpy( &pVarBinding->name, &sg_MibOidPrefix);
                pVarBinding->name.ids[ HTTP_PREFIX_OID_LENGTH - 1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            *pAsniErrorIndex =
              (( *pAsniErrorStatus != SNMP_ERRORSTATUS_NOERROR ) ?
               (( DIFF(pVarBinding - pRfcVariableBindings->list)) + 1) : 0);

        } // for

    } // try
    _except ( EXCEPTION_EXECUTE_HANDLER   ) 
    {

        //
        //  For now do nothing.
        //


    }



    return ( SNMPAPI_NOERROR);
}   // SnmpExtensionQuery()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\test\makefile.inc ===
$(O)\snmp.res: snmp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\test\snmptest.cxx ===
#include "iis.h"
#include "stdio.h"
#include "Mgmtapi.h"

#define g_Usage L"Usage\n"
#define g_NotUsage L"NotUsage\n"

LPSNMP_MGR_SESSION  g_pSess = NULL;

VOID 
OpenCounters()
{

    HRESULT hr = S_OK;

    LPSTR computer = "EMILYK3-IIS";
    CHAR agent[1000];
    struct hostent* phostentry = gethostbyname(computer);
	
    if ( phostentry == NULL )
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        wprintf(L"Failed to get the host name with hr = %x\n", hr);
        return;
    }

    sprintf(agent,"%u.%u.%u.%u",(BYTE)(phostentry->h_addr)[0],
                                (BYTE)(phostentry->h_addr)[1],
                                (BYTE)(phostentry->h_addr)[2],
                                (BYTE)(phostentry->h_addr)[3]);


    g_pSess = SnmpMgrOpen(agent, "public", 6000, 3);

    if ( !g_pSess )
    {
        wprintf(L"Failed to open the manager\n");
    }
    else
    {
        wprintf(L"Openned the manager\n");

    }

}

VOID 
CloseCounters()
{
    if ( g_pSess )
    {
        SnmpMgrClose(g_pSess);
    };
}

VOID
ProcessCounters(
    RFC1157VarBindList* pvariableBindings
    )
{
	LPSTR string = NULL;
    DWORD chString = 0;

	// Display the resulting variable bindings.
    SnmpMgrOidToStr(&(pvariableBindings->list[0].name), &string);

    wprintf(L"list[0].name = %S \n", string);

    LONG lastResult=(long) (pvariableBindings->list[0].value.asnValue.number);
    
    wprintf(L"Counter Value: %ld\n", lastResult);    
    
	if (string) SNMP_free(string);
}

VOID 
RequestCounters(
    DWORD dwCounter)
{
	RFC1157VarBindList variableBindings;
	AsnObjectIdentifier reqObject;
	AsnInteger errorStatus;
    AsnInteger errorIndex;

    LPSTR ctrStart = ".1.3.6.1.4.1.311.1.7.3.1.";
    LPSTR ctrEnd   = ".0";
    CHAR  fullctr[1000];

    sprintf(fullctr, "%s%d%s", ctrStart, dwCounter, ctrEnd);
    wprintf(L"Counter strings is %S \n", fullctr);
    
    if ( g_pSess )
    {
	    variableBindings.list = NULL;
        variableBindings.len = 0;

	    if (!SnmpMgrStrToOid(fullctr, &reqObject))
		{
            wprintf(L"Failed to get the Oid\n");
        }

        variableBindings.len++;
        if ((variableBindings.list = (RFC1157VarBind *)SNMP_realloc(
				    variableBindings.list, sizeof(RFC1157VarBind) *
                    variableBindings.len)) == NULL)
		{
            wprintf(L"Failed to realloc space \n");
        }

	    variableBindings.list[variableBindings.len - 1].name = reqObject; // NOTE!  structure copy
	    variableBindings.list[variableBindings.len - 1].value.asnType = ASN_NULL;

        if (!SnmpMgrRequest(g_pSess, 
                            ASN_RFC1157_GETREQUEST, 
                            &variableBindings,
                            &errorStatus, 
                            &errorIndex) )
        {
            wprintf(L"Failed to get the counters requested\n");
        }
        else
        {
            if ( errorStatus == SNMP_ERRORSTATUS_NOERROR )
            {
                ProcessCounters(&variableBindings);

               	SnmpUtilVarBindListFree(&variableBindings);

            }
            else
            {

                switch (errorStatus)
                {
                    case SNMP_ERRORSTATUS_TOOBIG:
                        wprintf(L"SNMP_ERRORSTATUS_TOOBIG %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_NOSUCHNAME:
                        wprintf(L"SNMP_ERRORSTATUS_NOSUCHNAME %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_BADVALUE:
                        wprintf(L"SNMP_ERRORSTATUS_BADVALUE %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_READONLY:
                        wprintf(L"SNMP_ERRORSTATUS_READONLY %d\n", errorIndex);

                    break;

                    case SNMP_ERRORSTATUS_GENERR:
                        wprintf(L"SNMP_ERRORSTATUS_GENERR %d\n", errorIndex);

                    break;

                    default:
                        wprintf(L"hum...\n");
                }

                wprintf(L"Error status is %x \n ", errorStatus);
            }
        }
    }
}


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{

    DWORD dwErr = 0;
    WSADATA WSADATA;
    WORD wVersionRequested;
    wVersionRequested = MAKEWORD( 2, 2 );

    dwErr = WSAStartup(wVersionRequested, &WSADATA);
    if ( dwErr != ERROR_SUCCESS )
        printf("failed WSAStartup\n");

    OpenCounters();

/*
    for ( DWORD i = 1; i < 53; i++ )
    {
        RequestCounters(i);
    }
*/

    RequestCounters(18);

    CloseCounters();

    WSACleanup();

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\snmp\dll\shared_mem_mib.cxx ===
/*++  BUILD Version: 0001   // Increment this if a change has global effects.

   Copyright    (c)    2000    Microsoft Corporation

   Module  Name :

      shared_memory_mib.cxx

   Abstract:

      This file defines the shared memory routine that is used to get
      data from IIS 6, and beyond.

   Author:

       Emily B. Kruglick    ( EmilyK )     30-Nov-2000

   Environment:

       User Mode -- Win32

   Project:

       SNMP Extension DLL for HTTP Service DLL

   Functions Exported:

     UINT  W3QueryStatisticsFromSharedMemory();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include "wasdbgut.h"

# include <winperf.h>
# include <limits.h>

# include "perfcount.h"
# include "perf_sm.h"
# include "inetinfo.h"


typedef struct _SNMP_PROP_MAP
{
    DWORD OffsetInW3Block;
    DWORD OffsetInW3_STATISTICS_1Block;
    DWORD Size;
} SNMP_PROP_MAP;

#define SNMP_MAP(w3name, statname) \
    { FIELD_OFFSET( W3_COUNTER_BLOCK, w3name ), \
    FIELD_OFFSET( W3_STATISTICS_1, statname), \
    RTL_FIELD_SIZE(W3_COUNTER_BLOCK, w3name) }


SNMP_PROP_MAP aSNMPPropMap[] =
{
    SNMP_MAP(BytesSent,             TotalBytesSent),
    SNMP_MAP(BytesReceived,         TotalBytesReceived),
    SNMP_MAP(FilesSent,             TotalFilesSent),
    SNMP_MAP(FilesReceived,         TotalFilesReceived),
    SNMP_MAP(CurrentAnonymous,      CurrentAnonymousUsers),
    SNMP_MAP(CurrentNonAnonymous,   CurrentNonAnonymousUsers),
    SNMP_MAP(TotalAnonymous,        TotalAnonymousUsers),
    SNMP_MAP(TotalNonAnonymous,     TotalNonAnonymousUsers),
    SNMP_MAP(MaxAnonymous,          MaxAnonymousUsers),
    SNMP_MAP(MaxNonAnonymous,       MaxNonAnonymousUsers),
    SNMP_MAP(CurrentConnections,    CurrentConnections),
    SNMP_MAP(MaxConnections,        MaxConnections),
    SNMP_MAP(ConnectionAttempts,    ConnectionAttempts),
    SNMP_MAP(LogonAttempts,         LogonAttempts),

    SNMP_MAP(TotalOptions,          TotalOptions),
    SNMP_MAP(TotalGets,             TotalGets),
    SNMP_MAP(TotalPosts,            TotalPosts),
    SNMP_MAP(TotalHeads,            TotalHeads),
    SNMP_MAP(TotalPuts,             TotalPuts),
    SNMP_MAP(TotalDeletes,          TotalDeletes),
    SNMP_MAP(TotalTraces,           TotalTraces),
    SNMP_MAP(TotalMove,             TotalMove),
    SNMP_MAP(TotalCopy,             TotalCopy),
    SNMP_MAP(TotalMkcol,            TotalMkcol),
    SNMP_MAP(TotalPropfind,         TotalPropfind),
    SNMP_MAP(TotalProppatch,        TotalProppatch),
    SNMP_MAP(TotalSearch,           TotalSearch),
    SNMP_MAP(TotalLock,             TotalLock),
    SNMP_MAP(TotalUnlock,           TotalUnlock),
    SNMP_MAP(TotalOthers,           TotalOthers),      
    SNMP_MAP(TotalCGIRequests,      TotalCGIRequests),
    SNMP_MAP(TotalBGIRequests,      TotalBGIRequests),
    SNMP_MAP(TotalNotFoundErrors,   TotalNotFoundErrors),
    SNMP_MAP(TotalLockedErrors,     TotalLockedErrors),

    SNMP_MAP(CurrentCalAuth,        CurrentCalAuth),
    SNMP_MAP(MaxCalAuth,            MaxCalAuth),
    SNMP_MAP(TotalFailedCalAuth,    TotalFailedCalAuth),
    SNMP_MAP(CurrentCalSsl,         CurrentCalSsl),
    SNMP_MAP(MaxCalSsl,             MaxCalSsl),
    SNMP_MAP(TotalFailedCalSsl,     TotalFailedCalSsl),

    SNMP_MAP(CurrentCGIRequests,    CurrentCGIRequests),
    SNMP_MAP(CurrentBGIRequests,    CurrentBGIRequests),
    SNMP_MAP(MaxCGIRequests,        MaxCGIRequests),
    SNMP_MAP(MaxBGIRequests,        MaxBGIRequests),

    SNMP_MAP(MeasuredBandwidth,     MeasuredBw),
    SNMP_MAP(ServiceUptime,         ServiceUptime),

};
DWORD cSNMPPropMap = sizeof (aSNMPPropMap) / sizeof( SNMP_PROP_MAP );

/***************************************************************************++

Routine Description:

   Helper function to hook up to shared memory when we are ready to 
   provide counters.

Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD
HookUpSharedMemory(
    PERF_SM_MANAGER* pManager
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( pManager );


    //
    // Initialize the memory manager for readonly access
    //
    dwErr = pManager->Initialize(FALSE);
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // Initialize a reader to point to the appropriate
    // counter set.
    //
    dwErr = pManager->CreateNewCounterSet( SITE_COUNTER_SET );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }


exit:

    return dwErr;
}


/***************************************************************************++

Routine Description:

    Hooks up to shared memory, and grabs the appropriate counters
    for the snmp counters.  Then returns them to the main processing
    code in the same form that was expected in IIS 5.

Arguments:

    None.

Return Value:

    UINT

--***************************************************************************/
UINT
W3QueryStatisticsFromSharedMemory(
    LPW3_STATISTICS_1  pHttpStatistics
    )
{
    PERF_SM_MANAGER Manager;
    DWORD dwErr = ERROR_SUCCESS;
    LPBYTE pW3Counters = NULL;

    DBG_ASSERT ( pHttpStatistics );

    // Open up shared memory.

    dwErr = HookUpSharedMemory(&Manager);
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // Delay, if we need to wait for counters to be refreshed.
    // if we eventually have logging in snmp then we should
    // log if we were not able to get fresh counters.
    Manager.EvaluateIfCountersAreFresh();

    // Request the counters.
    dwErr = Manager.GetSNMPCounterInfo( &pW3Counters );
    if ( dwErr != ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // Make sure we clear this out, because there are some counters
    // which we no longer support.
    //
    memset ( pHttpStatistics, 0, sizeof( LPW3_STATISTICS_1 ) );

    // Copy out the appropriate values.
    for ( DWORD index = 0; index < cSNMPPropMap ; index ++ )
    {
        LPBYTE Source = pW3Counters + aSNMPPropMap[index].OffsetInW3Block;
        LPBYTE Destination = ( LPBYTE ) pHttpStatistics + aSNMPPropMap[index].OffsetInW3_STATISTICS_1Block;

        if ( aSNMPPropMap[index].Size == sizeof ( DWORD ) )
        {
            * ( DWORD * ) Destination = * ( DWORD * ) Source;
        }
        else
        {
            DBG_ASSERT ( aSNMPPropMap[index].Size == sizeof ( ULONGLONG ) );

            * ( ULONGLONG * ) Destination = * ( ULONGLONG * ) Source;
        }
    }

    Manager.PingWASToRefreshCounters();

exit:

    //
    // Note, when the Manager distructs, we will let go of the shared memory.
    //

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\staticfiles\dav\makefile.inc ===
#
# Defines build rules for targets that makefile.def
# won't build. !include this file in your makefile.inc
#

#build JAVAIMPORTS1 macro
!if "$(JAVACOMTLBIMPORTDST)" != ""
JAVAIMPORTS=$(JAVACOMTLBIMPORTDST);$(JAVAIMPORTS)
!endif

JAVAIMPORTS=$(JAVAIMPORTS: =)
JAVAIMPORTSDEPS=$(JAVAIMPORTS:;= )

!if "$(JAVAIMPORTS)" != ""
#put a semicolon in front, and remove the one in back
JAVAIMPORTS1=-$(JAVAIMPORTS)+
JAVAIMPORTS1=$(JAVAIMPORTS1:-;=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:-=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:;+=)
JAVAIMPORTS1=$(JAVAIMPORTS1:+=)
!endif

####################################
# COOL COMPILER SPECIFIC
####################################

# Set java resource file flags
!if "$(JAVARES)" != ""
COMXCOOLRESFLAGS=-res:$(JAVARES)
!else
COMXCOOLRESFLAGS=
!endif

# Set java import files flags
!if "$(JAVAIMPORTS1)" != ""
COMXCOOLIMPORTFLAGS=$(JAVAIMPORTS1:;= -I:)
!else
COMXCOOLIMPORTFLAGS=
!endif

COMXCOOLCOMMAND=$(COMXCOOL) $(COMXCOOLFLAGS) $(COMXCOOLRESFLAGS) $(COMXCOOLIMPORTFLAGS)

#
# Build a COM+ java dll
#
!if "$(USE_COOL)" == "1"

# JAVAIMPORTS (Sytem.XSP.dll) is not part of our project, no use putting
# dependency on it.  We cannot build it even if it is outdated. 
!if "$(JAVADLL)" != ""
$(JAVADLL) : $(JAVASOURCES) $(JAVARES) # $(JAVAIMPORTSDEPS)
    $(COMXCOOLCOMMAND) -dll -out:$@ $(JAVASOURCES)
!endif

!endif

######################################
# END OF COMPILER SPECIFIC
######################################

#
# Build a type library from a COM+ java dll or exe
#
!if "$(JAVATLB)" != ""
$(JAVATLB) : $(JAVADLL) $(JAVAEXE)
    echo cl comreg_$**
    $(COMXCOMREG) $** -r $*.reg -xr
!endif

#
# Build a EE dll from a COM type library
#
!if "$(JAVACOMTLBIMPORTSRC)" != ""
!if "$(JAVACOMTLBIMPORTDST)" != ""
$(JAVACOMTLBIMPORTDST) : $(JAVACOMTLBIMPORTSRC)
    echo cl tlbimp_$**
    $(COMXTLBIMP) /Fe $@ /Tlb $**
!endif
!endif

#
# Build a COM+ VB dll or exe
#
!if "$(VBTARGET)" != ""
$(VBTARGET) : $(VBSOURCES) $(@B).vbp
    echo cl compiling_vb_files_into_dll
    $(COMXBC) -i:$(@B).vbp -o $(@B).dll -s $(@D)  $(COMXBCDIRECTIVES) $(VBDIRECTIVEFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\staticfiles\dav\sources.inc ===
PROJECT_ROOT=.
!INCLUDE .\FIND_ROOT.INC
!INCLUDE $(PROJECT_ROOT)\PLACE.INC

!INCLUDE $(IISBASEDIR)\ICEPICK.INC

WIN32_WINNT_VERSION=0x0500

TARGETNAME=iiswp
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM

USE_MSVCRT=1

CAT42INCLUDES=$(IISBASEDIR)\import\inc

CAT42LIBS=$(IISBASEDIR)\import\lib\*\cat.lib   \


INCLUDES=.\;..\;$(INCLUDES);            \
         ..\..\inc;                     \
         $(IISBASEDIR)\inc;             \
         ..\..\webserver\comxbin;       \
         $(IISBASEDIR)\misc\irtl;       \
         $(CAT42INCLUDES)

LINKER_FLAGS = $(LINKER_FLAGS) /DEF:..\appwp.def

C_DEFINES=-DUNICODE -D_UNICODE


ULLIBS  =                                                       \
         $(IISBASEDIR)\lib\*\ulapi.lib                          \


SOURCES=                            \
            ..\iiswp.rc                \
            ..\controlchannel.cxx      \
            ..\wpconfig.cxx            \
            ..\wpcontext.cxx           \
            ..\apppool.cxx             \
            ..\workerrequest.cxx       \
            ..\wreqpool.cxx            \
            ..\ipm_io_c.cxx            \
            ..\wpipm.cxx               \
            ..\iiswp.cxx               \
            ..\CgiNative.cxx           \
            ..\ISAPINative.cxx         \
            ..\DateTime.cxx            \
            ..\DAVPropBag.cxx          \

UMTYPE=console
UMENTRY=wmain


TARGETLIBS =                                                    \
        $(SDK_LIB_PATH)\ntdll.lib                               \
        $(SDK_LIB_PATH)\kernel32.lib                            \
        $(SDK_LIB_PATH)\user32.lib                              \
        $(SDK_LIB_PATH)\ole32.lib                               \
        $(SDK_LIB_PATH)\oleaut32.lib                            \
        $(SDK_LIB_PATH)\uuid.lib                                \
        $(IISBASEDIR)\lib\*\iisutil.lib                         \
        $(IISBASEDIR)\lib\*\irtl.lib                            \
        $(IISBASEDIR)\lib\*\ipm.lib                             \
        $(ULLIBS)                                               \
        $(CAT42LIBS)



!IF "$(NTNOPCH)" == ""
PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\staticfiles\dav\davpropbag.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :

        DAVPropBag.cxx

   Abstract :
 
        This Module is used by DAV to retrieve properties stored within
		files on NTFS NT 5 systems.

   Author:

        Emily Kruglick     (emilyk)     08-Sept-1999

   Project:

        Web Server

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "precomp.hxx"

#include <malloc.h>
#include <stdio.h>
#include <string.h>
#include <pbagex.h>


// Function declaration for the StgOpenStoreageOnHandle
// it is supported from OLE32.dll, but is not exposed or
// documented.
typedef HRESULT (__stdcall * STGOPENSTORAGEONHANDLE)(
	IN HANDLE hStream,
	IN DWORD grfMode,
	IN void *reserved1,
	IN void *reserved2,
	IN REFIID riid,
	OUT void **ppObjectOpen );

#define DEC_CONST		extern const __declspec(selectany)

// Must match the constant values defined in managed code.
DEC_CONST int gc_iDavType_String			= 1;
DEC_CONST int gc_iDavType_String_XML_TAG	= 2;
DEC_CONST int gc_iDavType_String_XML_FULL	= 3;
DEC_CONST int gc_iDavType_Date_ISO8601		= 4;
DEC_CONST int gc_iDavType_Date_Rfc1123		= 5;
DEC_CONST int gc_iDavType_Float				= 6;
DEC_CONST int gc_iDavType_Boolean			= 7;
DEC_CONST int gc_iDavType_Int				= 8;


/********************************************************************++
 Routines borrowed from DAVFS that manage converting data for properties
++********************************************************************/
#define CchConstString(_s)  ((sizeof(_s)/sizeof(_s[0])) - 1)

DEC_CONST WCHAR gc_wszIso8601_min[]			= L"yyyy-mm-ddThh:mm:ssZ";
DEC_CONST UINT gc_cchszIso8601_min			= CchConstString(gc_wszIso8601_min);
DEC_CONST WCHAR gc_wszIso8601_scanfmt[]		= L"%04hu-%02hu-%02huT%02hu:%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_tz_scanfmt[]	= L"%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_fmt[]			= L"%04d-%02d-%02dT%02d:%02d:%02d.%03dZ";
DEC_CONST WCHAR gc_wszRfc1123_min[]			= L"www, dd mmm yyyy hh:mm:ss GMT";
DEC_CONST UINT	gc_cchRfc1123_min			= CchConstString (gc_wszRfc1123_min);
DEC_CONST WCHAR gc_wszRfc1123_fmt[] 		= L"%hs, %02d %hs %04d %02d:%02d:%02d GMT";
DEC_CONST CHAR gc_szRfc1123_fmt[]	 		= "%hs, %02d %hs %04d %02d:%02d:%02d GMT";


BOOL __fastcall
FGetDateIso8601FromSystime(SYSTEMTIME * psystime, LPWSTR pwszDate, ULONG cSize)
{
	//	If there is not enough space...
	//
	if (cSize <= gc_cchszIso8601_min)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszIso8601_fmt,
						 psystime->wYear,
						 psystime->wMonth,
						 psystime->wDay,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond,
						 psystime->wMilliseconds));
}


/********************************************************************++
Global Entry Points for callback from XSP
++********************************************************************/

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

/********************************************************************++
++********************************************************************/
// Used to store linked list of property information.
struct PropNode
{
	 BSTR PropName;
     BSTR PropValue;
     int	PropType;
     int	ResultCode;
     PropNode* next;
};

const int ALL_PROPS_REQUESTED = 1;
const int PROP_NAMES_ONLY_REQUESTED = 2;

// Class is used to hold information about a URI's properties
// so we don't have to evaluate from the URI twice when we need 
// to get the count of values that we should expect back.
class DAVPropertyManager
{
public:
	DAVPropertyManager();
	~DAVPropertyManager();

	HRESULT GetCountOfProperties(BSTR uri, int flag, BSTR* RequestedProps, int ReqPropsCount, int* count);
	HRESULT GetProperties(  BSTR uri
							, int  flag
							, BSTR* RequestedProps
							, int  RequestedPropsCount
							, BSTR* names
							, BSTR* values
							, int*   types
							, int*   codes
							, int    count);

private:

	HRESULT EvaluateURI(LPWSTR wszURI, int flag, BSTR* propnames, int propnamescount);
	HRESULT GetPropertyBag( LPCWSTR pwszPath, IPropertyBagEx** ppBag);
	HRESULT StoreProps( IPropertyBagEx* pBag, BSTR* RequestedProps, int RequestedPropCount, int flag);
	HRESULT AddPropToList(LPWSTR name, PROPVARIANT* var, int resultcode);
	HRESULT CopyValue (LPWSTR origVal, BSTR* pnewValue);
	HRESULT SavePropValue ( PROPVARIANT* var, BSTR* ppValue, int* ppType );

	int			_count;					// number of properties found
	LPWSTR		_uri;					// uri the properties were retrieved from
	PropNode*	_pPropertyList;			// saved property listing
	PropNode*	_pLastPropertyAdded;	// last spot in property listing

};

DAVPropertyManager::DAVPropertyManager()
{
	_count = 0;
	_uri = NULL;
	_pPropertyList = NULL;
	_pLastPropertyAdded = NULL;
}

DAVPropertyManager::~DAVPropertyManager()
{
	delete[] _uri;

	PropNode* tpi;

	while (_pPropertyList != NULL)
	{
		tpi = _pPropertyList->next;

		if (_pPropertyList->PropName) SysFreeString(_pPropertyList->PropName);
		if (_pPropertyList->PropValue) SysFreeString(_pPropertyList->PropValue);
		
		// Types are set to integers so they don't need freeing!!
		// so they are never freed!!
		// delete[] _pPropertyList->PropType;
		delete _pPropertyList;
		_pPropertyList = tpi;
	}

}

HRESULT DAVPropertyManager::EvaluateURI(BSTR wszURI, int flag, BSTR* RequestedProps, int RequestedPropsCount)
{
	HRESULT hr = S_OK;
	IPropertyBagEx* pBag = NULL;

	if (wszURI == NULL)
		return E_INVALIDARG;

	// Save the URI for later use.  (Right now we don't have a later use, but we might someday.)
	_uri = new WCHAR[wcslen(wszURI) + 1];
	if (_uri == NULL) 
	{
		hr = E_OUTOFMEMORY;
		goto cleanup;
	}
	wcscpy (_uri, wszURI);

	hr = GetPropertyBag(wszURI, &pBag);
	if (SUCCEEDED (hr))
	{
		hr = StoreProps(pBag, RequestedProps, RequestedPropsCount, flag);
	}

cleanup:
	if (pBag) 
		pBag->Release();

	return hr;
}

// BUGBUG:  This is an extremely simplified version just to get us running, it will need to be compared with ScGetPropertyBag 
// and have all the complexity added back in.
HRESULT DAVPropertyManager::GetPropertyBag( LPCWSTR pwszPath, IPropertyBagEx** ppBag)
{
	HRESULT hr = S_OK;
	DWORD dwResult = 0;

	HANDLE hFile = NULL;
	HINSTANCE hLib = NULL;

	hFile = CreateFileW (pwszPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == NULL)
	{
		dwResult = GetLastError();
		hr = HRESULT_FROM_WIN32(dwResult);
		goto cleanup;
	}

	hLib = LoadLibrary (L"ole32.dll");
	if (hLib == NULL)
	{
		// Physical Address does not need to be freed (I believe).
		STGOPENSTORAGEONHANDLE pfnStorage = (STGOPENSTORAGEONHANDLE) GetProcAddress (hLib, "StgOpenStorageOnHandle");

		hr = (*pfnStorage) (hFile,
						STGM_READ | STGM_SHARE_DENY_WRITE,
						NULL,
						NULL,
						IID_IPropertyBagEx,
						(LPVOID *)ppBag);

		if (FAILED(hr)) goto cleanup;
	}
	else
	{
		dwResult = GetLastError();
		hr = HRESULT_FROM_WIN32(dwResult);
		goto cleanup;
	}

	if (*ppBag == NULL)
	{
		hr = E_FAIL;
		goto cleanup;
	}

cleanup:

	if (hFile) CloseHandle(hFile);
	if (hLib) FreeLibrary(hLib);

	return hr;
}

HRESULT DAVPropertyManager::StoreProps( IPropertyBagEx* pBag, BSTR* RequestedProps, int RequestedPropCount, int flag )
{
	HRESULT hr = S_OK;

	IEnumSTATPROPBAG* enumBag = NULL;
	STATPROPBAG sp[16];
	ULONG cprops = 0;
	LPWSTR propnames[16] = {0};
	LPWSTR* passprops = NULL;
	PROPVARIANT propvariants[16];

	// Need to clear out the propvariants memory.
	ZeroMemory (&propvariants, sizeof(PROPVARIANT) * 16 );

	ULONG i = 0;

	// Figure out if we want all properties or just selected ones and if we want the property values as well.
	bool fAllProps = ((flag == ALL_PROPS_REQUESTED) || (flag == PROP_NAMES_ONLY_REQUESTED));
	bool fPropValues = flag != PROP_NAMES_ONLY_REQUESTED;

	// Validate that either we want all properties or have been given specific properties we want to get
	ASSERT (fAllProps || (RequestedProps && RequestedPropCount > 0));

	// If we are looking for all properties then we need an enum bag to use to get the properties
	if (fAllProps) hr = pBag->Enum (NULL, 0, &enumBag);

	bool fMorePropertiesExist = fAllProps;
	do
	{
		if (fAllProps)
		{
			// Use the enumBag to get the properties names we need.
			hr = enumBag->Next(16, sp, &cprops);
			if (FAILED(hr)) goto cleanup;

			fMorePropertiesExist = (hr == S_OK);  // hr will be S_FALSE when we have processed all the properties.

			// Need to first go through and create a list of the properties I am going to ask
			// for when I read multiple property info from the bag.
			for (i = 0 ; i < cprops ; i++)
			{
				// grab the pointer to the property name
				propnames[i] = sp[i].lpwstrName;
			}

			// set it into the variable we will use below.
			passprops = propnames;
		}
		else
		{
			// if we all ready had the property names set them into the correct variables.
			passprops = (LPWSTR*) RequestedProps;
			cprops = RequestedPropCount;
		}

		// Now that i have set the property names in I can ask
		// for the properties back.
		hr = pBag->ReadMultiple (cprops,
					   passprops,
					   propvariants,
					   NULL);
		if (FAILED(hr)) goto cleanup;

		for (i = 0 ; i < cprops ; i++)
		{
			if (propvariants[i].vt != VT_EMPTY)
			{
				if (fPropValues)
					AddPropToList(passprops[i], &(propvariants[i]), 200);
				else
					AddPropToList(passprops[i], NULL, 200);
			}

			// If the enumBag->Next created property names then we need to clean them up.
			if (fAllProps)
			{
				CoTaskMemFree(passprops[i]);
				passprops[i] = NULL;
			}

		//	MessageBox(NULL, sp[i].lpwstrName, L"Names", MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONHAND);
		}
		
		// Free the memory for the PROPVARIANTS
		FreePropVariantArray(cprops, propvariants);


	} while (fMorePropertiesExist);

cleanup:

	if (enumBag) enumBag->Release();

	if ((fAllProps) && (passprops != NULL))
	{
		for (i = 0; i<cprops; i++)
		{
			if (passprops[i] != NULL) 
			{
				CoTaskMemFree(passprops[i]);
			}
		}
	}
	return hr;
}

HRESULT DAVPropertyManager::AddPropToList(LPWSTR name, PROPVARIANT* var, int resultcode)
{
	HRESULT hr = S_OK;
	PropNode* tmp = new PropNode;
	if (tmp==NULL) 
	{ 
		// We won't record an error, the property will just be dropped.
		return E_OUTOFMEMORY;
	}

	if (var)
	{
		hr = SavePropValue(var, &(tmp->PropValue), &(tmp->PropType));
		if (FAILED(hr)) 
		{
			// if we had any problem with saving the property value then we 
			// will just ignore the property being returned to the user.
			delete tmp;
			return S_OK;
		}
	}
	else
	{
		tmp->PropValue = NULL;
		tmp->PropType = 0;
	}

	// Make copy of names and values, so we don't end up with someone changing our values later
	// like when another enumBag->Next is called.
	hr = CopyValue(name, &(tmp->PropName));
	if (FAILED(hr))
	{
		SysFreeString(tmp->PropValue) ;
		delete tmp;
		return hr;
	}

	tmp->ResultCode = resultcode;
	tmp->next = NULL;

	if (_pLastPropertyAdded)
	{
		_pLastPropertyAdded->next = tmp;
		_pLastPropertyAdded = tmp;
	}
	else
	{
		_pPropertyList = tmp;
		_pLastPropertyAdded = tmp;
	}

	// Make sure we record that we have another property.
	_count++;

	return hr;
}

HRESULT DAVPropertyManager::CopyValue (LPWSTR origVal, BSTR* pnewValue)
{
	ASSERT (pnewValue);

	*pnewValue = SysAllocString(origVal);
	if (*pnewValue == NULL) return E_OUTOFMEMORY;

	return S_OK;

}

HRESULT DAVPropertyManager::SavePropValue ( PROPVARIANT* var, BSTR* ppValue, int* ppType )
{
	HRESULT hr = S_OK;
	ULONG cch = 0;		// Count of characters needed for new string
	WCHAR wszBuf[100];  // Buffer for converting number into a string
	VARIANT* pvarTrue = reinterpret_cast<VARIANT*>(var);  // Used for reaching numeric types.
	CHAR szBuf[100];    // Buffer for convertint asci values.
	LPWSTR tmp = NULL;

	// Validate we have the correct variables coming in.
	ASSERT (ppValue && ppType);
	ASSERT (var);

	if (ppValue==NULL || ppType ==NULL) return E_INVALIDARG;
	if (var==NULL) return E_INVALIDARG;

	// Initalize outgoing variables.
	*ppValue = NULL;
	*ppType = 0;

	switch (var->vt)
	{
		case VT_NULL:
		case VT_EMPTY:

			break;

		case VT_BSTR:

			hr = CopyValue(static_cast<LPWSTR>(var->bstrVal), ppValue);
			break;

		case VT_LPWSTR:

			hr = CopyValue(var->pwszVal, ppValue);
			break;

		case VT_LPSTR:

			if (!var->pszVal)
				break;

			cch = strlen (var->pszVal) + 1;
			tmp = new WCHAR[cch];
			if (tmp == NULL) 
				hr = E_OUTOFMEMORY;
			else
			{
				MultiByteToWideChar (CP_ACP,
									 0,
									 var->pszVal,
									 -1,
									 tmp,
									 cch);
				
				*ppValue = SysAllocString(tmp);
				delete[] tmp;
			}
			break;

		case VT_I1:

			// BUGBUG:  Do we want to new the wszBuf each time
			//          and then itow directly into it, instead of
			//          having to do the new and copy after the itow?
			*ppType = gc_iDavType_Int;
			_itow (pvarTrue->cVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI1:

			*ppType = gc_iDavType_Int;
			_ultow (var->bVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I2:

			*ppType = gc_iDavType_Int;
			_itow (var->iVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI2:

			*ppType = gc_iDavType_Int;
			_ultow (var->uiVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I4:

			*ppType = gc_iDavType_Int;
			_ltow (var->lVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI4:

			*ppType =  gc_iDavType_Int;
			_ultow (var->ulVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_I8:

			*ppType =  gc_iDavType_Int;
			_i64tow (var->hVal.QuadPart, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UI8:

			*ppType = gc_iDavType_Int;
			_ui64tow (var->uhVal.QuadPart, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_INT:

			*ppType =  gc_iDavType_Int;
			_itow (pvarTrue->intVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_UINT:

			*ppType =  gc_iDavType_Int;
			_ultow (pvarTrue->uintVal, wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_BOOL:

			*ppType =  gc_iDavType_Boolean;
			_itow (!(VARIANT_FALSE == var->boolVal), wszBuf, 10);
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_R4:
		case VT_R8:

			if (VT_R4 == var->vt)
				_gcvt (var->fltVal, 99, szBuf);
			else
				_gcvt (var->dblVal, 99 , szBuf);

			MultiByteToWideChar (CP_ACP,
								 0,
								 szBuf,
								 -1,
								 wszBuf,
								 100);

			*ppType = gc_iDavType_Float;
			hr = CopyValue(wszBuf, ppValue);
			break;

		case VT_FILETIME:

			SYSTEMTIME st;

			FileTimeToSystemTime (&var->filetime, &st);
			if (!FGetDateIso8601FromSystime(&st, wszBuf, 100))
			{
				hr = E_INVALIDARG;
			} 
			else
			{
				*ppType = gc_iDavType_Date_ISO8601;
				hr = CopyValue(wszBuf, ppValue);
			}
			break;

		case VT_CY:
		case VT_DATE:
		case VT_DISPATCH:
		case VT_ERROR:
		case VT_VARIANT:
		case VT_UNKNOWN:
		case VT_DECIMAL:
		case VT_RECORD:
		case VT_BLOB:
		case VT_STREAM:
		case VT_STORAGE:
		case VT_STREAMED_OBJECT:
		case VT_STORED_OBJECT:
		case VT_BLOB_OBJECT:
		case VT_CF:
		case VT_CLSID:

		// DAVFS supported vectors of wstrs because at one point you could save them, however that was long ago
		// JoelS didn't have any problem with my decision not to support reading these back so we are not.
		// They complicate property management since they require multiple value support.
		case VT_VECTOR | VT_LPWSTR:

		default:

			hr = E_UNEXPECTED;
			break;
	}

	return hr;
}




HRESULT DAVPropertyManager::GetCountOfProperties(  BSTR uri
												 , int     flag
												 , BSTR* propnames
												 , int	   propnamescount
 												 , int* count)

{
	HRESULT hr = S_OK;

	if (_uri == NULL)
		hr = EvaluateURI(uri, flag, propnames, propnamescount);

	*count = _count;
	return hr;
}

HRESULT DAVPropertyManager::GetProperties(  BSTR uri
										  , int    flag
										  , BSTR* propnames
										  , int    propnamescount
										  , BSTR* names
										  , BSTR* values
										  , int*   types
										  , int*   codes
										  , int    count)
{
	HRESULT hr = S_OK;

	if (_uri == NULL)
		hr = EvaluateURI(uri, flag, propnames, propnamescount);

	if (SUCCEEDED(hr))
	{
		if (count != _count)
			return E_INVALIDARG;

	//	MessageBox(NULL, L"GetProperties", L"IN", MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONHAND);
		PropNode* tpi = _pPropertyList;

		int i = 0;
		while ((tpi != NULL) && (i < count))
		{
			names[i] = tpi->PropName;
			values[i] = tpi->PropValue;
			types[i] = tpi->PropType;
			codes[i++] = tpi->ResultCode;
			tpi = tpi->next;
		}
	}

	return hr;
}



// Exported functions for interacting with the DAVPropertyManager Class.
dllexp 
HRESULT DAVGetPropertyCount (BSTR uri, BSTR* propnames, int propnamescount, int flag,  int* count, int* addr)
{
	HRESULT hr = S_OK;

	if (*addr == NULL)
	{
		*addr = (int) new DAVPropertyManager();
	}

	DAVPropertyManager* pm = (DAVPropertyManager*) *addr;

	hr = pm->GetCountOfProperties(uri, flag, propnames, propnamescount, count);

	WCHAR buf[100];

	swprintf(buf, L"Count is %i\r\n", *count); 
	OutputDebugString(buf);

	return hr;

}

dllexp 
HRESULT DAVGetProperties (  BSTR uri
						  , BSTR* propnames
						  , int propnamescount
						  , int flag
						  , BSTR* names
						  , BSTR* values
						  , int* types
						  , int* codes
						  , int count
						  , int* addr)
{
	HRESULT hr = S_OK;

	if (*addr == NULL)
	{
		*addr = (int) new DAVPropertyManager();
	}

	DAVPropertyManager* pm = (DAVPropertyManager*) *addr;

	hr = pm->GetProperties(uri, flag, propnames, propnamescount, names, values, types, codes, count);

	return hr;

}

dllexp 
HRESULT DAVFreePropManager (int addr)
{
	HRESULT hr = S_OK;

	if (addr != NULL)
	{
		DAVPropertyManager* pm = (DAVPropertyManager*) addr;
		delete pm;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\utils\generatehash\makefile.inc ===
#
# Defines build rules for targets that makefile.def
# won't build. !include this file in your makefile.inc
#

#build JAVAIMPORTS1 macro
!if "$(JAVACOMTLBIMPORTDST)" != ""
JAVAIMPORTS=$(JAVACOMTLBIMPORTDST);$(JAVAIMPORTS)
!endif

JAVAIMPORTS=$(JAVAIMPORTS: =)
JAVAIMPORTSDEPS=$(JAVAIMPORTS:;= )

!if "$(JAVAIMPORTS)" != ""
#put a semicolon in front, and remove the one in back
JAVAIMPORTS1=-$(JAVAIMPORTS)+
JAVAIMPORTS1=$(JAVAIMPORTS1:-;=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:-=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:;+=)
JAVAIMPORTS1=$(JAVAIMPORTS1:+=)
!endif

####################################
# COOL COMPILER SPECIFIC
####################################

# Set java resource file flags
!if "$(JAVARES)" != ""
COMXCOOLRESFLAGS=/win32res:$(JAVARES)
!else
COMXCOOLRESFLAGS=
!endif

# Set java import files flags
!if "$(JAVAIMPORTS1)" != ""
COMXCOOLIMPORTFLAGS=$(JAVAIMPORTS1:;=-I:)
!else
COMXCOOLIMPORTFLAGS=
!endif

COMXCOOLCOMMAND=$(COMXCOOL) $(COMXCOOLFLAGS) $(COMXCOOLRESFLAGS) $(COMXCOOLIMPORTFLAGS)

#
# Build a COM+ java dll
#
!if "$(USE_COOL)" == "1"

!if "$(JAVAEXE)" != ""
$(JAVAEXE) : $(JAVASOURCES) $(JAVARES) # $(JAVAIMPORTSDEPS)
    $(COMXCOOLCOMMAND) -exe -out:$@ $(JAVASOURCES)
!endif

!endif

######################################
# END OF COMPILER SPECIFIC
######################################

#
# Build a type library from a COM+ java dll or exe
#
!if "$(JAVATLB)" != ""
$(JAVATLB) : $(JAVADLL) $(JAVAEXE)
    echo cl comreg_$**
    $(COMXCOMREG) $** -r $*.reg -xr
!endif

#
# Build a EE dll from a COM type library
#
!if "$(JAVACOMTLBIMPORTSRC)" != ""
!if "$(JAVACOMTLBIMPORTDST)" != ""
$(JAVACOMTLBIMPORTDST) : $(JAVACOMTLBIMPORTSRC)
    echo cl tlbimp_$**
    $(COMXTLBIMP) /Fe $@ /Tlb $**
!endif
!endif

#
# Build a COM+ VB dll or exe
#
!if "$(VBTARGET)" != ""
$(VBTARGET) : $(VBSOURCES) $(@B).vbp
    echo cl compiling_vb_files_into_dll
    $(COMXBC) -i:$(@B).vbp -o $(@B).dll -s $(@D)  $(COMXBCDIRECTIVES) $(VBDIRECTIVEFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\entrypts.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    entrypts.cxx

    This file implements the Extensible Performance Objects for
    the iis counters.

    FILE HISTORY:
        EmilyK      24-Aug-2000 Created, based on w3ctrs code.

*/

#include <windows.h>
#include <winperf.h>
#include "perfcount.h"
#include "w3data.h"
#include "w3msg.h"
#include "iisdef.h"
#include "wasdbgut.h"
#include "perfutil.h"
#include "eventlog.hxx"
#include "regconst.h"

#include "perf_sm.h"

//
//  common defines
//



//
//  Public prototypes.
//

PM_OPEN_PROC    OpenW3PerformanceData;
PM_COLLECT_PROC CollectW3PerformanceData;
PM_CLOSE_PROC   CloseW3PerformanceData;

//
// Global object contecting to the site counters memory.
//
CRITICAL_SECTION g_IISMemManagerCriticalSection;
PERF_SM_MANAGER* g_pIISMemManager;
LONG             g_IISNumberInitialized;
HANDLE           g_hWASProcessWait;

//
// Number of tick counts that must have passed to make the data old.
//------------------------------------------------------------------
// You can override this value by senting "FreshTimeForCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
DWORD   g_IIS_MillisecondsCountersAreFresh = 60000;  // one minute in milliseconds

//
// How long to Sleep before each check for new counters
//------------------------------------------------------------------
// You can override this value by senting "CheckCountersEveryNMiliseconds"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
// This value is milliseconds.
//
DWORD   g_IIS_MillisecondsToSleepBeforeCheckingForRefresh = 250; // 1/4 second

//
// Number of times to wait for the time between tickcounts.
//------------------------------------------------------------------
// You can override this value by senting "NumberOfTimesToCheckCounters"
// (a DWORD value) under the W3svc\Performance key.  Setting this value
// to zero (or not setting this value) causes us to us the default listed here.
//
DWORD   g_IIS_MaxNumberTimesToCheckCountersOnRefresh = 4; 

// Pointer to the event log class so we can log problems with perf counters.
EVENT_LOG*        g_pEventLog = NULL;

//
// Private Supporting Functions
//

/***************************************************************************++

Routine Description:

   Looks up in the registry all the specific counter values
   that we need to be able to play nice with the other counters
   on the machine.
    
Arguments:

    None

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD EstablishIndexes()
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;

    PERF_COUNTER_DEFINITION* pDefinition = NULL;

    //
    //  Open the HTTP Server service's Performance key.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        REGISTRY_KEY_W3SVC_PERFORMANCE_KEY_A,
                        0,
                        KEY_QUERY_VALUE,
                        &hkey );

    if( err == NO_ERROR)
    {
    
        //
        //  Read the first counter DWORD.
        //
    
        size = sizeof(DWORD);

        err = RegQueryValueEx( hkey,
                               "First Counter",
                               NULL,
                               &type,
                               (LPBYTE)&dwFirstCounter,
                               &size );
        if( err == NO_ERROR )
        {
            //
            //  Read the first help DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Help",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstHelp,
                                   &size );

            if ( err == NO_ERROR )
            {
                //
                // First establish all of the W3 Service Counters
                // ==============================================

                //
                //  Update the object & counter name & help indicies.
                //
                W3DataDefinition.W3ObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                W3DataDefinition.W3ObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                // 
                // Figure out the first counter definition.  It starts
                // after the PERF_OBJECT_TYPE structure, which is the
                // first iten in the W3DataDefinition.
                //
                pDefinition = (PERF_COUNTER_DEFINITION*) ((LPBYTE) (&W3DataDefinition) 
                                                           + sizeof(PERF_OBJECT_TYPE));

                //
                // Now simply walk through the counters incrementing
                // the pDefinition by on PERF_COUNTER_DEFINITION as you go.
                //
                for (int i = 0; i < NUMBER_OF_W3_COUNTERS; i++, pDefinition++)
                {
                    pDefinition->CounterNameTitleIndex += dwFirstCounter;
                    pDefinition->CounterHelpTitleIndex += dwFirstHelp;
                }

                // 
                // Now do all of the W3 Global Service Counters
                // ============================================

                //
                //  Update the object & counter name & help indicies.
                //
                W3GlobalDataDefinition.W3GlobalObjectType.ObjectNameTitleIndex
                    += dwFirstCounter;
                W3GlobalDataDefinition.W3GlobalObjectType.ObjectHelpTitleIndex
                    += dwFirstHelp;

                // 
                // Figure out the first counter definition.  It starts
                // after the PERF_OBJECT_TYPE structure, which is the
                // first iten in the W3DataDefinition.
                //
                pDefinition =  (PERF_COUNTER_DEFINITION*) 
                                            ((LPBYTE) (&W3GlobalDataDefinition) 
                                                    + sizeof(PERF_OBJECT_TYPE));

                //
                // Now simply walk through the counters incrementing
                // the pDefinition by on PERF_COUNTER_DEFINITION as you go.
                //
                for ( int i = 0; 
                          i < NUMBER_OF_W3_GLOBAL_COUNTERS; 
                          i++, pDefinition++ )
                {
                    pDefinition->CounterNameTitleIndex += dwFirstCounter;
                    pDefinition->CounterHelpTitleIndex += dwFirstHelp;
                }

            }
        }

        if( hkey != NULL )
        {
            RegCloseKey( hkey );
            hkey = NULL;
        }
        
    }

    return err;
}

/***************************************************************************++

Routine Description:

    Routine deletes the shared memory if it is in existence.

Arguments:

    None

Return Value:

    None

  Note:  It should always be called from inside a critical section.

--***************************************************************************/
VOID FreeSharedManager(BOOL HandleCallbackAsWell
    )
{

    //
    // Only clean up the callback handle if we are told
    // to, this is so we don't clean it up if we are 
    // in the middle of a callback call.
    //
    if ( HandleCallbackAsWell && g_hWASProcessWait )
    {
        if ( !UnregisterWait( g_hWASProcessWait ) )
        {
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(GetLastError()),
                "Could not unregister the old process wait handle \n"
                ));

        }

        g_hWASProcessWait = NULL;
    }

    //
    // Now clean up the shared memory object.
    //
    if ( g_pIISMemManager )
    {
        delete g_pIISMemManager;
        g_pIISMemManager = NULL;
    }

}

/***************************************************************************++

Routine Description:

    Routine drops the shared memory if the managing process of the memory
    goes away.

Arguments:

    LPVOID lpParameter - Unused
    BOOL   bUnused     - Unused

Return Value:

    None

--***************************************************************************/
VOID CALLBACK ShutdownMemory(
    PVOID lpUnused,
    BOOLEAN   bUnused
    )
{

    EnterCriticalSection ( &g_IISMemManagerCriticalSection );

    FreeSharedManager(FALSE);

    LeaveCriticalSection ( &g_IISMemManagerCriticalSection );

}


/***************************************************************************++

Routine Description:

   Helper function to hook up to shared memory when we are ready to 
   provide counters.

Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD
HookUpSharedMemory()
{
    DWORD dwErr = ERROR_SUCCESS;

    //
    // If we are not hooked up to the manager than hook up.
    //
    if ( !g_pIISMemManager )
    {
        //
        // Hook up to the manager of the shared memory.
        //
        g_pIISMemManager = new PERF_SM_MANAGER();
        if ( ! g_pIISMemManager )
        {
            dwErr = ERROR_OUTOFMEMORY;
            goto exit;
        }

        //
        // Initialize the memory manager for readonly access
        //
        dwErr = g_pIISMemManager->Initialize(FALSE);
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        //
        // if we re-initialized then we need to setup the
        // wait on the process again.  it is possible that 
        // the previous wait has not been cleaned up (since
        // we can't clean it up in the callback function) so
        // if this is the case we need to clean it up first.
        //
        if ( g_hWASProcessWait != NULL )
        {
            if ( !UnregisterWait( g_hWASProcessWait ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Could not unregister the old process wait handle \n"
                    ));

            }

            g_hWASProcessWait = NULL;
        }
    
        //
        // Register to wait on the managing process,
        // so we release any shared memory if the managing
        // process shutsdown or crashes.
        //
        if ( !RegisterWaitForSingleObject( &g_hWASProcessWait,
                                          g_pIISMemManager->GetWASProcessHandle(),
                                          &ShutdownMemory,
                                          NULL,
                                          INFINITE,
                                          WT_EXECUTEONLYONCE | 
                                          WT_EXECUTEINIOTHREAD ) )
        {
            dwErr = GetLastError();
                        
            DPERROR(( 
                DBG_CONTEXT,
                HRESULT_FROM_WIN32(dwErr),
                "Could not register to wait on the process handle \n"
                ));

            goto exit;

        }

        //
        // Initialize a reader to point to the appropriate
        // counter set.
        //
        dwErr = g_pIISMemManager->CreateNewCounterSet( SITE_COUNTER_SET );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }

        //
        // Initialize a reader to point to the appropriate
        // counter set.
        //
        dwErr = g_pIISMemManager->CreateNewCounterSet( GLOBAL_COUNTER_SET );
        if ( dwErr != ERROR_SUCCESS )
        {
            goto exit;
        }
    }

    //
    // Whether we just hooked up to the memory or not, we still want
    // to do one final check to make sure the memory is still valid.
    // It might have been invalidated in since the last gathering, or
    // it might have been invalidated while we were hooking up the 
    // wait on the process id.  Either way, if it is now not valid,
    // drop it.
    //

    if ( g_pIISMemManager->ReleaseIsNeeded() )
    {
        // 
        // The exit will take care of deleteing
        // the memory manager which will release 
        // the files.
        //
        dwErr = ERROR_NOT_READY;
        goto exit;
    }

exit:

    if ( dwErr != ERROR_SUCCESS )
    {
        FreeSharedManager(TRUE);
    }

    return dwErr;
}


//
//  Public Exported functions.
//

/***************************************************************************++

Routine Description:

   Is called to initialize any memory data structures needed for 
   supporting the performance counter publishing.
    
Arguments:

   LPWSTR lpDeviceNames - Poitner to object ID of each device
                          to be opened.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD OpenW3PerformanceData( LPWSTR lpDeviceNames )
{
    DWORD dwErr = ERROR_SUCCESS;
    static BOOL fInit = FALSE;


    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - OpenW3PerformanceData routine \n"
            ));
    }

    //
    // If we are the first one here then we can setup the
    // objects the correct way.  
    //
    // Note:  this is not neccessarily completely safe, but
    //        it really isn't that big of a problem if these
    //        objects get setup twice.
    //
    if ( !fInit )
    {
        //
        // Setup the event log so we can log errors.
        //
        // If this fails then the g_pEventLog will still
        // be null.  We would not fail in this case, and
        // since we do not have the event viewer we really
        // don't have any place to log a message.  We will
        // validate that this has been set before using it
        // throughout the code.
        //
        g_pEventLog = new EVENT_LOG(L"W3CTRS");

        //
        // Establish all machine static information about
        // the counters.
        //
        dwErr = EstablishIndexes();
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_W3SVC_REGISTRATION_MAY_BE_BAD, // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }

            goto exit;
        }

        fInit = TRUE;


    }

exit:

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - OpenW3PerformanceData routine \n"
            ));
    }

    return dwErr;

}   // OpenW3PerformanceData


/***************************************************************************++

Routine Description:

   Is called to retrieve counters from our library.
    
Arguments:

     LPWSTR    lpValueName      - Name fo the set of counters to retrieve.

     LPVOID  * lppData          - On entry contains a pointer to the buffer to
                                  receive the completed PerfDataBlock & subordinate
                                  structures.  On exit, points to the first bytes
                                  *after* the data structures added by this routine.

     LPDWORD   lpcbTotalBytes  - On entry contains a pointer to the
                                 size (in BYTEs) of the buffer referenced by lppData.
                                 On exit, contains the number of BYTEs added by this
                                 routine.

     LPDWORD   lpNumObjectTypes - Receives the number of objects added
                                  by this routine.

Return Value:

    DWORD             -  Win32 Error Code  (MUST be either NO_ERROR or ERROR_MORE_DATA)

--***************************************************************************/
DWORD CollectW3PerformanceData( 
     LPWSTR    lpValueName,
     LPVOID  * lppData,
     LPDWORD   lpcbTotalBytes,
     LPDWORD   lpNumObjectTypes 
     )
{
    DBG_ASSERT ( lppData );
    DBG_ASSERT ( lpcbTotalBytes );
    DBG_ASSERT ( lpNumObjectTypes );

    LPVOID                  pData           = *lppData;

    COUNTER_GLOBAL_STRUCT*  pSiteObject     = NULL;
    LPVOID                  pSiteInstance   = NULL;
    COUNTER_GLOBAL_STRUCT*  pGlobalObject   = NULL;
    LPVOID                  pGlobalInstance = NULL;

    DWORD                   dwErr           = ERROR_SUCCESS;

    DWORD                   dwSiteSize      = 0;
    DWORD                   dwGlobalSize    = 0;
    DWORD                   dwTotalSize     = 0;

    DWORD                   dwQueryType     = GetQueryType( lpValueName );

    BOOL                    fGetSites       = TRUE;
    BOOL                    fGetGlobal      = TRUE;

    DWORD                   NumObjects      = 2;


    //
    // Figure out if it is a query type we do not support.
    //
    if (( dwQueryType == QUERY_FOREIGN ) || (dwQueryType == QUERY_COSTLY))
    {
        // We don't do foreign queries
        
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;

        return ERROR_SUCCESS;
    }

    //
    // If it is a query by item, then figure out if we own any of the
    // items it is referring to.
    //
    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        W3DataDefinition.W3ObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            fGetSites = FALSE;
            NumObjects--;

        }

        if( !IsNumberInUnicodeList(
                        W3GlobalDataDefinition.W3GlobalObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            fGetGlobal = FALSE;
            NumObjects--;
       
        }

        if ( NumObjects == 0 ) 
        {
            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;

            return ERROR_SUCCESS;
        }
    }

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - CollectW3PerformanceData routine \n"
            ));
    }

    // 
    // if we got this far then we know that we want to get something.
    //
    EnterCriticalSection ( &g_IISMemManagerCriticalSection );

    dwErr = HookUpSharedMemory();
    if ( dwErr != ERROR_SUCCESS )
    {
        // 
        // According to the perf by laws you can only
        // return Success or More Data from here so 
        // we will return Success.
        // 

        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        dwErr = ERROR_SUCCESS;

        goto exit;
    }

    DBG_ASSERT ( g_pIISMemManager );

    //
    // Now check that the memory has been updated recently.  If it has 
    // not been then we need to ping WAS and let them know that we need
    // new data, and wait on that new data.
    //
    if ( ! g_pIISMemManager->EvaluateIfCountersAreFresh() )
    {
        if ( g_pEventLog )
        {
            g_pEventLog->
                LogEvent(
                    W3_W3SVC_REFRESH_TAKING_TOO_LONG, // message id
                    0,                                // count of strings
                    NULL,                             // array of strings
                    0                                // error code
                    );
        }
    }

    if ( fGetSites)
    {
        //
        // Get the counter information from shared memory.
        //
        dwErr = g_pIISMemManager->GetCounterInfo(SITE_COUNTER_SET, 
                                                 &pSiteObject, 
                                                 &pSiteInstance);
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_UNABLE_QUERY_W3SVC_DATA,       // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }
           
            // 
            // According to the perf by laws you can only
            // return Success or More Data from here so 
            // we will need to log the error and then return
            // Success, since this does not mean we have more data.
            // 

            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            dwErr = ERROR_SUCCESS;

            goto exit;
        }

        dwSiteSize = sizeof(W3DataDefinition) + pSiteObject->SizeData;

    }


    if ( fGetGlobal )
    {
        //
        // Get the counter information from shared memory.
        //
        dwErr = g_pIISMemManager->GetCounterInfo(GLOBAL_COUNTER_SET, 
                                                 &pGlobalObject, 
                                                 &pGlobalInstance);
        if ( dwErr != ERROR_SUCCESS )
        {
            if ( g_pEventLog )
            {
                g_pEventLog->
                    LogEvent(
                        W3_UNABLE_QUERY_W3SVC_DATA,       // message id
                        0,                                // count of strings
                        NULL,                             // array of strings
                        HRESULT_FROM_WIN32(dwErr)         // error code
                        );
            }

            // 
            // According to the perf by laws you can only
            // return Success or More Data from here so 
            // we will need to log the error and then return
            // Success, since this does not mean we have more data.
            // 

            *lpcbTotalBytes = 0;
            *lpNumObjectTypes = 0;
            dwErr = ERROR_SUCCESS;

            goto exit;
        }

        dwGlobalSize = sizeof(W3GlobalDataDefinition) + 
                       pGlobalObject->SizeData;

    }

    //
    // Figure out the total size of the memory
    //
    dwTotalSize = dwSiteSize + dwGlobalSize;

    //
    //  If we don't have room tell the counter library.
    //
    if ( dwTotalSize > *lpcbTotalBytes )
    {
        *lpcbTotalBytes = 0;
        *lpNumObjectTypes = 0;
        dwErr = ERROR_MORE_DATA;

        goto exit;

    }

    if ( fGetSites )
    {
        //
        // Copy in the definition of the data for sites.
        //
        memcpy (pData, &W3DataDefinition, sizeof(W3DataDefinition));
        ((PERF_OBJECT_TYPE*) pData)->NumInstances = pSiteObject->NumInstances;
        ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = dwSiteSize;
        pData = (LPBYTE) pData + sizeof(W3DataDefinition);

        // Copy in the actual data for sites
        memcpy ( pData, pSiteInstance, pSiteObject->SizeData );
        pData = (LPBYTE) pData + pSiteObject->SizeData;
    }

    if ( fGetGlobal )
    {
        //
        // Copy in the definition of the data for global
        //
        memcpy (pData, &W3GlobalDataDefinition, sizeof(W3GlobalDataDefinition));
        ((PERF_OBJECT_TYPE*) pData)->NumInstances = pGlobalObject->NumInstances;
        ((PERF_OBJECT_TYPE*) pData)->TotalByteLength = dwGlobalSize;
        pData = (LPBYTE) pData + sizeof(W3GlobalDataDefinition);

        // Copy in the actual data for global
        memcpy ( pData, pGlobalInstance, pGlobalObject->SizeData );
        pData = (LPBYTE) pData + pGlobalObject->SizeData;
    }

    // Make sure we didn't lie about the size.
    DBG_ASSERT ( dwTotalSize == DIFF((PCHAR) pData - (PCHAR) (*lppData)) );

    *lpcbTotalBytes = dwTotalSize;
    *lpNumObjectTypes = NumObjects;
    *lppData = pData;

    //
    // Let WAS know that we need new counters.
    //
    g_pIISMemManager->PingWASToRefreshCounters();

exit:

    LeaveCriticalSection ( &g_IISMemManagerCriticalSection );

    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - CollectW3PerformanceData routine \n"
            ));
    }

    return dwErr;

}   // CollectW3PerformanceData

/***************************************************************************++

Routine Description:

   Terminates the performance counters.
    
Arguments:

    None.

Return Value:

    DWORD             -  Win32 Error Code

--***************************************************************************/
DWORD CloseW3PerformanceData( VOID )
{
    //
    // On tclose tell the timer queue to stop launching
    // the checking code.
    //
    // Note if someone calls close and then collect again
    // we will have stopped listening to notifications from
    // w3svc and will not know when to drop the memory.
    //
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Entering W3CTRS - CloseW3PerformanceData routine \n"
            ));
    }

    EnterCriticalSection ( &g_IISMemManagerCriticalSection );
    
    FreeSharedManager(TRUE);

    LeaveCriticalSection( &g_IISMemManagerCriticalSection );

    if ( g_pEventLog )
    {
        delete g_pEventLog;

        g_pEventLog = NULL;
    }
    
    IF_DEBUG( WEB_ADMIN_SERVICE_PERFCOUNT )
    {
        DBGPRINTF((
            DBG_CONTEXT,
            "Exiting W3CTRS - CloseW3PerformanceData routine \n"
            ));
    }

    return ERROR_SUCCESS;

}   // CloseW3PerformanceData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\perfutil.h ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.h

   Abstract:

      This file supports routines used to parse and create Performance Monitor
       Data structures, used by all the Internet Services product.

   Author:

       Emily Kruglick    ( EmilyK )    28-Sep-2000  
         Ported from IIS 5 tree.

   Environment:

      User Mode

   Project:
   
       Internet Services Common Runtime code

   Revision History:


--*/

# ifndef _PERFUTIL_H_
# define _PERFUTIL_H_

//
//  Utility macro.  This is used to reserve a DWORD multiple of
//  bytes for Unicode strings embedded in the definitional data,
//  viz., object instance names.
//

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))
#define QWORD_MULTIPLE(x) ((((x)+sizeof(LONGLONG)-1)/sizeof(LONGLONG))*sizeof(LONGLONG))


/************************************************************
 *     Symbolic Constants
 ************************************************************/


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4


/************************************************************
 *     Function Declarations
 ************************************************************/

DWORD
GetQueryType (IN LPWSTR lpwszValue);

BOOL
IsNumberInUnicodeList (IN DWORD dwNumber, IN LPWSTR lpwszUnicodeList);

# endif // _PERFUTIL_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) w3ctrs.ini
    $(MY_BINPLACE) w3ctrs.h
    $(MY_BINPLACE) w3ctrs.reg

.\w3msg.h .\msg00001.bin .\w3msg.rc : .\w3msg.mc
        mc -v  w3msg.mc

clean::
    -del w3msg.h w3msg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\main.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Main entry points for the perf lib dll.

Author:

    Emily Kruglick (EmilyK)   11-Sep-2000

Revision History:

--*/


#include "wasdbgut.h"
#include "iisdef.h"
#include "winperf.h"
#include "perf_sm.h"
#include "regconst.h"

//
// global variables
//

// debug support
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

extern CRITICAL_SECTION g_IISMemManagerCriticalSection;
extern PERF_SM_MANAGER* g_pIISMemManager;
extern LONG             g_IISNumberInitialized;
extern HANDLE           g_hWASProcessWait;


/***************************************************************************++

Routine Description:

    The dll entry point. Used to set up debug libraries, etc.

Arguments:

    DllHandle - The dll module handle for this dll. Does not need to be
    closed.

    Reason - The dll notification reason.

    pReserved - Reserved, not used.

Return Value:

    BOOL

--***************************************************************************/

extern "C"
BOOL
WINAPI
DllMain(
    HINSTANCE DllHandle,
    DWORD Reason,
    LPVOID pReserved
    )
{

    BOOL Success = TRUE;
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER( pReserved );

    switch ( Reason )
    {

    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( WEB_ADMIN_SERVICE_NAME_A );

        LOAD_DEBUG_FLAGS_FROM_REG_STR( REGISTRY_KEY_W3SVC_PARAMETERS_A, 0 );

        Success = VALID_DEBUG_PRINT_OBJECT();

        if ( ! Success )
        {
            DBGPRINTF((
                DBG_CONTEXT,
                "Debug print object is not valid\n"
                ));

            goto exit;
        }


        Success = DisableThreadLibraryCalls( DllHandle );

        if ( ! Success )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );

            DPERROR((
                DBG_CONTEXT,
                hr,
                "Disabling thread library calls failed\n"
                ));

            goto exit;
        }

        InitializeCriticalSection( &g_IISMemManagerCriticalSection );

        g_IISNumberInitialized = 0;
 
        g_pIISMemManager = NULL;

        g_hWASProcessWait = NULL;

        break;

    case DLL_PROCESS_DETACH:

        if ( g_hWASProcessWait != NULL )
        {
            if ( !UnregisterWait( g_hWASProcessWait ) )
            {
                DPERROR(( 
                    DBG_CONTEXT,
                    HRESULT_FROM_WIN32(GetLastError()),
                    "Could not unregister the old process wait handle \n"
                    ));

            }

            g_hWASProcessWait = NULL;
        }

        // DBG_ASSERT ( g_pIISMemManager == NULL );

        DeleteCriticalSection ( &g_IISMemManagerCriticalSection );

        DELETE_DEBUG_PRINT_OBJECT();

        break;

    default:

        break;

    }


exit:

    return Success;

}   // DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\perfutil.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      perfutil.cxx

   Abstract:

      This file implements the utility routines for 
      IIS W3 Perf Counters.

   Author:

       Emily Kruglick   ( EmilyK )     28-Sep-2000  
          Ported from IIS 5 tree.

   Environment:
       User Mode
       
   Project:

       Internet Servies Common Runtime functions

   Functions Exported:

        DWORD GetQueryType();
        BOOL  IsNumberInUnicodeList();

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <windows.h>
#include <string.h>

#include <winperf.h>
#include <perfutil.h>


/************************************************************
 *     Global Data Definitions
 ************************************************************/

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN_ON_QWORD(x) \
     ((VOID *)(((ULONG_PTR)(x) + ((8)-1)) & ~((ULONG_PTR)(8)-1)))

/************************************************************
 *    Functions 
 ************************************************************/

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3ctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    iis6ctrs.h

    Offset definitions for the W3 Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    W3OpenPerformanceData procecedure, they will be added to the
    W3 Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the IIS6CTRS.DLL DLL code as well as the
    IIS6CTRS.INI definition file.  IIS6CTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        KestutiP    15-May-1999 Added Service Uptime counters
        EmilyK      10-Sept-2000 Altered to be IIS6CTRS

*/


#ifndef _IIS6CTRS_H_
#define _IIS6CTRS_H_


//
//  The W3 Server counter object.
//

#define W3_COUNTER_OBJECT                     0

//
//  The individual counters.
//
#define W3_BYTES_SENT_COUNTER                          2
#define W3_BYTES_SENT_PER_SEC                          4
#define W3_BYTES_RECEIVED_COUNTER                      6
#define W3_BYTES_RECEIVED_PER_SEC                      8

#define W3_BYTES_TOTAL_COUNTER                         10
#define W3_BYTES_TOTAL_PER_SEC                         12
#define W3_FILES_SENT_COUNTER                          14

#define W3_FILES_SENT_SEC                              16
#define W3_FILES_RECEIVED_COUNTER                      18
#define W3_FILES_RECEIVED_SEC                          20
#define W3_FILES_TOTAL_COUNTER                         22
#define W3_FILES_SEC                                   24

#define W3_CURRENT_ANONYMOUS_COUNTER                   26
#define W3_CURRENT_NONANONYMOUS_COUNTER                28
#define W3_TOTAL_ANONYMOUS_COUNTER                     30
#define W3_ANONYMOUS_USERS_SEC                         32
#define W3_TOTAL_NONANONYMOUS_COUNTER                  34

#define W3_NON_ANONYMOUS_USERS_SEC                     36
#define W3_MAX_ANONYMOUS_COUNTER                       38
#define W3_MAX_NONANONYMOUS_COUNTER                    40
#define W3_CURRENT_CONNECTIONS_COUNTER                 42
#define W3_MAX_CONNECTIONS_COUNTER                     44

#define W3_CONNECTION_ATTEMPTS_COUNTER                 46
#define W3_CONNECTION_ATTEMPTS_SEC                     48
#define W3_LOGON_ATTEMPTS_COUNTER                      50
#define W3_LOGON_ATTEMPTS_SEC                          52
#define W3_TOTAL_OPTIONS_COUNTER                       54

#define W3_TOTAL_OPTIONS_SEC                           56
#define W3_TOTAL_GETS_COUNTER                          58
#define W3_TOTAL_GETS_SEC                              60
#define W3_TOTAL_POSTS_COUNTER                         62
#define W3_TOTAL_POSTS_SEC                             64

#define W3_TOTAL_HEADS_COUNTER                         66
#define W3_TOTAL_HEADS_SEC                             68
#define W3_TOTAL_PUTS_COUNTER                          70
#define W3_TOTAL_PUTS_SEC                              72
#define W3_TOTAL_DELETES_COUNTER                       74

#define W3_TOTAL_DELETES_SEC                           76
#define W3_TOTAL_TRACES_COUNTER                        78
#define W3_TOTAL_TRACES_SEC                            80
#define W3_TOTAL_MOVE_COUNTER                          82
#define W3_TOTAL_MOVE_SEC                              84

#define W3_TOTAL_COPY_COUNTER                          86
#define W3_TOTAL_COPY_SEC                              88
#define W3_TOTAL_MKCOL_COUNTER                         90
#define W3_TOTAL_MKCOL_SEC                             92
#define W3_TOTAL_PROPFIND_COUNTER                      94

#define W3_TOTAL_PROPFIND_SEC                          96
#define W3_TOTAL_PROPPATCH_COUNTER                     98
#define W3_TOTAL_PROPPATCH_SEC                         100
#define W3_TOTAL_SEARCH_COUNTER                        102
#define W3_TOTAL_SEARCH_SEC                            104

#define W3_TOTAL_LOCK_COUNTER                          106
#define W3_TOTAL_LOCK_SEC                              108
#define W3_TOTAL_UNLOCK_COUNTER                        110
#define W3_TOTAL_UNLOCK_SEC                            112
#define W3_TOTAL_OTHERS_COUNTER                        114

#define W3_TOTAL_OTHERS_SEC                            116
#define W3_TOTAL_REQUESTS_COUNTER                      118
#define W3_TOTAL_REQUESTS_SEC                          120
#define W3_TOTAL_CGI_REQUESTS_COUNTER                  122
#define W3_CGI_REQUESTS_SEC                            124

#define W3_TOTAL_BGI_REQUESTS_COUNTER                  126
#define W3_BGI_REQUESTS_SEC                            128
#define W3_TOTAL_NOT_FOUND_ERRORS_COUNTER              130
#define W3_TOTAL_NOT_FOUND_ERRORS_SEC                  132
#define W3_TOTAL_LOCKED_ERRORS_COUNTER                 134

#define W3_TOTAL_LOCKED_ERRORS_SEC                     136
#define W3_CURRENT_CGI_COUNTER                         138
#define W3_CURRENT_BGI_COUNTER                         140
#define W3_MAX_CGI_COUNTER                             142
#define W3_MAX_BGI_COUNTER                             144

#define W3_CURRENT_CAL_AUTH_COUNTER                    146
#define W3_MAX_CAL_AUTH_COUNTER                        148
#define W3_TOTAL_FAILED_CAL_AUTH_COUNTER               150
#define W3_CURRENT_CAL_SSL_COUNTER                     152
#define W3_MAX_CAL_SSL_COUNTER                         154

#define W3_BLOCKED_REQUESTS_COUNTER                    156
#define W3_ALLOWED_REQUESTS_COUNTER                    158
#define W3_REJECTED_REQUESTS_COUNTER                   160
#define W3_CURRENT_BLOCKED_REQUESTS_COUNTER            162
#define W3_TOTAL_FAILED_CAL_SSL_COUNTER                164

#define W3_MEASURED_BANDWIDTH_COUNTER                  166
#define W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER       168
#define W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER     170
#define W3_SERVICE_UPTIME_COUNTER                      172


//
//  The IIS Global Counters
//

#define W3_GLOBAL_COUNTER_OBJECT             174


//
//  The individual counters.
//

#define W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER              176
#define W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER                178
#define W3_GLOBAL_FILE_CACHE_HITS_COUNTER                   180
#define W3_GLOBAL_FILE_CACHE_MISSES_COUNTER                 182

#define W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER              184
#define W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM        186
#define W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER                188
#define W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER   190
#define W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER       192

#define W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER              194
#define W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER               196
#define W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER               198
#define W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER                 200
#define W3_GLOBAL_URI_CACHE_HITS_COUNTER                    202

#define W3_GLOBAL_URI_CACHE_MISSES_COUNTER                  204
#define W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER               206
#define W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM         208
#define W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER                 210
#define W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER                212

#define W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER               214
#define W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER                 216
#define W3_GLOBAL_METADATA_CACHE_HITS_COUNTER                   218
#define W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER                 220
#define W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER              222

#define W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM        224
#define W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER                226
#define W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER                228
#define W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER            230
#define W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER              232

#define W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER                 234
#define W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC                 236
#define W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER               238
#define W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER            240
#define W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM      242

#define W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER              244
#define W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER             246

#endif  // _IIS6CTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3data.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1996           **/
/**********************************************************************/

/*
    w3ata.cxx

    Constant data structures for the W3 Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        Bob Watson/MuraliK     03-Oct-1996 - Added rate counters for W3.
        EmilyK      10-Sep-2000 Altered to be cxx as well as other IIS 6 changes

*/

#include <windows.h>
#include <winperf.h>
#include <w3ctrs.h>
#include <perfcount.h>
#include <w3data.h>

W3_COUNTER_BLOCK     w3c;
W3_GLOBAL_COUNTER_BLOCK IISGlobal;

//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

W3_DATA_DEFINITION W3DataDefinition =
{
    {   // W3ObjectType
        sizeof(W3_DATA_DEFINITION), // + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_COUNTER_OBJECT,
        NULL,
        W3_COUNTER_OBJECT,
        NULL,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_COUNTERS,
        5,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // W3BytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_COUNTER,
        NULL,
        W3_BYTES_SENT_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesSent)
    },

    {   // W3BytesSent/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_SENT_PER_SEC,
        NULL,
        W3_BYTES_SENT_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesSent)
    },

    {   // W3BytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_COUNTER,
        NULL,
        W3_BYTES_RECEIVED_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesReceived)
    },


    {   // W3BytesReceived/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_RECEIVED_PER_SEC,
        NULL,
        W3_BYTES_RECEIVED_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesReceived)
    },

    {   // W3BytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_COUNTER,
        NULL,
        W3_BYTES_TOTAL_COUNTER,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(w3c.BytesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesTotal)
    },

    {   // W3BytesTotal/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BYTES_TOTAL_PER_SEC,
        NULL,
        W3_BYTES_TOTAL_PER_SEC,
        NULL,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(w3c.BytesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BytesTotal)
    },

    {   // W3FilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_COUNTER,
        NULL,
        W3_FILES_SENT_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesSent)
    },

    {   // W3FilesSentSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SENT_SEC,
        NULL,
        W3_FILES_SENT_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesSent),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesSent)
    },

    {   // W3FilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_COUNTER,
        NULL,
        W3_FILES_RECEIVED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesReceived)
    },

    {   // W3FilesReceivedSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_RECEIVED_SEC,
        NULL,
        W3_FILES_RECEIVED_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesReceived),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesReceived)
    },

    {   // W3FilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_TOTAL_COUNTER,
        NULL,
        W3_FILES_TOTAL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.FilesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesTotal)
    },

    {   // W3FilesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_FILES_SEC,
        NULL,
        W3_FILES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.FilesTotal),
        FIELD_OFFSET(W3_COUNTER_BLOCK, FilesTotal)
    },

    {   // W3CurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_ANONYMOUS_COUNTER,
        NULL,
        W3_CURRENT_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentAnonymous)
    },

    {   // W3CurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_NONANONYMOUS_COUNTER,
        NULL,
        W3_CURRENT_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentNonAnonymous)
    },

    {   // W3TotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_ANONYMOUS_COUNTER,
        NULL,
        W3_TOTAL_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalAnonymous)
    },

    {   // W3TotalAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ANONYMOUS_USERS_SEC,
        NULL,
        W3_ANONYMOUS_USERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalAnonymous)
    },

    {   // W3NonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NONANONYMOUS_COUNTER,
        NULL,
        W3_TOTAL_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNonAnonymous)
    },

    {   // W3NonAnonymous/Sec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_NON_ANONYMOUS_USERS_SEC,
        NULL,
        W3_NON_ANONYMOUS_USERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNonAnonymous)
    },

    {   // W3MaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_ANONYMOUS_COUNTER,
        NULL,
        W3_MAX_ANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxAnonymous)
    },

    {   // W3MaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_NONANONYMOUS_COUNTER,
        NULL,
        W3_MAX_NONANONYMOUS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxNonAnonymous),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxNonAnonymous)
    },

    {   // W3CurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CONNECTIONS_COUNTER,
        NULL,
        W3_CURRENT_CONNECTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentConnections),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentConnections)
    },

    {   // W3MaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CONNECTIONS_COUNTER,
        NULL,
        W3_MAX_CONNECTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxConnections),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxConnections)
    },

    {   // W3ConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_COUNTER,
        NULL,
        W3_CONNECTION_ATTEMPTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ConnectionAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ConnectionAttempts)
    },
    {   // W3ConnectionsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CONNECTION_ATTEMPTS_SEC,
        NULL,
        W3_CONNECTION_ATTEMPTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.ConnectionAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ConnectionAttempts)
    },

    {   // W3LogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_COUNTER,
        NULL,
        W3_LOGON_ATTEMPTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.LogonAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, LogonAttempts)
    },

    {   // W3LogonAttemptsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_LOGON_ATTEMPTS_SEC,
        NULL,
        W3_LOGON_ATTEMPTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.LogonAttempts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, LogonAttempts)
    },

    {   // W3TotalOptions
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_COUNTER,
        NULL,
        W3_TOTAL_OPTIONS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOptions),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOptions)
    },

    {   // W3TotalOptionsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OPTIONS_SEC,
        NULL,
        W3_TOTAL_OPTIONS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOptions),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOptions)
    },

    {   // W3TotalGets
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_COUNTER,
        NULL,
        W3_TOTAL_GETS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalGets),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalGets)
    },

    {   // W3TotalGetsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_GETS_SEC,
        NULL,
        W3_TOTAL_GETS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalGets),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalGets)
    },

    {   // W3TotalPosts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_COUNTER,
        NULL,
        W3_TOTAL_POSTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPosts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPosts)
    },

    {   // W3TotalPostsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_POSTS_SEC,
        NULL,
        W3_TOTAL_POSTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPosts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPosts)
    },

    {   // W3TotalHeads
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_COUNTER,
        NULL,
        W3_TOTAL_HEADS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalHeads),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalHeads)
    },

    {   // W3TotalHeadsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_HEADS_SEC,
        NULL,
        W3_TOTAL_HEADS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalHeads),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalHeads)
    },

    {   // W3TotalPuts
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_COUNTER,
        NULL,
        W3_TOTAL_PUTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPuts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPuts)
    },

    {   // W3TotalPutsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PUTS_SEC,
        NULL,
        W3_TOTAL_PUTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPuts),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPuts)
    },

    {   // W3TotalDeletes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_COUNTER,
        NULL,
        W3_TOTAL_DELETES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalDeletes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalDeletes)
    },

    {   // W3TotalDeletesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_DELETES_SEC,
        NULL,
        W3_TOTAL_DELETES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalDeletes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalDeletes)
    },

    {   // W3TotalTraces
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_COUNTER,
        NULL,
        W3_TOTAL_TRACES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalTraces),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalTraces)
    },

    {   // W3TotalTracesSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_TRACES_SEC,
        NULL,
        W3_TOTAL_TRACES_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalTraces),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalTraces)
    },

    {   // W3TotalMove
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_COUNTER,
        NULL,
        W3_TOTAL_MOVE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMove),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMove)
    },

    {   // W3TotalMoveSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MOVE_SEC,
        NULL,
        W3_TOTAL_MOVE_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMove),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMove)
    },

    {   // W3TotalCopy
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_COUNTER,
        NULL,
        W3_TOTAL_COPY_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCopy),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCopy)
    },

    {   // W3TotalCopySec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_COPY_SEC,
        NULL,
        W3_TOTAL_COPY_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCopy),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCopy)
    },

    {   // W3TotalMkcol
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_COUNTER,
        NULL,
        W3_TOTAL_MKCOL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalMkcol),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMkcol)
    },

    {   // W3TotalMkcolSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_MKCOL_SEC,
        NULL,
        W3_TOTAL_MKCOL_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalMkcol),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalMkcol)
    },

    {   // W3TotalPropfind
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_COUNTER,
        NULL,
        W3_TOTAL_PROPFIND_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalPropfind),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPropfind)
    },

    {   // W3TotalPropfindSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPFIND_SEC,
        NULL,
        W3_TOTAL_PROPFIND_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalPropfind),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalPropfind)
    },

    {   // W3TotalProppatch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_COUNTER,
        NULL,
        W3_TOTAL_PROPPATCH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalProppatch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalProppatch)
    },

    {   // W3TotalProppatchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_PROPPATCH_SEC,
        NULL,
        W3_TOTAL_PROPPATCH_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalProppatch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalProppatch)
    },

    {   // W3TotalSearch
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_COUNTER,
        NULL,
        W3_TOTAL_SEARCH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalSearch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalSearch)
    },

    {   // W3TotalSearchSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_SEARCH_SEC,
        NULL,
        W3_TOTAL_SEARCH_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalSearch),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalSearch)
    },

    {   // W3TotalLock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_COUNTER,
        NULL,
        W3_TOTAL_LOCK_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLock)
    },

    {   // W3TotalLockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCK_SEC,
        NULL,
        W3_TOTAL_LOCK_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLock)
    },

    {   // W3TotalUnlock
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_COUNTER,
        NULL,
        W3_TOTAL_UNLOCK_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalUnlock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalUnlock)
    },

    {   // W3TotalUnlockSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_UNLOCK_SEC,
        NULL,
        W3_TOTAL_UNLOCK_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalUnlock),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalUnlock)
    },

    {   // W3TotalOthers
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_COUNTER,
        NULL,
        W3_TOTAL_OTHERS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalOthers),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOthers)
    },

    {   // W3TotalOthersSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_OTHERS_SEC,
        NULL,
        W3_TOTAL_OTHERS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalOthers),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalOthers)
    },

    {   // W3TotalRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalRequests)
    },

    {   // W3TotalRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_REQUESTS_SEC,
        NULL,
        W3_TOTAL_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalRequests)
    },

    {   // W3TotalCGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_CGI_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCGIRequests)
    },

    {   // W3TotalCGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CGI_REQUESTS_SEC,
        NULL,
        W3_CGI_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalCGIRequests)
    },

    {   // W3TotalBGIRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        NULL,
        W3_TOTAL_BGI_REQUESTS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBGIRequests)
    },

    {   // W3TotalBGIRequestsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BGI_REQUESTS_SEC,
        NULL,
        W3_BGI_REQUESTS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBGIRequests)
    },

    {   // W3TotalNotFoundErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        NULL,
        W3_TOTAL_NOT_FOUND_ERRORS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalNotFoundErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNotFoundErrors)
    },

    {   // W3TotalNotFoundErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        NULL,
        W3_TOTAL_NOT_FOUND_ERRORS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalNotFoundErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalNotFoundErrors)
    },

    {   // W3TotalLockedErrors
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        NULL,
        W3_TOTAL_LOCKED_ERRORS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalLockedErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLockedErrors)
    },

    {   // W3TotalLockedErrorsSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_LOCKED_ERRORS_SEC,
        NULL,
        W3_TOTAL_LOCKED_ERRORS_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(w3c.TotalLockedErrors),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalLockedErrors)
    },

    {   // W3CurrentCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CGI_COUNTER,
        NULL,
        W3_CURRENT_CGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCGIRequests)
    },

    {   // W3CurrentBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BGI_COUNTER,
        NULL,
        W3_CURRENT_BGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBGIRequests)
    },

    {   // W3MaxCGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CGI_COUNTER,
        NULL,
        W3_MAX_CGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCGIRequests)
    },

    {   // W3MaxBGI
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_BGI_COUNTER,
        NULL,
        W3_MAX_BGI_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxBGIRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxBGIRequests)
    },

    {   // W3CurrentCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_AUTH_COUNTER,
        NULL,
        W3_CURRENT_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCalAuth)
    },

    {   // W3MaxCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_AUTH_COUNTER,
        NULL,
        W3_MAX_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCalAuth)
    },

    {   // W3TotalFailedCalAuth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        NULL,
        W3_TOTAL_FAILED_CAL_AUTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalAuth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalFailedCalAuth)
    },

    {   // W3CurrentCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_CAL_SSL_COUNTER,
        NULL,
        W3_CURRENT_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentCalSsl)
    },

    {   // W3MaxCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MAX_CAL_SSL_COUNTER,
        NULL,
        W3_MAX_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MaxCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MaxCalSsl)
    },

    {   // W3TotalFailedCalSsl
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        NULL,
        W3_TOTAL_FAILED_CAL_SSL_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalFailedCalSsl),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalFailedCalSsl)
    },

    {   // W3BlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.BlockedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, BlockedRequests)
    },
    
    {   // W3AllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        W3_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.AllowedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, AllowedRequests)
    },
    
    {   // W3RejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        W3_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.RejectedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, RejectedRequests)
    },
    
    {   // W3CurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        W3_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedRequests),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBlockedRequests)
    },
   
    {   // W3MeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        W3_MEASURED_BANDWIDTH_COUNTER,
        NULL,
        W3_MEASURED_BANDWIDTH_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.MeasuredBandwidth),
        FIELD_OFFSET(W3_COUNTER_BLOCK, MeasuredBandwidth)
    },

    {   // W3TotalBlockedBandwidthBytes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        W3_TOTAL_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.TotalBlockedBandwidthBytes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, TotalBlockedBandwidthBytes)
    },

    {   // W3CurrentBlockedBandwidthBytes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        W3_CURRENT_BLOCKED_BANDWIDTH_BYTES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.CurrentBlockedBandwidthBytes),
        FIELD_OFFSET(W3_COUNTER_BLOCK, CurrentBlockedBandwidthBytes)
    },

    {   // W3ServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        W3_SERVICE_UPTIME_COUNTER,
        NULL,
        W3_SERVICE_UPTIME_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(w3c.ServiceUptime),
        FIELD_OFFSET(W3_COUNTER_BLOCK, ServiceUptime)
    }
};

//
// Global Data Structure.
// 
//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//
W3_GLOBAL_DATA_DEFINITION W3GlobalDataDefinition =
{
    {   // W3GlobalObjectType
        sizeof(W3_GLOBAL_DATA_DEFINITION), // + sizeof (W3_COUNTER_BLOCK),
        sizeof(W3_GLOBAL_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        W3_GLOBAL_COUNTER_OBJECT,
        NULL,
        W3_GLOBAL_COUNTER_OBJECT,
        NULL,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_W3_GLOBAL_COUNTERS,
        2,                              // Default = ???
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // CurrentFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_FILES_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentFilesCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentFilesCached)
    },

    {   // TotalFilesCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FILES_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFilesCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFilesCached)
    },

    {   // FileCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHits)
    },
    {   // FileCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheMisses)
    },

    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.FileCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHits)
    },

    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_FILE_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.FileCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheHitRatio)
    },

    {   // FileCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_FILE_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.FileCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, FileCacheFlushes)
    },
    {   // CurrentFileCacheMemoryUsage
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(IISGlobal.CurrentFileCacheMemoryUsage),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentFileCacheMemoryUsage)
    },
    {   // MaxFileCacheMemoryUsage
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        W3_GLOBAL_MAX_FILE_CACHE_MEMORY_USAGE_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_LARGE_RAWCOUNT,
        sizeof(IISGlobal.MaxFileCacheMemoryUsage),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, MaxFileCacheMemoryUsage)
    },
    {   // ActiveFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER,
        NULL,
        W3_GLOBAL_ACTIVE_FLUSHED_FILES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.ActiveFlushedFiles),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, ActiveFlushedFiles)
    },
    {   // TotalFlushedFiles
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_FILES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedFiles),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedFiles)
    },
    {   // CurrentUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentUrisCached)
    },
    {   // TotalUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalUrisCached)
    },
    {   // UriCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHits)
    },
    {   // UriCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheMisses)
    },

    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.UriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHits)
    },

    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.UriCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheHitRatio)
    },

    {   // UriCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UriCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UriCacheFlushes)
    },
    {   // TotalFlushedUris
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedUris),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedUris)
    },
    {   // CurrentBlobsCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_CURRENT_METADATA_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.CurrentBlobsCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, CurrentBlobsCached)
    },
    {   // TotalBlobsCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_METADATA_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalBlobsCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalBlobsCached)
    },
    {   // BlobCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHits)
    },
    {   // BlobCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheMisses)
    },
    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.BlobCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHits)
    },
    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_METADATA_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.BlobCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheHitRatio)
    },
    {   // BlobCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_METADATA_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.BlobCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, BlobCacheFlushes)
    },
    {   // TotalFlushedBlobs
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER,
        NULL,
        W3_GLOBAL_TOTAL_FLUSHED_METADATA_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.TotalFlushedBlobs),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, TotalFlushedBlobs)
    },
    {   // UlCurrentUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_CURRENT_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlCurrentUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlCurrentUrisCached)
    },
    {   // UlTotalUrisCached
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_TOTAL_URIS_CACHED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlTotalUrisCached),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlTotalUrisCached)
    },
    {   // UlUriCacheHits
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // UlUriCacheHitsPerSec
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HITS_PER_SEC,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // UlUriCacheMisses
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_MISSES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheMisses),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheMisses)
    },
    {   // Calculated ratio of hits to total requests. - Numerator (cache hits)
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_FRACTION,
        sizeof(IISGlobal.UlUriCacheHits),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHits)
    },
    {   // Calculated ratio of hits to total requests - Denominator, (hits + misses)
        // Not Displayed
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_HIT_RATIO_COUNTER_DENOM,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_RAW_BASE,
        sizeof(IISGlobal.UlUriCacheHitRatio),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheHitRatio)
    },
    {   // UlUriCacheFlushes
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_URI_CACHE_FLUSHES_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlUriCacheFlushes),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlUriCacheFlushes)
    },
    {   // UlTotalFlushedUris
        sizeof(PERF_COUNTER_DEFINITION),
        W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        W3_GLOBAL_KERNEL_TOTAL_FLUSHED_URIS_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(IISGlobal.UlTotalFlushedUris),
        FIELD_OFFSET(W3_GLOBAL_COUNTER_BLOCK, UlTotalFlushedUris)
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\w3ctrs\w3data.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    w3data.h

    Extensible object definitions for the W3 Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        EmilyK      10-Sep-2000 Altered for IIS 6 counters implementation.

*/


#ifndef _W3DATA_H_
#define _W3DATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _W3_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            W3ObjectType;
    PERF_COUNTER_DEFINITION     W3BytesSent;
    PERF_COUNTER_DEFINITION     W3BytesSentSec;
    PERF_COUNTER_DEFINITION     W3BytesReceived;
    PERF_COUNTER_DEFINITION     W3BytesReceivedSec;

    PERF_COUNTER_DEFINITION     W3BytesTotal;
    PERF_COUNTER_DEFINITION     W3BytesTotalSec;
    PERF_COUNTER_DEFINITION     W3FilesSent;
    PERF_COUNTER_DEFINITION     W3FilesSentSec;
    PERF_COUNTER_DEFINITION     W3FilesReceived;

    PERF_COUNTER_DEFINITION     W3FilesReceivedSec;
    PERF_COUNTER_DEFINITION     W3FilesTotal;
    PERF_COUNTER_DEFINITION     W3FilesSec;
    PERF_COUNTER_DEFINITION     W3CurrentAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentNonAnonymous;

    PERF_COUNTER_DEFINITION     W3TotalAnonymous;
    PERF_COUNTER_DEFINITION     W3AnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3TotalNonAnonymous;
    PERF_COUNTER_DEFINITION     W3NonAnonymousUsersSec;
    PERF_COUNTER_DEFINITION     W3MaxAnonymous;

    PERF_COUNTER_DEFINITION     W3MaxNonAnonymous;
    PERF_COUNTER_DEFINITION     W3CurrentConnections;
    PERF_COUNTER_DEFINITION     W3MaxConnections;
    PERF_COUNTER_DEFINITION     W3ConnectionAttempts;
    PERF_COUNTER_DEFINITION     W3ConnectionAttemptsSec;

    PERF_COUNTER_DEFINITION     W3LogonAttempts;
    PERF_COUNTER_DEFINITION     W3LogonAttemptsSec;
    PERF_COUNTER_DEFINITION     W3TotalOptions;
    PERF_COUNTER_DEFINITION     W3TotalOptionsSec;
    PERF_COUNTER_DEFINITION     W3TotalGets;

    PERF_COUNTER_DEFINITION     W3TotalGetsSec;
    PERF_COUNTER_DEFINITION     W3TotalPosts;
    PERF_COUNTER_DEFINITION     W3TotalPostsSec;
    PERF_COUNTER_DEFINITION     W3TotalHeads;
    PERF_COUNTER_DEFINITION     W3TotalHeadsSec;

    PERF_COUNTER_DEFINITION     W3TotalPuts;
    PERF_COUNTER_DEFINITION     W3TotalPutsSec;
    PERF_COUNTER_DEFINITION     W3TotalDeletes;
    PERF_COUNTER_DEFINITION     W3TotalDeletesSec;
    PERF_COUNTER_DEFINITION     W3TotalTraces;

    PERF_COUNTER_DEFINITION     W3TotalTracesSec;
    PERF_COUNTER_DEFINITION     W3TotalMove;
    PERF_COUNTER_DEFINITION     W3TotalMoveSec;
    PERF_COUNTER_DEFINITION     W3TotalCopy;
    PERF_COUNTER_DEFINITION     W3TotalCopySec;

    PERF_COUNTER_DEFINITION     W3TotalMkcol;
    PERF_COUNTER_DEFINITION     W3TotalMkcolSec;
    PERF_COUNTER_DEFINITION     W3TotalPropfind;
    PERF_COUNTER_DEFINITION     W3TotalPropfindSec;
    PERF_COUNTER_DEFINITION     W3TotalProppatch;

    PERF_COUNTER_DEFINITION     W3TotalProppatchSec;
    PERF_COUNTER_DEFINITION     W3TotalSearch;
    PERF_COUNTER_DEFINITION     W3TotalSearchSec;

    PERF_COUNTER_DEFINITION     W3TotalLock;
    PERF_COUNTER_DEFINITION     W3TotalLockSec;
    PERF_COUNTER_DEFINITION     W3TotalUnlock;
    PERF_COUNTER_DEFINITION     W3TotalUnlockSec;
    PERF_COUNTER_DEFINITION     W3TotalOthers;

    PERF_COUNTER_DEFINITION     W3TotalOthersSec;
    PERF_COUNTER_DEFINITION     W3TotalRequests;
    PERF_COUNTER_DEFINITION     W3TotalRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalCGIRequests;
    PERF_COUNTER_DEFINITION     W3CGIRequestsSec;

    PERF_COUNTER_DEFINITION     W3TotalBGIRequests;
    PERF_COUNTER_DEFINITION     W3BGIRequestsSec;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrors;
    PERF_COUNTER_DEFINITION     W3TotalNotFoundErrorsSec;
    PERF_COUNTER_DEFINITION     W3TotalLockedErrors;

    PERF_COUNTER_DEFINITION     W3TotalLockedErrorsSec;
    PERF_COUNTER_DEFINITION     W3CurrentCGIRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxCGIRequests;
    PERF_COUNTER_DEFINITION     W3MaxBGIRequests;

    PERF_COUNTER_DEFINITION     W3CurrentCalAuth;
    PERF_COUNTER_DEFINITION     W3MaxCalAuth;
    PERF_COUNTER_DEFINITION     W3TotalFailedCalAuth;
    PERF_COUNTER_DEFINITION     W3CurrentCalSsl;
    PERF_COUNTER_DEFINITION     W3MaxCalSsl;

    PERF_COUNTER_DEFINITION     W3TotalFailedCalSsl;
    PERF_COUNTER_DEFINITION     W3BlockedRequests;
    PERF_COUNTER_DEFINITION     W3AllowedRequests;
    PERF_COUNTER_DEFINITION     W3RejectedRequests;
    PERF_COUNTER_DEFINITION     W3CurrentBlockedRequests;

    PERF_COUNTER_DEFINITION     W3MeasuredBandwidth;
    PERF_COUNTER_DEFINITION     W3TotalBlockedBandwidthBytes;
    PERF_COUNTER_DEFINITION     W3CurrentBlockedBandwidthBytes;
    PERF_COUNTER_DEFINITION     W3ServiceUptime;

} W3_DATA_DEFINITION;

//
//  The counter structure returned.
//

typedef struct _W3_GLOBAL_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            W3GlobalObjectType;

    PERF_COUNTER_DEFINITION     CurrentFilesCached;
    PERF_COUNTER_DEFINITION     TotalFilesCached;
    PERF_COUNTER_DEFINITION     FileCacheHits;
    PERF_COUNTER_DEFINITION     FileCacheMisses;
    PERF_COUNTER_DEFINITION     FileCacheHitRatio;
    PERF_COUNTER_DEFINITION     FileCacheHitRatioDenom;

    PERF_COUNTER_DEFINITION     FileCacheFlushes;
    PERF_COUNTER_DEFINITION     CurrentFileCacheMemoryUsage;
    PERF_COUNTER_DEFINITION     MaxFileCacheMemoryUsage;
    PERF_COUNTER_DEFINITION     ActiveFlushedFiles;
    PERF_COUNTER_DEFINITION     TotalFlushedFiles;

    PERF_COUNTER_DEFINITION     CurrentUrisCached;
    PERF_COUNTER_DEFINITION     TotalUrisCached;
    PERF_COUNTER_DEFINITION     UriCacheHits;
    PERF_COUNTER_DEFINITION     UriCacheMisses;
    PERF_COUNTER_DEFINITION     UriCacheHitRatio;
    PERF_COUNTER_DEFINITION     UriCacheHitRatioDenom;

    PERF_COUNTER_DEFINITION     UriCacheFlushes;
    PERF_COUNTER_DEFINITION     TotalFlushedUris;
    PERF_COUNTER_DEFINITION     CurrentBlobsCached;
    PERF_COUNTER_DEFINITION     TotalBlobsCached;
    PERF_COUNTER_DEFINITION     BlobCacheHits;

    PERF_COUNTER_DEFINITION     BlobCacheMisses;
    PERF_COUNTER_DEFINITION     BlobCacheHitRatio;
    PERF_COUNTER_DEFINITION     BlobCacheHitRatioDenom;
    PERF_COUNTER_DEFINITION     BlobCacheFlushes;
    PERF_COUNTER_DEFINITION     TotalFlushedBlobs;

    PERF_COUNTER_DEFINITION     UlCurrentUrisCached;
    PERF_COUNTER_DEFINITION     UlTotalUrisCached;
    PERF_COUNTER_DEFINITION     UlUriCacheHits; 
    PERF_COUNTER_DEFINITION     UlUriCacheHitsPerSec; 
    PERF_COUNTER_DEFINITION     UlUriCacheMisses; 

    PERF_COUNTER_DEFINITION     UlUriCacheHitRatio; 
    PERF_COUNTER_DEFINITION     UlUriCacheHitRatioDenom; 
    PERF_COUNTER_DEFINITION     UlUriCacheFlushes;
    PERF_COUNTER_DEFINITION     UlTotalFlushedUris;

} W3_GLOBAL_DATA_DEFINITION;

extern  W3_GLOBAL_DATA_DEFINITION    W3GlobalDataDefinition;
extern  W3_DATA_DEFINITION           W3DataDefinition;

extern  W3_COUNTER_BLOCK             w3c;
extern  W3_GLOBAL_COUNTER_BLOCK      W3Global;

#define NUMBER_OF_W3_COUNTERS ((sizeof(W3_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))

#define NUMBER_OF_W3_GLOBAL_COUNTERS ((sizeof(W3_GLOBAL_DATA_DEFINITION) -        \
                                        sizeof(PERF_OBJECT_TYPE)) /           \
                                         sizeof(PERF_COUNTER_DEFINITION))

//
//  Restore default packing & alignment.
//

#pragma pack()


#endif  // _W3DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\webserver\makefile.inc ===
#
# Defines build rules for targets that makefile.def
# won't build. !include this file in your makefile.inc
#

#build JAVAIMPORTS1 macro
!if "$(JAVACOMTLBIMPORTDST)" != ""
JAVAIMPORTS=$(JAVACOMTLBIMPORTDST);$(JAVAIMPORTS)
!endif

JAVAIMPORTS=$(JAVAIMPORTS: =)
JAVAIMPORTSDEPS=$(JAVAIMPORTS:;= )

!if "$(JAVAIMPORTS)" != ""
#put a semicolon in front, and remove the one in back
JAVAIMPORTS1=-$(JAVAIMPORTS)+
JAVAIMPORTS1=$(JAVAIMPORTS1:-;=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:-=;)
JAVAIMPORTS1=$(JAVAIMPORTS1:;+=)
JAVAIMPORTS1=$(JAVAIMPORTS1:+=)
!endif

####################################
# COOL COMPILER SPECIFIC
####################################

# Set java resource file flags
!if "$(JAVARES)" != ""
COMXCOOLRESFLAGS=/win32res:$(JAVARES)
!else
COMXCOOLRESFLAGS=
!endif

# Set java import files flags
!if "$(JAVAIMPORTS1)" != ""
COMXCOOLIMPORTFLAGS=$(JAVAIMPORTS1:;=-I:)
!else
COMXCOOLIMPORTFLAGS=
!endif

COMXCOOLCOMMAND=$(COMXCOOL) $(COMXCOOLFLAGS) $(COMXCOOLRESFLAGS) $(COMXCOOLIMPORTFLAGS)

#
# Build a COM+ java dll
#
!if "$(USE_COOL)" == "1"

# JAVAIMPORTS (Sytem.XSP.dll) is not part of our project, no use putting
# dependency on it.  We cannot build it even if it is outdated. 
!if "$(JAVADLL)" != ""
$(JAVADLL) : $(JAVASOURCES) $(JAVARES) # $(JAVAIMPORTSDEPS)
    $(COMXCOOLCOMMAND) -dll -out:$@ $(JAVASOURCES)
!endif

!endif

######################################
# END OF COMPILER SPECIFIC
######################################

#
# Build a type library from a COM+ java dll or exe
#
!if "$(JAVATLB)" != ""
$(JAVATLB) : $(JAVADLL) $(JAVAEXE)
    echo cl comreg_$**
    $(COMXCOMREG) $** -r $*.reg -xr
!endif

#
# Build a EE dll from a COM type library
#
!if "$(JAVACOMTLBIMPORTSRC)" != ""
!if "$(JAVACOMTLBIMPORTDST)" != ""
$(JAVACOMTLBIMPORTDST) : $(JAVACOMTLBIMPORTSRC)
    echo cl tlbimp_$**
    $(COMXTLBIMP) /Fe $@ /Tlb $**
!endif
!endif

#
# Build a COM+ VB dll or exe
#
!if "$(VBTARGET)" != ""
$(VBTARGET) : $(VBSOURCES) $(@B).vbp
    echo cl compiling_vb_files_into_dll
    $(COMXBC) -i:$(@B).vbp -o $(@B).dll -s $(@D)  $(COMXBCDIRECTIVES) $(VBDIRECTIVEFLAGS)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\webserver\place.inc ===
#
# Enable warning level 4, treat warnings as errors
#
# Use Unicode
#

C_DEFINES = $(C_DEFINES) /DUNICODE /D_UNICODE

#
# COM+ tools
#


COMXJVC=jvc
COMXSMC=smc
COMXCOOL=coolc
COMXCOMREG=comreg
COMXTLBIMP=tlbimp
COMXBC=bc

!IFNDEF COMXJVCWARNINGLEVEL
COMXJVCWARNINGLEVEL=/w:4 /wx
!ENDIF

COMXJVCFLAGS=/nologo /C:j- /C:r $(COMXJVCWARNINGLEVEL)

!if "$(NTDEBUG)" != ""
COMXJVCFLAGS = $(COMXJVCFLAGS) /D:DBG /g /O- 
!else
COMXJVCFLAGS = $(COMXJVCFLAGS)
!endif

COMXSMCFLAGS=-smscorlib.dll -e50 -L -X

!if "$(NTDEBUG)" != ""
COMXSMCFLAGS = $(COMXSMCFLAGS) -D:DBG=1 -Zi
!else
COMXSMCFLAGS = $(COMXSMCFLAGS)
!endif

COMXCOOLFLAGS = /W:4 /warnaserror+ /assembly+

!if "$(NTDEBUG)" != ""
COMXCOOLFLAGS = $(COMXCOOLFLAGS) /define:DBG /debug+
!endif


COMXBCDIRECTIVES=
!if "$(NTDEBUG)" != ""
COMXBCDIRECTIVES=$(COMXBCDIRECTIVES) -DDBG=1
!endif

#
# MIDL Options - put output files into obj directory
#

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_FLAGS=$(MIDL_FLAGS) -tlb $(O)\$(<F:.idl=.tlb)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\application\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();
  
// 
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISMAPP";

/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iismapp");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISMAPP::DllMain::DLL_PROCESS_ATTACH\n"));
        }
        
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISMAPP::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\application\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\application\dynamiccontentmodule.cxx ===
/********************************************************************++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    DynamicContentModule.cxx

Abstract:

    This file contains implementation of IAppLayer interface.

Author:

    Lei Jin(leijin)        6-Jan-1999

Revision History:

--********************************************************************/
# include "precomp.hxx"
# include "DynamicContentModule.hxx"
# include "extension.hxx"

CExtensionCollection* CDynamicContentModule::m_pExtensionCollection = NULL;   
/********************************************************************++

Routine Description:

Arguments:

Returns:


--********************************************************************/
CDynamicContentModule::CDynamicContentModule()
:   m_pRequest(NULL),
    m_pExtensionContext(NULL),
    m_fValid(FALSE)
{    
    // TODO : Remove this check.  m_pExtensionCollection should always available    
    if (m_pExtensionCollection == NULL)
    {
        m_pExtensionCollection = CExtensionCollection::Instance();
    }
    DBG_ASSERT(m_pExtensionCollection != NULL);
    //InitializeListHead(&m_AppCollection);
}

CDynamicContentModule::~CDynamicContentModule()
{
    // m_pExtensionCollection = CExtensionCollection::Instance();
    // DBG_ASSERT(m_pExtensionCollection != NULL);
    //InitializeListHead(&m_AppCollection);
}

/********************************************************************++

Routine Description:

Arguments:

Returns:


--********************************************************************/



/********************************************************************++

Routine Description:

    The entry point of Application layer.  This function calls the proper extension
    to process the request.
    
Arguments:

Returns:


--********************************************************************/
MODULE_RETURN_CODE
CDynamicContentModule::ProcessRequest(
    IN  IWorkerRequest*   pWorkerRequest
    )
{
    MODULE_RETURN_CODE  mrc =   MRC_CONTINUE;
    HRESULT             hr  =   NOERROR;
    
    //
    // Get extension's name
    //
    if (m_pRequest != NULL && 
        m_pRequest == pWorkerRequest && 
        m_pExtension != NULL)
    {
        DWORD Status;
        hr = m_pExtension->Invoke(pWorkerRequest, this, &Status);

        mrc = (Status == HSE_STATUS_PENDING) ? MRC_PENDING : MRC_OK;
        goto LExit;
    }
    
    WCHAR   ExtensionPath[MAX_PATH];
    UINT    RequiredSize;
    hr = pWorkerRequest->GetInfoForId(
                                PROPID_ExtensionPath,
                                ExtensionPath,
                                sizeof(ExtensionPath),
                                &RequiredSize);
                                
    if (SUCCEEDED(hr))
    {
        // Find IExtension
        IExtension* pExtension = NULL;

        hr = m_pExtensionCollection->Search(
                                        ExtensionPath, 
                                        &pExtension);
        
        if (SUCCEEDED(hr) && pExtension == NULL)
        {   
            m_pExtensionCollection->Lock();

            hr = m_pExtensionCollection->Search(
                                            ExtensionPath, 
                                            &pExtension);

            if (SUCCEEDED(hr) && pExtension == NULL)
            {
                CISAPIExtension * pExtensionNew = new CISAPIExtension(ExtensionPath);
                //pExtension = (CExtension*)(pExtensionNew);
                pExtension = pExtensionNew;
                
                if (pExtension == NULL)
                {
                    DBGPRINTF((DBG_CONTEXT, "Not enough memory for Extension %S", ExtensionPath));
                    hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
                }
                else
                {
                    hr = pExtension->Load(NULL);
                    if (SUCCEEDED(hr))
                    {
                        hr = m_pExtensionCollection->Add(pExtension);
                    }
                    else
                    {
                        pExtension->Terminate();
                        delete pExtension;
                        pExtension = NULL;
                    }
                }        
            }

            m_pExtensionCollection->UnLock();
        }

        if (SUCCEEDED(hr) && pExtension != NULL)
        {
            DWORD   Status;
           // Invoke the extension to process the woker request
            m_pExtension = pExtension;
            hr = m_pExtension->Invoke(pWorkerRequest, this, &Status);                    

            mrc = (Status == HSE_STATUS_PENDING) ? MRC_PENDING : MRC_OK;
        }
        
    }

LExit:
    // Todo: MRC_PENDING
    if (FAILED(hr))
    {
        mrc = MRC_ERROR;
    }
    
    return mrc;
}

ULONG
CDynamicContentModule::Initialize(
    IWorkerRequest * pReq
    )
{
    m_nRefs                 = 0;
    m_pExtensionContext     = NULL;
    m_pRequest              = NULL;
    m_pExtension            = NULL; 
    m_fValid                = FALSE;
    
    memset((PVOID)&m_AsyncIOContext,  0, sizeof(IOContext));
    return 0; // TODO: NOERROR in HRESULT, the interface will use HRESULT later.
}

ULONG
CDynamicContentModule::Cleanup
    (
    IWorkerRequest * pReq
    )
{
    /*
    LONG                    m_nRefs;

    PVOID                   m_pExtensionContext;  // like ECB for ISAPI.
    IWorkerRequest*         m_pRequest;           // IWorkerRequest pointer. 
    IExtension*             m_pExtension;         // Extension
    IOContext               m_AsyncIOContext;     // Currently it is AsyncIO context
                                                  // only
    bool                    m_fValid;             // valid flag
    */
    // delete the ECB
    if (m_pExtensionContext)
    {
        delete [] (unsigned char*)m_pExtensionContext; 
        m_pExtensionContext = NULL;
    }

    m_pRequest      = NULL;
    m_pExtension    = NULL;
    
    m_fValid        = FALSE;
    memset((PVOID)&m_AsyncIOContext,  0, sizeof(IOContext));
    return 0; // see the comment in Initialize()
}
/********************************************************************++

Routine Description:
    This function shuts down all extensions in the extesion collection.
    
Arguments:
    void
    
Returns:
    HRESULT

    CONSIDER:
    If performance becomes a big factor, we can do some optimization such as

    1. Post the extension to another thread to shut them down.
    2. mutliple phase shutdown.
--********************************************************************/
HRESULT
CDynamicContentModule::ShutdownExtensions(
    void
    )
{
    IExtension* pExtension = NULL;
    
    while(m_pExtensionCollection->Count() != 0)
    {
        pExtension = NULL;
        
        m_pExtensionCollection->Lock();

        m_pExtensionCollection->Remove(&pExtension);

        m_pExtensionCollection->UnLock();

        if (pExtension != NULL)
        {
            pExtension->Terminate();
            delete pExtension;
        }        
    }

    return NOERROR;
}

/********************************************************************++

Routine Description:

    The entry point of Application layer.  This function calls the proper extension
    to process the request.
    
Arguments:

Returns:


--********************************************************************/
IWorkerRequest*
CDynamicContentModule::QueryWorkerRequest(
    void
    )
{
    return m_pRequest;
}

/********************************************************************++

Routine Description:
    Query the extension object.
    
Arguments:

Returns:


--********************************************************************/
IExtension*
CDynamicContentModule::QueryExtension(
    void
    )
{
    return m_pExtension;
}

/********************************************************************++

Routine Description:
    Query the ExtensionContext.
    
Arguments:

Returns:


--********************************************************************/
PVOID
CDynamicContentModule::QueryExtensionContext(
    void
    )
{
    return m_pExtensionContext;
}

/********************************************************************++

Routine Description:
    Query IO Context.  Returns the AsyncIOContext address.
    
Arguments:

Returns:


--********************************************************************/
IOContext*
CDynamicContentModule::QueryIOContext(
    void
    )
{
    return &m_AsyncIOContext;
}

/********************************************************************++

Routine Description:
    Bind the worker request to the module context.
    
Arguments:
    IWorkerRequest*     a pointer to worker request.
Returns:


--********************************************************************/
HRESULT
CDynamicContentModule::BindWorkerRequest(
    IWorkerRequest* pRequest
    )
{
    HRESULT hr;
    m_pRequest = pRequest;

    hr = (pRequest != NULL) ? NOERROR : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    
    return hr;
}

/********************************************************************++

Routine Description:
    Bind the extension context to this module context.  The extension context
    can be an ECB, for example.
    
Arguments:
    PVOID   the data structure pointer to the ExtensionContext.
Returns:
    HRESULT

--********************************************************************/
HRESULT
CDynamicContentModule::BindExtensionContext(
    PVOID   pContext
    )
{
    HRESULT hr;
    m_pExtensionContext = pContext;

    hr = (pContext != NULL) ? NOERROR : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    
    return hr;
}

/********************************************************************++

Routine Description:
    Bind the extension into the module context.
    
Arguments:
    IExtension*     the input extension pointer
    
Returns:
    HRESULT

--********************************************************************/
HRESULT
CDynamicContentModule::BindExtension(
    IExtension *pExtension
    )
{
    HRESULT hr;
    m_pExtension = pExtension;

    hr = (pExtension != NULL) ? NOERROR : HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\inc\ulsimapi.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       ulsimapi.h

   Abstract:
       Contains the Private headers for the Simulator implementation of UL.
       UL Simulator exposes the UL API set directly for use from the worker
       process without having to worry about the UL driver. The implementation
       will use the Winsock directly for in-process operation.

   Author:

       Murali R. Krishnan    ( MuraliK )    23-Nov-1998

   Environment:
       User Mode - IIS Worker Process
--*/

# ifndef _ULSIMAPI_HXX_
# define _ULSIMAPI_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/

# include "ulapi.h"

# ifdef UL_SIMULATOR_ENABLED

//
// handle changes in the UL interfaces in Jan 1999
//

typedef UL_HTTP_VERB          HTTP_VERB;
typedef UL_HTTP_HEADER_ID     HTTP_HEADER_ID;
typedef UL_HTTP_CONNECTION_ID HTTP_CONNECTION_ID;
typedef UL_HTTP_VERSION       HTTP_VERSION;

# define MaxHeaderID  (UlHeaderMaximum)

#ifdef __cplusplus
extern "C" {
#endif

//
// Internal constants for UL Simulator
//
# define ULSIM_MAX_BUFFER   (4096)  // 4KB


//
// Simulator specific functions
//

HRESULT
WINAPI
UlsimAssociateCompletionPort(
   IN HANDLE    DataChannel,
   IN HANDLE    hCompletionPort,
   IN ULONG_PTR CompletionKey
   );

HRESULT
WINAPI
UlsimCloseConnection( IN UL_HTTP_CONNECTION_ID ConnID);

HRESULT
WINAPI
UlsimCleanupDataChannel(
   IN HANDLE    DataChannel
   );

HRESULT
WINAPI
UlsimCleanupControlChannel(
   IN HANDLE    ControlChannel
   );

#ifdef __cplusplus
};
#endif


# endif // UL_SIMULATOR_ENABLED

# endif // _ULSIMAPI_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\connection\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\errorhandling\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\statemachine\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\application\extension.cxx ===
/********************************************************************++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    extension.cxx

Abstract:

    This file contains implementation of IExtension interface.

Author:

    Lei Jin(leijin)        6-Jan-1999

Revision History:

--********************************************************************/
# include "precomp.hxx"
# include "extension.hxx"
# include "dynamiccontentmodule.hxx"
# include "server.hxx"
# include "objbase.h"

CExtension::CExtension(
    LPCWSTR ExtensionPath
    )
:   m_Ref(0)    
{
    m_ExtensionPathCharCount = wcslen(ExtensionPath);    
    wcsncpy(m_ExtensionPath, ExtensionPath, MAX_PATH);
    
} // CISAPIExtension::CISAPIExtension

bool 
CExtension::IsMatch(
    LPCWSTR ExtensionPath,
    UINT    ExtensionPathCharCount
    )
{
    bool fIsMatch = FALSE;

    if ( ExtensionPathCharCount == m_ExtensionPathCharCount &&
         0 == wcsncmp(m_ExtensionPath, 
                ExtensionPath, 
                (m_ExtensionPathCharCount+1)*sizeof(WCHAR)
                ))
    {
        fIsMatch = TRUE;
    }

    return fIsMatch;
} // CISAPIExtension::IsMatch

CISAPIExtension::CISAPIExtension(
    LPCWSTR ExtensionPath
    )
: CExtension(ExtensionPath)
{
    m_pEntryFunction = NULL;
    m_pTerminateFunction = NULL;
} // CISAPIExtension::CISAPIExtension




HRESULT
CISAPIExtension::RefreshAcl(
    void
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
} // CISAPIIExtension::RefreshAcl

HRESULT
CISAPIExtension::Load(
    IN  HANDLE  ImpersonationHandle
    )
{
    HRESULT hr = NOERROR;

    // Call LoadLibrary

    m_DllHandle = LoadLibraryEx(m_ExtensionPath,
                    NULL,
                    LOAD_WITH_ALTERED_SEARCH_PATH
                    );

    if (m_DllHandle == NULL)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    // Check to see if the extension dll is in the correct format. win95, win98, win2000,etc.

    // Retrieve ISAPI entry points.
    PFN_GETEXTENSIONVERSION pfnGetExtVer = NULL;

    pfnGetExtVer            = (PFN_GETEXTENSIONVERSION)GetProcAddress(m_DllHandle,
                                                            "GetExtensionVersion"
                                                            );

    m_pEntryFunction        = (PFN_HTTPEXTENSIONPROC)GetProcAddress(m_DllHandle,
                                                            "HttpExtensionProc"
                                                            );

    m_pTerminateFunction    = (PFN_TERMINATEEXTENSION)GetProcAddress(m_DllHandle,
                                                            "TerminateExtension"
                                                            );

    // Invert back to original security context in order to call GetExtensionVersion. 
    //

    //RevertToSelf();
    
    if (pfnGetExtVer != NULL && 
        m_pEntryFunction != NULL && 
        m_pTerminateFunction != NULL)
    {
        HSE_VERSION_INFO    IsapiExtensionVersionInfo;
        INT                 RetValue;

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        DBG_ASSERT(SUCCEEDED(hr));
        
        RetValue = pfnGetExtVer(&IsapiExtensionVersionInfo);

        CoUninitialize();
        if (!RetValue)
        {
        DBGPRINTF((DBG_CONTEXT, 
            "ISAPIExtension: Get Extension version failed, %d\n",
            GetLastError()));
            
        hr = HRESULT_FROM_WIN32(GetLastError());
        }        
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    // Re-impersonate the user
    /*
    if (!ImpersonateLoggedOnUser(ImpersonationHandle))
    {
        // CONSIDER:: Win95 does not have this function.
        DBGPRINTF((DBG_CONTEXT, "ImpersonateLoggedOnUser failed, %d\n",
                    GetLastError()));

        // Successfully called GetExtensionVersion function, therefore, must
        // to call TerminateExtension function here to balanced the call.
        if (SUCCEEDED(hr))
        {
            if (m_pTerminateFunction)
            {
                m_pTerminateFunction(HSE_TERM_MUST_UNLOAD);
            }
            
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    */
    
    // If any error occurred.
    if (FAILED(hr) && m_DllHandle)
    {
        FreeLibrary(m_DllHandle);
        m_DllHandle             = NULL;
        m_pEntryFunction        = NULL;
        m_pTerminateFunction    = NULL;
    }

    return hr;
} // CISAPIExtension::Load

/********************************************************************++

Routine Description:
    Invoke a ISAPI extension to process a request.

Arguments:
    
Returns:
    HRESULT
         
--********************************************************************/
HRESULT
CISAPIExtension::Invoke(
    IN  IWorkerRequest          *pRequest,
    IN  CDynamicContentModule   *pModuleContext,
    OUT DWORD*                  pStatus
    )
{
    HRESULT hr = NOERROR;
    // Construct ECB out of pRequest
    CHAR    pTemp[10];
    _EXTENSION_CONTROL_BLOCK *pecb = NULL;
    UINT    RequiredSize;
    UINT    Size = 1;
    DWORD   HttpExtensionRetVal;

    IOContext* pContext =pModuleContext->QueryIOContext();

    if (pContext->fOutstandingIO &&
        pContext->pfnIOCompletion != NULL)
    {
        DWORD AsyncIODataByteCount;
        DWORD AsyncIOError;
        UINT  RequiredBufferSize;

        AsyncIODataByteCount    = pRequest->GetInfoForId(PROPID_AsyncIOCBData,
                                                      &AsyncIODataByteCount,
                                                      sizeof(DWORD),
                                                      &RequiredBufferSize
                                                      );

        AsyncIOError            = pRequest->GetInfoForId(PROPID_AsyncIOError,
                                                      &AsyncIOError,
                                                      sizeof(DWORD),
                                                      &RequiredBufferSize
                                                      ); 
                                                      
        pContext->pfnIOCompletion((EXTENSION_CONTROL_BLOCK *)pModuleContext->QueryExtensionContext(),
                                    pContext->pAsyncIOContext,
                                    AsyncIODataByteCount,
                                    AsyncIOError);

        // BUG:
        // What status returned here is unresolved.
        // Infact, it should still be PENDING such that 
        // ISAPI dll makes DONE_WITH_SESSION callback to finish the request.
        //
        *pStatus = HSE_STATUS_PENDING;
        goto LExit;
    };

    hr = pRequest->GetInfoForId(
                            PROPID_ECB,
                            pTemp,
                            Size,
                            &RequiredSize);

    if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
    {
        Size = RequiredSize;
        pecb = (_EXTENSION_CONTROL_BLOCK*) new unsigned char[Size];
        
        hr = pRequest->GetInfoForId(
                            PROPID_ECB,
                            pecb,
                            Size,
                            &RequiredSize);
    }
    
    // Bind ECB to a Request
    if (SUCCEEDED(hr))
    {
        /*hr = pRequest->BindProperty(
                             PROPID_ECB,
                             pEcb);
         */                    
        // Call HttpExtenion function
        if (SUCCEEDED(hr))
        {
            
            pModuleContext->BindWorkerRequest(pRequest);
            pecb->ConnID                 =   (HCONN)pModuleContext;
            pecb->GetServerVariable     =   GetServerVariable; 
            pecb->WriteClient           =   WriteClient;
            pecb->ReadClient            =   ReadClient;
            pecb->ServerSupportFunction =   ServerSupportFunction;
            pModuleContext->BindExtensionContext((PVOID)pecb);
            HttpExtensionRetVal = m_pEntryFunction(pecb);

            if (HttpExtensionRetVal == HSE_STATUS_SUCCESS)
            {
               // pRequest->CloseConnection();
            }

            if (HttpExtensionRetVal == HSE_STATUS_ERROR)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            *pStatus = HttpExtensionRetVal;
        }
    }        

LExit:
    
    return hr;
} // CISAPIExtension::Invoke

/*
HRESULT
CISAPIExtension::AsyncIOCallback(
    IN  CDynamicContentModule   *pModuleContext
    )
{
    HRESULT hr = NOERROR;
    IOContext pContext =pModuleContext->QueryIOContext();

    pContext->pfnIOCompletion(pContext->pAsyncIOContext);

    return hr;
}
*/
/********************************************************************++

Routine Description:
    Terminate an ISPAI extension.  This function calls ISAPI's TERMINATE function,
    and unload the isapi from the memory.

Arguments:
    
Returns:
    HRESULT
         
--********************************************************************/
HRESULT
CISAPIExtension::Terminate(
    void
    )
{
    HRESULT hr;
    DWORD   TerminateExtensionRetVal;

    TerminateExtensionRetVal = m_pTerminateFunction(HSE_TERM_MUST_UNLOAD);

    hr = HRESULT_FROM_WIN32(TerminateExtensionRetVal);

    if (m_DllHandle)
    {
        FreeLibrary(m_DllHandle);
        m_DllHandle = NULL;        
    }

    m_pEntryFunction        = NULL;
    m_pTerminateFunction    = NULL;

    return hr;
} // CISAPIExtension::Terminate

/********************************************************************++

Routine Description:
    ServerSupportFunction for ISAPI extension to call.  See ISAPI's doc
    for the usage of this function.

Arguments:
    
Returns:
    HRESULT
         
--********************************************************************/
BOOL
WINAPI
CISAPIExtension::ServerSupportFunction(
    HCONN   hConn,
    DWORD   dwRequest,
    LPVOID  lpvBuffer,
    LPDWORD lpdwSize,
    LPDWORD lpdwDataType
    )
{
    bool        fRet;
    CDynamicContentModule*  pModuleContext;
    IWorkerRequest*         pRequest;
    //
    //  Resolve the IHttpResponse object from hConn
    //
    pModuleContext = static_cast<CDynamicContentModule *>(hConn);    
    pRequest = pModuleContext->QueryWorkerRequest();

    HRESULT     hr = NOERROR;

    static CHAR HTTPStatus[] = "HTTP/1.1 ";
    static CHAR NewLine[] = "\r\n";
    
    switch (dwRequest)
    {
    
        case HSE_REQ_BASE:

        case HSE_REQ_SEND_URL_REDIRECT_RESP:
        case HSE_REQ_SEND_URL:
        {
            if (lpvBuffer == NULL)
            {
            SetLastError(ERROR_INVALID_PARAMETER);
            fRet = FALSE;
            break;
            }

            //
            // CONSIDER:  Keep_Conn.
            //
            
            //
            // Convert ANSI string to UNICODE string
            //
            
            STRAU*   pURLString = new STRAU((LPCSTR)lpvBuffer, FALSE);

            if (pURLString != NULL)
            {
                hr = pRequest->Redirect(pURLString->QueryStrW());
                delete pURLString;
                pURLString = NULL;

                fRet = SUCCEEDED(hr);
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
            }

            break;
        }
            
        
        case HSE_REQ_SEND_RESPONSE_HEADER:
        {
            // NYI
            // Backward compatibility support only.  Low priority.
            // See HSE_REQ_SEND_RESPONSE_HEADER_EX for more detail.
            //
            if (lpvBuffer == NULL && lpdwDataType == NULL)
            {
                break;
            }
            
            UL_DATA_CHUNK   Header;
            UINT    StatusLen = (PVOID)(lpvBuffer) ? strlen((LPSTR)lpvBuffer) + 1 : 0;

            //
            // This command is really a hack.
            //  lpdwDataType is actually for additional header string.
            //
            UINT    HeaderLen = (PVOID)(lpdwDataType) ? strlen((LPSTR)lpdwDataType) + 1 : 0;

            CHAR *pBuffer = NULL;

            pBuffer = new CHAR[StatusLen + HeaderLen + sizeof(HTTPStatus) + 
                        sizeof(NewLine)];
            
            if (pBuffer)
            {
                CHAR *pTemp                 = pBuffer;
                Header.DataChunkType        = UlDataChunkFromMemory;
                Header.FromMemory.pBuffer   = (PVOID)(pBuffer);
                Header.FromMemory.BufferLength = 0;
                
                if (lpvBuffer)
                {
                    memcpy(pTemp, HTTPStatus, sizeof(HTTPStatus)-1);
                    pTemp += sizeof(HTTPStatus)-1;
                    memcpy(pTemp, lpvBuffer, StatusLen-1);
                    pTemp += StatusLen-1;
                    memcpy(pTemp, NewLine, sizeof(NewLine)-1);
                    pTemp += sizeof(NewLine)-1;
                    
                    Header.FromMemory.BufferLength   = StatusLen 
                            + sizeof(HTTPStatus)+sizeof(NewLine) - 3;
                }
                memcpy(pTemp, lpdwDataType, HeaderLen);
                Header.FromMemory.BufferLength   += HeaderLen;
                
                hr = pRequest->SendHeader(  &Header,
                                            FALSE,
                                            FALSE
                                            );
                delete [] pBuffer;
            }
            else
            {
                fRet = FALSE;
                SetLastError(ERROR_OUTOFMEMORY);
            }
            break;
        }
        case HSE_REQ_DONE_WITH_SESSION:
        {
            if (lpvBuffer &&
                *((DWORD *)lpvBuffer) == HSE_STATUS_SUCCESS_AND_KEEP_CONN)
            {

            }

            // CONSIDER:
            // Race condition between mainline thread and callback thread.
            //
            // hr = pRequest->CloseConnection();
            hr = pRequest->FinishPending();
            break;
        }
        case HSE_REQ_MAP_URL_TO_PATH:
        {
            // UNDONE:
            // Wait for metabase module hook up.
            break;
        }
        case HSE_REQ_GET_SSPI_INFO:
        {
            // UNDONE
            // Wait for authentication module hook up.
            break;
        }
        case HSE_APPEND_LOG_PARAMETER:
        {
            if (lpvBuffer == NULL)
            {
            SetLastError(ERROR_INVALID_PARAMETER);
            fRet = FALSE;
            break;
            }

            //
            // CONSIDER:  Keep_Conn.
            //
            
            //
            // Convert ANSI string to UNICODE string
            //
            
            STRAU*   pURLString = new STRAU((LPCSTR)lpvBuffer, FALSE);

            if (pURLString != NULL)
            {
                hr = pRequest->AppendToLog(pURLString->QueryStrW());
                delete pURLString;
                pURLString = NULL;

                fRet = SUCCEEDED(hr);
            }
            else
            {
                SetLastError(ERROR_OUTOFMEMORY);
                fRet = FALSE;
            }

            break;
        }

        case HSE_REQ_IO_COMPLETION:
        {
            // UNDONE
            //
            break;
        }

        case HSE_REQ_TRANSMIT_FILE:
        {
            if (lpvBuffer == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                fRet    = FALSE;
                break;
            }
            IOContext* pIOContext = pModuleContext->QueryIOContext();

            pIOContext->fOutstandingIO  = TRUE;
            pIOContext->pfnIOCompletion = ((LPHSE_TF_INFO)lpvBuffer)->pfnHseIO;
            pIOContext->pAsyncIOContext = ((LPHSE_TF_INFO)lpvBuffer)->pContext;
            
            hr      = pRequest->TransmitFile((LPHSE_TF_INFO) lpvBuffer);
            fRet    = SUCCEEDED(hr);
            break;
        }
        
        case HSE_REQ_REFRESH_ISAPI_ACL:
        {
            break;
        }
        
        case HSE_REQ_IS_KEEP_CONN:
        {
            break;
        }
        
        case HSE_REQ_ASYNC_READ_CLIENT:
        {
            if (lpvBuffer == NULL || lpdwSize == NULL)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                fRet = FALSE;
                break;
            }
            //
            // CONSIDER: 
            // The **ASyncRead** interface might need to be redesigned, such that
            // it does not only takes a Extension object pointer, but also takes  
            // the AppLayerContext object pointer.
            // 
            
            break;
        }
        
        case HSE_REQ_GET_IMPERSONATION_TOKEN:
        {
            // UNDONE
            // Wait for authentication or metabase module.
            // Also, the ul.sys.
            break;
        }
        
        case HSE_REQ_MAP_URL_TO_PATH_EX:
        {
            // UNDONE
            // uridata module.
            //
            break;
        }
        
        case HSE_REQ_ABORTIVE_CLOSE:
        {
            break;
        }
        
        case HSE_REQ_GET_CERT_INFO_EX:
        {
            // UNDONE
            // authentication or metabase module.
            break;
        }
        
        case HSE_REQ_SEND_RESPONSE_HEADER_EX:
        {
            // NYI
            // Backward compatibility support only.  Low priority.
            // See HSE_REQ_SEND_RESPONSE_HEADER_EX for more detail.
            //
            UL_DATA_CHUNK   Header;
            HSE_SEND_HEADER_EX_INFO* pHeaderExInfo = (HSE_SEND_HEADER_EX_INFO*)lpvBuffer;
            
            DWORD StatusLen = 0;
            DWORD HeaderLen = 0;

            if (pHeaderExInfo->pszStatus)
            {
                StatusLen = strlen((LPSTR)pHeaderExInfo->pszStatus)+1;
            }

            if (pHeaderExInfo->pszHeader)
            {
                HeaderLen = strlen((LPSTR)pHeaderExInfo->pszHeader)+1;
            }
            CHAR* pBuffer = new CHAR[StatusLen + HeaderLen +
                                    sizeof(HTTPStatus) + sizeof(NewLine)];
            if (pBuffer)
            {
                CHAR* pTemp = pBuffer;

                Header.DataChunkType = UlDataChunkFromMemory;
                Header.FromMemory.pBuffer        = (PVOID)pBuffer;
                Header.FromMemory.BufferLength   = 0;

                
                if (pHeaderExInfo->pszStatus != NULL)
                {   
                    memcpy(pTemp, HTTPStatus, sizeof(HTTPStatus)-1);
                    pTemp += sizeof(HTTPStatus)-1;
                    memcpy(pTemp, pHeaderExInfo->pszStatus, StatusLen-1);
                    pTemp += StatusLen-1;
                    
                    memcpy(pTemp, NewLine, sizeof(NewLine)-1);
                    pTemp += sizeof(NewLine)-1;

                    Header.FromMemory.BufferLength += StatusLen  + 
                                    sizeof(NewLine) + sizeof(HTTPStatus) - 3;
                }
                memcpy(pTemp, pHeaderExInfo->pszHeader, HeaderLen-1);
                Header.FromMemory.BufferLength += HeaderLen-1;

                hr = pRequest->SendHeader(  &Header,
                                            FALSE,
                                            FALSE
                                            ); 
                delete [] pBuffer;
            }                                       
            break;
        }
        
        case HSE_REQ_CLOSE_CONNECTION:
        {
            fRet = pRequest->CloseConnection();            
            break;
        }
    }
    return TRUE;
}


BOOL
WINAPI
CISAPIExtension::WriteClient(
    HCONN   hConn,
    LPVOID  Buffer,
    LPDWORD lpdwSize,
    DWORD   dwReserved
    )
{
    bool                    fRet        = TRUE;
    HRESULT                 hr          = NOERROR;
    IWorkerRequest*         pRequest    = NULL;  
    CDynamicContentModule*  pModuleContext;

    //
    //  Resolve the IHttpResponse object from hConn
    //
    pModuleContext = static_cast<CDynamicContentModule *>(hConn);
    
    pRequest = pModuleContext->QueryWorkerRequest();

    if (dwReserved != HSE_IO_ASYNC)
    {
    //
    //  SyncWrite
    //
    UL_DATA_CHUNK  DataChunk;

    DataChunk.DataChunkType            = UlDataChunkFromMemory;
    DataChunk.FromMemory.pBuffer       = Buffer;
    DataChunk.FromMemory.BufferLength  = *lpdwSize;
    
    hr = pRequest->SyncWrite(&DataChunk,
                               lpdwSize);

    // Check the return value
    // SetLastError if hr result is an error.
    //

    fRet = SUCCEEDED(hr);
    
    }
    else
    {
    // AsyncIO
    // NYI
    }
    
    return fRet;
}

/********************************************************************++

Routine Description:
    Read data from http client synchronously.
    
Arguments:
    None
    
Returns:
    HRESULT

--********************************************************************/

BOOL
WINAPI
CISAPIExtension::ReadClient(
    IN  HCONN   hConn,
    IN  LPVOID  pBuffer,
    IN  LPDWORD pdwSize
    )
{
    HRESULT hr          = NOERROR;
    BOOL    fReturn     = TRUE;
    // CONSIDER:
    // 1. Chunk data read.  It has chunk data header and footer.
    // 2. Filter. (ReadData, this is handled in IWorkerRequest interface or lower.
    //
    CDynamicContentModule *pContext = (CDynamicContentModule *)hConn;

    if (pContext == NULL ||
        pBuffer == NULL ||
        pdwSize == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);        
        return FALSE;
    }

    IWorkerRequest *pRequest = pContext->QueryWorkerRequest();

    DBG_ASSERT(pRequest != NULL);

    hr = pRequest->SyncRead(pBuffer,
                           *pdwSize,
                           (UINT*)pdwSize);
                        
    if (FAILED(hr))
    {
        SetLastError(WIN32_FROM_HRESULT(hr));
        fReturn = FALSE;
    }
    
    return fReturn;
}

/********************************************************************++

Routine Description:
    GetServerVariable for ISAPI Extension.  This function is passed to ISAPI.dll
    and later called by ISAPI.dll to query server info.
    
Arguments:
    None
    
Returns:
    HRESULT

--********************************************************************/
BOOL
WINAPI
CISAPIExtension::GetServerVariable(
    IN  HCONN   hConn,
    IN  LPSTR   lpszVariableName,
    IN  LPVOID  lpvBuffer, 
    IN  LPDWORD lpdwSize
    )
{   
    BOOL    fReturn = TRUE;

    CDynamicContentModule*    pContext = (CDynamicContentModule*)hConn;

    if (pContext == NULL ||
        lpszVariableName == NULL )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    IWorkerRequest *pRequest = pContext->QueryWorkerRequest();

    DBG_ASSERT(pRequest != NULL);

    STRAU       strName(lpszVariableName, FALSE);
    UINT        PropertyId;

    CHttpServer*    pServer = CHttpServer::Instance();
    HRESULT     hr;
    // TODO:
    // I see this call is not efficient since if the GetServerVariable
    // passes a small buffer to cause ERROR_INSUFFICIENT_BUFFER, GetIdForName
    // will get called at least twice.
    // Option 1: tree-lize the mapping.
    // Option 2: localize the mapping.
    // Option 3: Have a new function called GetInfoForName.
    //
    hr = pServer->GetIdForName(strName.QueryStrW(),
                          &PropertyId);
    
    UINT   RequiredBufferSize;
    hr = pRequest->GetInfoForId(PropertyId,
                            lpvBuffer,
                            *lpdwSize,
                            &RequiredBufferSize
                            );

    *lpdwSize = RequiredBufferSize;
    if (FAILED(hr))
    {           
        SetLastError(WIN32_FROM_HRESULT(hr));
        fReturn = FALSE;
    }    
    
    return fReturn; 
}

/********************************************************************++
class CExtensionCollection

    Singleton class.  This class maps to a collection of extension object.  It 
    supports extension lookup, add, remove, etc.
    
    This class is part of IAppLayer class.

--********************************************************************/

// static private instance.
CExtensionCollection* CExtensionCollection::m_Instance = NULL;

/********************************************************************++

Routine Description:
    This function is the contructor of CExtensionCollection.

Arguments:
    None
    
Returns:
    HRESULT

--********************************************************************/
CExtensionCollection::CExtensionCollection(
    void
    )
:   m_ExtensionCount(0)
{
    InitializeListHead(&m_ExtensionList);
    InitializeCriticalSectionAndSpinCount(
        &m_Lock,
        EXTENSION_CS_SPINS
        );
        
}

/********************************************************************++

Routine Description:
    Singleton class instance method.
    
Arguments:
    None
    
Returns:
    HRESULT

--********************************************************************/
CExtensionCollection*    
CExtensionCollection::Instance(
    void
    )
{
    if (m_Instance == NULL)
    {
        m_Instance = new CExtensionCollection; 
    }

    return m_Instance;
}

/********************************************************************++
CExtensionCollection::Add

Routine Description:
    This function adds a extension object to the collection.

    
Arguments:
    pExtension             It holds a pointer to the extension object.
    
Returns:
    HRESULT

--********************************************************************/
HRESULT
CExtensionCollection::Add(
    IN  IExtension*    pExtension
    )
{
    HRESULT hr = NOERROR;

    DBG_ASSERT(pExtension != NULL);
    
    Lock();

    InsertHeadList(&m_ExtensionList, pExtension->GetListEntry());
    m_ExtensionCount++;

    UnLock();

    return hr;
}

/********************************************************************++
CExtensionCollection::Remove

Routine Description:
    This function removes a extension object to the collection.

    
Arguments:
    ppExtension             It holds a pointer to the extension object on return.
    
Returns:
    HRESULT

--********************************************************************/
HRESULT
CExtensionCollection::Next(
    IN  IExtension*     pExtensionCurrent,
    OUT IExtension**    ppExtensionNext
    )
{
    HRESULT     hr              = NOERROR;
    PLIST_ENTRY pListEntry      = NULL;
    IExtension* pExtensionNext  = NULL;
    
    DBG_ASSERT(ppExtensionNext != NULL && pExtensionCurrent != NULL);

    pListEntry = (pExtensionCurrent->GetListEntry())->Flink; 
   
    if (pListEntry != &m_ExtensionList)
    {
        pExtensionNext = CONTAINING_RECORD(
                        pListEntry,
                        CExtension,
                        m_Link);
    }

    *ppExtensionNext = pExtensionNext;
    
    return hr;
}

/********************************************************************++
CExtensionCollection::Remove

Routine Description:
    This function removes a extension object to the collection.

    
Arguments:
    ppExtension             It holds a pointer to the extension object on return.
    
Returns:
    HRESULT

--********************************************************************/
HRESULT
CExtensionCollection::Remove(
    OUT  IExtension**    ppExtension
    )
{
    HRESULT     hr          = NOERROR;
    PLIST_ENTRY pListEntry  = NULL;
    IExtension* pExtension  = NULL;
    
    DBG_ASSERT(ppExtension != NULL);

    Lock();

    if (!IsListEmpty(&m_ExtensionList))
    {
        pListEntry = RemoveHeadList(&m_ExtensionList);
        m_ExtensionCount--;
    }
    
    UnLock();

    if (pListEntry)
    {
        pExtension = CONTAINING_RECORD(
                        pListEntry,
                        CExtension,
                        m_Link);
    }

    *ppExtension = pExtension;
    
    return hr;
}

/********************************************************************++
CExtensionCollection::Search

Routine Description:
    This function finds the extension object from it's cache collection.  If
    the extension object is not found, then, a new extension object will be
    constructed.

    
Arguments:
    ExtensionPath           The extension physical path.
    ppExtension             It holds a pointer to the extension object on return.

    NYI:
    A flag indicates whether this extension needs to go to the cache collection.

Returns:
    HRESULT

--********************************************************************/
HRESULT
CExtensionCollection::Search(
    IN  LPCWSTR         ExtensionPath,
    OUT IExtension**    ppExtension
    )
{
    // Parameter validation
    if (ExtensionPath == NULL || ppExtension == NULL)
        {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        }

    HRESULT         hr = NOERROR;
    UINT            ExtensionPathCharCount;
    PLIST_ENTRY     pNode;
    bool            fFound      = FALSE;
    CExtension*     pExtension  = NULL;;  

    ExtensionPathCharCount = wcslen(ExtensionPath);

    Lock();

    pNode = m_ExtensionList.Flink;
    for (UINT i = 0; i < m_ExtensionCount; i++)
    {
        pExtension = CONTAINING_RECORD(
                        pNode,
                        CExtension,
                        m_Link);
        
        if (pExtension->IsMatch(
                            ExtensionPath,
                            ExtensionPathCharCount))
        {
        // NYI AddRef pExtension
        fFound = TRUE;
        break;
        }
    }
    
    UnLock();

    *ppExtension = (fFound) ? pExtension : NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\application\server.cxx ===
/********************************************************************++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    iserver.cxx

Abstract:

    This file contains implementation of iserver interface.

Author:

    Lei Jin(leijin)        6-Jan-1999

Revision History:

--********************************************************************/
# include "precomp.hxx"
# include "server.hxx"

/********************************************************************++

Routine Description:

    The static function Instance() uses lazy initialization for static 
    member CHttpServer::m_instance.  This operation guarantees that only a
    singleton CHttpServer object ever created.

Arguments:

    None.

Return Value:

    CHttpServer*    a pointer to CHttpServer object.  NULL if failed.

--********************************************************************/

CHttpServer * CHttpServer::m_instance = NULL;

CHttpServer*
CHttpServer::Instance(
    void
    )
{
    if (m_instance == NULL)
    {
        m_instance = new CHttpServer;
    }

    DBG_ASSERT(m_instance != NULL);
    
    return m_instance;
} // CHttpServer::Instance

#define BIND_ID_WITH_STRING(id, string)     string

PropertyIdMapping IdMap[]={
    {PROPID_ECB,                L"ECB"},
    {PROPID_KeepConn,           L"KeepConn"},
    {PROPID_ImpersonationToken, L"ImpersonationToken"},
    {PROPID_CertficateInfo,     L"CertficateInfo"},
    {PROPID_VirtualPathInfo,    L"VirtualPath"},
    {PROPID_ExecuteFlags,       L"ExecuteFlags"},
    {PROPID_AppPhysicalPath,    L"AppPhysicalPath"},
    {PROPID_AppVirtualPath,     L"AppVirtualPath"},
    {PROPID_ExtensionPath,      L"ExtensionPath"},
    {PROPID_AsyncIOCBData,      L""},
    {PROPID_AsyncIOError,       L""},
    {PROPID_PhysicalPath,       L""},
    {PROPID_PhysicalPathLen,    L""},
    {PROPID_VirtualPath,         L""},
    {PROPID_VirtualPathLen,      L""},
    {PROPID_URL,                 L"URL"},
    {PROPID_MAX,                 L""}
    };
    
/********************************************************************++

Routine Description:

    The static function Instance() uses lazy initialization for static 
    member CHttpServer::m_instance.  This operation guarantees that only a
    singleton CHttpServer object ever created.

Arguments:

    None.

Return Value:

    CHttpServer*    a pointer to CHttpServer object.  NULL if failed.

--********************************************************************/

HRESULT
CHttpServer::GetIdForName(
    IN  LPCWSTR     PropertyName,
    OUT UINT*       pPropertyId
    )
{
    HRESULT hr = NOERROR;

    *pPropertyId = 0;
    
    for (UINT i = 0; i < sizeof(IdMap)/sizeof(PropertyIdMapping); i++)
    {
        if (0 == wcsncmp(
                    IdMap[i].m_PropertyName,
                    PropertyName,
                    wcslen(PropertyName)+sizeof(WCHAR)))
        {
            *pPropertyId = IdMap[i].m_PropertyId;
            break;
        }
    }
    
    return hr;
} // CHttpServer::GetIdForName

HRESULT
CHttpServer::ProcessChildRequest(
    IN  LPCWSTR     URI,
    IN  UINT        ExecutionFlags
    )
{
    HRESULT hr = NOERROR;

    //  This function requires UL_DATA_CHUNK structure to provide
    //  some way to pass the security token of the request.
    //
    //  It is an easy and clean design to have the worker process to 
    //  passing the child request's URL via UL_DATA_CHUNK back to UL.SYS.
    //  This requires that the same methods also passed the security token
    //  such that the when the UL.SYS forwards to another process, it uses
    //  this orignal request's security context.
    //
    //
    //  NYI
    //
    return hr;

} // CHttpServer::ProcessChildRequest
        

HRESULT
CHttpServer::MapURLToPath(
    IN  LPCWSTR     URLPath,
    IN  LPWSTR      PhysicalPath,
    IN  UINT        PhysicalPathSize,
    OUT UINT*    RequiredPhysicalPathSize
    )
{
    HRESULT hr = NOERROR;

    //
    // Require the URICache.
    // Example:
    //
    //  /vroot/AppPath/dir1
    //
    //  ==>URICache::Lookup(/vroot/AppPath/dir1)
    // returns /vroot/AppPath  ==> c:\temp
    // Then, the MapURLtoPath needs to resolve to c:\temp\dir1
    //

    // NYI

    return hr;
} // CHttpServer::MapURLToPath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\connection\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();
                                                                               
//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISMCONN";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iismconn");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        // LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISMCONN::DllMain::DLL_PROCESS_ATTACH\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISMCONN::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\errorhandling\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();
                                                                               
//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISMERR";

HINSTANCE g_hInstance = NULL;

/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iismerr");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        // LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISMERR::DllMain::DLL_PROCESS_ATTACH\n"));
        }

        g_hInstance = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISMERR::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\connection\connectionmodule.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     ConnectionModule.cxx

   Abstract:
     This module implements the IIS Connection Module
 
   Author:

       Saurab Nog    ( SaurabN )     29-Jan-1999

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

#include "precomp.hxx"
#include "ConnectionModule.hxx"

 
CConnectionHashTable  * m_pConnectionHT              = NULL;

TS_RESOURCE           * CConnectionModule::m_pHTLock = NULL;
bool                    CConnectionModule::m_fInitialized = false;


//
// iModule methods
//

ULONG 
CConnectionModule::Initialize(
    IWorkerRequest * pReq
    )
{
    if (! m_fInitialized)
    {
        m_pHTLock       = new TS_RESOURCE();
        m_pConnectionHT = new CConnectionHashTable();

        m_fInitialized = true;

        if  ((!m_pHTLock) || (!m_pConnectionHT))
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    return NO_ERROR;
}
    
ULONG 
CConnectionModule::Cleanup(
    IWorkerRequest * pReq
    )
{
    LONG nRef = m_pConn->Release();

    if ((0 == nRef) && ( ! m_pConn->IsConnected()))
    {
        m_pHTLock->Lock( TSRES_LOCK_WRITE);
        
        m_pConnectionHT->DeleteRecord(m_pConn);

        m_pHTLock->Unlock();
        
        delete m_pConn;
        m_pConn = NULL;
    }

    return NO_ERROR;
}
    
MODULE_RETURN_CODE 
CConnectionModule::ProcessRequest(
    IWorkerRequest * pReq
    )
{
    PCONNECTION_RECORD      pConn;
    LK_RETCODE              lkrc;
    UL_HTTP_CONNECTION_ID   connId = pReq->QueryConnectionId();
    
    if ( UL_IS_NULL_ID( &connId))
    {
        return MRC_ERROR;
    }
    
    m_pHTLock->Lock( TSRES_LOCK_READ);

    lkrc = m_pConnectionHT->FindKey(&connId, &pConn);

    if ( (LK_SUCCESS != lkrc) && (LK_NO_SUCH_KEY != lkrc))
    {
        m_pHTLock->Unlock();
        return MRC_ERROR;
    }
    
    if ( LK_NO_SUCH_KEY == lkrc)
    {
        pConn = new CONNECTION_RECORD(connId);

        if (!pConn)
        {
            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Memory allocation failed for CONNECTION_RECORD.\n" ));
            }
            
            m_pHTLock->Unlock();
            return MRC_ERROR;
        }

        m_pHTLock->Convert(TSRES_CONV_WRITE);
        
        lkrc = m_pConnectionHT->InsertRecord( pConn);
        
        if (LK_SUCCESS != lkrc)
        {
            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "HT Insert failed for CONNECTION_RECORD. Returned :%d\n",
                            lkrc));
            }

            m_pHTLock->Unlock();
        
            delete pConn;
            return MRC_ERROR;
        }
    }

    m_pHTLock->Unlock();

    pConn->AddRef();
    m_pConn = pConn;
    
    return MRC_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\errorhandling\errorhandlingmodule.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     ErrorHandlingModule.cxx

   Abstract:
     This module implements the IIS Error Handling Module
 
   Author:

       Saurab Nog    ( SaurabN )     29-Jan-1999

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

#include "precomp.hxx"
#include "buffer.hxx"
#include "StatusCodes.hxx"
#include "ErrorHandlingModule.hxx"

 /********************************************************************++
--********************************************************************/

#define PSZ_SERVER_NAME_STRING   "Server: IIS-WorkerProcess v1.0\r\n"

extern  HINSTANCE  g_hInstance;

bool    CErrorHandlingModule::m_fInitialized = false;

struct  ERROR_RESPONSE
{
    ULONG   HttpErrorCode;
    ULONG   ErrorStringId;
    CHAR    ErrorString[MAX_PATH];
}
g_ErrorResponseTable[] = 
{
    {HT_BAD_REQUEST             ,IDS_HTRESP_BAD_REQUEST             ,NULL},
    {HT_DENIED                  ,IDS_HTRESP_DENIED                  ,NULL},
    {HT_PAYMENT_REQ             ,IDS_HTRESP_PAYMENT_REQ             ,NULL},
    {HT_FORBIDDEN               ,IDS_HTRESP_FORBIDDEN               ,NULL},
    {HT_NOT_FOUND               ,IDS_HTRESP_NOT_FOUND               ,NULL},
    {HT_METHOD_NOT_ALLOWED      ,IDS_HTRESP_METHOD_NOT_ALLOWED      ,NULL},
    {HT_NONE_ACCEPTABLE         ,IDS_HTRESP_NONE_ACCEPTABLE         ,NULL},
    {HT_PROXY_AUTH_REQ          ,IDS_HTRESP_PROXY_AUTH_REQ          ,NULL},
    {HT_REQUEST_TIMEOUT         ,IDS_HTRESP_REQUEST_TIMEOUT         ,NULL},
    {HT_CONFLICT                ,IDS_HTRESP_CONFLICT                ,NULL},
    {HT_GONE                    ,IDS_HTRESP_GONE                    ,NULL},
    {HT_LENGTH_REQUIRED         ,IDS_HTRESP_LENGTH_REQUIRED         ,NULL},
    {HT_PRECOND_FAILED          ,IDS_HTRESP_PRECOND_FAILED          ,NULL},
    {HT_URL_TOO_LONG            ,IDS_HTRESP_URL_TOO_LONG            ,NULL},
    {HT_RANGE_NOT_SATISFIABLE   ,IDS_HTRESP_RANGE_NOT_SATISFIABLE   ,NULL},
    
    {HT_SERVER_ERROR            ,IDS_HTRESP_SERVER_ERROR            ,NULL},
    {HT_NOT_SUPPORTED           ,IDS_HTRESP_NOT_SUPPORTED           ,NULL},
    {HT_BAD_GATEWAY             ,IDS_HTRESP_BAD_GATEWAY             ,NULL},
    {HT_SVC_UNAVAILABLE         ,IDS_HTRESP_SERVICE_UNAVAIL         ,NULL},
    {HT_GATEWAY_TIMEOUT         ,IDS_HTRESP_GATEWAY_TIMEOUT         ,NULL},
};

int g_cResponseTableEntries = 
                        sizeof(g_ErrorResponseTable)/sizeof(ERROR_RESPONSE);

 /********************************************************************++
--********************************************************************/

//
// iModule methods
//

ULONG
CErrorHandlingModule::Initialize(
    IWorkerRequest * pReq
)
{
    if (!m_fInitialized)
    {
        m_fInitialized = true;

        //
        // Load all error strings into memory
        //

        for(int i=0; i < g_cResponseTableEntries; i++)
        {
           LoadStringA( g_hInstance, 
                        g_ErrorResponseTable[i].ErrorStringId,
                        g_ErrorResponseTable[i].ErrorString,
                        sizeof(g_ErrorResponseTable[i].ErrorString)
                       );
        }
    }

    return NO_ERROR;
}

 /********************************************************************++
--********************************************************************/

MODULE_RETURN_CODE 
CErrorHandlingModule::ProcessRequest(
    IWorkerRequest * pReq
    )
{
    int                 index = 0;
    BUFFER *            pulResponseBuffer = QueryResponseBuffer();
    BUFFER *            pDataBuffer       = QueryDataBuffer();
    ULONG               HttpError, Win32Error;
    ULONG               cbRequiredSize ;
    
    PUL_HTTP_RESPONSE_v1   pHttpResponse;
    PUL_DATA_CHUNK      pDataChunk;

    //
    // Handle callback
    //

    if (true == m_fInUse)
    {
        m_fInUse = false;
        return MRC_OK;
    }
    
    //
    // Resize response buffer
    //
    
    cbRequiredSize = sizeof(UL_HTTP_RESPONSE_v1) + 1 * sizeof(UL_DATA_CHUNK);
    
    if ( pulResponseBuffer->QuerySize() < cbRequiredSize)
    {
        if ( !pulResponseBuffer->Resize(cbRequiredSize))
        {
            return MRC_ERROR;
        }
    }

    //
    // Retrieve error information
    //
    
    pReq->QueryLogStatus(&HttpError, &Win32Error);

    if ( (HT_OK == HttpError) && ( 0 != Win32Error) )
    {
        HttpError = HT_SERVER_ERROR;
    }
    
    //
    // Search for Http error code in the table
    //
    
    for (index =0; index < g_cResponseTableEntries; index++)
    {
        if (g_ErrorResponseTable[index].HttpErrorCode == HttpError)
        {
            break;
        }
    }

    //
    // Find required Data buffer size
    //

    cbRequiredSize = sizeof("HTTP/1.1 XXX\r\n") + sizeof(PSZ_SERVER_NAME_STRING);

    if ( index <  g_cResponseTableEntries)
    {
        //
        // Error String found
        //

        cbRequiredSize += strlen( g_ErrorResponseTable[index].ErrorString) + 1;
    }

    //
    // Check data buffer size
    //

    if ( pDataBuffer->QuerySize() < cbRequiredSize)
    {
        if ( !pDataBuffer->Resize(cbRequiredSize))
        {
            return MRC_ERROR;
        }
    }

    //
    // Setup the ul chunks
    //

    pHttpResponse = (PUL_HTTP_RESPONSE_v1) pulResponseBuffer->QueryPtr();

    pHttpResponse->Flags = UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH;
    pHttpResponse->HeaderChunkCount     = 1;
    pHttpResponse->EntityBodyChunkCount = 0;

    //
    // Build Response String
    //

    if ( index <  g_cResponseTableEntries)
    {
        //
        // Error String found
        //

        cbRequiredSize = wsprintfA((LPSTR) pDataBuffer->QueryPtr(),
                                   "%s %u %s\r\n%s",
                                   "HTTP/1.1", 
                                   HttpError,  
                                   g_ErrorResponseTable[index].ErrorString,
                                   PSZ_SERVER_NAME_STRING
                                  );    
    }
    else
    {
        cbRequiredSize = wsprintfA((LPSTR) pDataBuffer->QueryPtr(),
                                   "%s %u\r\n%s",
                                   "HTTP/1.1", HttpError,
                                   PSZ_SERVER_NAME_STRING
                                  );
    }

    //
    // Fill in the response line data chunk
    //

    pDataChunk    = (PUL_DATA_CHUNK)    (pHttpResponse+1);

    pDataChunk->DataChunkType           = UlDataChunkFromMemory;
    pDataChunk->FromMemory.pBuffer      = pDataBuffer->QueryPtr();
    pDataChunk->FromMemory.BufferLength = cbRequiredSize;

    // 
    // Send out response to client
    //
    
    m_fInUse = true;
    
    if (  NO_ERROR != pReq->SendAsyncResponse( pHttpResponse ))
    {
        m_fInUse = false;
        return MRC_ERROR;
    }

    return MRC_PENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\errorhandling\resource.h ===
//
//  HTTP server response string IDs
//
//

#define ID_HTTP_ERROR_BASE          (1000)

#define IDS_HTRESP_OK                   (ID_HTTP_ERROR_BASE+200)
#define IDS_HTRESP_CREATED              (ID_HTTP_ERROR_BASE+201)
#define IDS_HTRESP_ACCEPTED             (ID_HTTP_ERROR_BASE+202)
#define IDS_HTRESP_PARTIAL              (ID_HTTP_ERROR_BASE+203)
#define IDS_HTRESP_NO_CONTENT           (ID_HTTP_ERROR_BASE+204)

#define IDS_HTRESP_MULTIPLE_CHOICE      (ID_HTTP_ERROR_BASE+300)
#define IDS_HTRESP_MOVED                (ID_HTTP_ERROR_BASE+301)
#define IDS_HTRESP_REDIRECT             (ID_HTTP_ERROR_BASE+302)
#define IDS_HTRESP_REDIRECT_METHOD      (ID_HTTP_ERROR_BASE+303)
#define IDS_HTRESP_NOT_MODIFIED         (ID_HTTP_ERROR_BASE+304)

#define IDS_HTRESP_BAD_REQUEST          (ID_HTTP_ERROR_BASE+400)
#define IDS_HTRESP_DENIED               (ID_HTTP_ERROR_BASE+401)
#define IDS_HTRESP_PAYMENT_REQ          (ID_HTTP_ERROR_BASE+402)
#define IDS_HTRESP_FORBIDDEN            (ID_HTTP_ERROR_BASE+403)
#define IDS_HTRESP_NOT_FOUND            (ID_HTTP_ERROR_BASE+404)
#define IDS_HTRESP_METHOD_NOT_ALLOWED   (ID_HTTP_ERROR_BASE+405)
#define IDS_HTRESP_NONE_ACCEPTABLE      (ID_HTTP_ERROR_BASE+406)
#define IDS_HTRESP_PROXY_AUTH_REQ       (ID_HTTP_ERROR_BASE+407)
#define IDS_HTRESP_REQUEST_TIMEOUT      (ID_HTTP_ERROR_BASE+408)
#define IDS_HTRESP_CONFLICT             (ID_HTTP_ERROR_BASE+409)
#define IDS_HTRESP_GONE                 (ID_HTTP_ERROR_BASE+410)
#define IDS_HTRESP_LENGTH_REQUIRED      (ID_HTTP_ERROR_BASE+411)
#define IDS_HTRESP_PRECOND_FAILED       (ID_HTTP_ERROR_BASE+412)
#define IDS_HTRESP_URL_TOO_LONG         (ID_HTTP_ERROR_BASE+414)
#define IDS_HTRESP_RANGE_NOT_SATISFIABLE (ID_HTTP_ERROR_BASE+416)

#define IDS_HTRESP_SERVER_ERROR         (ID_HTTP_ERROR_BASE+500)
#define IDS_HTRESP_NOT_SUPPORTED        (ID_HTTP_ERROR_BASE+501)
#define IDS_HTRESP_BAD_GATEWAY          (ID_HTTP_ERROR_BASE+502)
#define IDS_HTRESP_SERVICE_UNAVAIL      (ID_HTTP_ERROR_BASE+503)
#define IDS_HTRESP_GATEWAY_TIMEOUT      (ID_HTTP_ERROR_BASE+504)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000
# define    DEBUG_PARSING              0x40000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\statemachine\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISSTATE";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iisstate");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        // LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISSTATE::DllMain::DLL_PROCESS_ATTACH\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISSTATE::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\statemachine\statemachinemodule.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     StateMachineModule.cxx

   Abstract:
     This module implements the IIS State Machine Module
 
   Author:

       Saurab Nog    ( SaurabN )     29-Jan-1999

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

//
// This is the state machine transition table. The rows are present
// processing states. The columns are return codes from the module.
//

#include "precomp.hxx"

//
// The WREQ_STATE_CHANGE_LIST gives the list of state transition mappings
// It conists of a list of state-transitions encoded using the macros:
//
//  WS_CHANGE( currentState, String, nextState}
// This list is just for documnetation aid only for now.
//

/*
# define WREQ_STATE_CHANGE_LIST()              \
  WS_CHANGE(WRS_FREE,              Success,    WRS_READ_REQUEST)         \
  WS_CHANGE(WRS_FREE,              Error,      WRS_UNDEFINED)            \
  WS_CHANGE(WRS_READ_REQUEST,      Success,    WRS_PROCESSING_REQUEST)   \
  WS_CHANGE(WRS_READ_REQUEST,      MoreHeaders,WRS_READ_REQUEST)         \
  WS_CHANGE(WRS_READ_REQUEST,      Error,      WRS_ERROR)                \
  WS_CHANGE(WRS_PROCESSING_REQUEST,Success,    WRS_SEND_RESPONSE)        \
  WS_CHANGE(WRS_PROCESSING_REQUEST,Error,      WRS_ERROR)                \
  WS_CHANGE(WRS_PROCESSING_REQUEST,ReadEntity, WRS_READ_ENTITY_BODY)     \
  WS_CHANGE(WRS_SEND_RESPONSE,     Success,    WRS_FREE)                 \
  WS_CHANGE(WRS_SEND_RESPONSE,     Error,      WRS_ERROR)                \
  WS_CHANGE(WRS_READ_ENTITY_BODY,  Success,    WRS_PROCESSING_REQUEST)   \
  WS_CHANGE(WRS_READ_ENTITY_BODY,  Error,      WRS_ERROR)                \
  WS_CHANGE(WRS_ERROR,             Success,    WRS_FREE)                 \
  WS_CHANGE(WRS_ERROR,             Error,      WRS_FREE)                 \
*/


WREQ_STATE g_StateTransitionTable[][MRC_MAXIMUM] = {
// -------------------------------------------------------------------------------------------------------------------
//                              MRC_ERROR  MRC_OK                       MRC_PENDING    MRC_CONTINUE   MRC_REQUEST_DONE
//--------------------------------------------------------------------------------------------------------------------
/*WRS_FREE                  */ { WRS_FREE,  WRS_READ_REQUEST,           WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_READ_REQUEST          */ { WRS_ERROR, WRS_FETCH_CONNECTION_DATA,  WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_FETCH_CONNECTION_DATA */ { WRS_ERROR, WRS_FETCH_URI_DATA,         WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_FETCH_URI_DATA        */ { WRS_ERROR, WRS_SECURITY,               WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_SECURITY              */ { WRS_ERROR, WRS_UNDEFINED,              WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_PROCESSING_STATIC     */ { WRS_ERROR, WRS_FREE,                   WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_PROCESSING_DYNAMIC    */ { WRS_ERROR, WRS_FREE,                   WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
/*WRS_ERROR                 */ { WRS_FREE,  WRS_FREE,                   WRS_UNDEFINED, WRS_UNDEFINED, WRS_UNDEFINED },
};

CStateMachineModule::CStateMachineModule()
    : m_nRefs   ( 0)
{
}

/********************************************************************++
--********************************************************************/

CStateMachineModule::~CStateMachineModule()
{
}

/********************************************************************++
--********************************************************************/

ULONG
CStateMachineModule::Initialize(IWorkerRequest * pReq)
{
    return NO_ERROR;
}

/********************************************************************++
--********************************************************************/

ULONG 
CStateMachineModule::Cleanup(IWorkerRequest * pReq)
{
    return NO_ERROR;
}

/********************************************************************++
--********************************************************************/

MODULE_RETURN_CODE 
CStateMachineModule::ProcessRequest(IWorkerRequest * pReq)
{
    WREQ_STATE         nextState    = WRS_UNDEFINED;
    WREQ_STATE         presentState = pReq->QueryState();
    MODULE_RETURN_CODE mrc          = pReq->QueryProcessingCode();

    nextState = g_StateTransitionTable[presentState][mrc];

    if (WRS_UNDEFINED != nextState )
    {
        pReq->SetState(nextState);
        
        mrc = MRC_OK;
    }
    else
    {
        if ( (WRS_SECURITY == presentState) && (MRC_OK == mrc ))
        {
            PURI_DATA  pUriData= (PURI_DATA) pReq->QueryModule(WRS_FETCH_URI_DATA);

            nextState = pUriData->IsDynamicRequest() ?  WRS_PROCESSING_DYNAMIC :
                                                        WRS_PROCESSING_STATIC;
            pReq->SetState(nextState);
            
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Invalid Target State for State Table Translation\n" ));
                        
            DBG_ASSERT(FALSE);
            
            mrc = MRC_ERROR;
        }
    }

    return mrc;
}
    
/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\dirlist.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     DirList.cxx

   Abstract:
     This code produces HTML directory listings
 
   Author:

       Saurab Nog    ( SaurabN )     22-Feb-1999

   FILE HISTORY:
        Johnl       09-Sep-1994     Created
        MuraliK     06-Dec-1995     Added support to use WIN32_FIND_DATA
        SaurabN     22-Feb-1999     Ported to IIS Rearchitecture project

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

#include "precomp.hxx"
#include <buffer.hxx>
#include <stringau.hxx>
#include <iiscnfg.h>

/********************************************************************++
--********************************************************************/

//
// Private constants.
//

#define DIRLIST_CHUNK_BUFFER_SIZE 8192

//
//  Private globals. 
//

//  BUGBUG: Should be loaded from Resource file
CHAR g_achToParentText[] = "[To Parent Directory]";

DWORD   g_fDirFlagsSet = FALSE;

//
//  Private Manifests
//

//
//  The first part of the HTML document, %s is the URL
//

#define HTML_DIR_HEADER             "<head><title>%s - %s</title></head>"     \
                                    "<body><H1>%s - %s</H1>"                  \
                                    "<hr>\r\n\r\n<pre>"

//
//  The footer for an HTML document
//

#define HORZ_RULE                   "</pre><hr></body>"

//
// Empty chunk to terminate the document
//

#define EMPTY_CHUNK                 "0\r\n\r\n"

//
// HTML for link to Parent
//

#define HTML_TO_PARENT       "<A HREF=\"%s\">%s</A><br><br>"

//
//  These constants define the field width for the directory listing
//

#define PAD_LONG_DATE           29
#define PAD_SHORT_DATE          10
#define PAD_TIME                 8
#define PAD_FILESIZE            12

//
//  Space between columns
//

#define COL_SPACE             " "
#define PAD_COL_SPACING       (sizeof(COL_SPACE) - 1)

//
//  A wsprintf format string that prints the file format like:
//
//  <date><time><size><anchor><file name>
//

#define DIR_FORMAT_STR        "%s%s%s<A HREF=\"%s\">%s</A><br>"

//
//  We assume a formatted directory entry will fit in this size
//

#define MIN_BUFF_FREE               350
#define CHUNK_OFFSET                10

//
//  Global data
//

/********************************************************************++
--********************************************************************/

//
//  Private prototypes.
//


VOID PadDirField( 
    CHAR *  pch,
    INT     pad );

ULONG
AddDirHeaders(
    IN     LPSTR               pszServer,
    IN OUT LPSTR               pszPath,
    IN     BOOL                fModifyPath,
    OUT    CHAR *              pchBuf,
    IN     DWORD               cbBuf,
    OUT    DWORD *             pcbWritten,
    IN     CHAR *              pszToParentText
    );

ULONG
FormatDirEntry(
    OUT CHAR *              pchBuf,
    IN  DWORD               cbBuf,
    OUT DWORD *             pcbWritten,
    IN  CHAR *              pchFile,
    IN  CHAR *              pchLink,
    IN  DWORD               dwAttributes,
    IN  LARGE_INTEGER *     pliSize,
    IN  LARGE_INTEGER *     pliLastMod,
    IN  DWORD               dwDirBrowseFlags,
    IN  BOOL                bLocalizeDateAndTime
    );

ULONG
BuildDirectoryListingChunk(
    PUL_DATA_CHUNK      pDataChunk,
    BUFFER *            pDataBuffer,
    DWORD               cbBuff,
    UL_HTTP_VERSION     HttpVersion,
    bool                fLastChunk
    );

BOOL
UrlEscape( 
    CHAR * pchSrc,
    CHAR * pchDest,
    DWORD  cbDest
    );

/********************************************************************++
--********************************************************************/


ULONG
DoDirList(
    IWorkerRequest *    pReq,
    LPCWSTR             pwszDirPath,
    BUFFER *            pulResponseBuffer,
    BUFFER *            pDataBuffer,
    PULONG              pHttpStatus
    )
/*++

    NAME:       DoDirList

    SYNOPSIS:   Produces an HTML doc from a directory enumeration

    ARGUMENTS:  pReq         - Worker Request doing the directory listing
                pwszDirPath  - Directory to enumerate
                pulResponseBuffer - Where to build the response chunks for UL
                pDataBuffer  - Where to create the body of the dir listing
                pHttpStatus  - Where to set the HTTP Status code

    RETURNS:    Win32 Error

    NOTES:      We temporarily escape the directory URL so the anchors
                are built correctly (no spaces etc).

    HISTORY:
        Johnl       12-Sep-1994 Created
--*/
{

    //
    // Helpful pointers and variables
    //
    
    PUL_HTTP_RESPONSE_v1   pulResponse;
    PUL_DATA_CHUNK      pDataChunk;
    PUL_HTTP_REQUEST    pulRequest = pReq->QueryHttpRequest();
    UL_HTTP_VERSION     HttpVersion = pulRequest->Version;

    //
    // FindFile variables
    //
    
    HANDLE              hDirSearch;
    WIN32_FIND_DATAA    FileFindData;

    
    DWORD               cbFree;             // # bytes free in the Data Buffer
    DWORD               cbOffset;           // # bytes used in the Data Buffer
    DWORD               cbWritten;          
    bool                fHeaderSent = false;// has the first chunk been sent
    
    ULONG               rc  = NO_ERROR;
    STRAU               str;
    CHAR                szFooterChunk[]    = HORZ_RULE"\r\n"EMPTY_CHUNK;

    IF_DEBUG( PARSING )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[DoDirList] Doing directory list on %ws\n",
                   pwszDirPath));
    }

    //
    // Setup FindFirstFile. 
    //
    
    if ( !str.Copy  ( pwszDirPath  ) ||
         !str.Append( "\\*", 2  )            // Append search string to path
       )
    {
        return ERROR_OUTOFMEMORY;
    }
    
    //
    // Start searching the files in this directory.
    //
    
    hDirSearch = ::FindFirstFileA( str.QueryStrA(), &FileFindData) ;
    
    if (INVALID_HANDLE_VALUE == hDirSearch)
    {
        return GetLastError();
    }

    //
    // From this point onwards everbody must return via exit to 
    // close the search handle correctly.
    //

    //
    // Create Response Header. 2 chunks - 
    //    i)  Standard Response Header
    //    ii) HTML Dirlist 
    //

    if (NO_ERROR != (rc = ResizeResponseBuffer(pulResponseBuffer, 2)))
    {
        goto exit;
    }

    pulResponse = (PUL_HTTP_RESPONSE_v1 ) (pulResponseBuffer->QueryPtr());
    
    pulResponse->Flags                = 0;
    pulResponse->HeaderChunkCount     = 1;
    pulResponse->EntityBodyChunkCount = 1;

    pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);
    
    FillDataChunkWithStringItem(pDataChunk, STIDirectoryListingHeaders);

    pDataChunk++;    // point to Data Chunk

    //
    // Head request processing done
    //
    
    if ( UlHttpVerbHEAD == pulRequest->Verb)
    {
        pulResponse->EntityBodyChunkCount = 0;
        rc = NO_ERROR;
        goto exit;
    }

    //
    // Resize Data Buffer to appropriate size for chunking
    //
    
    if (!pDataBuffer->Resize( DIRLIST_CHUNK_BUFFER_SIZE ))
    {
        rc = ERROR_OUTOFMEMORY;
        goto exit;
    }

    //
    // Leave space for chunk encoding
    //
    
    cbFree  = pDataBuffer->QuerySize() - CHUNK_OFFSET;
    cbOffset= CHUNK_OFFSET;
    
    //
    //  Add the "To Parent" anchor and directory name at the top
    //

    rc = AddDirHeaders( (LPSTR) pReq->QueryHostAddr(false),
                        (LPSTR) pReq->QueryURI(false),
                        FALSE,
                        (CHAR *) pDataBuffer->QueryPtr() + cbOffset,
                        cbFree,
                        &cbWritten,
                        g_achToParentText );
                        
    if ( NO_ERROR != rc)
    {
        goto exit;
    }

    //
    // Update Data Buffer information
    //
    
    cbFree   -= cbWritten;
    cbOffset += cbWritten;
    
    //
    //  For each subsequent file/directory, display it
    //
    
    do
    {
        //
        //  Ignore the "." and ".." and hidden entries
        //

        if ( ( 0 == (FileFindData.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) &&
             strcmp( FileFindData.cFileName, ".") &&
             strcmp( FileFindData.cFileName, "..")  )
        {
            //
            //  Build HTML listing.
            //

            LARGE_INTEGER  liSize;
            LARGE_INTEGER  liTime;

            //
            //  Do we need to send this chunk of our directory listing response?
            //

            if ( cbFree  < MIN_BUFF_FREE )  // Enough space for next listing
            {

                //
                // Chunk encode the data & create appropriate UL Data Chunk
                //
                
                rc = BuildDirectoryListingChunk( pDataChunk, 
                                                 pDataBuffer,
                                                 cbOffset,
                                                 HttpVersion,
                                                 false
                                                );
                
                if (NO_ERROR == rc)
                {
                    //
                    // Send a Synchronous response. This may become async later
                    //
                    
                    rc = pReq->SendSyncResponse( pulResponse);
                }

                if (NO_ERROR == rc)
                {
                    if (!fHeaderSent)
                    {
                        //
                        // This is the first send. No mode headers. 
                        // Data chunk is the 1 & only chunk from now on.
                        //
                        
                        fHeaderSent = true;
    
                        pulResponse->Flags                = 0;
                        pulResponse->HeaderChunkCount     = 0;
                        pulResponse->EntityBodyChunkCount = 1;

                        pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);
                    }

                    //
                    // Leave space for chunk encoding
                    //
    
                    cbFree  = pDataBuffer->QuerySize() - CHUNK_OFFSET;
                    cbOffset= CHUNK_OFFSET;
                }
                else
                {
                    goto exit;
                }
            }

            //
            // Create the link. RequestURI+'/'+FileName
            //

            if ( !(str.Copy  ( (LPSTR) pReq->QueryURI(false)) &&
                  ((*(str.QueryStr() + str.QueryCCH() - 1) != '/') ? str.Append("/") : 1 ) &&
                  str.Append(FileFindData.cFileName))
               )
            {
                rc = ERROR_OUTOFMEMORY;
                goto exit;
            }

            //
            // The liTime is a hack, since FormatDirEntry() does not
            // take FILETIMEs. It should probably be modified.
            //
            
            liTime.HighPart = FileFindData.ftLastWriteTime.dwHighDateTime;
            liTime.LowPart  = FileFindData.ftLastWriteTime.dwLowDateTime;
            liSize.HighPart = FileFindData.nFileSizeHigh;
            liSize.LowPart  = FileFindData.nFileSizeLow;

            //
            // Create directory entry in the data buffer
            //
            
            rc = FormatDirEntry( (CHAR *) pDataBuffer->QueryPtr() + cbOffset,
                                  cbFree,
                                  &cbWritten,
                                  (char * ) FileFindData.cFileName,
                                  str.QueryStrA(),
                                  FileFindData.dwFileAttributes,
                                  (LARGE_INTEGER *) &liSize,
                                  (LARGE_INTEGER *) &liTime,
                                  MD_DIRBROW_MASK,
                                  TRUE 
                                );
                                
            if (NO_ERROR != rc)
            {
                goto exit;
            }

            //
            //  Track how much was just added for this directory entry
            //

            cbFree   -= cbWritten;
            cbOffset += cbWritten;

        }
        
    }
    while ( FindNextFileA( hDirSearch, &FileFindData));

    //
    // Add a nice horizontal line at the end of the listing.
    // Resize if needed
    //
    
    if ( cbFree < sizeof(szFooterChunk)-1)
    {
        if (!pDataBuffer->Resize(cbOffset+sizeof(szFooterChunk)))
        {
            rc = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }
    
    memcpy( (CHAR *)pDataBuffer->QueryPtr()+cbOffset,  HORZ_RULE, sizeof(HORZ_RULE)-1);
    
    cbOffset += sizeof(HORZ_RULE)-1;

    //
    // Build the last directory chunk
    //

    rc = BuildDirectoryListingChunk( pDataChunk, 
                                     pDataBuffer,
                                     cbOffset,
                                     HttpVersion,
                                     true
                                   );

exit:

    //
    // The last chunk should be sent asynchronously to drive the
    // request to the next state.
    //

    FindClose(hDirSearch);
    hDirSearch = NULL;

    return rc;
}

/********************************************************************++
--********************************************************************/

ULONG
AddDirHeaders(
    IN     LPSTR               pszServer,
    IN OUT LPSTR               pszPath,
    IN     BOOL                fModifyPath,
    OUT    CHAR *              pchBuf,
    IN     DWORD               cbBuf,
    OUT    DWORD *             pcbWritten,
    IN     CHAR *              pszToParentText
    )
/*++

Routine Description:

    Provides the initial HTML needed for a directory listing.

Arguments:

    pszServer - Server name
    pszPath - Path portion of URL
    fModifyPath - Set to TRUE if the last segment of the pszPath
        parameter should be removed
    pchBuf - Buffer to place text into
    cbBuf - size of pchBuf
    pcbWritten - Number of bytes written to pchBuf
    pszToParentText - The text to use for the "To Parent"

Returns:

    Win32 Error

--*/
{
    DWORD  cch;
    DWORD  cchUrl;
    DWORD  cchServer;
    DWORD  cbNeeded;
    CHAR * pch;
    CHAR * GfrPath = pszPath;
    DWORD  cbInBuf = cbBuf;
    CHAR * pchSlash = NULL;
    CHAR * pch1 = NULL;
    CHAR * pch2 = NULL;
    CHAR   ch2;

    //
    //  Add the HTML document header
    //

    cchServer = strlen( pszServer );
    cchUrl    = strlen( pszPath );

    cbNeeded = sizeof( HTML_DIR_HEADER ) - 1 +
               2 * (cchServer + cchUrl) * sizeof(CHAR);

    if ( cbBuf < cbNeeded )
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    cch = wsprintfA(  pchBuf,
                      HTML_DIR_HEADER,
                      pszServer,
                      pszPath,
                      pszServer,
                      pszPath );

    cbBuf  -= cch;
    pchBuf += cch;

    //
    //  If there's no slash, then we assume we're at the root so we're done
    //

    if ( !strchr( pszPath, '/' ) )
    {
        goto Exit;
    }

    //
    //  If we're not at the root, add a "to parent", but first remove the
    //  last segment of the path
    //

    pch1 = strrchr( pszPath, '/' );

    if ( !pch1 )
    {
        goto Exit;
    }

    //
    //  If the URL ended in a slash, then go to the previous
    //  one and truncate one character after it.
    //

    if ( *(pch1+1) == TEXT('\0') )
    {
        *pch1 = '\0';

        pch2 = strrchr( pszPath, '/' );

        if ( !pch2 )
        {
            goto Exit;
        }
    }
    else
    {
        pch2 = pch1;
        pch1 = NULL;
    }

    ch2   = *(++pch2);
    *pch2 = TEXT('\0');

    //
    //  Do we have enough room in the buffer?
    //

     cbNeeded = sizeof( HTML_TO_PARENT ) +
                strlen( pszPath )        +
                strlen( pszToParentText );

     if ( cbBuf < cbNeeded )
     {
         return ERROR_INSUFFICIENT_BUFFER;
     }

     cch =  wsprintfA( pchBuf,
                       HTML_TO_PARENT,
                       pszPath,
                       pszToParentText );

    cbBuf  -= cch;
    pchBuf += cch;

Exit:
    *pcbWritten = cbInBuf - cbBuf;

    //
    //  Restore the path if we shouldn't remove the last segment
    //

    if ( !fModifyPath )
    {
        if ( pch1 )
            *pch1 = '/';

        if ( pch2 )
            *pch2 = ch2;
    }

    return NO_ERROR;
}

/********************************************************************++
--********************************************************************/

ULONG
FormatDirEntry(
    OUT CHAR *              pchBuf,
    IN  DWORD               cbBuf,
    OUT DWORD *             pcbWritten,
    IN  CHAR *              pchFile,
    IN  CHAR *              pchLink,
    IN  DWORD               dwAttributes,
    IN  LARGE_INTEGER *     pliSize,
    IN  LARGE_INTEGER *     pliLastMod,
    IN  DWORD               dwDirBrowseFlags,
    IN  BOOL                bLocalizeDateAndTime
    )
/*++

Routine Description:

    Formats an individual directory entry

Arguments:

    pchBuf - Buffer to place text into
    cbBuf - size of pchBuf
    pcbWritten - Number of bytes written to pchBuf
    pchFile - Display name of directory entry
    pchLink - HTML Anchor for pchFile
    dwAttributes - File attributes
    pliSize - File size, if NULL, then the file size isn't displayed
    pliLastMod - Last modified time
    dwDirBrowseFlags - Controls what fields to display
    bLocalizeDateAndTime - TRUE if pliLastMod must be converted to local time

Returns:

    Win32 Error

--*/
{
    UINT        cchTime;
    CHAR        achDate[50];
    CHAR        achTime[15];
    CHAR        achSize[30];
    CHAR        achLink[MAX_PATH * 2 + 1];
    SYSTEMTIME  systime;
    SYSTEMTIME  systimeUTCFile;
    CHAR *      pch;

    *achDate = *achTime = *achSize = '\0';

    //
    //  Add optional date and time of this file.  We use the locale
    //  and timezone of the server
    //

    if ( (dwDirBrowseFlags & (MD_DIRBROW_SHOW_DATE | MD_DIRBROW_SHOW_TIME)) &&
         ((0 != pliLastMod->HighPart) && ( 0 != pliLastMod->LowPart))
       )
    {
        BOOL fLongDate = (0 != (dwDirBrowseFlags & MD_DIRBROW_LONG_DATE));
        LCID lcid;

        if (bLocalizeDateAndTime) 
        {

            FILETIME ftLocal;
            SYSTEMTIME tmpTime;
            
            if ( !FileTimeToLocalFileTime( (PFILETIME)pliLastMod,
                                           &ftLocal ) ||
                 !FileTimeToSystemTime( &ftLocal, &systime ))
            {
                return GetLastError();
            }

            //
            // Don't use FileTimeToSystemTime followed by 
            // SystemTimeToTzSpecificLocalTime because it is not win95 compliant.  
            // Behaviour is different because that one maintains active timezone 
            // information.
            //

        } 
        else if ( !FileTimeToSystemTime( (FILETIME *) pliLastMod,
                                            &systime )) 
        {
            return GetLastError();
        }

        lcid = GetSystemDefaultLCID();

        if ( dwDirBrowseFlags & MD_DIRBROW_SHOW_DATE )
        {
            cchTime = GetDateFormatA( lcid,
                                      LOCALE_NOUSEROVERRIDE |
                                      (fLongDate ? DATE_LONGDATE :
                                                   DATE_SHORTDATE),
                                      &systime,
                                      NULL,
                                      achDate,
                                      sizeof(achDate));

            PadDirField( achDate, fLongDate ? PAD_LONG_DATE : PAD_SHORT_DATE );
        }

        if ( dwDirBrowseFlags & MD_DIRBROW_SHOW_TIME )
        {
            cchTime = GetTimeFormatA( lcid,
                                      LOCALE_NOUSEROVERRIDE |
                                      TIME_NOSECONDS,
                                      &systime,
                                      NULL,
                                      achTime,
                                      sizeof(achTime));

            PadDirField( achTime,
                         PAD_TIME );
        }
    }

    //
    //  Add the optional file size
    //

    if ( (dwDirBrowseFlags & MD_DIRBROW_SHOW_SIZE) &&
         pliSize 
       )
    {
        INT pad = PAD_FILESIZE;

        if ( dwAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            strcpy( achSize,
                    "&lt;dir&gt;" );

            //
            //  Need to adjust for using "&lt;" instead of "<"
            //

            pad += 6;
        }
        else
        {
            _itoa( pliSize->LowPart, achSize, 10 );
        }

        PadDirField( achSize, pad );
    }


    //
    //  We have to escape the link name that is used in the URL anchor
    //

    
    UrlEscape( pchLink,
               achLink,
               sizeof(achLink) );
    
    
    //
    //  If the show extension flag is not set, then strip it.  If the
    //  file name begins with a dot, then don't strip it.
    //

    if ( !(dwDirBrowseFlags & MD_DIRBROW_SHOW_EXTENSION) )
    {
        pch = (char *) pchFile + strlen( pchFile );

        while ( *pch != '.'  &&
                pch > (pchFile + 1) )
        {
            pch--;
        }

        if ( *pch == '.' )
            *pch = '\0';
    }

    //
    //  Make sure there's enough room at the end of the string for the sprintf
    //

    UINT cbTotal =  strlen( achDate ) +
                    strlen( achTime ) +
                    strlen( achSize ) +
                    strlen( achLink ) +
                    strlen( pchFile ) +
                    sizeof( DIR_FORMAT_STR );

    if ( cbTotal > cbBuf )
    {
        //
        //  Note we will lose this directory entry if we fail here
        //

        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pcbWritten = wsprintfA(  pchBuf,
                              DIR_FORMAT_STR,
                              achDate,
                              achTime,
                              achSize,
                              achLink,    // Escaped link
                              pchFile );  // Unescaped file name

    return NO_ERROR;
}

/*******************************************************************

    NAME:       PadDirField

    SYNOPSIS:   Right Justifies and pads the passed string and appends
                a column spacing

    ENTRY:      pch - String to pad
                pad - Size of field to pad to

    HISTORY:
        Johnl       12-Sep-1994 Created

********************************************************************/

VOID PadDirField( CHAR * pch,
                  INT    pad )
{
    INT   cch ;
    INT   diff;
    INT   i;

    cch = strlen( pch );

    if ( cch > pad )
    {
        pad = cch;
    }
    
    diff = pad-cch;

    //
    //  Insert spaces in front of the text to pad it out
    //

    memmove( pch + diff, pch, cch + 1);

    for ( i = 0; i < diff; i++, pch++ )
    {
        *pch = ' ';
    }
    
    //
    //  Append a column spacer at the end
    //

    pch += cch;

    for ( i = 0; i < PAD_COL_SPACING; i++, pch++ )
    {
        *pch = ' ';
    }
    
    *pch = '\0';
}

/********************************************************************++
--********************************************************************/

ULONG
BuildDirectoryListingChunk(
    PUL_DATA_CHUNK      pDataChunk,
    BUFFER *            pDataBuffer,
    DWORD               cbBuff,
    UL_HTTP_VERSION     HttpVersion,
    bool                fLastChunk
    )
/*++

    BuildDirectoryListingChunk

    Routine Description - Add a chunk header and footer to some stuff we're
    about to send. It's assumed CHUNK_OFFSET bytes at the start of the buffer
    are reserved for us. We also append at least a CRLF to the end, and maybe
    more, that the caller needs to be aware of.

    Arguments:

        pDataChunk      - Pointer to Data chunk that will point to the data buffer. 
        pDataBuffer     - Pointer to Data buffer to add chunking stuff to.
        cbBuff          - Bytes currently in Data Buffer.
        HttpVersion     - HTTP Version for this request.
        fLastChunk      - TRUE if this is the last chunk of the response.

    Returns:
        Win32 Error
--*/
{
    DWORD   dwChunkLength = 0;
    
    if ( UlHttpVersion11 <= HttpVersion)
    {
        CHAR        cChunkSize[10];
        DWORD       cbFooter = 2;
        CHAR        szFooter[]   = "\r\n"EMPTY_CHUNK;
        //
        // Stamp the chunk size in
        //
    
        dwChunkLength = wsprintfA(cChunkSize, "%x\r\n", cbBuff-CHUNK_OFFSET);

        DBG_ASSERT(CHUNK_OFFSET >= dwChunkLength);
        
        memcpy((CHAR *)pDataBuffer->QueryPtr() + CHUNK_OFFSET - dwChunkLength,
                cChunkSize,
                dwChunkLength);

        if (fLastChunk)
        {
            cbFooter = sizeof(szFooter)-1;
        }

        if ( pDataBuffer->QuerySize() < (cbBuff + cbFooter))
        {
            if (!pDataBuffer->Resize(pDataBuffer->QuerySize() + cbFooter))
            {
                return ERROR_OUTOFMEMORY;
            }
        }

        memcpy( (CHAR *)pDataBuffer->QueryPtr() + cbBuff,
                szFooter,
                cbFooter
               );
               
        cbBuff += cbFooter;
    }

    //
    // Fill in the UL Data Chunk
    //

    pDataChunk->DataChunkType           = UlDataChunkFromMemory;
    pDataChunk->FromMemory.pBuffer      = ((LPBYTE) pDataBuffer->QueryPtr()) + CHUNK_OFFSET - dwChunkLength;
    pDataChunk->FromMemory.BufferLength = cbBuff - ( CHUNK_OFFSET - dwChunkLength);
    
    return NO_ERROR;
}


/********************************************************************++
--********************************************************************/

//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
    (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')

BOOL
UrlEscape( CHAR * pchSrc,
           CHAR * pchDest,
           DWORD  cbDest
           )
/*++

Routine Description:

    Replaces all "bad" characters with their ascii hex equivalent

Arguments:

    pchSrc - Source string
    pchDest - Receives source with replaced hex equivalents
    cbDest - Size of pchDest

Returns:

    TRUE if all characters converted, FALSE if the destination buffer is too
    small

--*/
{
    CHAR    ch;
    DWORD   cbSrc;

    cbSrc = strlen( pchSrc ) + 1;

    *pchDest = '\0';

    if ( cbSrc > cbDest )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    while ( ch = *pchSrc++ )
    {
        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&') ||
              (ch == '#')) &&
             !(ch == '\n' || ch == '\r')  )
        {
            if ( cbDest < cbSrc + 2 )
            {
                strcpy( pchDest, pchSrc );
                return FALSE;
            }

            //
            //  Insert the escape character
            //

            pchDest[0] = '%';

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            pchDest[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            pchDest[1] = HEXDIGIT( nDigit );

            pchDest += 3;
            cbDest  -= 3;
        }
        else
        {
            *pchDest++ = ch;
            cbDest++;
        }

        cbSrc++;
    }

    *pchDest = '\0';

    return TRUE;
}

/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISMSTAT";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iismstat");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        // LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISMSTAT::DllMain::DLL_PROCESS_ATTACH\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISMSTAT::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\uridata\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\dotrace.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       DoTrace.cxx

   Abstract:
       Defines the functions for processing TRACE requests.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     01-Dec-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

/********************************************************************++
--********************************************************************/

ULONG
ResizeResponseBuffer(
    BUFFER * pulResponseBuffer, 
    ULONG   cDataChunks
    )
{
    DWORD   cbRequiredSize;

    cbRequiredSize = sizeof(UL_HTTP_RESPONSE_v1) + 
                     cDataChunks * sizeof(UL_DATA_CHUNK);
    
    if ( pulResponseBuffer->QuerySize() < cbRequiredSize)
    {
        if ( !pulResponseBuffer->Resize(cbRequiredSize))
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    return NO_ERROR;
}

/********************************************************************++

Routine Description:
    This function handles TRACE verb. 
    It produces a plain echo and sends this out to the client.
    The resposne consists of two chunks:
    a) Usualy headers sent out by the server
    b) Request headers formatted by the server code and sent out
            as an echo to the client.

    On success an async operation will be queued and one can expect 
     to receive the async io completion.

Arguments:
    None

Returns:
    ULONG

--********************************************************************/

ULONG
DoTRACEVerb(
    IWorkerRequest * pReq, 
    BUFFER         * pulResponseBuffer, 
    BUFFER         * pDataBuffer,
    PULONG           pHttpStatus
    )
{

    DBG_ASSERT( NULL != pReq);
    DBG_ASSERT( NULL != pulResponseBuffer);
    DBG_ASSERT( NULL != pDataBuffer);

    ULONG               rc, cbDataLen = 0;
    PUL_HTTP_REQUEST    pulRequest   = pReq->QueryHttpRequest();
    PUL_HTTP_RESPONSE_v1   pulResponse;
    PUL_DATA_CHUNK      pDataChunk;

    //
    // resize the response buffer appropriately
    //
    
    if ( NO_ERROR != (rc = ResizeResponseBuffer(pulResponseBuffer, 3)))
    {
        return rc;
    }
    
    //
    // Format the trace response for transmission.
    //

    pulResponse = (PUL_HTTP_RESPONSE_v1 ) (pulResponseBuffer->QueryPtr());
    
    pulResponse->Flags = UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH;
    pulResponse->HeaderChunkCount     = 1;
    pulResponse->EntityBodyChunkCount = (0 == pulRequest->EntityBodyLength) ?
                                        1 : 2;

    pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);
    
    FillDataChunkWithStringItem( pDataChunk, STITraceMessageHeaders);

    //
    // Reconstruct the request into the data buffer
    //

    rc = BuildEchoOfHttpRequest( pulRequest, pDataBuffer, cbDataLen);
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "Failed to create a trace of request headers."));
        }

        return (rc);
    }

    pDataChunk[1].DataChunkType           = UlDataChunkFromMemory;
    pDataChunk[1].FromMemory.pBuffer      = pDataBuffer->QueryPtr();
    pDataChunk[1].FromMemory.BufferLength = cbDataLen;

    //
    // ISSUE: Use original request buffer not the one modified by Filters.
    //
    
    if (0 != pulRequest->EntityBodyLength)
    {
        pDataChunk[2].DataChunkType           = UlDataChunkFromMemory;
        pDataChunk[2].FromMemory.pBuffer      = pulRequest->pEntityBody;
        pDataChunk[2].FromMemory.BufferLength = pulRequest->EntityBodyLength;
    }
        
    return rc;
    
} // DoTRACEVerb()




/********************************************************************++

Routine Description:
    Formats a trace response message and sends this out to the client.
    This is a temporary placeholder till other parts of infrastructure
     are developed.

    On success an async operation will be queued and one can expect 
     to receive the async io completion.

Arguments:
    None
    
Returns:
    ULONG

--********************************************************************/

ULONG
SendTraceResponseAsHTML(
    IWorkerRequest * pReq, 
    BUFFER         * pulResponseBuffer, 
    BUFFER         * pDataBuffer
    )
{
    DBG_ASSERT( pReq != NULL);

    ULONG               rc;
    PUL_HTTP_REQUEST    pulRequest   = pReq->QueryHttpRequest();
    PUL_HTTP_RESPONSE_v1   pulResponse;
    PUL_DATA_CHUNK      pDataChunk;

    //
    // resize the response buffer appropriately
    //
    
    if ( NO_ERROR != (rc = ResizeResponseBuffer(pulResponseBuffer, 4)))
    {
        return rc;
    }
    
    //
    // Format the trace response for transmission.
    //

    pulResponse = (PUL_HTTP_RESPONSE_v1) (pulResponseBuffer->QueryPtr());
    
    pulResponse->Flags = (UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH | 
                          UL_HTTP_RESPONSE_FLAG_CALC_ETAG );
    pulResponse->HeaderChunkCount     = 1;
    pulResponse->EntityBodyChunkCount = 3;

    pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);

    FillDataChunkWithStringItem( pDataChunk + 0, STITraceMessageHeadersHTML);
    FillDataChunkWithStringItem( pDataChunk + 1, STITraceMessageBodyStartHTML);

    if (!DumpHttpRequestAsHtml( pulRequest, pDataBuffer)) 
    {
        rc = GetLastError();
        
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "Failed to create a trace of request headers. Error=%08x\n",
                        rc
                        ));
        }

        return (rc);
    }

    pDataChunk[2].DataChunkType           = UlDataChunkFromMemory;
    pDataChunk[2].FromMemory.pBuffer      = pDataBuffer->QueryPtr();
    pDataChunk[2].FromMemory.BufferLength = strlen((LPSTR) pDataBuffer->QueryPtr());

    FillDataChunkWithStringItem( pDataChunk + 3, STITraceMessageBodyEndHTML);

    return rc;

} // SendTraceResponseAsHTML()

/********************************************************************++

Routine Description:
    This function handles all the verbs except ones that have specific 
        functions.
        
    On success an async operation will be queued and one can expect 
     to receive the async io completion.

Arguments:
    None

Returns:
    ULONG

--********************************************************************/

ULONG
DoDefaultVerb(
    IWorkerRequest * pReq, 
    BUFFER         * pulResponseBuffer, 
    BUFFER         * pDataBuffer,
    PULONG           pHttpStatus
    )
{
    DBG_ASSERT( pReq != NULL);

    //
    // NYI: For now send back the trace of headers themselves
    //
    
    return SendTraceResponseAsHTML(pReq, pulResponseBuffer, pDataBuffer);
    
} // DoDefaultVerb()

/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\doget.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
       DoGet.cxx

   Abstract:
       Defines the functions for processing GET requests.

   Author:
       Saurab Nog       (SaurabN)       10-Jan-1999          

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process (web service)
--*/

/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#include <iiscnfg.h>
#include <StatusCodes.hxx>

DWORD AToDW(
    LPCSTR *ppStr,
    LPCSTR pEnd,
    bool   *pfIsPresent
    );


/********************************************************************++

Routine Description:

    This function handles GET & HEAD verb.

    The UL Response in placed in pulResponseBuffer. Data to be
    sent is placed in pDataBuffer.

    We never retrieve a hidden file or directory.  We will process
    hidden map files however.

    On success an async operation will be queued and one can expect
    to receive the async io completion.

Arguments:
    pReq                - Worker Request
    pulResponseBuffer   - Ul Response should be built in this buffer
    pDataBuffer         - Data to be sent from memory for async 
                          operation must be put in this buffer.
    pHttpStatus         - HTTP Status Code
    
Returns:
    Win32 Error

--********************************************************************/

ULONG
DoGETVerb(
    IWorkerRequest * pReq,
    BUFFER         * pulResponseBuffer,
    BUFFER         * pDataBuffer,
    PULONG           pHttpStatus
    )
{
    DBG_ASSERT(NULL != pReq );

    BOOL    fHidden;
    BOOL    fDirectory;
    bool    fIsMapRequest;
    ULONG   rc;

    PUL_HTTP_REQUEST    pulRequest      = pReq->QueryHttpRequest();
    PURI_DATA           pUriData        = (PURI_DATA) pReq->QueryModule(WRS_FETCH_URI_DATA);
    LPCWSTR             pwszFileName    = pUriData->QueryFileName();

    DBG_ASSERT(NULL != pulRequest);
    DBG_ASSERT(NULL != pUriData);
    DBG_ASSERT(NULL != pwszFileName);

    IF_DEBUG( DUMPS)
    {
        //
        // Dump the request object for now
        //

        DumpHttpRequest( pulRequest);
    }

    //
    // Don't allow the * URL
    //
    
    if ( pulRequest->pFullUrl[0]  == L'*')
    {
        *pHttpStatus = HT_BAD_REQUEST;
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check file name is not too long
    //
    
    if ( wcslen(pwszFileName)  > MAX_PATH)
    {   
        *pHttpStatus = HT_URL_TOO_LONG;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Check for hidden files. Deny processing except for MAP files
    //

    fHidden         = pUriData->QueryFileAttributes() & FILE_ATTRIBUTE_HIDDEN;
    fDirectory      = pUriData->QueryFileAttributes() & FILE_ATTRIBUTE_DIRECTORY;
    fIsMapRequest   = !_wcsnicmp( (pwszFileName+wcslen(pwszFileName)-3), L"map", 3);

    if (fHidden && !fIsMapRequest)
    {
        //
        // Not a MAP file
        //
        
        *pHttpStatus = HT_NOT_FOUND;
        return fDirectory ? ERROR_PATH_NOT_FOUND : ERROR_FILE_NOT_FOUND;
    }


    if (fDirectory)
    {
        BOOL fAllowDefaultFile = pUriData->QueryDirBrowseFlags()  & MD_DIRBROW_LOADDEFAULT;
        BOOL fAllowDirList     = pUriData->QueryDirBrowseFlags()  & MD_DIRBROW_ENABLED;

        //
        // Send default file if enabled
        //

        if ( fAllowDefaultFile)
        {
            rc = CheckDefaultLoad(pwszFileName);

            //
            // continue only if no default file exists
            //

            if ( rc != ERROR_FILE_NOT_FOUND )
            {
                return rc;
            }
        }

        //
        // Send directory listing if enabled
        //

        if (fAllowDirList)
        {
            return DoDirList( pReq,
                              pwszFileName,
                              pulResponseBuffer,
                              pDataBuffer,
                              pHttpStatus
                            );
        }

        *pHttpStatus = HT_FORBIDDEN;
        return ERROR_ACCESS_DENIED;
    }
    else
    {
        if (fIsMapRequest)
        {
            //
            // MAP request
            //

            return ProcessISMAP( pReq,
                                 pwszFileName,
                                 pulResponseBuffer,
                                 pDataBuffer,
                                 pHttpStatus
                               );
        }
        
        rc = BuildFileItemResponse( pulRequest,
                                    pUriData,
                                    pwszFileName,
                                    pulResponseBuffer,
                                    pHttpStatus
                                  );

        IF_DEBUG( TRACE)
        {
            DBGPRINTF(( DBG_CONTEXT, "BuildFileItemResponse returned: %d\n", rc));
        }
    }

    if ( NO_ERROR != rc )
    {
        //
        // Send operation failed. Wind back and let the callee take
        // care of cleaning up.
        //

        IF_DEBUG( ERROR)
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "DoGETVerb() failed for %s\n",
                      (PSTR)pulRequest->pFullUrl
                   ));
        }
    }

    return rc;

} // DoGETVerb()

/********************************************************************++

Routine Description:
    This function sends out the file item referenced by the URI Item
    data. It creates a response header with the appropriate fields and
    tags on the file-name as the entity body chunk before calling into UL.

    On success an async operation will be queued and one can expect
    to receive the async io completion.

Arguments:
    None

Returns:
    ULONG

--********************************************************************/

ULONG
BuildFileItemResponse(
    PUL_HTTP_REQUEST    pulRequest,
    PURI_DATA           pUriData,
    LPCWSTR             pwszFileName,
    BUFFER            * pulResponseBuffer,
    PULONG              pHttpStatus
    )
{
    DBG_ASSERT( pulRequest   != NULL);
    DBG_ASSERT( pUriData     != NULL);
    DBG_ASSERT( pwszFileName != NULL);

    ULONG               rc = NO_ERROR;

    PUL_HTTP_RESPONSE_v1   pulResponse;
    PUL_DATA_CHUNK      pDataChunk;
    PUL_BYTE_RANGE      pByteRange;
    LPCSTR              pszRangeHeader;
    BUFFER              ByteRangeBuffer(sizeof(UL_BYTE_RANGE));
    DWORD               i, cValidRanges = 0;
    DWORD               dwHeaderLength;

    if ( 0 != ( dwHeaderLength = pulRequest->Headers.pKnownHeaders[UlHeaderRange].RawValueLength))
    {
        DWORD   cbFileSizeLow, cbFileSizeHigh;
        
        pszRangeHeader = (LPCSTR) pulRequest->Headers.pKnownHeaders[UlHeaderRange].pRawValue;

        pUriData->QueryFileSize(cbFileSizeLow, cbFileSizeHigh);
        
        rc = ProcessRangeRequest(
                                 pszRangeHeader,
                                 dwHeaderLength,
                                 cbFileSizeLow,
                                 cbFileSizeHigh,
                                 0,                 // BUGBUG: Footer size 0 for now.
                                 ByteRangeBuffer,
                                 cValidRanges,
                                 pHttpStatus
                                 );

        IF_DEBUG( TRACE)
        {
            DBGPRINTF((DBG_CONTEXT, "ProcessRangeRequest returned: %d\n", rc));
        }
    }

    if ((NO_ERROR != rc) && 
        (0 == pulRequest->Headers.pKnownHeaders[UlHeaderIfRange].RawValueLength))
    {
        return rc;
    }

    pByteRange = (PUL_BYTE_RANGE) ByteRangeBuffer.QueryPtr();

    if ( 0 == cValidRanges)
    {
        pByteRange->StartingOffset.QuadPart = 0;
        pByteRange->Length.QuadPart         = UL_BYTE_RANGE_TO_EOF;
        cValidRanges                        = 1;
    }

    //
    // resize the response buffer appropriately
    //

    if ( NO_ERROR != (rc = ResizeResponseBuffer(pulResponseBuffer, 1 + cValidRanges)))
    {
        return rc;
    }

    //
    // A successful response to the client will consist of several small headers
    // 1. Standard server headers
    // 2. Time specific headers eg:
    //      Date: <currentdate/time> header
    // 3. Item specific headers eg:
    //      Last-Modified: <date/time>
    //      Content-Length: BB bytes
    //      Content-Type: text/html
    // 4. Termination chunk for indicating end of headers.
    //

    pulResponse = (PUL_HTTP_RESPONSE_v1 ) pulResponseBuffer->QueryPtr();

    pulResponse->Flags = (UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH |
                          UL_HTTP_RESPONSE_FLAG_CALC_ETAG |
                          UL_HTTP_RESPONSE_FLAG_CALC_LAST_MODIFIED);
    pulResponse->HeaderChunkCount     = 1;
    pulResponse->EntityBodyChunkCount = cValidRanges;

    pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);

    //
    // Store the response headers to send out.
    //

    //
    // Fill in the standard Response Header 
    //

    FillDataChunkWithStringItem( pDataChunk, STIStandardResponseHeaders);
    pDataChunk++;

    //
    // Fill in the file specific data here
    //

    for (i=0; i < cValidRanges; pDataChunk++, i++)
    {
        ZeroMemory(pDataChunk, sizeof(*pDataChunk));
        
        pDataChunk->DataChunkType          = UlDataChunkFromFileName;
        pDataChunk->FromFileName.FileNameLength = wcslen(pwszFileName)*sizeof(WCHAR);
        pDataChunk->FromFileName.pFileName = (PWSTR ) pwszFileName;
        pDataChunk->FromFileName.ByteRange = pByteRange[i];
    }

    return (rc);

} // BuildFileResponseItem()

/********************************************************************++

  Routine Description:

    Process a range request, updating member variables

  Returns:

    VOID

  Arguments:

    pstrPath        File being requested
    pdwOffset       Range offset
    pdwSizeToSend   Range size
    pfIsNxRange     TRUE if valid next range exists


--********************************************************************/


ULONG
ProcessRangeRequest(
    LPCSTR          pszRangeHeader,
    DWORD           cbHeaderLength,
    DWORD           cbFileSizeLow,
    DWORD           cbFileSizeHigh,
    DWORD           cbFooterLength,
    BUFFER&         ByteRangeBuffer,
    DWORD&          cRangeCount,
    PULONG          pHttpStatus
    )
{
    DWORD       cbOffset       = 0;
    ULONGLONG   cbSizeToSend   = 0;
    CHAR        Ch;

    BUFFER  bufRangeHeaders;

    bool    fEndOfRange             = false;
    bool    fEntireFile             = false;
    bool    fUnsatisfiableByteRange = false;

    LPCSTR  pszEndOfHeader = pszRangeHeader+cbHeaderLength-1;

    //
    // Skip the bytes = part of the header
    //

    while ((*pszRangeHeader != '=') && (pszRangeHeader <= pszEndOfHeader))
    {
        pszRangeHeader++;
    }

    if (*pszRangeHeader == '=')
    {
        pszRangeHeader++;
    }

    //
    // Rules for processing ranges
    //
    // If there is any Syntactically Invalid Byte-Range in the request, then the header
    // must be ignored. Return code is 200 with entire body (i.e. *pfEntireFile = TRUE).
    //
    // If the request is Syntactically Valid & any element is satisfiable, the partial
    // data for the satisfiable portions should be sent with return code HT_PARTIAL_CONTENT.
    //
    // If the request is Syntactically Valid & all elements are unsatisfiable and there
    // is no If-Range header the return error code is HT_RANGE_NOT_SATISFIABLE (416)
    //

    do
    {
        fUnsatisfiableByteRange = false;

        //
        // Skip to begining of next range
        //

        while ( (Ch=*pszRangeHeader) && (' '== Ch) && (pszRangeHeader <= pszEndOfHeader))
        {
            ++pszRangeHeader;
        }

        //
        // Test for end of range
        //

        if ( pszRangeHeader == pszEndOfHeader )
        {
            fEndOfRange = true;
            break;
        }

        //
        // determine Offset & Size to send
        //

        DWORD   cbBeginning, cbEnd;
        bool    fIsBeginningDefined, fIsEndDefined;

        cbBeginning = AToDW( &pszRangeHeader, pszEndOfHeader, &fIsBeginningDefined );

        if ( *pszRangeHeader == '-' )
        {
            ++pszRangeHeader;

            cbEnd = AToDW( &pszRangeHeader, pszEndOfHeader, &fIsEndDefined );

            if ( *pszRangeHeader == '-' || (!fIsBeginningDefined && !fIsEndDefined) )
            {
                //
                // Syntactically Invalid Range. Skip RANGE Header
                //

                fEntireFile = true;
                break;
            }

            if ( fIsBeginningDefined )
            {
                if ( fIsEndDefined )
                {
                    if ( cbBeginning <= cbEnd )
                    {
                        if ( cbEnd < cbFileSizeLow )
                        {
                            //
                            // Normal case
                            //

                            cbOffset     = cbBeginning;
                            cbSizeToSend = cbEnd - cbBeginning + 1;
                        }
                        else if (cbEnd < (cbFileSizeLow + cbFooterLength) )
                        {
                            //
                            // Asking for part of footer, send entire file.
                            //

                            cbOffset     = 0;
                            cbSizeToSend = UL_BYTE_RANGE_TO_EOF;
                        }
                        else if ( cbBeginning < cbFileSizeLow )
                        {
                            //
                            // End is past the file
                            //

                            cbOffset     = cbBeginning;
                            cbSizeToSend = UL_BYTE_RANGE_TO_EOF;
                        }
                        else if (cbBeginning < (cbFileSizeLow + cbFooterLength))
                        {
                            //
                            // Asking for part of footer, send entire file.
                            //

                            cbOffset     = 0;
                            cbSizeToSend = UL_BYTE_RANGE_TO_EOF;
                        }
                        else
                        {
                            //
                            // Syntactically Valid but Unsatisfiable range.
                            // Skip to the next range.
                            //

                            fUnsatisfiableByteRange  = true;
                        }
                    }
                    else
                    {
                        //
                        // End < Beginning : Syntactically Invalid Range. Skip RANGE Header
                        //

                        fEntireFile = true;
                        break;
                    }
                }
                else
                {
                    //
                    // Starting at cbBeginning until end.
                    //

                    if ( cbBeginning < cbFileSizeLow + cbFooterLength)
                    {
                        if ( 0 != cbFooterLength)
                        {
                            //
                            // There's a footer on the file, send the whole thing.
                            //

                            cbOffset = 0;
                            cbSizeToSend = cbFileSizeLow;
                        }
                        else
                        {
                            cbOffset = cbBeginning;
                            cbSizeToSend = cbFileSizeLow - cbBeginning;
                        }
                    }
                    else
                    {
                        //
                        // Syntactically Valid but Unsatisfiable range.
                        // Skip to the next range.
                        //

                        fUnsatisfiableByteRange  = TRUE;
                    }
                }
            }
            else
            {
                //
                // cbEnd last bytes
                //

                if (    (0    != cbEnd)      &&
                        (cbEnd < cbFileSizeLow)  &&
                        (cbFooterLength == 0)
                   )
                {
                    cbOffset = cbFileSizeLow - cbEnd;
                    cbSizeToSend = cbEnd;
                }
                else if ( 0 == cbEnd )
                {
                   //
                   // Syntactically Valid but Unsatisfiable range.
                   // Skip to the next range.
                   //

                    fUnsatisfiableByteRange  = true;
                }
                else
                {
                    //
                    // Return entire file
                    //

                    cbOffset = 0;
                    cbSizeToSend = cbFileSizeLow;
                }
            }
        }
        else
        {
            //
            // Syntactically Invalid Range. Skip RANGE Header
            //

            fEntireFile = true;
            break;
        }

        //
        // Skip to begining of next range
        //

        while ( (Ch=*pszRangeHeader) && Ch!=',' && (pszRangeHeader <= pszEndOfHeader))
        {
            ++pszRangeHeader;
        }
        if ( Ch == ',' )
        {
            ++pszRangeHeader;
        }

        if (!fUnsatisfiableByteRange)
        {
            //
            // Build range header
            //

            cRangeCount++;

            //
            // Resze if needed
            //
            
            if ( ByteRangeBuffer.QuerySize() < cRangeCount*sizeof(UL_BYTE_RANGE))
            {
                if (!ByteRangeBuffer.Resize( cRangeCount*sizeof(UL_BYTE_RANGE)))
                {
                    return ERROR_OUTOFMEMORY;
                }
            }

            PUL_BYTE_RANGE pRange = ((PUL_BYTE_RANGE) ByteRangeBuffer.QueryPtr() )
                                        + cRangeCount-1;

            pRange->StartingOffset.QuadPart = cbOffset;
            pRange->Length.QuadPart         = cbSizeToSend;
        }

    }
    while ( (!fEndOfRange ) && (pszRangeHeader <= pszEndOfHeader));


    if (fEntireFile)
    {
        cRangeCount = 0;
    }
    else
    {
        if (!cRangeCount)
        {
            //
            // Range request is not satisfiable
            //

            *pHttpStatus = HT_RANGE_NOT_SATISFIABLE;
            cRangeCount = 0;
            return NO_ERROR;
        }
        else
        {
            //
            // Range is satisfiable. Partial Content
            //
            
            *pHttpStatus = HT_PARTIAL;
        }
    }

    return NO_ERROR;

} // ProcessingRangeRequest

/********************************************************************++
--********************************************************************/

DWORD AToDW(
    LPCSTR *ppStr,
    LPCSTR pEnd,
    bool   *pfIsPresent
    )
/*++

  Routine Description:

    Convert ASCII to DWORD, set flag stating presence
    of a numeric value, update pointer to character stream

  Returns:
    DWORD value converted from ASCII

  Arguments:

    ppStr         PSTR to numeric value, updated on return
    pEnd          End of string pointed to by ppStr
    pfIsPresent   flag set to TRUE if numeric value present on return

  History:
    Phillich    08-Feb-1996 Created

--*/
{
    LPCSTR pStr = *ppStr;
    DWORD dwV = 0;

    if ( isdigit( *pStr ) )
    {
        int c;

        while ( (c = *pStr) && isdigit( c ) && (pStr <= pEnd))
        {
            dwV = dwV * 10 + c - '0';
            ++pStr;
        }

        *pfIsPresent = true;
        *ppStr = pStr;
    }
    else
    {
        *pfIsPresent = false;
    }

    return dwV;
}

/********************************************************************++
--********************************************************************/

ULONG
CheckDefaultLoad(
    LPCWSTR pwszDirPath
)
{  return NO_ERROR;}

/********************************************************************++
--********************************************************************/

/***************************** End of File ***************************/

            /*
            if (!fIsBeginningDefined)
            {
                dwBeginning = cbSizeLow + cbFooterLength - dwEnd;
                dwEnd       = cbSizeLow + cbFooterLength;
            }

            if (!fIsEndDefined)
            {
                dwEnd = cbSizeLow + cbFooterLength;
            }

            //
            // Check if the range is unsatisfiable
            //

            if ( ( dwBeginning > dwEnd) ||
                 ( dwBeginning > cbSizeLow + cbFooterLength) )
            {
                //
                // Syntactically Valid but Unsatisfiable range. Skip to the next range.
                //

                fUnsatisfiableByteRange  = true;
                continue;
            }

            //
            // If any part of the file falls within the footer, send the entire file
            //

            if ( ( (dwEnd > cbSizeLow) && (dwEnd < (cbSizeLow + QueryMetaData()->QueryFooterLength()) )) ||
                 (fIsBeginningDefined && (dwEnd < (cbSizeLow + QueryMetaData()->QueryFooterLength()) ))
            {
            }

        }
        else
        {
            //
            // Syntactically Invalid Range. Skip RANGE Header
            //

            fEntireFile = TRUE;
            break;

        }
            */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\processmap.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     ProcessMap.cxx

   Abstract:
     This file implements IIS Map File Processing

   Author:

       Saurab Nog    ( SaurabN )     29-Jan-1999

   Environment:
       Win32 - User Mode

   Project:
      IIS Worker Process (web service)

--*/

#include "precomp.hxx"

//
//  Maximum number of vertices in image map polygon
//

#define MAXVERTS    160

//
//  Point offset of x and y
//

#define X           0
#define Y           1

//
//  Computes the square of a number. Used for circle image maps
//

#define SQR(x)      ((x) * (x))

//
//  These are the characters that are considered to be white space
//

#define ISWHITEW( ch )      ((ch) == L'\t' || (ch) == L' ' || (ch) == L'\r')

#define ISWHITEA( ch )      ((ch) == '\t' || (ch) == ' ' || (ch) == '\r')

//
// Macros to Skip white and Non White characters
//

#define SKIPNONWHITE( pch ) while ( *(pch) && !ISWHITEA( *(pch) )) \
                            { (pch)++; }

#define SKIPWHITE( pch )    while( ISWHITEA( *(pch))    ||      \
                                   ( ')' == *(pch))     ||      \
                                   ( '(' == *(pch))             \
                                 )                              \
                            { (pch)++; }

/*
 * Mini HTML document for moved directories
 *
 *  %s is the URL of the new location of the object
*/

const CHAR g_szMovedMessage[] =
"<head><title>Document Moved</title></head>\n<body><h1>Object Moved</h1>This document may be found <a HREF=""%s"">here</a></body>";

//
// Private function prototypes
//

ULONG
SearchMapFile(
    LPCWSTR     pwszMapFileName,
    INT         x,
    INT         y,
    STRAU *     pstrURL,
    bool  *     pfFound,
    PULONG      pHttpStatus
    );

bool
PointInPoly(
    int point_x,
    int point_y,
    double pgon[MAXVERTS][2]
    );

INT
GetNumber( CHAR ** ppch );


/*******************************************************************

    NAME:       HTTP_REQUEST::ProcessISMAP

    SYNOPSIS:   Checks of the URL and passed parameters specify an
                image mapping file

    RETURNS:    Win32 Error

    NOTES:      gFile - Opened file Info
                pchFile - Fully qualified name of file
                pstrResp - Response to send if *pfHandled is FALSE
                pfFound - TRUE if a mapping was found
                pfHandled - Set to TRUE if no further processing is needed,
                    FALSE if pstrResp should be sent to the client

    HISTORY:
        Johnl       17-Sep-1994 Created

********************************************************************/

ULONG
ProcessISMAP(
    IWorkerRequest *    pReq,
    LPCWSTR             pwszMapFileName,
    BUFFER *            pulResponseBuffer,
    BUFFER *            pDataBuffer,
    PULONG              pHttpStatus
    )
{
    ULONG       x, y;
    PWSTR       pwszParams = (PWSTR) pReq->QueryQueryString(true);
    ULONG       rc = NO_ERROR;
    bool        fEntryFound= false;

    STRAU       strURL;

    //
    //  Get the x and y cooridinates of the mouse click on the image
    //

    x = wcstoul( pwszParams,
                 NULL,
                 10 );

    //
    //  Move past x and any intervening delimiters
    //

    while ( iswdigit( *pwszParams ))
    {
        pwszParams++;
    }

    while ( *pwszParams && !iswdigit( *pwszParams ))
    {
        pwszParams++;
    }

    y = wcstoul( pwszParams,
                 NULL,
                 10 );

    /*
    if ( !ImpersonateUser() )
    {
        return FALSE;
    }


    if ( !SearchMapFile( gFile,
                         pchFile,
                         &pInstance->GetTsvcCache(),
                         QueryImpersonationHandle(),
                         x,
                         y,
                         &strURL,
                         pfFound,
                         IsAnonymous()||IsClearTextPassword() ))
    {
        RevertUser();
        return FALSE;
    }

    RevertUser();
    */

    rc = SearchMapFile(  pwszMapFileName,
                         x,
                         y,
                         &strURL,
                         &fEntryFound,
                         pHttpStatus
                       );

    if (NO_ERROR != rc)
    {
        return rc;
    }

    if ( !fEntryFound )
    {
        PUL_HTTP_REQUEST    pHttpReq = pReq->QueryHttpRequest();

        if ( 0 < pHttpReq->Headers.pKnownHeaders[UlHeaderReferer].RawValueLength )
        {
            strURL.Copy(
                pHttpReq->Headers.pKnownHeaders[UlHeaderReferer].pRawValue,
                pHttpReq->Headers.pKnownHeaders[UlHeaderReferer].RawValueLength
             );
        }
        else
        {
            return NO_ERROR;
        }
    }

    //
    //  If the found URL starts with a forward slash ("/foo/bar/doc.htm")
    //  and it doesn't contain a bookmark ('#')
    //  then the URL is local and we build a fully qualified URL to send
    //  back to the client.
    //  we assume it's a fully qualified URL ("http://foo/bar/doc.htm")
    //  and send the client a redirection notice to the mapped URL
    //

    if ( *strURL.QueryStrA() == '/' )
    {
            CHAR    achPort[32];
            STRAU   strOldURL;

            //
            //  fully qualify the URL and send a redirect.  Some browsers
            //  (emosaic) don't like doc relative URLs with bookmarks
            //
            //  NOTE: We fully qualify the URL with the protocol (http or
            //  https) based on the port this request came in on.  This means
            //  you cannot have a partial URL with a bookmark (which is how
            //  we got here) go from a secure part of the server to a
            //  nonsecure part of the server.
            //

            if ( !strOldURL.Copy( strURL )                                      ||
                // BUGBUG !strURL.Copy( (pReq->IsSecurePort() ? "https://" : "http://" ))||
                 !strURL.Copy("http://")                                       ||
                 !strURL.Append( (LPSTR) pReq->QueryHostAddr(false))            ||
                 !strURL.Append( strOldURL )
                )
            {
                return ERROR_OUTOFMEMORY;
            }


            /*
            strURL.Append( ":" );

            _ultoa( pReq->QueryPort(), achPort, 10 );
            strURL.Append( achPort );
            */

    }

    rc = BuildURLMovedResponse( pulResponseBuffer,
                                pDataBuffer,
                                strURL );

    *pHttpStatus = HT_REDIRECT;

    return rc;
}

/*******************************************************************

    NAME:       SearchMapFile

    SYNOPSIS:   Searches the given mapfile for a shape that contains
                the passed cooridinates

    ENTRY:      gFile - Open file Info
                pchFile - Fully qualified path to file
                pTsvcCache - Cache ID
                hToken - Impersonation token
                x        - x cooridinate
                y        - y cooridinate
                pstrURL  - receives URL indicated in the map file
                pfFound  - Set to TRUE if a mapping was found
                fMayCacheAccessToken  - TRUE access token may be cached

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      This routine will attempt to cache the file.  You must call
                this function while impersonating the appropriate user

    HISTORY:
        Johnl       19-Sep-1994 Created

********************************************************************/

ULONG
SearchMapFile(
    LPCWSTR     pwszMapFileName,
    INT         x,
    INT         y,
    STRAU *     pstrURL,
    bool  *     pfFound,
    PULONG      pHttpStatus
    )
{
    HANDLE      hFile;
    DWORD       dwFileSize;
    DWORD       dwBytesRead;
    BUFFER      FileContents;
    CHAR *      pch;
    bool        fComment    = false;
    bool        fIsNCSA     = false;
    LPSTR       pszURL;                    // valid only if fIsNCSA is TRUE
    CHAR *      pchPoint    = NULL;
    UINT        dis, bdis   = (UINT) -1;
    CHAR *      pchDefault  = NULL;
    CHAR *      pchStart;
    DWORD       cchUrl;
    ULONG       rc = NO_ERROR;

    //
    // Open the file for use
    //

    hFile = ::CreateFile( pwszMapFileName,
                          GENERIC_READ,
                          FILE_SHARE_READ,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );

    if ( INVALID_HANDLE_VALUE == hFile)
    {
        rc = GetLastError();

        if ( ERROR_ACCESS_DENIED == rc )
        {
            *pHttpStatus = HT_DENIED;
        }

        if ( (ERROR_PATH_NOT_FOUND == rc) || (ERROR_FILE_NOT_FOUND == rc))
        {
            *pHttpStatus = HT_NOT_FOUND;
        }

        return rc;
    }

    //
    // Resize buffer to hold file contents
    //

    dwFileSize = GetFileSize( hFile, NULL);

    if (FileContents.QuerySize() < dwFileSize)
    {
        if ( ! FileContents.Resize(dwFileSize))
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    //
    // Read in the file contents into buffer
    //

    if ( ! ReadFile( hFile, FileContents.QueryPtr(), dwFileSize, &dwBytesRead, NULL))
    {
        return GetLastError();
    }

    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    //  Loop through the contents of the file and see what we've got
    //


    *pfFound = false;
    pch = (PCHAR) FileContents.QueryPtr();

    while ( *pch )
    {
        fIsNCSA = false;

        //
        //  note: _tolower doesn't check case (tolower does)
        //

        switch ( (*pch >= 'A' && *pch <= 'Z') ? _tolower( *pch ) : *pch )
        {
        case '#':
            fComment = true;
            break;

        case '\r':
        case '\n':
            fComment = false;
            break;

        //
        //  Rectangle and Oval.
        //
        //  BUGBUG handles oval as a rect, as they are using the same
        //  specification format. Should do better.

        case 'r':
        case 'o':

            if ( !fComment &&
                 ((0 == _strnicmp("rect", pch, 4 )) || ( 0 == _strnicmp("oval", pch, 4)))
               )
            {
                INT     x1, y1, x2, y2;

                SKIPNONWHITE( pch );
                pszURL =      pch;
                SKIPWHITE   ( pch );

                if ( !isdigit(*pch) && *pch!='(' )
                {
                    fIsNCSA     = true;
                    SKIPNONWHITE( pch );
                }

                x1 = GetNumber( &pch );
                y1 = GetNumber( &pch );
                x2 = GetNumber( &pch );
                y2 = GetNumber( &pch );

                if ( x >= x1 && x < x2 &&
                     y >= y1 && y < y2   )
                {
                    if ( fIsNCSA )
                    {
                        pch = pszURL;
                    }

                    goto Found;
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE   ( pch );
                    SKIPNONWHITE( pch );
                }

                continue;
            }
            break;

        //
        //  Circle
        //

        case 'c':

            if ( !fComment &&  ( 0 == _strnicmp( "circ", pch, 4 )) )
            {
                INT     xCenter, yCenter, xEdge, yEdge;
                INT     r1, r2;

                SKIPNONWHITE( pch );
                pszURL =      pch;
                SKIPWHITE   ( pch );

                if ( !isdigit(*pch) && *pch!='(' )
                {
                    fIsNCSA     = true;
                    SKIPNONWHITE( pch );
                }

                //
                //  Get the center and edge of the circle
                //

                xCenter = GetNumber( &pch );
                yCenter = GetNumber( &pch );

                xEdge = GetNumber( &pch );
                yEdge = GetNumber( &pch );

                //
                //  If there's a yEdge, then we have the NCSA format, otherwise
                //  we have the CERN format, which specifies a radius
                //

                if ( yEdge != -1 )
                {
                    r1 = ((yCenter - yEdge) * (yCenter - yEdge)) +
                         ((xCenter - xEdge) * (xCenter - xEdge));

                    r2 = ((yCenter - y) * (yCenter - y)) +
                         ((xCenter - x) * (xCenter - x));

                    if ( r2 <= r1 )
                    {
                        if ( fIsNCSA )
                        {
                            pch = pszURL;
                        }

                        goto Found;
                    }
                }
                else
                {
                    INT radius;

                    //
                    //  CERN format, third param is the radius
                    //

                    radius = xEdge;

                    if ( SQR( xCenter - x ) + SQR( yCenter - y ) <= SQR( radius ))
                    {
                        if ( fIsNCSA )
                        {
                            pch = pszURL;
                        }

                        goto Found;
                    }
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE   ( pch );
                    SKIPNONWHITE( pch );
                }
                continue;
            }
            break;

        //
        //  Polygon and Point
        //

        case 'p':

            if ( !fComment && ( 0 ==_strnicmp( "poly", pch, 4)) )
            {
                DWORD       i = 0;
                CHAR *      pchLast;
                bool        fOverflow = false;
                double      pgon[MAXVERTS][2];

                SKIPNONWHITE( pch );
                pszURL =      pch;
                SKIPWHITE   ( pch );

                if ( !isdigit(*pch) && (*pch != '(') )
                {
                    fIsNCSA     = true;
                    SKIPNONWHITE( pch );
                }

                //
                //  Build the array of points
                //

                while ( *pch && *pch != '\r' && *pch != '\n' )
                {
                    pgon[i][0] = GetNumber( &pch );

                    //
                    //  Did we hit the end of the line (and go past the URL)?
                    //

                    if ( pgon[i][0] != -1 )
                    {
                        pgon[i][1] = GetNumber( &pch );
                    }
                    else
                    {
                        break;
                    }

                    if ( i < MAXVERTS-1 )
                    {
                        i++;
                    }
                    else
                    {
                        fOverflow = true;
                    }
                }

                pgon[i][X] = -1;

                if ( !fOverflow && PointInPoly( x, y, pgon ))
                {
                    if ( fIsNCSA )
                    {
                        pch = pszURL;
                    }

                    goto Found;
                }

                //
                //  Skip the URL
                //

                if ( !fIsNCSA )
                {
                    SKIPWHITE   ( pch );
                    SKIPNONWHITE( pch );
                }

                continue;
            }
            else if ( !fComment && ( 0 == _strnicmp( "point", pch, 5)) )
            {
                INT     x1, y1;

                SKIPNONWHITE( pch );
                pszURL =      pch;
                SKIPWHITE   ( pch );
                SKIPNONWHITE( pch );

                x1 = GetNumber( &pch );
                y1 = GetNumber( &pch );

                x1 -= x;
                y1 -= y;
                dis = SQR(x1) + SQR(y1);

                if ( dis < bdis )
                {
                    pchPoint = pszURL;
                    bdis     = dis;
                }
            }
            break;

        //
        //  Default URL
        //

        case 'd':
            if ( !fComment && ( 0 == _strnicmp( "def", pch, 3 )) )
            {
                //
                //  Skip "default" (don't skip white space)
                //

                SKIPNONWHITE( pch );

                pchDefault =  pch;

                //
                //  Skip URL
                //

                SKIPWHITE   ( pch );
                SKIPNONWHITE( pch );

                continue;
            }
            break;
        }

        pch++;
        SKIPWHITE( pch );

    }   // while

    //
    //  If we didn't find a mapping and a default was specified, use
    //  the default URL
    //

    if ( pchPoint )
    {
        pch = pchPoint;
        goto Found;
    }

    if ( pchDefault )
    {
        pch = pchDefault;
        goto Found;
    }

    IF_DEBUG( PARSING )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[SearchMapFile] No mapping found for (%d,%d)\n",
                    x,
                    y ));
    }

    goto Exit;

Found:

    //
    //  pch should point to the white space immediately before the URL
    //

    SKIPWHITE   ( pch );
    pchStart =    pch;
    SKIPNONWHITE( pch );

    //
    //  Determine the length of the URL and copy it out
    //

    cchUrl = DIFF(pch - pchStart);

    if ( !pstrURL->Copy( pchStart, cchUrl + 1 ))
    {
        return ERROR_OUTOFMEMORY;
    }

    /*
    pstrURL->SetLen(cchUrl);

    if ( !pstrURL->Unescape() )
    {
        fRet = FALSE;
        goto Exit;
    }
    */

    IF_DEBUG( PARSING )
    {
        DBGPRINTF((DBG_CONTEXT,
                  "[SearchMapFile] Mapping for (%d,%d) is %s\n",
                   x,
                   y,
                   pstrURL->QueryStr() ));
    }

    *pfFound = true;

Exit:

    return rc;
}

/*******************************************************************
*******************************************************************/

bool
PointInPoly(
    int point_x,
    int point_y,
    double pgon[MAXVERTS][2]
    )
{
    int         i, numverts, xflag0;
    int         crossings;
    double      *p, *stop;
    double      tx, ty, y;

    for (i = 0; pgon[i][X] != -1 && i < MAXVERTS; i++);

    numverts    = i;
    crossings   = 0;

    tx  = (double) point_x;
    ty  = (double) point_y;
    y   = pgon[numverts - 1][Y];

    p   = (double *) pgon + 1;

    if ((y >= ty) != (*p >= ty))
    {
        if ((xflag0 = (pgon[numverts - 1][X] >= tx)) ==
            (*(double *) pgon >= tx))
        {
            if (xflag0)
            {
                crossings++;
            }
        }
        else
        {
            crossings += (pgon[numverts - 1][X] - (y - ty) *
                            (*(double *) pgon - pgon[numverts - 1][X]) /
                            (*p - y)) >= tx;
        }
    }

    stop = pgon[numverts];

    for (y = *p, p += 2; p < stop; y = *p, p += 2)
    {
        if (y >= ty)
        {
            while ((p < stop) && (*p >= ty))
            {
                p += 2;
            }

            if (p >= stop)
            {
                break;
            }

            if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
            {
                if (xflag0)
                {
                    crossings++;
                }
            }
            else
            {
                crossings += (*(p - 3) - (*(p - 2) - ty) *
                             (*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
            }
        }
        else
        {
            while ((p < stop) && (*p < ty))
            {
                p += 2;
            }

            if (p >= stop)
            {
                break;
            }

            if ((xflag0 = (*(p - 3) >= tx)) == (*(p - 1) >= tx))
            {
                if (xflag0)
                {
                    crossings++;
                }

            }
            else
            {
                crossings += (*(p - 3) - (*(p - 2) - ty) *
                             (*(p - 1) - *(p - 3)) / (*p - *(p - 2))) >= tx;
            }
        }
    }

    return (crossings & 0x01);
}

/*******************************************************************

    NAME:       GetNumber

    SYNOPSIS:   Scans for the beginning of a number and places the
                pointer after the found number


    ENTRY:      ppch - Place to begin.  Will be set to character after
                    the last digit of the found number

    RETURNS:    Integer value of found number (or -1 if not found)

    HISTORY:
        Johnl   19-Sep-1994 Created

********************************************************************/

INT
GetNumber( CHAR ** ppch )
{
    CHAR * pch = *ppch;
    INT    n;

    //
    //  Make sure we don't get into the URL
    //

    while ( *pch &&
            !isdigit( *pch ) &&
            !isalpha( *pch ) &&
            *pch != '/'      &&
            *pch != '\r'     &&
            *pch != '\n' )
    {
        pch++;
    }

    if ( !isdigit( *pch ) )
    {
        return -1;
    }

    n = atoi( pch );

    while ( isdigit( *pch ))
    {
        pch++;
    }

    *ppch = pch;

    return n;
}


/*******************************************************************

    NAME:       BuildURLMovedResponse

    SYNOPSIS:   Builds a full request indicating an object has moved to
                the location specified by URL. Uses HT_REDIRECT only.

    ENTRY:      pbufResp - String to receive built response
                pstrURL   - New location of object, gets escaped
                fIncludeParams - TRUE to include params from original request
                                 in redirect

    RETURNS:    TRUE if successful, FALSE on error

    NOTES:      This routine doesn't support sending a Unicode doc moved
                message

    HISTORY:
        Johnl       17-Sep-1994 Created

********************************************************************/

ULONG
BuildURLMovedResponse(
    BUFFER *    pulResponseBuffer,
    BUFFER *    pDataBuffer,
    STRAU&      strURL,
    bool        fIncludeParams,
    LPSTR       pszParams
    )
{
    DWORD               cbRequired;
    PUL_HTTP_RESPONSE_v1   pulResponse;
    PUL_DATA_CHUNK      pDataChunk;
    PCHAR               pCh;
    ULONG               rc = NO_ERROR;


    //
    //  Technically we should escape more characters then just the spaces but
    //  that would probably break some number of client apps
    //

    /*
    if ( !pstrURL->EscapeSpaces() )
    {
        return FALSE;
    }
    */

    if ( fIncludeParams &&  (NULL != pszParams) )
    {
        if ( !strURL.Append( "?" ) ||
             !strURL.Append( pszParams )
           )
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    cbRequired = 2* strURL.QueryCBA()       +
                sizeof(g_szMovedMessage)    +
                sizeof("Location: \r\n\r\n")    +
                10;                             // Slop

    //
    // Resize Data Buffer
    //

    if ( cbRequired > pDataBuffer->QuerySize() )
    {
        if ( !pDataBuffer->Resize(cbRequired ))
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    //
    // Resize UL Response Buffer. 3 Chunks - Status Code, Location, Body
    //

    if ( NO_ERROR != ( rc = ResizeResponseBuffer( pulResponseBuffer, 3)))
    {
        return rc;
    }

    //
    // Create UL Response.
    //

    pulResponse = (PUL_HTTP_RESPONSE_v1 ) (pulResponseBuffer->QueryPtr());

    pulResponse->Flags = UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH;
    pulResponse->HeaderChunkCount     = 2;
    pulResponse->EntityBodyChunkCount = 1;

    //
    // Build Chunks
    //

    pDataChunk = (PUL_DATA_CHUNK )(pulResponse + 1);

    //
    // First Header Chunk - Status Line
    //

    FillDataChunkWithStringItem( pDataChunk, STIRedirectResponseHeaders);

    //
    // Second Header Chunk - Location
    //

    pDataChunk++;

    pCh = (PCHAR) pDataBuffer->QueryPtr();

    memcpy( pCh , "Location: ", sizeof("Location: ")-1);
    pCh += sizeof("Location: ")-1;

    memcpy( pCh, strURL.QueryStrA(), strURL.QueryCBA());
    pCh += strURL.QueryCBA();

    memcpy( pCh , "\r\n\r\n", sizeof("\r\n\r\n")-1);
    pCh += sizeof("\r\n\r\n")-1;

    pDataChunk->DataChunkType           = UlDataChunkFromMemory;
    pDataChunk->FromMemory.pBuffer      = pDataBuffer->QueryPtr();
    pDataChunk->FromMemory.BufferLength = DIFF(pCh - (PCHAR)pDataBuffer->QueryPtr());

    //
    // First Data Chunk - Message Body
    //

    pDataChunk++;

    cbRequired = wsprintfA(pCh, g_szMovedMessage, strURL.QueryStrA());

    pDataChunk->DataChunkType           = UlDataChunkFromMemory;
    pDataChunk->FromMemory.pBuffer      = pCh;
    pDataChunk->FromMemory.BufferLength = cbRequired;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\responseheaders.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       ResponseHeaders.hxx
       
   Abstract:
       Declarations of strings and functions for accessing 
       the standard headers used in the response headers list.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     01-Dec-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


#ifndef _RESPONSE_HEADERS_HXX_
#define _RESPONSE_HEADERS_HXX_


/************************************************************++
 *     Extern definitions for strings
 --************************************************************/


enum STRING_TABLE_INDEX {
    STIMin,
    
    STITraceMessageHeadersHTML,
    STITraceMessageBodyStartHTML,
    STITraceMessageBodyEndHTML,

    STITraceMessageHeaders,
    STITraceMessageBodyStart,
    STITraceMessageBodyEnd,

    STIStandardResponseHeaders,
    STIStandardResponseHeadersEnd,

    STIDirectoryListingHeaders,

    STIRedirectResponseHeaders,
	
    STIMax
};


void FillDataChunkWithStringItem(
        IN PUL_DATA_CHUNK pdc, 
        IN STRING_TABLE_INDEX sti);


#endif // _RESPONSE_HEADERS_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\ulutil.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ulutil.cxx

Abstract:

    General utility functions shared by the various UL test apps.

Author:

    Keith Moore (keithmo)        19-Aug-1998

Revision History:
    Murali Krishnan (MuraliK)    18-Nov-1998   Modified for tracing

--*/


#include "precomp.hxx"

#define MAX_VERB_LENGTH     16
#define MAX_HEADER_LENGTH   256
#define MAX_URL_LENGTH      256

#define READ_STRING( localaddr, locallen, remoteaddr, remotelen )           \
    if( TRUE )                                                              \
    {                                                                       \
        ULONG _len;                                                         \
        RtlZeroMemory( (localaddr), (locallen) );                           \
        _len = min( (locallen), (remotelen) );                              \
        RtlCopyMemory(                                                      \
            (PVOID)(localaddr),                                             \
            (PVOID)(remoteaddr),                                            \
            _len                                                            \
            );                                                              \
    } else

inline
ULONG
COPY_STRING( 
    PVOID   localaddr, 
    ULONG   locallen, 
    PVOID   remoteaddr, 
    ULONG   remotelen )
{
    ULONG _len;                                                         
    _len = min( locallen, remotelen );                              
     RtlCopyMemory(                                                      
            (PVOID)(localaddr),                                             
            (PVOID)(remoteaddr),                                            
            _len                                                            
            );                                                              

     return _len;
}

DWORD
CalculateHeaderSize( IN PUL_HTTP_REQUEST pRequest);

VOID
DumpHttpRequest(
    IN PUL_HTTP_REQUEST pRequest
    )
{
#if 0
    PBYTE pRawRequest;
    ULONG i, cbLen;
    UCHAR verbBuffer[MAX_VERB_LENGTH];
    UCHAR headerBuffer[MAX_HEADER_LENGTH];
    UCHAR headerNameBuffer[MAX_HEADER_LENGTH];
    UCHAR urlBuffer[MAX_URL_LENGTH];
    UCHAR rawUrlBuffer[MAX_URL_LENGTH];

    PUL_KNOWN_HTTP_HEADER   pKnownHeader;
    PUL_UNKNOWN_HTTP_HEADER pUnknownHeader;

    pRawRequest = (PBYTE)pRequest;

    //
    // Read the raw verb, raw url, and url buffers.
    //

    if (pRequest->Verb == UlHttpVerbUnknown)
    {
        READ_STRING(
            verbBuffer,
            sizeof(verbBuffer),
            pRawRequest + pRequest->VerbOffset,
            pRequest->VerbLength
            );
    }
    else
    {
        verbBuffer[0] = '\0';
    }

    READ_STRING(
        rawUrlBuffer,
        sizeof(rawUrlBuffer),
        pRawRequest + pRequest->RawUrlOffset,
        pRequest->RawUrlLength
        );

    READ_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        pRawRequest + pRequest->UrlOffset,
        pRequest->UrlLength
        );

    //
    // Display the header.
    //

    wprintf(
        L"UL_HTTP_REQUEST:\n"
        L"    ConnectionId         = %08lx%08lx\n"
        L"    RequestId            = %08lx%08lx\n"
        L"    Verb                  = %hs\n",
        pRequest->ConnectionId,
        pRequest->RequestId,
        VerbToString( pRequest->Verb, cbLen)
        );

    wprintf(
        L"    VerbLength            = %lu\n"
        L"    VerbOffset            = %08lx (%hs)\n"
        L"    RawUrlLength          = %lu\n"
        L"    RawUrlOffset          = %08lx (%hs)\n"
        L"    UrlLength             = %lu\n"
        L"    UrlOffset             = %08lx (%hs)\n",
        pRequest->VerbLength,
        pRequest->VerbOffset,
        verbBuffer,
        pRequest->RawUrlLength,
        pRequest->RawUrlOffset,
        rawUrlBuffer,
        pRequest->UrlLength,
        pRequest->UrlOffset,
        urlBuffer
        );

    wprintf(
        L"    UnknownHeaderCount    = %lu\n"
        L"    UnknownHeaderOffset   = %08lx\n"
        L"    EntityBodyLength      = %lu\n"
        L"    EntityBodyOffset      = %08lx\n",
        pRequest->UnknownHeaderCount,
        pRequest->UnknownHeaderOffset,
        pRequest->EntityBodyLength,
        pRequest->EntityBodyOffset
        );

    //
    // Display the known headers.
    //

    pKnownHeader = &pRequest->KnownHeaders[0];

    for (i = 0 ; i < UlHeaderMaximum ; i++)
    {
        READ_STRING(
            headerBuffer,
            sizeof(headerBuffer),
            pRawRequest + pKnownHeader->ValueOffset,
            pKnownHeader->ValueLength
            );

        wprintf(
            L"    UL_KNOWN_HTTP_HEADER[%lu]:\n"
            L"        HeaderID          = %hs\n"
            L"        HeaderLength      = %lu\n"
            L"        HeaderOffset      = %08lx (%hs)\n",
            i,
            HeaderIdToString( (UL_HTTP_HEADER_ID)i, cbLen),
            pKnownHeader->ValueLength,
            pKnownHeader->ValueOffset,
            headerBuffer
            );

        pKnownHeader++;
    }

    //
    // Display the unknown headers.
    //

    pUnknownHeader =
        (PUL_UNKNOWN_HTTP_HEADER)( pRawRequest + pRequest->UnknownHeaderOffset );

    for (i = 0 ; i < pRequest->UnknownHeaderCount ; i++)
    {
        READ_STRING(
            headerNameBuffer,
            sizeof(headerNameBuffer),
            pRawRequest + pUnknownHeader->NameOffset,
            pUnknownHeader->NameLength
            );

        READ_STRING(
            headerBuffer,
            sizeof(headerBuffer),
            pRawRequest + pUnknownHeader->ValueOffset,
            pUnknownHeader->ValueLength
            );

        wprintf(
            L"    UL_UNKNOWN_HTTP_HEADER[%lu]:\n"
            L"        HeaderNameLength  = %lu\n"
            L"        HeaderNameOffset  = %08lx (%hs)\n"
            L"        HeaderLength      = %lu\n"
            L"        HeaderOffset      = %08lx (%hs)\n",
            i,
            pUnknownHeader->NameLength,
            pUnknownHeader->NameOffset,
            headerNameBuffer,
            pUnknownHeader->ValueLength,
            pUnknownHeader->ValueOffset,
            headerBuffer
            );

        pUnknownHeader++;
    }

    wprintf( L"\n" );

#endif // 0

    wprintf( L"DumpHttpRequest: NOT IMPLEMENTED\n");
    
}   // DumpHttpRequest




/*********************************************************************++
Routine Description:
  This function xlates the request object into HTML for rendering the same
   to the client.

Arguments:
  pRequest - pointer to the request object
  pBuffer  - pointer to buffer object into which the html dump is generated

Result:
  TRUE on success and FALSE if the space is not sufficient.

WARNING:
  There is a weak buffer size check performed.
  The input is expected to be sufficient enough for generating and
    dumping all the HTTP headers into it.
--*********************************************************************/
BOOL
DumpHttpRequestAsHtml(
    IN PUL_HTTP_REQUEST pRequest,
    OUT BUFFER * pBuffer
    )
{

#if 0
//
// Each header is generated as
//    <HeaderName>: <HeaderValue>\r\n
// hence there is at least a slop of 5 bytes required per header.
//

# define DUMP_HTML_SLOP_PER_HEADER     (20)

//
// minimum overhead for echoing headers
//

# define DUMP_HTML_MIN_SIZE            (100)

    PBYTE   pRawRequest;
    
    UCHAR   verbBuffer  [MAX_VERB_LENGTH];
    
    UCHAR   urlBuffer   [MAX_URL_LENGTH];
    UCHAR   rawUrlBuffer[MAX_URL_LENGTH];
    
    UCHAR   headerBuffer    [MAX_HEADER_LENGTH];
    UCHAR   headerNameBuffer[MAX_HEADER_LENGTH];
    ULONG   i, cbLen;

    PUL_KNOWN_HTTP_HEADER   pKnownHeader;
    PUL_UNKNOWN_HTTP_HEADER pUnknownHeader;

    //
    // I am probably better of using ostrstream for generating the output and
    //  then finally modifying this for the buffer.
    // For now this path is ignored.
    //

    pRawRequest = (PBYTE)pRequest;

    if ((pRequest == NULL) || (pBuffer == NULL)) {
        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }

    //
    // Calculate the required size for buffer
    //
    DWORD nHeaders = pRequest->UnknownHeaderCount + (DWORD)UlHeaderMaximum;
    DWORD cbMinHeadersSize = CalculateHeaderSize( pRequest);

    cbMinHeadersSize += (nHeaders * DUMP_HTML_SLOP_PER_HEADER) + DUMP_HTML_MIN_SIZE;

    if ( (pBuffer->QuerySize() < cbMinHeadersSize) ) {
        if (!pBuffer->Resize( pBuffer->QuerySize() + cbMinHeadersSize)) {
            return (FALSE);
        }
    }
    LPSTR pszBuffer = static_cast<LPSTR> (pBuffer->QueryPtr());

    // NYI: I am not checking for the size of the buffer beyond this point

    //
    // Read the raw verb, raw url, and url buffers.
    //

    if (pRequest->Verb == UlHttpVerbUnknown)
    {
        READ_STRING(
            verbBuffer,
            sizeof(verbBuffer),
            pRawRequest + pRequest->VerbOffset,
            pRequest->VerbLength
            );
    }
    else
    {
        verbBuffer[0] = '\0';
    }

    READ_STRING(
        rawUrlBuffer,
        sizeof(rawUrlBuffer),
        pRawRequest + pRequest->RawUrlOffset,
        pRequest->RawUrlLength
        );

    READ_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        pRawRequest + pRequest->UrlOffset,
        pRequest->UrlLength
        );

    //
    // Display the header.
    //

    DWORD cbBody;

    cbBody = wsprintfA( pszBuffer,
                        "UL_HTTP_REQUEST:<br>\n"
                        "    ConnectionId          = %08lx%08lx<br>\n"
                        "    ReceiveId             = %08lx%08lx<br>\n"
                        "    Verb                  = %s<br>\n"
                        ,
                        pRequest->ConnectionId,
                        pRequest->RequestId,
                        VerbToString( pRequest->Verb, cbLen )
                            );

    cbBody += wsprintfA( pszBuffer + cbBody,
                         "    Verb                  = %s(%lu)<br>\n"
                         "    RawUrl                = %s(%lu)<br>\n"
                         "    Url                   = %s(%lu)<br>\n"
                         ,
                         verbBuffer,
                         pRequest->VerbLength,
                         rawUrlBuffer,
                         pRequest->RawUrlLength,
                         urlBuffer,
                         pRequest->UrlLength
                         );

    cbBody += wsprintfA( pszBuffer + cbBody,
                         "    UnknownHeaderCount    = %lu<br>\n"
                         "    EntityBodyLength      = %lu<br>\n"
                         ,
                         pRequest->UnknownHeaderCount,
                         pRequest->EntityBodyLength
                         );

    //
    // Display the known headers.
    //

    pKnownHeader = &pRequest->KnownHeaders[0];

    for (i = 0 ; i < UlHeaderMaximum ; i++)
    {
        READ_STRING(
            headerBuffer,
            sizeof(headerBuffer),
            pRawRequest + pKnownHeader->ValueOffset,
            pKnownHeader->ValueLength
            );

        cbBody += wsprintfA(pszBuffer + cbBody,
                            "    UL_HTTP_HEADER[%lu]:<br>\n"
                            "    %20s= %s(%lu)<br>\n"
                            ,
                            i,
                            HeaderIdToString( (UL_HTTP_HEADER_ID)i, cbLen ),
                            headerBuffer,
                            pKnownHeader->ValueLength
                            );

        pKnownHeader++;
    }

    //
    // Display the unknown headers.
    //

    pUnknownHeader =
        (PUL_UNKNOWN_HTTP_HEADER)( pRawRequest +
                                   pRequest->UnknownHeaderOffset );

    for (i = 0 ; i < pRequest->UnknownHeaderCount ; i++)
    {
        READ_STRING(
            headerNameBuffer,
            sizeof(headerNameBuffer),
            pRawRequest + pUnknownHeader->NameOffset,
            pUnknownHeader->NameLength
            );

        READ_STRING(
            headerBuffer,
            sizeof(headerBuffer),
            pRawRequest + pUnknownHeader->ValueOffset,
            pUnknownHeader->ValueLength
            );

        cbBody += wsprintfA( pszBuffer + cbBody,
                             "    UL_UNKNOWN_HTTP_HEADER[%lu]:<br>\n"
                             "    %20s(%lu)=%20s(%lu)<br>\n"
                             ,
                             i,
                             headerNameBuffer,
                             pUnknownHeader->NameLength,
                             headerBuffer,
                             pUnknownHeader->ValueLength
                             );

        pUnknownHeader++;
    }

    cbBody += wsprintfA( pszBuffer + cbBody, "<br>\n");

#endif // 0

    wprintf( L"DumpHttpRequestAsHtml: NOT IMPLEMENTED\n");

    return (TRUE);
}   // DumpHttpRequestAsHtml()

/*********************************************************************++
--*********************************************************************/

inline
ULONG
BuildRequestLine(
    LPSTR   pszBuffer,
    ULONG   cbBufferSize,
    LPSTR   pszVerb,
    ULONG   cbVerbLen,
    LPSTR   pchURL,
    ULONG   cbURLLen
    )
{
    ULONG   cbRemainingSize, cbLen;

    //
    // Verb
    //

    cbRemainingSize = cbBufferSize;
    
    cbLen = COPY_STRING(
                    pszBuffer,
                    cbRemainingSize,
                    pszVerb,
                    cbVerbLen
                    );

    pszBuffer    += cbLen;
    *(pszBuffer)  = ' ';
    pszBuffer++;
    cbRemainingSize -= cbLen+1;

    //
    // RawURL
    //
    
    cbLen = COPY_STRING(
                     pszBuffer,
                     cbRemainingSize,
                     pchURL,
                     cbURLLen
                     );

    pszBuffer    += cbLen;
    *(pszBuffer)  = ' ';
    pszBuffer++;

    cbRemainingSize -= cbLen+1;

    //
    // Protocol Version
    //

    cbLen = COPY_STRING(
                     pszBuffer,
                     cbRemainingSize,
                     "HTTP/1.1\r\n",
                     sizeof("HTTP/1.1\r\n")-1
                     );

    return (cbBufferSize - cbRemainingSize + cbLen);
}

/*********************************************************************++
--*********************************************************************/

inline
ULONG
BuildHeader(
    LPSTR   pszBuffer,
    ULONG   cbBufferSize,
    LPSTR   pszHeaderName,
    ULONG   cbHeaderNameLen,
    LPSTR   pchHeaderValue,
    ULONG   cbHeaderValueLen
    )
{
    ULONG   cbRemainingSize, cbLen;

    cbRemainingSize = cbBufferSize;

    //
    // Header Name
    //
    
    cbLen = COPY_STRING(
                    pszBuffer,
                    cbRemainingSize,
                    pszHeaderName,
                    cbHeaderNameLen
                    );
                            
    pszBuffer       += cbLen;

    //
    // : 
    //
    
    *(pszBuffer)    = ':';
    *(pszBuffer+1)  = ' ';

    pszBuffer       += 2;
    cbRemainingSize -= cbLen +2;

    //
    // Header Value
    //
    
    cbLen = COPY_STRING(
                    pszBuffer,
                    cbRemainingSize,
                    pchHeaderValue,
                    cbHeaderValueLen
                    );

    pszBuffer       += cbLen;
    *(pszBuffer)    = '\r';
    *(pszBuffer+1)  = '\n';

    return (cbBufferSize - cbRemainingSize + cbLen + 2);
 }           

/*********************************************************************++
Routine Description:
  This function xlates the request object into textual format for
  transmission to the client. This code may also be used for the
  ISAPI Read-Raw filters

Arguments:
  pRequest - pointer to the request object
  pBuffer  - pointer to buffer object into which the html dump is generated

Result:
  Win32 Error.

WARNING:
  There is a weak buffer size check performed.
--*********************************************************************/

ULONG
BuildEchoOfHttpRequest(
    IN  PUL_HTTP_REQUEST    pRequest,
    OUT BUFFER            * pBuffer,
    OUT ULONG&              cbOutputLen
    )
{
#if 0
    LPSTR                   pRawRequest, pszBuffer, pStr;
    PUL_KNOWN_HTTP_HEADER   pKnownHeader;
    PUL_UNKNOWN_HTTP_HEADER pUnknownHeader;
    DWORD                   cbTotalSize, cbRemainingSize;
    DWORD                   cbLen, i;

    if ((pRequest == NULL) || (pBuffer == NULL)) 
    {
        return ( ERROR_INVALID_PARAMETER);
    }


    pRawRequest = (LPSTR)pRequest;

    //
    // Calculate the required size for buffer
    //
    
    cbTotalSize = CalculateHeaderSize( pRequest) +1 ;

    //
    // Check and adjust the buffer as needed
    //
    if ( (pBuffer->QuerySize() < cbTotalSize) ) 
    {
        if (!pBuffer->Resize( cbTotalSize)) 
        {
            return (ERROR_OUTOFMEMORY);
        }
    }

    pszBuffer = static_cast<LPSTR> (pBuffer->QueryPtr());
    cbRemainingSize = cbTotalSize;

    //
    // I am not checking for the size of the buffer beyond this point
    //
    // first line of request:
    //  <Verb> <RawURL> <Protocol/Version>
    //

    if (pRequest->Verb == UlHttpVerbUnknown)
    {
        pStr    = pRawRequest + pRequest->VerbOffset;
        cbLen   = pRequest->VerbLength;
    }
    else
    {
        pStr   = VerbToString( pRequest->Verb, cbLen);   
    }


    cbLen = BuildRequestLine(
                    pszBuffer,
                    cbRemainingSize,
                    pStr,
                    cbLen,
                    pRawRequest + pRequest->RawUrlOffset,
                    pRequest->RawUrlLength
                    );                    
    
    
    pszBuffer       += cbLen;
    cbRemainingSize -= cbLen;

    //
    // Echo the known headers.
    //

    pKnownHeader = pRequest->KnownHeaders;

    for (i = 0 ; i < UlHeaderMaximum ; i++)
    {
        if (0 != pKnownHeader->ValueLength)
        {
            pStr  = HeaderIdToString( (UL_HTTP_HEADER_ID)i , cbLen);

            cbLen = BuildHeader(
                            pszBuffer,
                            cbRemainingSize,
                            pStr,
                            cbLen,
                            pRawRequest + pKnownHeader->ValueOffset,
                            pKnownHeader->ValueLength
                            );     

            pszBuffer       += cbLen;
            cbRemainingSize -= cbLen;
        } 
        
        pKnownHeader++;
    }

    //
    // Echo the unknown headers.
    //

    pUnknownHeader =
        (PUL_UNKNOWN_HTTP_HEADER)( pRawRequest +
                                   pRequest->UnknownHeaderOffset );

    for (i = 0 ; i < pRequest->UnknownHeaderCount ; i++)
    {
        cbLen = BuildHeader(
                        pszBuffer,
                        cbRemainingSize,
                        pRawRequest + pUnknownHeader->NameOffset,
                        pUnknownHeader->NameLength,
                        pRawRequest + pUnknownHeader->ValueOffset,
                        pUnknownHeader->ValueLength
                        );        

        pszBuffer       += cbLen;
        cbRemainingSize -= cbLen;

        pUnknownHeader++;
    }

    DBG_ASSERT( cbRemainingSize >= 0);

    *pszBuffer  = '\0';
    cbOutputLen = cbTotalSize - cbRemainingSize;
#endif
    return (NO_ERROR);
    
}   // BuildEchoOfHttpRequest()


#define SetStringAndLength( result, cbLen, cString)     \
    {                                                   \
        (result) = (cString);                           \
        (cbLen) = sizeof(cString)-1;                    \
    }                           

PSTR
VerbToString(
    IN  UL_HTTP_VERB    Verb,
    OUT ULONG&          VerbLength
    )
{
    PSTR result;

    switch (Verb)
    {
    case UlHttpVerbUnparsed:
        SetStringAndLength( result, VerbLength, "UnparsedVerb");
        break;

    case UlHttpVerbGET:
        SetStringAndLength( result, VerbLength, "GET");
        break;

    case UlHttpVerbPUT:
        SetStringAndLength( result, VerbLength, "PUT");
        break;

    case UlHttpVerbHEAD:
        SetStringAndLength( result, VerbLength, "HEAD");
        break;

    case UlHttpVerbPOST:
        SetStringAndLength( result, VerbLength, "POST");
        break;

    case UlHttpVerbDELETE:
        SetStringAndLength( result, VerbLength, "DELETE");
        break;

    case UlHttpVerbTRACE:
        SetStringAndLength( result, VerbLength, "TRACE");
        break;

    case UlHttpVerbOPTIONS:
        SetStringAndLength( result, VerbLength, "OPTIONS");
        break;

    case UlHttpVerbMOVE:
        SetStringAndLength( result, VerbLength, "MOVE");
        break;

    case UlHttpVerbCOPY:
        SetStringAndLength( result, VerbLength, "COPY");
        break;

    case UlHttpVerbPROPFIND:
        SetStringAndLength( result, VerbLength, "PROPFIND");
        break;

    case UlHttpVerbPROPPATCH:
        SetStringAndLength( result, VerbLength, "PROPPATCH");
        break;

    case UlHttpVerbMKCOL:
        SetStringAndLength( result, VerbLength, "MKCOL");
        break;

    case UlHttpVerbLOCK:
        SetStringAndLength( result, VerbLength, "LOCK");
        break;

    case UlHttpVerbUnknown:
        SetStringAndLength( result, VerbLength, "UnknownVerb");
        break;

    case UlHttpVerbInvalid:
        SetStringAndLength( result, VerbLength, "InvalidVerb");
        break;

    default:
        SetStringAndLength( result, VerbLength, "INVALID");
        break;
    }

    return result;

}   // VerbToString


PSTR
HeaderIdToString(
    IN  UL_HTTP_HEADER_ID HeaderId,
    OUT ULONG&            HeaderNameLength
    )
{
    PSTR result;

    switch (HeaderId)
    {
    case UlHeaderAccept:
        SetStringAndLength( result, HeaderNameLength, "Accept");
        break;

    case UlHeaderAcceptEncoding:
        SetStringAndLength( result, HeaderNameLength, "AcceptEncoding");
        break;

    case UlHeaderAuthorization:
        SetStringAndLength( result, HeaderNameLength, "Authorization");
        break;

    case UlHeaderAcceptLanguage:
        SetStringAndLength( result, HeaderNameLength, "AcceptLanguage");
        break;

    case UlHeaderConnection:
        SetStringAndLength( result, HeaderNameLength, "Connection");
        break;

    case UlHeaderCookie:
        SetStringAndLength( result, HeaderNameLength, "Cookie");
        break;

    case UlHeaderContentLength:
        SetStringAndLength( result, HeaderNameLength, "ContentLength");
        break;

    case UlHeaderContentType:
        SetStringAndLength( result, HeaderNameLength, "ContentType");
        break;

    case UlHeaderExpect:
        SetStringAndLength( result, HeaderNameLength, "Expect");
        break;

    case UlHeaderHost:
        SetStringAndLength( result, HeaderNameLength, "Host");
        break;

    case UlHeaderIfModifiedSince:
        SetStringAndLength( result, HeaderNameLength, "IfModifiedSince");
        break;

    case UlHeaderIfNoneMatch:
        SetStringAndLength( result, HeaderNameLength, "IfNoneMatch");
        break;

    case UlHeaderIfMatch:
        SetStringAndLength( result, HeaderNameLength, "IfMatch");
        break;

    case UlHeaderIfUnmodifiedSince:
        SetStringAndLength( result, HeaderNameLength, "IfUnmodifiedSince");
        break;

    case UlHeaderIfRange:
        SetStringAndLength( result, HeaderNameLength, "IfRange");
        break;

    case UlHeaderPragma:
        SetStringAndLength( result, HeaderNameLength, "Pragma");
        break;

    case UlHeaderReferer:
        SetStringAndLength( result, HeaderNameLength, "Referer");
        break;

    case UlHeaderRange:
        SetStringAndLength( result, HeaderNameLength, "Range");
        break;

    case UlHeaderUserAgent:
        SetStringAndLength( result, HeaderNameLength, "UserAgent");
        break;

    default:
        SetStringAndLength( result, HeaderNameLength, "INVALID");
        break;
    }

    return result;

}   // HeaderIdToString


DWORD
CalculateHeaderSize( IN PUL_HTTP_REQUEST pRequest)
{
#if 0
    //
    // Each header is generated as
    //    <HeaderName>: <HeaderValue>\r\n
    // hence there is at least a slop of 5 bytes required per header.
    //

    # define TRACE_SLOP_PER_HEADER     (5)

    DWORD cbHeaders = 0;
    DWORD i, cbLen;

    //
    // calculate the length for the first header line
    //
    if ( pRequest->Verb  == UlHttpVerbUnknown)
    {
        cbHeaders += pRequest->VerbLength + 1;
    } 
    else
    {
        VerbToString( pRequest->Verb, cbLen);
        cbHeaders += cbLen + 1;
    }

    cbHeaders += pRequest->RawUrlLength+1;

    cbHeaders += 10; // for protocol version string & \r\n

    //
    // calculate the length for known headers
    //

    PUL_KNOWN_HTTP_HEADER pKnownHeader = &pRequest->KnownHeaders[0];

    for (i = 0 ; i < (DWORD)UlHeaderMaximum ; i++)
    {
        if (0 != pKnownHeader->ValueLength)
        {
            HeaderIdToString( (UL_HTTP_HEADER_ID)i, cbLen);
            
            cbHeaders += cbLen + 
                         pKnownHeader->ValueLength + 
                         TRACE_SLOP_PER_HEADER;
        }

        pKnownHeader++;
    }

    //
    // Calculate the length for unknown headers
    //

    PUL_UNKNOWN_HTTP_HEADER
    pUnknownHeader =
        (PUL_UNKNOWN_HTTP_HEADER)( ((BYTE * ) pRequest) + pRequest->UnknownHeaderOffset );

    for (i = 0 ; i < pRequest->UnknownHeaderCount ; i++)
    {
        cbHeaders +=   pUnknownHeader->NameLength +
                       pUnknownHeader->ValueLength +
                       TRACE_SLOP_PER_HEADER;
                       
        pUnknownHeader++;
    }

    return (cbHeaders);
#endif

    return 0;
    
} // CalculateHeaderSize()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

# define    DEBUG_UL_CALLS             0x00010000
# define    DEBUG_PROCESS_REQUEST      0x00020000
# define    DEBUG_WORKER_REQUEST       0x00040000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\uridata\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     03-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

//
//  Configuration parameters registry key.
//

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszIisRtlRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\IISMURID";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("iismurid");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        // LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszIisRtlRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, "IISMURID::DllMain::DLL_PROCESS_ATTACH\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "IISMURID::DllMain::DLL_PROCESS_DETACH\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\staticprocessingmodule.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
    StaticProcessingModule.cxx

   Abstract:
     Implements the IIS Static Processing Module
 
   Author:

       Saurab Nog    ( SaurabN )     10-Feb-1999

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

#include "precomp.hxx"

typedef 
ULONG (* PMFN_VERB)( IWorkerRequest * pReq, 
                     BUFFER         * pulResponseBuffer, 
                     BUFFER         * pDataBuffer,
                     PULONG           pHttpStatus
                    );

/********************************************************************++
//
// Following table gives a list of verbs sent to us from UL
//  and the pointer to functions that handle the verb.
// The listing corresponds to the listing in uldef.h
// We store the verb as well for sanity checks to protect ourselves
//  from accidental changes in UL Headers
//
// NOTE: Changes in Uldef listing need to be reflected here as well.
//
// NYI: For now several items list the DoDefaultVerb() as the handler.
// These will be incrementally fixed as more code is added.
//
--********************************************************************/

struct VERB_PROCESSOR
{
    UL_HTTP_VERB  httpVerb;
    PMFN_VERB  pmfnVerbProcessor;
}
    g_rgVerbProcessors[] =
    {
        { UlHttpVerbUnparsed,     &DoDefaultVerb },
        { UlHttpVerbGET,          &DoGETVerb     },
        { UlHttpVerbPUT,          &DoDefaultVerb },
        { UlHttpVerbHEAD,         &DoGETVerb     },
        { UlHttpVerbPOST,         &DoDefaultVerb },
        { UlHttpVerbDELETE,       &DoDefaultVerb },
        { UlHttpVerbTRACE,        &DoTRACEVerb   },
        { UlHttpVerbOPTIONS,      &DoDefaultVerb },
        { UlHttpVerbMOVE,         &DoDefaultVerb },
        { UlHttpVerbCOPY,         &DoDefaultVerb },
        { UlHttpVerbPROPFIND,     &DoDefaultVerb },
        { UlHttpVerbPROPPATCH,    &DoDefaultVerb },
        { UlHttpVerbMKCOL,        &DoDefaultVerb },
        { UlHttpVerbLOCK,         &DoDefaultVerb },
        { UlHttpVerbUnknown,      &DoDefaultVerb },
        { UlHttpVerbInvalid,      &DoDefaultVerb },
    };

/********************************************************************++
--********************************************************************/

inline 
PMFN_VERB 
FindVerbProcessor(
    IN UL_HTTP_VERB httpVerb
    )
{
    DBG_ASSERT( (httpVerb >=0) && (httpVerb < UlHttpVerbInvalid));
    DBG_ASSERT( httpVerb == g_rgVerbProcessors[httpVerb].httpVerb);
    return  g_rgVerbProcessors[httpVerb].pmfnVerbProcessor;
}

/********************************************************************++
--********************************************************************/

CStaticProcessingModule::CStaticProcessingModule() 
    : 
    m_fInUse        ( false),
    m_buffUlResponse( sizeof(UL_HTTP_RESPONSE_v1) + 2*sizeof(UL_DATA_CHUNK))
{
}

/********************************************************************++

Routine Description:
  This function is the switch board for processing the current request.

Arguments:
  pReq - pointer to the conatining worker request.

Returns:
   MODULE RETURN CODES.

   If there is an error, this function sends out error message to the
   client and derferences the object preparing for cleanup.

--********************************************************************/

MODULE_RETURN_CODE 
CStaticProcessingModule::ProcessRequest(
    IWorkerRequest * pReq
    )
{
    ULONG               rc      =   NO_ERROR;
    MODULE_RETURN_CODE  mrc     =   MRC_ERROR;
    ULONG               httprc  =   HT_OK;
    
    PUL_HTTP_REQUEST pulRequest = pReq->QueryHttpRequest();

    if (m_fInUse)
    {
        //
        // This is the IO Completion coming back. No more processing.
        //

        m_fInUse = false;
        
        return MRC_OK;
    }

    //
    // Find the associated verb and dispatch processing to that particular verb handler.
    //
    
    DBG_ASSERT( pulRequest->Verb < UlHttpVerbInvalid);

    PMFN_VERB pfnVerb = FindVerbProcessor(pulRequest->Verb);

    //
    // Dispatch to the appropriate verb handler to complete processing of request.
    //
    
    rc = (*pfnVerb)(pReq, QueryResponseBuffer(), QueryDataBuffer(), &httprc);

    //
    // Check if we encountered any Win32 or HTTP Error
    //

    if ( ( NO_ERROR == rc) &&  ( HT_BAD_REQUEST >= httprc) )
    {

        //
        // Successful Response
        //
            
        PUL_HTTP_RESPONSE_v1 pulResponse = (PUL_HTTP_RESPONSE_v1)
                                        QueryResponseBuffer()->QueryPtr();
        //
        // Extra processing for HEAD
        //

        if ( UlHttpVerbHEAD == pulRequest->Verb)
        {
            //
            // Compute Content Length for the body & Add that as a header.
            //

            //
            // BUG: Compute content length.
            //
            
            pulResponse->EntityBodyChunkCount = 0;
        }
            
        // 
        // Send out response to client
        //

        m_fInUse = true;

        rc = pReq->SendAsyncResponse( pulResponse );

        IF_DEBUG( TRACE)
        {
            DBGPRINTF(( DBG_CONTEXT, "SendAsyncResponse returned: %d\n", rc));
        }

        if (NO_ERROR == rc)
        {            
            mrc = MRC_PENDING;
        }
        else
        {
            m_fInUse = false;
            mrc = MRC_ERROR;
        }
    }
    else
    {
        //
        // Protocol Processing Error
        //

        if ( HT_OK == httprc)
        {
            //
            // No Protocol error specified. Convert to Server Error
            //

            httprc = HT_SERVER_ERROR;
        }
        
        mrc = MRC_ERROR;
    }

    pReq->SetLogStatus(httprc, rc);
    
    return mrc;
}

/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\apppool.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     AppPool.cxx

   Abstract:
     Defines the functions used to access the data channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Oct-1998

   Project:

       IIS Worker Process

--*/

/*********************************************************
 * Include Headers
 *********************************************************/

# include "precomp.hxx"
# include "AppPool.hxx"

/*********************************************************
 * Member Functions of UL_APP_POOL
 *********************************************************/

UL_APP_POOL::UL_APP_POOL()
: m_hAppPool( NULL)
{
    IF_DEBUG( INIT_CLEAN) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Created UL_APP_POOL=>%08x\n", this));
    }
}

/********************************************************************++
++********************************************************************/

UL_APP_POOL::~UL_APP_POOL()
{
    Cleanup();

    IF_DEBUG( INIT_CLEAN) 
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Destroyed UL_APP_POOL=>%08x\n", 
                    this));
    }
}

/********************************************************************++
++********************************************************************/
/*++
  UL_APP_POOL::Initialize()

  Description:
    This function creates a new data channel for the specified namespace
    group object. The UL will then queue up the requests for the namespace
    group to this data channel.

  Arguments:
    pszNSGO  - pointer to NameSpace Group object
--*/

ULONG
UL_APP_POOL::Initialize( IN LPCWSTR pwszAppPoolName)
{
    ULONG   rc;

    if ( m_hAppPool != NULL) 
    {
        //
        // There is already an App Pool channel established
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of data channel\n"));
        return ERROR_DUP_NAME;
    }

    rc = UlOpenAppPool( &m_hAppPool,
                        pwszAppPoolName,               
                        UL_OPTION_OVERLAPPED  // ASync handle
                      );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "Failed to open AppPool '%ws': rc = 0x%0x8\n", 
                        pwszAppPoolName, rc));
        }
    }

    return (rc);
    
} // UL_APP_POOL::Initialize()

/********************************************************************++
++********************************************************************/

/*++
  UL_APP_POOL::Cleanup()

  Description:
    Closes the data channel and rests all the data inside Data channel

  Arguments:
    None

  Returns:
    Win32 error
--*/

ULONG 
UL_APP_POOL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

#ifdef UL_SIMULATOR_ENABLED
    UlsimCleanupDataChannel( m_hAppPool);
    m_hAppPool = NULL;
#else
    
    if ( m_hAppPool != NULL) 
    {
        if (!::CloseHandle( m_hAppPool)) 
        {
            rc = GetLastError();
            
            IF_DEBUG( ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                    "Unable to cleanup Data Channel handle (%08x)\n",
                    m_hAppPool
                    ));
            }
        } 
        else 
        {
            m_hAppPool = NULL;
        }
    }
#endif
    
    return (rc);

} // UL_APP_POOL::Cleanup()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\cport.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     cport.cxx

   Abstract:
     Defines the routines for completion port module.

     COMPLETION_PORT is an abstraction for the NT completion port.
     It allows one to queue up async I/O operations. On completion
     of the IO, we will be notified. We maintain a pool of threads
     waiting on the completion port. An operation posted to the 
     completion port will release a thread for execution. The released
     thread will take appropriate action, or indicate the completion
     to the handler queueing the request, and finally will come back
     to wait on the queue.

     We define two data structures for this purpose:
     1)  COMPLETION_PORT - encapsulates the completion port & thread pool
     2)  CP_CONTEXT  - COMPLETION PORT context that defines the interface
                          for items queued to the completion port.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     29-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/*********************************************************
 * Include Headers
 *********************************************************/

# include "precomp.hxx"


/*********************************************************
 * Define Configuration Constants
 *********************************************************/

//
// Min and max threads to maintain in the completion port
//
const int MIN_THREADS         = 1;
const int MAX_THREADS_DEFAULT = 128;



/*********************************************************
 * Member Functions of COMPLETION_PORT
 *********************************************************/

COMPLETION_PORT::COMPLETION_PORT()
    : m_hCompletionPort( NULL),
      m_nThreadsCurr (0),
      m_nThreadsMax  (MAX_THREADS_DEFAULT),
      m_fShutdown    (TRUE), // start off with TRUE so that proper shutdown happens
      m_fLastThreadDone ( FALSE)
{

    IF_DEBUG( INIT_CLEAN) {
       DBGPRINTF(( DBG_CONTEXT, "COMPLETION_PORT(%08x) created \n", this));
    }

} // COMPLETION_PORT::COMPLETION_PORT


COMPLETION_PORT::~COMPLETION_PORT()
{
    //
    // Wait for and synchronize all resources -> do cleanup
    //
    
    HRESULT hr = Cleanup();

    DBG_ASSERT( SUCCEEDED( hr));

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "COMPLETION_PORT(%08x) deleted\n", this));
    }

} // COMPLETION_PORT::~COMPLETION_PORT()


/*++
  COMPLETION_PORT::Initialize()

  o  Initializes the completion port data structure for handling IO operations.
  This fucntion creates the completion port, 
  and starts up an initial pool of threads for handling completions.

  Arguments:
    nThreadsMax - max. number of threads allowed for this completion port's pool

  Return:
    ULONG - Win32 error codes.

--*/

ULONG 
COMPLETION_PORT::Initialize(
    IN DWORD nThreadsInitial,
    IN DWORD nThreadsMax
    )
{
    ULONG rc = NO_ERROR;

    //
    // Check to see if the completion port is already there.
    // Fail creation if completion port already exists.
    //
    if ( m_hCompletionPort != NULL) 
    {
        
        IF_DEBUG( ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Duplicate creation of completion port\n"));
        }
        
        return ERROR_DUP_NAME;
    }


    //
    // Validate the number of threads for the completion port
    //
    if (nThreadsMax < MIN_THREADS) {

        IF_DEBUG( ERROR) 
        { 
            DBGPRINTF(( DBG_CONTEXT, "Less number of threads specified\n"));
        }
        return ERROR_INVALID_PARAMETER;
    }


    //
    // Create the IO completion port
    //
    m_hCompletionPort = CreateIoCompletionPort( 
                            INVALID_HANDLE_VALUE,
                            m_hCompletionPort,
                            NULL,                   // no context for main handle
                            0                       // concurency
                            );

    if ( !m_hCompletionPort) 
    {
        IF_DEBUG( ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, "CreateIoCompletionPort() failed. Error=%d\n",
                        GetLastError()));
        }
        return GetLastError();
    }

    //
    // Setup the data structure members
    //
    m_nThreadsCurr      = 0;
    m_nThreadsAvailable = 0;
    m_nThreadsMax       = max (nThreadsMax, MIN_THREADS);
    m_nThreadsInitial   = min (nThreadsMax, max (nThreadsInitial, MIN_THREADS));

    //
    // Set the last thread done and Shutdown to be false. 
    // Now onwards shutdown will require synchronization for cleanup.
    //
    m_fLastThreadDone = m_fShutdown = FALSE;

    //
    // Start up the appropriate number of threads.
    //
    for( DWORD i = 0; i < m_nThreadsInitial; i++) {

        StartThread();
    }
    

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Initialized Completion port COMPLETION_PORT::%08x\n", this));
    }

    return (rc);
    
} // COMPLETION_PORT::Initialize()


/*++
  COMPLETION_PORT::Cleanup()

  o  Cleans up the data. Closes the completion port handle
   and resets the value of internal data members.

  Arguments:
    None

  Return:
    ULONG - Win32 error codes.

  Note:
    This function should be called after the SynchronizeWithShutdown is called.
--*/

ULONG
COMPLETION_PORT::Cleanup(void)
{
    if (m_hCompletionPort != NULL) 
    {
        //
        // Free up the handle to completion port
        //

        if (!CloseHandle( m_hCompletionPort)) 
        {
            IF_DEBUG(ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, "Error(%d) in closing completion port handle(%08x).\n",
                            GetLastError(), m_hCompletionPort));
            }
            
            return ( GetLastError());
        }
        
        m_hCompletionPort = NULL;
    }

    IF_DEBUG( INIT_CLEAN) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Cleaned up completion port %08x\n", this));
    }

    return ( NO_ERROR);
    
} // COMPLETION_PORT::Cleanup()



/*++
  CP_ThreadProc()

  Description:
    Callback function for the WIN32 thread creation API.
    It is a dummy function. It forwards the call to the member
    function of the COMPLETION_PORT object.

  Arguments:
    lpCP - pointer to the COMPLETION_PORT object to which the thread
           should be attached to.

--*/
DWORD WINAPI CP_ThreadProc( LPVOID lpCP)
{
    return (((COMPLETION_PORT *) lpCP)->ThreadFunc());
    
} // CP_ThreadProc()


/*++
  COMPLETION_PORT::StartThread()

  Description:
    Callback function for the WIN32 thread creation API.
    It is a dummy function. It forwards the call to the member
    function of the COMPLETION_PORT object.

  Arguments:
    lpCP - pointer to the COMPLETION_PORT object to which the thread
           should be attached to.

--*/

ULONG
COMPLETION_PORT::StartThread(void)
{
    ULONG rc = NO_ERROR;

    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Starting up thread for completion port IO. Thread #%d\n", 
                    m_nThreadsCurr));
    }

    //
    // Check if there is room for more threads and startup additional threads.
    //

    if ( m_nThreadsCurr < m_nThreadsMax ) 
    {
        HANDLE hThread;
        DWORD  dwThreadId;

        InterlockedIncrement( (LPLONG ) &m_nThreadsCurr);
        
        if ( m_nThreadsCurr < m_nThreadsMax) 
        {
            hThread = CreateThread( NULL,                   // security attributes
                                    0,                      // dwStackSize
                                    CP_ThreadProc,
                                    this,                   // context
                                    0,                      // no creation flags
                                    &dwThreadId
                                    );

            // 
            // close the handle to free up system resources
            //
            if (hThread) 
            {
                DBG_REQUIRE( CloseHandle( hThread));
            }
            
        } 
        else 
        {
            
            // 
            // thread creation failed. adjust counts appropriately
            //
            if ( InterlockedDecrement((LPLONG) &m_nThreadsCurr) == 0) 
            {
                DBGPRINTF(( DBG_CONTEXT, "Failed to create any threads."
                            " Error=%d\n",
                            GetLastError()));
                            
                rc = GetLastError();
            }
        }
    } 
    else 
    {
        IF_DEBUG( TRACE) {
            DBGPRINTF(( DBG_CONTEXT, "Max Thread count(%d) reached. Stop here.\n",
                        m_nThreadsMax));
        }
    }               

    return (rc);
    
} // COMPLETION_PORT::ThreadFunc()


ULONG 
COMPLETION_PORT::ThreadFunc(void)
{
    BOOL            fRet;
    LPOVERLAPPED    lpo;
    DWORD           cbData;
    PCP_CONTEXT     pcpContext;
    DWORD           dwError;
    
    DBG_ASSERT( m_hCompletionPort != NULL);

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Thread(%d) starts waiting on the completion port\n",
                    GetCurrentThreadId()
                    ));
    }

    for (;;) 
    {

        lpo         = NULL;
        cbData      = 0;
        pcpContext  = NULL;
        dwError     = NO_ERROR;

        InterlockedIncrement( (LPLONG) &m_nThreadsAvailable);
        
        fRet = GetQueuedCompletionStatus( m_hCompletionPort,
                                          &cbData,
                                          (PULONG_PTR ) &pcpContext,
                                          &lpo,
                                          INFINITE
                                        );

        InterlockedDecrement( (LPLONG) &m_nThreadsAvailable);

        if ( m_fShutdown) 
        {
            break;
        }

        if ( !fRet)
        {
            dwError = GetLastError();
        }

        if ( pcpContext != NULL) 
        { 
            //
            // Create another thread if need be.
            //

            if (0 == m_nThreadsAvailable)
            {
                StartThread();
            }
            
            pcpContext->CompletionCallback( cbData, dwError, lpo);
        } 
        else 
        {
            //
            // NYI: This is probably the main completion port handle.
            //
            
            IF_DEBUG( ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                            "Completion Call back returned NULL context\n"
                            ));
            }
        }

    } // for

    //
    // Decrement # current threads used
    //
    if (InterlockedDecrement( (LPLONG ) &m_nThreadsCurr) == 0) 
    {
        
        //
        // indicate that the last thread is exiting
        // NYI: Use an event in the future.
        //
        
        m_fLastThreadDone = TRUE;
    }

    IF_DEBUG( TRACE) {
        DBGPRINTF(( DBG_CONTEXT, "Thread %d terminates\n", 
                    GetCurrentThreadId()));
    }
    
    return (NO_ERROR);

} // COMPLETION_PORT::ThreadFunc()


ULONG 
COMPLETION_PORT::AddHandle( IN PCP_CONTEXT pcpContext)
{
    DBG_ASSERT( NULL != m_hCompletionPort);
    DBG_ASSERT( pcpContext != NULL);

    HANDLE hDone;
    ULONG  rc = NO_ERROR;

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Adding handle(%08x) to CompletionPort(%08x) with context %08x\n",
                    pcpContext->GetAsyncHandle(), m_hCompletionPort, pcpContext
                    ));
    }

    hDone = CreateIoCompletionPort( 
                pcpContext->GetAsyncHandle(),        // new handle value
                m_hCompletionPort,
                (ULONG_PTR ) pcpContext,
                0                                    // concurrency value
                );
                                    
    if (hDone == NULL) 
    {
        rc = GetLastError();
    }

    return (rc);

} // COMPLETION_PORT::AddHandle()


ULONG 
COMPLETION_PORT::SynchronizeWithShutdown(void)
{
    // NYI:

    //
    // I need to synchronize with # items outstanding and hence be able
    //  to tell it is okay to cleanup this object
    // 
    

    //
    // Shutdown the running threads as well.
    //
    DWORD nThreadsCurrent = m_nThreadsCurr;

    if (nThreadsCurrent > 0) 
    {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        IF_DEBUG( TRACE) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Posting shutdown message to all threads (%d).\n",
                        nThreadsCurrent));
        }

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        // BUGBUG: Each thread cannot exit with the first error received.
        //  Some thread has to loop until all contexts have gone away.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for ( i=0; i < nThreadsCurrent; i++) 
        {
            fRes = PostQueuedCompletionStatus( m_hCompletionPort,
                                         0,
                                         0,
                                         &overlapped );

            DBG_ASSERT( (fRes == TRUE) ||
                        ( (fRes == FALSE) &&
                          (GetLastError() == ERROR_IO_PENDING) )
                        );
        }

        //
        // Now wait for the pool threads to shutdown.
        //
        DWORD dwWaitCount = 0;
        
        while ( !m_fLastThreadDone) 
        {
            IF_DEBUG( TRACE) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                            "Wait(count=%d) for shutdown. Threads %d pending.\n",
                            dwWaitCount, m_nThreadsCurr
                            ));
            }

            dwWaitCount++;
            Sleep( 10*1000);  // sleep for some time: 10 seconds
        
        } // while
    }

    // Aha! we are done with all threads. Get out of here.

    return (NO_ERROR);

} // COMPLETION_PORT::SynchronizeWithShutdown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\static\responseheaders.cxx ===
*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       ResponseHeaders.cxx
       
   Abstract:
       Defines the string constants containing the standard
       headers used for creating response headers to be sent out.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     01-Dec-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************++
 *     Include Headers
 --************************************************************/

# include "precomp.hxx"
# include "ResponseHeaders.h"

/************************************************************++
 *  Constant string definitions 
 *
 *  The constant strings are defined in one single place to 
 *   maintain integrity and also to enable modifications to be
 *   localized within this code path.
 *
 --************************************************************/
#define    SZ_PROTOCOL_VERSION        "HTTP/1.1"
#define    SZ_STATUS_OK               "200 OK"
#define    SZ_STATUS_REDIRECT         "302 Object Moved"
#define    SZ_CRLF                    "\r\n"
#define    SZ_SERVER_NAME             "Server: IIS-WorkerProcess v1.0\r\n"
#define    SZ_CONNECTION_CLOSE        "Connection: close\r\n"
#define    SZ_CONTENT_TEXT_HTML       "Content-Type: text/html\r\n"

const CHAR g_rgchTraceMessageHeadersHTML[] = 
SZ_PROTOCOL_VERSION " " SZ_STATUS_OK SZ_CRLF
SZ_SERVER_NAME
;

const CHAR g_rgchTraceMessageBodyStartHTML[] = 
 "<HTML><TITLE> Trace of Headers Received </TITLE><BODY>\r\n"
;

const CHAR g_rgchTraceMessageBodyEndHTML[] = 
 "</BODY></HTML>\r\n"
;

const CHAR g_rgchTraceMessageHeaders[] = 
SZ_PROTOCOL_VERSION " " SZ_STATUS_OK SZ_CRLF
SZ_SERVER_NAME
"Content-Type: message/http\r\n"
SZ_CRLF
;

const CHAR g_rgchTraceMessageBodyStart[] = 
 "<HTML><TITLE> Trace of Headers Received </TITLE><BODY>\r\n"
;

const CHAR g_rgchTraceMessageBodyEnd[] = 
 "</BODY></HTML>\r\n"
;

const CHAR g_rgchGetResponseHeaders[] = 
SZ_PROTOCOL_VERSION " " SZ_STATUS_OK SZ_CRLF
SZ_SERVER_NAME
SZ_CRLF
;

//
// Defines the response header for a successful response.
//
const CHAR g_rgchStandardResponseHeaders[] = 
SZ_PROTOCOL_VERSION " " SZ_STATUS_OK SZ_CRLF
SZ_SERVER_NAME
SZ_CONTENT_TEXT_HTML
SZ_CRLF
;

const CHAR g_rgchStandardResponseHeadersEnd[] = 
SZ_CRLF        // extra CRLF to indicate termination of headers
;

//
// Defines the headers & response chunk for a successful dirlist
//

const CHAR g_rgchDirectoryListingHeaders[] =
SZ_PROTOCOL_VERSION " " SZ_STATUS_OK SZ_CRLF
SZ_SERVER_NAME
SZ_CONTENT_TEXT_HTML
"Transfer-Encoding: chunked\r\n"
SZ_CRLF
;

//
// Headers for a redirect
//

const CHAR g_rgchRedirectResponseHeaders[] =
SZ_PROTOCOL_VERSION " " SZ_STATUS_REDIRECT SZ_CRLF
SZ_SERVER_NAME
SZ_CONTENT_TEXT_HTML
;

/************************************************************++
 *  STRING_TABLE_ITEM
 *  The string table maintains a indexed list of pointers 
 *  to constant strings along with the length of the strings.
 *
 *  A single module level global variable g_rgStringTable
 *  keeps track of all the response related strings that
 *  are used for sending responses to the clients.
 *  This table is statically initailized at the startup time
 *
 --************************************************************/
# define InitItem( sti, pszConstantItem)  \
    { pszConstantItem, (sizeof(pszConstantItem) - 1) }

struct STRING_TABLE_ITEM {
    const CHAR * pszItem;
    DWORD        cchItem;
} g_rgStringTable[STIMax] = 
{
    InitItem( STIMin, ""),
    InitItem( STITraceMessageHeadersHTML,   g_rgchTraceMessageHeadersHTML),
    InitItem( STITraceMessageBodyStartHTML, g_rgchTraceMessageBodyStartHTML),
    InitItem( STITraceMessageBodyEndHTML,   g_rgchTraceMessageBodyEndHTML),

    InitItem( STITraceMessageHeaders,     g_rgchTraceMessageHeaders),
    InitItem( STITraceMessageBodyStart,   g_rgchTraceMessageBodyStart),
    InitItem( STITraceMessageBodyEnd,     g_rgchTraceMessageBodyEnd),

    InitItem( STIStandardResponseHeaders,   g_rgchStandardResponseHeaders),
    InitItem( STIStandardResponseHeadersEnd,g_rgchStandardResponseHeadersEnd),

    InitItem( STIDirectoryListingHeaders, g_rgchDirectoryListingHeaders),

    InitItem( STIRedirectResponseHeaders, g_rgchRedirectResponseHeaders),

};


/********************************************************************++

Routine Description:
    This function fills the data chunk with string item corresponding 
    to the index supplied. For now we employ a direct string table lookup.

Arguments:
    None

Returns:
    None
    
--********************************************************************/

void FillDataChunkWithStringItem(
        IN PUL_DATA_CHUNK pdc, 
        IN STRING_TABLE_INDEX sti)
{
    DBG_ASSERT( pdc != NULL);
    DBG_ASSERT( (sti > STIMin) && (sti < STIMax));

    pdc->DataChunkType           = UlDataChunkFromMemory;

    DBG_ASSERT( g_rgStringTable[sti].pszItem != NULL);
    pdc->FromMemory.pBuffer      = (PVOID ) g_rgStringTable[sti].pszItem;
    pdc->FromMemory.BufferLength = g_rgStringTable[sti].cchItem;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\controlchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ControlChannel.cxx

   Abstract:
     Defines the functions used to access the control channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Oct-1998

   Project:

       IIS Worker Process

--*/


# include "precomp.hxx"
# include "ControlChannel.hxx"

/********************************************************************++

  UL_CONTROL_CHANNEL::Initialize()

  Description:
     This function initializes the control channel for given address, NSGO, 
     and host name. It opens the control channel, registers a virtual host,
     and NSGO. After that it registers the URL for which notifications are 
     to be handled within the NSGO.

  Arguments:


  Returns:

++********************************************************************/

ULONG 
UL_CONTROL_CHANNEL::Initialize( 
    IN MULTISZ& mszURLList,
    IN LPCWSTR  pwszAppPoolName
    )
{
    ULONG   rc;
    LPCWSTR pwszURL;

    if ( m_hControlChannel != NULL) 
    {
        //
        // There is already a control channel
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of control channel\n"));
        return ERROR_DUP_NAME;
    }
    
    //
    // 1. Open a control channel object from the UL driver
    //
    
    rc = UlOpenControlChannel( &m_hControlChannel, 0);

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "UlOpenControlChannel() failed. Error = %08x. Returning\n", 
                        rc
                        ));
        }

        return (rc);
    }

    //
    // 2. Create a Config Group on this control channel
    //
    
    rc = UlCreateConfigGroup( m_hControlChannel, &m_ConfigGroupId );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateConfigGroup failed. Error=%08x. Returning\n",
                       rc
                       ));
        }

        return rc;
    }

    //
    // 3. Insert all specified URLs into the config group
    //

    pwszURL = mszURLList.First();

    while (NULL != pwszURL)
    {
        rc = AddURLToConfigGroup(pwszURL);

        if (NO_ERROR != rc)
        {
            return rc;
        }

        pwszURL = mszURLList.Next(pwszURL);
    }

    //
    // 4. Activate the Control Channel and the Config Group
    //

    UL_ENABLED_STATE    ccState = UlEnabledStateActive;

    rc = UlSetControlChannelInformation( m_hControlChannel,
                                         UlControlChannelStateInformation,
                                         &ccState,
                                         sizeof(ccState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate ControlChannel. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    UL_CONFIG_GROUP_STATE   cgState;

    cgState.Flags.Present = 1;
    cgState.State         = UlEnabledStateActive;  
                                         
    rc = UlSetConfigGroupInformation( m_hControlChannel,
                                      m_ConfigGroupId,
                                      UlConfigGroupStateInformation,
                                      &cgState,
                                      sizeof(cgState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate Config Group. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    //
    // 5. Create an AppPool 
    //

    rc = UlCreateAppPool( &m_hAppPool,
                          pwszAppPoolName,
                          0,
                          UL_OPTION_OVERLAPPED
                        );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateAppPool failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }
    
    //
    // 6. Associate AppPool with the config group
    //

    UL_CONFIG_GROUP_APP_POOL    AppPoolConfig;

    AppPoolConfig.Flags.Present = 1;
    AppPoolConfig.AppPoolHandle = m_hAppPool;
    
    rc = UlSetConfigGroupInformation( m_hControlChannel,
                                      m_ConfigGroupId,
                                      UlConfigGroupAppPoolInformation,
                                      &AppPoolConfig,
                                      sizeof(AppPoolConfig)
                                    );
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlSetConfigGroupInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Initialize()

/********************************************************************++
++********************************************************************/


ULONG 
UL_CONTROL_CHANNEL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

#ifdef UL_SIMULATOR_ENABLED

    rc = UlsimCleanupControlChannel( m_hControlChannel);
# else

    if ( m_hControlChannel != NULL) 
    {
        if ( ! UL_IS_NULL_ID(&m_ConfigGroupId) )
        {
            rc = UlDeleteConfigGroup( m_hControlChannel, m_ConfigGroupId);
            UL_SET_NULL_ID(&m_ConfigGroupId);
        }

        if ( NULL != m_hAppPool )
        {
            if ( !::CloseHandle( m_hAppPool))
            {
                rc = GetLastError();
            }
        }

        m_hAppPool = NULL;
        
        if (!::CloseHandle( m_hControlChannel)) 
        {
            rc = GetLastError();
        }
        
        m_hControlChannel = NULL;
    }
#endif
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Cleanup()

/********************************************************************++
++********************************************************************/

ULONG
UL_CONTROL_CHANNEL::AddURLToConfigGroup( IN LPCWSTR  pwszURL)
{
    //
    //  Add the URL to the Config Group
    //

    ULONG rc;

    rc = UlAddUrlToConfigGroup( m_hControlChannel,
                                m_ConfigGroupId,
                                pwszURL,
                               0
                              );
    
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG (ERROR)
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "UlAddUrlToConfigGroup() failed. Error=%08x\n",
                       rc));
        }
    }

    return (rc);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\modules\uridata\uridata.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     UriData.hxx

   Abstract:
     This module declares the URI_DATA data structure which 
     encapsulates all the relevant metadata and lookup processing
     data for an URI item.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     02-Dec-1998

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

/************************************************************++
 *  Include Headers 
 --************************************************************/

 #include "precomp.hxx"
 #include <iiscnfg.h>

//
// WARNING:
//  THIS IS THROW AWAY CODE waiting for the complete URI_DATA object
//

BOOL ConvertSlashes(IN LPWSTR psz, IN DWORD cchLen);

/************************************************************++
 *  Implement Member Functions of URI_DATA
 *  Make dummy implementations now. MCourage will make full-blown
 *   implementation of this code
 --************************************************************/

 URI_DATA::URI_DATA(void)
    : m_strUriFileName(),
      m_strUri(),
      m_strPhysicalPath(),
      m_strExtensionPath(),
      m_nRefs (1),
      m_fDynamic (false),
      m_dwDirBrowseFlags (MD_DIRBROW_ENABLED),
      m_cbFileSizeLow  (0),
      m_cbFileSizeHigh (0),
      m_dwSignature( URI_DATA_SIGNATURE)
{
    
}

URI_DATA::~URI_DATA()
{
    m_dwSignature = (URI_DATA_SIGNATURE_FREE);
}


MODULE_RETURN_CODE 
URI_DATA::ProcessRequest( IN IWorkerRequest * pReq)
{
    PWSTR               pwszUri;
    PUL_HTTP_REQUEST    pHttpRequest = pReq->QueryHttpRequest();

    pwszUri = (LPWSTR)pReq->QueryURI(true);
    DBG_ASSERT( pwszUri != NULL);

    //
    // Extract the URI key and store it inside the URI item
    // exclude the null-character while copying over the URL.
    //
    if ( !m_strUri.Copy( pwszUri) ||
         !m_strUri.IsValid()
        )
    {
        DBGPRINTF(( DBG_CONTEXT, "Copy of URI (%s) failed.\n"));
        return (MRC_ERROR);
    }


    pwszUri = m_strUri.QueryStrW(); // force a unicode conversion to  start with.
    DBG_ASSERT( pwszUri != NULL);

    //
    // Convert the URI key into file-name with respect to current directory
    //  and store it inside the UriFileName item
    //

    //
    // FileName part = CurrentWorking Directory + URI appended to it.
    //
    WCHAR  rgchFileName[MAX_PATH];
    GetCurrentDirectoryW( MAX_PATH, rgchFileName );
    if (rgchFileName[wcslen(rgchFileName) - 1] == L'\\' )
    {
        rgchFileName[wcslen(rgchFileName) - 1] = L'\0';
    }

    if (!m_strUriFileName.Copy( rgchFileName))
    {
        return (MRC_ERROR);
    }

    // Make ExtensionPath out of current directory.
    if (!m_strExtensionPath.Copy(rgchFileName))
    {
        return (MRC_ERROR);
    }

    //
    // canonicalize and append the URI string.
    //
    if ( !m_strUriFileName.ResizeW( m_strUriFileName.QueryCBW() + m_strUri.QueryCBW()) ||
         !m_strUriFileName.Append( m_strUri) ||
         !ConvertSlashes( m_strUriFileName.QueryStrW(), m_strUriFileName.QueryCCH())
         )
    {
        return (MRC_ERROR);
    }

    if (!m_strPhysicalPath.Copy(m_strUriFileName))
    {
        return (MRC_ERROR);
    }
    // Parse out the query string
    // Quick prototype of extension path
    UINT    i;
    UINT    UriLength               = m_strUri.QueryCCH();
    INT     ExtensionOffset         = -1;
    INT     FileExtensionOffset     = -1;
    WCHAR*  pChar                   = (WCHAR *)pwszUri;
    for (i  = 0; i <= UriLength; pChar++, i++)
    {
        if (*pChar == L'/')
        {
            ExtensionOffset = i+1;
        }
        else
        {
            if (*pChar == L'.')
            {
            FileExtensionOffset = i+1;
            }
        }
    }

    if (ExtensionOffset != -1)
    {
        WCHAR   FileExtensionMapping[MAX_PATH+1];
        INT     FileExtensionMappingLength = (FileExtensionOffset != -1) ?
                                                UriLength-FileExtensionOffset: 0;
        // EXTENSION MAPPING
        INT     ExtensionLength = UriLength - ExtensionOffset;

        if (ExtensionLength == -1) ExtensionLength = 0;
         
        m_strExtensionPath.Append(L"\\");
        m_strExtensionPath.Append(pwszUri+ExtensionOffset, 
            ExtensionLength);

        DBG_ASSERT(FileExtensionMappingLength < MAX_PATH);
                    
        if (FileExtensionOffset != -1 && 
            FileExtensionMappingLength > 0)
        {
            memcpy(FileExtensionMapping, pwszUri+FileExtensionOffset,
                FileExtensionMappingLength*sizeof(WCHAR));

            FileExtensionMapping[FileExtensionMappingLength] = L'\0';
        }

        // a little script mapping
        if (0 == wcsncmp(FileExtensionMapping, L"dll", sizeof(L"dll")/sizeof(WCHAR)))
        {
            m_fDynamic = TRUE;
        }

        if (0 == wcsncmp(FileExtensionMapping, L"asp", sizeof(L"dll")/sizeof(WCHAR)))
        {
            m_fDynamic = TRUE;
        }

       if (0 == wcsncmp(FileExtensionMapping, L"xsp", sizeof(L"dll")/sizeof(WCHAR)))
        {
            // 
            // Hard coded script mapping
            //
            m_fDynamic = TRUE;
            if (!m_strExtensionPath.Copy(rgchFileName))
                {
                    return (MRC_ERROR);
                }

            m_strExtensionPath.Append(L"\\xspisapi.dll");
        }

    }    

    //
    // Open file & set attributes
    //

    m_dwFileAttributes = GetFileAttributes(m_strUriFileName.QueryStrW());
    m_cbFileSizeLow    = GetFileSize(m_strUriFileName.QueryStrW(), &m_cbFileSizeLow);
    
    /*
    //
    // append default.htm if there is no specific file specified at the end
    //
    if ( m_strUriFileName.QueryStrW()[m_strUriFileName.QueryCCH() - 1] == L'\\')
    {
        m_strUriFileName.Append(L"default.htm");
    }
    */
    
    DBGPRINTF(( DBG_CONTEXT, "URI_DATA::Initialize(%ws) => %ws\n",
                pwszUri, m_strUriFileName.QueryStrW()
                ));
                
    return MRC_OK;
}


BOOL ConvertSlashes(IN LPWSTR pszSource, IN DWORD cchLen)
{
    LPWSTR psz;

    //
    // convert all leading slashes into the backward slashes for use with  file system
    //
    for( psz = pszSource; psz < pszSource + cchLen; psz++)
    {
        if ( *psz == L'/')
        {
            *psz = L'\\';
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\iiswp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     iiswp.cxx

   Abstract:
     Main module for the Worker Process of KDT
 
   Author:

       Murali R. Krishnan    ( MuraliK )     23-Sept-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();



class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
        SET_DEBUG_FLAGS( DEBUG_ERROR | DEBUG_TRACE | DEBUG_UL_CALLS | DEBUG_PROCESS_REQUEST);
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};


WP_CONTEXT * g_pwpContext = NULL;

/************************************************************
 *    Functions 
 ************************************************************/

extern "C" INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    DEBUG_WRAPPER  dbgWrapper( "iiswp");
    WP_CONFIG      wpConfig;
    ULONG          rc;


    //
    // We don't want the worker process to get stuck in a dialog box
    // if it goes awry.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX );


    if (argc > 0 ) 
    {

        BOOL fRet;
        fRet = wpConfig.ParseCommandLine( argc, argv);

        if (!fRet) 
        {
            return (ERROR_WORKER_PROCESS_EXIT_CODE);
        }
    }

    rc = UlInitialize(0);
    
    if (NO_ERROR != rc)
    {
        DBGPRINTF(( DBG_CONTEXT, "Error (rc=%08x) in UlInitialize. Exiting\n",
                    rc ));
        return (ERROR_WORKER_PROCESS_EXIT_CODE);
    }

    if ( wpConfig.FSetupControlChannel()) 
    {

        IF_DEBUG( TRACE) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Setting up Control Channel\n" ));
        }

        rc = wpConfig.SetupControlChannel();

        if (NO_ERROR != rc) 
        {
            IF_DEBUG(ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT, 
                            "Error (rc=%08x) in setting up Control Channel. Exiting\n",
                            rc
                         ));
            }

            UlTerminate();
            return (ERROR_WORKER_PROCESS_EXIT_CODE);
        }
    }

    //
    // Initialize global state
    //
    
    g_pwpContext = new WP_CONTEXT;
    
    if (NULL == g_pwpContext) 
    {

        IF_DEBUG(ERROR) 
        {
           DBGPRINTF(( DBG_CONTEXT, "Memory failure in creating WP_CONTEXT object.\n"));
        }

        UlTerminate();
        return (ERROR_WORKER_PROCESS_EXIT_CODE);
    }

    //
    // Initialize the worker process context
    //

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Initalizing conext for AppPool: %ws\n", 
                    wpConfig.QueryAppPoolName()
                 ));
    }

    rc = g_pwpContext->Initialize( &wpConfig);
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, "Error (rc=0x%08x) in initalizing AppPool '%ws'. Exiting\n",
                            rc, wpConfig.QueryAppPoolName()
                     ));
        }

        goto cleanup;
    }

    //
    // In future this main thread will be subsumed by one of the
    // worker threads or this may become the OLE Main thread.
    //
    
    rc = g_pwpContext->RunMainThreadLoop();

cleanup:

    //
    // exit from the function.
    //
    
    IF_DEBUG(TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Exiting the AppPool process\n"));
    }
    
    delete g_pwpContext;
    g_pwpContext = NULL;
    
    UlTerminate();

    //
    // If we exited the main loop cleanly, then signal a clean exit
    // to the web admin service.
    //

    if ( rc == NO_ERROR )
    {
        rc = CLEAN_WORKER_PROCESS_EXIT_CODE;
    }
    
    return rc;
    
} // wmain()



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\modulemanager.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module  Name :
     ModuleManager.cxx

   Abstract:
     This module implements the IIS Module Manager
 
   Author:

       Saurab Nog    ( SaurabN )     29-Jan-1999

   Environment:
       Win32 - User Mode
       
   Project:
	  IIS Worker Process (web service)

--*/

#include "precomp.hxx"
#include "ModuleManager.hxx"
#include <StaticProcessingModule.hxx>
#include <DynamicContentModule.hxx>
#include <ConnectionModule.hxx>
#include <ErrorHandlingModule.hxx>

/*
CModuleManager::CModuleManager()
{
    m_rgModuleArray[WRS_FREE]               = new CIISModule(); 
    m_rgModuleArray[WRS_READ_REQUEST]       = new CIISModule(); 
    m_rgModuleArray[WRS_FETCH_URI_DATA]     = new CIISModule(); 
    m_rgModuleArray[WRS_SECURITY]           = new CIISModule(); 
    m_rgModuleArray[WRS_PROCESSING_STATIC]  = new CIISModule(); 
    m_rgModuleArray[WRS_PROCESSING_DYNAMIC] = new CIISModule(); 
    m_rgModuleArray[WRS_ERROR]              = new CIISModule(); 
}
*/

/********************************************************************++
--********************************************************************/
/*
CModuleManager::~CModuleManager()
{
    for (int i = 0; i < WRS_MAXIMUM; i++)
    {
        if (NULL != m_rgModuleArray[i])
        {
            delete m_rgModuleArray[i];
            m_rgModuleArray[i] = NULL;
        }
    }
}

*/
/********************************************************************++
--********************************************************************/

IModule * CModuleManager::GetModule (
    IN WREQ_STATE  state
)
{
    IModule * pMod;
    
    switch (state)
    {
        case WRS_FREE:
        case WRS_READ_REQUEST:
        case WRS_SECURITY:
            pMod = NULL; 
            break;

        case WRS_FETCH_CONNECTION_DATA:
            pMod = new CConnectionModule;
            break;
        
        case WRS_PROCESSING_DYNAMIC:
            pMod = new CDynamicContentModule;
            break;
            
        case WRS_FETCH_URI_DATA:
            pMod = new URI_DATA; 
            break;
        
        case WRS_PROCESSING_STATIC:
            pMod = new CStaticProcessingModule; 
            break;

        case WRS_ERROR:
            pMod = new CErrorHandlingModule;
            break;

        default:
            pMod = NULL;
            break;
     }

     return pMod;
}

/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\ipm_io_c.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ipm_io_c.hxx

Abstract:

    This module contains classes for doing async io in the
    worker process.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include "precomp.hxx"
#include "ipm_io_c.hxx"


/***************************************************************************++

Routine Description:

    Creates an i/o handler
    
Arguments:

    hPipe           - A handle to the named pipe to be handled
    ppPipeIoHandler - receives a pointer to the handler on success
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_FACTORY_C::CreatePipeIoHandler(
    IN  HANDLE             hPipe,
    OUT PIPE_IO_HANDLER ** ppPipeIoHandler
    )
{
    HRESULT        hr = S_OK;
    ULONG          rc;
    IO_HANDLER_C * pHandler;

    //
    // create the object
    //

    pHandler = new IO_HANDLER_C(hPipe);
    if (pHandler) {
        //
        // bind handle to completion port
        //
        rc = m_pCompletionPort->AddHandle(pHandler);
        if (rc == NO_ERROR) {
            *ppPipeIoHandler = pHandler;
            InterlockedIncrement(&m_cPipes);

            pHandler->Reference();

            DBGPRINTF((
                DBG_CONTEXT,
                "Created IO_HANDLER_C (%x) - m_cPipes = %d\n",
                pHandler,
                m_cPipes
                ));
            
        } else {
            delete pHandler;
            hr = HRESULT_FROM_WIN32(rc);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Closes an i/o handler
    
Arguments:

    pPipeIoHandler - pointer to the handler to be closed
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_FACTORY_C::ClosePipeIoHandler(
    IN PIPE_IO_HANDLER * pPipeIoHandler
    )
{
    IO_HANDLER_C * pIoHandler = (IO_HANDLER_C *) pPipeIoHandler;
    LONG           cPipes;

    if (pIoHandler) {
        cPipes = InterlockedDecrement(&m_cPipes);

        DBGPRINTF((
            DBG_CONTEXT,
            "Closed IO_HANDLER_C (%x) - m_cPipes = %d\n",
            pPipeIoHandler,
            m_cPipes
            ));

        DBG_ASSERT( cPipes >= 0 );
        
        pIoHandler->Dereference();

        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
}


/***************************************************************************++

Routine Description:

    Disconnects the named pipe
    
Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_C::Disconnect(
    VOID
    )
{
    HRESULT hr = S_OK;

    CheckSignature();

    if (!CloseHandle(GetHandle())) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Writes data to the pipe
    
Arguments:

    pContext - the context to be notified on completion
    pv       - a parameter passed to the context
    pBuff    - the data to send
    cbBuff   - number of bytes in the data
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_C::Write(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN const BYTE * pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_WRITE;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // write to the pipe
        //

        hr = IpmWriteFile(
                    GetHandle(),
                    (PVOID) pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );
                    
        if (FAILED(hr))
        {
            Dereference();              
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Reads data from the pipe
    
Arguments:

    pContext - the context to be notified on completion
    pv       - a parameter passed to the context
    pBuff    - the buffer that receives the data
    cbBuff   - size of the buffer
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
IO_HANDLER_C::Read(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN BYTE *       pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    DWORD          dwReadError;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    DBGPRINTF((
        DBG_CONTEXT,
        "\n    IO_HANDLER_C::Read(%x, %x, pBuff %x, %d)\n",
        pContext,
        pv,
        pBuff,
        cbBuff
        ));

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_READ;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // read from the pipe
        //

        hr = IpmReadFile(
                    GetHandle(),
                    pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );
                    
        if (FAILED(hr))
        {
            Dereference();
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Handles I/O completions from the completion port
    
Arguments:

    cbData  - Amount of data transferred
    dwError - win32 error code
    lpo     - pointer to overlapped used for the i/o
    
Return Value:

    None.
    
--***************************************************************************/
VOID
IO_HANDLER_C::CompletionCallback(
    IN DWORD        cbData,
    IN DWORD        dwError,
    IN LPOVERLAPPED lpo
    )
{
    IO_CONTEXT_C * pIoContext;
    HRESULT        hr = HRESULT_FROM_WIN32(dwError);

    CheckSignature();

    //
    // get the context object
    //
    pIoContext = CONTAINING_RECORD(lpo, IO_CONTEXT_C, m_Overlapped);
    DBG_ASSERT( pIoContext->m_dwSignature == IO_CONTEXT_C_SIGNATURE );

    DBGPRINTF((
        DBG_CONTEXT,
        "\n    IO_HANDLER_C::CompletionCallback(%d, %x, pIoContext %x) %s\n",
        cbData,
        dwError,
        pIoContext,
        pIoContext->m_IoType == IPM_IO_WRITE ? "WRITE" : "READ"
        ));
        
    //
    // do the notification
    //
    switch (pIoContext->m_IoType) {
    case IPM_IO_WRITE:
        pIoContext->m_pContext->NotifyWriteCompletion(
            pIoContext->m_pv,
            cbData,
            hr
            );
        break;

    case IPM_IO_READ:
        pIoContext->m_pContext->NotifyReadCompletion(
            pIoContext->m_pv,
            cbData,
            hr
            );
        break;

    default:
        DBG_ASSERT(FALSE);
        break;
    }

    Dereference();

    delete pIoContext;
}

//
// end ipm_io_c.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\workerrequest.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       WorkerRequest.cxx

   Abstract:
       Defines the functions for WORKER_REQUEST object

   Author:

       Murali R. Krishnan    ( MuraliK )     23-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
       IIS Worker Process (web service)
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

// Header file required form _alloca
#include <malloc.h>
#include <httpext.h>
#include "StateMachineModule.hxx"
#include "ModuleManager.hxx"
#include <StatusCodes.hxx>

//
//  Default response buffer size
//

#define DEF_RESP_BUFF_SIZE           4096

//
// The Module Manager
//

CModuleManager g_ModuleManager;


//
// IIS supplied state machine module
//

CStateMachineModule g_StateMachineModule;

/********************************************************************++
 *          Member functions of WORKER_REQUEST
++********************************************************************/

WORKER_REQUEST::WORKER_REQUEST( IN WORKER_REQUEST_POOL * pReqPool)
  : m_pbRequest         ( (UCHAR * ) m_rgchInlineRequestBuffer),
    m_cbRequest         ( sizeof( m_rgchInlineRequestBuffer)),
    m_signature         ( WORKER_REQUEST_SIGNATURE),
    m_pReqPool          ( pReqPool),
    m_nRefs             ( 1)
{
    InitializeListHead( &m_lRequestEntry);
    ZeroMemory( &m_rgpModuleInfo, sizeof(m_rgpModuleInfo));

    //
    // Make WRS_FREE and WRS_READ_REQUEST point to self
    //

    m_rgpModuleInfo[WRS_FREE].pModule         = (IModule *)this;
    m_rgpModuleInfo[WRS_READ_REQUEST].pModule = (IModule *)this;

    //
    // Temporary
    //

    m_rgpModuleInfo[WRS_SECURITY].pModule = (IModule *)this;

    Reset();

    IF_DEBUG( WORKER_REQUEST)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Created worker request (%08x)\n", this
            ));
    }

    DBG_ASSERT( pReqPool != NULL);

} // WORKER_REQUEST::WORKER_REQUEST()

/********************************************************************++
++********************************************************************/

WORKER_REQUEST::~WORKER_REQUEST(void)
{
    DBG_ASSERT( WORKER_REQUEST_SIGNATURE == m_signature );
    DBG_ASSERT( WRS_FREE == m_wreqState);

    /* BUG : leaking contexts.

    if ( NULL != m_pUriData)
    {
        m_pUriData->Release();
        m_pUriData = NULL;
    }
    */

    if (!IsListEmpty( &m_lRequestEntry))
    {
        DBG_ASSERT( m_pReqPool);

        //
        // remove from the list if it not already done so.
        //

        m_pReqPool->RemoveRequestFromList( this);
        m_pReqPool = NULL;
    }

    DBG_ASSERT( m_nRefs == 0);

    m_signature = ( WORKER_REQUEST_SIGNATURE_FREE);

} // WORKER_REQUEST::~WORKER_REQUEST()

/********************************************************************++
++********************************************************************/

void
WORKER_REQUEST::Reset()
{
    m_wreqState         = WRS_FREE;
    m_wreqPrevState     = WRS_UNDEFINED;
    m_IOState           = WRIO_NONE;
    m_ReadState         = WRREADREQUEST_NONE;

    m_dwLogHttpResponse = HT_OK;
    m_dwLogWinError     = NO_ERROR;
    m_cbRead            = 0;
    m_cbWritten         = 0;
    m_cbAsyncIOData     = 0;
    m_dwAsyncIOError    = NO_ERROR;

    m_strHost.Reset();
    m_strURI.Reset();
    m_strQueryString.Reset();

    m_strMethod.Reset();
    m_strContentType.Reset();

    ZeroMemory( &m_overlapped, sizeof(m_overlapped));

    for (ULONG i=0; i < WRS_MAXIMUM; i++)
    {
        m_rgpModuleInfo[i].fInitialized = false;
    }

    //
    // ISSUE - Should request buffer be reset.
    //

} // WORKER_REQUEST::Reset()

/********************************************************************++

Routine Description:
  This function is the switch board for processing the current request.
  The WORKER_REQUEST object employs a state machine for handling the
  variuos stages of the operation. This function examines the state
  and appropriately takes the necessary actions to move the request
  from one state to another to eventually complete the processing of
  request.

Arguments:
  cbData - count of bytes of data handled in last IO operation
  dwError - Error if any during the processing of request
  lpo    - pointer to the overlapped structure supplied for handling
              this request.
Returns:
   NO_ERROR on successful return.

   If there is an error, this function sends out error message to the
     client and derferences the object preparing for cleanup.

--********************************************************************/

HRESULT
WORKER_REQUEST::FinishPending(
    void
    )
{

    MODULE_RETURN_CODE  mrc;

    mrc = g_StateMachineModule.ProcessRequest(this);

    if (mrc != MRC_OK)
    {
        //
        // Hmmm, State M/C says something sucks.
        //

        DBGPRINTF((DBG_CONTEXT,
                   "State Machine Module could not determine next state. Resetting\n"
                   ));

        SetState(WRS_FREE);
    }

    //
    // Call DoWork to complete the rest of the state machine.
    //

    return DoWork( 0,               // cbData
                   0,               // dwError
                   &m_overlapped    // lpo
                 );

}

/********************************************************************++

Routine Description:
  This function is the switch board for processing the current request.
  The WORKER_REQUEST object employs a state machine for handling the
  variuos stages of the operation. This function examines the state
  and appropriately takes the necessary actions to move the request
  from one state to another to eventually complete the processing of
  request.

Arguments:
  cbData - count of bytes of data handled in last IO operation
  dwError - Error if any during the processing of request
  lpo    - pointer to the overlapped structure supplied for handling
              this request.
Returns:
   NO_ERROR on successful return.

   If there is an error, this function sends out error message to the
     client and derferences the object preparing for cleanup.

--********************************************************************/

ULONG
WORKER_REQUEST::DoWork(
    IN DWORD cbData,
    IN DWORD dwError,
    IN LPOVERLAPPED lpo
    )
{

    MODULE_RETURN_CODE  mrc = MRC_OK;
    IModule *           pModule;

    IF_DEBUG( TRACE) {
        DBGPRINTF(( DBG_CONTEXT,
                "WORKER_REQUEST(%08x)::DoWork( %d, %d, %08x)\n"
                ,
                this,
                cbData,
                dwError,
                lpo
                ));
    }

    DBG_ASSERT( (lpo == &m_overlapped));

    //
    // Dereference if the current state indicates there was an async
    // IO operation and this call is the async IO completion.
    //

    if ( WRIO_NONE != m_IOState)
    {
        DBG_ASSERT(ReferenceCount() > 1);

        DereferenceRequest(this);

        m_cbAsyncIOData    = cbData;
        m_dwAsyncIOError   = dwError;

        (WRIO_READ == m_IOState) ? m_cbRead += cbData : m_cbWritten += cbData;

        m_IOState = WRIO_NONE;
    }

    //
    // Execute loop while status is not PENDING
    //

    while (MRC_PENDING != mrc)
    {
        pModule = QueryModule(QueryState());

        if (NULL == pModule)
        {
            pModule = g_ModuleManager.GetModule(QueryState());

            if (pModule)
            {
                //
                // Establish module in Module Array & Initialize it.
                //

                SetModule(QueryState(), pModule);
            }
        }

        if ( (NULL == pModule) ||
             (NO_ERROR != InitializeModule( QueryState()) )
           )
        {
            //
            // Out of memory or the module failed to initialize.
            // Kill object & get out.
            //

            DereferenceRequest(this);
            break;
        }

        mrc = pModule->ProcessRequest(this);

        if ( (MRC_PENDING != mrc) && (MRC_CONTINUE != mrc) )
        {
            m_ProcessingCode = mrc;

            //
            // The state machine's process request will compute
            // the next state and set that in the worker request
            //

            mrc = g_StateMachineModule.ProcessRequest(this);

            if (mrc != MRC_OK)
            {
                //
                // Hmmm, State M/C says something sucks.
                //

                DBGPRINTF((DBG_CONTEXT,
                           "State Machine Module could not determine next state. Resetting\n"
                           ));

                SetState(WRS_FREE);
            }
        }
    }

    return NO_ERROR;

} // WORKER_REQUEST::DoWork()


/********************************************************************++

Routine Description:
  This function provides default implementations for certain states
  of the worker request.

Arguments:

Returns:

--********************************************************************/


MODULE_RETURN_CODE
WORKER_REQUEST::ProcessRequest(
    IWorkerRequest * pReq
    )
{
    MODULE_RETURN_CODE  mrc = MRC_OK;
    ULONG               rc  = NO_ERROR;

    IF_DEBUG( TRACE) {
        DBGPRINTF(( DBG_CONTEXT,
                "WORKER_REQUEST(%p)::ProcessRequest. IWorkerRequest: %p\n",
                this, pReq));
    }

    DBG_ASSERT( pReq == (IWorkerRequest *)this);

    WREQ_STATE state = QueryState();

    //
    // Examine the state machine to take appropriate actions
    //
    switch (state)
    {

    case WRS_FREE:
        {
            ULONG       state ;

            //
            // Call cleanup on all instatiated modules
            //

            for (state = 0; state < WRS_MAXIMUM; state++)
            {
                CleanupModule( (WREQ_STATE)state);
            }


            //
            // Close the connection to indicate End Of Request
            //

            if ( NULL != QueryModule(WRS_FETCH_URI_DATA))
            {
                CloseConnection();
            }


            //
            // Reset the worker request object
            //

            Reset();

        }
        break;      // case WRS_FREE

    case WRS_READ_REQUEST:
        {
            DWORD   cbData  =0;

            if ( WRREADREQUEST_NONE == m_ReadState)
            {
                //
                // We have not issued a read yet
                //

                UL_HTTP_CONNECTION_ID   reqId;

                UL_SET_NULL_ID(&reqId);

                //
                // Ask UL for any request. This may complete synchronously
                //

                rc = ReadHttpRequest(&cbData, reqId);
            }
            else
            {
                //
                // This is the Async IO completion callback
                //

                QueryAsyncIOStatus(&cbData, &rc);
            }

            //
            // Check to see if we need to resize buffer and resubmit read.
            //

            if (ERROR_MORE_DATA == rc)
            {
                //
                // cbData contains the buffer size needed to get the request.
                //

                if (m_pbRequest != m_rgchInlineRequestBuffer)
                {
                    delete [] m_pbRequest;
                    m_cbRequest = 0;
                }

                m_pbRequest = new UCHAR[cbData];

                if ( NULL != m_pbRequest)
                {
                    m_cbRequest = cbData;
                }
                else
                {
                    rc = ERROR_OUTOFMEMORY;
                    break;
                }

                //
                // DO NOT use QueryRequestID here because we have not
                // set the state to WRREADREQUEST_COMPLETED
                //

                rc = ReadHttpRequest(&cbData, QueryHttpRequest()->RequestId);
            }

            //
            // If Read is completed, do some post processing.
            //

            if ( NO_ERROR == rc)
            {
                m_ReadState = WRREADREQUEST_COMPLETED;

                rc = ParseHttpRequest();
            }

            //
            // Set Appropriate return Code
            //

            if (NO_ERROR != rc )
            {
                mrc = (ERROR_IO_PENDING == rc) ?  MRC_PENDING : MRC_ERROR;
            }
        }
        break;  // case WRS_READ_REQUEST

    default:
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unknown state (%d) entered for default ProcessRequest\n",
                        pReq->QueryState()
                        ));

            //mrc = MRC_ERROR;
            //DBG_ASSERT( FALSE);

        }
        break;  // default

    } // switch

    return mrc;

} // WORKER_REQUEST::DoWork()

/********************************************************************++

Routine Description:
    Submits read operation for the worker request.
    This is used for reading in the headers only at the start of requests.
    It uses the internal buffers maintained in the WORKER_REQUEST object
     and posts an asynchronous read operation.

Arguments:
    None

Returns:
    ULONG

--********************************************************************/

ULONG
WORKER_REQUEST::ReadHttpRequest(
    DWORD *             pcbRequiredLen,
    UL_HTTP_REQUEST_ID  reqId
    )
{
    ULONG               rc;

    DBG_ASSERT( m_pwpContext != NULL);
    DBG_ASSERT( m_pbRequest != NULL);

    //
    // Check if there is already Async IO pending.
    //

    if ( WRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an async IO request
    //

    ReferenceRequest(this);
    m_IOState = WRIO_READ;

    //
    // Submit async read operation for request.
    // Use overlapped for async reads.
    //

    m_ReadState = WRREADREQUEST_ISSUED;

    rc = UlReceiveHttpRequest(
            m_pwpContext->GetAsyncHandle(),
            reqId,
            0,
            (PUL_HTTP_REQUEST) m_pbRequest,
            m_cbRequest,
            pcbRequiredLen,
            &m_overlapped
            );

    if (ERROR_IO_PENDING != rc)
    {
        //
        // The read completed synchronously or there was an error.
        // Adjust the ref count immediately.
        //

         m_IOState = WRIO_NONE;
         DereferenceRequest( this);
    }

    return (rc);

} // WORKER_REQUEST::ReadHttpRequest()

/********************************************************************++
--********************************************************************/

ULONG
WORKER_REQUEST::ParseHttpRequest(void)
{
    //
    // Do some parsing here for Read stage.
    //

    PWSTR               pwszEndOfURL, pwszQuery, pwszAbsPath, pwszHost;
    PUL_HTTP_REQUEST    pHttpRequest = QueryHttpRequest();

    //
    // Set Host, URI & QueryString
    //

    pwszEndOfURL = (PWSTR) pHttpRequest->pFullUrl +
                            (pHttpRequest->FullUrlLength/sizeof(WCHAR));

    if (NULL != pHttpRequest->pQueryString)
    {
        pwszQuery = (PWSTR) pHttpRequest->pQueryString;

        //
        // Skip the '?' in QueryString
        //

        if ( !m_strQueryString.Copy(pwszQuery+1, DIFF(pwszEndOfURL - (pwszQuery+1))))
        {
            return ERROR_OUTOFMEMORY;
        }

    }
    else
    {
        pwszQuery = pwszEndOfURL;
    }

    if (NULL != pHttpRequest->pAbsPath)
    {
        pwszAbsPath = (PWSTR) pHttpRequest->pAbsPath;

        if ( !m_strURI.Copy(pwszAbsPath, DIFF(pwszQuery - pwszAbsPath)))
        {
            return ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        pwszAbsPath = pwszQuery;
    }


    if (0 != pHttpRequest->pHost)
    {
        //
        // BUGBUG: Hostname includes port number
        //

        pwszHost = (PWSTR) pHttpRequest->pHost;

        if ( !m_strHost.Copy(pwszHost, DIFF(pwszAbsPath - pwszHost)))
        {
            return ERROR_OUTOFMEMORY;
        }
    }

    return NO_ERROR;
}

/********************************************************************++

Routine Description:
    Submits a read operation to read in the entity body received for
    a given request. This function allows the WORKER_REQUEST to read
    in arbitrary data that client has sent for this request.

    The function can read from UL synchronously or asynchronous.

    If async read is requested the overlapped structure that is part
    of this request object will be used. Atmost ONE IO can be in
    progress. Check for the same as well.

Arguments:
    pbBuffer        - Buffer to read data into
    cbBuffer        - Size of buffer
    pcbBytesRead    - The number of bytes actually read when the call
                      completes.
    fAsync          - true  => Asynchronous read
                      false => Synchronous read

Returns:
    ULONG -   Win32 Error
    ERROR_ALREADY_WAITING  - There is already an IO in progress.

--********************************************************************/

ULONG
WORKER_REQUEST::ReadData(
   IN       PVOID   pbBuffer,
   IN       ULONG   cbBuffer,
   OUT      PULONG  pcbBytesRead,
   IN       bool    fAsync
   )
{
    DWORD   cbReceived;
    ULONG   rc = ERROR_SUCCESS;

    DBG_ASSERT(NULL != pbBuffer);
    DBG_ASSERT(0    <  cbBuffer);
    DBG_ASSERT(NULL !=  pcbBytesRead);

    //
    // Check if there is already Async IO pending.
    //

    if ( WRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an async IO request
    //

    ReferenceRequest(this);
    m_IOState = WRIO_READ;


    /*
    rc = UlReceiveEntityBody(
            m_pwpContext->GetAsyncHandle(),
            QueryRequestId(),
            pbBuffer,
            cbBuffer,
            pcbBytesRead,
            fAsync ? &m_overlapped : NULL
            );
    */

    //
    // Check if Async IO is pending
    //

    if ( fAsync && (ERROR_IO_PENDING == rc))
    {
        //
        // Good. Async IO is pending. Ignore the error
        //

        rc = NO_ERROR;
    }

    //
    // if t was a sync call or there is a failure adjust
    // the ref count immediately.
    //

    if ( (!fAsync)  || (NO_ERROR != rc) )
    {
        m_IOState = WRIO_NONE;
        DereferenceRequest( this);
    }

    return rc;
}

/********************************************************************++

Routine Description:
    This function sends the response using async Send operation.
    On success an async operation will be queued. There will be
    an IO completion callback when the io completes.

Arguments:
    pulResponse - ptr to UL response to send

Returns:
    ULONG
    The Async call originally returns ERROR_IO_PENDING which is mapped
    to NO_ERROR by this function.

--********************************************************************/

ULONG
WORKER_REQUEST::SendAsyncResponse( IN PUL_HTTP_RESPONSE_v1 pulResponse)
{
    DWORD     cbSent;
    ULONG     rc;

    DBG_ASSERT( pulResponse != NULL);

    //
    // Check if there is already Async IO pending.
    //

    if ( WRIO_NONE != m_IOState)
    {
        return ERROR_ALREADY_WAITING;
    }

    //
    // Bump up the reference count before making an async IO request
    //

    ReferenceRequest(this);
    m_IOState = WRIO_WRITE;

    //
    // Submit async send operation to send out the response.
    // Use overlapped structure for send operations
    //

    rc = UlSendHttpResponse(
            m_pwpContext->GetAsyncHandle(),
            QueryRequestId(),
            UL_SEND_RESPONSE_FLAG_MORE_DATA,        // Flags
            NULL,
            pulResponse->HeaderChunkCount + pulResponse->EntityBodyChunkCount,
            (PUL_DATA_CHUNK)(pulResponse + 1),
            NULL,
            &cbSent,
            &m_overlapped
            );

    if ( ERROR_IO_PENDING == rc)
    {
        //
        // Good. Async IO is pending. Ignore the error
        //
        rc = NO_ERROR;
    }

    //
    // if there is a failure adjust the ref count immediately.
    //

    if (NO_ERROR != rc)
    {
        m_IOState = WRIO_NONE;
        DereferenceRequest( this);
    }

    return (rc);
}

/********************************************************************++

Routine Description:
    This function sends the response using sync Send operation.

Arguments:
    pulResponse - ptr to UL response to send

Returns:
    ULONG - Win32 Error

--********************************************************************/

ULONG
WORKER_REQUEST::SendSyncResponse( IN PUL_HTTP_RESPONSE_v1 pulResponse)
{
    DWORD     cbSent;
    ULONG     rc;

    DBG_ASSERT( pulResponse != NULL);

    //
    // Bump up the reference count before making an async IO request
    //

    ReferenceRequest(this);

    //
    // Submit sync send (NO Overlapped) to send out the response.
    //

    rc = UlSendHttpResponse(
            m_pwpContext->GetAsyncHandle(),
            QueryRequestId(),
            UL_SEND_RESPONSE_FLAG_MORE_DATA,
            NULL,
            pulResponse->HeaderChunkCount + pulResponse->EntityBodyChunkCount,
            (PUL_DATA_CHUNK)(pulResponse + 1),
            NULL,
            &cbSent,
            NULL
            );

    DereferenceRequest( this);

    return rc;
}

/********************************************************************++

Routine Description:
    This function forces a close operation on the connection object.
    A connection close will result in aborted IO operations if any
    pending.

    BUGBUG: If there are no async IO pending then we need to try alternate
    ways of cleaning up this object.

Arguments:
    None

Returns:
    None

--********************************************************************/
bool
WORKER_REQUEST::CloseConnection(void)
{

    if ( WRREADREQUEST_COMPLETED != m_ReadState)
    {
        //
        // We have no Connection ID yet. Return success
        //

        return true;
    }

#ifdef UL_SIMULATOR_ENABLED

    PUL_HTTP_REQUEST pulRequest = (PUL_HTTP_REQUEST ) m_pbRequest;

    if ( pulRequest != NULL)
    {
        UlsimCloseConnection( pulRequest->ConnectionId);
    }

    return TRUE;

#else

    ULONG               rc;

    //
    // Call SendResponse with flags = 0 to indicate end of request
    //

    rc = UlSendHttpResponse(
            m_pwpContext->GetAsyncHandle(),
            QueryRequestId(),
            0,                                  // Flags
            NULL,
            0,                                  // DataChunkCount
            NULL,
            NULL,                               // pCachePolicy
            NULL,
            NULL
            );

    return (NO_ERROR == rc);

#endif

} // WORKER_REQUEST::CloseConnection()

//
//  Define a quick default property size lookup table for GetInfoForId().
//
#define PROPERTYSIZEUNKNOWN                 0
#define SetInitPropertySize(id, size)       size

size_t DefaultPropertySize[] = {
    SetInitPropertySize(PROPID_ECB,                 PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_KeepConn,            sizeof(DWORD)),
    SetInitPropertySize(PROPID_ImpersonationToken,  PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_CertficateInfo,      PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_VirtualPathInfo,     PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_ExecuteFlags,        sizeof(DWORD)),
    SetInitPropertySize(PROPID_AppPhysicalPath,     PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_AppVirtualPath,      PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_ExtensionPath,       PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_AsyncIOCBData,       sizeof(DWORD)),
    SetInitPropertySize(PROPID_AsyncIOError,        sizeof(DWORD)),
    SetInitPropertySize(PROPID_PhysicalPath,        PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_PhysicalPathLen,     sizeof(DWORD)),
    SetInitPropertySize(PROPID_VirtualPath,         PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_VirtualPathLen,      sizeof(DWORD)),
    SetInitPropertySize(PROPID_MAX,                 PROPERTYSIZEUNKNOWN),
    SetInitPropertySize(PROPID_MAX,                 PROPERTYSIZEUNKNOWN)
};
/********************************************************************++

Routine Description:

Arguments:
    None

Returns:
    None

--********************************************************************/

HRESULT
WORKER_REQUEST::GetInfoForId(
    IN  UINT     PropertyId,
    OUT PVOID    pBuffer,
    IN  UINT     BufferSize,
    OUT UINT*    pRequiredBufferSize
    )
{
    HRESULT     hr      = NOERROR;
    PURI_DATA   pUriData= (PURI_DATA) QueryModule(WRS_FETCH_URI_DATA);

    //
    //  Validate the input parameters.
    //
    //if (pBuffer == NULL ||
      if ( PropertyId >= PROPID_MAX )
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    //  For the fixed-size property, check the input buffer size.
    //
    if (DefaultPropertySize[PropertyId] != PROPERTYSIZEUNKNOWN &&
        BufferSize < DefaultPropertySize[PropertyId])
    {
        *pRequiredBufferSize = DefaultPropertySize[PropertyId];
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    // Presets pRequiredbufferSize to the DefaultPropertySize.
    // Property with variant size needs to sets the pRequiredBufferSize to
    // proper value.
    *pRequiredBufferSize = DefaultPropertySize[PropertyId];

    //  Buffer is large enough for the next step.
    //
    //  Calculate the variant size property size or value.
    //  Fill in the fixed size property.
    //
    UINT        RequiredBufferSize = 0;
    switch (PropertyId)
    {
        case PROPID_ECB:

        RequiredBufferSize  =   sizeof(_EXTENSION_CONTROL_BLOCK);

        RequiredBufferSize  +=  (pUriData->QueryPhysicalPath())->QueryCBA();
        RequiredBufferSize  +=  (pUriData->QueryUri())->QueryCBA();
        RequiredBufferSize  +=  m_strQueryString.QueryCBA();
        RequiredBufferSize  +=  m_strMethod.QueryCBA();
        RequiredBufferSize  +=  m_strContentType.QueryCBA();

        RequiredBufferSize += 6*sizeof(CHAR);


        if (BufferSize < RequiredBufferSize)
        {
            *pRequiredBufferSize = RequiredBufferSize;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        else
        {
        _EXTENSION_CONTROL_BLOCK *  pECB;
        /*
        HCONN     ConnID;                 // Context number not to be modified!
        DWORD     dwHttpStatusCode;       // HTTP Status code
        CHAR      lpszLogData[HSE_LOG_BUFFER_LEN];// null terminated log info specific to this Extension DLL

        LPSTR     lpszMethod;             // REQUEST_METHOD
        LPSTR     lpszQueryString;        // QUERY_STRING
        LPSTR     lpszPathInfo;           // PATH_INFO
        LPSTR     lpszPathTranslated;     // PATH_TRANSLATED

        DWORD     cbTotalBytes;           // Total bytes indicated from client
        DWORD     cbAvailable;            // Available number of bytes
        LPBYTE    lpbData;                // pointer to cbAvailable bytes

        LPSTR     lpszContentType;        // Content type of client data
        */

        pECB =  static_cast<_EXTENSION_CONTROL_BLOCK *>(pBuffer);

        pECB->cbSize            =   sizeof(_EXTENSION_CONTROL_BLOCK);
        pECB->dwVersion         =   MAKELONG( HSE_VERSION_MINOR,
                                              HSE_VERSION_MAJOR);

        pECB->ConnID            =   (HCONN)this;

        pECB->dwHttpStatusCode  =   200;
        pECB->lpszLogData[0]    =   '\0';

        CHAR* pTemp = (CHAR*)(pECB+1);


        pECB->lpszMethod    = pTemp;
        memcpy(pTemp, m_strMethod.QueryStrA(), m_strMethod.QueryCBA()+1);
        pTemp += m_strMethod.QueryCBA()+1;


        pECB->lpszQueryString = pTemp;
        memcpy(pTemp, m_strQueryString.QueryStrA(), m_strQueryString.QueryCBA()+1);
        pTemp += m_strQueryString.QueryCBA()+1;

        pECB->lpszPathInfo = pTemp;
        memcpy(pTemp, (pUriData->QueryUri())->QueryStrA(), (pUriData->QueryUri())->QueryCBA()+1);
        pTemp += (pUriData->QueryUri())->QueryCBA()+1;

        pECB->lpszContentType = pTemp;
        memcpy(pTemp, m_strContentType.QueryStrA(), m_strContentType.QueryCBA()+1);
        pTemp += m_strContentType.QueryCBA()+1;

        pECB->lpszPathTranslated = pTemp;
        memcpy(pTemp, (pUriData->QueryPhysicalPath())->QueryStrA(),
                (pUriData->QueryPhysicalPath())->QueryCBA()+1);
        pTemp += (pUriData->QueryPhysicalPath())->QueryCBA()+1;

        pECB->cbTotalBytes  = 0;
        pECB->cbAvailable   = 0;
        pECB->lpbData       = NULL;
        }

        break;

    case    PROPID_KeepConn:

        /*This flag might be retrieved from the local flag or flag from connection */
        break;

    case    PROPID_ImpersonationToken:



        break;

    case    PROPID_CertficateInfo:

        break;

    case    PROPID_VirtualPathInfo:

        break;
    case    PROPID_ExecuteFlags:

        break;
    case    PROPID_AppPhysicalPath:

        break;
    case    PROPID_AppVirtualPath:

        break;
    case    PROPID_ExtensionPath:
        {
            *pRequiredBufferSize = (pUriData->QueryExtensionPath())->QueryCBW()+
                                    sizeof(WCHAR);

            if (BufferSize < *pRequiredBufferSize)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                break;
            }

            memcpy(pBuffer,
                (pUriData->QueryExtensionPath())->QueryStrW(), *pRequiredBufferSize);

            hr = NOERROR;
        }

        break;

     case   PROPID_AsyncIOCBData:
        {
            *(DWORD*)pBuffer = m_cbAsyncIOData;
            hr = NOERROR;
        }
        break;
     case   PROPID_AsyncIOError:
        {
            *(DWORD*)pBuffer = m_dwAsyncIOError;
            hr = NOERROR;
        }
        break;

    case    PROPID_URL:
        {
            *pRequiredBufferSize = (pUriData->QueryUri())->QueryCBA()+
                                    sizeof(CHAR);

            if (BufferSize < *pRequiredBufferSize)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                break;
            }

            if (pBuffer)
            {
                memcpy(pBuffer,
                    (pUriData->QueryExtensionPath())->QueryStrA(), *pRequiredBufferSize);
            }

            hr = NOERROR;
        }

    default:

            ;
    }
    return hr;
}

HRESULT
WORKER_REQUEST::AsyncRead(
    IN  IExtension* pExtension,
    OUT PVOID       pBuffer,
    IN  DWORD       NumBytesToRead
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

/************************************************************++
SyncRead

    Read data from http client connection synchronously.

Input:
    pBuffer         pointer to the data buffer.
    NumBytesToRead  Number of bytes to be readed.
    pNumBytesRead   pointer to the number of bytes read by SyncRead operation.
Return:
 --************************************************************/

HRESULT
WORKER_REQUEST::SyncRead(
    OUT PVOID       pBuffer,
    IN  UINT        NumBytesToRead,
    OUT UINT*       pNumBytesRead
    )
{
    HRESULT hr = NOERROR;

    if (pBuffer == NULL || pNumBytesRead == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // NYI
    //
    //
    return ERROR_CALL_NOT_IMPLEMENTED;
}

bool
WORKER_REQUEST::IsClientConnected(
    void
    )
{
    return TRUE;
}

HRESULT
WORKER_REQUEST::SendHeader(
    PUL_DATA_CHUNK  pHeader,
    bool            KeepConnectionFlag,
    bool            HeaderCacheEnableFlag
    )
{
    HRESULT hr = NOERROR;

    if (pHeader == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    BYTE    ResponseBuffer[sizeof(UL_HTTP_RESPONSE_v1)+sizeof(UL_DATA_CHUNK)];

    PUL_HTTP_RESPONSE_v1 pUlHttpResponse;
    PUL_DATA_CHUNK      pUlDataChunk;

    pUlHttpResponse         = (PUL_HTTP_RESPONSE_v1)(ResponseBuffer);

    pUlHttpResponse->Flags  = ( UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH |
                                UL_HTTP_RESPONSE_FLAG_CALC_ETAG);

    pUlHttpResponse->HeaderChunkCount       = 1;
    pUlHttpResponse->EntityBodyChunkCount   = 0;


    pUlDataChunk                = (PUL_DATA_CHUNK)(pUlHttpResponse+1);

    memcpy(pUlDataChunk, pHeader, sizeof(UL_DATA_CHUNK));

    //
    // TODO: Combine SendSyncResponse and SendAsyncResponse
    //

    hr = SendSyncResponse(pUlHttpResponse);

    return hr;
}

HRESULT
WORKER_REQUEST::AppendToLog(
    LPCWSTR LogEntry
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}


HRESULT
WORKER_REQUEST::Redirect(
    LPCWSTR RedirectURL
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}

/********************************************************************++

Routine Description:

Arguments:
Returns:
   HRESULT
   NOERROR on successful return.


--********************************************************************/
HRESULT
WORKER_REQUEST::SyncWrite(
    PUL_DATA_CHUNK  pData,
    ULONG*          pDataSizeWritten
    )
{
    HRESULT hr = NOERROR;

    if (pData == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    BYTE    ResponseBuffer[sizeof(UL_HTTP_RESPONSE_v1)+sizeof(UL_DATA_CHUNK)];

    PUL_HTTP_RESPONSE_v1   pUlHttpResponse;
    PUL_DATA_CHUNK      pUlDataChunk;
    UL_BYTE_RANGE       *pUlByteRange;

    pUlHttpResponse         = (PUL_HTTP_RESPONSE_v1)(ResponseBuffer);

    pUlHttpResponse->Flags  = ( UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH |
                                UL_HTTP_RESPONSE_FLAG_CALC_ETAG);

    pUlHttpResponse->HeaderChunkCount       = 0;
    pUlHttpResponse->EntityBodyChunkCount   = 1;

    pUlDataChunk            = (PUL_DATA_CHUNK)(pUlHttpResponse+1);

    memcpy(pUlDataChunk, pData, sizeof(UL_DATA_CHUNK));

    //
    // TODO: Combine SendSyncResponse and SendAsyncResponse
    //
    hr = SendSyncResponse(pUlHttpResponse);

    return hr;
}

HRESULT
WORKER_REQUEST::AsyncWrite(
    PUL_DATA_CHUNK  pData,
    ULONG*          pDataSizeWritten
    )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
}



/********************************************************************++
  Description:
     The function supports the transmitfile api for worker request.  The input
     parameter LPHSE_TF_INFO has a bunch stuff.  Most important member is a file
     handle.  The file handle is also supported by UL_DATA_CHUNK.

    This structure also specifies a byte range, and additional header and tail buffer
    around the transmitted data.

    Well, we just need to add more UL_DATA_CHUNK here.

  Arguments:

  Returns:
     HRESULT
--********************************************************************/
HRESULT
WORKER_REQUEST::TransmitFile(
    LPHSE_TF_INFO   pTransmitFileInfo
    )
{
    HRESULT hr = NOERROR;

    if (pTransmitFileInfo == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if (pTransmitFileInfo->pfnHseIO == NULL ||
        pTransmitFileInfo->pContext == NULL ||
        pTransmitFileInfo->hFile == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // Initial DataChunkCount is 1 for the filehandle datachunk.
    // Add more chunks for StatusCode, Head, and Tail if necessary.
    UINT    DataChunkCount  = 1;
    bool    ChunksHasHeader = FALSE;
    bool    ChunksHasHead   = FALSE;
    bool    ChunksHasTail   = FALSE;

    if (pTransmitFileInfo->pszStatusCode != NULL)
    {
        DataChunkCount++;
        ChunksHasHeader = TRUE;
    }

    if (pTransmitFileInfo->pHead != NULL)
    {
        DataChunkCount++;
        ChunksHasHead = TRUE;
    }

    if (pTransmitFileInfo->pTail != NULL)
    {
        DataChunkCount++;
        ChunksHasTail = TRUE;
    }

    // Stack overflow exception will be generated if the program
    // can not allocate memory on the stack.
    BYTE *pResponseBuffer = (BYTE *)_alloca(sizeof(UL_HTTP_RESPONSE_v1)+
                                        DataChunkCount*sizeof(UL_DATA_CHUNK));

    DBG_ASSERT(pResponseBuffer != NULL);

    PUL_HTTP_RESPONSE_v1   pUlHttpResponse;
    PUL_DATA_CHUNK      pUlDataChunk;
    UL_BYTE_RANGE       *pUlByteRange;

    pUlHttpResponse         = (PUL_HTTP_RESPONSE_v1)(pResponseBuffer);

    pUlHttpResponse->Flags  = ( UL_HTTP_RESPONSE_FLAG_CALC_CONTENT_LENGTH |
                                UL_HTTP_RESPONSE_FLAG_CALC_ETAG);

    pUlHttpResponse->HeaderChunkCount = (ChunksHasHeader) ? 1 : 0;

    pUlHttpResponse->EntityBodyChunkCount   =   DataChunkCount -
                                                pUlHttpResponse->HeaderChunkCount;

    pUlDataChunk    = (PUL_DATA_CHUNK)(pUlHttpResponse+1);

    // Data chunk for http status header
    if (ChunksHasHeader)
    {
        (pUlDataChunk->FromMemory).pBuffer      = (PVOID)pTransmitFileInfo->pszStatusCode;
        (pUlDataChunk->FromMemory).BufferLength = strlen(pTransmitFileInfo->pszStatusCode);
        pUlDataChunk->DataChunkType             = UlDataChunkFromMemory;
        pUlDataChunk++;
    }

    // Data chunk for data head
    if (ChunksHasHead)
    {
        (pUlDataChunk->FromMemory).pBuffer      = pTransmitFileInfo->pHead;
        (pUlDataChunk->FromMemory).BufferLength = pTransmitFileInfo->HeadLength;
        pUlDataChunk->DataChunkType             = UlDataChunkFromMemory;
        pUlDataChunk++;
    }

    // File Handle, at this point, there is always a UL_DATA_CHUNK for file handle.
    pUlByteRange = &(pUlDataChunk->FromFileHandle.ByteRange);
    pUlByteRange->StartingOffset.LowPart        = pTransmitFileInfo->Offset;
    pUlByteRange->StartingOffset.HighPart       = 0;
    pUlByteRange->Length.LowPart                = pTransmitFileInfo->BytesToWrite;
    pUlByteRange->Length.HighPart               = 0;
    (pUlDataChunk->FromFileHandle).FileHandle   = pTransmitFileInfo->hFile;
    pUlDataChunk->DataChunkType                 = UlDataChunkFromFileHandle;

    // Data chunk for data tail
    if (ChunksHasTail)
    {
        (pUlDataChunk->FromMemory).pBuffer      = pTransmitFileInfo->pTail;
        (pUlDataChunk->FromMemory).BufferLength = pTransmitFileInfo->TailLength;
        pUlDataChunk->DataChunkType             = UlDataChunkFromMemory;
        pUlDataChunk++;
    }

    //
    // TODO: Combine SendSyncResponse and SendAsyncResponse
    //
    hr = SendAsyncResponse(pUlHttpResponse);

    return hr;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\wpcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     wpcontext.cxx

   Abstract:
     This module defines the member functions of the WP_CONTEXT.
     The WP_CONTEXT object embodies an instance of the Worker process
     object. It contains a completion port, pool of worker threads, 
     pool of worker requests, a data channel for the worker process, etc.
     It is responsible for setting up the context for processing requests
     and handles delegating the processing of requests.

     NYI: In the future we should be able to run WP_CONTEXT object as 
     a COM+ object and be run standalone using a hosting exe. 

   Author:

       Murali R. Krishnan    ( MuraliK )     17-Nov-1998

   Project:

       IIS Worker Process 

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include <stdio.h>
# include <conio.h>
# include <io.h>

/************************************************************
 *    Functions 
 ************************************************************/


WP_CONTEXT::WP_CONTEXT(void)
    : m_hDoneEvent ( NULL),
      m_ulAppPool(),
      m_cp(),
      m_wreqPool(),
      m_pConfigInfo ( NULL)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Initialized WP_CONTEXT(%08x)\n", this));
    }

} // WP_CONTEXT::WP_CONTEXT()


WP_CONTEXT::~WP_CONTEXT(void)
{
    IF_DEBUG( INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT, "Destroying WP_CONTEXT(%08x)\n", this));
    }

    Cleanup();

} // WP_CONTEXT::WP_CONTEXT()



/********************************************************************++

Routine Description:
    Initializes the global state for the request processor.
    The function initializes all the following components:
    - Data Channel for UL
    - Thread pool for 

Arguments:
    ConfigInfo - configuration information for this Worker process.

Returns:
    ULONG

    NYI: There are several other configuration paramaters that are important.
    However at the present point, not all config parameters 
    are allowed in here.

--********************************************************************/

ULONG
WP_CONTEXT::Initialize(IN WP_CONFIG * pConfigInfo)
{
    ULONG       rc = NO_ERROR;
    LPCWSTR     pwszAppPoolName;

    m_pConfigInfo = pConfigInfo;
    
    pwszAppPoolName = m_pConfigInfo->QueryAppPoolName();
    
    rc = m_ulAppPool.Initialize(pwszAppPoolName);
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR) 
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "Failed to initialize AppPool\n"));
        }
        return (rc);
    }

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "AppPool Initialized\n"));
    }

    //
    // Initialize of the shutdown event
    //
    
    m_hDoneEvent = IIS_CREATE_EVENT( 
                       "WP_CONTEXT::m_hDoneEvent",  // name
                       &m_hDoneEvent,               // address of storage loc
                       TRUE,                        // manual reset
                       FALSE                        // Initial State
                       );
    
    if (m_hDoneEvent == NULL) 
    {
        rc = GetLastError();
        
        IF_DEBUG(ERROR)
        {
            DPERROR(( DBG_CONTEXT, rc,
                      "Failed to create DoneEvent.\n"
                      ));
        }

        return (rc);
    }
    
    //
    // Initialize Completion ports for handling IO operations
    // NYI: allow thread pool configuration
    //
    
    rc = m_cp.Initialize( INITIAL_CP_THREADS, MAX_CP_THREADS);

    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR) 
        {
           DPERROR(( DBG_CONTEXT, rc, "Failed in initializing the completion port/thread pool\n"));
        }

        return (rc);
    }

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Completion Port Initialized\n"));
    }


#ifdef UL_SIMULATOR_ENABLED

    rc = UlsimAssociateCompletionPort(
              m_ulAppPool.GetHandle(),
              m_cp.QueryCompletionPort(),
              (ULONG_PTR ) this);
              
#else

    //
    //  Associate data channel and the WP_CONTEXT object with completion port
    //
    
    rc = m_cp.AddHandle( this);
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                "Failed to add App Pool handle to completion port. Error=0x%08x\n",
                 rc
                 ));
        }
        
        return (rc);
    }
#endif

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Added Data channel to CP context\n"));
    }

    //
    // Create a pool of worker requests
    // NYI: Allow the worker requests limit to be configurable.
    //
    
    rc = m_wreqPool.AddPoolItems( this, 
                                  NUM_INITIAL_REQUEST_POOL_ITEMS
                                  );
    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Failed to add pool of worker requests. Error=%08x\n", rc
                ));
        }

        return (rc);
    }

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, "Created WORKER_REQUEST pool\n"));
    }


    //
    // Initialize IPM if requested to
    //

    if ( m_pConfigInfo->FRegisterWithWAS())
    {
        rc = m_WpIpm.Initialize(this);
    
        if (NO_ERROR != rc) 
        {
            IF_DEBUG( ERROR) 
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize IPM. Error=0x%08x\n", rc
                    ));
            }

            //
            //BUGBUG: Non fatal error for now
            //
            // return (rc);

            rc = NO_ERROR;
        }
        else
        {
            IF_DEBUG( TRACE) 
            {
                DBGPRINTF(( DBG_CONTEXT, "Initialized IPM\n"));
            }

        }
    }

    return (rc);

} // WP_CONTEXT::Initialize()



/********************************************************************++

Routine Description:
  This function cleans up the sub-objects inside WP_CONTEXT.
  It first forces a close of the handle and then waits for all
    the objects to drain out.

  NYI: Do two-phase shutdown logic

Arguments:
    None

Returns:
    WIn32 Error

--********************************************************************/

ULONG
WP_CONTEXT::Cleanup(void)
{
    ULONG rc;

    //
    // shut down IPM
    //

    if ( m_pConfigInfo->FRegisterWithWAS())
    {
        rc = m_WpIpm.Terminate();
    
        if (NO_ERROR != rc) 
        {
            IF_DEBUG( ERROR)
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Couldn't shut down IPM. Error=0x%08x\n",
                            rc));
            }
        } 
    }

    //
    // Indicate shutdown mode to Completion port
    //
    
    rc = m_cp.SetShutdown();

    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed in COMPLETION_PORT::SetShutdown(). Error=%08x\n",
                        rc));
        }
        
        return (rc);
    }

    // 
    // Remove the CP_CONTEXT from the Completion port. 
    // A close of the AppPool should help
    //

    rc = m_ulAppPool.Cleanup();

    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed in UL_APP_POOL::CloseHandle(). Error=%08x\n",
                        rc));
        }
        
        return (rc);
    }

    //
    // Synchronize for shutdown
    //
    rc = m_cp.SynchronizeWithShutdown();

    if (NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed in COMPLETION_PORT::SynchronizeWithShutdown(). \
                        Error=%08x\n",
                        rc));
        }
        
        return (rc);
    }

    rc = m_wreqPool.ReleaseAllWorkerRequests();
    
    if (NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "Cleanup Global State for Worker Requests failed; Error=%08x\n", 
                       rc));
        }
        return (rc);
    }

    //
    // Do the real cleanups
    //
    
    rc = m_cp.Cleanup();

    return rc;
    
} // WP_CONTEXT::Cleanup()


/********************************************************************++

Routine Description:
  CompletionCallBack() is called when an async IO completes. One of the 
  completion port thread pools call into this function with IO status code.
  The function identifies the request object associated with the completed IO
  and calls the request object for further processing.

Arguments:
  cbData  - count of bytes of data involved in the IO operation
  dwError - DWORD containing the error code for last IO operation
  lpo     - pointer to overlapped IO structure assocaited with last 
            IO operation.
Returns:
    HRESULT
--********************************************************************/
void
WP_CONTEXT::CompletionCallback(
    IN DWORD cbData,
    IN DWORD dwError,
    IN LPOVERLAPPED lpo
    )
{
    HRESULT hr;
    
    PWORKER_REQUEST pwr;

    IF_DEBUG( TRACE) 
    {
        DBGPRINTF(( DBG_CONTEXT, 
                    "Entering %08x::ProcessCompletion( cbData=%d, cbError=%d,"
                    " lpo=%08x)\n",
                    this, cbData, dwError, lpo
                    ));
    }

    if ( (lpo == NULL) ) 
    {

        DBGPRINTF(( DBG_CONTEXT, "NULL Overlapped. Cleanup and get out of here\n"));
        
        DBG_ASSERT( dwError != NO_ERROR);
        DBG_ASSERT( FALSE);
        return;
    }

    if ( m_wreqPool.NumItemsInPool() < NUM_INITIAL_REQUEST_POOL_ITEMS) {

        //
        // Add a fixed # of pooled items to the outstanding request pool
        //
        
        (void )m_wreqPool.AddPoolItems( this, REQUEST_POOL_INCREMENT);

        //
        // ignore the return value here.
        //
    }
    
    //
    // Find the worker request using the overlapped structure.
    //
    
    pwr = CONTAINING_RECORD( lpo, WORKER_REQUEST, m_overlapped);
    DBG_ASSERT( pwr != NULL);

    //
    // Call the processing function for the WORKER_REQUEST
    //

    ReferenceRequest( pwr);
    hr = pwr->DoWork( cbData, dwError, lpo);
    DBG_ASSERT( SUCCEEDED(hr));
    DereferenceRequest(pwr);

    return;
}  // WP_CONTEXT::CompletionCallback()



/********************************************************************++

Routine Description:
  The main thread watches inputs and handles requests for processing requests.
  When shutdown is requested, This thread will initiate the shutdown operations
  and cleanup all assocaited objects.
  NYI: Temporarily it reads "stdin" every PERIODIC_CHECK_INTERVAL seconds
   to see if this process should be termintaed.

Arguments:
  None

Returns:
  Win32 Error
--********************************************************************/

# define PERIODIC_CHECK_INTERVAL  1000  // 1 second

ULONG 
WP_CONTEXT::RunMainThreadLoop(void)
{
    bool   fShutdown = false;

    if ( m_pConfigInfo->FInteractiveConsole())
    {
        //
        // put up the command prompt
        //
        
        wprintf( L"WP>");
    }

    do 
    {
        DWORD dwWait;

        dwWait = MsgWaitForMultipleObjects( 1,
                                            &m_hDoneEvent,
                                            FALSE,
                                            PERIODIC_CHECK_INTERVAL,
                                            QS_ALLINPUT
                                          );
                                        
        switch (dwWait) 
        {
            case WAIT_OBJECT_0: 
                {
                    fShutdown = true;
                    
                    IF_DEBUG( TRACE) 
                    {
                        DBGPRINTF(( DBG_CONTEXT, 
                                    "Shutdown signalled. Exiting the program\n"
                                 ));
                    }
                    break;
                }

            case WAIT_OBJECT_0+1:
                {
                    //
                    // Message in the message queue
                    //
                }
            
            default:
            case WAIT_TIMEOUT: 
                {
                /*
                    if ( m_pConfigInfo->FInteractiveConsole())
                    {
                        int     ch;
                        CHAR    pszCommand[200];
                        //
                        // Console data to be read here.
                        //
        
                        IF_DEBUG(TRACE) 
                        {
                            DBGPRINTF(( DBG_CONTEXT, "Checking for input\n"));
                        }

                        //
                        // there is some input. Monitor and terminate if needed.
                        //

                        ungetc(0xFF, stdin);

                        scanf( "%s", pszCommand);
            
                        wprintf( L" Got the command [%S]\n", pszCommand+1);

                        if ( !lstrcmpiA(pszCommand+1, "Quit")) 
                        {
                            IndicateShutdown();
                        }

                        //
                        // put up the command prompt
                        //
        
                        wprintf( L"WP>");

                    }
                  */
                    break;
                }
                
        } // switch

    } while ( !fShutdown);

    //
    // NYI: cleanup happens after we return from this function.
    //

    return (NO_ERROR);
    
} // WP_CONTEXT::RunMainThreadLoop()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\wpipm.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wpipm.cxx

Abstract:

    Contains the WPIPM class that handles communication with
    the admin service. WPIPM responds to pings, and tells
    the process when to shut down.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include <precomp.hxx>
#include "wpipm.hxx"
#include "ipm_io_c.hxx"




/***************************************************************************++

Routine Description:

    Initializes WPIPM.
    
Arguments:

    pWpContext - pointer to the wp context (so we can tell it to shutdown)
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::Initialize(
    WP_CONTEXT * pWpContext
    )
{
    HRESULT        hr = S_OK;
    IO_FACTORY_C * pFactory;
    STRU           strPipeName;

    m_pWpContext      = pWpContext;
    m_pMessageGlobal  = NULL;
    m_pPipe           = NULL;
    m_hTerminateEvent = NULL;

    //
    // create MESSAGE_GLOBAL
    //
    pFactory = new IO_FACTORY_C(&(pWpContext->m_cp));
    if (pFactory) {
        m_pMessageGlobal = new MESSAGE_GLOBAL(pFactory);

        if (m_pMessageGlobal) {
            hr = m_pMessageGlobal->InitializeMessageGlobal();
        } else {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // create the MESSAGE_PIPE and termination event
    //
    if (SUCCEEDED(hr)) {
        m_hTerminateEvent = CreateEvent(
                                NULL,  // default security
                                TRUE,  // manual reset
                                FALSE, // initial state
                                NULL   // unnamed
                                );

        if (m_hTerminateEvent) {
            hr = m_pMessageGlobal->CreateMessagePipe(
                        this,
                        &m_pPipe
                        );
        } else {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // connect the MESSAGE_PIPE
    //
    if (SUCCEEDED(hr)) {
        hr = strPipeName.Copy(IPM_NAMED_PIPE_NAME);

        if (SUCCEEDED(hr)) {
            hr = m_pMessageGlobal->ConnectMessagePipe(
                        strPipeName,
                        pWpContext->m_pConfigInfo->GetNamedPipeId(),
                        m_pPipe
                        );
        }
    }


    if (FAILED(hr)) {
        // pipe takes care of itself
        m_pPipe = NULL;
        
        Terminate();
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    Terminates WPIPM.

    If the message pipe is open this function will disconnect it
    and wait for the pipe's disconnection callback.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::Terminate(
    VOID
    )
{
    HRESULT hr = S_OK;
    HRESULT hrGlobalTerminate;
    DWORD   dwWaitResult;

    if (m_pMessageGlobal) {
        if (m_pPipe) {
            hr = m_pMessageGlobal->DisconnectMessagePipe(m_pPipe);
            m_pPipe = NULL;
            // pipe deletes itself

            if (SUCCEEDED(hr)) {
                dwWaitResult = WaitForSingleObject(
                                    m_hTerminateEvent,
                                    INFINITE
                                    );

            }
        }

        hrGlobalTerminate = m_pMessageGlobal->TerminateMessageGlobal();

        if (SUCCEEDED(hr)) {
            hr = hrGlobalTerminate;
        }

        m_pMessageGlobal = NULL;
    }

    m_pWpContext = NULL;

    if (m_hTerminateEvent) {
        CloseHandle(m_hTerminateEvent);
    }

    return hr;
}


/***************************************************************************++

Routine Description:

    This is a callback from the message pipe that means
    the pipe has received a message.
    
    We decode the message and respond appropriately.
    
Arguments:

    pPipeMessage - the message that we received
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::AcceptMessage(
    IN const MESSAGE * pPipeMessage
    )
{
    HRESULT hr;

    switch (pPipeMessage->GetOpcode()) {
    case IPM_OP_PING:
        hr = HandlePing();
        break;

    case IPM_OP_SHUTDOWN:
        hr = HandleShutdown();
        break;

    default:
        DBG_ASSERT(FALSE);
        hr = E_FAIL;
        break;
    }

    return hr;
}



/***************************************************************************++

Routine Description:

    This is a callback from the message pipe that means
    the pipe has been disconnected and you won't be receiving
    any more messages.
    
    Tells WPIPM::Terminate that it's ok to exit now.
    
Arguments:

    hr - the error code associated with the pipe disconnection
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::PipeDisconnected(
    IN HRESULT hr
    )
{
    //
    // CODEWORK: should we do something with the parameter?
    //


    //
    // If the pipe disappears out from under us, assume the WAS has
    // gone bad, and initiate clean shutdown of this worker process.
    //

    m_pWpContext->IndicateShutdown();


    if (SetEvent(m_hTerminateEvent)) {
        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(GetLastError());
    }
}


/***************************************************************************++

Routine Description:

    Handles the ping message. Sends the ping response message.
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::HandlePing(
    VOID
    )
{
    HRESULT hr;

    hr = m_pPipe->WriteMessage(
                IPM_OP_PING_REPLY,  // ping reply opcode
                0,                  // no data to send
                NULL                // pointer to no data
                );

    return hr;
}


/***************************************************************************++

Routine Description:

    Handles the shutdown message. Shuts down the process
    
Arguments:

    None.
    
Return Value:

    HRESULT

--***************************************************************************/
HRESULT
WP_IPM::HandleShutdown(
    VOID
    )
{
    HRESULT hr = S_OK;

    //
    // BUGBUG: Surely this is not the right way out!
    //
    // ExitProcess(NO_ERROR);

    m_pWpContext->IndicateShutdown();
    return hr;
}


//
// end of wpipm.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\wpconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     WpConfig.cxx

   Abstract:
     Module implementing the Worker Process Configuration Data structure.
     WP_CONFIG object encapsulates configuration supplied from the commandline
     as well as remotely supplied from the admin process.
 
   Author:

       Murali R. Krishnan    ( MuraliK )     21-Oct-1998

   Environment:
       Win32 - User Mode

   Project:
	   IIS Worker Process
--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"


const WCHAR g_rgchUsage[] = 
L"Usage: %s [options] APN\n"
L"\tAPN -- AppPool Name\n"
L"\t-d <URL List> -- Indicates that the process should register the given \n"
L"\t\tnamespace itself. This mode is for running worker process in\n"
L"\t\tstand alone mode (for debugging)\n"
L"\t-c  -- include an interactive console session. The console session uses\n"
L"\t\t stdin and stdout for controlling the administration process\n"
L"\t-l  -- Log errors that stop the worker process into the eventlog\n"
L"\t-ld -- Disables logging the errors of worker process to eventlog\n"
L"\t\t(default is not write to eventlog)\n"
L"\t-a  -- Look for web admin service and register with the same\n"
L"\t\t(default is look for web admin service)\n"
L"\t-ad -- Do not look for web admin service and do registration\n"
L"\t<URL List> uses the syntax: {http[s]://IP:port/URL | http[s]://hostname:port/URL }+\n"
L"\t\twith space as separator\n"
L"\t\t eg: -d http://localhost:80/  => listen for all HTTP requests on port 80\n"
L"\t\t eg: -d http://localhost:80/ http://localhost:81/  => listen on port 80 & 81\n"
;

/************************************************************
 *     Member functions of WP_CONFIG
 ************************************************************/

WP_CONFIG::WP_CONFIG(void)
    : m_pwszAppPoolName     ( AP_NAME),
      m_fSetupControlChannel( false),
      m_fLogErrorsToEventLog( false),
      m_fRegisterWithWAS    ( true),
      m_fInteractiveConsole ( true),
      m_NamedPipeId         ( 0   )
{
    lstrcpy( m_pwszProgram,  L"WP");
}


void
WP_CONFIG::PrintUsage() const
{ 
    wprintf( g_rgchUsage, m_pwszProgram);
}

/********************************************************************++

Routine Description:
    Parses the command line to read in all configuration supplied.
    This function updates the state variables inside WP_CONFIG for use 
    in starting up the Worker process.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:
    argc - count of arguments supplied
    argv - pointer to strings containing the arguments.

Returns:
    Boolean

--********************************************************************/
bool
WP_CONFIG::ParseCommandLine(int argc, PWSTR  argv[])
{
    bool    fRet = true;
    int     iArg;

    lstrcpyn( m_pwszProgram, argv[0], sizeof(m_pwszProgram));

    if ( argc < 2) 
    {
        wprintf( L"Invalid number of parameters (%d)\n", argc);
        PrintUsage();
        return (false);
    }

    for( iArg = 1; iArg < argc; iArg++) 
    {
        if ( (argv[iArg][0] == L'-') || (argv[iArg][0] == L'/')) 
        {
            switch (argv[iArg][1]) 
            {

            case L'c': case L'C':
                m_fInteractiveConsole = true;
                break;

            case L'd': case L'D':
                wprintf( L"Warning: Always registers for http://*:80/ for now\n");
                
                m_fSetupControlChannel = true;
                iArg++;
                
                while ( (iArg < argc-1) && 
                        (argv[iArg][0] != L'-') && (argv[iArg][0] != L'/'))
                {
                    if ( !InsertURLIntoList(argv[iArg]) )
                    {
                        wprintf(L"Invalid URL: %ws\n", argv[iArg]);
                    }

                    iArg++;
                }

                iArg--;
                break;

            case L'a': case L'A':
                wprintf(L"Warning: This option is not supported now\n");
                if ( (L'd' == argv[iArg][2]) || (L'D' == argv[iArg][2]))
                {
                    m_fRegisterWithWAS = false;
                }
                else
                {
                    // -a NamedPipe Id
                    if ( L'\0' == argv[iArg][2] )
                    {
                        iArg++;
                        
                    }

                    m_NamedPipeId = _wtoi(argv[iArg]);
                    DBGPRINTF((DBG_CONTEXT, "NamedPipe id, %d\n", m_NamedPipeId));
                    
                    if (0 == m_NamedPipeId)
                    {
                        DBGPRINTF((DBG_CONTEXT, "invalid NamedPipe id, %s\n",
                                argv[iArg]));
                        
                        fRet = false;
                    }
                }
                break;
            
            case L'l': case L'L':
                wprintf(L"Warning: This option is not supported now\n");
                if (L' ' == argv[iArg][0])
                {
                    m_fLogErrorsToEventLog = true;
                }
                break;

            default:
            case L'?': 
                fRet = false;
                break;
            } // switch
        } 
        else 
        {
            //
            // Take the next item as the NSG name and bail out here
            //
            m_pwszAppPoolName = argv[iArg];
            
            if ( iArg != (argc - 1)) 
            {
                //
                // this is not the last argument => unwanted parameters exist
                // give warning and ignore 
                //
                wprintf( L"Warning: Too many arguments supplied\n");
            }
            
            break; // get out of here.
        }
    }

    if (!fRet) 
    {
        PrintUsage();
    }

    return ( fRet);

} // WP_CONFIG::ParseCommandLine()


/********************************************************************++

Routine Description:
    Sets up the control channel for processing requests. It uses 
    the configuration parameters supplied for initializing the 
    UL_CONTROL_CHANNEL.

    See g_rgchUsage[] for details on the arguments that can be supplied

Arguments:

Returns:
    Win32 error

--********************************************************************/

ULONG
WP_CONFIG::SetupControlChannel(void)
{

    //
    // Setup a control channel for our local use now. Used mainly for
    // the purpose of debugging.
    // In general control channel work is done by the AdminProces.
    //
    
    return m_ulcc.Initialize( m_mszURLList, QueryAppPoolName());
    
} // WP_CONFIG::SetupControlChannel()

/********************************************************************++
--********************************************************************/

bool
WP_CONFIG::InsertURLIntoList( LPCWSTR pwszURL  )
{
    LPCWSTR pwszOriginalURL = pwszURL;
    
    //
    // Minimum length: 11 (http://*:1/). Begins with http
    //
    
    if ( ( wcslen(pwszURL) < 11 ) || ( 0 != _wcsnicmp(pwszURL, L"http", 4)) )
    {
        return false;
    }

    pwszURL += 4;

    //
    // https
    //
    
    if ((L's' == *pwszURL) || (L'S' == *pwszURL))
    {
        pwszURL++;
    }

    //
    // ://
    //
    
    if ( (L':' != *pwszURL) || (L'/' != *(pwszURL+1)) || (L'/' != *(pwszURL+2)) )
    {
        return false;
    }

    pwszURL += 3;

    //
    // Skip host name or Ip Address
    //
    
    while ( (0 != *pwszURL) && ( L':' != *pwszURL))
    {
        pwszURL++;
    }

    //
    // Check port # exists
    //
    
    if (0 == *pwszURL)
    {
        return false;
    }

    //
    // Check port number is numeric
    //

    pwszURL++;

    while ( (0 != *pwszURL) && ( L'/' != *pwszURL) )
    {
        if (( L'0' > *pwszURL) || ( L'9' < *pwszURL))
        {
            return false;
        }

        pwszURL++;
    }

    //
    // Check / after port number exists
    //
    
    if (0 == *pwszURL)
    {
        return false;
    }
    
    //
    // URL is good.
    //
    
    IF_DEBUG( TRACE)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Inserting URL '%ws' into Config Group List\n",
                    pwszOriginalURL
                    ));
    }
    return ( TRUE == m_mszURLList.Append( pwszOriginalURL));

} // WP_CONFIG::InsertURLIntoList()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\proto\wreqpool.cxx ===
/********************************************************************++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

      wreqpool.cxx

   Abstract:
      This module implements the functions for managing the 
      pool of worker requests.

   Author:

       Murali R. Krishnan    ( MuraliK )     29-Oct-1998

   Environment:
       Win32 - User Mode
       
   Project:
	   IIS Worker Process (web service)

--********************************************************************/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"
#include "wreqpool.hxx"

/************************************************************
 *    Functions 
 ************************************************************/

/********************************************************************++
  WORKER_REQUEST_POOL::WORKER_REQUEST_POOL()

  o  Construct a new worker requst pool object.
  This pool will maintain a list of all actice request objects.
  
  Currently we do not plan to maintain a pool of inactive requests.
  The inactive requests will come out of the heap and be freed
  to the heap. Improvements in NT heap manager obviate the need 
  for separate free list. If needed we can add the free list back later.
--********************************************************************/
WORKER_REQUEST_POOL::WORKER_REQUEST_POOL(void)
    : m_nRequests ( 0),
      m_dwSignature( WREQ_POOL_SIGNATURE)
{
    InitializeListHead( &m_lRequestList);

    //
    // Use spinned critical section. 
    // All operations using the CS are short lived and 
    //  hence we keep the spins to a small amount.
    //
    InitializeCriticalSectionAndSpinCount(
        &m_csRequestList,
        WORKER_REQUEST_CS_SPINS
        );

} // WORKER_REQUEST_POOL::WORKER_REQUEST_POOL()

/********************************************************************++
--********************************************************************/

WORKER_REQUEST_POOL::~WORKER_REQUEST_POOL(void)
{
    if (m_nRequests > 0) 
    {
        ReleaseAllWorkerRequests();
    }

    DeleteCriticalSection( &m_csRequestList);
    InitializeListHead( &m_lRequestList);

    m_dwSignature = ( WREQ_POOL_SIGNATURE_FREE);

} // WORKER_REQUEST_POOL::~WORKER_REQUEST_POOL()


/********************************************************************++
    WORKER_REQUEST_POOL::ReleaseAllWorkerRequests()
  
    o  Walks the global list of all request objects and releases
       the requests

    NYI: For now it directly frees up the request. We need to post
         cancellations for the same as appropriate.
--********************************************************************/

HRESULT
WORKER_REQUEST_POOL::ReleaseAllWorkerRequests(void)
{
    LIST_ENTRY * plScan;

    if ( m_nRequests > 0) {

        EnterCriticalSection( &m_csRequestList);
        
        for (plScan = m_lRequestList.Flink; 
             plScan != &m_lRequestList;
             plScan = plScan->Flink) 
        {
            
            PWORKER_REQUEST pwr = 
                CONTAINING_RECORD( plScan, WORKER_REQUEST, m_lRequestEntry);
            
            //
            // Post a connection close operation for now.
            // The natural cleanup will take care of removing
            // these items from the list
            //
            ReferenceRequest(pwr);
            pwr->CloseConnection();
            DereferenceRequest( pwr);
        } // for
        
        LeaveCriticalSection( &m_csRequestList);
    }

    return (NOERROR);
} // WORKER_REQUEST_POOL::ReleaseAllWorkerRequests();

/********************************************************************++
--********************************************************************/

void
WORKER_REQUEST_POOL::AddRequestToList(WORKER_REQUEST * pRequest)
{
    EnterCriticalSection( &m_csRequestList);
    InsertTailList( &m_lRequestList, &pRequest->m_lRequestEntry);
    m_nRequests++;
    LeaveCriticalSection( &m_csRequestList);

} // WORKER_REQUEST_POOL::AddRequestToList()

/********************************************************************++
--********************************************************************/

void
WORKER_REQUEST_POOL::RemoveRequestFromList(WORKER_REQUEST * pRequest)
{
    EnterCriticalSection( &m_csRequestList);
    RemoveEntryList( &pRequest->m_lRequestEntry);
    m_nRequests--;
    LeaveCriticalSection( &m_csRequestList);

    InitializeListHead( &pRequest->m_lRequestEntry);

} // WORKER_REQUEST_POOL::RemoveRequestFromList()

/********************************************************************++
  Description:
    WORKER_REQUEST_POOL::AddPoolItems()
  
    o  Adds a fixed number of items to the pool and adds them to the 
     current list of worker requests. After creating the object,
     an async read for request is posted on the worker request objects.

  Arguments:
    pContext - pointer to the CONTEXT object for IO operations
    nWorkerItemsToAdd - count of new worker requests to be added to the list

  Returns:
    ULONG

  --********************************************************************/
  
ULONG 
WORKER_REQUEST_POOL::AddPoolItems(
     IN WP_CONTEXT * pContext,
     IN int          nWorkerItemsToAdd)
{
    int     i;
    ULONG   rc;
    
    PWORKER_REQUEST pwr;

    //
    // Loop through and create specified # of worker request objects
    // Attach the current context to these objects
    //

    for (i = 0; i < nWorkerItemsToAdd; i++) 
    {
        pwr = new WORKER_REQUEST( this);

        if ( NULL == pwr) 
        {
            rc = GetLastError();
            
            if (NO_ERROR != rc) 
            {
                IF_DEBUG( ERROR) 
                {
                    DPERROR(( DBG_CONTEXT, rc, 
                              "Unable to create worker request %d.\n", 
                              i));
                }
            }

            //
            // NYI: Log an event to the evnet log on this failure
            //

            //
            // For now bail out of this loop on error
            //
            break;
        } 
        else 
        {

            AddRequestToList( pwr);

            //
            // Initialize the Context for the object.
            //

            pwr->SetWPContext( pContext);

            //
            // Start off a read operation on the request
            // We surround the read with Ref/deref to protect against 
            //   multi-threaded race conditions.
            //

            ReferenceRequest( pwr);
            
            rc = pwr->DoWork( 0, 0, &pwr->m_overlapped);
            
            // assume no failure in initial req. read operations
            DBG_ASSERT( NO_ERROR == rc);
            
            DereferenceRequest( pwr);
        }
    } // for

    return (NOERROR);
    
} // WORKER_REQUEST_POOL::AddPoolItems()

/***************************** End of File ***************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\dbgutil.h ===
/*++

   Copyright    (c)   1994-1998    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to 
      modify for each application the accompanying pgmutils.dll is used.
     
   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE 

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputKdb )

    
// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants 
// 


// Use the default constants from pudebug.h + following constants

# define DEBUG_CHANNEL          0x00010000
# define DEBUG_CONNECTION       0x00020000


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\dllmain.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     dllmain.cxx

   Abstract:
     Contains the standard definitions for a DLL

   Author:

       Murali R. Krishnan    ( MuraliK )     24-Nov-1998

   Project:

       Internet Server DLL

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"


/************************************************************
 *     Global Variables
 ************************************************************/

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();
                                                                               //
//  Configuration parameters registry key.
//
#define IISWP_KEY \
            "System\\CurrentControlSet\\Services\\IISWP"

#define IISWP_PARAMETERS_KEY \
            IISWP_KEY "\\Parameters"

const CHAR g_pszRegLocation[] =
    IISWP_PARAMETERS_KEY "\\UlSim";


/************************************************************
 *     DLL Entry Point
 ************************************************************/
extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD     dwReason,
    LPVOID    lpvReserved)
{
    BOOL  fReturn = TRUE;  // ok

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);

        CREATE_DEBUG_PRINT_OBJECT("ulsim");
        if (!VALID_DEBUG_PRINT_OBJECT()) {
            return (FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszRegLocation, DEBUG_ERROR );

        IF_DEBUG(INIT_CLEAN) 
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "DllMain::DLL_PROCESS_ATTACH succeeded\n"));
        }

    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if (lpvReserved == NULL)
        {
            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            IF_DEBUG(INIT_CLEAN)
            {
                DBGPRINTF((DBG_CONTEXT,
                           "DllMain::DLL_PROCESS_DETACH succeeded\n"));
            }

            DELETE_DEBUG_PRINT_OBJECT();
        }
    }

    return fReturn;
} // DllMain()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\parse.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    parse.c

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       27-Apr-1998

Revision History:

--*/


#include "precomp.hxx"
#include "parsep.h"
#include "rcvhdrs.h"
#include "httputil.h"
#include "iisdef.h"
#include "_hashfn.h"
#include "wchar.h"

//
// The fast verb translation table
//
FAST_VERB_ENTRY FastVerbTable[] =
{
    CREATE_FAST_VERB_ENTRY(GET),
    CREATE_FAST_VERB_ENTRY(PUT),
    CREATE_FAST_VERB_ENTRY(HEAD),
    CREATE_FAST_VERB_ENTRY(POST),
    CREATE_FAST_VERB_ENTRY(DELETE),
    CREATE_FAST_VERB_ENTRY(TRACE),
    CREATE_FAST_VERB_ENTRY(OPTIONS),
    CREATE_FAST_VERB_ENTRY(MOVE),
    CREATE_FAST_VERB_ENTRY(COPY),
    CREATE_FAST_VERB_ENTRY(MKCOL),
    CREATE_FAST_VERB_ENTRY(LOCK)
};

//
// The long verb translation table. All verbs more than 7 characters long
// belong in this table.
//
LONG_VERB_ENTRY LongVerbTable[] =
{
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH)
};

//
// The header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
HEADER_MAP_ENTRY HeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(ACCEPT:,
                            UlHeaderAccept,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(ACCEPT-ENCODING:,
                            UlHeaderAcceptEncoding,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(AUTHORIZATION:,
                            UlHeaderAuthorization,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(ACCEPT-LANGUAGE:,
                            UlHeaderAcceptLanguage,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(CONNECTION:,
                            UlHeaderConnection,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(COOKIE:,
                            UlHeaderCookie,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(CONTENT-LENGTH:,
                            UlHeaderContentLength,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(CONTENT-TYPE:,
                            UlHeaderContentType,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(EXPECT:,
                            UlHeaderExpect,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(HOST:,
                            UlHeaderHost,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(IF-MODIFIED-SINCE:,
                            UlHeaderIfModifiedSince,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(IF-NONE-MATCH:,
                            UlHeaderIfNoneMatch,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(IF-MATCH:,
                            UlHeaderIfMatch,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(IF-UNMODIFIED-SINCE:,
                            UlHeaderIfUnmodifiedSince,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(IF-RANGE:,
                            UlHeaderIfRange,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(PRAGMA:,
                            UlHeaderPragma,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(REFERER:,
                            UlHeaderReferer,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(RANGE:,
                            UlHeaderRange,
                            DefaultHeaderHandler),
    CREATE_HEADER_MAP_ENTRY(USER-AGENT:,
                            UlHeaderUserAgent,
                            DefaultHeaderHandler)
};

//
// The header index table. This is initialized by the init code.
//
HEADER_INDEX_ENTRY  HeaderIndexTable[NUMBER_HEADER_INDICIES];

#define NUMBER_FAST_VERB_ENTRIES    (sizeof(FastVerbTable)/sizeof(FAST_VERB_ENTRY))
#define NUMBER_LONG_VERB_ENTRIES    (sizeof(LongVerbTable)/sizeof(LONG_VERB_ENTRY))
#define NUMBER_HEADER_MAP_ENTRIES   (sizeof(HeaderMapTable)/sizeof(HEADER_MAP_ENTRY))

/*++

Routine Description:

    A utility routine to find a token. We take an input pointer, skip any
    preceding LWS, then scan the token until we find either LWS or a CRLF
    pair.

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    TokenLength     - Where to return the length of the token.

Return Value:

    A pointer to the token we found, as well as the length, or NULL if we
    don't find a delimited token.

--*/
PUCHAR
FindWSToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *pTokenLength)
{
    PUCHAR  pTokenStart;

    // First, skip any preceding LWS.

    while ( BufferLength != 0 && IS_HTTP_LWS(*pBuffer) )
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, fail.
    if (BufferLength == 0)
    {
        return NULL;
    }

    pTokenStart = pBuffer;

    // Now skip over the token, until we see either LWS or a CR or LF.
    while (BufferLength != 0 &&
           (*pBuffer != CR &&
            *pBuffer != SP &&
            *pBuffer != LF &&
            *pBuffer != HT)
          )
    {
        pBuffer++;
        BufferLength--;
    }

    // See why we stopped.
    if (BufferLength == 0)
    {
        // Ran out of buffer before end of token.
        return NULL;
    }

    // Success. Set the token length and return the start of the token.
    *pTokenLength = DIFF(pBuffer - pTokenStart);
    return pTokenStart;
}

/*++

Routine Description:

    The slower way to look up a verb. We find the verb in the request and then
    look for it in the LongVerbTable. If it's not found, we'll return
    UnknownVerb. If it can't be parsed we return UnparsedVerb. Otherwise
    we return the verb type.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by pHttpRequest.
    pVerb               - Where we return a pointer to the verb, if it's an
                            unknown ver.
    ppVerbLength        - Where we return the length of the verb
    pBytesTaken         - The total length consumed, including the length of
                            the verb plus preceding & 1 trailing whitespace.

Return Value:

    The verb we found, or the appropriate error.

--*/
UL_HTTP_VERB
LookupVerb(
    IN  PUCHAR pHttpRequest,
    IN  ULONG  HttpRequestLength,
    OUT PUCHAR *ppVerb,
    OUT ULONG  *pVerbLength,
    OUT ULONG  *pBytesTaken
    )
{
    ULONG       TokenLength;
    PUCHAR      pToken;
    PUCHAR      pTempRequest;
    ULONG       TempLength;
    ULONG       i;

    // just in case we don't find one
    //
    *ppVerb = NULL;
    *pVerbLength = 0;

    // Since we may have gotten here due to a extraneous CRLF pair, skip
    // any of those now. Need to use a temporary variable since
    // the original input pointer and length are used below.

    pTempRequest = pHttpRequest;
    TempLength = HttpRequestLength;

    while ( TempLength != 0 &&
            ((*pTempRequest == CR) || (*pTempRequest == LF)) )
    {
        pTempRequest++;
        TempLength--;
    }

    // First find the verb.

    pToken = FindWSToken(pTempRequest, TempLength, &TokenLength);

    if (pToken == NULL)
    {
        // Didn't find it.
        return UlHttpVerbUnparsed;
    }

    // Make sure we stopped because of a SP.

    if (*(pToken + TokenLength) != SP)
    {
        return UlHttpVerbInvalid;
    }

    // Otherwise, we found one, so update bytes taken and look up up in
    // the table.

    *pBytesTaken = DIFF(pToken - pHttpRequest) + TokenLength + 1;

    for (i = 0; i < NUMBER_LONG_VERB_ENTRIES; i++)
    {
        if (LongVerbTable[i].RawVerbLength == TokenLength &&
            RtlEqualMemory(pToken, LongVerbTable[i].RawVerb, TokenLength))
        {
            // Found it.
            return LongVerbTable[i].TranslatedVerb;
        }
    }

    // The only other things this could be are an unknown verb or a very
    // small 0.9 request. Since 0.9 requests can only be GETs, check that
    // now.

    if (HttpRequestLength >= (sizeof("GET ") - 1))
    {
        if (RtlEqualMemory(pHttpRequest, "GET ", sizeof("GET ") - 1))
        {
            // This is a GET request.
            return UlHttpVerbGET;
        }
    }

    // If we got here, we searched the table and didn't find it.

    *ppVerb = pToken;
    *pVerbLength = TokenLength;

    return UlHttpVerbUnknown;
}


/*++

Routine Description:

    A utility routine to check for an absolute URL in a URL string. If we
    determine that the input pointer does point at an absolute URL, we
    isolate out the host portion and return that, as well as the length
    of the scheme prefix+host.

Arguments:

    pURL            - Pointer to the URL we're to examine
    URLLength       - Length of data pointed to by pURL (which may include
                        more than the URL).
    pHostPtr        - Pointer to where to return a pointer to the host field.
    BytesTaken      - Pointer to where to return length of scheme+host.

Return Value:

    STATUS_SUCCESS if it worked, or an appropriate error if we failed.

--*/
NTSTATUS
CheckForAbsoluteURL(
    IN  PUCHAR      pURL,
    IN  ULONG       URLLength,
    IN  PUCHAR      *pHostPtr,
    IN  ULONG       *BytesTaken
    )
{
    PUCHAR      pURLStart;

    // When we're called, we know that the start of the URL must point at
    // an absolute scheme prefix. Adjust for that now.

    pURLStart = pURL + HTTP_PREFIX_SIZE;
    URLLength -= HTTP_PREFIX_SIZE;

    // Now check the second half of the absolute URL prefix. We use the larger
    // of the two possible prefix length here to do the check, because even if
    // it's the smaller of the two we'll need the extra bytes after the prefix
    // anyway for the host name.

    if (URLLength >= HTTP_PREFIX2_SIZE)
    {
        if ( (*(PULONG)pURLStart & HTTP_PREFIX1_MASK) == HTTP_PREFIX1)
        {
            // Valid absolute URL.
            pURLStart += HTTP_PREFIX1_SIZE;
            URLLength -= HTTP_PREFIX1_SIZE;
        }
        else
        {
            if ( *(PULONG)pURLStart == HTTP_PREFIX2)
            {
                // Valid absolute URL.
                pURLStart += HTTP_PREFIX2_SIZE;
                URLLength -= HTTP_PREFIX2_SIZE;
            }
            else
            {
                return STATUS_INVALID_DEVICE_REQUEST;
            }
        }
    }
    else
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // OK, we've got a valid absolute URL, and we've skipped over
    // the prefix part of it. Save a pointer to the host, and
    // search the host string until we find the trailing slash,
    // which signifies the end of the host/start of the absolute
    // path.
    *pHostPtr = pURLStart;

    // BUGBUG BUGBUG Really need to check here and make sure
    // that the hostname only contains alphanum, digit and '-',
    // but need to wait on that for a while.
    while (URLLength && *pURLStart != '/')
    {
        pURLStart++;
        URLLength--;
    }

    if (URLLength == 0)
    {
        // Ran out of buffer.
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // Otherwise, pURLStart points to the start of the absolute path portion.

    *BytesTaken = DIFF(pURLStart - pURL);

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Look up a header that we don't have in our fast lookup table. This
    could be because it's a header we don't understand, or because we
    couldn't use the fast lookup table due to insufficient buffer length.
    The latter reason is uncommon, but we'll check the input table anyway
    if we're given one. If we find a header match in our mapping table,
    we'll call the header handler. Otherwise we'll try to allocate an
    unknown header element, fill it in and chain it on the http connection.

Arguments:

    pHttpConn           - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderMap          - Pointer to start of an array of header map entries
                            (may be NULL).
    HeaderMapCount      - Number of entries in array pointed to by pHeaderMap.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/
ULONG
LookupHeader(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    IN  PHEADER_MAP_ENTRY   pHeaderMap,
    IN  ULONG               HeaderMapCount
    )
{
    ULONG           CurrentOffset;
    ULONG           HeaderNameLength;
    ULONG           i;
    ULONG           BytesTaken;
    ULONG           HeaderValueLength;
    UCHAR           CurrentChar;

    //
    // First, let's find the terminating : of the header, if there is one.
    // This will also give us the length of the header, which we can then
    // use to search the header map table if we have one.
    //

    for (CurrentOffset = 0; CurrentOffset < HttpRequestLength; CurrentOffset++)
    {
        CurrentChar = *(pHttpRequest + CurrentOffset);

        if (CurrentChar == ':')
        {
            // We've found the end of the header.
            break;
        }
        else
        {
            if (!IS_HTTP_TOKEN(CurrentChar))
            {
                // Uh-oh, this isn't a valid header. What do we do now?
                return -1;
                break;
            }
        }

    }

    // Find out why we got out. If the current offset is less than the
    // header length, we got out because we found the :.

    if (CurrentOffset < HttpRequestLength)
    {
        // Found the terminator.
        CurrentOffset++;            // Update to point beyond termintor.
        HeaderNameLength = CurrentOffset;
    }
    else
    {
        // Didn't find the :, need more.

        return 0;
    }

    // See if we have a header map array we need to search.
    //
    if (pHeaderMap != NULL)
    {
        // We do have an array to search.
        for (i = 0; i < HeaderMapCount; i++)
        {
            if (HeaderNameLength == pHeaderMap->HeaderLength &&
                _strnicmp(pHttpRequest,
                          pHeaderMap->Header.HeaderChar,
                          HeaderNameLength) == 0 )
            {
                // This header matches. Call the handling function for it.
                BytesTaken =
                    (*(pHeaderMap->pHandler))(
                        pHttpConn,
                        pHttpRequest + HeaderNameLength,
                        HttpRequestLength - HeaderNameLength,
                        pHeaderMap->HeaderID
                    );

                // If the handler consumed a non-zero number of bytes, it
                // worked, so return that number plus the header length.

                //
                // BUGBUG - it might be possible for a header handler to
                // encounter an error, for example being unable to
                // allocate memory, or a bad syntax in some header. We
                // need a more sophisticated method to detect this than
                // just checking bytes taken.
                //

                if (BytesTaken != 0)
                {
                    return HeaderNameLength + BytesTaken;
                }

                // Otherwise he didn't take anything, so return 0.
                return 0;
            }

            pHeaderMap++;
        }
    }

    // OK, at this point either we had no header map array or none of them
    // matched. We have an unknown header. Just make sure this header is
    // terminated and save a pointer to it.

    // Find the end of the header value
    //
    BytesTaken = FindHeaderEnd(pHttpRequest + HeaderNameLength,
                               HttpRequestLength - HeaderNameLength);

    // Strip of the trailing CRLF from the header value length
    //
    HeaderValueLength = BytesTaken - CRLF_SIZE;

    // any value there?
    //
    if (HeaderValueLength > 0)
    {
        PHTTP_UNKNOWN_HEADER        pUnknownHeader;
        PLIST_ENTRY                 pListStart;
        PLIST_ENTRY                 pCurrentListEntry;
        ULONG                       OldHeaderLength;
        PUCHAR                      pHeaderValue;

        pHeaderValue = pHttpRequest + HeaderNameLength;

        // skip any preceding LWS.
        //
        while ( HeaderValueLength > 0 && IS_HTTP_LWS(*pHeaderValue) )
        {
            pHeaderValue++;
            HeaderValueLength--;
        }


        // Have an unknown header. Search our list of unknown headers,
        // and if we've already seen one instance of this header add this
        // on. Otherwise allocate an unknown header structure and set it
        // to point at this header.

        pListStart = &pHttpConn->UnknownHeaderList;

        for (pCurrentListEntry = pHttpConn->UnknownHeaderList.Flink;
             pCurrentListEntry != pListStart;
             pCurrentListEntry = pCurrentListEntry->Flink
            )
        {
            pUnknownHeader = CONTAINING_RECORD(
                                pCurrentListEntry,
                                HTTP_UNKNOWN_HEADER,
                                List
                                );

            if (HeaderNameLength == pUnknownHeader->HeaderNameLength &&
                _strnicmp(pHttpRequest,
                          pUnknownHeader->pHeaderName,
                          HeaderNameLength) == 0
               )
            {
                // This header matches.

                OldHeaderLength = pUnknownHeader->HeaderValue.HeaderLength;

                if (AppendHeaderValue(&pUnknownHeader->HeaderValue,
                                      pHeaderValue,
                                      HeaderValueLength) )
                {
                    // Successfully appended it. Update the total request
                    // length for the length added.

                    pHttpConn->TotalRequestSize +=
                        (pUnknownHeader->HeaderValue.HeaderLength -
                            OldHeaderLength);

                    return HeaderNameLength + BytesTaken;
                }
                else
                {
                    // BUGBUG couldn't append header, need to return an error.
                    ASSERT(FALSE);
                    return 0;
                }
            }

        }

        //
        // Didn't find a match. Allocate a new unknown header structure, set
        // it up and add it to the list.
        //

        /*
        pUnknownHeader = UL_ALLOCATE_POOL(NonPagedPool,
                                          sizeof(HTTP_UNKNOWN_HEADER),
                                          UL_REGISTRY_DATA_POOL_TAG
                                          );
        */

        pUnknownHeader = (PHTTP_UNKNOWN_HEADER)
                                LocalAlloc(LMEM_FIXED, sizeof(HTTP_UNKNOWN_HEADER));

        if (pUnknownHeader == NULL)
        {
            // BUGBUG handle this.
            ASSERT(FALSE);
            return 0;
        }

        pUnknownHeader->HeaderNameLength = HeaderNameLength;
        pUnknownHeader->pHeaderName = pHttpRequest;
        pUnknownHeader->HeaderValue.HeaderLength = HeaderValueLength;
        pUnknownHeader->HeaderValue.pHeader = pHeaderValue;
        pUnknownHeader->HeaderValue.OurBuffer = 0;
        InsertTailList(&pHttpConn->UnknownHeaderList, &pUnknownHeader->List);

        pHttpConn->UnknownHeaderCount++;
        pHttpConn->TotalRequestSize += (HeaderNameLength + HeaderValueLength);



        return HeaderNameLength + BytesTaken;
    }

    return 0;
}



/*++

Routine Description:

    The routine to parse an individual header. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header in our lookup table. We try first the fast way, and then
    try again the slow way in case there wasn't quite enough data the first
    time.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pHttpConn           - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/

ULONG
ParseHeader(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength
    )
{
    ULONG               i;
    ULONG               j;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    UCHAR               c;
    PHEADER_MAP_ENTRY   pCurrentHeaderMap;
    ULONG               HeaderMapCount;
    PHTTP_HEADER        pFoundHeader;
    BOOLEAN             SmallHeader = FALSE;

    ASSERT(HttpRequestLength >= CRLF_SIZE);

    c = *pHttpRequest;

    // If this isn't a continuation line, look up the header.

    if (!IS_HTTP_LWS(c))
    {
        // Uppercase the character, and find the appropriate set of header map
        // entries.

        c = UPCASE_CHAR(c);

        if (IS_HTTP_UPCASE(c))
        {
            c -= 'A';

            pCurrentHeaderMap = HeaderIndexTable[c].pHeaderMap;
            HeaderMapCount = HeaderIndexTable[c].Count;

            // Loop through all the header map entries that might match
            // this header, and check them. The count will be 0 if there
            // are no entries that might match and we'll skip the loop.

            for (i = 0; i < HeaderMapCount; i++)
            {
                // If we have enough bytes to do the fast check, do it.
                // Otherwise skip this. We may skip a valid match, but if
                // so we'll catch it later.

                if (HttpRequestLength >= pCurrentHeaderMap->MinBytesNeeded)
                {
                    for (j = 0; j < pCurrentHeaderMap->ArrayCount; j++)
                    {
                        Temp = *(PULONGLONG)(pHttpRequest +
                                                (j * sizeof(ULONGLONG)));

                        if ((Temp & pCurrentHeaderMap->HeaderMask[j]) !=
                            pCurrentHeaderMap->Header.HeaderLong[j] )
                        {
                            break;
                        }
                    }

                    // See why we exited out.
                    if (j == pCurrentHeaderMap->ArrayCount)
                    {
                        // Exited because we found a match. Call the
                        // handler for this header to take cake of this.

                        BytesTaken =
                            (*(pCurrentHeaderMap->pHandler))(
                                pHttpConn,
                                pHttpRequest +
                                    pCurrentHeaderMap->HeaderLength,
                                HttpRequestLength -
                                    pCurrentHeaderMap->HeaderLength,
                                pCurrentHeaderMap->HeaderID
                            );

                        // If the handler consumed a non-zero number of
                        // bytes, it worked, so return that number plus
                        // the header length.


                        if (BytesTaken != 0)
                        {
                            return pCurrentHeaderMap->HeaderLength +
                                    BytesTaken;
                        }

                        return 0;
                    }

                    // If we get here, we exited out early because a match
                    // failed, so keep going.
                }
                else if (SmallHeader == FALSE)
                {
                    //
                    // Remember that we didn't check a header map entry
                    // because the bytes in the buffer was not LONGLONG
                    // aligned
                    //
                    SmallHeader = TRUE;
                }

                // Either didn't match or didn't have enough bytes for the
                // check. In either case, check the next header map entry.

                pCurrentHeaderMap++;
            }

            // Got all the way through the appropriate header map entries
            // without a match. This could be because we're dealing with a
            // header we don't know about or because it's a header we
            // care about that was too small to do the fast check. The
            // latter case should be very rare, but we still need to
            // handle it.

            // Update the current header map pointer to point back to the
            // first of the possibles. If there were no possibles,
            // the pointer will be NULL and the HeaderMapCount 0, so it'll
            // stay NULL. Otherwise the subtraction will back it up the
            // appropriate amount.

            if (SmallHeader)
            {
                pCurrentHeaderMap -= HeaderMapCount;
            }
            else
            {
                pCurrentHeaderMap = NULL;
                HeaderMapCount = 0;
            }

        }
        else
        {
            pCurrentHeaderMap = NULL;
            HeaderMapCount = 0;
        }

        // At this point either the header starts with a non-alphabetic
        // character or we don't have a set of header map entries for it.

        BytesTaken = LookupHeader(pHttpConn,
                                  pHttpRequest,
                                  HttpRequestLength,
                                  pCurrentHeaderMap,
                                  HeaderMapCount);
    }
    else
    {
        // This is a continuation line for the previous header.
        BytesTaken = 0;
    }

    return  BytesTaken;
}


/*++

Routine Description:

    This is the core HTTP protocol request engine. It takes a stream of bytes
    and parses them as an HTTP request.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by HttpRequest.

Return Value:

    Status of parse attempt.

--*/
NTSTATUS
ParseHttp(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG               *pBytesTaken
    )

{
    ULONG           CurrentBytesTaken;
    ULONG           TotalBytesTaken;
    ULONG           i;
    NTSTATUS        ReturnStatus;
    PUCHAR          pURLStart;
    PUCHAR          pAbsPathStart;
    PUCHAR          pHost;
    PUCHAR          pTemp;

    ReturnStatus = STATUS_SUCCESS;
    TotalBytesTaken = 0;

    switch (pHttpConn->ParseState)
    {
    case ParseVerbState:

        // Look through the fast verb table for the verb. We can only do
        // this if the input data is big enough.
        if (HttpRequestLength >= sizeof(ULONGLONG))
        {
            ULONGLONG   RawInputVerb;

            RawInputVerb = *(ULONGLONG *)pHttpRequest;

            // Loop through the fast verb table, looking for the verb.
            for (i = 0; i < NUMBER_FAST_VERB_ENTRIES;i++)
            {
                // Mask out the raw input verb and compare against this
                // entry.

                if ((RawInputVerb & FastVerbTable[i].RawVerbMask) ==
                    FastVerbTable[i].RawVerb.LongLong)
                {
                    // It matched. Save the translated verb from the
                    // table, update the request pointer and length,
                    // switch states and get out.

                    pHttpConn->Verb = FastVerbTable[i].TranslatedVerb;
                    CurrentBytesTaken = FastVerbTable[i].RawVerbLength;

                    pHttpConn->ParseState = ParseURLState;
                    break;
                }
            }
        }

        if (pHttpConn->ParseState != ParseURLState)
        {
            UL_HTTP_VERB           RequestVerb;

            // Didn't switch states yet, because we haven't found the
            // verb yet. This could be because a) the incoming request
            // was too small to allow us to use our fast lookup (which
            // might be OK in an HTTP/0.9 request), or b) the incoming
            // verb is a PROPFIND or such that is too big to fit into
            // our fast find table, or c) this is an unknown verb. In
            // any of these cases call our slower verb parser to try
            // again.

            RequestVerb = LookupVerb(pHttpRequest,
                                     HttpRequestLength,
                                     &pHttpConn->pRawVerb,
                                     &pHttpConn->RawVerbLength,
                                     &CurrentBytesTaken);

            if (RequestVerb == UlHttpVerbUnparsed)
            {
                ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                break;
            }

            if (RequestVerb == UlHttpVerbInvalid)
            {
                // Do something to indicate the error.
                ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

            pHttpConn->Verb = RequestVerb;

            // Could be a raw verb
            //
            pHttpConn->TotalRequestSize += pHttpConn->RawVerbLength;
        }

        // Otherwise, fall through to the URL parse stage.


        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

    case ParseURLState:

        // We're parsing the URL. pHTTPRequest points to the incoming URL,
        // HttpRequestLength is the length of this request that is left.

        pURLStart = pHttpRequest;

        // First, see if this is an absolute URL.
        if (HttpRequestLength >= HTTP_PREFIX_SIZE &&
            *(PULONG)pHttpRequest == HTTP_PREFIX)
        {
            // This might be an absolute URL.

            ReturnStatus = CheckForAbsoluteURL(pHttpRequest,
                                               HttpRequestLength,
                                               &pHost,
                                               &CurrentBytesTaken);

            if (ReturnStatus != STATUS_SUCCESS)
            {
                break;
            }

            HttpRequestLength -= CurrentBytesTaken;
            pHttpRequest += CurrentBytesTaken;
            pHttpConn->TotalRequestSize += CurrentBytesTaken;

        }
        else
        {
            pHost = NULL;
        }

        // Find the WS terminating the URL. This might be better
        // done with a specialized routine, maybe one that computes
        // some sort of hash on the URL for the cache later as it
        // scans the URL, and canonicalizes as it scans.


        pAbsPathStart = FindWSToken(pHttpRequest,
                                    HttpRequestLength,
                                    &CurrentBytesTaken);

        if (pAbsPathStart == NULL)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }

        // Make sure that we've got an an actual absolute URL.
        if (*pAbsPathStart != '/')
        {
            ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        pHttpConn->RawUrl.pUrl      = (pHost != NULL) ? pHost : pAbsPathStart;
        pHttpConn->RawUrl.pHost     = pHost;
        pHttpConn->RawUrl.pAbsPath  = pAbsPathStart;
        pHttpConn->RawUrl.Length    = CurrentBytesTaken;

        pHttpConn->TotalRequestSize += CurrentBytesTaken;

        // Move the request pointer to point beyond the absolute path,
        // and update the lengths. We know there's at least one character
        // beyond the absolute path or our parse above wouldn't have
        // terminated, so we'll add that in.

        HttpRequestLength -= DIFF(pAbsPathStart - pHttpRequest) +
                                CurrentBytesTaken + 1;

        // Adjust the http request pointer to point beyond the
        // terminating space. We need to save the pointer to
        // the space for the version check in the process.

        pHttpRequest = pAbsPathStart + CurrentBytesTaken;

        pTemp = pHttpRequest;
        pHttpRequest++;

        if (*pTemp != SP)
        {
            // This is probably a 0.9 request. Check the size, adjusting
            // for the space we've already accounted for in
            // HttpRequestLength.

            if (HttpRequestLength >= (CRLF_SIZE - 1))
            {
                if (*(PUSHORT)pTemp == CRLF ||
                    *(PUSHORT)pTemp == LFLF)
                {
                    // This is a 0.9 request. No need to go any further,
                    // since by definition there are no more headers.
                    // Just update things and get out.

                    TotalBytesTaken += DIFF(pHttpRequest - pURLStart) + 1;

                    pHttpConn->Version = UlHttpVersion09;
                    pHttpConn->ParseState = ParseDoneState;
                    break;
                }
                else
                {
                    // Terminated for a weird reason!
                    ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                    break;
                }
            }
            else
            {
                ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                break;
            }
        }

        TotalBytesTaken += DIFF(pHttpRequest - pURLStart);
        pHttpConn->ParseState = ParseVersionState;

        // Fall through to parsing the version.

    case ParseVersionState:

        if (HttpRequestLength < MIN_VERSION_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            break;
        }

        if (*(PULONGLONG)pHttpRequest == HTTP_11_VERSION)
        {
            pHttpConn->Version = UlHttpVersion11;
        }
        else
        {
            if (*(PULONGLONG)pHttpRequest == HTTP_10_VERSION)
            {
                pHttpConn->Version = UlHttpVersion10;
            }
            else
            {
                // BUGBUG for now this is OK. In the future need to add code
                // to check the major version number and handle as a 1.1
                // request if we can. It's also possible that there's extra WS
                // between the URL and the version, which we should check
                // for and handle here.
                ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                break;
            }

        }

        // Make sure we're terminated on this line.

        pTemp = pHttpRequest + sizeof(ULONGLONG);

        if (*(PUSHORT)pTemp != CRLF && *(PUSHORT)pTemp != LFLF)
        {
            // Might want to be more liberal, and see if there's space
            // after the version. This also could be a sub-version withing
            // HTTP/1.1, ie HTTP/1.11 or something like that.
            ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }


        HttpRequestLength -= MIN_VERSION_SIZE;
        pHttpRequest += MIN_VERSION_SIZE;

        TotalBytesTaken += MIN_VERSION_SIZE;

        pHttpConn->ParseState = ParseHeadersState;

    case ParseHeadersState:

        // Loop through the headers, parsing each one. Since the minimum header
        // is a CRLF, we can loop as long as we've got at least that much. At
        // the start of each loop pHttpRequest is pointing at a header.

        // Assume that the reason we broke out of the loop is because of
        // insufficient data. We'll update the status if we have successfull
        // processing.

        ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;

        while (HttpRequestLength >= CRLF_SIZE)
        {

            // If this is an empty header, we're done.

            if (*(PUSHORT)pHttpRequest == CRLF ||
                *(PUSHORT)pHttpRequest == LFLF)
            {
                TotalBytesTaken += CRLF_SIZE;
                pHttpConn->ParseState = ParseDoneState;
                ReturnStatus = STATUS_SUCCESS;
                break;
            }

            // Otherwise call our header parse routine to deal with this.

            CurrentBytesTaken = ParseHeader(pHttpConn,
                                            pHttpRequest,
                                            HttpRequestLength);

            // If no bytes were consumed, the header must be incomplete, so
            // bail out until we get more data on this connection.

            if (CurrentBytesTaken == 0)
            {
                break;
            }

            // Otherwise we parsed a header, so update and continue.

            pHttpRequest += CurrentBytesTaken;
            TotalBytesTaken += CurrentBytesTaken;
            HttpRequestLength -= CurrentBytesTaken;

        }

        break;

    default:
        // this should never happen!
        //
        ASSERT(FALSE);
        break;

    }


    *pBytesTaken = TotalBytesTaken;

    return ReturnStatus;

}

/*++

Routine Description:

    Routine to initialize the parse code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeParser(
    VOID
    )
{
    ULONG               i;
    ULONG               j;
    PHEADER_MAP_ENTRY   pHeaderMap;
    PHEADER_INDEX_ENTRY pHeaderIndex;
    UCHAR               c;

    //
    // Make sure the entire table starts life as zero
    //
    RtlZeroMemory(&HeaderIndexTable, sizeof(HeaderIndexTable));

    for (i = 0; i < NUMBER_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &HeaderMapTable[i];

        c = pHeaderMap->Header.HeaderChar[0];

        pHeaderIndex = &HeaderIndexTable[c - 'A'];

        if (pHeaderIndex->pHeaderMap == NULL)
        {
            pHeaderIndex->pHeaderMap = pHeaderMap;
            pHeaderIndex->Count = 1;
        }
        else
        {
            pHeaderIndex->Count++;
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] =
                CREATE_HEADER_MASK(pHeaderMap->HeaderLength,
                                    sizeof(ULONGLONG) * (j+1));
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

    }

    return STATUS_SUCCESS;
}

NTSTATUS
UlCookUrl(
    PHTTP_CONNECTION pHttpConn
    )
{
    NTSTATUS Status;
    PUCHAR  pHost;
    ULONG   HostLength;
    PUCHAR  pAbsPath;
    ULONG   AbsPathLength;
    ULONG   PortNum;
    ULONG   UrlLength;
    ULONG   PortLength;
    ULONG   LengthCopied;
    PWSTR   pUrl = NULL;
    PWSTR   pCurrent;

    // We must have already parsed the entire headers + such
    //
    if (pHttpConn->ParseState != ParseDoneState)
        return STATUS_INVALID_DEVICE_STATE;


    // collect the host + abspath sections
    //

    if (pHttpConn->RawUrl.pHost != NULL)
    {
        pHost = pHttpConn->RawUrl.pHost;
        HostLength = DIFF(pHttpConn->RawUrl.pAbsPath - pHttpConn->RawUrl.pHost);

        pAbsPath = pHttpConn->RawUrl.pAbsPath;
        AbsPathLength = pHttpConn->RawUrl.Length - DIFF(pAbsPath - pHttpConn->RawUrl.pUrl);

    }
    else
    {
        pHost = NULL;
        HostLength = 0;

        pAbsPath = pHttpConn->RawUrl.pAbsPath;
        AbsPathLength = pHttpConn->RawUrl.Length;
    }


    // found a host yet?
    //
    if (pHost == NULL)
    {
        // do we have a host header?
        //
        if (pHttpConn->Headers[UlHeaderHost].pHeader != NULL )
        {
            pHost       = pHttpConn->Headers[UlHeaderHost].pHeader+1;
            HostLength  = pHttpConn->Headers[UlHeaderHost].HeaderLength-3;
        }
        else
        {
            // get the ip address from the transport
            //

            // CODEWORK
            pHost       = "localhost";
            HostLength  = sizeof("localhost")-1;

        }

    }

    // get the port address from the transport
    //

        // CODEWORK
        PortNum = 80;

    UrlLength = (HTTP_PREFIX_SIZE+HTTP_PREFIX2_SIZE) + HostLength + (sizeof(":")-1) + MAX_PORT_LENGTH + AbsPathLength;
    UrlLength *= sizeof(WCHAR);

    // allocate a new buffer to hold this guy
    //

    /*
    pUrl = UL_ALLOCATE_POOL(NonPagedPool,
                            UrlLength + sizeof(WCHAR),
                            UL_REGISTRY_DATA_POOL_TAG);
    */

    pUrl = (PWSTR) LocalAlloc(LMEM_FIXED,  UrlLength + sizeof(WCHAR));

    if (pUrl == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pHttpConn->CookedUrl.pUrl = pCurrent = pUrl;


    // compute the scheme
    //
    if (FALSE)
    {
        // yep, ssl
        //

        // CODEWORK

        // copy the NULL for the hash function to work
        //
        RtlCopyMemory(pCurrent, L"HTTPS://", sizeof(L"HTTPS://"));

        pCurrent                    += (sizeof(L"HTTPS://")-1) / sizeof(WCHAR);
        pHttpConn->CookedUrl.Length  = (sizeof(L"HTTPS://")-1);

        pHttpConn->CookedUrl.Hash    = HashStringNoCaseW(pCurrent, 0);

    }
    else
    {
        // not ssl
        //
        RtlCopyMemory(pCurrent, L"HTTP://", sizeof(L"HTTP://"));

        pCurrent                    += (sizeof(L"HTTP://")-1) / sizeof(WCHAR);
        pHttpConn->CookedUrl.Length  = (sizeof(L"HTTP://")-1);

        pHttpConn->CookedUrl.Hash    = HashStringNoCaseW(pCurrent, 0);

    }

    //
    // assemble the rest of the url
    //

    // host
    //

    Status = UlpCleanAndCopyUrl(FALSE,
                                pCurrent,
                                pHost,
                                HostLength,
                                &LengthCopied,
                                NULL,
                                &pHttpConn->CookedUrl.Hash);

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pHttpConn->CookedUrl.pHost   = pCurrent;
    pHttpConn->CookedUrl.Length += LengthCopied;
    pCurrent += LengthCopied / sizeof(WCHAR);

    // port
    //
    PortLength = swprintf(pCurrent, L":%d", PortNum);

    pCurrent += PortLength;

    // swprintf returns char not byte count
    //
    pHttpConn->CookedUrl.Length += PortLength * sizeof(WCHAR);

    // abs_path
    //
    Status = UlpCleanAndCopyUrl(TRUE,
                                pCurrent,
                                pAbsPath,
                                AbsPathLength,
                                &LengthCopied,
                                &pHttpConn->CookedUrl.pQueryString,
                                &pHttpConn->CookedUrl.Hash);

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pHttpConn->CookedUrl.pAbsPath = pCurrent;
    pHttpConn->CookedUrl.Length  += LengthCopied;

    ASSERT(pHttpConn->CookedUrl.Length <= UrlLength);

    // Update pHttpConn
    //

    pHttpConn->TotalRequestSize += pHttpConn->CookedUrl.Length;

    Status = STATUS_SUCCESS;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pUrl != NULL)
        {
            /*
            UL_FREE_POOL(pUrl, UL_REGISTRY_DATA_POOL_TAG);
            */

            LocalFree(pUrl);

            RtlZeroMemory(&pHttpConn->CookedUrl, sizeof(pHttpConn->CookedUrl));
        }
    }

    return Status;
}

NTSTATUS
Unescape(
    PUCHAR pChar,
    PUCHAR pOutChar
    )

{
    UCHAR Result, Digit;

    if (pChar[0] != '%' ||
        isxdigit(pChar[1]) == FALSE ||
        isxdigit(pChar[2]) == FALSE)
    {
        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined
    //

    // uppercase #1
    //
    Digit = pChar[1] & 0xDF;

    Result = ((Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0')) << 4;

    // uppercase #2
    //
    Digit = pChar[2] & 0xDF;

    Result |= (Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0');

    *pOutChar = Result;

    return STATUS_SUCCESS;
}


NTSTATUS
PopChar(
    IN PUCHAR pChar,
    OUT WCHAR * pUnicodeChar,
    OUT PULONG pCharToSkip
    )
{
    NTSTATUS Status;
    WCHAR   UnicodeChar;
    UCHAR   Char;
    UCHAR   Trail1;
    UCHAR   Trail2;
    ULONG   CharToSkip;

    // need to unescape ?
    //
    if (pChar[0] == '%')
    {
        Status = Unescape(pChar, &Char);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;
        CharToSkip = 3;
    }
    else
    {
        Char = pChar[0];
        CharToSkip = 1;
    }

    //
    // convert to unicode, checking for utf8 .
    //
    // 3 byte runs are the largest we can have.  16 bits in UCS-2 =
    // 3 bytes of (4+4,2+6,2+6) where it's code + char.
    // for a total of 6+6+4 char bits = 16 bits.
    //

    //
    // NOTE: we'll only bother to decode utf if it was escaped
    // thus the (CharToSkip == 3)
    //
    if ((CharToSkip == 3) && (Char & 0xf0) == 0xe0)
    {
        // 3 byte run
        //

        // Unescape the next 2 trail bytes
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        Status = Unescape(pChar+CharToSkip, &Trail2);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE ||
            IS_UTF8_TRAILBYTE(Trail2) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        // handle three byte case
        // 1110xxxx 10xxxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x0f) << 12) |
                                ((Trail1 & 0x3f) << 6) |
                                (Trail2 & 0x3f));

    }
    else if ((CharToSkip == 3) && (Char & 0xe0) == 0xc0)
    {
        // 2 byte run
        //

        // Unescape the next 1 trail byte
        //

        Status = Unescape(pChar+CharToSkip, &Trail1);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        CharToSkip += 3; // %xx

        if (IS_UTF8_TRAILBYTE(Trail1) == FALSE)
        {
            // bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        // handle two byte case
        // 110xxxxx 10xxxxxx

        UnicodeChar = (USHORT) (((Char & 0x0f) << 6) |
                                (Trail1 & 0x3f));

    }

    // now this can either be unescaped high-bit (bad)
    // or escaped high-bit.  (also bad)
    //
    // thus not checking CharToSkip
    //

    else if ((Char & 0x80) == 0x80)
    {
        // high bit set !  bad utf!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;

    }

    // Normal character (again either escaped or unescaped)
    //
    else
    {
        // Simple conversion to unicode :)
        //
        UnicodeChar = (USHORT)Char;
    }

    // turn backslashes into forward slashes
    //
    if (UnicodeChar == L'\\')
        UnicodeChar = L'/';

    *pCharToSkip  = CharToSkip;
    *pUnicodeChar = UnicodeChar;

    Status = STATUS_SUCCESS;
end:
    return Status;
}


//
// PAULMCD(2/99): stolen from iisrtl\string.cxx and incorporated
// and added more comments
//

//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000

//
// Private globals
//

//
// this table says what to do based on the current state and the current
// character
//
ULONG  pActionTable[16] =
{
    // state 0 = fresh, seen nothing exciting yet
    //
        ACTION_EMIT_CH,             // other = emit it                      newstate = 0
        ACTION_EMIT_CH,             // "."   = emit it                      newstate = 0
        ACTION_NOTHING,             // EOS   = normal finish                newstate = 4
        ACTION_EMIT_CH,             // "/"   = we saw the "/", emit it      newstate = 1

    // state 1 = we saw a "/" !
    //
        ACTION_EMIT_CH,             // other = emit it,                     newstate = 0
        ACTION_NOTHING,             // "."   = eat it,                      newstate = 2
        ACTION_NOTHING,             // EOS   = normal finish                newstate = 4
        ACTION_NOTHING,             // "/"   = extra slash, eat it,         newstate = 1

    // state 2 = we saw a "/" and ate a "." !
    //
        ACTION_EMIT_DOT_CH,         // other = emit the dot we ate.         newstate = 0
        ACTION_NOTHING,             // "."   = eat it, a ..                 newstate = 3
        ACTION_NOTHING,             // EOS   = normal finish                newstate = 4
        ACTION_NOTHING,             // "/"   = we ate a "/./", swallow it   newstate = 1

    // state 3 = we saw a "/" and ate a ".." !
    //
        ACTION_EMIT_DOT_DOT_CH,     // other = emit the "..".               newstate = 0
        ACTION_EMIT_DOT_DOT_CH,     // "."   = 3 dots, emit the ".."        newstate = 0
        ACTION_BACKUP,              // EOS   = we have a "/..\0", backup!   newstate = 4
        ACTION_BACKUP               // "/"   = we have a "/../", backup!    newstate = 1
};

//
// this table says which newstate to be in given the current state and the
// character we saw
//
ULONG  pNextStateTable[16] =
{
    // state 0
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    //  state 1
    0 ,              // other
    2 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 2
    0 ,             // other
    3 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 3
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1               // "\"
};

//
// this says how to index into pNextStateTable given our current state.
//
// since max states = 4, we calculate the index by multiplying with 4.
//
#define IndexFromState( st)   ( (st) * 4)




/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode
    computes the case insensitive hash

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
UlpCleanAndCopyUrl(
    IN      BOOLEAN MakeCanonical,
    IN OUT  PWSTR   pDestination,
    IN      PUCHAR  pSource,
    IN      ULONG   SourceLength,
    OUT     PULONG  pBytesCopied,
    OUT     PWSTR * ppQueryString,
    OUT     PULONG  pUrlHash
    )
{
    NTSTATUS Status;
    PWSTR   pDest;
    PUCHAR  pChar;
    ULONG   CharToSkip;
    UCHAR   Char;
    BOOLEAN HashValid;
    ULONG   UrlHash;
    ULONG   BytesCopied;
    PWSTR   pQueryString;
    ULONG   StateIndex;
    WCHAR   UnicodeChar;


// a cool local helper macro
//
#define EMIT_CHAR(ch)                               \
do {                                                \
    pDest[0] = (ch);                                \
    pDest += 1;                                     \
    BytesCopied += 2;                               \
    if (HashValid)                                  \
        UrlHash = HashCharNoCaseW((ch), UrlHash);   \
} while (0)


    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    HashValid = TRUE;
    UrlHash = *pUrlHash;

    StateIndex = 0;

    while (SourceLength > 0)
    {
        // advance !  it's at the top of the loop to enable ANSI_NULL to come through ONCE
        //
        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        // hit the end?
        //
        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
        }
        else
        {
            // Peek briefly to see if we hit the query string
            //
            if (pQueryString == NULL && pChar[0] == '?')
            {
                // remember it's location
                //
                pQueryString = pDest;

                // let it fall through ONCE to the canonical
                // in order to handle trailing "/.."

                UnicodeChar = L'?';
                CharToSkip = 1;
            }
            else
            {
                // grab the next char
                //
                Status = PopChar(pChar, &UnicodeChar, &CharToSkip);
                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
            }
        }

        if (MakeCanonical)
        {
            //
            // now use the state machine to make it canonical .
            //

            //
            // from the old value of StateIndex, figure out our new base StateIndex
            //
            StateIndex = IndexFromState(pNextStateTable[StateIndex]);

            //
            // now based on the char we just popped, what StateIndex should we be in?
            //
            switch (UnicodeChar)
            {
            case L'?':              StateIndex += 2;    break;
            case UNICODE_NULL:      StateIndex += 2;    break;
            case L'.':              StateIndex += 1;    break;
            case L'/':              StateIndex += 3;    break;
            default:                StateIndex += 0;    break;
            }

        }
        else
        {
            StateIndex = (UnicodeChar == UNICODE_NULL) ? 2 : 0;
        }

        //
        //  Perform the action associated with the state.
        //

        switch (pActionTable[StateIndex])
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_CH:

            EMIT_CHAR(UnicodeChar);

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest current points 1 past the last '/'.  backup over it and find the
            // preceding '/', set pDest to 1 past that one.
            //

            // backup over the slash.
            //
            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest[0] == L'/');

            // are we at the start of the string?  that's bad, can't go back!
            //
            if (pDest == pDestination)
            {
                ASSERT(BytesCopied == 0);

                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
                goto end;
            }

            // Find the previous slash now
            //
            while (pDest > pDestination &&
                   pDest[0] != L'/')
            {
                pDest       -= 1;
                BytesCopied -= 2;
            }

            // now we already have a slash, so don't have to store 1.
            //
            ASSERT(pDest[0] == L'/');

            // now skip it
            //
            pDest       += 1;
            BytesCopied += 2;

            // our running hash is no longer valid
            //
            HashValid = FALSE;

            break;

        default:
            ASSERTMSG("UL!UlCleanAndCopyUrl: Invalid action code in state table!", TRUE);
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
            break;
        }

        // Just hit the query string ?
        //
        if (MakeCanonical && pQueryString != NULL)
        {
            // Stop canonical processing
            //
            MakeCanonical = FALSE;

            // Need to emit the '?', it wasn't emitted above
            //

            ASSERT(pActionTable[StateIndex] != ACTION_EMIT_CH);

            EMIT_CHAR(L'?');

        }

    }

    // end it off
    //
    // it hasn't been ended off in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;

    // need to recompute the hash?
    //
    if (HashValid == FALSE)
    {
        // this can happen if we had to backtrack due to /../
        //
        UrlHash = HashStringNoCaseW(pDestination, *pUrlHash);
    }

    *pUrlHash = UrlHash;
    *pBytesCopied = BytesCopied;
    if (ppQueryString != NULL)
        *ppQueryString = pQueryString;

    Status = STATUS_SUCCESS;

end:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\makefile.inc ===
lprmnmsg.h lprmnmsg.rc msg00001.bin: lprmnmsg.mc
    mc -v lprmnmsg.mc
clean::
    del lprmnmsg.rc lprmnmsg.rc msg00001.bin
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\httptypes.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    httptypes.h

Abstract:

    The definition of HTTP specific types

Author:


Revision History:

--*/


#ifndef _HTTPTYPES_H_
#define _HTTPTYPES_H_

#define CR          0x0D
#define LF          0x0A
#define SP          0x20
#define HT          0x09

#define CRLF_SIZE   2
#define CRLF        0x0A0D          // Reversed for endian switch
#define LFLF        0x0A0A

#define UPCASE_CHAR(c)  ((c) & 0xdf)

//
// The enum type for our parse state.
//
typedef enum _PARSE_STATE
{
    ParseVerbState,
    ParseURLState,
    ParseVersionState,
    ParseHeadersState,
    ParseDoneState
} PARSE_STATE, *PPARSE_STATE;

// The enum type for the HTTP connection state.
//
typedef enum _HTTP_STATE
{
    HttpInitialState,
    HttpReadRequestState,
    HttpReadBodyState,
    HttpClosingState
} HTTP_STATE, *PHTTP_STATE;

//
// Structure we use for tracking headers from incoming requests. The pointer
// points into a buffer we received from the transport, unless the OurBuffer
// flag is set, which indicates we had to allocate a buffer and copy the header
// due to multiple occurences of the header or a continuation line.
//
typedef struct _HTTP_HEADER
{
    ULONG       HeaderLength;
    PUCHAR      pHeader;
    ULONG       OurBuffer:1;
    ULONG       Valid:1;

} HTTP_HEADER, *PHTTP_HEADER;

//
// Structure we use for tracking unknown headers. These structures are
// dyanmically allocated when we see an unknown header.
//
typedef struct _HTTP_UNKNOWN_HEADER
{
    LIST_ENTRY  List;
    ULONG       HeaderNameLength;
    PUCHAR      pHeaderName;
    HTTP_HEADER HeaderValue;

} HTTP_UNKNOWN_HEADER, *PHTTP_UNKNOWN_HEADER;


//
// Structure we use for a local copy of the data from the transport's
// buffer .
//
typedef struct _UL_REQUEST_BUFFER
{
    LIST_ENTRY  ListEntry;
    /*
    UCHAR       pBuffer[0];
    */

} UL_REQUEST_BUFFER, *PUL_REQUEST_BUFFER;


//
// Structure used for tracking an HTTP connection, which may represent
// either a real TCP connection or a virtual MUX connection.
//

typedef struct _HTTP_CONNECTION         // HttpConn
{
    UL_HTTP_CONNECTION_ID  ConnectionID;           // Opaque ID for this
                                                // connection.
    /*

    UL_SPIN_LOCK        SpinLock;               // Spinlock protecting this
                                                // connection.
    union
    {
        UL_WORK_ITEM    WorkItem;               // A work item, used for queuing
        LIST_ENTRY      ListEntry;              // or simply queue it with this
    };
    */

    ULONG               RefCount;               // Reference count of this
                                                // connection.

    ULONG               NextRecvNumber;         // Receive sequence number.
    ULONG               NextSendNumber;         // Send sequence number.

    HTTP_STATE          HttpState;              // Current state of the
                                                // HTTP connection.
    PARSE_STATE         ParseState;             // Current state of our parsing
                                                // effort.

    ULONG               TotalRequestSize;       // Total bytes needed for this
                                                // request.

    ULONG               KnownHeaderCount;       // Number of 'known' headers we
                                                // have.

    ULONG               UnknownHeaderCount;     // Number of 'unknown' headers
                                                // we have.
    UL_HTTP_VERB        Verb;                   // Verb of this request.
    PUCHAR              pRawVerb;               // Pointer to raw verb, valid
                                                // if Verb == UnknownVerb.
    ULONG               RawVerbLength;          // Length of raw verb.

    struct
    {

        PUCHAR          pUrl;                   // The raw URL.

                                                // all of the below ptrs point
                                                // into pUrl
                                                // ==========================

        PUCHAR          pHost;                  // host part, if any
        PUCHAR          pAbsPath;               // points to the abs_path part

                                                // ==========================
                                                //
        ULONG           Length;                 // The length of the raw URL.

    } RawUrl;

    struct
    {

        PWSTR           pUrl;                   // The canonicalized, fully
                                                // qualified URL.

                                                // all of the below ptrs point
                                                // into pUrl
                                                // ==========================

        PWSTR           pHost;                  // points to the host part
        PWSTR           pAbsPath;               // points to the abs_path part
        PWSTR           pQueryString;           // points to the query string

                                                // ==========================
                                                //

        ULONG           Length;                 // the entire length (Bytes)
        ULONG           Hash;                   // the entire 32-bit hash

    } CookedUrl;                                // mmm... tasty

    UL_HTTP_VERSION     Version;                // Version of current request.
    ULONG               HeaderBufferOwnedCount; // Count of header buffers we own.
    HTTP_HEADER         Headers[UlHeaderMaximum]; // Array of headers.
    LIST_ENTRY          UnknownHeaderList;      // List of headers we don't
                                                // know about.

    UL_URL_CONTEXT      UrlContext;             // The context for the url.

    /*
    PUL_CONNECTION      pConnection;            // Associated TDI/MUX connection
    */
    
    LIST_ENTRY          BufferHead;             // A list of buffers that we use to
                                                // store the protocol part of the
                                                // request (non-body)

} HTTP_CONNECTION, *PHTTP_CONNECTION;


#endif // _HTTPTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\parse.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    parse.h

Abstract:

    Contains all of the public definitions for the HTTP parsing code.

Author:

    Henry Sanders (henrysa)       04-May-1998

Revision History:

--*/

#ifndef _PARSE_H_
#define _PARSE_H_

extern "C"
{
//
// The initialization routine.
//
NTSTATUS InitializeParser(VOID);

//
// The main HTTP parse routine.
//
NTSTATUS
ParseHttp(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    OUT ULONG               *pBytesTaken
    );

//
// Utility tokenizing routine.
//
PUCHAR
FindWSToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *TokenLength
    );

NTSTATUS
UlCookUrl(
    PHTTP_CONNECTION pHttpConn
    );
}

#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\rcvhdrs.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    rcvhdrs.h

Abstract:

    Contains definitions for rcvhdrs.c .

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#ifndef _RCVHDRS_H_
#define _RCVHDRS_H_

ULONG
DefaultHeaderHandler(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    );

ULONG
FindHeaderEnd(
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength
    );

BOOLEAN
AppendHeaderValue(
    IN  PHTTP_HEADER        pHttpHeader,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength
    );

#endif  // _RCVHDRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\httputil.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    httputil.h

Abstract:

    Contains miscellaneous utility definitions.

Author:

    Henry Sanders (henrysa)       12-May-1998

Revision History:

--*/

#ifndef _HTTPUTIL_H_
#define _HTTPUTIL_H_

#ifdef __cplusplus
extern"C"
#else
extern
#endif
ULONG   HttpChars[256];

#define HTTP_CHAR           0x01
#define HTTP_UPCASE         0x02
#define HTTP_LOCASE         0x04
#define HTTP_ALPHA          (HTTP_UPCASE | HTTP_LOCASE)
#define HTTP_DIGIT          0x08
#define HTTP_CTL            0x10
#define HTTP_LWS            0x20
#define HTTP_HEX            0x40
#define HTTP_SEPERATOR      0x80
#define HTTP_TOKEN          0x100

#define IS_HTTP_UPCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_LOCASE(c)       (HttpChars[(UCHAR)(c)] & HTTP_UPCASE)
#define IS_HTTP_ALPHA(c)        (HttpChars[(UCHAR)(c)] & HTTP_ALPHA)
#define IS_HTTP_DIGIT(c)        (HttpChars[(UCHAR)(c)] & HTTP_DIGIT)
#define IS_HTTP_CTL(c)          (HttpChars[(UCHAR)(c)] & HTTP_CTL)
#define IS_HTTP_LWS(c)          (HttpChars[(UCHAR)(c)] & HTTP_LWS)
#define IS_HTTP_SEPERATOR(c)    (HttpChars[(UCHAR)(c)] & HTTP_SEPERATOR)    
#define IS_HTTP_TOKEN(c)        (HttpChars[(UCHAR)(c)] & HTTP_TOKEN)

#ifdef __cplusplus
extern"C"
#else
extern
#endif
NTSTATUS
InitializeHttpUtil(
    VOID
    );

#endif  // _HTTPUTIL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\parsep.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    parsep.h

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       04-May-1998

Revision History:

--*/

#ifndef _PARSEP_H_
#define _PARSEP_H_

#define MIN_VERSION_SIZE    (sizeof("HTTP/1.1\r\n") - 1)

#define MAX_VERB_LENGTH     (sizeof("PROPPATCH"))

#define HTTP_11_VERSION 0x312e312f50545448
#define HTTP_10_VERSION 0x302e312f50545448

#define UPCASE_MASK ((ULONGLONG)0xdfdfdfdfdfdfdfdf)

#define MAX_HEADER_LONG_COUNT   3
#define MAX_HEADER_LENGTH       (MAX_HEADER_LONG_COUNT * sizeof(ULONGLONG))

#define NUMBER_HEADER_INDICIES  26



#define HTTP_PREFIX         'http'
#define HTTP_PREFIX_SIZE    (sizeof("http") - 1)

#define HTTP_PREFIX1        '://\0'
#define HTTP_PREFIX1_SIZE   (sizeof("://") - 1)
#define HTTP_PREFIX1_MASK   0x00ffffff

#define HTTP_PREFIX2        's://'
#define HTTP_PREFIX2_SIZE   (sizeof("s://") - 1)

#define MAX_PORT_LENGTH     10  // 0xffffffff = 4294967295 = 10 chars = 10 bytes


typedef ULONG   (*PFN_HEADER_HANDLER)(PHTTP_CONNECTION  pHttpConn,
                                      PUCHAR            pHttpRequest,
                                      ULONG             HttpRequestLength,
                                      UL_HTTP_HEADER_ID HeaderID
                                      );

//
// Structure of the fast verb lookup table. The table consists of a series of
// entries where each entry contains an HTTP verb represented as a ulonglong,
// a mask to use for comparing that verb, the length of the verb and the
// translated id.
//
typedef struct _FAST_VERB_ENTRY
{
    union
    {
        UCHAR       Char[sizeof(ULONGLONG)+1];
        ULONGLONG   LongLong;
    }           RawVerb;
    ULONGLONG   RawVerbMask;
    ULONG       RawVerbLength;
    UL_HTTP_VERB   TranslatedVerb;

} FAST_VERB_ENTRY, *PFAST_VERB_ENTRY;

//
// Stucture of the all verb lookup table. This table holds all verbs that
// we understand, including those that are too long to fit in the fast
// verb table.
//
typedef struct _LONG_VERB_ENTRY
{
    ULONG       RawVerbLength;
    UCHAR       RawVerb[MAX_VERB_LENGTH];
    UL_HTTP_VERB   TranslatedVerb;

} LONG_VERB_ENTRY, *PLONG_VERB_ENTRY;

//
// Structure for a header map entry. Each header map entry contains a
// verb and a series of masks to use in checking that verb.
//
typedef struct _HEADER_MAP_ENTRY
{
    ULONG               HeaderLength;
    ULONG               ArrayCount;
    ULONG               MinBytesNeeded;
    union
    {
        UCHAR               HeaderChar[MAX_HEADER_LENGTH];
        ULONGLONG           HeaderLong[MAX_HEADER_LONG_COUNT];
    }                   Header;
    ULONGLONG           HeaderMask[MAX_HEADER_LONG_COUNT];

    UL_HTTP_HEADER_ID      HeaderID;
    PFN_HEADER_HANDLER  pHandler;

}  HEADER_MAP_ENTRY, *PHEADER_MAP_ENTRY;


//
// Structure for a header index table entry.
//
typedef struct _HEADER_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    ULONG               Count;

} HEADER_INDEX_ENTRY, *PHEADER_INDEX_ENTRY;

//
// A (complex) macro to create a mask for a header map entry,
// given the header length and the mask offset (in bytes). This
// mask will need to be touched up for non-alphabetic characters.
//
#define CREATE_HEADER_MASK(hlength, maskoffset) \
    ((hlength) > (maskoffset) ? UPCASE_MASK : \
        (((maskoffset) - (hlength)) >= 8 ? 0 : \
        (UPCASE_MASK >> ( ((maskoffset) - (hlength)) * (ULONGLONG)8))))

// Macro for creating header map entries. The mask entries are created
// by the init code.

#define CREATE_HEADER_MAP_ENTRY(header, ID, handler) { \
    \
    sizeof(#header) - 1, \
    ((sizeof(#header) - 1) / 8) + \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1), \
    (((sizeof(#header) - 1) / 8) + \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1)) * 8, \
    { #header }, \
    { 0, 0, 0}, \
    ID, \
    handler, \
    }

//
// Macro for defining fast verb table entries. Note that we don't subtrace 1
// from the various sizeof occurences because we'd just have to add it back
// in to account for the seperating space.
//
#define CREATE_FAST_VERB_ENTRY(verb)    { {#verb " "}, \
                                                (0xffffffffffffffff >> \
                                                ((8 - (sizeof(#verb))) * 8)), \
                                                (sizeof(#verb)), UlHttpVerb##verb }
//
// Macro for defining all verb table entries.
//
#define CREATE_LONG_VERB_ENTRY(verb)    { sizeof(#verb) - 1, \
                                             #verb,\
                                             UlHttpVerb##verb }

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)

NTSTATUS
CheckForAbsoluteURL(
    IN  PUCHAR      pURL,
    IN  ULONG       URLLength,
    IN  PUCHAR      *pHostPtr,
    IN  ULONG       *BytesTaken
    );

UL_HTTP_VERB
LookupVerb(
    IN  PUCHAR pHttpRequest,
    IN  ULONG  HttpRequestLength,
    OUT PUCHAR *ppVerb,
    OUT ULONG  *pVerbLength,
    OUT ULONG  *pBytesTaken
    );

ULONG
ParseHeader(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength
    );


ULONG
LookupHeader(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHttpRequest,
    IN  ULONG               HttpRequestLength,
    IN  PHEADER_MAP_ENTRY   pCurrentHeaderMap,
    IN  ULONG               HeaderMapCount
    );

NTSTATUS
UlpCleanAndCopyUrl(
    IN      BOOLEAN MakeCanonical,
    IN OUT  PWSTR   pDestination,
    IN      PUCHAR  pSource,
    IN      ULONG   SourceLength,
    OUT     PULONG  pBytesCopied,
    OUT     PWSTR * ppQueryString,
    OUT     PULONG  pUrlHash
    );

#endif // _PARSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\rcvhdrs.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    rcvhdrs.c

Abstract:

    Contains all of the per header handling code for received headers.

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#include    "precomp.hxx"
#include    "httptypes.h"
#include    "rcvhdrs.h"

/*++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a header.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    TokenLength     - Where to return the length of the token.

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--*/
ULONG
FindHeaderEnd(
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength
    )
{
    UCHAR       CurrentChar;
    ULONG       CurrentOffset;
    BOOLEAN     HaveCR;
    BOOLEAN     HaveHeader;

    HaveCR = FALSE;
    HaveHeader = FALSE;

    //
    // While we still have data, loop through looking for a CRLF or LFLF pair.
    //

    for (CurrentOffset = 0; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);

        //
        // If this character is a CR or LF, we may be done.
        //
        if (CurrentChar == CR || CurrentChar == LF)
        {
            // If we've already seen a CR (or LF) immediately preceding this,
            // see if this is a LF to terminate the line.

            if (HaveCR)
            {
                if (CurrentChar == LF)
                {
                    // It is a LF, so we're done.

                    HaveHeader = TRUE;
                    break;
                }

                // Otherwise, we have a non LF after a CR (or LF). The only
                // character this could be is a CR, since we're inside
                // the if statement. This could be the start of a CRLF
                // sequence, if this is some bizarre LFCRLF or CRCRLF
                // sort of thing. Anyway, we don't want to set HaveCR
                // to false here.

                ASSERT(CurrentChar == CR);

            }
            else
            {
                // Otherwise, we haven't seen the start of the terminating pair
                // yet, so remember that we now have.

                HaveCR = TRUE;
            }
        }
        else
        {
            // Set HaveCR to false, since this character is neither a CR or
            // or LF, and we need to find a new potential start.

            HaveCR = FALSE;
        }

    }

    // If we found the termination OK, return the length of the value.
    if (HaveHeader)
    {
        return CurrentOffset+1;     // Update for the last character
    }

    return 0;
}

/*++

Routine Description:

    Append a header value to an existing HTTP_HEADER entry, allocating
    a buffer and copying the existing buffer.

Arguments:

    pHttpHeader     - Pointer to HTTP_HEADER structure to append to.
    pHeader         - Pointer header to be appended.
    HeaderLength    - Length of data pointed to by pHeader.

Return Value:

    TRUE if we succeed, FALSE otherwise.

--*/
BOOLEAN
AppendHeaderValue(
    PHTTP_HEADER    pHttpHeader,
    PUCHAR          pHeader,
    ULONG           HeaderLength
    )
{
    PUCHAR          pNewHeader, pOldHeader;
    ULONG           OldHeaderLength;


    OldHeaderLength = pHttpHeader->HeaderLength;

    /*
    pNewHeader = UL_ALLOCATE_POOL(NonPagedPool,
                                  OldHeaderLength + HeaderLength +
                                    sizeof(", ") - 1,
                                  UL_REGISTRY_DATA_POOL_TAG
                                  );
    */

    pNewHeader = (PUCHAR) LocalAlloc(LMEM_FIXED,
                                  OldHeaderLength + HeaderLength +
                                    sizeof(", ") - 1
                                  );

    if (pNewHeader == NULL)
    {
        // Had a failure.

        return FALSE;
    }

    //
    // Copy the old data into the new header.
    //
    memcpy( pNewHeader,
            pHttpHeader->pHeader,
            OldHeaderLength
          );


    // And copy in the new data as well, seperated by a comma.

    *(pNewHeader + OldHeaderLength) = ',';
    *(pNewHeader + OldHeaderLength + 1) = ' ';
    OldHeaderLength += sizeof(", ") - 1;

    memcpy( pNewHeader + OldHeaderLength, pHeader, HeaderLength);

    // Now replace the existing header.

    pOldHeader = pHttpHeader->pHeader;
    pHttpHeader->HeaderLength = OldHeaderLength + HeaderLength;
    pHttpHeader->pHeader = pNewHeader;

    // If the old header was our buffer, free it too.
    //
    if (pHttpHeader->OurBuffer)
    {
        LocalFree( pOldHeader );
    }

    pHttpHeader->OurBuffer = 1;

    return TRUE;
}

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
ULONG
DefaultHeaderHandler(
    IN  PHTTP_CONNECTION    pHttpConn,
    IN  PUCHAR              pHeader,
    IN  ULONG               HeaderLength,
    IN  HTTP_HEADER_ID      HeaderID
    )
{
    ULONG       HeaderValueLength;

    HeaderValueLength = FindHeaderEnd(pHeader, HeaderLength);

    if (HeaderValueLength != 0)
    {
        if (!pHttpConn->Headers[HeaderID].Valid)
        {
            // No existing header, just save this pointer for now.
            //
            pHttpConn->Headers[HeaderID].Valid = TRUE;
            pHttpConn->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pHttpConn->Headers[HeaderID].pHeader = pHeader;
            pHttpConn->TotalRequestSize += HeaderValueLength;
            pHttpConn->KnownHeaderCount++;

        }
        else
        {
            ULONG           OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pHttpConn->Headers[HeaderID].HeaderLength;

            if (!AppendHeaderValue(&pHttpConn->Headers[HeaderID],
                                    pHeader,
                                    HeaderLength) )
            {
                // BUGBUG need to handle this better.

                ASSERT(FALSE);
                return 0;
            }

            // Update total request length for the amount we just added.
            pHttpConn->TotalRequestSize +=
                (pHttpConn->Headers[HeaderID].HeaderLength - OldHeaderLength);

            pHttpConn->HeaderBufferOwnedCount++;
        }

    }

    return HeaderValueLength;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\httputil.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    httputil.c

Abstract:

    Contains miscellaneous utility functions.

Author:

    Henry Sanders (henrysa)       12-May-1998

Revision History:

--*/

#include    "precomp.hxx"
#include    "httptypes.h"
#include    "httputil.h"

ULONG   HttpChars[256];

/*++

Routine Description:

    Routine to initialize the utilitu code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeHttpUtil(
    VOID
    )
{
    ULONG               i;

    // Initialize the HttpChars array appropriately.

    for (i = 0; i < 128; i++)
    {
        HttpChars[i] = HTTP_CHAR;
    }

    for (i = 'A'; i <= 'Z'; i++)
    {
        HttpChars[i] |= HTTP_UPCASE;
    }

    for (i = 'a'; i <= 'z'; i++)
    {
        HttpChars[i] |= HTTP_LOCASE;
    }

    for (i = '0'; i <= '9'; i++)
    {
        HttpChars[i] |= (HTTP_DIGIT | HTTP_HEX);
    }


    for (i = 0; i <= 31; i++)
    {
        HttpChars[i] |= HTTP_CTL;
    }

    HttpChars[127] |= HTTP_CTL;

    HttpChars[SP] |= HTTP_LWS;
    HttpChars[HT] |= HTTP_LWS;


    for (i = 'A'; i <= 'F'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    for (i = 'a'; i <= 'f'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    HttpChars['('] |= HTTP_SEPERATOR;
    HttpChars[')'] |= HTTP_SEPERATOR;
    HttpChars['<'] |= HTTP_SEPERATOR;
    HttpChars['>'] |= HTTP_SEPERATOR;
    HttpChars['@'] |= HTTP_SEPERATOR;
    HttpChars[','] |= HTTP_SEPERATOR;
    HttpChars[';'] |= HTTP_SEPERATOR;
    HttpChars[':'] |= HTTP_SEPERATOR;
    HttpChars['\\'] |= HTTP_SEPERATOR;
    HttpChars['"'] |= HTTP_SEPERATOR;
    HttpChars['/'] |= HTTP_SEPERATOR;
    HttpChars['['] |= HTTP_SEPERATOR;
    HttpChars[']'] |= HTTP_SEPERATOR;
    HttpChars['?'] |= HTTP_SEPERATOR;
    HttpChars['='] |= HTTP_SEPERATOR;
    HttpChars['{'] |= HTTP_SEPERATOR;
    HttpChars['}'] |= HTTP_SEPERATOR;
    HttpChars[SP] |= HTTP_SEPERATOR;
    HttpChars[HT] |= HTTP_SEPERATOR;

    for (i = 0; i < 128; i++)
    {
        if (!IS_HTTP_SEPERATOR(i) && !IS_HTTP_CTL(i))
        {
            HttpChars[i] |= HTTP_TOKEN;
        }
    }

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\ulchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      UlChannel.cxx

   Abstract:
      Implements the simple CHANNEL for the UL simulator

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Nov-1998

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "httptypes.h"
# include "ulchannel.hxx"
# include "socklib.hxx"
# include "mswsock.h"
# include <string.h>
# include <httptypes.h>
# include <parse.h>
# include <httputil.h>
# include <stringau.hxx>
# include <httputil.h>

#include <stdio.h>
#include <wtypes.h>
#include <atlbase.h>
#include <atlconv.h>
#include <atlconv.cpp>

/************************************************************
 *    Member Functions for ULSIM_CONNECTION
 *
 *    A connection object is created everytime a new request
 *      operation is submitted. The connection object
 *      encapsulates the read buffers for HTTP request and
 *      stores the connected socket for data transmissions.
 *
 *    Current implementation assumes simple synchronous socket
 *      operation.
 ************************************************************/

HRESULT
ULSIM_CONNECTION::SetReceiveBuffers(
   IN LPVOID pRequestBuffer,
   IN DWORD RequestBufferLength,
   OUT LPDWORD pBytesReturned OPTIONAL,
   IN LPOVERLAPPED pOverlapped OPTIONAL
   )
{
    m_pRequestBuffer      = pRequestBuffer;
    m_RequestBufferLength = RequestBufferLength;
    m_pBytesReturned      = pBytesReturned;
    m_pOverlapped         = pOverlapped;

    return (NOERROR);
} // ULSIM_CONNECTION::SetReceiveBuffers()


HRESULT
ULSIM_CONNECTION::AcceptConnection( IN SOCKET listenSocket)
{
    m_saAddrLen = sizeof( m_saAddr);
    memset( &m_saAddr, 0, m_saAddrLen);

    m_sConnection = accept( listenSocket, (PSOCKADDR ) &m_saAddr, &m_saAddrLen);
    if ( m_sConnection == INVALID_SOCKET)
    {
        return (HRESULT_FROM_WIN32( WSAGetLastError()));
    }

    IF_DEBUG( CONNECTION)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Accepted a new connection from (%s)\n",
                    inet_ntoa( m_saAddr.sin_addr)
                    ));
    }

    return (NOERROR);
} // ULSIM_CONNECTION::AcceptConnection()


ULONG
ULSIM_CONNECTION::ReceiveData(
    OUT PBYTE       rgBuffer,
    IN OUT LPDWORD  pcbData
    )
{
    int cbRead;

    cbRead = recv( m_sConnection,
                   (char * ) rgBuffer,
                   *pcbData,
                   0);

    if (cbRead == SOCKET_ERROR)
    {
        return WSAGetLastError();
    }

    *pcbData = cbRead;

    IF_DEBUG( CONNECTION)
    {
        DBGPRINTF(( DBG_CONTEXT,
                "Conn(%08x)::ReceiveData( %08x)=> %d bytes read\n",
                this, rgBuffer, cbRead
                ));
    }

    return (NO_ERROR);
} // ULSIM_CONNECTION::ReceiveData()

HRESULT
ULSIM_CONNECTION::SendData(
    IN PBYTE       rgBuffer,
    IN OUT LPDWORD  pcbData
    )
{
    int cbSent;

    cbSent = send( m_sConnection,
                   (const char * )rgBuffer,
                   *pcbData,
                   0);

    IF_DEBUG( CONNECTION)
    {
        DBGPRINTF(( DBG_CONTEXT,
                "Conn(%08x)::SendData( %08x, %d)=> %d bytes sent\n",
                this, rgBuffer, *pcbData, cbSent
                ));
    }

    if (cbSent == SOCKET_ERROR)
    {
        return (HRESULT_FROM_WIN32( WSAGetLastError()));
    }

    *pcbData = cbSent;

    return (NOERROR);
} // ULSIM_CONNECTION::SendData()

VOID
ULSIM_CONNECTION::CopyParsedRequest(
    IN PHTTP_CONNECTION  pHttpConnection,
    IN PUL_HTTP_REQUEST pUlHttpRequest
    )
{
    int i;

    USES_CONVERSION;

    PUCHAR  pBuffer = (PUCHAR)pUlHttpRequest+sizeof(UL_HTTP_REQUEST);

    pUlHttpRequest->ConnectionId = (ULONGLONG) this;

    pUlHttpRequest->RequestId    = (ULONGLONG) this;

    pUlHttpRequest->Version      = pHttpConnection->Version;

    pUlHttpRequest->Verb              = pHttpConnection->Verb;

    pUlHttpRequest->RawUrlLength      = (USHORT)pHttpConnection->RawUrl.Length*2;
    pUlHttpRequest->pRawUrl           = (PWSTR) pBuffer;     // after verb

    memcpy( pBuffer,
            A2W((LPSTR)pHttpConnection->RawUrl.pUrl),
            pUlHttpRequest->RawUrlLength );

    pBuffer += pUlHttpRequest->RawUrlLength + 2;

    *(pBuffer-2) = 0;
    *(pBuffer-1) = 0;


    pUlHttpRequest->FullUrlLength    = (USHORT)pHttpConnection->CookedUrl.Length*2 ;
    pUlHttpRequest->pFullUrl         = (PWSTR) pBuffer ;   // after raw URL

    memcpy( pBuffer,
            pHttpConnection->CookedUrl.pUrl,
            pUlHttpRequest->FullUrlLength
          );

    pBuffer += pUlHttpRequest->FullUrlLength + 2;
    *(pBuffer-2) = 0;
    *(pBuffer-1) = 0;

    pUlHttpRequest->pHost          =  (NULL == pHttpConnection->CookedUrl.pHost) ? NULL  :
                                              pUlHttpRequest->pFullUrl + (
                                              pHttpConnection->CookedUrl.pHost -
                                              pHttpConnection->CookedUrl.pUrl) ;

    pUlHttpRequest->pAbsPath       = (NULL == pHttpConnection->CookedUrl.pAbsPath) ? NULL :
                                              pUlHttpRequest->pFullUrl + (
                                              pHttpConnection->CookedUrl.pAbsPath -
                                              pHttpConnection->CookedUrl.pUrl) ;

    pUlHttpRequest->pQueryString   = (NULL == pHttpConnection->CookedUrl.pQueryString) ? NULL :
                                              pUlHttpRequest->pFullUrl + (
                                              pHttpConnection->CookedUrl.pQueryString -
                                              pHttpConnection->CookedUrl.pUrl) ;

    pUlHttpRequest->HostLength = (pUlHttpRequest->pAbsPath - pUlHttpRequest->pHost) * 2;

    if ( pUlHttpRequest->pQueryString )
    {
        pUlHttpRequest->AbsPathLength = (pUlHttpRequest->pQueryString - pUlHttpRequest->pAbsPath) * 2;
        pUlHttpRequest->QueryStringLength = (USHORT)(pHttpConnection->CookedUrl.Length -
                                            (pHttpConnection->CookedUrl.pQueryString -
                                            pHttpConnection->CookedUrl.pUrl))*2;

    }
    else
    {
        pUlHttpRequest->AbsPathLength = (USHORT)(pHttpConnection->CookedUrl.Length -
                                        ((pHttpConnection->CookedUrl.pAbsPath -
                                        pHttpConnection->CookedUrl.pUrl)*2) );

        pUlHttpRequest->QueryStringLength =  0;
    }


    //
    // Copy known headers
    //

    PUL_HEADER_VALUE pHttpHeader = pUlHttpRequest->Headers.pKnownHeaders;

    for (i = 0 ; i < UlHeaderRequestMaximum ; i++)
    {
        if ( pHttpConnection->Headers[i].HeaderLength )
        {
            //
            // Copy the header sans the CRLF and leading white spaces.
            //

            pHttpHeader[i].RawValueLength =
                            ((USHORT)pHttpConnection->Headers[i].HeaderLength - 2)*2;

            PUCHAR   pCh = pHttpConnection->Headers[i].pHeader;

            while (IS_HTTP_LWS(*pCh))
            {
                pCh++;
                pHttpHeader[i].RawValueLength--;
            }

            memcpy( pBuffer,
                    A2W((LPSTR)pCh),
                    pHttpHeader[i].RawValueLength
                  );

            pHttpHeader[i].pRawValue = (LPWSTR) pBuffer;

            pBuffer += pHttpHeader[i].RawValueLength +2 ;

            *(pBuffer-2) = 0;
            *(pBuffer-1) = 0;
        }
        else
        {
            pHttpHeader[i].RawValueLength = 0;
            pHttpHeader[i].pRawValue      = NULL;
        }
    }

    pUlHttpRequest->Headers.UnknownHeaderCount = 0;             // assume no unknown headers for now
    pUlHttpRequest->Headers.pUnknownHeaders = NULL;
    pUlHttpRequest->EntityBodyLength   = 0;             // assume no entity body for now
    pUlHttpRequest->pEntityBody   = NULL;

} // ULSIM_CONNECTION::CopyParsedRequest()


HRESULT
ULSIM_CONNECTION::ParseIntoHttpRequest(
    IN PBYTE    rgbBuffer,
    IN DWORD    cbRead
    )
{
    HRESULT hr = NOERROR;
    PUL_HTTP_REQUEST pur = (PUL_HTTP_REQUEST ) m_pRequestBuffer;

    //
    // Need to parse the request into the supplied object.
    //

    rgbBuffer[cbRead++] = '\0';
    OutputDebugStringA(" <--- Request is NOT parsed\n");
    OutputDebugStringA((const char * ) rgbBuffer);
    OutputDebugStringA(" ---> Request End\n");

#ifdef TEST_IMPL
    m_cbRead = 0;

# define TEST_URL  "/"
# define TEST_REQUEST_LENGTH  (sizeof(UL_HTTP_REQUEST) + sizeof( TEST_URL))

    if ( m_RequestBufferLength < TEST_REQUEST_LENGTH) {

        *m_pBytesReturned = TEST_REQUEST_LENGTH;
        return (HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER));
    }

    //
    // setup the member fields directly in the fake request object
    //
    pur->ConnectionID      = (HTTP_CONNECTION_ID ) this;
    pur->ReceiveSequenceNumber = 1;
    pur->Verb              = GETVerb;
    pur->VerbLength        = 0;
    pur->VerbOffset        = 0;
    pur->RawURLLength      = sizeof(TEST_URL);
    pur->RawURLOffset      = sizeof(UL_HTTP_REQUEST); // starts after req.
    pur->URLLength         = sizeof(TEST_URL);
    pur->URLOffset         = sizeof(UL_HTTP_REQUEST);
    pur->UnknownHeaderCount= 0;
    pur->UnknownHeaderOffset= 0;
    pur->EntityBodyLength  = 0;
    pur->EntityBodyOffset  = 0;

    memcpy( (PBYTE) (pur + 1), TEST_URL, sizeof(TEST_URL));

    m_cbRead = TEST_REQUEST_LENGTH;

#else

    if ( m_RequestBufferLength < cbRead)
    {
        *m_pBytesReturned = cbRead;
        return (HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER));
    }

    HTTP_CONNECTION     HttpConnection = {0};
    ULONG               cbBytesTaken;

    NTSTATUS err = ParseHttp( &HttpConnection,
                              rgbBuffer,
                              cbRead,
                              &cbBytesTaken
                              );

    switch (err)
    {
        case STATUS_MORE_PROCESSING_REQUIRED:
            hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER);
            break;

        case STATUS_INVALID_DEVICE_REQUEST:
            hr = E_FAIL;
            break;

        case STATUS_SUCCESS:

            cbBytesTaken += sizeof(UL_HTTP_REQUEST);

            if ( m_RequestBufferLength < cbBytesTaken)
            {
                *m_pBytesReturned = cbBytesTaken;
                hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                UlCookUrl(&HttpConnection);

                ZeroMemory(pur, sizeof(UL_HTTP_REQUEST));
                CopyParsedRequest(&HttpConnection, pur);
                m_cbRead = cbBytesTaken;
                hr = S_OK;
            }
            break;

        default:

            DBGPRINTF((DBG_CONTEXT,
                "Unknown return code (%u) from Parse\n",
                err
                ));
            break;
    }

 #endif

    IF_DEBUG( CONNECTION)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Conn[%08x]:Parse(%08x, %d) => parsed request %d bytes\n",
            this, rgbBuffer, cbRead, m_cbRead
            ));
    }

    if ( NULL != m_pBytesReturned)
    {
        *m_pBytesReturned = m_cbRead;
    }


    return (hr);
} // ULSIM_CONNECTION::ParseIntoHttpRequest()


/********************************************************************++
  Description:
    This module transmits the given file using synchronous IO.
    This is mainly intended for simulation purpose.

  Arguments:
     pszFileName - name of the file containing contents to be sent out.
     byteRange   - range within the file that should be sent out.
     pcbData     - returns the count of bytes sent out

  Returns:
     HRESULT - NOERROR on success and error on failure.
--********************************************************************/
HRESULT
ULSIM_CONNECTION::TransmitFile(
        IN LPCWSTR                pszFileName,
        IN HANDLE                 hFileHandle,
        IN const UL_BYTE_RANGE &  byteRange,
        OUT LPDWORD               pcbData
        )
{
    HRESULT hr = NOERROR;
    HANDLE hFile;
    LONG cbHigh = byteRange.StartingOffset.HighPart;
    DWORD dwError;
    DWORD cbBytesToSend;

    DBG_ASSERT( (pszFileName == NULL) || (hFileHandle == NULL));
    DBG_ASSERT( !((pszFileName == NULL) && (hFileHandle == NULL)));

    DBG_ASSERT( pcbData != NULL);
    *pcbData = 0;

    hFile = hFileHandle;

    if (NULL == hFile)
    {
        //
        // Open the file for transmission.
        //
        hFile = CreateFile( pszFileName,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL
                            );
    }

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        goto Cleanup;
    }

    //
    // Seek to the starting offset specified.
    //
    dwError = SetFilePointer(
                 hFile,
                 byteRange.StartingOffset.LowPart,
                 &cbHigh,
                 FILE_BEGIN
                 );
    if (dwError == 0xFFFFFFFF)
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        goto Cleanup;
    }

    //
    // Transmit the file using synchronous IO model
    // Assume that we do not have high order bit in the size specified
    //
    if (byteRange.Length.QuadPart == UL_BYTE_RANGE_TO_EOF)
    {
        cbBytesToSend = 0; // 0 indicates that we need to send till end of file

        *pcbData = GetFileSize(hFile, NULL);
        if (*pcbData == 0xFFFFFFFF)
        {
            hr = HRESULT_FROM_WIN32( GetLastError());
            goto Cleanup;
        }
    }
    else
    {
        // only use the lower part of the byte range.
        *pcbData = cbBytesToSend = byteRange.Length.LowPart;
        DBG_ASSERT( byteRange.Length.HighPart == 0);
    }

    if (!::TransmitFile( m_sConnection,
                       hFile,
                       cbBytesToSend,
                       0,   // let system decide the bytes per send.
                       NULL, // no overlapped structure, we expect sync. operation
                       NULL, // no header/tail buffers
                       0     // flags for send operation
                       )
       )
    {
      hr = HRESULT_FROM_WIN32( GetLastError());
    }

Cleanup:

    //
    // Only close file handles if it was opened locally
    //

    if ((hFile != INVALID_HANDLE_VALUE) && (NULL == hFileHandle))
    {
        CloseHandle(hFile);
    }

    if (FAILED(hr))
    {
        *pcbData = 0;
    }

    return (hr);

} // ULSIM_CONNECTION::TransmitFile()


/************************************************************
 *    Member Functions for ULSIM_CHANNEL
 ************************************************************/


/********************************************************************++
  Description:
    This is the thread back function for receiving new connection
    requests and posting them for completion using async io model.
    This function invokes the member function of the simulated channel
    object.

  Arguments:
    pSimChannel - pointer to the simulated channel object starting this thread

  Returns:
    None
--********************************************************************/
DWORD WINAPI
AcceptConnections( IN PVOID pSimChannel)
{
    ULSIM_CHANNEL * pusc = (ULSIM_CHANNEL * ) pSimChannel;

    return    pusc->AcceptConnectionsLoop();
}

ULSIM_CHANNEL::ULSIM_CHANNEL(void)
    : m_fVHost            (FALSE),   // vhost is not set up
      m_pszHostName       (NULL),
      m_dwVHostFlags      (0),

      m_fNSG              (FALSE),
      m_pszNameSpaceGroup (NULL),

      m_fURL              (FALSE),
      m_pszURL            (NULL),

      m_sListenSocket     (NULL),
      m_fDataChannel      (FALSE),
      m_dwDataChannelFlags(0),

      m_hCompletionPort   (NULL),
      m_pCompletionKey    (NULL),

      m_hConnectionsSemaphore (NULL),
      m_dwConnectionThread (0)
{
    InitializeCriticalSection( &m_csConnectionsList);
    InitializeListHead( &m_lConnections);

} // ULSIM_CHANNEL::ULSIM_CHANNEL()


ULSIM_CHANNEL::~ULSIM_CHANNEL(void)
{
    if ( NULL != m_pszHostName) {
        delete m_pszHostName;
        m_pszHostName = NULL;
    }

    if ( NULL != m_pszNameSpaceGroup) {
        delete m_pszNameSpaceGroup;
        m_pszNameSpaceGroup = NULL;
    }

    if (NULL != m_pszURL) {
        delete m_pszURL;
        m_pszURL = NULL;
    }

    if ( NULL != m_sListenSocket) {
        g_socketLibrary.CloseSocket( m_sListenSocket);
        m_sListenSocket = NULL;
    }

    m_hCompletionPort = NULL;
    m_pCompletionKey  = NULL;

    DeleteCriticalSection( &m_csConnectionsList);
    if ( m_hConnectionsSemaphore != NULL)
    {
        CloseHandle( m_hConnectionsSemaphore);
    }
} // ULSIM_CHANNEL::~ULSIM_CHANNEL()


HRESULT
ULSIM_CHANNEL::InitializeControlChannel(IN DWORD dwFlags)
{
    m_dwControlChannelFlags = dwFlags;
    return (NOERROR);
}


HRESULT
ULSIM_CHANNEL::AddNameSpaceGroup( IN LPCWSTR pszNameSpaceGroup)
{
    if ( m_fNSG ) {

        //
        // NYI: We do not support multiple NSGs in the simulator
        //

        return (HRESULT_FROM_WIN32( ERROR_DUP_NAME));
    }

    if ( NULL == pszNameSpaceGroup) {
        return (HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER));
    }

    DWORD cchLen = ((pszNameSpaceGroup != NULL) ?
                    lstrlenW( pszNameSpaceGroup) : 0);
    if (cchLen) {
        m_pszNameSpaceGroup = new WCHAR[cchLen + 1];
        if (!m_pszNameSpaceGroup) {
            return (HRESULT_FROM_WIN32(GetLastError()));
        }
        // Just making a direct copy for now!
        lstrcpy( m_pszNameSpaceGroup, pszNameSpaceGroup);
    }

    m_fNSG = TRUE;
    return (NOERROR);
}


BOOL
ULSIM_CHANNEL::IsNameSpaceGroup(IN LPCWSTR pszNSG)
{
    // do the namespace groups match up?
    return (!lstrcmp( pszNSG, m_pszNameSpaceGroup));
}


HRESULT
ULSIM_CHANNEL::AddURL(IN LPSTR pszURL)
{
    if ( m_fURL) {

        //
        // NYI: We do not support multiple URLs in the simulator
        //
        return (HRESULT_FROM_WIN32( ERROR_DUP_NAME));
    }

    if ( pszURL == NULL) {
        return (HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER));
    }

    DWORD cchLen = ((pszURL != NULL) ?
                    strlen( pszURL) : 0);
    if (cchLen) {
        m_pszURL = new char[cchLen + 1];
        if (!m_pszURL) {
            return (HRESULT_FROM_WIN32(GetLastError()));
        }
        // Just making a direct copy for now!
        lstrcpyA( m_pszURL, pszURL);
    }

    m_fURL = TRUE;
    return (NOERROR);
}

HRESULT
ULSIM_CHANNEL::InitializeDataChannel(IN DWORD dwFlags)
{
    HRESULT hr = NOERROR;

    if ( m_fDataChannel) {
        // only one binding of data channel is permitted
        return (HRESULT_FROM_WIN32( ERROR_DUP_NAME));
    }

    m_dwDataChannelFlags = dwFlags;
    m_fDataChannel = TRUE;
    InitializeParser();
    InitializeHttpUtil();

    if ( m_dwDataChannelFlags & UL_OPTION_OVERLAPPED)
    {
        m_hConnectionsSemaphore = CreateSemaphore( NULL, 0, MAX_QUEUED_ITEMS, NULL);
        if (m_hConnectionsSemaphore == NULL)
        {
            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }

    return (hr);
}

HRESULT
ULSIM_CHANNEL::CloseDataChannel(void)
{
    HRESULT hr = NOERROR;

    //
    // signal termination by closing the semapahore for processing connections
    // this forces the cleanup of the listening thread
    //
    if ( m_hConnectionsSemaphore != NULL)
    {
        if (!CloseHandle( m_hConnectionsSemaphore))
        {
            hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }

    return (hr);

} // ULSIM_CHANNEL::CloseDataChannel()

/********************************************************************++
  Description:
     The StartListen function sets up the entire infrastructure to
     enable the data channel to function properly.
     It uses the binding information specified as part of the control
     channel specification to build a listening endpoint.
     And then it sets up the socket listener in action.

     For simplicity, I choose to use the synchronous socket calls for listen.
     I can conceptually use ATQ stuff. However ATQ stuff is too involved
     and has several other code pieces it depends on, that I do not want
     to build a dependency for the same.

  Arguments:
     None

  Returns:
     HRESULT
--********************************************************************/
HRESULT
ULSIM_CHANNEL::StartListen(void)
{
    HRESULT hr;

    if (m_sListenSocket != NULL) {
        // already initailized
        return (NOERROR);
    }

    hr = g_socketLibrary.Initialize();
    if (FAILED(hr)) {
        return (hr);
    }

    //
    // Create, bind and set a socket in listening mode
    //

    hr = g_socketLibrary.CreateListenSocket(
              INADDR_ANY, // m_hostAddress.TcpIp.IpAddress,
              80,        // m_hostAddress.TcpIp.Port,
              &m_sListenSocket
              );

    return (hr);
} // ULSIM_CHANNEL::StartListen()


/********************************************************************++
  Description:
     For asynchrnous operation UL will post completions to the
     Completion port to which the handle is associated. However in
     the simulation we do not have a completion port. Hence we demand
     the user of UL to associate a completion port with our channel.
     When the completion port is associated we will also start a dedicated
     thread to do accept and dispatch for new connections at the listening socket.

  Arguments:
     None

  Returns:
     HRESULT
--********************************************************************/
HRESULT
ULSIM_CHANNEL::AssociateCompletionPort(
   IN HANDLE    hCompletionPort,
   IN ULONG_PTR CompletionKey
)
{
    HRESULT hr = NOERROR;

    //
    // Validate that the completion port is NOT already setup
    // and that the incoming completion port handle is valid
    //
    if ( !(m_dwDataChannelFlags & UL_OPTION_OVERLAPPED) ||
         (m_hCompletionPort != NULL) ||
         (hCompletionPort == NULL)
         )
    {
        return (HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER));
    }

    //
    // set the values up; the completion key is not interpreted by us
    //
    m_hCompletionPort = hCompletionPort;
    m_pCompletionKey  = CompletionKey;

    //
    // Start up a connection acceptance thread if one is not already present
    //
    if ( m_dwConnectionThread == 0)
    {
        HANDLE hThread;

        hThread = CreateThread( NULL,   // lpThreadAttributes
                                0,
                                AcceptConnections,
                                this,
                                0,
                                &m_dwConnectionThread
                                );
        if ( hThread != NULL )
        {
            // close the extra handle here.
            CloseHandle( hThread);

            IF_DEBUG( CHANNEL)
            {
               DBGPRINTF(( DBG_CONTEXT,
                   " Started IO Thread %d\n", m_dwConnectionThread
                   ));
            }
        } else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DPERROR(( DBG_CONTEXT, hr,
                " Unable to start the connection thread.\n"
                ));
        }
    }

    return (hr);
}

/********************************************************************++
  Description:
     This function notifies about IO completion. We do this by posting
     completion status to the completion port associated with this channel.
     In the simulator implementation, this function is called by the thread
     that came from the user. It sychronously completes the IO buts posts
     a message to simulate the async handling of IO operations.

  Arguments:
     cbTransferred - no. of bytes of data exchanged during the io operation.
     pOverlapped   - pointer to the overlapped structure used for posting
                        the IO operation.

  Returns:
     HRESULT
--********************************************************************/
HRESULT
ULSIM_CHANNEL::NotifyIoCompletion(
   IN DWORD cbTransferred,
   IN LPOVERLAPPED pOverlapped
   )
{
    HRESULT hr;

    DBG_ASSERT( m_dwDataChannelFlags & UL_OPTION_OVERLAPPED);

    if (m_hCompletionPort == NULL)
    {
        return (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
    }

    IF_DEBUG( CHANNEL)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Posting IO completion for Key(%08x) cb=%d\n",
            m_pCompletionKey,  cbTransferred
            ));
    }

    //
    // Post completion queued status just from this thread directly
    //
    if ( PostQueuedCompletionStatus( m_hCompletionPort,
                                     cbTransferred,
                                     m_pCompletionKey,
                                     pOverlapped
                                     )
         )
    {
        //
        // Notification was successful
        //
        hr = NOERROR;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return (hr);
}


/********************************************************************++
  Description:
     The function creates a connection object and stores the
     IO parameters inside the object.
     It initiates an IO operation by
      a) queuing the connection object for async IO if required. OR
      b) performs synchronous connection accept/receive/parsing for
      synchronous data channel.

     If there are any errors, the connection object is cleaned up.

  Arguments:

    pRequestBuffer - Supplies a pointer to the request buffer to be filled
        in by UL.SYS.

    RequestBufferLength - Supplies the length of pRequestBuffer.

    pBytesReturned - Optionally supplies a pointer to a DWORD which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    lpOverlapped - pointer to the overlapped structure to use in the IO operation

  Returns:
     Win32 error
--********************************************************************/

ULONG
ULSIM_CHANNEL::ReceiveAndParseRequest(
    IN LPVOID pRequestBuffer,
    IN DWORD RequestBufferLength,
    OUT LPDWORD pBytesReturned,
    IN LPOVERLAPPED lpOverlapped
    )
{
    ULONG rc;

    if ( pBytesReturned != NULL)
    {
        *pBytesReturned = 0;
    }

    //
    // Create a new connection object for the new socket.
    //

    ULSIM_CONNECTION * pConn = new ULSIM_CONNECTION();

    if (NULL == pConn)
    {
        return (GetLastError());
    }

    rc = pConn->SetReceiveBuffers(
                    pRequestBuffer,
                    RequestBufferLength,
                    pBytesReturned,
                    lpOverlapped
                    );
    DBG_ASSERT(SUCCEEDED( rc));

    if (m_dwDataChannelFlags & UL_OPTION_OVERLAPPED)
    {
        //
        // We need to do async IO operation for this data channel
        // Queue up the connection object for io handler thread
        //  and signal the io handler about a waiting item
        //

        rc = EnqueueConnection( pConn);
    }
    else
    {
        //
        // Perform synchronous IO operation here.
        //

        rc = AcceptAndParseConnection( pConn);
    }

    if ( (NO_ERROR != rc) &&
        (rc != ERROR_IO_PENDING)
        )
    {
        delete pConn;
    }

    return (rc);

} // ULSIM_CHANNEL::ReceiveAndParseRequest()
/********************************************************************++
  Description:


  Arguments:


  Returns:
     HRESULT
--********************************************************************/
HRESULT
ULSIM_CHANNEL::ReceiveEntityBody(
    IN LPVOID pRequestBuffer,
    IN DWORD RequestBufferLength,
    OUT LPDWORD pBytesReturned,
    IN LPOVERLAPPED lpOverlapped
    )
{
    HRESULT hr;

    if ( pBytesReturned != NULL)
    {
        *pBytesReturned = 0;
    }

    //
    // Create a new connection object for the new socket.
    //

    ULSIM_CONNECTION * pConn = new ULSIM_CONNECTION();
    if (NULL == pConn)
    {
        return (HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = pConn->SetReceiveBuffers(
                    pRequestBuffer,
                    RequestBufferLength,
                    pBytesReturned,
                    lpOverlapped
                    );
    DBG_ASSERT(SUCCEEDED( hr));

    // TODO:
    // I have not figure out how to do AsyncIO Read here.  So,
    // only synchronous read.

    if (m_dwDataChannelFlags & UL_OPTION_OVERLAPPED)
    {
        //
        // We need to do async IO operation for this data channel
        // Queue up the connection object for io handler thread
        //  and signal the io handler about a waiting item
        //

        hr = EnqueueConnection( pConn);
    }
    else
    {
        //
        // Perform synchronous IO operation here.
        //
        hr = pConn->ReceiveData( (PBYTE)pRequestBuffer, pBytesReturned);
    }

    if (!SUCCEEDED(hr) &&
        (hr != HRESULT_FROM_WIN32( ERROR_IO_PENDING))
        )
    {
        delete pConn;
    }

    return hr;

}


/********************************************************************++
  Description:
     The function performs a synchronous accept on the listening socket and
     waits for a new connection to be received. Once the new connection
     comes in, it attempts to parse the request received. The parsed
     response and connection are stored inside the connection object
     supplied.

     If there are any failures, the caller is responsible for cleaningup
     the connection object.

  Arguments:

    pConn - pointer to the ULSIM connection object in which the new connection
        is accepted and request is parsed into.

  Returns:
     HRESULT
--********************************************************************/
HRESULT
ULSIM_CHANNEL::AcceptAndParseConnection( IN ULSIM_CONNECTION * pConn)
{
    HRESULT hr;

    //
    // do a blocking accept operation waiting for new connection to arrive
    //
    hr = pConn->AcceptConnection( m_sListenSocket);

    if (SUCCEEDED(hr))
    {
        BYTE    rgbBuffer[ULSIM_MAX_BUFFER];
        DWORD   cbRead, cbRemaining;

        //
        // Read the data synchronously.
        // Assume that the buffer is sufficiently big enough for decent sized requests.
        //

        cbRead  = 0;

        do
        {
            cbRemaining = sizeof(rgbBuffer) - cbRead;              // Remaining Space

            hr = pConn->ReceiveData( rgbBuffer+cbRead, &cbRemaining);

            if (SUCCEEDED(hr))
            {
                cbRead += cbRemaining;

                //
                // Parse out the request into the UL's format
                //
                hr = pConn->ParseIntoHttpRequest(
                               rgbBuffer,
                               cbRead
                               );
            }
        }
        while (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr);
    }

    IF_DEBUG( CHANNEL)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "AcceptAndParseConnection() finished => %08x(%d)\n",
            hr, hr
            ));
    }

    return (hr);
} // ULSIM_CHANNEL::AcceptAndParseConnection()



HRESULT
ULSIM_CHANNEL::SendResponse(
   IN UL_HTTP_CONNECTION_ID ConnectionID,
   IN PUL_HTTP_RESPONSE  pHttpResponse,
   IN ULONG EntityChunkCount,
   IN PUL_DATA_CHUNK pEntityChunks ,
   OUT LPDWORD pcbSent
   )
{
    USES_CONVERSION;

    HRESULT hr = NOERROR;
    ULSIM_CONNECTION * pConn = (ULSIM_CONNECTION * ) ConnectionID;
    DWORD cbData;
    ULONG   i;
    static LPSTR   HeaderName[] = {
                "Cache-Control: ",
                   "Connection: ",
                         "Date: ",
                   "Keep-Alive: ",
                       "Pragma: ",
                      "Trailer: ",
            "Transfer-Encoding: ",
                      "Upgrade: ",
                          "Via: ",
                      "Warning: ",
                        "Allow: ",
               "Content-Length: ",
                 "Content-Type: ",
             "Content-Encoding: ",
             "Content-Language: ",
             "Content-Location: ",
                  "Content-MD5: ",
                "Content-Range: ",
                      "Expires: ",
                "Last-Modified: ",
                "Accept-Ranges: ",
                          "Age: ",
                         "ETag: ",
                     "Location: ",
           "Proxy-Authenticate: ",
                  "Retry-After: ",
                       "Server: ",
                   "Set-Cookie: ",
                         "Vary: ",
             "WWW-Authenticate: ",
            };


    char  HttpStatus[100];
    char  LineTerm[] = "\r\n";

    if ( (pConn == NULL) ||
         (pHttpResponse == NULL)
         )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER);
    }

    IF_DEBUG( CHANNEL)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Conn[%08lx%08lx]::SendResponse(%08x)\n",
                    ConnectionID, pHttpResponse));
    }

    DWORD cbTotalSent = 0;

    //
    // Send the status
    //

    cbData = sprintf(HttpStatus,
                     "HTTP/1.1 %d %ws\r\n",
                     pHttpResponse->StatusCode,
                     pHttpResponse->pReason);

    pConn->SendData( (PBYTE ) HttpStatus,
                              &cbData
                              );
    //
    // Send response headers
    //

    for(i = 0; i < UlHeaderResponseMaximum; i++)
    {
        if ( pHttpResponse->Headers.pKnownHeaders[i].RawValueLength > 0)
        {
            //
            // send the name
            //

            cbData = strlen(HeaderName[i]);
            pConn->SendData( (PBYTE ) HeaderName[i],
                                  &cbData
                              );

            //
            // send the value

            cbData = pHttpResponse->Headers.pKnownHeaders[i].RawValueLength/2;
            pConn->SendData( (UCHAR *)W2A(pHttpResponse->Headers.pKnownHeaders[i].pRawValue),
                             &cbData
                           );

            //
            // Terminate the header
            //

            cbData = sizeof(LineTerm)-1;
            pConn->SendData( (PBYTE ) LineTerm,
                             &cbData
                           );

        }
    }

    //
    // Forget unknown Headers
    //

    //
    // Terminate headers
    //

    cbData = sizeof(LineTerm)-1;
    pConn->SendData( (PBYTE ) LineTerm,
                             &cbData
                   );


    for (i = 0; i < EntityChunkCount; i++)
    {
        PUL_DATA_CHUNK pdc = &pEntityChunks[i];

        IF_DEBUG( CHANNEL)
        {
            DBGPRINTF(( DBG_CONTEXT,
                "\tChunk[%d] Type=%d\n", i, pdc->DataChunkType
                ));
        }

        switch ( pdc->DataChunkType)
        {
        case UlDataChunkFromMemory:
            cbData = pdc->FromMemory.BufferLength;
            hr = pConn->SendData( (PBYTE ) pdc->FromMemory.pBuffer,
                                  &cbData
                                  );
            if (FAILED(hr))
            {
                break;
            }
            DBG_ASSERT( cbData == pdc->FromMemory.BufferLength);
            cbTotalSent += cbData;
            break;

        case UlDataChunkFromFileName:
            hr = pConn->TransmitFile(
                    pdc->FromFileName.pFileName,
                    NULL,
                    pdc->FromFileName.ByteRange,
                    &cbData
                    );
            if (FAILED(hr))
            {
                break;
            }

            cbTotalSent += cbData;
            break;

        case UlDataChunkFromFileHandle:
            hr = pConn->TransmitFile(
                    NULL,
                    pdc->FromFileHandle.FileHandle,
                    pdc->FromFileHandle.ByteRange,
                    &cbData
                    );
            if (FAILED(hr))
            {
                break;
            }

            cbTotalSent += cbData;
            break;

        default:
            DBGPRINTF(( DBG_CONTEXT, "Unknown chunk type %d\n",
                pdc->DataChunkType
                ));
            break;
        }
    }

    if ( pcbSent != NULL) {
        *pcbSent = cbTotalSent;
    }

    IF_DEBUG( CHANNEL)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "SendResponse(%08lx%08lx, %08x, %08x) => sent %d bytes, Error=%08x\n",
            ConnectionID, pHttpResponse, pcbSent, *pcbSent, hr
            ));
    }

    //
    // NYI: free up the connection object here ?
    //

    return (hr);
} // ULSIM_CHANNEL::SendResponse()


ULONG
ULSIM_CHANNEL::EnqueueConnection( IN ULSIM_CONNECTION * pConn)
{
    ULONG rc=ERROR_IO_PENDING;

    DBG_ASSERT( pConn != NULL);

    EnterCriticalSection( &m_csConnectionsList);
    InsertHeadList( &m_lConnections, &pConn->m_lEntry);
    LeaveCriticalSection( &m_csConnectionsList);

    //
    // Signal that there is a pending connection object available
    //
    if (!ReleaseSemaphore( m_hConnectionsSemaphore, 1, NULL))
    {
        rc = GetLastError();

        //
        // remove from the list now
        //
        EnterCriticalSection( &m_csConnectionsList);
        RemoveEntryList( &pConn->m_lEntry);
        LeaveCriticalSection( &m_csConnectionsList);
        InitializeListHead( &pConn->m_lEntry);
    }
    else
    {
        IF_DEBUG( CHANNEL)
        {

            DBGPRINTF(( DBG_CONTEXT,
                "Enqueued a connection (%08x) for IO\n", pConn));
        }
    }

    return rc;
} // ULSIM_CHANNEL::EnqueueConnection()


HRESULT
ULSIM_CHANNEL::DequeueConnection( OUT ULSIM_CONNECTION ** ppConn)
{
    HRESULT hr=NOERROR;
    DBG_ASSERT( ppConn != NULL);
    DWORD dwWait;

    *ppConn = NULL;

    dwWait = WaitForSingleObject( m_hConnectionsSemaphore, INFINITE);

    switch (dwWait)
    {
    case WAIT_ABANDONED:
        hr = HRESULT_FROM_WIN32( WAIT_ABANDONED);
        break;

    case WAIT_OBJECT_0:
        {
            PLIST_ENTRY pl;
            EnterCriticalSection( &m_csConnectionsList);
            pl = RemoveHeadList( &m_lConnections);
            LeaveCriticalSection( &m_csConnectionsList);

            InitializeListHead( pl);
            *ppConn = CONTAINING_RECORD( pl, ULSIM_CONNECTION, m_lEntry);

            IF_DEBUG( CHANNEL)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Dequeued Connection (%08x) for IO\n", *ppConn));
            }

            break;
        }

    case WAIT_TIMEOUT:
        DBG_ASSERT( FALSE);
        hr = HRESULT_FROM_WIN32( WAIT_TIMEOUT);
        break;

    default:
        hr = HRESULT_FROM_WIN32( GetLastError());
        break;
    } // switch

    return hr;
} // ULSIM_CHANNEL::DequeueConnection()



HRESULT
ULSIM_CHANNEL::AcceptConnectionsLoop(void)
{
    ULSIM_CONNECTION * pConn;
    DWORD dwWait;

    IF_DEBUG( CHANNEL)
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Starting the connection thread %d\n",
            GetCurrentThreadId()
            ));
    }

    for( ;; )
    {
        HRESULT hr;

        pConn = NULL;

        //
        // pull an connection object to process and receive the connection object
        //

        hr = DequeueConnection( &pConn);

        if (hr == HRESULT_FROM_WIN32( WAIT_ABANDONED))
        {
            //
            // this is our signal for cleanup. Exit this loop
            //
            break;
        }

        if (FAILED(hr))
        {
            DPERROR(( DBG_CONTEXT, hr,
                "Unknown error when dequeuing the connection\n"));

            // ignore and continue
            continue;
        }

        DBG_ASSERT( pConn != NULL);

        //
        // Do a blocking accept operation, read request and parse the data
        //
        hr = AcceptAndParseConnection( pConn);

        //
        // Deliver the connections to the caller
        // For non-overlapped IO requests, just a function return does the trick
        // For overlapped IO with completion ports handle them differently.
        //
        DBG_ASSERT( pConn->m_pOverlapped != NULL);
        pConn->m_pOverlapped->Internal = hr; // store the error value here
        HRESULT hr1;
        hr1 = NotifyIoCompletion( pConn->m_cbRead,
                                  pConn->m_pOverlapped
                                 );

        // ignore the error returned by the Notify IO routine.

        if (FAILED(hr))
        {
            // there was a failure in accepting the connection.
            // delete the connection object
            delete pConn;
        }

    } // for

    return (NOERROR);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\ulsimapi.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    ulsimapi.c

Abstract:

    User-mode simulator interface for Universal Listener API.
    UL.sys runs in kernel mode => any bug can lead to blue-screens.
    This simulator maps UL API to an user-mode implementation based
    on sockets. The implementation is poor in performance, but is 
    well suited for functional runs for UL interfaces. 
    This will enable testing of Worker Process and other components 
    built on top of the UL interfaces.

    Implementation:
      The UL interfaces can be grouped into two broad categories:
        a) Control Channel API and 
        b) Data Channel API
     For most part the control channel API are one-time calls and 
     this UL simulator does not offer multi-thread protection for such
     API now.

     For data channel operations, the API does support multi-threaded
     protection for common receive and send operations.

     ULSIM creates a single object called ULSIM_CHANNEL to store control
      and data channel operations. Internally the ULSIM_CHANNEL creates 
      additional objects for handling IO operations and return calls 
      to the UL user.
     
     There is one single Channel (g_pulChannel) that stores both data and 
      control channel. It is responsible for the simulated HTTP engine
      in the user-mode for the users of ULAPI.

Author:

    Murali R. Krishnan (MuraliK) 20-Nov-1998

Revision History:

--*/


#include "precomp.hxx"
#include "httptypes.h"
#include "ulchannel.hxx"


//
// Global pointer to the single CHANNEL simulated
// We bundle the Control and Data channel into a single data structure
//

ULSIM_CHANNEL * g_pulChannel;


ULONG
WINAPI
UlInitialize(
    IN ULONG Reserved   // must be zero
    )
{
    return NO_ERROR;
}

VOID
WINAPI
UlTerminate(
    VOID
    )
{
}

ULONG
WINAPI
UlCreateConfigGroup(
    IN HANDLE ControlChannelHandle,
    OUT PUL_CONFIG_GROUP_ID pConfigGroupId
    )
{
    return NO_ERROR;
}

ULONG
WINAPI
UlDeleteConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN UL_CONFIG_GROUP_ID ConfigGroupId
    )
{
    return NO_ERROR;
}

ULONG
WINAPI
UlAddUrlToConfigGroup(
    IN HANDLE ControlChannelHandle,
    IN UL_CONFIG_GROUP_ID ConfigGroupId,
    IN PCWSTR pFullyQualifiedUrl,
    IN UL_URL_CONTEXT UrlContext
    )
{
    return NO_ERROR;   
}

ULONG
WINAPI
UlSetControlChannelInformation(
    IN HANDLE ControlChannelHandle,
    IN UL_CONTROL_CHANNEL_INFORMATION_CLASS InformationClass,
    IN PVOID pControlChannelInformation,
    IN ULONG Length
    )
{
    return NO_ERROR;
}

ULONG
WINAPI
UlSetConfigGroupInformation(
    IN HANDLE ControlChannelHandle,
    IN UL_CONFIG_GROUP_ID ConfigGroupId,
    IN UL_CONFIG_GROUP_INFORMATION_CLASS InformationClass,
    IN PVOID pConfigGroupInformation,
    IN ULONG Length
    )
{
    return NO_ERROR;
}

ULONG
WINAPI
UlCreateAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN LPSECURITY_ATTRIBUTES pSecurityAttributes,
    IN ULONG Options
    )
{
    ULONG rc;
    
    if (NULL == g_pulChannel)
    {
        g_pulChannel = new ULSIM_CHANNEL();

        if (NULL == g_pulChannel)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    rc = g_pulChannel->InitializeDataChannel(Options) ||
         g_pulChannel->StartListen();
    
    *pAppPoolHandle = UlChannelToHandle(g_pulChannel);
    
    return rc;   
}

ULONG
WINAPI
UlOpenAppPool(
    OUT PHANDLE pAppPoolHandle,
    IN PCWSTR pAppPoolName,
    IN ULONG Options
    )
{
    if (!g_pulChannel)
    {
        return ERROR_INVALID_HANDLE;
    }
    
    *pAppPoolHandle = UlChannelToHandle(g_pulChannel);
    return NO_ERROR; 
}


/***************************************************************************++

Routine Description:

    Opens a control channel to UL.SYS.

Arguments:

    pControlChannel - Receives a handle to the control channel if successful.

    Flags - Supplies zero or more UL_CHANNEL_FLAG_* flags.

Return Value:

    HRESULT - Completion status.

Note: 
   UL uses real handles for control channel and data channel. But we do not 
   have handles in the simulation interface. We will let the little
   structures leak in the event of failures :(
--***************************************************************************/

ULONG
WINAPI
UlOpenControlChannel(
    OUT PHANDLE pControlChannelHandle,
    IN ULONG Options
    )
{
    ULONG rc;
    ULSIM_CHANNEL * pulc;

    if ( g_pulChannel != NULL) {
        
        return ( HRESULT_FROM_WIN32( ERROR_DUP_NAME));
    }

    //
    // create a fake control channel object
    //
    pulc = new ULSIM_CHANNEL();
    if ( pulc == NULL) {
        return ( ERROR_NOT_ENOUGH_MEMORY);
    }

    g_pulChannel = pulc;


    //
    // Initialize the control channel properly
    //

    rc = pulc->InitializeControlChannel( Options);
    
    if (NO_ERROR != rc) 
    {
        *pControlChannelHandle = NULL;
        return (rc);
    }

    *pControlChannelHandle = UlChannelToHandle(pulc);

    return (NO_ERROR);
    
}   // UlOpenControlChannel


/***************************************************************************++

Routine Description:

    Waits for an incoming HTTP request from UL.SYS.

Arguments:

    DataChannel - Supplies a handle to a UL.SYS data channel as returned
        from UlBindToNameSpaceGroup().

    pRequestBuffer - Supplies a pointer to the request buffer to be filled
        in by UL.SYS.

    RequestBufferLength - Supplies the length of pRequestBuffer.

    pBytesReturned - Optionally supplies a pointer to a DWORD which will
        receive the actual length of the data returned in the request buffer
        if this request completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure for the
        request.

Return Value:

    HRESULT - Completion status.

Note:
    We should have a listening socket established by now.
    We pass through the call from the user-mode to the blocking recv() call
    on the socket. If there is some data read, then the data is parsed 
    to construct the UL_HTTP_REQUEST object to be passed back to the client.
    
    We estimate a buffer size of 4K for the request size before parsing.
    Certainly there are optimizations that can be done, but they are deferred!
--***************************************************************************/

ULONG
WINAPI
UlReceiveHttpRequest(
    IN HANDLE DataChannel,
    IN UL_HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,   
    OUT PUL_HTTP_REQUEST pRequestBuffer,
    IN ULONG RequestBufferLength,
    OUT PULONG pBytesReturned,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    ULONG rc;

    ULSIM_CHANNEL * pulChannel = HandleToUlChannel( DataChannel);
    

    if ( !pulChannel ||
         !pRequestBuffer ||
         !pulChannel->IsReadyForDataReceive()
         )
    {

        return ERROR_INVALID_PARAMETER;
    }

    rc = pulChannel->ReceiveAndParseRequest(
              pRequestBuffer,
              RequestBufferLength,
              pBytesReturned,
              pOverlapped
              );

    return (rc);
}   // UlReceiveHttpRequest

ULONG
WINAPI
UlReceiveEntityBody(
    IN HANDLE AppPoolHandle,
    IN UL_HTTP_REQUEST_ID RequestId,
    OUT PVOID pEntityBodyBuffer,
    IN ULONG EntityBodyBufferLength,
    OUT PULONG pBytesReceived,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
   ULONG rc;

    ULSIM_CHANNEL * pulChannel = HandleToUlChannel( AppPoolHandle);
    

    if ( !pulChannel ||
         !pEntityBodyBuffer ||
         !pulChannel->IsReadyForDataReceive()
         )
    {

        return ERROR_INVALID_PARAMETER;
    }

    rc = pulChannel->ReceiveAndParseRequest(
              pEntityBodyBuffer,
              EntityBodyBufferLength,
              pBytesReceived,
              pOverlapped
              );

    return (rc);

}

/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    DataChannel - Supplies a handle to a UL.SYS data channel as returned
        from UlBindToNameSpaceGroup().

    ConnectionID - Supplies a connection ID as returned by
        UlReceiveHttpRequest().

    Flags - Supplies zero or more UL_SEND_RESPONSE_FLAG_* control flags.

    pHttpResponse - Supplies the HTTP response.

    pBytesSent - Optionally supplies a pointer to a DWORD which will
        receive the actual length of the data sent if this request
        completes synchronously (in-line).

    pOverlapped - Optionally supplies an OVERLAPPED structure.

Return Value:

    HRESULT - Completion status.

--***************************************************************************/
ULONG
WINAPI
UlSendHttpResponse(
    IN HANDLE DataChannel,
    IN UL_HTTP_REQUEST_ID RequestId,
    IN ULONG Flags,
    IN PUL_HTTP_RESPONSE pHttpResponse,
    IN ULONG EntityChunkCount OPTIONAL,
    IN PUL_DATA_CHUNK pEntityChunks OPTIONAL,
    IN PUL_CACHE_POLICY pCachePolicy OPTIONAL,
    OUT PULONG pBytesSent OPTIONAL,
    IN LPOVERLAPPED pOverlapped OPTIONAL
    )
{
    ULONG rc;
    ULSIM_CHANNEL * pulChannel = HandleToUlChannel( DataChannel);
    

    if ( !pulChannel                         ||
         UL_IS_NULL_ID(&RequestId)           ||
         Flags                               ||  // no flags supported
         !pulChannel->IsReadyForDataReceive()||
         !pHttpResponse
         ) 
    {
        return ERROR_INVALID_PARAMETER;
    }


    DWORD cbSent = 0;
    rc = pulChannel->SendResponse((UL_HTTP_CONNECTION_ID)RequestId, 
                                  pHttpResponse, 
                                  EntityChunkCount,
                                  pEntityChunks,
                                  &cbSent
                                  );
    //
    // save the number of bytes required
    //
    if ( pBytesSent != NULL)
    {
        *pBytesSent = cbSent;
    }

    if (NO_ERROR != rc) 
    {
        return (rc);
    }

    //
    // Handle the notifications differently for Overlapped IO
    //
    if ( pOverlapped != NULL) {

        rc = pulChannel->NotifyIoCompletion( cbSent,
                                             pOverlapped
                                             );
    } 

    return (rc);
}   // UlSendHttpResponse


/***************************************************************************++
 ***************************************************************************++

  ULSIM Extensions for hanlding special operations

 --***************************************************************************
 --***************************************************************************/


/***************************************************************************++

Routine Description:

    The ULSimulator uses fake handles for the callers. The callers expect 
    completion using the completion port logic for asynchronous IO. 
    This function allows the caller to set the associated completion port
    and completion key so that the simulator can post queued completion status
    for signifying the completion of the IO operation.

Arguments:

    DataChannel - Supplies a handle to a UL.SYS data channel as returned
        from UlBindToNameSpaceGroup().

    hCompletionPort - Suppplies a handle for the completion port to which the 
        data channel IO operations are delivered.

    CompletionKey   - Supplies a completion key that is treated as opaque
        pointer and returned to the caller on completing IO operations.

Return Value:

    HRESULT - Completion status.

Note:
    In the UL simulator we store the completion port and completion key
    along inside the UL Channel object. These are used when completion async
    IO operations.
--***************************************************************************/
HRESULT WINAPI
UlsimAssociateCompletionPort(
   IN HANDLE    DataChannel,
   IN HANDLE    hCompletionPort,
   IN ULONG_PTR CompletionKey
   )
{
    ULSIM_CHANNEL * pulChannel = HandleToUlChannel( DataChannel);
    
    if (!pulChannel) {
        return (HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER));
    }

    return (pulChannel->AssociateCompletionPort( hCompletionPort, 
                                                 CompletionKey)
            );
} 


HRESULT WINAPI
UlsimCloseConnection( IN UL_HTTP_CONNECTION_ID ConnID)
{
    HRESULT hr;
    ULSIM_CONNECTION * pConn = (ULSIM_CONNECTION * ) ConnID;

    if ( !pConn)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // Assume no other thread is tinkering with this object
    // a delete of the connection object frees up memory and 
    //  closes the socket for the client
    //
    delete pConn;

    return (NOERROR);
} 


HRESULT WINAPI
UlsimCleanupDataChannel(
   IN HANDLE    DataChannel
   )
{
    HRESULT hr;

    ULSIM_CHANNEL * pulChannel = HandleToUlChannel( DataChannel);

    if ( !pulChannel) 
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return (pulChannel->CloseDataChannel());
}

HRESULT WINAPI
UlsimCleanupControlChannel(
   IN HANDLE    ControlChannel
   )
{
    if ( g_pulChannel != ((ULSIM_CHANNEL *) ControlChannel))
    {
        return (ERROR_INVALID_PARAMETER);
    }

    delete g_pulChannel;
    return (NOERROR);
}

/***************************************************************************++

Routine Description:

    Creates a new virtual host.

Arguments:

    ControlChannel - Supplies a handle to a UL.SYS control channel as
        returned from UlOpenControlChannel().

    pHostAddress - Supplies the local address for the virtual host.

    pHostName - Optionally supplies a host name for the virtual host.

    Flags - Supplies behavior flags for the virtual host. 

Return Value:

    HRESULT - Completion status.

Note:
    In the simulation interface, we use this method to store the info
    about the virtual host within the control channel.
    Atmost one VHost will be supported!

    ***DEFUNCT***
--***************************************************************************/

/*
HRESULT WINAPI
UlCreateVirtualHost(
    IN HANDLE ControlChannel,
    IN PUL_HOST_ADDRESS pHostAddress,
    IN LPSTR pHostName OPTIONAL,
    IN DWORD Flags
    )
{
    ULSIM_CHANNEL * pulcc = HandleToUlChannel( ControlChannel);

    if ( !pulcc) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    //
    // BUGBUG: Only TCP/IP supported right now...
    //

    if (pHostAddress->AddressType != UlTcpipAddressType)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return pulcc->AddVHost( pHostAddress, pHostName, Flags);
}   // UlCreateVirtualHost
*/




/***************************************************************************++

Routine Description:

    Creates a new NameSpace Group.

Arguments:

    ControlChannel - Supplies a handle to a UL.SYS control channel as
        returned from UlOpenControlChannel().

    pNameSpaceGroupName - Supplies the name of the new NameSpace Group.

Return Value:

    HRESULT - Completion status.

Note:
    In the simulation API we only support a single Namespace group
    per Control Channel. This is stored within the control channel.

    ***DEFUNCT***

--***************************************************************************/
/*
HRESULT WINAPI
UlCreateNameSpaceGroup(
    IN HANDLE ControlChannel,
    IN LPWSTR pNameSpaceGroupName
    )
{
    ULSIM_CHANNEL * pulcc = HandleToUlChannel( ControlChannel);

    if ( !pulcc) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    return pulcc->AddNameSpaceGroup( pNameSpaceGroupName);
    
}   // UlCreateNameSpaceGroup
*/


/***************************************************************************++

Routine Description:

    Adds a new URL to a NameSpace Group.

Arguments:

    ControlChannel - Supplies a handle to a UL.SYS control channel as
        returned from UlOpenControlChannel().

    pHostAddress - Supplies the local address for the virtual host that is
        to own the URL.

    pNameSpaceGroupName - Supplies the name of the NameSpace Group that is
        to own the URL.

    pHostName - Optionally supplies the name of the virtual host that is to
        own the URL.

    pUrlName - Supplies the name of the URL to add to the NameSpace Group.

Return Value:

    HRESULT - Completion status.

Note:
   For the simulator, we will only support one single URL to be added to
   the Namespace group. This will be stored inside the control channel.

   **** DEFUNCT ****  

--***************************************************************************/

/*
HRESULT WINAPI
UlAddUrlToNameSpaceGroup(
    IN HANDLE ControlChannel,
    IN PUL_HOST_ADDRESS pHostAddress,
    IN LPWSTR pNameSpaceGroupName,
    IN LPSTR pHostName OPTIONAL,
    IN LPSTR pUrlName
    )
{
    ULSIM_CHANNEL * pulcc = HandleToUlChannel( ControlChannel);

    if ( !pulcc) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    if ( !pulcc->IsHost( pHostAddress, pHostName) ||
         !pulcc->IsNameSpaceGroup( pNameSpaceGroupName)
         ) {

        return (HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER));
    }

    return (pulcc->AddURL( pUrlName));

}   // UlAddUrlToNameSpaceGroup

*/
/***************************************************************************++

Routine Description:

    Binds the local process to the specified NameSpace Group by opening a
    data channel to UL.SYS.

Arguments:

    pDataChannel - Receives a handle to the data channel if successful.

    pNameSpaceGroupName - Supplies the name of the NameSpace Group to
        bind to.

    Flags - Supplies zero or more UL_CHANNEL_FLAG_* flags.

Return Value:

    HRESULT - Completion status.

Note:
    Here the bulk of work has to be done. We use the namespace group specified
    to associate the same with the global Control channel in this simulator.
    If the Control channel is not completely initialized this call will fail.
    
--***************************************************************************/

/*
HRESULT WINAPI
UlBindToNameSpaceGroup(
    OUT LPHANDLE pDataChannel,
    IN LPWSTR pNameSpaceGroupName,
    IN DWORD Flags
    )
{
    HRESULT hr;

    *pDataChannel = NULL;

    if ( !pNameSpaceGroupName ||
         !g_pulChannel->IsNameSpaceGroup( pNameSpaceGroupName)
         )
    {
        //
        // there is no registered namespace group for the given item.
        // bail out and return error
        //
        return (HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND));
    }

    hr = g_pulChannel->InitializeDataChannel( Flags);
    
    if (FAILED(hr)) {
        return (hr);
    }

    //
    // Start off the data channel and get it functioning
    //

    hr = g_pulChannel->StartListen();
    
    if (FAILED(hr)) {
        return (hr);
    }

    *pDataChannel = UlChannelToHandle( g_pulChannel);
    return (NOERROR);

}   // UlBindToNameSpaceGroup

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\dirmon.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    dirmon.h

Abstract:

    Public header for directory monitor

Author:

    Bilal Alam (balam)          Jan-24-2000

Revision History:

--*/

#ifndef _DIRMON_H_
#define _DIRMON_H_

#include <thread_pool.h>
#include "lkrhash.h"

class CDirMonitor;

class CDirMonitorEntry
{
    friend class CDirMonitor;

public:
    CDirMonitorEntry(
        VOID
    );

    virtual
    ~CDirMonitorEntry(
        VOID
    );

    virtual
    VOID
    AddRef()
    {
        // This ref count tracks how many templates
        // and applications are depending on this monitor entry.

        InterlockedIncrement(&m_cDirRefCount);
    };

    virtual
    BOOL
    Release(
        VOID
    );    // return FALSE if last release
    
    virtual
    BOOL
    Init(
        DWORD               cbBufferSize
    );
    
 protected:
    DWORD               m_cPathLength;
    LPWSTR              m_pszPath;
    BYTE*               m_pbBuffer;
    LONG                m_cDirRefCount; // Ref count for external usage
    LONG                m_cIORefCount;  // Ref count of Asynch IO
    HANDLE              m_hDir;
    BOOL                m_fWatchSubdirectories;

    DWORD
    GetBufferSize(
        VOID
    );
    
    BOOL
    SetBufferSize(
        DWORD               cbBufferSize
    );
    
    BOOL
    ResetDirectoryHandle(
        VOID
    );

 private:
    DWORD               m_dwNotificationFlags;
    OVERLAPPED          m_ovr;
    DWORD               m_cBufferSize;
    CDirMonitor*        m_pDirMonitor;
    BOOL                m_fInCleanup;

    VOID
    IOAddRef(
        VOID
    );
    
    BOOL
    IORelease(
        VOID
    );       // return FALSE if last release
    
    BOOL
    RequestNotification(
        VOID
    );
    
    BOOL
    Cleanup(
        VOID
    );
    
    virtual
    BOOL
    ActOnNotification(
        DWORD dwStatus,
        DWORD dwBytesWritten
    ) = 0;
} ;


class CDirMonitor : public CTypedHashTable<CDirMonitor, CDirMonitorEntry, const WCHAR*>
{
public:
    CDirMonitor(
        VOID
    );
    
    ~CDirMonitor(
        VOID
    );

    CDirMonitorEntry *
    FindEntry(
        WCHAR *             pszPath
    );
    
    BOOL
    Monitor(
        CDirMonitorEntry *  pDME,
        WCHAR *             pszDirectory,
        BOOL                fWatchSubDirectories,
        DWORD               dwFlags
    );
    
    VOID
    Cleanup(
        VOID
    );
    
    LK_RETCODE
    InsertEntry(
        CDirMonitorEntry *  pDME
    );
    
    LK_RETCODE
    RemoveEntry(
        CDirMonitorEntry *  pDME
    );
    
    LONG
    AddRef(
        VOID
    )
    {
        return InterlockedIncrement( &m_cRefs );
    }
    
    
    LONG Release(
        VOID
    )
    {
        return InterlockedDecrement( &m_cRefs);
    }
    
    static const
    WCHAR *
    CDirMonitor::ExtractKey(
        const CDirMonitorEntry*     pDME
    )
    {
        return pDME->m_pszPath;
    };

    static
    DWORD
    CDirMonitor::CalcKeyHash(
        const WCHAR*                pszKey
    )
    {
        return HashStringNoCase( pszKey );
    }

    static
    bool
    CDirMonitor::EqualKeys(
        const WCHAR*                pszKey1,
        const WCHAR*                pszKey2
    )
    {
        return _wcsicmp(pszKey1, pszKey2) == 0;
    };

    static
    VOID
    CDirMonitor::AddRefRecord(
        CDirMonitorEntry*           pDME,
        int                         nIncr
    )
    {
    }

private:
    CRITICAL_SECTION    m_csSerialComplLock;
    LONG                m_cRefs;
    BOOL                m_fShutdown;

    VOID
    SerialComplLock(
        VOID
    )
    {
        EnterCriticalSection( &m_csSerialComplLock);
    }
    
    VOID
    SerialComplUnlock(
        VOID
    )
    {
        LeaveCriticalSection( &m_csSerialComplLock);
    }

public:
    static
    VOID
    DirMonitorCompletionFunction(
        PVOID                       pCtxt,
        DWORD                       dwBytesWritten,
        DWORD                       dwCompletionStatus,
        OVERLAPPED *                pOvr
    );

    static
    VOID
    OverlappedCompletionRoutine(
        DWORD                       dwErrorCode,
        DWORD                       dwNumberOfBytesTransfered,
        LPOVERLAPPED                lpOverlapped
    );
};


inline
BOOL
CDirMonitorEntry::Release(
    VOID
)
{
    BOOL fRet = TRUE;
    CDirMonitor *pDirMonitor = m_pDirMonitor;
    LONG     cRefs;

    //
    // Guard against someone doing a FindEntry on an entry we are releasing
    //
    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteLock();
    }
    cRefs = InterlockedDecrement(&m_cDirRefCount);

    if (cRefs == 0)
    {
        // When ref count reaches 0, clean up resources
        
        BOOL fDeleteNeeded = Cleanup();

        // Cleanup said that we need to handle the deletion,
        // probably because there were no Asynch operations outstanding
        
        if (fDeleteNeeded)
        {
            delete this;
        }
        
        fRet = FALSE;
    }

    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteUnlock();
    }

    return fRet;
}

inline
VOID
CDirMonitorEntry::IOAddRef(
    VOID
)
{
    // This refcount track how many
    // asynch IO requests are oustanding
    
    InterlockedIncrement( &m_cIORefCount );
}

inline
BOOL
CDirMonitorEntry::IORelease(
    VOID
)
{
    BOOL fRet = TRUE;
    CDirMonitor *pDirMonitor = m_pDirMonitor;

    //
    // Guard against someone doing a FindEntry on an entry we are releasing
    //
    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteLock();
    }
    InterlockedDecrement(&m_cIORefCount);

    // When both IO and external ref counts reaches 0,
    // free this object
    if (m_cIORefCount == 0 &&
        m_cDirRefCount == 0)
    {
        delete this;
        
        fRet = FALSE;
    }

    if (pDirMonitor != NULL)
    {
        pDirMonitor->WriteUnlock();
    }

    return fRet;
}

inline
DWORD
CDirMonitorEntry::GetBufferSize(
    VOID
)
{
    return m_cBufferSize;
}


#endif /* _DIRMON_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\socklib.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
      socklib.cxx

   Abstract:
      Sockets Library implementation.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Nov-1998

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "precomp.hxx"
# include "socklib.hxx"

SOCKET_LIBRARY  g_socketLibrary;
/************************************************************
 *    Functions 
 ************************************************************/

SOCKET_LIBRARY::SOCKET_LIBRARY()
    : m_fInitialized (FALSE)
{

}

SOCKET_LIBRARY::~SOCKET_LIBRARY()
{
    Cleanup();
}

HRESULT
SOCKET_LIBRARY::Initialize(void)
{
    WSADATA   wsaData;
    INT       serr;

    // check if the library is already initialized.
    if ( m_fInitialized) {
        return ( NOERROR);
    }

    //
    //  Connect to WinSock 2.0
    //
    
    serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);
    
    if( serr != 0 ) {
        return(HRESULT_FROM_WIN32( serr));
    }

    m_fInitialized = TRUE;
    return ( NOERROR);
} // SOCKET_LIBRARY::Initialize()


HRESULT
SOCKET_LIBRARY::Cleanup(void)
{
    if (m_fInitialized) {
        INT serr = WSACleanup();
        if ( serr == 0) {
            m_fInitialized = FALSE;
        }
        return (HRESULT_FROM_WIN32(serr));
    }
    return (NOERROR);
} // SOCKET_LIBRARY::Cleanup()


/********************************************************************++

  Description:
     This function creates a new socket and binds it to the address 
     specified. The newly created socket is returned.
     After the socket is created put this socket in listening mode
 
  Arguments:
    ipAddress - contains the ip address to which the socket should bind
    port      - port number to which the socket is bound to.
    psock     - pointer ot a SOCKET location which contains the socket
                    created on return.

  Returns:
    HRESULT
--********************************************************************/
HRESULT
SOCKET_LIBRARY::CreateListenSocket(
          IN ULONG ipAddress, 
          IN USHORT port,
          OUT SOCKET * psock )
{
    if (!m_fInitialized) {
        return (HRESULT_FROM_WIN32( WSANOTINITIALISED));
    }
    
    int rc;
    SOCKET sNew;

    sNew = WSASocket( 
                   AF_INET,
                   SOCK_STREAM,
                   IPPROTO_TCP,
                   NULL,          // protocol info
                   0,             // group id = 0 => no constraints
                   0              // synchronous IO
                   );

    if (sNew == INVALID_SOCKET) {
        return (HRESULT_FROM_WIN32( WSAGetLastError()));
    }

    //
    // bind the socket to the right address
    //
    SOCKADDR_IN inAddr;
    PSOCKADDR pAddress;
    INT addrLength;
    
    pAddress = (PSOCKADDR )&inAddr;
    addrLength = sizeof(inAddr);
    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(port);
    inAddr.sin_addr.s_addr = ipAddress;

    rc = bind(sNew, pAddress, addrLength);

    if ( rc != 0) {

        closesocket( sNew); // free the socket

        return (HRESULT_FROM_WIN32( WSAGetLastError()));
    }

    //
    // put the socket in listening mode
    //
    if ( listen( sNew, 100) != 0) {

        //
        // failed to put the socket for listen
        //

        closesocket( sNew); // free the socket

        return (HRESULT_FROM_WIN32( WSAGetLastError()));
    }

    //
    // we got a successful socket. now return this socket
    //
    *psock = sNew;
    return (NOERROR);
} // SOCKET_LIBRARY::CreateListenSocket()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\logging.h ===
/*++

   Copyright    (c)   2000    Microsoft Corporation

   Module Name :
     logging.h

   Abstract:
     Logging classes

   Author:
     Anil Ruia (AnilR)                  1-Jul-2000

   Environment:
     Win32 - User Mode
--*/

#ifndef _LOGGING_H_
#define _LOGGING_H_

enum LAST_IO_PENDING
{
    LOG_READ_IO,
    LOG_WRITE_IO,

    LOG_NO_IO
};

class LOG_CONTEXT
{
 public:
    LOG_CONTEXT()
        : m_msStartTickCount (0),
          m_msProcessingTime (0),
          m_dwBytesRecvd     (0),
          m_dwBytesSent      (0),
          m_ioPending        (LOG_NO_IO),
          m_strLogParam      (m_achLogParam, sizeof m_achLogParam)
    {
        ZeroMemory(&m_UlLogData, sizeof m_UlLogData);
    }

    HTTP_LOG_FIELDS_DATA *QueryUlLogData()
    {
        return &m_UlLogData;
    }

    //
    // The querystring to be logged, may differ from the original querystring
    // because of ISAPI doing HSE_APPEND_LOG_PARAMETER
    //
    STRA               m_strLogParam;
    CHAR               m_achLogParam[256];

    //
    // The data UL is interested in
    //
    HTTP_LOG_FIELDS_DATA m_UlLogData;

    //
    // Couple other things for custom logging
    //
    STRA               m_strVersion;

    MULTISZA           m_mszHTTPHeaders;

    //
    // Keep track whether the last I/O was a read or a write so that we
    // know on completion whether to increment bytes read or bytes written
    //
    LAST_IO_PENDING    m_ioPending;

    DWORD              m_msStartTickCount;
    DWORD              m_msProcessingTime;

    DWORD              m_dwBytesRecvd;
    DWORD              m_dwBytesSent;
};

class dllexp LOGGING
{
 public:

    LOGGING();

    HRESULT ActivateLogging(IN LPCSTR  pszInstanceName,
                            IN LPCWSTR pszMetabasePath,
                            IN IMSAdminBase *pMDObject);

    void LogInformation(IN LOG_CONTEXT *pLogData);

    BOOL IsRequiredExtraLoggingFields() const
    {
        return !m_mszExtraLoggingFields.IsEmpty();
    }

    const MULTISZA *QueryExtraLoggingFields() const
    {
        return &m_mszExtraLoggingFields;
    }

    void LogCustomInformation(IN DWORD            cCount, 
                              IN CUSTOM_LOG_DATA *pCustomLogData,
                              IN LPSTR            szHeaderSuffix);

    static HRESULT Initialize();
    static VOID    Terminate();

    BOOL QueryDoUlLogging() const
    {
        return m_fUlLogType;
    }

    BOOL QueryDoCustomLogging() const
    {
        return (m_pComponent != NULL);
    }

    VOID AddRef();

    VOID Release();

  private:

    ~LOGGING();

    DWORD        m_Signature;
    LONG         m_cRefs;

    BOOL         m_fUlLogType;
    ILogPlugin  *m_pComponent;

    MULTISZA     m_mszExtraLoggingFields;
};

#endif // _LOGGING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\core\wp\ulsim\_hashfn.h ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
       hashfn.h

   Abstract:
       Declares and defines a collection of overloaded hash functions.
       It is strongly suggested that you use these functions with LKHash.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

        Paul McDaniel (paulmcd)     Feb-05-1999     Trimmed for kernel mode
                                                    and C (not C++)

--*/

#ifndef __HASHFN_H__
#define __HASHFN_H__


// Produce a scrambled, randomish number in the range 0 to RANDOM_PRIME-1.
// Applying this to the results of the other hash functions is likely to
// produce a much better distribution, especially for the identity hash
// functions such as Hash(char c), where records will tend to cluster at
// the low end of the hashtable otherwise.  LKHash applies this internally
// to all hash signatures for exactly this reason.

__inline ULONG
HashScramble(ULONG dwHash)
{
    // Here are 10 primes slightly greater than 10^9
    //  1000000007, 1000000009, 1000000021, 1000000033, 1000000087,
    //  1000000093, 1000000097, 1000000103, 1000000123, 1000000181.

    // default value for "scrambling constant"
    const ULONG RANDOM_CONSTANT = 314159269UL;
    // large prime number, also used for scrambling
    const ULONG RANDOM_PRIME =   1000000007UL;

    return (RANDOM_CONSTANT * dwHash) % RANDOM_PRIME ;
}


// Fast, simple hash function that tends to give a good distribution.
// Apply HashScramble to the result if you're using this for something
// other than LKHash.

__inline ULONG
HashStringA(
    const char* psz,
    ULONG       dwHash)
{
    for (  ;  *psz;  ++psz)
        dwHash = 37 * dwHash  +  *psz;

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  *pwsz;

    return dwHash;
}


// Quick-'n'-dirty case-insensitive string hash function.
// Make sure that you follow up with _stricmp or _mbsicmp.  You should
// also cache the length of strings and check those first.  Caching
// an uppercase version of a string can help too.
// Again, apply HashScramble to the result if using with something other
// than LKHash.
// Note: this is not really adequate for MBCS strings.

__inline ULONG
HashStringNoCaseA(
    const char* psz,
    ULONG       dwHash)
{
    for (  ;  *psz;  ++psz)
        dwHash = 37 * dwHash  +  (*psz & 0xDF);  // strip off lowercase bit

    return dwHash;
}


// Unicode version of above

__inline ULONG
HashStringNoCaseW(
    const wchar_t* pwsz,
    ULONG          dwHash)
{
    for (  ;  *pwsz;  ++pwsz)
        dwHash = 37 * dwHash  +  (*pwsz & 0xFFDF);

    return dwHash;
}

__inline ULONG
HashCharNoCaseW(
    WCHAR UnicodeChar,
    ULONG Hash
    )
{
    Hash = 37 * Hash + (UnicodeChar & 0xFFDF);
    return Hash;
}


// HashBlob returns the hash of a blob of arbitrary binary data.
//
// Warning: HashBlob is generally not the right way to hash a class object.
// Consider:
//     class CFoo {
//     public:
//         char   m_ch;
//         double m_d;
//         char*  m_psz;
//     };
//
//     inline ULONG Hash(const CFoo& rFoo)
//     { return HashBlob(&rFoo, sizeof(CFoo)); }
//
// This is the wrong way to hash a CFoo for two reasons: (a) there will be
// a 7-byte gap between m_ch and m_d imposed by the alignment restrictions
// of doubles, which will be filled with random data (usually non-zero for
// stack variables), and (b) it hashes the address (rather than the
// contents) of the string m_psz.  Similarly,
//
//     bool operator==(const CFoo& rFoo1, const CFoo& rFoo2)
//     { return memcmp(&rFoo1, &rFoo2, sizeof(CFoo)) == 0; }
//
// does the wrong thing.  Much better to do this:
//
//     ULONG Hash(const CFoo& rFoo)
//     {
//         return HashString(rFoo.m_psz,
//                           37 * Hash(rFoo.m_ch)  +  Hash(rFoo.m_d));
//     }
//
// Again, apply HashScramble if using with something other than LKHash.

__inline ULONG
HashBlob(
    PUCHAR      pb,
    ULONG       cb,
    ULONG       dwHash)
{
    while (cb-- > 0)
        dwHash = 37 * dwHash  +  *pb++;

    return dwHash;
}


// ======= <snip>
//
//  paulmcd: a bunch snipped due to use of overloading, not allowed in C
//
// ======= <snip>

__inline ULONG HashFloat(float f)
{
    // be careful of rounding errors when computing keys
    union {
        float f;
        ULONG dw;
    } u;
    u.f = f;
    return u.dw;
}

__inline ULONG HashDouble(double dbl)
{
    // be careful of rounding errors when computing keys
    union {
        double dbl;
        ULONG  dw[2];
    } u;
    u.dbl = dbl;
    return u.dw[0] * 37  +  u.dw[1];
}

#endif // __HASHFN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\streamfilt.h ===
#ifndef _STREAMFILT_H_
#define _STREAMFILT_H_

#include <httpapi.h>

//
// Structure containing friendly local/remote information
//

struct _RAW_STREAM_INFO;

typedef HRESULT (*PFN_SEND_DATA_BACK)
(
    PVOID                    pvStreamContext,
    _RAW_STREAM_INFO *       pRawStreamInfo
);

typedef struct _CONNECTION_INFO {
    USHORT                  LocalPort;
    ULONG                   LocalAddress;
    USHORT                  RemotePort;
    ULONG                   RemoteAddress;
    BOOL                    fIsSecure;
    HTTP_RAW_CONNECTION_ID  RawConnectionId;
    PFN_SEND_DATA_BACK      pfnSendDataBack;
    PVOID                   pvStreamContext;
    ULONG                   ServerNameLength;
    PWSTR                   pServerName;
} CONNECTION_INFO, *PCONNECTION_INFO;

//
// Structure used to access/alter raw data stream (read/write)
//

typedef struct _RAW_STREAM_INFO {
    PBYTE               pbBuffer;
    DWORD               cbData;
    DWORD               cbBuffer;
} RAW_STREAM_INFO, *PRAW_STREAM_INFO;

//
// Called to handle read raw notifications
//

typedef HRESULT (*PFN_PROCESS_RAW_READ)
(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfReadMore,
    BOOL *                  pfComplete,
    DWORD *                 pcbNextReadSize
);

//
// Called to handle write raw notifications
//

typedef HRESULT (*PFN_PROCESS_RAW_WRITE)
(
    RAW_STREAM_INFO *       pRawStreamInfo,
    PVOID                   pvContext,
    BOOL *                  pfComplete
);

//
// Called when a connection goes away
//

typedef VOID (*PFN_PROCESS_CONNECTION_CLOSE)
(
    PVOID                   pvContext
);

//
// Called when a connection is created
//

typedef HRESULT (*PFN_PROCESS_NEW_CONNECTION)
(
    CONNECTION_INFO *       pConnectionInfo,
    PVOID *                 ppvContext
);

//
// Configure the stream filter (SFWP.EXE config will be different than
// INETINFO.EXE config)
//

typedef struct _STREAM_FILTER_CONFIG {
    BOOL                            fSslOnly;
    PFN_PROCESS_RAW_READ            pfnRawRead;
    PFN_PROCESS_RAW_WRITE           pfnRawWrite;
    PFN_PROCESS_CONNECTION_CLOSE    pfnConnectionClose;
    PFN_PROCESS_NEW_CONNECTION      pfnNewConnection;
} STREAM_FILTER_CONFIG, *PSTREAM_FILTER_CONFIG;

HRESULT
StreamFilterInitialize(
    STREAM_FILTER_CONFIG *      pStreamFilterConfig 
);

HRESULT
StreamFilterStart(
    VOID
);

HRESULT
StreamFilterStop( 
    VOID
);

VOID
StreamFilterTerminate(
    VOID
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\simplearray.h ===
#ifndef _SIMPLEARRAY_H_
#define _SIMPLEARRAY_H_

#include <malloc.h>

#ifndef SIMPLEARRAY_STARTSIZE
#define SIMPLEARRAY_STARTSIZE 1
#endif

template <class T>
class CSimpleArray
{
public:
    T* m_aT;
    int m_nSize;
    int m_nAllocSize;
    
    // Construction/destruction
    CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
    { }
    
    ~CSimpleArray()
    {
        RemoveAll();
    }
    
    // Operations
    int GetSize() const
    {
        return m_nSize;
    }
    BOOL Add(T& t)
    {
        if(m_nSize == m_nAllocSize)
        {
            T* aT;
            int nNewAllocSize = (m_nAllocSize == 0) ? SIMPLEARRAY_STARTSIZE : (m_nSize * 2);
            if (m_aT)
                aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
            else
                aT = (T*)malloc(nNewAllocSize * sizeof(T));
            if(aT == NULL)
                return FALSE;
            m_nAllocSize = nNewAllocSize;
            m_aT = aT;
        }
        m_nSize++;
        SetAtIndex(m_nSize - 1, t);
        return TRUE;
    }
    BOOL Remove(T& t)
    {
        int nIndex = Find(t);
        if(nIndex == -1)
            return FALSE;
        return RemoveAt(nIndex);
    }
    BOOL RemoveAt(int nIndex)
    {
        
        //---- always call the dtr ----
#if _MSC_VER >= 1200
        m_aT[nIndex].~T();
#else
        T* MyT;
        MyT = &m_aT[nIndex];
        MyT->~T();
#endif
        
        //---- if target entry is not at end, compact the array ----
        if(nIndex != (m_nSize - 1))
        {
            
            memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
        }
        
        m_nSize--;
        return TRUE;
    }
    void RemoveAll()
    {
        if(m_aT != NULL)
        {
            for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
                m_aT[i].~T();
#else
                T* MyT;
                MyT = &m_aT[i];
                MyT->~T();
#endif
            }
            free(m_aT);
            m_aT = NULL;
        }
        m_nSize = 0;
        m_nAllocSize = 0;
    }
    T& operator[] (int nIndex) const
    {
        DBG_ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_aT[nIndex];
    }
    T* GetData() const
    {
        return m_aT;
    }
    
    // Implementation
    class Wrapper
    {
    public:
        Wrapper(T& _t) : t(_t)
        {
        }
        template <class _Ty>
            void *operator new(size_t, _Ty* p)
        {
            return p;
        }
        T t;
    };
    void SetAtIndex(int nIndex, T& t)
    {
        DBG_ASSERT(nIndex >= 0 && nIndex < m_nSize);
        new(m_aT + nIndex) Wrapper(t);
    }
    int Find(T& t) const
    {
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] == t)
                return i;
        }
        return -1;  // not found
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\ulatq.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    ulatq.h

Abstract:

    Exported ULATQ.DLL routines.

    ULATQ contains the thread queue and UL support routines for
    IISPLUS.

Author:

    Taylor Weiss (TaylorW)       15-Dec-1999

Revision History:

--*/


#ifndef _ULATQ_H_
#define _ULATQ_H_

//
// The magic context that makes the world turn
//

typedef VOID*               ULATQ_CONTEXT;

//
// Some callbacks specified by user of ULATQ to catch certain events
//

typedef VOID
(*PFN_ULATQ_NEW_REQUEST)
(
    ULATQ_CONTEXT           pContext
);

typedef VOID
(*PFN_ULATQ_IO_COMPLETION)
(
    PVOID                   pvContext,
    DWORD                   cbWritten,
    DWORD                   dwCompletionStatus,
    OVERLAPPED *            lpo
);

typedef VOID
(*PFN_ULATQ_DISCONNECT)
(
    PVOID                   pvContext
);

typedef VOID
(*PFN_ULATQ_ON_SHUTDOWN)
(
    BOOL                    fImmediate
);

typedef HRESULT
(* PFN_ULATQ_COLLECT_PERF_COUNTERS)(
    OUT PBYTE *             ppCounterData,
    OUT DWORD *             pdwCounterData
);

typedef struct _ULATQ_CONFIG
{
    PFN_ULATQ_IO_COMPLETION         pfnIoCompletion;
    PFN_ULATQ_NEW_REQUEST           pfnNewRequest;
    PFN_ULATQ_DISCONNECT            pfnDisconnect;
    PFN_ULATQ_ON_SHUTDOWN           pfnOnShutdown;
    PFN_ULATQ_COLLECT_PERF_COUNTERS pfnCollectCounters;
}
ULATQ_CONFIG, *PULATQ_CONFIG;

//
// ULATQ_CONTEXT properties
//

typedef enum
{
    ULATQ_PROPERTY_COMPLETION_CONTEXT = 0,
    ULATQ_PROPERTY_HTTP_REQUEST,
    ULATQ_PROPERTY_APP_POOL_ID
} ULATQ_CONTEXT_PROPERTY_ID;

HRESULT
UlAtqInitialize(
    INT                 argc,
    LPWSTR              argv[],
    ULATQ_CONFIG *      pConfig
);

HRESULT
UlAtqStartListen(
    VOID
);

VOID
UlAtqTerminate(
    HRESULT hrToSend
);

VOID *
UlAtqGetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   ContextPropertyId
);

VOID
UlAtqSetContextProperty(
    ULATQ_CONTEXT               pContext,
    ULATQ_CONTEXT_PROPERTY_ID   ContextPropertyId,
    PVOID                       pvData
);

VOID
UlAtqFreeContext(
    ULATQ_CONTEXT               pContext
);

HRESULT
UlAtqSendEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    DWORD                       cChunks,
    HTTP_DATA_CHUNK *           pChunks,
    DWORD                      *pcbSent,
    HTTP_LOG_FIELDS_DATA       *pUlLogData
);

HRESULT
UlAtqReceiveEntityBody(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    VOID *                      pBuffer,
    DWORD                       cbBuffer,
    DWORD *                     pBytesReceived
);

HRESULT
UlAtqSendHttpResponse(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    DWORD                       dwFlags,
    HTTP_RESPONSE *             pResponse,
    HTTP_CACHE_POLICY *         pCachePolicy,
    DWORD *                     pcbSent,
    HTTP_LOG_FIELDS_DATA *      pUlLogData
);

HRESULT
UlAtqWaitForDisconnect(
    HTTP_CONNECTION_ID          connectionId,
    BOOL                        fAsync,
    VOID *                      pvContext
);

HRESULT
UlAtqReceiveClientCertificate(
    ULATQ_CONTEXT               pContext,
    BOOL                        fAsync,
    BOOL                        fDoCertMap,
    HTTP_SSL_CLIENT_CERT_INFO **ppClientCertInfo
);

HRESULT
UlAtqInduceShutdown(
    BOOL fImmediate
);

HRESULT
UlAtqFlushUlCache(
    WCHAR *                     pszURLPrefix
);

#endif // _ULATQ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\w3isapi.h ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     w3isapi.h

   Abstract:
     IIS+ ISAPI handler.
 
   Author:
     Taylor Weiss (TaylorW)             03-Feb-2000

   Project:
     w3isapi.dll

--*/

#ifndef _W3ISAPI_H_
#define _W3ISAPI_H_

#include <iisextp.h>
#include <iisapicore.h>

#define SIZE_CLSID_STRING 40

/* ISAPI_CORE_DATA -
   This structure contains the request data necessary to process
   an ISAPI request.
   
   For an "in process" request, this structure's pointers could
   potentially point to memory allocated by the server core.  To
   support "out of process" requests, it's necessary to append
   the important data to the structure itself in a single block.

   The _cbSize member should reflect the size of both the structure,
   and any such appended data.
*/
struct ISAPI_CORE_DATA
{
    //
    // Structure size information
    //
    
    DWORD       cbSize;

    //
    // CLSID of the WAM to handle the request - If
    // the value is an empty string, then the request
    // will be handled inproc.
    //

    WCHAR       szWamClsid[SIZE_CLSID_STRING];
    BOOL        fIsOop;

    //
    // Secure request?
    //

    BOOL        fSecure;

    //
    // Client HTTP version
    //

    DWORD       dwVersionMajor;
    DWORD       dwVersionMinor;

    //
    // Web site instance ID
    //

    DWORD       dwInstanceId;

    //
    // Request content-length
    //

    DWORD       dwContentLength;

    //
    // Authenticated client impersonation token
    //

    HANDLE      hToken;
    PSID        pSid;

    //
    // Embedded string sizes
    //

    DWORD       cbGatewayImage;
    DWORD       cbPhysicalPath;
    DWORD       cbPathInfo;
    DWORD       cbMethod;
    DWORD       cbQueryString;
    DWORD       cbPathTranslated;
    DWORD       cbContentType;
    DWORD       cbConnection;
    DWORD       cbUserAgent;
    DWORD       cbCookie;
    DWORD       cbApplMdPath;
    DWORD       cbApplMdPathW;
    DWORD       cbPathTranslatedW;

    //
    // Request string data
    //

    LPWSTR      szGatewayImage;
    LPSTR       szPhysicalPath;
    LPSTR       szPathInfo;
    LPSTR       szMethod;
    LPSTR       szQueryString;
    LPSTR       szPathTranslated;
    LPSTR       szContentType;
    LPSTR       szConnection;
    LPSTR       szUserAgent;
    LPSTR       szCookie;
    LPSTR       szApplMdPath;

    //
    // Unicode data used by ASP
    //
    // This is only populated in the OOP case so that
    // we can avoid an RPC call when ASP calls GetServerVariable
    // for them.  Inproc, they are NULL.
    //

    LPWSTR      szApplMdPathW;
    LPWSTR      szPathTranslatedW;

    //
    // Entity data
    //

    DWORD       cbAvailableEntity;
    LPVOID      pAvailableEntity;
};

typedef HRESULT(* PFN_ISAPI_INIT_MODULE)( LPSTR, LPSTR, DWORD );
typedef VOID(* PFN_ISAPI_TERM_MODULE)( VOID );
typedef HRESULT(* PFN_ISAPI_PROCESS_REQUEST)( IIsapiCore *, ISAPI_CORE_DATA *, DWORD * );
typedef HRESULT(* PFN_ISAPI_PROCESS_COMPLETION)( DWORD64, DWORD, DWORD );

#define ISAPI_INIT_MODULE           "InitModule"
#define ISAPI_TERM_MODULE           "TerminateModule"
#define ISAPI_PROCESS_REQUEST       "ProcessIsapiRequest"
#define ISAPI_PROCESS_COMPLETION    "ProcessIsapiCompletion"

#define ISAPI_MODULE_NAME       L"w3isapi.dll"

#endif // _W3ISAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\ulw3.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ulw3.h

Abstract:

    Defines the public ULW3.DLL entry point

Author:

    Bilal Alam (balam)      12-Dec-1999

Revision History:

--*/

#ifndef _ULW3_H_
#define _ULW3_H_

#define ULW3_DLL_NAME               (L"w3core.dll")
#define ULW3_DLL_ENTRY              ("UlW3Start")

#define SERVER_SOFTWARE_STRING      ("Microsoft-IIS/6.0")

typedef HRESULT (*PFN_ULW3_ENTRY)( INT argc, LPWSTR* argv, BOOL fCompat );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inetinfo\main.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This is the main routine for the Internet Services suite.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:
    Murali Krishnan ( Muralik)  16-Nov-1994  Added Gopher service
    Murali Krishnan ( Muralik)  3-July-1995  Removed non-internet info + trims
    Sophia Chung     (sophiac)  09-Oct-1995  Splitted internet services into
                                             access and info services
    Murali Krishnan ( Muralik)  20-Feb-1996  Enabled to run on NT Workstation
    Emily Kruglick  ( EmilyK)   14-Jun-2000  Moved file from iis 5 tree to iis 6.
                                             Removed all Win95 support.
                                             Added support for WAS controlling W3SVC.

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <inetsvcs.h>
#include <iis64.h>
#include "waslaunch.hxx"

#include "inetimsg.h"
#include "iisadmin.hxx"
#include <objbase.h>
#include "regconst.h"

//
// Modifications to this name should also be made in tsunami.hxx
//

#define INETA_W3ONLY_NO_AUTH            TEXT("W3OnlyNoAuth")

//
// Functions used to start/stop the RPC server
//

typedef   DWORD ( *PFN_INETINFO_START_RPC_SERVER)   ( VOID );
typedef   DWORD ( *PFN_INETINFO_STOP_RPC_SERVER)    ( VOID );

//
// Local function used by the above to load and invoke a service DLL.
//

VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    );

VOID
StartDispatchTable(
    VOID
    );


//
// Functions used to preload dlls into the inetinfo process
//

BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );

VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    );


//
// Used if the services Dll or entry point can't be found
//

VOID
AbortService(
    LPSTR  ServiceName,
    DWORD   Error
    );

//
// Dispatch table for all services. Passed to NetServiceStartCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
// Also add an entry in the following table InetServiceDllTable
//

SERVICE_TABLE_ENTRY InetServiceDispatchTable[] = {
                        { "GopherSvc", InetinfoStartService  },
                        { "MSFtpSvc",  InetinfoStartService  },
                        { "W3Svc",     InetinfoStartService  },
                        { "IISADMIN",  InetinfoStartService  },
                        { NULL,              NULL  },
                        };

SERVICE_TABLE_ENTRY W3ServiceDispatchTable[] = {
                        { "W3Svc",     InetinfoStartService  },
                        { NULL,              NULL  },
                        };

//
// DLL names for all services.
//  (should correspond exactly with above InetServiceDispatchTable)
//

struct SERVICE_DLL_TABLE_ENTRY  {

    LPSTR               lpServiceName;
    LPSTR               lpDllName;
    CRITICAL_SECTION    csLoadLock;
} InetServiceDllTable[] = {
    { "GopherSvc",      "gopherd.dll" },
    { "MSFtpSvc",       "ftpsvc2.dll" },
    { "W3Svc",          "w3svc.dll" },
    { "IISADMIN",       "iisadmin.dll" },
    { NULL,             NULL }
};

//
// Global parameter data passed to each service.
//

TCPSVCS_GLOBAL_DATA InetinfoGlobalData;

#include <initguid.h>
DEFINE_GUID(IisExeGuid, 
0x784d8901, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#ifndef _NO_TRACING_
#include "dbgutil.h"
#include "pudebug.h"
DECLARE_DEBUG_PRINTS_OBJECT()
#endif

//
// A global variable that remembers that we'll refuse to start.
//

BOOL RefuseStartup = FALSE;
BOOL g_fRunAsExe = FALSE;
BOOL g_fW3svcNoAuth = FALSE;
BOOL g_fOleInitialized = TRUE;

DWORD __cdecl
main(
    IN DWORD argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    This is the main routine for the LANMan services.  It starts up the
    main thread that is going to handle the control requests from the
    service controller.

    It basically sets up the ControlDispatcher and, on return, exits
    from this main thread.  The call to NetServiceStartCtrlDispatcher
    does not return until all services have terminated, and this process
    can go away.

    The ControlDispatcher thread will start/stop/pause/continue any
    services.  If a service is to be started, it will create a thread
    and then call the main routine of that service.  The "main routine"
    for each service is actually an intermediate function implemented in
    this module that loads the DLL containing the server being started
    and calls its entry point.


Arguments:

    None.

Return Value:

    None.

--*/
{

    HMODULE  dllHandle = NULL;
    HINSTANCE  hRpcRef = NULL;
    HMODULE * pPreloadDllHandles = NULL;
    DWORD dwIndex;
    struct SERVICE_DLL_TABLE_ENTRY * pEntry;
    DWORD err = ERROR_SUCCESS;

    //
    // Initialize OLE
    //

#ifndef _NO_TRACING_
    HRESULT hr;

    CREATE_DEBUG_PRINT_OBJECT("Inetinfo.exe");
 //   CREATE_INITIALIZE_DEBUG();
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED );
#else
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED );
#endif
    if ( FAILED(hr)) {
        if ( hr != E_INVALIDARG ) {
            IIS_PRINTF((buff,"CoInitialize failed with %x\n",hr));
            g_fOleInitialized = FALSE;
        }
    }


    //
    // Initialize Global Data.
    //
    //
    // Use the rpcref library, so that multiple services can
    // independently "start" the rpc server
    //

    hRpcRef = LoadLibrary("rpcref.dll");

    if ( hRpcRef != NULL )
    {
        InetinfoGlobalData.StartRpcServerListen =
            (PFN_INETINFO_START_RPC_SERVER)
            GetProcAddress(hRpcRef,"InetinfoStartRpcServerListen");

        InetinfoGlobalData.StopRpcServerListen =
            (PFN_INETINFO_STOP_RPC_SERVER)
            GetProcAddress(hRpcRef,"InetinfoStopRpcServerListen");
    }
    else
    {
        IIS_PRINTF((buff,
                   "Error %d loading rpcref.dll\n",
                   GetLastError() ));
#ifndef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
  //      DELETE_INITIALIZE_DEBUG()
#endif
        return GetLastError();
    }



    //
    //  Initialize service entry locks
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        InitializeCriticalSection( &( pEntry->csLoadLock ) );
    }

    //
    //  Disable hard-error popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX );

    //
    // Preload Dlls specified in the registry
    //

    if ( !LoadPreloadDlls( &pPreloadDllHandles ) )
    {
        IIS_PRINTF(( buff, "Error pre-loading DLLs\n" ));
    }


    if ( (argc > 2) && !_stricmp( argv[1], "-e" ))
    {
        PCHAR    pszName = argv[2];
        HANDLE   hAsExeEvent;
        HANDLE   hStartW3svc = NULL;
        PIISADMIN_SERVICE_DLL_EXEENTRY IisAdminExeEntry = NULL;
        PIISADMIN_SERVICE_DLL_EXEEXIT  IisAdminExeExit  = NULL;
        BOOL     IsIisAdmin = TRUE;


        //
        //  Create a named event.  The common internet services code attempts
        //  to create a semaphore with the same name, if it fails then the
        //  service is being run as an exe
        //

        g_fRunAsExe = TRUE;

        hAsExeEvent = CreateEvent( NULL,
                                   FALSE,
                                   FALSE,
                                   IIS_AS_EXE_OBJECT_NAME);

        err = GetLastError();
        if ( hAsExeEvent == NULL ) {

            IIS_PRINTF((buff,"Cannot create %s event. err %d\n",
                IIS_AS_EXE_OBJECT_NAME, err));
            goto Finished;
        }

        if ( err != ERROR_SUCCESS ) {

            CloseHandle(hAsExeEvent);

            IIS_PRINTF((buff,
                "Error %d in CreateEvent[%s]\n",
                err, IIS_AS_EXE_OBJECT_NAME));

            goto Finished;
        }

        //
        // All services are dependent on IISADMIN
        // so if it's not IISADMIN call it
        //

        if ( (_stricmp(IISADMIN_NAME, pszName) != 0) ) {

            //
            // Not IISADMIN
            //

            IsIisAdmin = FALSE;

            dllHandle = LoadLibrary(IISADMIN_NAME);

            if ( dllHandle == NULL ) {

                err = GetLastError();

                IIS_PRINTF((buff,
                         "Inetinfo: Failed to load DLL %s: %ld\n",
                                  IISADMIN_NAME, err));
                goto Finished;
            }

            //
            // Get the address of the service's main entry point.  This
            // entry point has a well-known name.
            //

            IisAdminExeEntry = (PIISADMIN_SERVICE_DLL_EXEENTRY)GetProcAddress(
                                                        dllHandle,
                                                        IISADMIN_EXEENTRY_STRING
                                                        );

            if (IisAdminExeEntry == NULL ) {
                err = GetLastError();
                IIS_PRINTF((buff,
                        "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                        IISADMIN_EXEENTRY_STRING, IISADMIN_NAME, err));
                goto Finished;
            }

            IisAdminExeExit = (PIISADMIN_SERVICE_DLL_EXEEXIT)GetProcAddress(
                                                        dllHandle,
                                                        IISADMIN_EXEEXIT_STRING
                                                        );

            if (IisAdminExeExit == NULL ) {
                err = GetLastError();
                IIS_PRINTF((buff,
                    "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                     IISADMIN_EXEEXIT_STRING, IISADMIN_NAME, err);
                     );
                goto Finished;
            }

            if (!IisAdminExeEntry( TRUE, FALSE, TRUE)) {
                IIS_PRINTF((buff,"IISadmin init failed\n"));
                err = 1;
                goto Finished;
            }
        }

        //
        //  Offset argv so that the first entry points to the dll name to
        //  load
        //

        IIS_PRINTF((buff,"Starting %s\n", pszName));
        InetinfoStartService( 1, &argv[2] );

        if (!IsIisAdmin) {
            IisAdminExeExit();
        }

        if ( hStartW3svc != NULL ) {
            CloseHandle( hStartW3svc );
        }
        CloseHandle( hAsExeEvent );

    } else {

        StartDispatchTable( );
    }

    DBGPRINTF((
    DBG_CONTEXT, 
    "Finishing main CTC = %d \n",
    GetTickCount()
    ));

Finished:

    //
    // Unload pre-loaded Dlls
    //

    UnloadPreloadDlls( &pPreloadDllHandles );

    //
    // Cleanup OLE
    //

    if ( g_fOleInitialized ) {
        CoUninitialize();
        g_fOleInitialized = FALSE;
    }

    //
    // Free the admin service dll
    // Note: this must happen after CoUninitialize or it causes
    // a crash on Win95
    //

    if (dllHandle != NULL) {
        FreeLibrary( dllHandle );
    }


    if ( hRpcRef != NULL ) {
        FreeLibrary( hRpcRef );
        hRpcRef = NULL;
    }

    //
    //  Terminate service entry locks
    //

    for ( dwIndex = 0 ; ; dwIndex++ )
    {
        pEntry = &( InetServiceDllTable[ dwIndex ] );
        if ( pEntry->lpServiceName == NULL )
        {
            break;
        }

        DeleteCriticalSection( &( pEntry->csLoadLock ) );
    }
    
    IIS_PRINTF((buff,"Exiting inetinfo.exe\n"));
#ifndef _NO_TRACING_
    DELETE_DEBUG_PRINT_OBJECT();
//    DELETE_INITIALIZE_DEBUG()
#endif

    DBGPRINTF((
    DBG_CONTEXT, 
    "Exiting main CTC = %d \n",
    GetTickCount()
    ));

    return err;

} // main



DWORD
FindEntryFromDispatchTable(
            IN LPSTR pszService
            )
{
    SERVICE_TABLE_ENTRY  * pService;

    for(pService = InetServiceDispatchTable;
        pService->lpServiceName != NULL;
        pService++) {

        if ( !lstrcmpi( pService->lpServiceName, pszService)) {
    
            return DIFF(pService - InetServiceDispatchTable);
        }
    }

    //
    // We have not found the entry. Set error and return
    //

    SetLastError( ERROR_INVALID_PARAMETER);
    return 0xFFFFFFFF;

} // FindEntryFromDispatchTable()

BOOL
GetDLLNameForDispatchEntryService(
    IN LPSTR                    pszService,
    IN OUT CHAR *               pszDllName,
    IN DWORD                    cbDllName
)
/*++

Routine Description:

    If the image name is not in the static dispatch table, then it might be
    in the registry under the value "IISDllName" under the key for the
    service.  This routine reads the registry for the setting (if existing).

    This code allows the exchange folks to install their service DLLs in a
    location other than "%systemroot%\inetsrv".  

Arguments:

    pszService - Service name
    pszDllName - Filled with image name
    cbDllName - Size of buffer pointed to by pszDllName

Return Value:

    TRUE if successful, else FALSE.

--*/
{
    HKEY hkey = NULL, hkeyService = NULL;
    DWORD err;
    DWORD valType;
    DWORD nBytes;
    BOOL ret = FALSE;
    
    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_SERVICES_KEY_A,
                 0,
                 KEY_READ,
                 &hkeyService
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff, 
            "Inetinfo: Failed to open service key: %ld\n", err));

        goto Cleanup;
    }

    err = RegOpenKeyEx(
                 hkeyService,
                 pszService,
                 0,
                 KEY_READ,
                 &hkey
                 );

    if (err != ERROR_SUCCESS) {

        IIS_PRINTF((buff, 
            "Inetinfo: Failed to open service key for %s: %ld\n",
                pszService, err));

        goto Cleanup;
    }

    nBytes = cbDllName;

    err = RegQueryValueEx(
                hkey,
                REGISTRY_VALUE_IISSERVICE_DLL_PATH_NAME_A,
                NULL,
                &valType,
                (LPBYTE)pszDllName,
                &nBytes);

    if ( err == ERROR_SUCCESS &&
         ( valType == REG_SZ || valType == REG_EXPAND_SZ ) )
    {
        IIS_PRINTF((buff,
            "Service Dll is %s", pszDllName));

        ret = TRUE;
    }

Cleanup:

    if (hkey != NULL) {
        RegCloseKey( hkey );
    }

    if (hkeyService != NULL) {
        RegCloseKey( hkeyService );
    }

    return ret;
}


VOID
InetinfoStartService (
    IN DWORD argc,
    IN LPSTR argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    HMODULE dllHandle;
    PINETSVCS_SERVICE_DLL_ENTRY serviceEntry;
    BOOL ok;
    DWORD Error;
    CHAR tmpDllName[MAX_PATH+1];
    LPSTR DllName;
    DWORD dwIndex;

    //
    // If we need to refuse to start services, do so.
    //

    if ( RefuseStartup ) {
        AbortService(argv[0], ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // Find the Dll Name for requested service
    //

    dwIndex = FindEntryFromDispatchTable( argv[0] );
    if ( dwIndex == 0xFFFFFFFF ) {

        if ( GetDLLNameForDispatchEntryService( argv[0],
                                                tmpDllName,
                                                sizeof( tmpDllName ) ) ) {
            IIS_PRINTF((buff,
                        "Service %s has path set in registry.  Assuming %s\n",
                        argv[0],
                        tmpDllName));
            DllName = tmpDllName;
        }
        else if ( strlen(argv[0]) < (MAX_PATH-4) ) {
            strcpy(tmpDllName, argv[0]);
            strcat(tmpDllName, ".dll");

            IIS_PRINTF((buff,"Service %s not on primary list.  Assuming %s\n",
                argv[0], tmpDllName));
            DllName = tmpDllName;
        } else {
            Error = ERROR_INSUFFICIENT_BUFFER;
            IIS_PRINTF((buff,
                    "Inetinfo: Failed To Find Dll For %s : %ld\n",
                    argv[0], Error));
            AbortService( argv[0], Error);
            return;
        }
    }
    else
    {
        DllName = InetServiceDllTable[ dwIndex ].lpDllName;
    }

    //
    // Load the DLL that contains the service.
    //

    if ( dwIndex != 0xFFFFFFFF )
    {
        EnterCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }

    dllHandle = LoadLibraryEx( DllName, NULL, LOAD_WITH_ALTERED_SEARCH_PATH );
    if ( dllHandle == NULL ) {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Failed to load DLL %s: %ld\n",
                 DllName, Error));
        AbortService(argv[0], Error);
        goto Finished;
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    serviceEntry = (PINETSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                dllHandle,
                                                INETSVCS_ENTRY_POINT_STRING
                                                );

    if ( serviceEntry == NULL ) {
        Error = GetLastError();
        IIS_PRINTF((buff,
                 "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                 INETSVCS_ENTRY_POINT_STRING, DllName, Error));
        AbortService(argv[0], Error);
    } else {

        //
        // Call the service's main entry point.  This call doesn't return
        // until the service exits.
        //

        serviceEntry( argc, argv, &InetinfoGlobalData );

    }

    //
    // wait for the control dispatcher routine to return.  This
    // works around a problem where simptcp was crashing because the
    // FreeLibrary() was happenning before the control routine returned.
    //

    Sleep( 500 );

    //
    // Unload the DLL.
    //

    ok = FreeLibrary( dllHandle );
    if ( !ok ) {
        IIS_PRINTF((buff,
                 "INETSVCS: Can't unload DLL %s: %ld\n",
                 DllName, GetLastError()));
    }

Finished:
    if ( dwIndex != 0xFFFFFFFF )
    {
        LeaveCriticalSection( &( InetServiceDllTable[ dwIndex ].csLoadLock ) );
    }
    
    return;

} // InetinfoStartService



VOID
DummyCtrlHandler(
    DWORD   Opcode
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler


VOID
AbortService(
    LPSTR  ServiceName,
    DWORD  Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE GenericServiceStatusHandle;
    SERVICE_STATUS GenericServiceStatus;

    if (!g_fRunAsExe) {
        GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
        GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
        GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
        GenericServiceStatus.dwCheckPoint         = 0;
        GenericServiceStatus.dwWaitHint           = 0;
        GenericServiceStatus.dwWin32ExitCode      = Error;
        GenericServiceStatus.dwServiceSpecificExitCode = 0;

        GenericServiceStatusHandle = RegisterServiceCtrlHandler(
                    ServiceName,
                    DummyCtrlHandler);

        if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {

            IIS_PRINTF((buff,
                     "[Inetinfo]RegisterServiceCtrlHandler[%s] failed %d\n",
                     ServiceName, GetLastError()));

        } else if (!SetServiceStatus (GenericServiceStatusHandle,
                    &GenericServiceStatus)) {

            IIS_PRINTF((buff,
                     "[Inetinfo]SetServiceStatus[%s] error %ld\n",
                     ServiceName, GetLastError()));
        }
    }

    return;
};

VOID
StartDispatchTable(
    VOID
    )
/*++

Routine Description:

    Returns the dispatch table to use.  It uses the default if
    the DispatchEntries value key does not exist

Arguments:

    None.

Return Value:

    Pointer to the dispatch table to use.

--*/
{
    LPSERVICE_TABLE_ENTRY dispatchTable = InetServiceDispatchTable;
    LPSERVICE_TABLE_ENTRY tableEntry = NULL;

    LPBYTE buffer;
    HKEY hKey = NULL;

    DWORD i;
    DWORD err;
    DWORD valType;
    DWORD nBytes = 0;
    DWORD nEntries = 0;
    PCHAR entry;
    BOOL  IsIisAdmin = TRUE;
    HMODULE  dllHandle;
    PIISADMIN_SERVICE_DLL_EXEENTRY IisAdminExeEntry = NULL;
    PIISADMIN_SERVICE_DLL_EXEEXIT  IisAdminExeExit  = NULL;
    DWORD   dwW3svcNoAuth;

    //
    // See if need to augment the dispatcher table
    //

    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_KEY_INETINFO_PARAMETERS_A,
                 0,
                 KEY_READ,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS ) {
        hKey = NULL;
        goto start_dispatch;
    }

    //
    // See if mono service
    //

    nBytes = sizeof(dwW3svcNoAuth);
    if ( RegQueryValueEx(
                    hKey,
                    INETA_W3ONLY_NO_AUTH,
                    NULL,
                    &valType,
                    (LPBYTE)&dwW3svcNoAuth,
                    &nBytes
                    ) == ERROR_SUCCESS && valType == REG_DWORD ) {
        g_fW3svcNoAuth = !!dwW3svcNoAuth;
    }

    if ( g_fW3svcNoAuth ) {

        dllHandle = LoadLibrary(IISADMIN_NAME);

        if ( dllHandle == NULL ) {

            err = GetLastError();

            IIS_PRINTF((buff,
                     "Inetinfo: Failed to load DLL %s: %ld\n",
                              IISADMIN_NAME, err));
            return;
        }

        //
        // Get the address of the service's main entry point.  This
        // entry point has a well-known name.
        //

        IisAdminExeEntry = (PIISADMIN_SERVICE_DLL_EXEENTRY)GetProcAddress(
                                                    dllHandle,
                                                    IISADMIN_EXEENTRY_STRING
                                                    );

        if (IisAdminExeEntry == NULL ) {
            err = GetLastError();
            IIS_PRINTF((buff,
                    "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                    IISADMIN_EXEENTRY_STRING, IISADMIN_NAME, err));
            return;
        }

        IisAdminExeExit = (PIISADMIN_SERVICE_DLL_EXEEXIT)GetProcAddress(
                                                    dllHandle,
                                                    IISADMIN_EXEEXIT_STRING
                                                    );

        if (IisAdminExeExit == NULL ) {
            err = GetLastError();
            IIS_PRINTF((buff,
                "Inetinfo: Can't find entry %s in DLL %s: %ld\n",
                 IISADMIN_EXEEXIT_STRING, IISADMIN_NAME, err);
                 );
            return;
        }

        if (!IisAdminExeEntry( FALSE, TRUE, TRUE )) {
            IIS_PRINTF((buff,"IISadmin init failed\n"));
            return;
        }

        IsIisAdmin = FALSE;

        dispatchTable = W3ServiceDispatchTable;

        goto start_dispatch;
    }

    //
    // See if the value exists and get the size of the buffer needed
    //

    nBytes = 0;
    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A,
                    NULL,
                    &valType,
                    NULL,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) || (nBytes <= sizeof(CHAR)) ) {
        goto start_dispatch;
    }

    //
    // Allocate nBytes to query the buffer
    //

    buffer = (LPBYTE)LocalAlloc(0, nBytes);
    if ( buffer == NULL ) {
        goto start_dispatch;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_DISPATCH_ENTRIES_A,
                    NULL,
                    &valType,
                    buffer,
                    &nBytes
                    );

    if ( (err != ERROR_SUCCESS) || (valType != REG_MULTI_SZ) ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // Walk the list and see how many entries we have. Remove the list
    // terminator from the byte count
    //

    nBytes -= sizeof(CHAR);
    for ( i = 0, entry = (PCHAR)buffer;
        i < nBytes;
        i += sizeof(CHAR) ) {

        if ( *entry++ == '\0' ) {
            nEntries++;
        }
    }

    if ( nEntries == 0 ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // Add the number of entries in the default list (including the NULL entry)
    //

    nEntries += sizeof(InetServiceDispatchTable) / sizeof(SERVICE_TABLE_ENTRY);

    //
    // Now we need to allocate the new dispatch table
    //

    tableEntry = (LPSERVICE_TABLE_ENTRY)
        LocalAlloc(0, nEntries * sizeof(SERVICE_TABLE_ENTRY));

    if ( tableEntry == NULL ) {
        LocalFree(buffer);
        goto start_dispatch;
    }

    //
    // set the dispatch table pointer to the new table
    //

    dispatchTable = tableEntry;

    //
    // Populate the table starting with the defaults
    //

    for (i=0; InetServiceDispatchTable[i].lpServiceName != NULL; i++ ) {

        tableEntry->lpServiceName =
            InetServiceDispatchTable[i].lpServiceName;
        tableEntry->lpServiceProc =
            InetServiceDispatchTable[i].lpServiceProc;
        tableEntry++;

    }

    //
    // Now let's add the ones specified in the registry
    //

    entry = (PCHAR)buffer;

    tableEntry->lpServiceName = entry;
    tableEntry->lpServiceProc = InetinfoStartService;
    tableEntry++;

    //
    // Skip the first char and the last NULL terminator.
    // This is needed because we already added the first one.
    //

    for ( i = 2*sizeof(CHAR); i < nBytes; i += sizeof(CHAR) ) {

        if ( *entry++ == '\0' ) {
            tableEntry->lpServiceName = entry;
            tableEntry->lpServiceProc = InetinfoStartService;
            tableEntry++;
        }
    }

    //
    // setup sentinel entry
    //

    tableEntry->lpServiceName = NULL;
    tableEntry->lpServiceProc = NULL;

start_dispatch:

    if ( hKey != NULL ) {
        RegCloseKey(hKey);
    }

    W3SVCLauncher* pLauncher = new W3SVCLauncher();
    if (pLauncher==NULL)
    {
        IIS_PRINTF((buff,
                 "Inetinfo: Can not launch the W3SVC launching class %lu\n",
                  GetLastError()));
    }
    else
    {
        pLauncher->StartListening();
    }


    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (
                dispatchTable
                )) {
        //
        // Log an event for failing to start control dispatcher
        //

        IIS_PRINTF((buff,
                 "Inetinfo: Failed to start control dispatcher %lu\n",
                  GetLastError()));
    }

    DBGPRINTF((
    DBG_CONTEXT, 
    "All services have shutdown CTC = %d \n",
    GetTickCount()
    ));

    if (pLauncher)
    {
        pLauncher->StopListening();

        delete pLauncher;
        pLauncher = NULL;
    }


    DBGPRINTF((
    DBG_CONTEXT, 
    "Completed all W3SVC new code CTC = %d \n",
    GetTickCount()
    ));

    // Now that we have returned from the StartServiceCtrlDispatcher it means
    // that even IISAdmin has shutdown.  This means that W3svc is no longer running
    // and that we do not need to keep listening for WAS to tell us to start W3WP.
    // Therefore we need to single the thread to complete so that inetinfo.exe shutsdown
    // correctly.

    //
    // free table if allocated
    //

    if ( dispatchTable != InetServiceDispatchTable &&
         dispatchTable != W3ServiceDispatchTable ) {
        LocalFree( dispatchTable );
        LocalFree( buffer );
    }

    if (!IsIisAdmin) {
        IisAdminExeExit();
        FreeLibrary( dllHandle );
    }

    DBGPRINTF((
    DBG_CONTEXT, 
    "Exiting StartDispatchTable CTC = %d \n",
    GetTickCount()
    ));

    return;

} // StartDispatchTable




BOOL
LoadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Force pre-loading of any DLLs listed in the associated registry key.
    This is to support DLLs that have code which must run before other parts
    of inetinfo start.

Arguments:

    On input, an (uninitialized) pointer to an array of module handles. This
    array is allocated, filled out, and returned to the caller by this
    function. The caller must eventually call UnloadPreloadDlls on this array
    in order to close the handles and release the memory.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL bSuccess = TRUE;
    HKEY hKey = NULL;
    DWORD err;
    DWORD cbBufferLen;
    DWORD valType;
    LPBYTE pbBuffer = NULL;
    DWORD i;
    PCHAR pszTemp = NULL;
    DWORD nEntries;
    PCHAR pszEntry = NULL;
    DWORD curEntry;


    *ppPreloadDllHandles = NULL;


    err = RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 REGISTRY_KEY_INETINFO_PARAMETERS_A,
                 0,
                 KEY_QUERY_VALUE,
                 &hKey
                 );

    if ( err != ERROR_SUCCESS ) {
        // Note: not considered an error if the key is not there

        hKey = NULL;

        goto Exit;
    }


    //
    // See if the value exists and get the size of the buffer needed
    //

    cbBufferLen = 0;

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A,
                    NULL,
                    &valType,
                    NULL,
                    &cbBufferLen
                    );

    //
    // Check for no value or an empty value (double null terminated).
    //
    if ( ( err != ERROR_SUCCESS ) || ( cbBufferLen <= 2 * sizeof(CHAR) ) )
    {
        // Note: not considered an error if the value is not there

        goto Exit;
    }

    //
    // Allocate cbBufferLen in order to fetch the data
    //

    pbBuffer = (LPBYTE)LocalAlloc(
                        0,
                        cbBufferLen
                        );

    if ( pbBuffer == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }

    //
    // Get the values
    //

    err = RegQueryValueEx(
                    hKey,
                    REGISTRY_VALUE_INETINFO_PRELOAD_DLLS_A,
                    NULL,
                    &valType,
                    pbBuffer,
                    &cbBufferLen
                    );

    if ( ( err != ERROR_SUCCESS ) || ( valType != REG_MULTI_SZ ) )
    {
        bSuccess = FALSE;
        goto Exit;
    }


    //
    // Walk the list and see how many entries we have. Ignore the list
    // terminator in the last byte of the buffer.
    //

    nEntries = 0;
    pszTemp = (PCHAR)pbBuffer;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            nEntries++;
        }

        pszTemp++;
    }


    //
    // Allocate the array of handles, with room for a sentinel entry
    //

    *ppPreloadDllHandles = (HMODULE *)LocalAlloc(
                                            0,
                                            ( nEntries + 1 ) * sizeof(HMODULE)
                                            );

    if ( *ppPreloadDllHandles == NULL )
    {
        bSuccess = FALSE;
        goto Exit;
    }


    //
    // Now attempt to load each DLL, and save the handle in the array
    //

    pszTemp = (PCHAR)pbBuffer;
    pszEntry = (PCHAR)pbBuffer;
    curEntry = 0;

    for ( i = 0; i < ( cbBufferLen - sizeof(CHAR) ) ; i += sizeof(CHAR) )
    {
        if ( *pszTemp == '\0' )
        {
            //
            // We've hit the end of one of the SZs in the Multi-SZ;
            // Load the DLL
            //

            (*ppPreloadDllHandles)[curEntry] = LoadLibrary( pszEntry );

            if ( (*ppPreloadDllHandles)[curEntry] == NULL )
            {
                IIS_PRINTF(( buff, "Preloading FAILED for DLL: %s\n", pszEntry ));
            }
            else
            {
                IIS_PRINTF(( buff, "Preloaded DLL: %s\n", pszEntry ));

                // Only move to the next slot if we got a valid handle
                curEntry++;
            }


            // Set the next entry pointer past the current null char
            pszEntry = pszTemp + sizeof(CHAR);
        }

        pszTemp++;
    }


    // Put in a sentinel at the end of the array

    (*ppPreloadDllHandles)[curEntry] = NULL;


Exit:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
    }

    if ( pbBuffer != NULL )
    {
        LocalFree( pbBuffer );
    }


    return bSuccess;

} // LoadPreloadDlls


VOID
UnloadPreloadDlls(
    HMODULE * * ppPreloadDllHandles
    )
/*++

Routine Description:

    Unload any DLLs which were preloaded by LoadPreloadDlls.

Arguments:

    Pointer to an array of module handles. Each handle will be freed,
    and then the memory of the array will be LocalFree()ed by this function.

Return Value:

    None.

--*/
{
    HMODULE * pHandleArray = *ppPreloadDllHandles;

    if ( pHandleArray != NULL )
    {

        IIS_PRINTF(( buff, "Unloading Preloaded DLLs\n" ));


        while ( *pHandleArray != NULL )
        {
            FreeLibrary( *pHandleArray );

            pHandleArray++;
        }


        LocalFree( *ppPreloadDllHandles );

        *ppPreloadDllHandles = NULL;
    }

    return;

} // UnloadPreloadDlls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inc\thread_pool.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name:

    thread_pool.h

Abstract:

    Public routines for the iisplus worker process thread pool.
    
    This thread pool is based on the IIS5 atq implementation.

Author:

    Taylor Weiss (TaylorW)       12-Jan-2000

Revision History:

--*/

#ifndef _THREAD_POOL_H_
#define _THREAD_POOL_H_


//
// ThreadPoolBindIoCompletionCallback:
//
// The real public API. Clients that wish to queue io completions
// to the process Thread Pool should use this call as they would 
// the NT5 thread pool call.
//

BOOL
ThreadPoolBindIoCompletionCallback(
    IN HANDLE FileHandle,                         // handle to file
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,  // callback
    IN ULONG Flags                                // reserved
    );

//
// ThreadPoolPostCompletion:
//
// Use this function to get one of the process worker threads
// to call your completion function.
//

BOOL ThreadPoolPostCompletion(
    IN DWORD dwBytesTransferred,
    IN LPOVERLAPPED_COMPLETION_ROUTINE Function,
    IN LPOVERLAPPED lpo
    );


// forward declarations
enum THREAD_POOL_INFO;
class THREAD_POOL_DATA;

// 
// To use a thread pool other than the per process thread pool
// Use the class THREAD_POOL instead of the global functions
//
class dllexp THREAD_POOL
{
public:
    static BOOL CreateThreadPool(OUT THREAD_POOL ** ppThreadPool);
    VOID TerminateThreadPool();

    BOOL BindIoCompletionCallback(IN HANDLE hFileHandle,
                                  IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                                  IN ULONG flags);

    BOOL PostCompletion(IN DWORD dwBytesTransferred,
                        IN LPOVERLAPPED_COMPLETION_ROUTINE function,
                        IN LPOVERLAPPED lpo);

    ULONG_PTR GetInfo(IN THREAD_POOL_INFO InfoId);
    ULONG_PTR SetInfo(IN THREAD_POOL_INFO InfoId,
                      IN ULONG_PTR        Data);

private:
    // use create and terminate
    THREAD_POOL();
    ~THREAD_POOL();
    
    // not implemented
    THREAD_POOL(const THREAD_POOL&);
    THREAD_POOL& operator=(const THREAD_POOL&);

    // private data
    THREAD_POOL_DATA * m_pData;
};


//
// Configuration API calls. ONLY ULATQ should call these.
//

HRESULT
ThreadPoolInitialize( VOID );

HRESULT
ThreadPoolTerminate( VOID );

ULONG_PTR
ThreadPoolSetInfo(
    IN THREAD_POOL_INFO InfoId,
    IN ULONG_PTR        Data
    );

ULONG_PTR
ThreadPoolGetInfo(
    IN THREAD_POOL_INFO InfoId
    );

//
// IDs for getting and setting configuration options
//
enum THREAD_POOL_INFO
{
    ThreadPoolMaxPoolThreads,    // per processor threads
    ThreadPoolMaxConcurrency,    // per processor concurrency value
    ThreadPoolThreadTimeout,     // timeout value for idle threads
    ThreadPoolIncMaxPoolThreads, // Up the max thread count - set only
    ThreadPoolDecMaxPoolThreads, // Decrease the max thread count - set only
    ThreadPoolMaxThreadLimit,    // absolute maximum number of threads
    ThreadPoolAvailableThreads   // Number of available threads - get only
};

#endif // !_THREAD_POOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\isapips\dlldata_stub.c ===
#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\inetinfo\waslaunch.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    waslaunch.cxx

Abstract:

    These are the classes used to communicate between
    inetinfo and WAS for launching a worker process in 
    inetinfo.

Author:

    Emily Kruglick (EmilyK) 14-Jun-2000

Revision History:

--*/

//
// INCLUDES
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>
#include <stdlib.h>
#include <inetsvcs.h>
#include <iis64.h>
#include <wpif.h>
#include "waslaunch.hxx"

#include <objbase.h>

//
// System related headers
//
#ifndef _NO_TRACING_
#include "dbgutil.h"
#include "pudebug.h"
#endif

#include "ulw3.h"

DECLARE_DEBUG_VARIABLE();

//
// Configuration parameters registry key.
//

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\WP";


class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
#else
        UNREFERENCED_PARAMETER(pszModule);
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};


VOID LaunchWorkerProcess()
{
    DEBUG_WRAPPER   dbgWrapper( "w3wp" );
    HRESULT         hr = S_OK;
    HMODULE         hModule = NULL;
    PFN_ULW3_ENTRY  pEntry = NULL;
    BOOL            fCoInit = FALSE;

    // Establish the parameters to pass in when starting
    // the worker process inside inetinfo.
    LPWSTR lpParameters[] =
    {
          { L"" }
        , { L"-a" }
        , { L"1" }
        , { L"DefaultAppPool" }
    };
    DWORD cParameters = 4;

    //
    // Do some COM junk
    //
    DBGPRINTF((
        DBG_CONTEXT, 
        "Inetinfo launch WPW3 - CoInit. CTC = %d \n",
        GetTickCount()
        ));


    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    if (FAILED(hr))
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));
        goto Finished;
    }
    
    fCoInit = TRUE;
    
    //
    // Load the ULW3 DLL which does all the work
    //

    DBGPRINTF((
        DBG_CONTEXT, 
        "Inetinfo launch WPW3 - LoadLib. CTC = %d \n",
        GetTickCount()
        ));

    hModule = LoadLibraryW( ULW3_DLL_NAME );
    if ( hModule == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error loading W3 service dll '%ws'.  Error = %d\n",
                    ULW3_DLL_NAME,
                    GetLastError() ));
        goto Finished;
    }
    
    pEntry = (PFN_ULW3_ENTRY) GetProcAddress( hModule, 
                                              ULW3_DLL_ENTRY );
    if ( pEntry == NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Could not find entry point '%s'.  Error = %d\n",
                    ULW3_DLL_ENTRY,
                    GetLastError() ));
        goto Finished;
    }


    DBGPRINTF((
        DBG_CONTEXT, 
        "Inetinfo launch WPW3 - EntryPoint. CTC = %d \n",
        GetTickCount()
        ));

    hr = pEntry( cParameters, 
                 lpParameters, 
                 TRUE );                    // Compatibility mode = TRUE
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error executing W3WP.  hr = %x\n",
                    hr ));
                    
        goto Finished;
    }
    
Finished:

    //
    // Cleanup any lingering COM objects before unloading
    //
    
    if ( fCoInit )
    {
        CoUninitialize();
    }

    if ( hModule != NULL )
    {
        FreeLibrary( hModule );
    }

}

DWORD WaitOnIISAdminStartup(W3SVCLauncher* pLauncher)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  IISAdminIsStarted = FALSE;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ServiceStatus;

    SC_HANDLE hManager = OpenSCManager(NULL, NULL, GENERIC_READ);
    if ( hManager == NULL )
    {
        dwErr = GetLastError();
        IIS_PRINTF((buff,
             "Failed to open the scm manager, can't wait on iisadmin %x\n",
              HRESULT_FROM_WIN32(dwErr)));

        goto exit;
    };

    hService = OpenServiceA( hManager, "IISADMIN", SERVICE_QUERY_STATUS);
    if ( hService == NULL )
    {
        dwErr = GetLastError();
        goto exit;
    };

    //
    // Make sure iisadmin has not started, and also verify that we are
    // still running ( so we don't hang the thread ).
    //
    while  ( !IISAdminIsStarted && pLauncher->StillRunning() )
    {

        if ( QueryServiceStatus( hService, &ServiceStatus ) )
        {
            if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING ) 
            {
                IISAdminIsStarted = TRUE;
            }
            else
            {
                Sleep ( 1000 );
            }
        }
        else
        {
            dwErr = GetLastError();
            goto exit;
        }

    }; // end of loop

exit:

    if  ( hService ) 
    {
        CloseServiceHandle ( hService );
        hService = NULL;
    };

    if  ( hManager ) 
    {
        CloseServiceHandle ( hManager );
        hManager = NULL;
    };

    return dwErr;
};

// Global Functions.
DWORD WINAPI W3SVCThreadEntry(LPVOID lpParameter)
{
    W3SVCLauncher* pLauncher = (W3SVCLauncher*) lpParameter;
    DWORD   dwErr = ERROR_SUCCESS;

    dwErr = WaitOnIISAdminStartup(pLauncher);

    DBG_ASSERT (pLauncher);
    if ( pLauncher && dwErr == ERROR_SUCCESS )
    {
        // Wait on the W3SVCStartW3SP 
        // If we are in shutdown mode just end, otherwise launch W3WP and wait 
        // for it to return.  Then loop back around.

        while (pLauncher->StillRunning())
        {
            // Do not care what the wait returns, just know that we did signal so we should
            // either end or start a W3WP in inetinfo.
            WaitForSingleObject(pLauncher->GetLaunchEvent(), INFINITE);

            DBGPRINTF((
                DBG_CONTEXT, 
                "Inetinfo launch signal received. CTC = %d \n",
                GetTickCount()
                ));

            // Once inetinfo has heard the event reset it.
            if (!ResetEvent(pLauncher->GetLaunchEvent()))
            {
                dwErr = GetLastError();
                IIS_PRINTF((buff,
                     "Inetinfo: Failed to reset the event %x\n",
                      HRESULT_FROM_WIN32(dwErr)));
                break;
            }
            
            // Assuming we are still running we need
            // to start up the W3WP code now.
            if (pLauncher->StillRunning())
            {
                LaunchWorkerProcess();
            }


        }
    }

    DBGPRINTF((
        DBG_CONTEXT, 
        "W3SVCThreadEntry exiting process (and thread). CTC = %d \n",
        GetTickCount()
        ));

    return dwErr;
};

W3SVCLauncher::W3SVCLauncher() :
    m_hW3SVCThread (NULL),
    m_hW3SVCStartEvent(NULL),
    m_dwW3SVCThreadId(0),
    m_bShutdown(FALSE)
{};
    

VOID W3SVCLauncher::StartListening() 
{ 
    // Make sure this function is not called twice
    // without a StopListening in between.
    DBG_ASSERT (m_hW3SVCStartEvent == NULL);
    DBG_ASSERT (m_hW3SVCThread == NULL);

    m_hW3SVCStartEvent = CreateEvent(NULL, TRUE, FALSE, WEB_ADMIN_SERVICE_START_EVENT_A);
    if (m_hW3SVCStartEvent != NULL)
    {
        
        // Before going off to the Service Controller set up a thread
        // that will allow WAS to contact inetinfo.exe if we need to start
        // w3wp inside of it for backward compatibility.

        m_hW3SVCThread = CreateThread(   NULL           // use current threads security
                                            , 0         // use default stack size
                                            , &W3SVCThreadEntry
                                            , this      // pass this object in.
                                            , 0         // don't create suspended
                                            , &m_dwW3SVCThreadId);
        if (m_hW3SVCThread == NULL)
        {
            IIS_PRINTF((buff,
                 "Inetinfo: Failed to start W3SVC listening thread %lu\n",
                  GetLastError()));
        }
    }
    else
    {
        IIS_PRINTF((buff,
                 "Inetinfo: Failed to create the W3SVC shutdown event so we can not start W3svc %lu\n",
                  GetLastError()));
    }
};

VOID W3SVCLauncher::StopListening()
{
    if (m_hW3SVCStartEvent && m_hW3SVCThread)
    {
        m_bShutdown = TRUE;
        if (!SetEvent(m_hW3SVCStartEvent))
        {
            IIS_PRINTF((buff, "Inetinfo: Failed to shutdown the W3SVC waiting thread %lu\n",
                        GetLastError()));
        }

        DBGPRINTF((
        DBG_CONTEXT, 
        "StopListening is waiting for thread exit. CTC = %d \n",
        GetTickCount()
        ));

        // Now wait on the thread to exit, so we don't allow
        // the caller to delete this object
        // before the thread is done deleting it's pieces.

        // BUGBUG: adjust the wait time to like 2 minutes 
        // and use TerminateThread if we timeout.
        WaitForSingleObject(m_hW3SVCThread, INFINITE);
        CloseHandle(m_hW3SVCThread);
        m_hW3SVCThread = NULL;

        DBGPRINTF((
        DBG_CONTEXT, 
        "StopListening thread has exited. CTC = %d \n",
        GetTickCount()
        ));

    }

    // Close down our handle to this event, 
    // so the kernel can release it.
    if (m_hW3SVCStartEvent)
    {
        CloseHandle(m_hW3SVCStartEvent);
        m_hW3SVCStartEvent = NULL;
    }

    DBGPRINTF((
    DBG_CONTEXT, 
    "Returning from stop listening call. CTC = %d \n",
    GetTickCount()
    ));

};

BOOL W3SVCLauncher::StillRunning()
{
    return (m_bShutdown == FALSE);
}

HANDLE W3SVCLauncher::GetLaunchEvent()
{
    DBG_ASSERT(m_hW3SVCStartEvent);
    return (m_hW3SVCStartEvent);
}

W3SVCLauncher::~W3SVCLauncher() 
{
    // Stop Listening should of been called first
    // which should of freed all of this.
    DBG_ASSERT(m_hW3SVCStartEvent == NULL);
    DBG_ASSERT(m_hW3SVCThread == NULL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\isapips\iisapicore_i_stub.c ===
#include "IIsapiCore_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\isapips\iisapicore_p_stub.c ===
#include "IIsapiCore_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\logging\logging.cxx ===
#include "precomp.hxx"
#include <initguid.h>
#include <ilogobj.hxx>
#include <httpapi.h>
#include <multisza.hxx>
#include "logging.h"
#include "colog.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

#define LOGGING_SIGNATURE      'GGOL'
#define LOGGING_SIGNATURE_FREE 'fgol'

CHAR g_pszComputerName[MAX_COMPUTERNAME_LENGTH + 1];

LOGGING::LOGGING()
    : m_fUlLogType (FALSE),
      m_pComponent (NULL),
      m_cRefs      (1),
      m_Signature  (LOGGING_SIGNATURE)
{}

LOGGING::~LOGGING()
{
    m_Signature = LOGGING_SIGNATURE_FREE;

    //
    // end of logging object
    //
    if (m_pComponent != NULL)
    {
        m_pComponent->TerminateLog();
        m_pComponent->Release();
        m_pComponent = NULL;
    }
}

VOID LOGGING::AddRef()
{
    InterlockedIncrement(&m_cRefs);
}

VOID LOGGING::Release()
{
    DBG_ASSERT(m_cRefs > 0);

    if (InterlockedDecrement(&m_cRefs) == 0)
    {
        delete this;
    }
}

HRESULT LOGGING::ActivateLogging(IN LPCSTR  pszInstanceName,
                                 IN LPCWSTR pszMetabasePath,
                                 IN IMSAdminBase *pMDObject)
{
    HRESULT hr = S_OK;
    DWORD   cbSize;
    DWORD   dwCch;
    STACK_STRU (strPlugin, 64);
    BOOL fInitializedLog = FALSE;
    STACK_STRA (strMetabasePath, 24);

    MB mb(pMDObject);
    if (!mb.Open(pszMetabasePath))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    //
    // If Logging is disabled, bail
    //

    DWORD dwLogType;
    if (mb.GetDword(L"", MD_LOG_TYPE, IIS_MD_UT_SERVER, &dwLogType))
    {
        if (dwLogType == MD_LOG_TYPE_DISABLED)
        {
            DBGPRINTF((DBG_CONTEXT, "Site %S has logging disabled\n",
                       pszInstanceName));
            hr = S_OK;
            goto Exit;
        }
    }

    if (!mb.GetStr(L"", MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, &strPlugin))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    mb.Close();

    //
    // Check if it is one of the built-in logging type handled by UL
    //
    if (!_wcsicmp(strPlugin.QueryStr(), NCSALOG_CLSID) ||
        !_wcsicmp(strPlugin.QueryStr(), ASCLOG_CLSID) ||
        !_wcsicmp(strPlugin.QueryStr(), EXTLOG_CLSID))
    {
        m_fUlLogType = TRUE;
        hr = S_OK;
        goto Exit;
    }
    m_fUlLogType = FALSE;

    //
    // It is custom/ODBC logging.  We handle it in usermode
    //
    CLSID clsid;
    if (FAILED(hr = CLSIDFromString(strPlugin.QueryStr(), &clsid)))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not convert string %S to CLSID\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    LPUNKNOWN punk;
    if (FAILED(hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                                     IID_IUnknown, (void **)&punk)))
    {
        DBGPRINTF((DBG_CONTEXT, "Could not create instance of %S\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    hr = punk->QueryInterface(IID_ILogPlugin, (void **)&m_pComponent);
    punk->Release();

    if (FAILED(hr))
    {
        DBGPRINTF((DBG_CONTEXT, "Failed to get interface for %S\n",
                   strPlugin.QueryStr()));
        goto Exit;
    }

    if (FAILED(hr = strMetabasePath.CopyW(pszMetabasePath)))
    {
        goto Exit;
    }

    if (FAILED(hr = m_pComponent->InitializeLog(pszInstanceName,
                                                strMetabasePath.QueryStr(),
                                                (PCHAR)pMDObject)))
    {
        goto Exit;
    }
    fInitializedLog = TRUE;

    cbSize = m_mszExtraLoggingFields.QuerySize();
    if (FAILED(m_pComponent->QueryExtraLoggingFields(
                   &cbSize,
                   m_mszExtraLoggingFields.QueryStr())))
    {
        if (!m_mszExtraLoggingFields.Resize(cbSize))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        cbSize = m_mszExtraLoggingFields.QuerySize();
        if (FAILED(hr = m_pComponent->QueryExtraLoggingFields(
                            &cbSize,
                            m_mszExtraLoggingFields.QueryStr())))
        {
            goto Exit;
        }
    }
    m_mszExtraLoggingFields.RecalcLen();

 Exit:
    if (FAILED(hr))
    {
        if (m_pComponent != NULL)
        {
            if (fInitializedLog)
            {
                m_pComponent->TerminateLog();
            }

            m_pComponent->Release();
            m_pComponent = NULL;
        }

        m_fUlLogType = FALSE;
    }

    return hr;
}


void LOGGING::LogInformation(
                  IN LOG_CONTEXT *pInetLogInfo)
{
    CInetLogInformation inetLog;

    inetLog.CanonicalizeLogRecord(pInetLogInfo);

    m_pComponent->LogInformation(&inetLog);
}


// static
HRESULT LOGGING::Initialize()
/*++

Routine Description:
    Initialize the logging object by loading the ComLog dll and
    set up all the dll entry point

Return Value:
    HRESULT
--*/
{
    DWORD cbSize = sizeof g_pszComputerName;
    if (!GetComputerNameA(g_pszComputerName, &cbSize))
    {
        strcpy(g_pszComputerName, "<Server>");
    }

    return S_OK;
}

// static
VOID LOGGING::Terminate()
{
    // nothing to do now
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\mbid\mbid.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    mbid.cxx

Abstract:

    Builds a library that defines the MB guids.

Author:

    Taylor Weiss  (TaylorW)       13-Dec-1999

Revision History:

--*/

#include <windows.h>
#include <initguid.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\logging\logobj.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :
        logobj.cxx

   Abstract:
        Log COM Object

   Author:

       Johnson Apacible (JohnsonA)      02-April-1997


--*/

#include "precomp.hxx"
#include <ilogobj.hxx>
#include <httpapi.h>
#include <multisza.hxx>
#include "logging.h"
#include "colog.hxx"

LPSTR ReturnStringInfo(LPSTR   pBuf,
                       LPDWORD pcbBuf,
                       LPSTR   pszInfo,
                       DWORD   cchInfo)
/*--
    Support the weird custom logging semantics.  Do the copy of the
    string from the value we have to the buffer provided if it is big
    enough or return the value if no buffer is provided
++*/
{
    if (pBuf != NULL)
    {
        if (*pcbBuf >= (cchInfo + 1))
        {
            memcpy(pBuf, pszInfo, cchInfo + 1);
        }
        else
        {
            *pcbBuf = cchInfo + 1;
            return NULL;
        }
    }

    *pcbBuf = cchInfo + 1;
    return pszInfo;
}


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetSiteName(IN PCHAR    pszSiteName,
                                 IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszSiteName,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ServiceName,
                            m_pLogContext->QueryUlLogData()->ServiceNameLength);
} // GetSiteName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetComputerName(IN PCHAR    pszComputerName,
                                     IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszComputerName,
                            pcbSize,
                            g_pszComputerName,
                            strlen(g_pszComputerName));
} // GetComputerName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientHostName(IN PCHAR    pszClientHostName,
                                       IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszClientHostName,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ClientIp,
                            m_pLogContext->QueryUlLogData()->ClientIpLength);
} // GetClientHostName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetClientUserName(IN PCHAR    pszClientUserName,
                                       IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszClientUserName,
                            pcbSize,
                            m_strUserName.QueryStr(),
                            m_strUserName.QueryCCH());
} // GetClientUserName


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetServerAddress(IN PCHAR    pszServerAddress,
                                      IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszServerAddress,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->ServerIp,
                            m_pLogContext->QueryUlLogData()->ServerIpLength);
} // GetServerIPAddress


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetOperation(IN PCHAR    pszOperation,
                                  IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszOperation,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->Method,
                            m_pLogContext->QueryUlLogData()->MethodLength);
} // GetOperation


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetTarget(IN PCHAR    pszTarget,
                               IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszTarget,
                            pcbSize,
                            m_strTarget.QueryStr(),
                            m_strTarget.QueryCCH());
} // GetTarget


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetParameters(IN PCHAR    pszParameters,
                                   IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszParameters,
                            pcbSize,
                            m_pLogContext->QueryUlLogData()->UriQuery,
                            m_pLogContext->QueryUlLogData()->UriQueryLength);
} // GetParameters


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetVersionString(
    IN PCHAR    pszVersionString,
    IN PDWORD   pcbSize
    )
{
    return ReturnStringInfo(pszVersionString,
                            pcbSize,
                            m_pLogContext->m_strVersion.QueryStr(),
                            m_pLogContext->m_strVersion.QueryCCH());
} //GetVersionString


LPSTR STDMETHODCALLTYPE
CInetLogInformation::GetExtraHTTPHeaders(IN PCHAR    pszHTTPHeaders,
                                         IN PDWORD   pcbSize)
{
    return ReturnStringInfo(pszHTTPHeaders,
                            pcbSize,
                            m_pLogContext->m_mszHTTPHeaders.QueryStr(),
                            m_pLogContext->m_mszHTTPHeaders.QueryCCH());
} // GetExtraHTTPHeaders



VOID
CInetLogInformation::CanonicalizeLogRecord(
        IN LOG_CONTEXT *pInetLogRecord)
{
    m_pLogContext = pInetLogRecord;

    HTTP_LOG_FIELDS_DATA *pUlLogData = pInetLogRecord->QueryUlLogData();

    if (pUlLogData->UriStem &&
        FAILED(m_strTarget.CopyW(pUlLogData->UriStem)))
    {
        m_strTarget.Reset();
    }

    if (pUlLogData->UserName &&
        FAILED(m_strUserName.CopyW(pUlLogData->UserName)))
    {
        m_strUserName.Reset();
    }

} // CanonicalizeLogRecord
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h	
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable

//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>

// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 

#define DEBUG_ODBC                 0x02000000L
#define DEBUG_DLL_MANAGER          0x80000000L

// end_user_modifiable

# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\dynodbc.cxx ===
/*++

Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    dynodbc.c

Abstract:

    This module provides functions for dynamically loading the ODBC
    functions.

Author:

    Murali R. Krishnan  (MuraliK)  3-Nov-1995

Revision History:

--*/

#include "precomp.hxx"

#define ODBC_MODULE_NAME                     "odbc32.dll"

#define LOAD_ENTRY( hMod, Name )             \
   ( p##Name = ( pfn##Name )GetProcAddress( ( hMod ), #Name ) )

//
//  ODBC DLL Entry Points, fill by calling LoadODBC
//

pfnSQLAllocConnect        pSQLAllocConnect   ;
pfnSQLAllocEnv            pSQLAllocEnv       ;
pfnSQLAllocStmt           pSQLAllocStmt      ;
pfnSQLBindCol             pSQLBindCol        ;
pfnSQLCancel              pSQLCancel         ;
pfnSQLColAttributes       pSQLColAttributes  ;
pfnSQLConnect             pSQLConnect        ;
pfnSQLDescribeCol         pSQLDescribeCol    ;
pfnSQLDisconnect          pSQLDisconnect     ;
pfnSQLError               pSQLError          ;
pfnSQLExecDirect          pSQLExecDirect     ;
pfnSQLExecute             pSQLExecute        ;
pfnSQLFetch               pSQLFetch          ;
pfnSQLFreeConnect         pSQLFreeConnect    ;
pfnSQLFreeEnv             pSQLFreeEnv        ;
pfnSQLFreeStmt            pSQLFreeStmt       ;
pfnSQLGetCursorName       pSQLGetCursorName  ;
pfnSQLNumResultCols       pSQLNumResultCols  ;
pfnSQLPrepare             pSQLPrepare        ;
pfnSQLRowCount            pSQLRowCount       ;
pfnSQLSetCursorName       pSQLSetCursorName  ;
pfnSQLTransact            pSQLTransact       ;

pfnSQLSetConnectOption    pSQLSetConnectOption;
pfnSQLDrivers             pSQLDrivers         ;
pfnSQLDataSources         pSQLDataSources     ;
pfnSQLBindParameter       pSQLBindParameter   ;
pfnSQLGetInfo             pSQLGetInfo        ;
pfnSQLMoreResults         pSQLMoreResults    ;

static BOOL               s_fODBCLoaded = FALSE;

BOOL
DynLoadODBC(
    VOID
    )
{
    HMODULE hMod;

    if( s_fODBCLoaded )
    {
        return TRUE;
    }

    if( ( hMod = ( HMODULE ) LoadLibraryA( ODBC_MODULE_NAME ) ) ) 
    {
        if( LOAD_ENTRY( hMod, SQLAllocConnect   )  &&
            LOAD_ENTRY( hMod, SQLAllocEnv       )  &&
            LOAD_ENTRY( hMod, SQLAllocStmt      )  &&
            LOAD_ENTRY( hMod, SQLBindCol        )  &&
            LOAD_ENTRY( hMod, SQLCancel         )  &&
            LOAD_ENTRY( hMod, SQLColAttributes  )  &&
            LOAD_ENTRY( hMod, SQLConnect        )  &&
            LOAD_ENTRY( hMod, SQLDescribeCol    )  &&
            LOAD_ENTRY( hMod, SQLDisconnect     )  &&
            LOAD_ENTRY( hMod, SQLError          )  &&
            LOAD_ENTRY( hMod, SQLExecDirect     )  &&
            LOAD_ENTRY( hMod, SQLExecute        )  &&
            LOAD_ENTRY( hMod, SQLFetch          )  &&
            LOAD_ENTRY( hMod, SQLFreeConnect    )  &&
            LOAD_ENTRY( hMod, SQLFreeEnv        )  &&
            LOAD_ENTRY( hMod, SQLFreeStmt       )  &&
            LOAD_ENTRY( hMod, SQLNumResultCols  )  &&
            LOAD_ENTRY( hMod, SQLPrepare        )  &&
            LOAD_ENTRY( hMod, SQLRowCount       )  &&
            LOAD_ENTRY( hMod, SQLTransact       )  &&
            LOAD_ENTRY( hMod, SQLSetConnectOption )  &&
            LOAD_ENTRY( hMod, SQLDrivers        )  &&
            LOAD_ENTRY( hMod, SQLDataSources    )  &&
            LOAD_ENTRY( hMod, SQLGetInfo        )  &&
            LOAD_ENTRY( hMod, SQLBindParameter  )  &&
            LOAD_ENTRY( hMod, SQLMoreResults    ) ) 
        {
            s_fODBCLoaded = TRUE;
        }
    }

    return ( s_fODBCLoaded );

} // DynLoadODBC()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\festrcnv.cxx ===
#include "precomp.hxx"

int PC_to_UNIX ( int CodePage, 
                 int CodeSet,
                 UCHAR *pPCChar, 
                 int PCChar_len,
                 UCHAR *pUNIXChar, 
                 int UNIXChar_len 
                 )

// The PC_to_UNIX function convert a character string as PC code
// set string to a UNIX code set string.
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from
//                      Operating System automatically.
//
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//
//                      Value           Meaning
//                      CODE_JPN_JIS    JIS Code Set. The function convert
//                                      pPCChar string
//                                      to a JIS code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert
//                                      pPCChar string
//                                      to a EUC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set.
//
// UCHAR *pPCChar       Points to the character string to be converted.
//
// int   PCChar_len     Specifies the size in bytes of the string pointed
//                      to by the pPCChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
//
// UCHAR *pUNIXChar     Points to a buffer that receives the convert string
//                      from PC Code to UNIX Code.
//
// int   UNIXChar_len   Specifies the size, in UNIX characters of the buffer
//                      pointed to by the pUNIXChar parameter. If the value is
//                      zero, the function returns the number of UNIX characters
//                      required for the buffer, and makes no use of the
//                      pUNIXChar buffer.
//
// Return Value
// If the function succeeds, and UNIXChar_len is nonzero, the return value is
// the number of UNIX characters written to the buffer pointed to by pUNIXChar.
//
// If the function succeeds, and UNIXChar_len is zero, the return value is the
// required size, in UNIX characters, for a buffer that can receive the
// converted string.
//
// If the function fails, the return value is -1. The error mean pUNIXChar
// buffer is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) 
        {
            CodePage = ( int )GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
//          re = PC_to_JPNUNIX ( CodeSet, 
//                               pPCChar, 
//                               PCChar_len,
//                               pUNIXChar, 
//                               UNIXChar_len );
//          break;
//      case ???:    // Taiwan Code Page
//          re = PC_to_TAIWANUNIX (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = PC_to_KOREAUNIX (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PC_to_PRCUNIX (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( PCChar_len == -1 ) 
            {
                PCChar_len = strlen ( ( CHAR * )pPCChar ) + 1;
            }
            if ( UNIXChar_len != 0 ) 
            {
                if ( PCChar_len > UNIXChar_len ) 
                {  
                    // Is the buffer small?
                    return ( -1 );
                }

                memmove ( pUNIXChar, pPCChar, PCChar_len );
            }
            re = PCChar_len;
            break;
        }
        return ( re );
}

int UNIX_to_PC ( 
    int CodePage, 
    int CodeSet,
    UCHAR *pUNIXChar, 
    int UNIXChar_len,
    UCHAR *pPCChar, 
    int PCChar_len 
    )

// The UNIX_to_PC function convert a character string as UNIX code 
// set string to a PC code set string. 
//
// int   CodePage       Country Code Page.
//                      If this value is -1, the function use OS CodePage from 
//                      Operating System automatically.
//                      
//                      Value           Meaning
//                      -1              Auto Detect Mode.
//                      932             Japan.
//                      ???             Taiwan.
//                      ???             Korea.
//                      ???             PRC(Chaina)?
//                      
// int   CodeSet        Code Set Type.
//                      There are three Japanese Code set in UNIX world.
//                      These code sets are JIS, EUC and Shift JIS.
//                      When CodePage is Japanese, the following Code set
//                      constants are defined:
//                      
//                      Value           Meaning
//                      CODE_UNKNOWN    Unknown. If this value is CODE_UNKNOWN,
//                                      Code Type is checked automatically. 
//                                      
//                      CODE_JPN_JIS    JIS Code Set. The function convert 
//                                      pUNIXChar string as JIS code set string
//                                      to a PC code set string.
//                      CODE_JPN_EUC    EUC Code Set. The function convert 
//                                      pUNIXChar string as EUC code set string
//                                      to a PC code set string.
//                      CODE_JPN_SJIS   Shift JIS Code Set. 
//
// UCHAR *pUNIXChar     Points to the character string to be converted.
//
// int   UNIXChar_len   Specifies the size in bytes of the string pointed
//                      to by the pUNIXChar parameter. If this value is -1,
//                      the string is assumed to be NULL terminated and the
//                      length is calculated automatically.
//
// UCHAR *pPCChar       Points to a buffer that receives the convert string
//                      from UNIX Code to PC Code.
//         
// int   PCChar_len     Specifies the size, in PC characters of the buffer
//                      pointed to by the pPCChar parameter. If the value is zero,
//                      the function returns the number of PC characters 
//                      required for the buffer, and makes no use of the pPCChar
//                      buffer.
//
// Return Value
// If the function succeeds, and PCChar_len is nonzero, the return value is the 
// number of PC characters written to the buffer pointed to by pPCChar.
//
// If the function succeeds, and PCChar_len is zero, the return value is the
// required size, in PC characters, for a buffer that can receive the 
// converted string.
//
// If the function fails, the return value is -1. The error mean pPCChar buffer
// is small for setting converted strings.
//
//@
{
        int     re;

        if ( CodePage == -1 ) {
            CodePage = (int)GetOEMCP();
        }
        switch ( CodePage ) {
        case 932:    // Japanese Code Page
//            re = JPNUNIX_to_PC ( CodeSet, pUNIXChar, UNIXChar_len,
//                                           pPCChar, PCChar_len );
//            break;
//      case ???:    // Taiwan Code Page
//          re = TAIWANUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // Korea Code Page
//          re = KOREAUNIX_to_PC (,,,,,,);
//          break;
//      case ???:    // PRC Code Page
//          re = PRCUNIX_to_PC (,,,,,,);
//          break;
        default:
            // Start Only Copy Process
            if ( UNIXChar_len == -1 ) 
            {
                UNIXChar_len = strlen ( ( CHAR * )pUNIXChar ) + 1;
            }
            if ( PCChar_len != 0 ) 
            {
                if ( UNIXChar_len > PCChar_len ) 
                {  
                    // Is the buffer small?
                    return ( -1 );
                }

                memmove ( pPCChar, pUNIXChar, UNIXChar_len );
            }
            re = UNIXChar_len;
            break;
        }
        return ( re );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\main.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    This is the HTTP ODBC gateway

Author:

    John Ludeman (johnl)   20-Feb-1995

Revision History:
	Tamas Nemeth (t-tamasn)  12-Jun-1998

--*/

//
//  System include files.
//

#include "precomp.hxx"
#include "iadmw.h"
#include <ole2.h>
#include <lmcons.h>

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );

}

//
//  Globals
//

IMSAdminBase *  g_pMetabase = NULL;

//
// Is this system DBCS?
//
BOOL           g_fIsSystemDBCS;        

//
//  Prototypes
//

HRESULT
ODBCInitialize(
    VOID
    );

VOID
ODBCTerminate(
    VOID
    );

HRESULT
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STRA *                    pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    );


DWORD
OdbcExtensionOutput(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput
    );

BOOL
OdbcExtensionHeader(
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders
    );

BOOL LookupHttpSymbols(  // eliminated, check its functionality
    const CHAR *   pszSymbolName,
    STRA *         pstrSymbolValue
    );


HRESULT
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STRA *         pstrError
    );

HRESULT
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STRA *          pstrParams
    );

BOOL
IsSystemDBCS(
    VOID
    );

CHAR * 
FlipSlashes( 
	CHAR * pszPath 
	);

HRESULT
GetPoolIDCTimeout(
    unsigned char * szMdPath,
    DWORD *         pdwPoolIDCTimeout
    );

DWORD
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    STACK_STRA(     strPath, MAX_PATH);
    STACK_STRA(     strParams, MAX_PATH);
    STRA            strError;
    CHAR *          pch;
    DWORD           cch;
    int             nCharset;
    HRESULT         hr;

	
	//
    //  Make sure ODBC is loaded
    //

    if ( !LoadODBC() )
    {
        STRA str;

        str.FormatString( ODBCMSG_CANT_LOAD_ODBC,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction( pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "500 Unable to load ODBC",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        return HSE_STATUS_ERROR;
    }

    //
    //  We currently only support the GET and POST methods
    //

    if ( !strcmp( pecb->lpszMethod, "POST" ))
    {
        if ( _stricmp( pecb->lpszContentType,
                       "application/x-www-form-urlencoded" ) )
        {
            goto BadRequest;
        }

        //
        //  The query params are in the extra data, add a few bytes in 
        //  case we need to double "'"
        //

        hr = strParams.Resize( pecb->cbAvailable + sizeof(TCHAR) + 3);
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error resizing param buffer, hr = 0x%x.\n",
                hr ));

            return HSE_STATUS_ERROR;
        }

        hr = strParams.Copy( ( const char * ) pecb->lpbData, 
                             pecb->cbAvailable );
    }
    else if ( !strcmp( pecb->lpszMethod, "GET" ) )
    {
        hr = strParams.Copy( pecb->lpszQueryString );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying params, hr = 0x%x.\n",
                hr ));

            return HSE_STATUS_ERROR;
        }
    }
    else
    {
BadRequest:

        STRA str;

        str.FormatString( ODBCMSG_UNSUPPORTED_METHOD,
                          NULL,
                          HTTP_ODBC_DLL );

        pecb->ServerSupportFunction(
                            pecb->ConnID,
                            HSE_REQ_SEND_RESPONSE_HEADER,
                            "400 Unsupported method",
                            NULL,
                            (LPDWORD) str.QueryStr() );

        return HSE_STATUS_ERROR;
    }

    //
    //  "Charset" field is enabled for CP932 (Japanese) only in 
    //  this version.
    //

    if ( 932 != GetACP() )
    {
        nCharset = CODE_ONLY_SBCS;
    }
    else
    {
        //
        //  Get the charset from .idc file
        //

        if ( FAILED( GetIDCCharset( pecb->lpszPathTranslated, 
                                    &nCharset, 
                                    &strError ) ) )
        {
            STRA str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( 
                               pecb->ConnID,
                               HSE_REQ_SEND_RESPONSE_HEADER,
                               (LPDWORD) "500 Error performing query",
                               NULL,
                               (LPDWORD) str.QueryStr() );

            return HSE_STATUS_ERROR;
        }

        if ( strParams.QueryCB() )
        {
            if ( CODE_ONLY_SBCS != nCharset )
            {
                //
                //  Convert the charset of Parameters to SJIS
                //

                if ( FAILED( ConvertUrlEncodedStringToSJIS( 
                                                    nCharset, 
                                                    &strParams ) ) )
                {
                    STRA str;

                    strError.LoadString( GetLastError(), 
                                         ( LPCSTR ) NULL );

                    str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                                      NULL,
                                      HTTP_ODBC_DLL );

                    pecb->ServerSupportFunction( 
                                pecb->ConnID,
                                HSE_REQ_SEND_RESPONSE_HEADER,
                                (LPDWORD) "500 Error performing Query",
                                NULL,
                                (LPDWORD) str.QueryStr() );

                    return HSE_STATUS_ERROR;
                }
            }
        }
    }

    //
    //  Walk the parameter string to do three things:
    //
    //    1) Double all single quotes to prevent SQL quoting problem
    //    2) Remove escaped '\n's so we don't break parameter parsing 
    //       later on
    //    3) Replace all '&' parameter delimiters with real '\n' so 
    //       escaped '&'s won't get confused later on
    //

    pch = strParams.QueryStr();
    cch = strParams.QueryCCH();

    while ( *pch )
    {
        switch ( *pch )
        {
        case '%':
            if ( pch[1] == '0' && toupper(pch[2]) == 'A' )
            {
                pch[1] = '2';
                pch[2] = '0';
            }
            else if ( pch[1] == '2' && pch[2] == '7' )
            {
                //
                //  This is an escaped single quote
                //

                // Include null
                if ( strParams.QueryCB() < (cch + 4) )  
                {
                    DWORD Pos = DIFF(pch - strParams.QueryStr());

                    hr = strParams.Resize( cch + 4 );
                    if ( FAILED( hr ) )
                    {
                        return HSE_STATUS_ERROR;
                    }

                    //
                    //  Adjust for possible pointer shift
                    //

                    pch = strParams.QueryStr() + Pos;
                }

                //
                //  Note the memory copy just doubles the existing 
                //  quote
                //

                memmove( pch+3,
                         pch,
                         (cch + 1) - DIFF(pch - strParams.QueryStr()) );

                // Adjust for the additional '%27'
                cch += 3;          
                pch += 3;
            }

            pch += 3;
            break;

        case '\'':
            if ( strParams.QueryCB() < (cch + 2) )
            {
                DWORD Pos = DIFF(pch - strParams.QueryStr());

                hr = strParams.Resize( cch + 2 );
                if ( FAILED( hr ) )
                {
                    return HSE_STATUS_ERROR;
                }

                //
                //  Adjust for possible pointer shift
                //

                pch = strParams.QueryStr() + Pos;
            }

            //
            //  Note the memory copy just doubles the existing quote
            //

            memmove( pch+1,
                     pch,
                     (cch + 1) - DIFF(pch - strParams.QueryStr()) );

            pch += 2;
            
            // Adjust for the additional '''
            cch++;          
            
            break;

        case '&':
            *pch = '\n';
            pch++;
            break;

        default:
            pch++;
        }
    }

    //
    //  The path info contains the location of the query file
    //

    hr = strPath.Copy( pecb->lpszPathTranslated );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying query file path, hr = 0x%x.\n",
            hr ));

        return HSE_STATUS_ERROR;
    }

    FlipSlashes( strPath.QueryStr() );

    //
    //  Attempt the query
    //

    BOOL fAccessDenied = FALSE;

    hr = DoQuery( pecb,
                  strPath.QueryStr(),
                  strParams.QueryStr(),
                  &strError,
                  nCharset,
                  &fAccessDenied );
    if ( FAILED( hr ) )
    {
        if ( fAccessDenied )
        {
            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "401 Authentication Required",
                     NULL,
                     NULL );

            return HSE_STATUS_ERROR;
        }
        else
        {
            STRA str;
            LPCSTR apsz[1];

            apsz[0] = strError.QueryStr();

            //
            //  Note we terminate the error message (ODBC sometimes generates
            //  22k errors) *and* we double the buffer size we pass to FormatString()
            //  because the win32 API FormatMessage() has a bug that doesn't
            //  account for Unicode conversion
            //

            if ( strlen( apsz[0] ) > 1024 ) {
                ((LPSTR)apsz[0])[1024] = '\0';
            }

            str.FormatString( ODBCMSG_ERROR_PERFORMING_QUERY,
                              apsz,
                              HTTP_ODBC_DLL,
                              1024 + strError.QueryCB() );

            pecb->ServerSupportFunction( pecb->ConnID,
                     HSE_REQ_SEND_RESPONSE_HEADER,
                     (LPDWORD) "500 Error performing query",
                     NULL,
                     (LPDWORD) str.QueryStr() );

            return HSE_STATUS_ERROR;
        }
    }

    return HSE_STATUS_SUCCESS;
}

HRESULT
DoQuery(
    EXTENSION_CONTROL_BLOCK * pecb,    
    const CHAR *              pszQueryFile,
    const CHAR *              pszParamList,
    STRA *                    pstrError,
    int                       nCharset,
    BOOL *                    pfAccessDenied
    )
/*++

Routine Description:

    Performs the actual query or retrieves the same query from the 
    query cache

Arguments:

    pecb - Extension context
    pTsvcInfo - Server info class
    pszQueryFile - .wdg file to use for query
    pszParamList - Client supplied param list
    pstrError - Error text to return errors in
    pfAccessDenied - Set to TRUE if the user was denied access

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    ODBC_REQ *              podbcreq;
    STACK_STRA(             strHeaders, MAX_PATH );
    CHAR                    achPragmas[250];
    DWORD                   cbPragmas = sizeof(achPragmas);
    CHAR                    achInstanceMetaPath[ MAX_PATH ];
    DWORD                   dwInstanceMetaPath = 
                              sizeof( achInstanceMetaPath );
    CHAR                    achURL[ MAX_PATH ];
    DWORD                   dwURL = sizeof( achURL );
    STACK_STRA(             strMetaPath, MAX_PATH );
    DWORD                   dwPoolIDCTimeout;
    DWORD                   dwRequiredLen;

    //
    // Get the metapath for the current request
    //
    if( !pecb->GetServerVariable( pecb->ConnID,
                                  "INSTANCE_META_PATH",
                                  achInstanceMetaPath,
                                  &dwInstanceMetaPath ) ||
        !pecb->GetServerVariable( pecb->ConnID,
                                  "URL",
                                  achURL,
                                  &dwURL ) )
    {
        return E_FAIL;
    }

    hr = strMetaPath.Copy( achInstanceMetaPath, dwInstanceMetaPath - 1 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying InstanceMetaPath, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strMetaPath.Append( "/Root" );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending metapath, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strMetaPath.Append( achURL, dwURL - 1 );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending URL, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    // Get the HTTPODBC metadata PoolIDCTimeout
    //    

    hr = GetPoolIDCTimeout( ( unsigned char * )strMetaPath.QueryStr(),
                            &dwPoolIDCTimeout );
    if( FAILED( hr ) )
    {
        dwPoolIDCTimeout = IDC_POOL_TIMEOUT;
    }

    //
    //  Create an odbc request as we will either use it for the query 
    //  or as the key for the cache lookup
    //	
	
	podbcreq = new ODBC_REQ( pecb,
                             dwPoolIDCTimeout,
                             nCharset );

    if( !podbcreq )
    {
        pstrError->LoadString( ERROR_NOT_ENOUGH_MEMORY );
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hr = podbcreq->Create( pszQueryFile, pszParamList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error creating ODBC_REQ object, hr = 0x%x.\n",
            hr ));

        // Best effort
        pstrError->LoadString( GetLastError() );

        delete podbcreq;
        podbcreq = NULL;

        return hr;
    }

    //
    //  Check to see if user already authentified
    //

    CHAR  achLoggedOnUser[UNLEN + 1];
    DWORD dwLoggedOnUser = sizeof( achLoggedOnUser );
    BOOL  fIsAuth = pecb->GetServerVariable( (HCONN)pecb->ConnID,
                                             "LOGON_USER",
                                             achLoggedOnUser,
                                             &dwLoggedOnUser ) &&
                                             achLoggedOnUser[0] != '\0';

    //
    //  Check to see if the client specified "Pragma: no-cache"
    //
    /* We don't do cache on HTTPODBC any more
    if ( pecb->GetServerVariable( pecb->ConnID,
                                  "HTTP_PRAGMA",
                                  achPragmas,
                                  &cbPragmas ))
    {
        CHAR * pch;

        //
        //  Look for "no-cache"
        //

        pch = _strupr( achPragmas );

        while ( pch = strchr( pch, 'N' ))
        {
            if ( !memcmp( pch, "NO-CACHE", 8 ))
            {
                fRetrieveFromCache = FALSE;
                goto Found;
            }

            pch++;
        }
    }*/

    //
    //  Open the query file and do the query
    //

    hr = podbcreq->OpenQueryFile( pfAccessDenied );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error opening query file, hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

    hr = podbcreq->ParseAndQuery( achLoggedOnUser );
    if( FAILED( hr ) )
    {
        goto Exit;
    }

    hr = podbcreq->AppendHeaders( &strHeaders );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error appending headers, hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

    hr = podbcreq->OutputResults( (ODBC_REQ_CALLBACK)OdbcExtensionOutput,
                                   pecb, &strHeaders,
                                   (ODBC_REQ_HEADER)OdbcExtensionHeader,
                                   fIsAuth,
                                   pfAccessDenied );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error in OutputResults(), hr = 0x%x.\n",
            hr ));

        goto Exit;
    }

	delete podbcreq;
	podbcreq = NULL;
    
	return S_OK;

Exit:

    //
	// Get the ODBC error to report to client 
	//
	podbcreq->GetLastErrorText( pstrError );
    
    delete podbcreq;
    podbcreq = NULL;
    
    return hr;
}


DWORD 
OdbcExtensionOutput( 
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchOutput,
    DWORD                     cbOutput 
    )
{
    if ( !pecb->WriteClient( pecb->ConnID,
                             (VOID *) pchOutput,
                             &cbOutput,
                             0 ))

    {
        return GetLastError();
    }

    return NO_ERROR;
}


BOOL 
OdbcExtensionHeader( 
    EXTENSION_CONTROL_BLOCK * pecb,
    const CHAR *              pchStatus,
    const CHAR *              pchHeaders 
    )
{
    return pecb->ServerSupportFunction(
                pecb->ConnID,
                HSE_REQ_SEND_RESPONSE_HEADER,
                (LPDWORD) "200 OK",
                NULL,
                (LPDWORD) pchHeaders );
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    DWORD  err;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( "httpodbc.dll");
        SET_DEBUG_FLAGS( 0 );

        DisableThreadLibraryCalls( hDll );
        break;

    case DLL_PROCESS_DETACH:

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }

    return TRUE;
}

BOOL
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    HRESULT hr;
    pver->dwExtensionVersion = MAKELONG( 0, 3 );
    strcpy( pver->lpszExtensionDesc,
            "Microsoft HTTP ODBC Gateway, v3.0" );

    hr = ODBCInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error on HTTPODBC initialization." ));

        SetLastError( hr );

        return FALSE;
    }

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&g_pMetabase
        );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error getting IMSAdminBase interface." ));

        SetLastError( hr );

        ODBCTerminate();

        return FALSE;
    }

    return TRUE;
}

BOOL
TerminateExtension(
    DWORD   dwFlags
    )
{
    ODBCTerminate();

    if ( g_pMetabase )
    {
        g_pMetabase->Release();
        g_pMetabase = NULL;
    }

    return TRUE;
}

HRESULT 
ODBCInitialize(
    VOID
    )
{
    HRESULT  hr = E_FAIL;

    if( !InitializeOdbcPool() )
    {
        return hr;
    }

    hr = ODBC_REQ::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_REQ, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        return hr;
    }

    hr = ODBC_STATEMENT::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_STATEMENT, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        ODBC_REQ::Terminate();
        return hr;
    }

    hr = ODBC_CONN_POOL::Initialize();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error initializing ODBC_CONN_POOL, hr = 0x%x.\n",
            hr ));

        TerminateOdbcPool();
        ODBC_REQ::Terminate();
        ODBC_STATEMENT::Terminate();
        return hr;
    }

    g_fIsSystemDBCS = IsSystemDBCS();
    
    return hr;
}

VOID
ODBCTerminate(
    VOID
    )
{
    TerminateOdbcPool();
    ODBC_REQ::Terminate();
    ODBC_STATEMENT::Terminate();
    ODBC_CONN_POOL::Terminate();
}

CHAR * skipwhite( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        if ( ' ' != ch && '\t' != ch )
            break;
        ++pch;
    }

    return pch;
}


CHAR * nextline( CHAR * pch )
{
    CHAR ch;

    while ( 0 != (ch = *pch) )
    {
        ++pch;

        if ( '\n' == ch )
        {
            break;
        }
    }

    return pch;
}


HRESULT
GetIDCCharset(
    CONST CHAR *   pszPath,
    int *          pnCharset,
    STRA *         pstrError
    )
{
    BUFFER           buff;
    HANDLE           hFile;
    DWORD            dwSize;
    HRESULT          hr;
    DWORD            dwErr;

#define QUERYFILE_READSIZE  4096

    if ( (!pnCharset)  ||  (!pszPath) )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    *pnCharset = CODE_ONLY_SBCS;

    if ( !buff.Resize( QUERYFILE_READSIZE + sizeof(TCHAR) ) )
    {
        pstrError->LoadString( ERROR_NOT_ENOUGH_MEMORY );
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hFile = CreateFileA( pszPath,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL | 
                         FILE_FLAG_SEQUENTIAL_SCAN,
                         NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
    {
        LPCSTR apsz[1];

        apsz[0] = pszPath;
        pstrError->FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               HTTP_ODBC_DLL );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    if ( !ReadFile( hFile, 
                    buff.QueryPtr(), 
                    QUERYFILE_READSIZE, 
                    &dwSize, 
                    NULL ) )
    {
        dwErr = GetLastError();
        pstrError->LoadString( dwErr );
        return HRESULT_FROM_WIN32( dwErr );
    }

    CloseHandle( hFile );

    *((CHAR *) buff.QueryPtr() + dwSize) = '\0';

    CHAR * pch = (CHAR *)buff.QueryPtr();  

    while ( *pch )
    {
        pch = skipwhite( pch );

        if ( 'C' == toupper( *pch ) && 
              !_strnicmp( IDC_FIELDNAME_CHARSET, 
                          pch, 
                          sizeof(IDC_FIELDNAME_CHARSET)-1 ) )
        {
            pch += sizeof(IDC_FIELDNAME_CHARSET) - 1;
            pch = skipwhite( pch );
            if ( 932 == GetACP() )
            {
                if ( !_strnicmp( IDC_CHARSET_JIS1, 
                                 pch, 
                                 sizeof(IDC_CHARSET_JIS1)-1 ) ||
                     !_strnicmp( IDC_CHARSET_JIS2, 
                                 pch, 
                                 sizeof(IDC_CHARSET_JIS2)-1 ) )
                {
                    *pnCharset = CODE_JPN_JIS;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_EUCJP, 
                                      pch, 
                                      sizeof(IDC_CHARSET_EUCJP)-1 ) )
                {
                    *pnCharset = CODE_JPN_EUC;
                    break;
                }
                else if ( !_strnicmp( IDC_CHARSET_SJIS, 
                                      pch, 
                                      sizeof(IDC_CHARSET_SJIS)-1 ) )
                {
                    *pnCharset = CODE_ONLY_SBCS;
                    break;
                }
                else
                {
                    LPCSTR apsz[1];
                    //
                    //  illegal value for Charset: field
                    //
                    apsz[0] = pszPath;
                    pstrError->FormatString( ODBCMSG_UNREC_FIELD,
                                             apsz,
                                             HTTP_ODBC_DLL );
                    return E_FAIL;
                }
            }

//
//          please add code here to support other FE character encoding(FEFEFE)
//
//          else if ( 949 == GetACP() )
//          ...

        }
        pch = nextline( pch );
    }

    return S_OK;
}

HRESULT
ConvertUrlEncodedStringToSJIS(
    int            nCharset,
    STRA *         pstrParams
    )
{
    STACK_STRA( strTemp, MAX_PATH);
    int         cbSJISSize;
    int         nResult;
    HRESULT     hr;

    //
    //  Pre-process the URL encoded parameters
    //

    for ( char * pch = pstrParams->QueryStr(); *pch; ++pch )
    {
        if ( *pch == '&' )
        {
            *pch = '\n';
        }
        else if ( *pch == '+' )
        {
            *pch = ' ';
        }
    }

    //
    //  URL decoding (decode %nn only)
    //

    hr = pstrParams->Unescape();
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error unescaping param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    //  charset conversion
    //

    hr = pstrParams->Clone( &strTemp );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error cloning param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    hr = strTemp.Copy( pstrParams->QueryStr() );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    cbSJISSize = UNIX_to_PC( GetACP(),
                             nCharset,
                             (UCHAR *)strTemp.QueryStr(),
                             strTemp.QueryCB(),
                             NULL,
                             0 );

    hr = pstrParams->Resize( cbSJISSize + sizeof(TCHAR) );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error resizing param string buffer, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    nResult = UNIX_to_PC( GetACP(),
                          nCharset,
                          (UCHAR *)strTemp.QueryStr(),
                          strTemp.QueryCB(),
                          (UCHAR *)pstrParams->QueryStr(),
                          cbSJISSize );
    if ( -1 == nResult || nResult != cbSJISSize )
    {
        return E_FAIL;
    }

    DBG_REQUIRE ( pstrParams->SetLen( cbSJISSize) );

    //
    //  URL encoding
    //

    hr = pstrParams->Escape();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error escaping param string, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return S_OK;
}

BOOL
IsSystemDBCS(
    VOID 
    )
{
    WORD wPrimaryLangID = PRIMARYLANGID( GetSystemDefaultLangID() );

    return ( wPrimaryLangID == LANG_JAPANESE ||
             wPrimaryLangID == LANG_CHINESE  ||
             wPrimaryLangID == LANG_KOREAN );
}

CHAR * FlipSlashes( CHAR * pszPath )
{
    CHAR   ch;
    CHAR * pszScan = pszPath;

    while( ( ch = *pszScan ) != '\0' )
    {
        if( ch == '/' )
        {
            *pszScan = '\\';
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes

HRESULT
GetPoolIDCTimeout(
    unsigned char * szMdPath,
    DWORD *         pdwPoolIDCTimeout
    )
{
    HRESULT         hr = NOERROR;
    DWORD           cbBufferRequired;

    const DWORD     dwTimeout = 2000;

    STACK_STRU(     strMetaPath, MAX_PATH );

    if ( g_pMetabase == NULL )
    {
        return E_NOINTERFACE;
    }

    hr = strMetaPath.CopyA( (LPSTR)szMdPath );
    if( FAILED(hr) )
    {
        return hr;
    }
    
    METADATA_HANDLE     hKey = NULL;
    METADATA_RECORD     MetadataRecord;

    hr = g_pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                               strMetaPath.QueryStr(),
                               METADATA_PERMISSION_READ,
                               dwTimeout,
                               &hKey
                               );

    if( SUCCEEDED(hr) )
    {
        MetadataRecord.dwMDIdentifier = MD_POOL_IDC_TIMEOUT;
        MetadataRecord.dwMDAttributes = METADATA_INHERIT;
        MetadataRecord.dwMDUserType = IIS_MD_UT_FILE;
        MetadataRecord.dwMDDataType = DWORD_METADATA;
        MetadataRecord.dwMDDataLen = sizeof( DWORD );
        MetadataRecord.pbMDData = (unsigned char *) pdwPoolIDCTimeout;
        MetadataRecord.dwMDDataTag = 0;

        hr = g_pMetabase->GetData( hKey,
                                   L"",
                                   &MetadataRecord,
                                   &cbBufferRequired
                                   );

        g_pMetabase->CloseKey( hKey );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcconn.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       odbcconn.cxx

   Abstract:

       This module defines member functions for ODBC_CONNECTION object.

   Author:

       Murali R. Krishnan    ( MuraliK )     16-Feb-1995

   Environment:

       User Mode - Win32.

   Project:

       Internet Services Common DLL

   Functions Exported:

       ODBC_PARAMETER::CopyValue( IN LPCWSTR pwszValue);
       ODBC_PARAMETER::Bind( IN HSTMT hstmt);

       ODBC_STATEMENT::~ODBC_STATEMENT()
       ODBC_STATEMENT::PrepareStatement( IN LPCSTR  pszStatement)
       ODBC_STATEMENT::PrepareStatement( IN LPCWSTR pwszStatement)
       ODBC_STATEMENT::BindParameter( IN PODBC_PARAMETER pOdbcParam)
       ODBC_STATEMENT::ExecuteStatement( VOID)
       ODBC_STATEMENT::ExecDirect( IN LPCSTR pwszSqlCommand,  IN DWORD cch)
       ODBC_STATEMENT::ExecDirect( IN LPCWSTR pwszSqlCommand, IN DWORD cch)
       ODBC_STATEMENT::QueryColNames( OUT STRA * *  apstrCols,
                                      OUT DWORD *  cCols,
                                      IN  DWORD    cchMaxFieldSize = 0 );
       ODBC_STATEMENT::QueryValuesAsStr( OUT STR * *   apstrValues,
                                         OUT DWORD * * apcbValues,
                                         OUT BOOL *    pfLast );


       ODBC_CONNECTION::~ODBC_CONNECTION();
       ODBC_CONNECTION::Open();
       ODBC_CONNECTION::Close();
       ODBC_CONNECTION::GetLastErrorCode();
       ODBC_CONNECTION::AllocStatement();


   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "precomp.hxx"

#define TCP_ALLOC(cb)             (VOID *)LocalAlloc( LPTR, cb ) 
#define TCP_FREE(p)               LocalFree( (HLOCAL) p )

//
// Since the ODBC does not support UNICODE APIs, we convert unicode to 
// ANSI to call the APIs. This will have to go away once we find some 
// other better way to do manage the same
//

//
//  Constants for display widths
//

#define MAX_NUM_PRECISION         15

//
//  Constant for all non string and non binary data.  40 is chosen to 
//  account for things such as Oracle's numeric types, which can have 
//  up to 38 digits of precision
//

#define MAX_NONCHAR_DATA_LEN      40

//
//  If no default maximum field size is specified, then use this value
//  as the maximum
//

#define DEFAULT_MAX_FIELD_SIZE    8192

ALLOC_CACHE_HANDLER *   ODBC_STATEMENT::sm_pachOdbcStatements;

/************************************************************
 *  Local Functions
 ************************************************************/

static 
inline 
VOID
CheckAndPrintErrorMessage( 
    IN ODBC_CONNECTION * poc,
    IN RETCODE           rc
    )
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STRA str;
        poc->GetLastErrorText( &str, NULL, rc );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()


static inline VOID
CheckAndPrintErrorMessage( 
    IN ODBC_STATEMENT * pos,
    IN RETCODE rc)
{

# if DBG
    if ( !ODBC_CONNECTION::Success( rc))  {

        STRA str;
        pos->GetLastErrorText( &str );

        DBGPRINTF( ( DBG_CONTEXT,
                    "ODBC Error Code( %d). Text: %s\n",
                    rc,
                    str.QueryStr() ));
    }
# endif // DBG

    return;

} // CheckAndPrintErrorMessage()

# if DBG

static VOID
PrintMultiString( 
    IN char * pszMsg, 
    IN DWORD cbLen, 
    IN char * pmsz
    )
{

    DBGPRINTF( ( DBG_CONTEXT,
                "Values of %s. %d bytes.\n", pszMsg, cbLen));
    for( char * psz = pmsz; 
         *psz != '\0'; 
         psz += (strlen( psz) + 1)) 
    {

        DBGPRINTF( ( DBG_CONTEXT, "%s\n", psz));
    }

    return;
} // PrintMultiString()

static VOID
AuxOdbcFunctions( IN HENV henv, IN HDBC hdbc)
/*++

  Function useful in walking throug a few additional ODBC functions
    to find out the ODBC setup information.
  Not to be part of the shipped code. Useful for development purposes.
  - MuraliK
--*/
{
    RETCODE rc;

    //
    // Set the trace file to a standard file.
    //
    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACE, SQL_OPT_TRACE_ON);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    rc = pSQLSetConnectOption( hdbc, SQL_OPT_TRACEFILE,
                     ( SQLULEN )"%systemroot%\\system32\\gophsql.log" );
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    UCHAR szDriverDesc[ 300];
    UCHAR szDriverAttrib[ 300];
    SWORD cbDD = 300;
    SWORD cbDA = 300;
    SWORD cbDDCur = 0;
    SWORD cbDACur = 0;

    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    rc = pSQLDrivers( henv, SQL_FETCH_FIRST,
                    szDriverDesc, cbDD, &cbDDCur,
                    szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDrivers( %08x) ==> RetCode = %d."
                " Driver Desc. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Driver Attributes", 
                      cbDACur, 
                      (char *) szDriverAttrib);


    szDriverDesc[0] = szDriverAttrib[0] = '\0';
    cbDDCur = cbDACur = 0;
    rc = pSQLDataSources( henv, SQL_FETCH_FIRST,
                          szDriverDesc, cbDD, &cbDDCur,
                          szDriverAttrib, cbDA, &cbDACur);
    DBG_ASSERT( ODBC_CONNECTION::Success( rc));

    DBGPRINTF( ( DBG_CONTEXT,
                " SQLDataSources( %08x) ==> RetCode = %d."
                " Data Sources. = ( %d bytes) %s. ",
                henv, rc, cbDDCur, szDriverDesc));
    PrintMultiString( " Data Source Description", cbDACur,
                     (char *) szDriverAttrib);

    return;
} // AuxOdbcFunctions()

# endif // DBG

/************************************************************
 *    Member Functions of ODBC_PARAMETER
 ************************************************************/

HRESULT
ODBC_PARAMETER::CopyValue( 
    IN LPCWSTR  pwszValue
    )
/*++
  Description:
    This function copies the given Unicode string as the value 
    into current parameter marker to be used for future insertion.

  Arguments:
    pwszValue - pointer to null-terminated string containing 
                Unicode value to be copied into the parameter 
                marker.

  Returns:
    TRUE on success and FALSE if there is any error.

  Note:
    Since ODBC does not support Unicode directly right now, we 
    convert string value to be ANSI before copying the value over.
--*/
{
    HRESULT hr;
    STRA    strValue;

    hr = strValue.CopyW( pwszValue );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying data, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return this->CopyValue( strValue.QueryStr() );

} // ODBC_PARAMETER::CopyValue()

HRESULT
ODBC_PARAMETER::CopyValue( 
    IN LPSYSTEMTIME lpst
    )
/*++
  Description:
    This function copies the given system time into the ODBC 
    timestamp structure for the current parameter marker to be 
    used for future insertion.

  Arguments:
    lpSystemTime - pointer to System Time structure containing 
                   current time.

  Returns:
    TRUE on success and FALSE if there is any error.

--*/
{
    TIMESTAMP_STRUCT * ptsOdbc;

    DBG_ASSERT( lpst != NULL);
    DBG_ASSERT( m_CType == SQL_C_TIMESTAMP);
    DBG_ASSERT( m_SqlType == SQL_TIMESTAMP);
    DBG_ASSERT( m_cbValueMax >= sizeof(TIMESTAMP_STRUCT));

    ptsOdbc = ( TIMESTAMP_STRUCT * ) m_pValue;

    DBG_ASSERT( m_pValue != NULL);

    //
    // Copy the individual fields over properly
    // The types used in ODBC/Win32 are different
    //  So do a type specific copy of the values.
    //

    ptsOdbc->year   = (SWORD ) lpst->wYear;
    ptsOdbc->month  = (UWORD ) lpst->wMonth;
    ptsOdbc->day    = (UWORD ) lpst->wDay;
    ptsOdbc->hour   = (UWORD ) lpst->wHour;
    ptsOdbc->minute = (UWORD ) lpst->wMinute;
    ptsOdbc->second = (UWORD ) lpst->wSecond;
    ptsOdbc->fraction = (UDWORD ) lpst->wMilliseconds;

    return S_OK;

} // ODBC_PARAMETER::CopyValue()

RETCODE
ODBC_PARAMETER::Bind( 
    IN HSTMT hStmt
    )
/*++
  Description:

    This functions binds the data about the parameter marker 'this'
     ( this object) represents to the statement provided.

  Arguments:
    hStmt        HANDLE for the statement to which this parameter
                  is to be bound.

  Returns:
    RETCODE value returned by SQLBindParamater().
--*/
{
    RETCODE  rc;
    DBG_ASSERT( hStmt != SQL_NULL_HSTMT);

    rc = pSQLBindParameter( hStmt,              // statement
                            QueryParamNumber(),
                            QueryParamType(),
                            QueryCType(),
                            QuerySqlType(),
                            QueryPrecision(),
                            QueryScale(),
                            QueryValue(),
                            QueryMaxCbValue(),
                            &(QueryCbValueRef())
                            );

    return ( rc);

} // ODBC_STATEMENT::BindParameter()

# if DBG

VOID
ODBC_PARAMETER::Print( 
    VOID
    ) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_PARAMETER ( %08x).\n"
                " Num=%u; Type=%d; CType=%d; SqlType=%d; Prec=%u;"
                " Scale=%d; CbMax=%d; Cb=%d.\n",
                this,
                QueryParamNumber(),
                QueryParamType(),
                QueryCType(),
                QuerySqlType(),
                QueryPrecision(),
                QueryScale(),
                QueryMaxCbValue(),
                QueryCbValue()));

    switch ( QuerySqlType() ) 
    {
      case SQL_INTEGER:
        {    
            DWORD  dwValue = *(DWORD *) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, 
                       " Integer Value = %u\n", 
                       dwValue ) );
            break;
        }
      case SQL_CHAR:
        {
            LPCSTR pszValue = (LPCSTR ) QueryValue();
            DBGPRINTF( ( DBG_CONTEXT, 
                       "String Value( %08x) = %s\n",
                       pszValue, 
                       pszValue ) );
            break;
        }
      default:
 
            DBGPRINTF( ( DBG_CONTEXT, 
                       " Type=%d. Unknown value at %08x\n",
                       QuerySqlType(), 
                       QueryValue() ) );
            break;

    } // switch

    return;

} // ODBC_PARAMETER::Print()

# endif // DBG

/************************************************************
 * ODBC_STATEMENT  member functions
 ************************************************************/


ODBC_STATEMENT::~ODBC_STATEMENT( VOID)
{
    //
    // Free the statement handle
    //
    if ( m_hStmt != SQL_NULL_HSTMT) {

        m_rc = pSQLFreeStmt( m_hStmt, SQL_DROP);
        m_hStmt = SQL_NULL_HSTMT;

        // Ignore the error code here.
        DBG_ASSERT( ODBC_CONNECTION::Success( m_rc));

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SqlFreeStmt() return code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    FreeColumnMemory();

    m_dwSignature = ODBC_STATEMENT_FREE_SIGNATURE;

} // ODBC_STATEMENT::~ODBC_STATEMENT()

HRESULT
ODBC_STATEMENT::ExecDirect(
    IN LPCSTR pszSqlCommand,
    IN DWORD cchSqlCommand
    )
{
    DBG_ASSERT( CheckSignature() );

    BOOL fReturn;

    IF_DEBUG( ODBC ) 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Executing the SQL command (%d bytes) %s.\n",
                    cchSqlCommand * sizeof( CHAR),
                    pszSqlCommand));
    }

    //
    //  SQLExecDirect only likes Unsigned chars !
    //
    m_rc = pSQLExecDirect( m_hStmt, 
                           (UCHAR FAR *) pszSqlCommand, 
                           cchSqlCommand);

    fReturn = ODBC_CONNECTION::Success( m_rc);

    IF_DEBUG( ODBC) 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLExecDirect() returns code %d\n",
                    m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if( fReturn )
    {
        return S_OK;
    }
    
    return E_FAIL;

} // ODBC_STATEMENT::ExecDirect()



HRESULT
ODBC_STATEMENT::ExecDirect(
    IN LPCWSTR pszSqlCommand,
    IN DWORD cchSqlCommand
    )
{
    HRESULT  hr;
    STRA     strCommand;

    DBG_ASSERT( CheckSignature() );

    hr = strCommand.CopyW( pszSqlCommand );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying sql command, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return ExecDirect( strCommand.QueryStr(), strCommand.QueryCCH() );

} // ODBC_STATEMENT::ExecDirect()

HRESULT
ODBC_STATEMENT::PrepareStatement(
    IN LPCSTR    pszStatement
    )
/*++

  This function prepares the SQL statement for future execution.

  Arguments:
    pszStatement - pointer to null terminated string containing the
                   statement.

  Returns:
     HRESULT
--*/
{
    BOOL fReturn;

    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( QueryErrorCode() == SQL_SUCCESS && 
                pszStatement != NULL);

    m_rc = pSQLPrepare( m_hStmt, (UCHAR FAR *) pszStatement, SQL_NTS);

    IF_DEBUG( ODBC ) 
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    " SQLPrepare( %s) returns ErrorCode = %d.\n",
                     pszStatement, m_rc));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    m_fPreparedStmt = ODBC_CONNECTION::Success( m_rc );

    if( m_fPreparedStmt )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::PrepareStatment()

HRESULT
ODBC_STATEMENT::PrepareStatement( 
    IN LPCWSTR   pwszCommand
    )
/*++

  This function prepares an ODBC statement for execution.
  Since ODBC does not support UNICODE, we convert the statement 
  into ANSI before calling the APIs.

  Arguments:
    pwszCommand - pointer to null-terminated string containing the
                  statement to be prepared.

  Returns:
    HRESULT
--*/
{
    BOOL    fReturn = FALSE;
    STRA    strCommand;
    HRESULT hr;

    DBG_ASSERT( CheckSignature() );

    hr = strCommand.CopyW( pwszCommand );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying command, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return PrepareStatement( strCommand.QueryStr() );

} // ODBC_STATEMENT::PrepareStatement()

HRESULT
ODBC_STATEMENT::BindParameter( 
    IN PODBC_PARAMETER pOdbcParameter
    )
{

    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( ODBC_CONNECTION::Success( m_rc) && 
                pOdbcParameter != NULL);

    m_rc = pOdbcParameter->Bind( m_hStmt);

    IF_DEBUG( ODBC) {

        CheckAndPrintErrorMessage( this, m_rc );
    }

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::BindParameter()

HRESULT
ODBC_STATEMENT::ExecuteStatement( 
    VOID
    )
/*++

  This function executes a prepared ODBC statement. At the end of 
  execution, the transaction is also committed to ensure that the 
  record is automatically written to the database.

  Arguments:
    None

  Returns:
    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( m_fPreparedStmt != FALSE);

    if ( !ODBC_CONNECTION::Success( QueryErrorCode()) ) 
    {
        DBGPRINTF(( DBG_CONTEXT,
         "!!WARNING!! - Attempting to use Invalid ODBC Connection!\n" ));
    }

    m_rc = pSQLExecute( m_hStmt);

    IF_DEBUG( ODBC) 
    {
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;

} // ODBC_STATEMENT::ExecuteStatement()

HRESULT
ODBC_STATEMENT::QueryRowCount(
    OUT DWORD * pcRows
    )
/*++

  Calls SQLRowCount on the current result set.

  NOTE: Not all database implementations support this!!

  Arguments:

    pcRows - Receives count of rows

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    DBG_ASSERT( CheckSignature() );

    m_rc = pSQLRowCount( m_hStmt,
                         (SDWORD *) pcRows );

    if( ODBC_CONNECTION::Success( m_rc ) )
    {
        return S_OK;
    }

    return E_FAIL;
}

HRESULT
ODBC_STATEMENT::QueryColNames(
    STRA * *  pastrCols,
    DWORD  *  cCols,
    DWORD     cchMaxFieldSize,
    BOOL *    pfHaveResultSet
    )
/*++

  This method returns the list of column names from the result table

  Arguments:

    pastrCols - Receives an array of STRAs containing the column names
    cCols - Count of columns returned (zero for no result set)
    cchMaxFieldSize - Maximum buffer size to allocate for any data 
                      fields, zero means use the default value.
    pfHaveResultSet - Set to TRUE if the current query was a SELECT 
                      and thus has rows that can be enumerated

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:

--*/
{
    HRESULT hr;
    SWORD   nresultcols;
    SWORD   i;
    CHAR    achColName[64];
    SWORD   cchColName;
    SWORD   ColType;
    DWORD   cchColLength;
    SWORD   scale;
    SWORD   nullable;

    *pastrCols       = NULL;
    *cCols           = 0;
    *pfHaveResultSet = TRUE;

    DBG_ASSERT( CheckSignature() );

    //
    //  Return the old binding info if we already have it
    //

    if ( m_astrColNames )
    {
        *pastrCols = m_astrColNames;
        *cCols = m_cCols;

        return S_OK;
    }

    //
    //  Provide a default maximum field size if none was specified
    //

    if ( !cchMaxFieldSize )
    {
        cchMaxFieldSize = DEFAULT_MAX_FIELD_SIZE;
    }

    //
    //  See what kind of statement it was.  If there are no result
    //  columns, the statement is not a SELECT statement.
    //

    m_rc = pSQLNumResultCols( m_hStmt,
                              &nresultcols );

    if ( !ODBC_CONNECTION::Success( m_rc ) )
    {
        return E_FAIL;
    }

    if ( nresultcols > 0 )
    {
        //
        //  Allocate an array of strings for the column names and 
        //  the column values
        //

        m_cCols = nresultcols;
        *cCols  = m_cCols;

        m_astrColNames = new STRA[m_cCols];
        m_astrValues   = new STRA[m_cCols];
        m_acbValue     = new LONG[m_cCols];

        if( m_astrColNames == NULL ||
            m_astrValues == NULL   ||
            m_acbValue == NULL )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }

        //
        //  Otherwise, get the column names of the result set and 
        //  use the display_size() function to compute the length 
        //  needed by each data type.  Next, bind the columns and 
        //  specify all data will be converted to char.
        //

        for (i = 0; i < m_cCols; i++ )
        {
            m_rc = pSQLDescribeCol( m_hStmt,
                                    i + 1,
                                    (UCHAR *) achColName,
                                    (SWORD)sizeof(achColName),
                                    &cchColName,
                                    &ColType,
                                    &cchColLength,
                                    &scale,
                                    &nullable );

            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }

            //
            //  Select the buffer size for the retrieved data for 
            //  this column
            //

            cchColLength = ODBC_CONNECTION::DisplaySize( ColType,
                             min( cchColLength, cchMaxFieldSize ) );

            //
            //  Copy the column name and set the column data size
            //

            hr = m_astrColNames[i].Copy( achColName );
            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error copying colume name, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            hr = m_astrValues[i].Resize( cchColLength + 1 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error resizing string buffer, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            m_rc = pSQLBindCol( m_hStmt,
                                i + 1,
                                SQL_C_CHAR,
                                m_astrValues[i].QueryStr(),
                                cchColLength,
                                &m_acbValue[i] );

            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }
        }

        *pastrCols = m_astrColNames;
        *cCols     = m_cCols;
    }
    else
    {
        *pfHaveResultSet = FALSE;
    }

    return S_OK;
}

HRESULT
ODBC_STATEMENT::QueryValuesAsStr(
    STRA * *      pastrValues,
    OUT DWORD * * pacbValues,
    BOOL *        pfLast
    )
/*++

  This method gets the data at the current position.

  Arguments:

    pastrValues - Receives a pointer to an array of strings that contains
        the alphanumeric representation of that field
    pacbValues - Receives pointer to array of DWORDs that contain the length
        of the field
    pfLast - Set to TRUE if there are no more values to retrieve

  Returns:

    HRESULT

  Note:

--*/
{
    HRESULT hr;

    DBG_ASSERT( CheckSignature() );

    *pastrValues = NULL;

    //
    //  Build the bindings if we haven't already
    //

    if ( !m_astrColNames )
    {
        STRA * astrCols;
        DWORD cCols;
        BOOL  fHaveResultSet;

        hr = QueryColNames( &astrCols,
                             &cCols,
                             0,
                             &fHaveResultSet );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    //
    //  If there are columns to enumerate, get them now
    //

    if ( m_astrColNames )
    {
        DWORD i;

        //
        //  Zero terminate the columns as some drivers don't write 
        //  anything for NULL fields
        //

        for ( i = 0; i < m_cCols; i++ )
        {
            *((CHAR *) m_astrValues[i].QueryStr()) = '\0';
            m_acbValue[i] = 0;
        }

        //
        //  Fill in the binding values
        //

        m_rc = pSQLFetch( m_hStmt );

        if ( m_rc == SQL_NO_DATA_FOUND )
        {
            *pfLast = TRUE;
        }
        else
        {
            if ( !ODBC_CONNECTION::Success( m_rc ) )
            {
                return E_FAIL;
            }

            *pfLast = FALSE;
        }

        *pastrValues = m_astrValues;
        *pacbValues  = ( DWORD * ) m_acbValue;
    }
    else
    {
        *pfLast = TRUE;
    }

    return S_OK;
}

HRESULT
ODBC_STATEMENT::MoreResults(
    BOOL * pfMoreResults
    )
/*++

    Determines if there are any more results sets to return to 
    the user

    pfMoreResults - Set to TRUE if there are more results in the 
                    result set

--*/
{
    DBG_ASSERT( CheckSignature() );

    *pfMoreResults = TRUE;

    m_rc = pSQLMoreResults( m_hStmt );

    if ( m_rc == SQL_NO_DATA_FOUND )
    {
        *pfMoreResults = FALSE;
        return S_OK;
    }

    if ( !ODBC_CONNECTION::Success( m_rc ))
    {
        return E_FAIL;
    }

    return S_OK;
}

VOID
ODBC_STATEMENT::FreeColumnMemory(
    VOID
    )
/*++
    This method frees memory allocated by the QueryColNames and
    QueryValuesAsStr methods.

--*/
{
    DBG_ASSERT( CheckSignature() );

    if ( m_astrColNames ) delete [] m_astrColNames;
    if ( m_astrValues )   delete [] m_astrValues;
    if ( m_acbValue )     delete [] m_acbValue;

    m_astrColNames = NULL;
    m_astrValues = NULL;
    m_acbValue = NULL;
}

//static
HRESULT
ODBC_STATEMENT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_STATEMENT lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_STATEMENT );

    DBG_ASSERT( sm_pachOdbcStatements == NULL );
    
    sm_pachOdbcStatements = new ALLOC_CACHE_HANDLER( "ODBC_STATEMENT",  
                                                     &acConfig );

    if ( sm_pachOdbcStatements == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_STATEMENT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_STATEMENT lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcStatements != NULL )
    {
        delete sm_pachOdbcStatements;
        sm_pachOdbcStatements = NULL;
    }
}

# if DBG

VOID
ODBC_STATEMENT::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ODBC_STATEMENT( %08x)."
                " HStmt = %08x. OdbcConn=%08x. RetCode = %d\n",
                m_hStmt, m_pOdbcConnection, m_rc));

} // ODBC_STATEMENT::Print()

# endif // DBG

/**************************************************
 *  Member Functions of class ODBC_CONNECTION
 **************************************************/


ODBC_CONNECTION::~ODBC_CONNECTION( VOID)
/*++
   This function closes the odbc connection ( if open) and cleans up.

--*/
{
    DBG_REQUIRE( SUCCEEDED( Close() ) );

    return;
} // ODBC_CONNECTION::~ODBC_CONNECTION()

HRESULT
ODBC_CONNECTION::Open(
    IN LPCSTR   pszDataSource,
    IN LPCSTR   pszUserName,
    IN LPCSTR   pszPassword
    )
/*++
  This function opens a new odbc connection to given data source
  using the user name and password supplied.

  Arguments:
    pszDataSource - pointer to null-terminated string containing ODBC
                    data source name
    pszUserName   - pointer to null-terminated string containing 
                    UserName
    pszPassword   - pointer to null-terminated string containing 
                    Password

  Returns:

    HRESULT
--*/
{
    HRESULT   hr = S_OK;
    BOOL      fReturn = FALSE;

    DBG_ASSERT( pszDataSource != NULL &&
                pszUserName != NULL &&
                pszPassword != NULL );

    //
    //  Allocate an ODBC environment
    //

    m_rc = pSQLAllocEnv( &m_henv );
    fReturn = Success( m_rc );

    IF_DEBUG( ODBC ) {

        DBGPRINTF( ( DBG_CONTEXT,
               "SQLAllocEnv() returned ErrorCode %d. henv = %08x\n",
               m_rc, m_henv));

        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( fReturn ) {

        //
        // Establish memory for connection handle within the environment
        //

        m_rc = pSQLAllocConnect( m_henv, &m_hdbc);
        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                   "SQLAllocConnect() returns code %d. hdbc = %08x\n",
                   m_rc, m_hdbc));

            CheckAndPrintErrorMessage( this, m_rc);
        }
    }

    if ( fReturn) {

        //
        // Use Following call to just printout the dynamic values for ODBC
        //
        // AuxOdbcFunctions( m_henv, m_hdbc);

#if 0
        {
            STRA str;
            STRA strOut;
            SWORD swStrOut;

            if ( FAILED( str.Append( pszDataSource ) )  ||
                 FAILED( str.Append( ";UID=" ) )        ||
                 FAILED( str.Append( pszUserName ) )    ||
                 FAILED( str.Append( ";PWD=" ) )        ||
                 FAILED( str.Append( pszPassword ) )    ||
                 FAILED( str.Append( ";APP=Internet Services") ) ||
                 FAILED( strOut.Resize( 255 ) ) )
            {
                return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            }

            m_rc = pSQLDriverConnect( m_hdbc,
                                      NULL,
                                      (UCHAR *) str.QueryStr(),
                                      SQL_NTS,
                                      (UCHAR *) strOut.QueryStr(),
                                      strOut.QuerySize(),
                                      &swStrOut,
                                      SQL_DRIVER_NOPROMPT );
        }
#else
        {
            m_rc = pSQLConnect( m_hdbc,
                               (UCHAR FAR *) pszDataSource, SQL_NTS,
                               (UCHAR FAR *) pszUserName,   SQL_NTS,
                               (UCHAR FAR *) pszPassword,   SQL_NTS );
        }
#endif

        fReturn = Success( m_rc);

        IF_DEBUG( ODBC) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLConnect( %s, %s, %s) returns code %d.\n",
                        pszDataSource,
                        pszUserName,
                        pszPassword,
                        m_rc ) );

            CheckAndPrintErrorMessage( this, m_rc );
        }
    }

    m_fValid = fReturn;

    if ( !fReturn ) {
        hr = HRESULT_FROM_WIN32( ERROR_GEN_FAILURE );
    }

    return hr;

} // ODBC_CONNECTION::Open()

HRESULT
ODBC_CONNECTION::Open(
    IN LPCWSTR  pwszDataSource,
    IN LPCWSTR  pwszUserName,
    IN LPCWSTR  pwszPassword
    )
/*++
  This function opens a new odbc connection to given data source
    using the user name and password supplied.

  Arguments:
    pwszDataSource - pointer to null-terminated string containing ODBC
                     data source name
    pwszUserName   - pointer to null-terminated string containing 
                     UserName
    pwszPassword   - pointer to null-terminated string containing 
                     Password

  Returns:
    TRUE on success and FALSE if there is an error.

  Note:
     Poor me.  ODBC Does not take UNICODE strings :(. 2/15/95
     So we will explicitly convert parameters to ANSI on stack.
--*/
{
    HRESULT hr;
    DWORD   dwError = NO_ERROR;
    STRA    strDataSource;
    STRA    strUserName;
    STRA    strPassword;

    //
    // Convert all parameters from UNICODE to ANSI
    //
    hr = strDataSource.CopyW( pwszDataSource );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strUserName.CopyW( pwszUserName );
    if( FAILED( hr ) )
    {
        return hr;
    }

    hr = strPassword.CopyW( pwszPassword );
    if( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Make an ANSI open call.
    //
    hr = Open( strDataSource.QueryStr(), 
               strUserName.QueryStr(), 
               strPassword.QueryStr() );

    //
    // Zero the password for security reasons.
    //
    memset( strPassword.QueryStr(), 
            0, strPassword.QueryCB() );

    return hr;

} // ODBC_CONNECTION::Open()


HRESULT
ODBC_CONNECTION::Close( 
    VOID
    )
/*++
  This function closes the connection established with the ODBC
  and frees up and dynamic memory used.

  Returns:
    TRUE on success and FALSE if there are any failures.

  Note:
    Intermediate failures are ignored. Normally they should not occur.

--*/
{
    BOOL fReturn = TRUE;

    //
    // Disconnect and free the connection.
    //
    if ( m_hdbc != SQL_NULL_HDBC) 
    {
        m_rc = pSQLDisconnect( m_hdbc );

        //
        //  Disconnect is allowed to fail w/o being fatal so don't set
        //  fReturn
        //

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "Warning: SQLDisconnect() returns code %d.\n",
                        m_rc));
            CheckAndPrintErrorMessage( this, m_rc);
        }

        m_rc = pSQLFreeConnect( m_hdbc);

        m_hdbc = SQL_NULL_HDBC;

        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeConnect() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }

        if( !fReturn )
        {
            return E_FAIL;
        }
    }

    //
    //  Free the ODBC environment handle.
    //
    if ( m_henv != SQL_NULL_HENV) {

        m_rc = pSQLFreeEnv( m_henv);
        m_henv = SQL_NULL_HENV;
        fReturn = fReturn && Success( m_rc);

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "SQLFreeEnv() returns code %d.\n",
                        m_rc));

            CheckAndPrintErrorMessage( this, m_rc);
        }

        if( !fReturn )
        {
            return E_FAIL;
        }
    }

    return S_OK;

} // ODBC_CONNECTION::Close()

PODBC_STATEMENT
ODBC_CONNECTION::AllocStatement( VOID)
/*++
  Description:
    This function allocates a new ODBC statement object and also 
    calls SQLAllocStatement to create the state required for 
    establishing the statement in the ODBC Manager.

  Arguments:
    None

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    PODBC_STATEMENT pOdbcStmt = NULL;
    HSTMT   hstmt = SQL_NULL_HSTMT;

    DBG_ASSERT( Success( m_rc));

    //
    // Allocate a statement handle and associate it with the connection.
    //
    m_rc = pSQLAllocStmt( m_hdbc, &hstmt);

    IF_DEBUG( ODBC) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "SqlAllocStmt() returns code %d."
                    " New Hstmt is : %08x\n",
                    m_rc, hstmt));
        CheckAndPrintErrorMessage( this, m_rc);
    }

    if ( ODBC_CONNECTION::Success( m_rc)) {

        pOdbcStmt = new ODBC_STATEMENT( this, hstmt);
    }

    return ( pOdbcStmt );

} // ODBC_CONNECTION::AllocStatement()


HRESULT
ODBC_CONNECTION::SetConnectOption(
    IN UWORD   Option,
    IN SQLULEN Param
    )
/*++

  Sets various options on this connection

  Arguments:

    Option - Option to set
    Param - Option value (32 bit dword or pointer to null terminated 
            string )

  Returns:
    HRESULT. Failures are considered to be soft errors as the problem 
    may be the driver doesn't support the option etc.

  Note:

--*/
{
    BOOL    fReturn = TRUE;
    RETCODE rc;

    if ( m_hdbc != SQL_NULL_HDBC)
    {
        rc = pSQLSetConnectOption( m_hdbc, Option, Param );

        fReturn = Success( rc );

        IF_DEBUG( ODBC ) 
        {

            DBGPRINTF( ( DBG_CONTEXT,
                      "SQLSetConnectOption( %d, %d ) returns code %d.\n",
                      Option,
                      Param,
                      rc ) );

            CheckAndPrintErrorMessage( this, rc);
        }
    }
    else
    {
        DBGPRINTF( ( DBG_CONTEXT,
                     "[SetConnectOption] Warning: "
                     "Setting option on closed connection\n" ));
    }

    if( fReturn )
    {
        return S_OK;
    }

    return E_FAIL;
}

BOOL
ODBC_CONNECTION::GetLastErrorText(
    OUT STRA *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or 
  windows error that occurred.  Even though the ODBC methods return 
  FALSE on failure, if it was an ODBC call that failed, then 
  GetLastError won't return the needed error code.  Clients of this 
  class should call this method to get a descriptive text string of 
  the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call 
    GetLastError for the error code.

--*/
{
    BOOL fReturn = TRUE;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = SUCCEEDED(pstrError->LoadString( GetLastError() ));

    } 
    else 
    {
        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        pstrError->Reset();

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) 
            {
                wsprintfA( rgchFullMsg,
                           "[State=%s][Error=%d]%s\n",
                           achState, lError, rgchMsg);

                if ( FAILED( pstrError->Append( rgchFullMsg ) ) )
                {

                    fReturn = FALSE;
                    break;
                }
            } 
            else 
            {
                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) 
                {
                    //
                    //  Append the end of unorder list marker
                    //

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc ) );

        if ( !ODBC_CONNECTION::Success( rc ) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                        "[GetLastErrorText] SqlError() returned error %d.\n",
                        rc));

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorText()

BOOL
ODBC_CONNECTION::GetLastErrorTextAsHtml(
    OUT STRA *    pstrError,
    IN  HSTMT    hstmt,
    IN  RETCODE  rc
    ) const
/*++

  This method returns the textual representation of the last ODBC or 
  windows error that occurred.  Even though the ODBC methods return 
  FALSE on failure, if it was an ODBC call that failed, then 
  GetLastError won't return the needed error code.  Clients of this 
  class should call this method to get a descriptive text string of 
  the failure.

  Returns:

    TRUE on success and FALSE if there are any failures.

  Note:
    If this function returns FALSE, then a client should call 
    GetLastError for the error code.

--*/
{
    BOOL    fReturn = TRUE;
    HRESULT hr;

    if ( ODBC_CONNECTION::Success( rc)) {

        fReturn = SUCCEEDED(pstrError->LoadString( GetLastError()));

    } else {

        CHAR     rgchMsg[ SQL_MAX_MESSAGE_LENGTH + 10];
        CHAR     achState[30];
        CHAR     rgchFullMsg[ sizeof(rgchMsg) + sizeof(achState) + 60];
        SWORD    cbMsg;
        LONG     lError;
        DWORD    dwError;

        //
        //  If we're formatting as HTML, we bullet list the items
        //

        if ( FAILED( hr = pstrError->Copy( "<UL>" ) ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying error data, hr = 0x%x.\n",
                hr ));

            return FALSE;
        }

        //
        //  Loop to pick up all of the errors
        //

        do {
            cbMsg = SQL_MAX_MESSAGE_LENGTH;

            rc = pSQLError( m_henv,
                            m_hdbc,
                            hstmt,
                            (UCHAR *) achState,
                            &lError,
                            (UCHAR *) rgchMsg,
                            cbMsg,
                            &cbMsg );

            if ( ODBC_CONNECTION::Success( rc)) 
            {
                wsprintfA( rgchFullMsg,
                           "<LI>[State=%s][Error=%d]%s\n",
                           achState, lError, rgchMsg);

                if ( FAILED( hr = pstrError->Append( rgchFullMsg ) ) ) 
                {
                    DBGPRINTF(( DBG_CONTEXT,
                        "Error appending error msg, hr = 0x%x.\n",
                        hr ));

                    fReturn = FALSE;
                    break;
                }
            } 
            else 
            {
                //
                //  This is indicates there are no more error strings
                //  to pick up so we should get out
                //

                if ( rc == SQL_NO_DATA_FOUND ) 
                {
                    //
                    //  Append the end of unorder list marker
                    //

                    if ( FAILED( hr = pstrError->Append( "</UL>" ) ) ) 
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error appending error, hr = 0x%x.\n",
                            hr ));

                        return FALSE;
                    }

                    rc = SQL_SUCCESS;
                    break;
                }
            }

        } while ( ODBC_CONNECTION::Success( rc ) );

        if ( !ODBC_CONNECTION::Success( rc) )
        {
            DBGPRINTF( ( DBG_CONTEXT,
                   "[GetLastErrorText] SqlError() returned error %d.\n",
                   rc ) );

            SetLastError( ERROR_GEN_FAILURE );
            fReturn = FALSE;
        }
    }

    return ( fReturn);

} // ODBC_CONNECTION::GetLastErrorTextAsHtml()

BOOL
ODBC_CONNECTION::GetInfo(IN DWORD fInfoType,
                         IN PVOID rgbInfoValue,
                         IN DWORD cbInfoValueMax,
                         IN OUT DWORD * pcbInfoValue)
/*++
  This function obtains the value of the fInfoType for a specific
  ODBC Connection. It mimicks the SQLGetInfo() and uses it to obtain
  this value. On successful return the pointer rgbInfoValue contains
  the requested value and pcbInfoValue contains the size in bytes of
  data.

  Arguments:
    fInfoType - flag containing the Information Type (name) to be 
                fetched.
    rgbInfoValue - pointer to buffer which will contain the return 
                   data.
    cbInfoValue  - size of rgbInfoValue in bytes.
    pcbInfoValue - pointer to location that will contain the size of
                   information stored in rgbInfoValue, on successful 
                   return. If buffer is insufficient, this location 
                   will contain the required number of bytes.

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fReturn = FALSE;

    if ( m_hdbc != SQL_NULL_HDBC) 
    {
        RETCODE rc;

        rc = pSQLGetInfo( m_hdbc, (UWORD ) fInfoType,
                         (PTR)   rgbInfoValue,
                         (SWORD) cbInfoValueMax,
                         (SWORD FAR *) pcbInfoValue );

        fReturn = Success( rc );

        IF_DEBUG( ODBC) 
        {
            DBGPRINTF( ( DBG_CONTEXT,
               "SQLGetInfo( %08x, %d, %08x, %d, %08x) returns %d.\n",
               m_hdbc, fInfoType, rgbInfoValue, cbInfoValueMax,
               pcbInfoValue, rc ) );

            CheckAndPrintErrorMessage( this, rc );
        }
    } 
    else 
    {
        DBGPRINTF( ( DBG_CONTEXT,
                    "[SQLGetInfo] Invalid Connection to ODBC\n"));
    }

    return ( fReturn );

} // ODBC_CONNECTION::GetInfo()

DWORD
ODBC_CONNECTION::DisplaySize(
    SWORD coltype,
    DWORD collen
    )
{
    DWORD cbSize = MAX_NONCHAR_DATA_LEN;

    //
    //  Note that we always set the size to at least four bytes.  
    //  This prevents any possible problems if the column to be 
    //  bound is NULLable, which can cause a NULL to be written 
    //  for the data during a fetch
    //

    switch ( coltype )
    {
      case SQL_CHAR:
      case SQL_VARCHAR:
      case SQL_LONGVARCHAR:
      case SQL_BINARY:
      case SQL_VARBINARY:
      case SQL_LONGVARBINARY:
        cbSize = max(collen + sizeof(CHAR), sizeof(PVOID));
        break;

      default:
        break;
    }

    return ( cbSize);

} // ODBC_CONNECTION::DisplaySize()

# if DBG
VOID
ODBC_CONNECTION::Print( 
    VOID
    ) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing ODBC_CONNECTION ( %08x). fValid = %d\n"
                " HENV = %08x. HDBC = %08x. ReturnCode =%d\n",
                this, m_fValid,
                m_henv, m_hdbc, m_rc));
    return;

} // ODBC_CONNECTION::Print()

# endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcpool.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    odbcpool.cxx

Abstract:

    Provides simple ODBC connection pooling for IDC.  The only keys 
    used for the connection pooling is the datasource name, the 
    username and password. ODBC options and other connection state 
    are not taken into consideration.

Author:

    John Ludeman (johnl)   01-Apr-1996

Revision History:
--*/

#include "precomp.hxx"

#ifndef _NO_TRACING_

#define IDC_PRINTF( x )      { char buff[256]; wsprintfA x;       \
                               DBGPRINTF((DBG_CONTEXT, buff )); }
#else

#if DBG
#define IDC_PRINTF( x )      { char buff[256]; wsprintfA x;       \
                                 OutputDebugString( buff ); }
#else
#define IDC_PRINTF( x )
#endif

#endif

//
//  Globals
//

CRITICAL_SECTION               g_csPoolLock;

LIST_ENTRY                     g_PoolList;

DWORD                          g_dwTimeoutID = 0;

//
// Various counters
//

DWORD                          g_cFree;
DWORD                          g_cUsed;

ALLOC_CACHE_HANDLER *          ODBC_CONN_POOL::sm_pachOdbcConnPools;

//static
HRESULT
ODBC_CONN_POOL::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_CONN_POOL lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_CONN_POOL );

    DBG_ASSERT( sm_pachOdbcConnPools == NULL );
    
    sm_pachOdbcConnPools = new ALLOC_CACHE_HANDLER( "ODBC_CONN_POOL",  
                                                     &acConfig );

    if ( sm_pachOdbcConnPools == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_CONN_POOL::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_CONN_POOL lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcConnPools != NULL )
    {
        delete sm_pachOdbcConnPools;
        sm_pachOdbcConnPools = NULL;
    }
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    );

BOOL
InitializeOdbcPool(
    VOID
    )
{
    DWORD  err;
    HKEY   hkey;

    InitializeListHead( &g_PoolList );
    INITIALIZE_CRITICAL_SECTION( &g_csPoolLock );

    //
    //  Kick off the pool scavenger
    //

    g_dwTimeoutID = ScheduleWorkItem( IDCPoolScavenger,
                                      NULL,
                                      IDC_POOL_TIMEOUT * 1000,
                                      TRUE );

    return TRUE;
}

VOID
TerminateOdbcPool(
    VOID
    )
{
    ODBC_CONN_POOL * pOCPool;

    if ( g_dwTimeoutID )
    {
        RemoveWorkItem( g_dwTimeoutID );
        g_dwTimeoutID = 0;
    }

    EnterCriticalSection( &g_csPoolLock );

    while ( !IsListEmpty( &g_PoolList ))
    {
        LIST_ENTRY * pEntry = g_PoolList.Flink;

        RemoveEntryList( pEntry );

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        delete pOCPool;
        pOCPool = NULL;
    }

    LeaveCriticalSection( &g_csPoolLock );
    DeleteCriticalSection( &g_csPoolLock );
}

HRESULT
OpenConnection(
    IN  ODBC_CONNECTION *   podbcconnNonPooled,
    OUT ODBC_CONNECTION * * ppodbcconnToUse,
    IN  DWORD               csecPoolTimeout,
    IN  const CHAR *        pszDataSource,
    IN  const CHAR *        pszUsername,
    IN  const CHAR *        pszPassword,
    IN  const CHAR *        pszLoggedOnUser
    )
/*++

Routine Description:

    This function opens an odbc connection, optionally from a pool of
    ODBC connections.

Arguments:

    podbcconnNonPooled - If pooling wasn't requested or the open 
                         failed, we use this odbc connection object
    ppodbcconnToUse - Receives pointer to either a pooled ODBC 
                      connection object or podbcconnNonPooled if a 
                      pooled object couldn't be used
    csecPoolTimeout - Amount of time to pool a connection, 0 to not 
                      pool
    pszDataSource - ODBC Datasource
    pszUsername - Username for datasource access
    pszPassword - Password for use with this username
    pszLoggedOnUser - The NT account this user is running under

Return Value:

    HRESULT

    ppodbcconnToUse will be set to the ODBC connection to use for the
        request

--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;
    HRESULT          hr;

    //
    //  Don't pool this connection if it wasn't requested
    //

    if ( !csecPoolTimeout )
    {
        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    //
    //  Look in the pool cache for an existing connection
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree()                        &&
             !lstrcmpiA( pOCPool->QueryDataSource(), 
                         pszDataSource )               &&
             !lstrcmpiA( pOCPool->QueryUsername(), 
                         pszUsername )                 &&
             !lstrcmpiA( pOCPool->QueryLoggedOnUser(), 
                         pszLoggedOnUser )             &&
             !strcmp( pOCPool->QueryPassword(),
                      pszPassword ))

        {
            //
            //  We have a match
            //

            pOCPool->MarkAsUsed();
            *ppodbcconnToUse = pOCPool->QueryOdbcConnection();
            pOCPool->SetTTL( csecPoolTimeout );
            LeaveCriticalSection( &g_csPoolLock );

            return S_OK;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );

    //
    //  Allocate a new connection pool and if we connect successfully, 
    //  put it in the pool list
    //

    pOCPool = new ODBC_CONN_POOL();
    
    if( pOCPool == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    hr = pOCPool->Create( pszDataSource,
                         pszUsername,
                         pszPassword,
                         pszLoggedOnUser );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error creating pool connection, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    if ( FAILED( pOCPool->Open() ) )
    {
        delete pOCPool;
        pOCPool = NULL;

        *ppodbcconnToUse = podbcconnNonPooled;

        return podbcconnNonPooled->Open( pszDataSource,
                                         pszUsername,
                                         pszPassword );
    }

    *ppodbcconnToUse = pOCPool->QueryOdbcConnection();

    EnterCriticalSection( &g_csPoolLock );

    //
    //  Account for the new pool item but we have to do it 
    //  with in the critical section
    //

    g_cFree++;

    pOCPool->MarkAsUsed();
    pOCPool->SetTTL( csecPoolTimeout );
    InsertHeadList( &g_PoolList, &pOCPool->m_ListEntry );

    LeaveCriticalSection( &g_csPoolLock );

    return S_OK;
}

VOID
CloseConnection(
    IN  ODBC_CONNECTION *   podbcconnPooled,
    IN  BOOL                fDelete
    )
/*++

Routine Description:

    This routine frees an ODBC connection back to the pool, 
    optionally deleting it

Arguments:

    podbcconnPooled - ODBC connection that is pooled, can be NULL
    fDelete - TRUE if the item should be delete rather then returned 
              to the pool
--*/
{
    LIST_ENTRY *     pEntry;
    ODBC_CONN_POOL * pOCPool;

    if ( !podbcconnPooled )
    {
        return;
    }

    //
    //  Look in the pool list to mark it as free
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pEntry->Flink )
    {
        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( podbcconnPooled == pOCPool->QueryOdbcConnection() )
        {
            pOCPool->MarkAsFree();

            if ( fDelete )
            {
                RemoveEntryList( pEntry );
                g_cFree--;
                delete pOCPool;
                pOCPool = NULL;
            }

            break;
        }
    }

    LeaveCriticalSection( &g_csPoolLock );
}

VOID
WINAPI
IDCPoolScavenger(
    PVOID pContext
    )
/*++

Routine Description:

    Walks the list of pooled connections and removes any that have 
    timed out

--*/
{
    LIST_ENTRY *     pEntry;
    LIST_ENTRY *     pNext;
    ODBC_CONN_POOL * pOCPool;

    //
    //  Look through the list and remove any old items
    //

    EnterCriticalSection( &g_csPoolLock );

    for ( pEntry  = g_PoolList.Flink;
          pEntry != &g_PoolList;
          pEntry  = pNext )
    {
        pNext = pEntry->Flink;

        pOCPool = CONTAINING_RECORD( pEntry,
                                     ODBC_CONN_POOL,
                                     m_ListEntry );

        if ( pOCPool->IsFree() && !pOCPool->DecrementTTL() )
        {
            IDC_PRINTF(( buff,
                         "[IDCPoolScavenger] Removing %s, %s, %s\n",
                         pOCPool->QueryDataSource(),
                         pOCPool->QueryUsername(),
                         pOCPool->QueryLoggedOnUser() ));

            RemoveEntryList( pEntry );
            g_cFree--;
            delete pOCPool;
            pOCPool = NULL;
        }
    }

#if 0
IDC_PRINTF(( buff,
             "[IDCPoolScavenger] Free items in pool %d, used %d\n",
             g_cFree,
             g_cUsed ));
#endif

    LeaveCriticalSection( &g_csPoolLock );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\odbcreq.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    odbcreq.cxx

Abstract:

    ODBC Request class used for ODBC requests from a query file

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

    MuraliK    25-Aug-1995     Fixed a heap corruption problem
    Phillich   24-Jan-1996     Fixed nested Ifs problem

--*/

#include "precomp.hxx"

//
//  Accumulate and output data in chunks of this size
//

#define OUTPUT_BUFFER_SIZE         8192

//
//  This is the maximum value for the expires time.  It's 10 years in seconds
//

#define MAX_EXPIRES_TIME           0x12cc0300

//
//  The special tag names for marking the beginning and ending of the
//  special tag sections
//

#define BEGIN_DETAIL_TEXT          "begindetail"
#define END_DETAIL_TEXT            "enddetail"
#define IF_TEXT                    "if"
#define ELSE_TEXT                  "else"
#define END_IF_TEXT                "endif"

//
//  Does a case insensitive compare of a .idc field name
//

#define COMP_FIELD( pchName, pchField, cch )  ((toupper(*(pchName)) == \
                                              toupper(*(pchField))) && \
                              !_strnicmp( (pchName), (pchField), (cch)))

//
//  Given a pointer to a token, skips to the next white space 
//  delimited token
//

#define NEXT_TOKEN( pchToken )   SkipWhite( SkipNonWhite( pchToken ) )

ALLOC_CACHE_HANDLER *   ODBC_REQ::sm_pachOdbcRequests;

//
//  Globals
//

extern BOOL             g_fIsSystemDBCS;   // Is this system DBCS?

//
//  Local Function Prototypes
//

HRESULT
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    );

HRESULT
GetFileData(
    IN     const CHAR *             pchFile,
	OUT    BYTE * *                 ppbData,
	OUT    DWORD *                  pcbData,
	IN     int                      nCharset,
	IN     BOOL                     fUseWin32Canon
    );


HRESULT
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STRA *             pStrOptions
    );

HRESULT
BuildMultiValue(
    const CHAR * pchValue,
    STRA *        pstrMulti,
    BOOL         fQuoteElements
    );

const CHAR *
SkipNonWhite(
    const CHAR * pch
    );

const CHAR *
SkipTo(
    const CHAR * pch,
    CHAR ch
    );

const CHAR *
SkipWhite(
    const CHAR * pch
    );

ODBC_REQ::ODBC_REQ(
    EXTENSION_CONTROL_BLOCK * pECB,
    DWORD                     csecConnPool,
    int                       nCharset
    )
    : _dwSignature        ( ODBC_REQ_SIGNATURE ),
      _pECB               ( pECB ),
      _cchMaxFieldSize    ( 0 ),
      _cMaxRecords        ( 0xffffffff ),
      _cCurrentRecordNum  ( 0 ),
      _cClientParams      ( 0 ),
      _podbcstmt          ( NULL ),
      _podbcconnPool      ( NULL ),
      _cbQueryFile        ( 0 ),
      _cNestedIfs         ( 0 ),
      _fDirect            ( FALSE ),
      _fValid             ( FALSE ),
      _pbufOut            ( NULL ),
      _csecExpires        ( 0 ),
      _csecExpiresAt      ( 0 ),
      _pstrValues         ( NULL ),
      _pcbValues          ( NULL ),
      _cQueries           ( 0 ),
      _csecConnPool       ( csecConnPool ),
      _pSecDesc           ( NULL ),
      _pstrCols           ( NULL ),
      _nCharset           ( nCharset )
{}

ODBC_REQ::~ODBC_REQ()
{
    DBG_ASSERT( CheckSignature() );

    if ( _podbcstmt )
    {
        delete _podbcstmt;
        _podbcstmt = NULL;
    }

    Close();

    if ( _pbufOut )
    {
        delete _pbufOut;
        _pbufOut = NULL;
    }

    if ( _pSecDesc )
    {
        LocalFree( _pSecDesc );
        _pSecDesc = NULL;
    }

    _dwSignature = ODBC_REQ_FREE_SIGNATURE;
}

HRESULT
ODBC_REQ::Create(
    CONST CHAR *         pszQueryFile,
    CONST CHAR *         pszParameters
    )
{
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    hr = _strQueryFile.Copy( pszQueryFile );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying QueryFile name, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = _plParams.ParsePairs( pszParameters, FALSE, FALSE, FALSE );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error parsing param pairs, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    if ( _strQueryFile.IsValid() )
    {
        _fValid = TRUE;
    }

    _cClientParams = _plParams.GetCount();

    return hr;
}

HRESULT
ODBC_REQ::OpenQueryFile(
    BOOL * pfAccessDenied
    )
{
    CHAR *            pchQueryFile;
    HRESULT           hr;

    DBG_ASSERT( CheckSignature() );

    hr = GetFileData( _strQueryFile.QueryStr(),
                      (BYTE **) &pchQueryFile,
                      &_cbQueryFile,
                      _nCharset,
					  TRUE );
    if ( FAILED( hr ) )
    {
        STRA strError;
        LPCSTR apsz[1];

        apsz[0] = _pECB->lpszPathInfo;

        strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                               apsz,
                               HTTP_ODBC_DLL );
        SetErrorText( strError.QueryStr() );

        DWORD dwE = GetLastError();
        if ( dwE == ERROR_ACCESS_DENIED || dwE == ERROR_LOGON_FAILURE )
        {
            *pfAccessDenied = TRUE;
        }

        DBGPRINTF(( DBG_CONTEXT,
                   "Error in GetFileData(), hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    //
    //  CODEWORK - It is possible to avoid this copy by not modifying the
    //  contents of the query file.  Would save a buffer copy
    //

    if( !_bufQueryFile.Resize( _cbQueryFile ) )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }

    memcpy( _bufQueryFile.QueryPtr(),
            pchQueryFile,
            _cbQueryFile );

    return S_OK;
}


HRESULT
ODBC_REQ::ParseAndQuery(
    CHAR *  pszLoggedOnUser
    )
/*++

Routine Description:

    This method parses the query file and executes the SQL statement

Arguments:

    pchLoggedOnUser - The NT user account this user is running under

Return Value:

    HRESULT

--*/
{
    STACK_STRA( strDatasource, 64 );
    STACK_STRA( strUsername, 64 );
    STACK_STRA( strPassword, 64 );
    CHAR *     pch;
    CHAR *     pchEnd;
    CHAR *     pszField;
    CHAR *     pszValue;
    BOOL       fRet;
    VOID *     pCookie = NULL;
    DWORD      csecPoolConnection = _csecConnPool;
    BOOL       fRetried;
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  We don't allow some security related parameters to be 
    //  specified from the client so remove those now
    //

    _plParams.RemoveEntry( "REMOTE_USER" );
    _plParams.RemoveEntry( "LOGON_USER" );
    _plParams.RemoveEntry( "AUTH_USER" );

    //
    //  Do a quick Scan for the DefaultParameters value to fill 
    //  in the blanks in the parameter list from the web browser
    //

    {
        pch = (CHAR *) _bufQueryFile.QueryPtr();
        pchEnd = pch + strlen(pch);

        ODBC_PARSER Parser( (CHAR *) _bufQueryFile.QueryPtr() );

        while ( ( pszField = Parser.QueryToken() ) < pchEnd )
        {
            if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                Parser.SkipTo( ':' );
                Parser += 1;
                Parser.EatWhite();

                hr = _plParams.ParsePairs( Parser.QueryLine(), TRUE );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                           "Error parsing param pairs, hr = 0x%x.\n",
                           hr ));
                    return hr;
                }

                break;
            }

            Parser.NextLine();
        }
    }

    //
    //  Replace any %XXX% fields with the corresponding parameter.  
    //  Note we reassign pch in case of a pointer shift during 
    //  ReplaceParams
    //

    hr = ReplaceParams( &_bufQueryFile, &_plParams );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in ReplaceParams(), hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    pch = (CHAR *) _bufQueryFile.QueryPtr();
    pchEnd = pch + strlen(pch);

    //
    //  Loop through the fields looking for values we recognize
    //

    {
        ODBC_PARSER Parser( pch );

        while ( (pszField = Parser.QueryToken()) < pchEnd )
        {
            //
            //  Ignore blank lines and Ctrl-Zs
            //

            if ( !*pszField || *pszField == 0x1a)
            {
                Parser.NextLine();
                continue;
            }

            Parser.SkipTo( ':' );
            Parser += 1;
            Parser.EatWhite();

            //
            //  Ignore comment fields
            //

            if ( *pszField == '#' || *pszField == ';' )
            {
                Parser.NextLine();
                continue;
            }

            if ( COMP_FIELD( "Datasource:", pszField, 11 ))
            {
                hr = Parser.CopyToEOL( &strDatasource );
            }
            else if ( COMP_FIELD( "Username:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &strUsername );
            }
            else if ( COMP_FIELD( "Password:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &strPassword );
            }
            else if ( COMP_FIELD( "Template:", pszField, 9 ))
            {
                hr = Parser.CopyToEOL( &_strTemplateFile );

                //
                //  Specifying a template of "Direct" means return the
                //  first column of data as raw data to the client
                //

                if ( !_stricmp( _strTemplateFile.QueryStr(), "Direct" ))
                {
                    _fDirect = TRUE;
                }
            }
            else if ( COMP_FIELD( "MaxFieldSize:", pszField, 13 ))
            {
                _cchMaxFieldSize = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "MaxRecords:", pszField, 11 ))
            {
                _cMaxRecords = atoi( Parser.QueryPos() );
            }
            else if ( COMP_FIELD( "RequiredParameters:", pszField, 12 ))
            {
                hr = _plReqParams.ParseSimpleList( Parser.QueryLine() );
            }
            else if ( COMP_FIELD( "Content-Type:", pszField, 13 ))
            {
                hr = Parser.CopyToEOL( &_strContentType );
            }
            else if ( COMP_FIELD( "DefaultParameters:", pszField, 18 ))
            {
                //
                //  Ignore, already processed
                //
            }
            else if ( COMP_FIELD( "Expires:", pszField, 8 ))
            {
//                _csecExpires = min( (DWORD) atoi( Parser.QueryPos() ),
//                                    MAX_EXPIRES_TIME );
			}
            else if ( COMP_FIELD( "ODBCOptions:", pszField, 12 ))
            {
                hr = Parser.CopyToEOL( &_strOdbcOptions );
            }
            else if ( COMP_FIELD( "ODBCConnection:", pszField, 15 ))
            {
                //
                //  Is there an override to the default?
                //

                if ( !_strnicmp( Parser.QueryToken(), "Pool", 4 ))
                {
                    if ( !csecPoolConnection )
                    {
                        // This is bogus - if somebody has turned off connection
                        // pooling on the vroot and enabled it in the idc,
                        // there's no defined way to set the timeout
                        // need to add a timeout here

                        csecPoolConnection = 30;
                    }
                }
                else if ( !_strnicmp( Parser.QueryToken(), "NoPool", 6 ))
                {
                    csecPoolConnection = 0;
                }
            }
            else if ( COMP_FIELD( "SQLStatement:", pszField, 13 ))
            {
                if ( _cQueries >= MAX_QUERIES )
                {
                    STRA strError;
                    strError.FormatString( ODBCMSG_TOO_MANY_SQL_STATEMENTS,
                                           NULL,
                                           HTTP_ODBC_DLL );

                    SetErrorText( strError.QueryStr() );

                    return E_FAIL;
                }

                while ( TRUE )
                {
                    hr = _strQueries[_cQueries].Append( 
                                                  Parser.QueryLine() );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                               "Error appeinding value, hr = 0x%x.\n",
                               hr ));
                        return hr;
                    }

                    Parser.NextLine();

                    //
                    //  Line continuation is signified by putting a '+' at
                    //  the beginning of the line
                    //

                    if ( *Parser.QueryLine() == '+' )
                    {
                        hr = _strQueries[_cQueries].Append( " " );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error appending space, hr = 0x%x.\n",
                                hr ));
                            return hr;
                        }

                        Parser += 1;
                    }
                    else
                    {
                        //
                        //  Ignore blank line
                        //

                        if ( !*Parser.QueryLine() &&
                             Parser.QueryLine() < pchEnd )
                        {
                            continue;
                        }
                        break;
                    }

                }

                _cQueries++;
                continue;
            }
            else if ( COMP_FIELD( IDC_FIELDNAME_CHARSET, 
                                  pszField, 
                                  sizeof(IDC_FIELDNAME_CHARSET)-1 ))
            {
                //
                // Ignore "Charset:" field
                //

                Parser.NextLine();
                continue;
            }
            else if ( COMP_FIELD( "TranslationFile:", pszField, 16 ))
            {
                hr = Parser.CopyToEOL( &_strTranslationFile );
            }
            else
            {
                //
                //  Unrecognized field, generate an error
                //

                STRA strError;
                LPCSTR apsz[1];

                apsz[0] = pszField;

                strError.FormatString( ODBCMSG_UNREC_FIELD,
                                       apsz,
                                       HTTP_ODBC_DLL );

                SetErrorText( strError.QueryStr() );

                hr = E_FAIL;
            }

            if ( FAILED( hr ) )
            {
                return hr;
            }

            Parser.NextLine();
        }
    }

    //
    //  Make sure the Datasource and SQLStatement fields are non-empty
    //

    if ( strDatasource.IsEmpty() || 
         !_cQueries              || 
         _strQueries[0].IsEmpty() )
    {
        STRA strError;
        strError.FormatString( ODBCMSG_DSN_AND_SQLSTATEMENT_REQ,
                               NULL,
                               HTTP_ODBC_DLL );

        SetErrorText( strError.QueryStr() );

        return E_FAIL;
    }

    //
    //  Make sure all of the required parameters have been supplied
    //

    while ( pCookie = _plReqParams.NextPair( pCookie,
                                             &pszField,
                                             &pszValue ))
    {
        if ( !_plParams.FindValue( pszField ))
        {
            STRA strError;
            LPCSTR apsz[1];

            apsz[0] = pszField;

            if ( FAILED( hr = strError.FormatString( ODBCMSG_MISSING_REQ_PARAM,
                                                     apsz,
                                                     HTTP_ODBC_DLL )))
            {
                return hr;
            }

            //
            //  Set the error text to return the user and indicate we 
            //  couldn't continue the operation
            //

            SetErrorText( strError.QueryStr() );

            return E_FAIL;
        }
    }

    //
    //  Don't retry the connection/query if not pooling.  The reason
    //  we do the retry is to report the error that occurred (this
    //  requires the ODBC connection object).
    //

    fRetried = csecPoolConnection == 0;

RetryConnection:

    //
    //  Open the database
    //

	if ( FAILED( OpenConnection( &_odbcconn,
                                 &_podbcconnPool,
                                 csecPoolConnection,
                                 strDatasource.QueryStr(),
                                 strUsername.QueryStr(),
                                 strPassword.QueryStr(),
                                 pszLoggedOnUser ) )               ||
         FAILED( SetOdbcOptions( QueryOdbcConnection(), 
                                 &_strOdbcOptions ) )              ||
         !( _podbcstmt = QueryOdbcConnection()->AllocStatement() ) ||
         FAILED( _podbcstmt->ExecDirect( _strQueries[0].QueryStr(),
                                         _strQueries[0].QueryCCH() ) ) )
    {
        //
        //  Delete the pooled connection and retry the open
        //

        if ( csecPoolConnection )
        {
            CloseConnection( _podbcconnPool, TRUE );

            _podbcconnPool = NULL;
            csecPoolConnection = 0;
        }

        if ( !fRetried )
        {
	        if( _podbcstmt )
		    {
			    delete _podbcstmt;
				_podbcstmt = NULL;
			}

            fRetried = TRUE;
            goto RetryConnection;
        }

        return E_FAIL;
    }
	
    CloseConnection( _podbcconnPool, TRUE );

    return S_OK;
}


HRESULT
ODBC_REQ::OutputResults(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    STRA *            pstrHeaders,
    ODBC_REQ_HEADER   pfnSendHeader,
    BOOL              fIsAuth,
    BOOL *            pfAccessDenied
    )
/*++

Routine Description:

    This method reads the template file and does the necessary
    result set column substitution

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback

Return Value:

    HRESULT

--*/
{
    DWORD               cbOut;
    DWORD               cbFile, cbHigh;
    DWORD               BytesRead;
    DWORD               cbToSend;
    BOOL                fLastRow = FALSE;
    const CHAR *        pchStartDetail;
    const CHAR *        pchIn;
    const CHAR *        pchEOF;
    const CHAR *        pchBOF = NULL;
    CHAR *              pchTag;
    const CHAR *        pchValue;
    DWORD               cbValue;
    enum TAG_TYPE       TagType;
    DWORD               err;
    BOOL                fTriedRelative = FALSE;
    BOOL                fExpr;
    STRA                 strError;
    const CHAR *        CharacterMap[256];
    BOOL                fIsSelect;
    BOOL                fMoreResults;
    BOOL                fHaveResultSet = FALSE;
    DWORD               iQuery = 1;
    HRESULT             hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  Set up the first buffer in the output chain
    //

    if ( !_pbufOut )
    {
        _pbufOut = new BUFFER_CHAIN_ITEM( OUTPUT_BUFFER_SIZE );

        if ( !_pbufOut || !_pbufOut->QueryPtr() )
        {
            return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        }
    }

    if ( !_fDirect )
    {
        CHAR * pchLastSlash;
        STACK_STRA( str, MAX_PATH );

TryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        hr = GetFileData( ( fTriedRelative ? str.QueryStr() :
                                             _strTemplateFile.QueryStr() ),
                          ( BYTE ** )&pchBOF,
                          &BytesRead,
                          _nCharset,
                          TRUE );
        if ( FAILED( hr ) )
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                                    ||
                 ( ( GetLastError() != ERROR_FILE_NOT_FOUND )  
                   && ( GetLastError() != ERROR_PATH_NOT_FOUND ) ) ||
                 FAILED( str.Copy( _strQueryFile ) ) )
            {
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTemplateFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       HTTP_ODBC_DLL );
                SetErrorText( strError.QueryStr() );

                if ( ( dwE == ERROR_ACCESS_DENIED || 
                     dwE == ERROR_LOGON_FAILURE) )
                {
                    *pfAccessDenied = TRUE;
                    return HRESULT_FROM_WIN32( dwE );
                }

                if (!pfnSendHeader( pvContext, 
                                    "500 IDC Query Error", 
                                    pstrHeaders->QueryStr() ))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DBGPRINTF(( DBG_CONTEXT,
                           "Error in SendHeader(), hr = 0x%x.\n",
                           hr ));
                    return hr;
                }

                goto ErrorExit;
            }

            pchLastSlash = ( PCHAR )_mbsrchr( ( PUCHAR )str.QueryStr(), 
                                              '\\' );

            if ( !pchLastSlash )
            {
                return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            hr = str.Append( _strTemplateFile );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error appending template file name, hr = 0x%x.\n",
                   hr ));

                return hr;
            }

            fTriedRelative = TRUE;
            goto TryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                hr = _strTemplateFile.Copy( str );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                      "Error updating template file path, hr = 0x%x.\n",
                      hr ));
                    
                    return hr;
                }
            }
        }
    }

    //
    //  Open the translation file if one was specified
    //

    if ( !_strTranslationFile.IsEmpty() )
    {
        CHAR * pchLastSlash;
        CHAR * pchTranslationFile;
        STACK_STRA( str, MAX_PATH );
        BOOL   fRet;
        VOID * pvCookie = NULL;
        CHAR * pchField;
        DWORD  cbRead;

        fTriedRelative = FALSE;

TranslationTryAgain:
        //
        //  Open and read the template file (automatically zero terminated)
        //

        hr = GetFileData( ( fTriedRelative ? str.QueryStr() :
                                  _strTranslationFile.QueryStr()),
                          ( BYTE ** )&pchTranslationFile,
                          &cbRead,
                          _nCharset,
                          TRUE );
        if ( FAILED( hr ) )
        {
            //
            //  If the open fails with a not found error, then make the
            //  template file relative to the query file and try again
            //

            if ( fTriedRelative                             ||
                 ( GetLastError() != ERROR_FILE_NOT_FOUND 
                 && GetLastError() != ERROR_PATH_NOT_FOUND) ||
                 FAILED( str.Copy( _strQueryFile ) ) )
            {
                LPCSTR apsz[1];
                DWORD dwE = GetLastError();

                apsz[0] = _strTranslationFile.QueryStr();

                strError.FormatString( ODBCMSG_QUERY_FILE_NOT_FOUND,
                                       apsz,
                                       HTTP_ODBC_DLL );
                SetErrorText( strError.QueryStr());

                if ( ( dwE == ERROR_ACCESS_DENIED || 
                     dwE == ERROR_LOGON_FAILURE ) )
                {
                    *pfAccessDenied = TRUE;
                    return HRESULT_FROM_WIN32( dwE );
                }

                goto ErrorExit;
            }

            pchLastSlash = (PCHAR)_mbsrchr( ( PUCHAR )str.QueryStr(), 
                                            '\\' );

            if ( !pchLastSlash )
            {
                return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            }

            str.SetLen( DIFF(pchLastSlash - str.QueryStr()) + 1 );

            hr = str.Append( _strTranslationFile );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                  "Error appending translation file name, hr = 0x%x.\n",
                  hr ));

                return hr;
            }

            fTriedRelative = TRUE;
            goto TranslationTryAgain;
        }
        else
        {
            //
            //  Update our template file path if it changed
            //

            if ( fTriedRelative )
            {
                hr = _strTranslationFile.Copy( str );
                if ( FAILED( hr ) )
                {
                    return hr;
                }
            }
        }

        hr = _plTransList.ParsePairs( pchTranslationFile,
                                      FALSE,
                                      TRUE,
                                      FALSE );  

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error in ParsePairs(), hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        //
        //  Build the character map
        //

        memset( CharacterMap, 0, sizeof( CharacterMap ) );

        while ( pvCookie = _plTransList.NextPair( pvCookie,
                                                  &pchField,
                                                  (LPSTR *)&pchValue ))
        {
            CharacterMap[ (BYTE) *pchField ] = pchValue;
        }
    }

    //
    //  We've already performed the first query at this point
    //

NextResultSet:

    //
    //  Get the list of column names in the initial result set.  
    //  The initial set must be initialized for compatibility 
    //  with previous versions of IDC (i.e., column variables 
    //  can be referenced outside the detail section ).
    //

    hr = _podbcstmt->QueryColNames( &_pstrCols,
                                    &_cCols,
                                    _cchMaxFieldSize,
                                    &fHaveResultSet );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in QueryColNames, hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    if ( !fHaveResultSet )
    {
        //
        //  Check to see if there are anymore result sets for this query
        //

        hr = _podbcstmt->MoreResults( &fMoreResults );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error in MoreResults, hr = 0x%x.\n",
                   hr ));
            return hr;
        }

        if ( fMoreResults )
        {
            goto NextResultSet;
        }
        else if ( iQuery < _cQueries )
        {
            //
            //  If there are no more result sets, see if there
            //  are more queries.  Note calling SQLMoreResults
            //  will discard this result set
            //

            hr = _podbcstmt->ExecDirect(
                               _strQueries[iQuery].QueryStr(),
                               _strQueries[iQuery].QueryCCH() );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                       "Error in ExecDirect(), hr = 0x%x.\n",
                       hr ));
                return hr;
            }

            iQuery++;

            goto NextResultSet;
        }
    }


    //
    //  Get the first row of values
    //

    hr = NextRow( &fLastRow );
    if ( fHaveResultSet && FAILED( hr ) )
    {
        //
        //  Some SQL statements don't generate any rows (i.e.,
        //  insert, delete etc.).  So don't bail if there's a column in
        //  the result set
        //

        if ( !_cCols )
        {
            return hr;
        }
    }

    // Send reply header

    if (!pfnSendHeader( pvContext, "200 OK", pstrHeaders->QueryStr() ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBGPRINTF(( DBG_CONTEXT,
                   "Error in SendHeader(), hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    //
    //  Copy the template to the output buffer while scanning for column
    //  fields that need to be replaced
    //

    #define SEND_DATA( pchData, cbData )  SendData( pfnCallback,     \
                                                    pvContext,       \
                                                    (pchData),       \
                                                    (DWORD)(cbData), \
                                                    &_pbufOut,       \
                                                    &cbOut )

    #define SEND_DATA_CHECK_ESC( pchData, cbData )  \
            ((TagType == TAG_TYPE_VALUE_TO_ESCAPE)  \
            ? SendEscapedData( pfnCallback,         \
                    pvContext,                      \
                    pchData,                        \
                    (DWORD)(cbData),                \
                    &cbOut )                        \
            : SEND_DATA( pchData,                   \
                    (DWORD)(cbData) ) )

    cbOut  = 0;
    pchStartDetail = NULL;

    if( pchBOF == NULL )
    {
        return E_FAIL;
    }

    pchIn  = pchBOF;
    pchEOF = pchBOF + BytesRead;

    while ( pchIn < pchEOF )
    {
        //
        //  Look for the start of a "<!--%" or <%" tag
        //

        pchTag = strchr( pchIn, '<' );

        if ( pchTag )
        {
            //
            //  Send any data preceding the tag
            //

            cbToSend = DIFF(pchTag - pchIn);

            hr = SEND_DATA( pchIn, cbToSend );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error sending data, hr = 0x%x.\n",
                   hr ));

                return hr;
            }

            pchIn += cbToSend;


            if ( !memcmp( pchTag, "<!--%", 5 ) ||
                 !memcmp( pchTag, "<%", 2 ) )
            {
                //
                //  Is this a tag we care about?  pchIn is advanced 
                //  except in the unknown case
                //

                LookupTag( pchTag,
                           &pchIn,
                           &pchValue,
                           &cbValue,
                           &TagType );

                switch( TagType )
                {
                case TAG_TYPE_VALUE:
                case TAG_TYPE_VALUE_TO_ESCAPE:

                    //
                    //  Map any characters if there was a translation file
                    //

                    if ( _strTranslationFile.IsEmpty() )
                    {
                        hr = SEND_DATA_CHECK_ESC( pchValue, (DWORD) -1 );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error sending esc data, hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }
                    }
                    else
                    {
                        const CHAR * pchStart = pchValue;

                        while ( *pchValue )
                        {
                            if ( CharacterMap[ (BYTE) *pchValue ] )
                            {
                                hr = SEND_DATA_CHECK_ESC( pchStart,
                                        pchValue - pchStart );
                                if( FAILED( hr ) )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error sending data, hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }

                                hr = SEND_DATA_CHECK_ESC(
                                        CharacterMap[ (BYTE) *pchValue],
                                        (DWORD) -1 );
                                if( FAILED( hr ) )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error sending data, hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }

                                pchStart = pchValue = pchValue + 1;
                            }
                            else
                            {
                                pchValue++;
                            }
                        }

                        hr = SEND_DATA_CHECK_ESC( pchStart, 
                                                  pchValue - pchStart );
                        if( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error sending data, hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }
                    }

                    break;

                case TAG_TYPE_BEGIN_DETAIL:

                    //
                    //  If we don't have a result set, get one now
                    //

                    if ( !fHaveResultSet )
                    {
                        fLastRow = TRUE;
                        _podbcstmt->FreeColumnMemory();
                        _cCurrentRecordNum = 0;
                        _pstrCols = _pstrValues = NULL;

NextResultSet2:
                        hr = _podbcstmt->MoreResults( &fMoreResults );
                        if ( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error in MoreResults(), hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }

                        if ( fMoreResults )
                        {
NewQuery:
                            hr = _podbcstmt->QueryColNames( 
                                                &_pstrCols,
                                                &_cCols,
                                                _cchMaxFieldSize,
                                                &fHaveResultSet );
                            if ( FAILED( hr ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                  "Error in QueryColNames, hr = 0x%x.\n",
                                  hr ));

                                return hr;
                            }

                            if ( !fHaveResultSet )
                                goto NextResultSet2;

                            hr = NextRow( &fLastRow );
                            if ( FAILED( hr ) )
                            {
                                //
                                //  Some SQL statements don't generate 
                                //  any rows (i.e., insert, delete etc.).  
                                //  So don't bail if there's a column in 
                                //  the result set
                                //

                                if ( !_cCols )
                                {
                                    DBGPRINTF(( DBG_CONTEXT,
                                     "Error in NextRow(), hr = 0x%x.\n",
                                     hr ));

                                    return hr;
                                }
                            }
                        }
                        else if ( iQuery < _cQueries )
                        {
                            //
                            //  If there are no more result sets, see if 
                            //  there are more queries.  Note calling 
                            //  SQLMoreResults will discard this result 
                            //  set
                            //

                            hr = _podbcstmt->ExecDirect(
                                       _strQueries[iQuery].QueryStr(),
                                       _strQueries[iQuery].QueryCCH() );
                            if ( FAILED( hr ) )
                            {
                                DBGPRINTF(( DBG_CONTEXT,
                                     "Error in ExecDirect(), hr = 0x%x.\n",
                                     hr ));
                                return hr;
                            }

                            iQuery++;

                            goto NewQuery;
                        }
                    }

                    if ( !fLastRow )
                    {
                        pchStartDetail = pchIn;
                    }
                    else
                    {
                        //
                        //  If no more data, then skip the detail section
                        //

                        SkipToTag( &pchIn, END_DETAIL_TEXT );

                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_END_DETAIL:

                    hr = NextRow( &fLastRow );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error in NextRow(), hr = 0x%x.\n",
                            hr ));
                        return hr;
                    }

                    _cCurrentRecordNum++;

                    if ( !fLastRow && _cCurrentRecordNum < _cMaxRecords )
                    {
                        pchIn = pchStartDetail;
                    }
                    else
                    {
                        fHaveResultSet = FALSE;
                    }

                    break;

                case TAG_TYPE_IF:

                    //
                    //  pchIn points to the first character of the 
                    //  expression on the way in, the first character 
                    //  after the tag on the way out
                    //

                    hr = EvaluateExpression( (const CHAR **)&pchIn, 
                                             &fExpr );
                    if ( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                          "Error in EvaluateExpression(), hr = 0x%x.\n",
                          hr ));

                        return hr;
                    }

                    //
                    //  If the expression is FALSE, then skip the 
                    //  intervening data till the endif tag
                    //

                    if ( !fExpr )
                    {
                        //
                        //  Look for a closing else or endif
                        //

                        if ( SkipConditionalBlock( &pchIn, 
                                                   pchEOF, 
                                                   ELSE_TEXT ) )
                        {
                            _cNestedIfs++;
                        }
                    }
                    else
                    {
                        _cNestedIfs++;
                    }
                    break;

                case TAG_TYPE_ELSE:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  else w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ELSES,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    //
                    //  We got here because we just finished processing a
                    //  TRUE expression, so skip the else portion of the if
                    //

                    SkipConditionalBlock( &pchIn, pchEOF, NULL );

                    _cNestedIfs--;
                    break;

                case TAG_TYPE_END_IF:

                    if ( _cNestedIfs == 0 )
                    {
                        //
                        //  endif w/o an if
                        //

                        strError.FormatString( ODBCMSG_TOO_MANY_ENDIFS,
                                               NULL,
                                               HTTP_ODBC_DLL );
                        SetErrorText( strError.QueryStr());

                        goto ErrorExit;
                    }

                    _cNestedIfs--;
                    break;

                default:
                case TAG_TYPE_UNKNOWN:
                    goto UnknownTag;

                }
            }
            else
            {
UnknownTag:
                //
                //  Move past the beginning of the tag so the next
                //  search skips this tag
                //

                hr = SEND_DATA( pchIn, 1 );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                        "Error sending data, hr = 0x%x.\n",
                        hr ));

                    return hr;
                }

                pchIn += 1;
            }
        }
        else
        {
            //
            //  No more tags, copy the rest of the data to the output
            //  buffer.
            //

            hr = SEND_DATA( pchIn, (DWORD) -1 );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            break;
        }
    }

    //
    //  Send the last of the data and append the last buffer chain 
    //  if we're caching
    //

    err = pfnCallback( pvContext,
                       (CHAR *)_pbufOut->QueryPtr(),
                       cbOut );

    if ( err )
    {
        SetLastError( err );
        goto ErrorExit;
    }


    return S_OK;

ErrorExit:

    //
    //  We've already sent the HTTP headers at this point, so just 
    //  append the error text to the end of this document.
    //

    {
        STRA str;
        
        if ( !GetLastErrorText( &strError ) )
        {
            return E_FAIL;
        }                 
        
        hr = str.Append( "<h1>Error performing operation</h1>");
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        hr = str.Append( strError );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        hr = str.Append( "</body>" );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                    "Error appending error msg, hr = 0x%x.\n",
                    hr ));

            return hr;
        }

        err = pfnCallback( pvContext,
                           str.QueryStr(),
                           str.QueryCB() );

        if ( err )
        {
            hr = HRESULT_FROM_WIN32( err );

            DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

            return hr;
        }
    }

    return S_OK;
}

HRESULT
ODBC_REQ::NextRow(
    BOOL * pfLast
    )
/*++

Routine Description:

    Advances the result set to the next row

Arguments:

    pfLast - Set to TRUE if there is no more data

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( CheckSignature() );

    return _podbcstmt->QueryValuesAsStr( &_pstrValues,
                                         &_pcbValues,
                                         pfLast );
}

HRESULT
ODBC_REQ::ReplaceParams(
    BUFFER * pbufFile,
    PARAM_LIST* pParamList
    )
/*++

Routine Description:

    This method looks at the query file and replaces any occurrences
    of %xxx% with the specified replacement value from pszParams

Arguments:

    pbufFile - Contents of file buffer
    ParamList - List of parameters to replace in the query file

Return Value:

    HRESULT

--*/
{
    DWORD      cParams = 0;
    CHAR *     pch;
    BOOL       fIsMultiValue;
    CHAR *     pchValue;
    CHAR *     pchTag;
    CHAR *     pchTerm;
    CHAR *     pchOldPointer;
    CHAR *     pchTmp;
    STACK_STRA( strMultiValue, MAX_PATH );
    DWORD      cbFile;
    DWORD      cbTag;
    DWORD      cbValue;
    HRESULT    hr;
    CHAR       szSymbolValue[ 256 ];
    CHAR     * achSymbolValue = szSymbolValue;
    DWORD      dwSymbolValue = sizeof( szSymbolValue );

    DBG_ASSERT( CheckSignature() );

    //
    //  Scan the query file looking for %xxx% replacements
    //

    pch = pchOldPointer = (CHAR *) pbufFile->QueryPtr();
    cbFile = strlen( pch ) + sizeof( CHAR );

    while ( *pch )
    {
        if ( (pchTag = strchr( pch, '%' )) &&
             (pchTerm = strchr( pchTag + 1, '%' )) )
        {
            *pchTerm = '\0';

            //
            //  Was this a '%' escape (i.e., '%%')?
            //

            if ( (pchTag + 1) == pchTerm )
            {
                pchValue = "%";
                goto Found;
            }

            //
            //  Look through the replacement list for a matching param
            //

            pchValue = pParamList->FindValue( pchTag + 1, 
                                              &fIsMultiValue );

            if ( !pchValue )
            {
                //
                //  Check to see if it's something the client has 
                //  defined
                //

                if( _pECB->GetServerVariable( _pECB->ConnID,
                                              pchTag + 1,
                                              achSymbolValue,
                                              &dwSymbolValue ) )
                {
                    hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error copying symbol value, hr = 0x%x.\n",
                            hr ));

                        return hr;
                    }

                    pchValue = _strSymbolValue.QueryStr();
                    fIsMultiValue = FALSE;
                    goto Found;
                }
                
                if( dwSymbolValue > sizeof( szSymbolValue ) )
                {
                    achSymbolValue = ( CHAR * )_alloca( dwSymbolValue );
                    if( !achSymbolValue )
                    {
                        return E_OUTOFMEMORY;
                    }

                    if( _pECB->GetServerVariable( _pECB->ConnID,
                                                  pchTag + 1,
                                                  achSymbolValue,
                                                  &dwSymbolValue ) )
                    {
                        hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );
                        if( FAILED( hr ) )
                        {
                            DBGPRINTF(( DBG_CONTEXT,
                                "Error copying symbol value, hr = 0x%x.\n",
                                hr ));

                            return hr;
                        }

                        pchValue = _strSymbolValue.QueryStr();
                        fIsMultiValue = FALSE;
                        goto Found;
                    }
                }

                //
                //  We didn't find a match, nuke the tag
                //

                memmove( pchTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                pch = pchTag;
                continue;
            }

Found:

            if ( fIsMultiValue )
            {
                //
                //  Determine whether this is a quoted multi-value or 
                //  not
                //

                pchTmp = pchTag;

                while ( --pchTmp >= pchOldPointer && 
                        ISWHITE( *pchTmp ) )
                {
                    ;
                }

                hr = BuildMultiValue( pchValue,
                                       &strMultiValue,
                                       *pchTmp == '\'' );
                if ( FAILED( hr ) )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                            "Error in BuildMultiValue(), hr = 0x%x.\n",
                            hr ));

                    return hr;
                }

                pchValue = strMultiValue.QueryStr();
            }

            //
            //  We have a match, replace the tag with the value.
            //  Note we count the surrounding '%'s with cbTag.
            //

            cbTag    = DIFF( pchTerm - pchTag ) + sizeof( CHAR );
            cbValue  = strlen( pchValue );

            if ( cbValue > cbTag )
            {
                //
                //  Resize if needed but watch for pointer shift
                //

                if ( pbufFile->QuerySize() < (cbFile + cbValue - cbTag))
                {
                    if ( !pbufFile->Resize( cbFile + cbValue - cbTag, 
                                            512 ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error resizing the buffer.\n" ));

                        return HRESULT_FROM_WIN32( 
                                       ERROR_NOT_ENOUGH_MEMORY );
                    }

                    if ( pbufFile->QueryPtr() != pchOldPointer )
                    {
                        CHAR * pchNewPointer = 
                                     ( CHAR * ) pbufFile->QueryPtr();
                        DWORD  cchLen = strlen( pchNewPointer);

                        pch     = pchNewPointer + 
                                  ( pch - pchOldPointer );
                        pchTag  = pchNewPointer + 
                                  ( pchTag - pchOldPointer );
                        pchTerm = pchNewPointer + 
                                  ( pchTerm - pchOldPointer );
                        pchOldPointer = pchNewPointer;

                        DBG_ASSERT( pch >= pchNewPointer &&
                                   pch < pchNewPointer + cchLen);
                        DBG_ASSERT( pchTag >= pchNewPointer &&
                                   pchTag < pchNewPointer + cchLen);
                        DBG_ASSERT( pchTerm >= pchNewPointer &&
                                   pchTerm <= pchNewPointer + cchLen);
                    }
                }

                //
                //  Expand the space for the value
                //

                memmove( pchTerm + 1 + cbValue - cbTag,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                cbFile += cbValue - cbTag;
            }
            else
            {
                //
                //  Collapse the space since tag is longer then the 
                //  value
                //

                memmove( pchTag + cbValue,
                         pchTerm + 1,
                         strlen( pchTerm + 1 ) + sizeof( CHAR ) );

                cbFile -= cbTag - cbValue;
            }

            //
            //  Replace the tag value with the replacement value
            //

            memcpy( pchTag,
                    pchValue,
                    cbValue );
            pch = pchTag + cbValue;
        }
        else
        {
            //
            //  No more tags to replace so get out
            //

            break;
        }
    }

    return S_OK;
}

VOID
ODBC_REQ::LookupTag(
    CHAR *          pchBeginTag,
    const CHAR * *  ppchAfterTag,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue,
    enum TAG_TYPE * pTagType
    )
/*++

Routine Description:

    This method looks at the tag, determines the tag type and
    returns the associated value.  This is used only for the .htx file.

Arguments:

    pchBeginTag - Points to first character of tag (i.e., '<')
    ppchAfterTag - Receives the first character after the tag if
        the tag
    ppchValue - If the tag is a value, returns the database value
    pcbValue - Receives number of bytes in the value being returned
    pTagType - Returns the tag type

Return Value:

    NONE

--*/
{
    CHAR * pchTerm;
    BOOL   fLongTagMarker;
    STACK_STRA( strTagName, 128);
    DWORD  cchToCopy;
    BOOL   fDoEsc = FALSE;

    DBG_ASSERT( CheckSignature() );

    *pTagType = TAG_TYPE_UNKNOWN;
    *ppchAfterTag = pchBeginTag;
    *pcbValue = (DWORD) -1;

    DBG_ASSERT( !memcmp( pchBeginTag, "<!--%", 5 ) ||
                !memcmp( pchBeginTag, "<%", 2 ) );

    fLongTagMarker = pchBeginTag[1] == '!';

    //
    //  Move past the tag marker, 5 for "<!--%" and 2 for "<%"
    //

    pchBeginTag += (fLongTagMarker ? 5 : 2);

    if ( *pchBeginTag == '"' )
    {
        if ( !memcmp( pchBeginTag, "\"%z\",", sizeof("\"%z\",") - 1 ) )
        {
            fDoEsc = TRUE;
            pchBeginTag += sizeof("\"%z\",") - 1;
        }
        else
        {
            return;
        }
    }

    //
    //  Find the end of the tag and make a copy.
    //

    pchTerm = strchr( pchBeginTag, '%' );

    if ( !pchTerm )
    {
        return;
    }

    cchToCopy = DIFF(pchTerm - pchBeginTag);

    if ( FAILED( strTagName.Copy( pchBeginTag, 
                                  cchToCopy * sizeof( CHAR ) ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying BeginTag." ));

        return;
    }

    LookupSymbol( strTagName.QueryStr(),
                  pTagType,
                  ppchValue,
                  pcbValue );

    if ( fDoEsc && *pTagType == TAG_TYPE_VALUE )
    {
        *pTagType = TAG_TYPE_VALUE_TO_ESCAPE;
    }

    if ( *pTagType != TAG_TYPE_IF )
    {
        *ppchAfterTag = pchTerm + (fLongTagMarker ? 4 : 2);
    }
    else
    {
        //
        //  We leave the pointer on the expression if this was an if
        //

        *ppchAfterTag = NEXT_TOKEN(pchBeginTag);
    }

    *pchTerm = '%';
}

HRESULT
ODBC_REQ::LookupSymbol(
    const CHAR *    pchSymbolName,
    enum TAG_TYPE * pTagType,
    const CHAR * *  ppchValue,
    DWORD *         pcbValue
    )
/*++

Routine Description:

    Looks to see if the specified symbol name is defined and what 
    the type value of the symbol is.

    The "if" symbols is special cased to allow the expression to 
    follow it

    If the symbol is a multi-value field (from command line) then 
    the tabs in the value in will be replaced by commas.

Arguments:

    pchSymbolName - Name of zero terminated symbol to find
    pTagType - Returns the tag type of the symbol
    ppchValue - Returns a pointer to the string value of the symbol
                if it has one
    pcbValue - Returns length of value

Return Value:

    HRESULT

--*/
{
    BOOL     fIsMultiValue;
    CHAR     szSymbolValue[ 256 ];
    CHAR   * achSymbolValue = szSymbolValue;
    DWORD    dwSymbolValue = sizeof( szSymbolValue );
    HRESULT  hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  Does the symbol match one of the column names?
    //

    if ( _pstrCols && _pstrValues )
    {
        for ( DWORD i = 0; i < _cCols; i++ )
        {
            if ( !lstrcmpiA( _pstrCols[i].QueryStr(),
                            pchSymbolName ))
            {
                *pTagType = TAG_TYPE_VALUE;
                *ppchValue = _pstrValues[i].QueryStr();
                *pcbValue  = _pcbValues[i];

                //
                //  BugID 33406 - Don't return half DBCS char at end 
                //  of data
                //

                if ( g_fIsSystemDBCS )
                {
                    CHAR * pch;
                    for ( pch = (CHAR *)*ppchValue; *pch; pch++ )
                    {
                        if ( IsDBCSLeadByte( *pch ) )
                        {
                            if ( !*(pch+1) )
                            {
                                *pch = '\0';
                                (*pcbValue)--;
                                break;
                            }
                            pch++;
                        }
                    }
                }
                return S_OK;
            }
        }
    }

    //
    //  Does it match any of the special values?
    //

    if ( !_stricmp( pchSymbolName, BEGIN_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_BEGIN_DETAIL;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, END_DETAIL_TEXT ))
    {
        *pTagType = TAG_TYPE_END_DETAIL;
        return S_OK;
    }
    else if ( !_strnicmp( pchSymbolName, IF_TEXT, sizeof(IF_TEXT) - 1 ))
    {
        //
        //  The IF tag is treated a little bit differently cause we 
        //  expect the expression to be included as part of the 
        //  symbol
        //

        *pTagType = TAG_TYPE_IF;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, END_IF_TEXT ))
    {
        *pTagType = TAG_TYPE_END_IF;
        return S_OK;
    }
    else if ( !_stricmp( pchSymbolName, ELSE_TEXT ))
    {
        *pTagType = TAG_TYPE_ELSE;
        return S_OK;
    }

    //
    //  Is it one of the parameters from the query (either one of the 
    //  form fields or from the DefaultParameters field in the wdg 
    //  file)?  These must be prefixed by "idc.", that is 
    //  "<%idc.Assign%>"
    //

    if ( !_strnicmp( pchSymbolName, "idc.", 4 )    &&
         (*ppchValue = _plParams.FindValue( pchSymbolName + 4,
                                            &fIsMultiValue,
                                            pcbValue )) ) 
    {
        *pTagType = TAG_TYPE_VALUE;

        //
        //  If this is a multi-value field, replace all the tabs with 
        //  commas. This is somewhat of a hack as it breaks the use of 
        //  this field when multiple queries are supported
        //

        if ( fIsMultiValue )
        {
            CHAR * pchtmp = (CHAR *) *ppchValue;

            while ( pchtmp = strchr( pchtmp, '\t' ))
            {
                *pchtmp = ',';
            }
        }

        return S_OK;
    }

    //
    //  Lastly, check to see if it's something the client has defined
    //

    if( !_pECB->GetServerVariable( _pECB->ConnID,
                                   ( LPSTR )pchSymbolName,
                                   achSymbolValue,
                                   &dwSymbolValue ) &&
        dwSymbolValue <= sizeof( szSymbolValue ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error getting server variable." ));

        return E_FAIL;
    }

    if( dwSymbolValue > sizeof( szSymbolValue ) )
    {
        achSymbolValue = ( CHAR * )_alloca( dwSymbolValue );
        if( !achSymbolValue )
        {
            return E_OUTOFMEMORY;
        }

        if( !_pECB->GetServerVariable( _pECB->ConnID,
                                       ( LPSTR )pchSymbolName,
                                       achSymbolValue,
                                       &dwSymbolValue ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error getting server variable." ));

            return E_FAIL;
        }
    }

    hr = _strSymbolValue.Copy( achSymbolValue, dwSymbolValue );
    if( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying symbol value, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    *pTagType  = TAG_TYPE_VALUE;
    *ppchValue = _strSymbolValue.QueryStr();
    *pcbValue  = _strSymbolValue.QueryCB();

    return S_OK;
}

HRESULT
ODBC_REQ::EvaluateExpression(
    const CHAR * * ppchExpression,
    BOOL *         pfExprValue
    )
/*++

Routine Description:

    Performs simple expression evaluation for an 'if' tag in the
    template file.  Valid expressions are:

    <%if <V1> <OP> <V2>%>

    where V1, V2 can be one of:
        Positive integer
        TotalRecords - Total records contained in result set
        MaxRecords - The maximum records specified in the query file

    OP can be one of:
        EQ - Equal
        LT - Less then
        GT - Greater then

Arguments:

    ppchExpression - Points to V1 on entry, set to the first character
                     after the end tag on exit
    pfExprValue - TRUE if the expression is TRUE, FALSE otherwise

Return Value:

    HRESULT

--*/
{
    EXPR_VALUE v1( this );
    EXPR_VALUE v2( this );
    TAG_TYPE   OpType;
    STRA       strError;
    CHAR *     pch;

    DBG_ASSERT( CheckSignature() );

    if ( !v1.Evaluate( ppchExpression )               ||
         FAILED(EvaluateOperator( ppchExpression, &OpType )) ||
         !v2.Evaluate( ppchExpression ))
    {
        return E_FAIL;
    }

    //
    //  If the symbols weren't found, default them to empty
    //  strings
    //

    if ( v1.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v1.SetType( TAG_TYPE_STRING );
    }

    if ( v2.QueryType() == TAG_TYPE_UNKNOWN )
    {
        v2.SetType( TAG_TYPE_STRING );
    }

    //
    //  The value types must match
    //

    if ( v1.QueryType() != v2.QueryType() )
    {
        BOOL fSt = FALSE;

        if ( v1.QueryType() == TAG_TYPE_STRING && v2.QueryType() == TAG_TYPE_INTEGER )
            fSt = v1.ConvertToInteger();
        else if ( v1.QueryType() == TAG_TYPE_INTEGER && v2.QueryType() == TAG_TYPE_STRING )
            fSt = v2.ConvertToInteger();

        if ( !fSt )
        {
            strError.FormatString( ODBCMSG_MISMATCHED_VALUES,
                                   NULL,
                                   HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return E_FAIL;
        }
    }

    //
    //  Move the current position to the end of this tag
    //

    if ( pch = strchr( *ppchExpression, '>' ))
    {
        *ppchExpression = pch + 1;
    }

    switch ( OpType )
    {
    case TAG_TYPE_OP_LT:

        *pfExprValue = v1.LT( v2 );
        break;

    case TAG_TYPE_OP_GT:

        *pfExprValue = v1.GT( v2 );
        break;

    case TAG_TYPE_OP_EQ:

        *pfExprValue = v1.EQ( v2 );
        break;

    case TAG_TYPE_OP_CONTAINS:

        //
        //  Contains is only valid for string values
        //

        if ( v1.QueryType() != TAG_TYPE_STRING )
        {
            strError.FormatString( 
                           ODBCMSG_CONTAINS_ONLY_VALID_ON_STRINGS,
                           NULL,
                           HTTP_ODBC_DLL );
            SetErrorText( strError.QueryStr());

            return E_FAIL;
        }

        *pfExprValue = v1.CONTAINS( v2 );
        break;

    default:

        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    return S_OK;
}

HRESULT
ODBC_REQ::EvaluateOperator(
    const CHAR * * ppchExpression,
    TAG_TYPE *     pTagType
    )
/*++

Routine Description:

    Determines which operator is being used in this expression

Arguments:

    ppchExpression - Points to the operator on entry, set to the
        next token on exit
    pTagType - Receives operator type

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DBG_ASSERT( CheckSignature() );

    if ( COMP_FIELD( *ppchExpression, "GT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_GT;
    }
    else if ( COMP_FIELD( *ppchExpression, "LT", 2 ))
    {
        *pTagType = TAG_TYPE_OP_LT;
    }
    else if ( COMP_FIELD( *ppchExpression, "EQ", 2 ))
    {
        *pTagType = TAG_TYPE_OP_EQ;
    }
    else if ( COMP_FIELD( *ppchExpression, "CONTAINS", 8 ))
    {
        *pTagType = TAG_TYPE_OP_CONTAINS;
    }
    else
    {
        //
        //  Unknown operator specified
        //

        STRA strError;

        strError.FormatString( ODBCMSG_UNRECOGNIZED_OPERATOR,
                               NULL,
                               HTTP_ODBC_DLL );
        SetErrorText( strError.QueryStr());
        return E_FAIL;
    }

    *ppchExpression = NEXT_TOKEN( *ppchExpression );

    return S_OK;
}

HRESULT
ODBC_REQ::SendData(
    ODBC_REQ_CALLBACK        pfnCallback,
    PVOID                    pvContext,
    const CHAR *             pbData,
    DWORD                    cbData,
    BUFFER_CHAIN_ITEM  * *   ppbufOut,
    DWORD *                  pcbOut
    )
/*++

Routine Description:

    This method buffers the outgoing data and sends it when the
    output buffer is full

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pbData - Pointer to data to send
    cbData - Number of bytes to send
    ppbufOut - Output buffer to buffer nonsent and cached data in
    pcbOut - Number of valid bytes in output buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD               cbToCopy;
    DWORD               err;
    BUFFER_CHAIN_ITEM * pbufOut = *ppbufOut;
    STACK_STRA(         strTemp, MAX_PATH);
    HRESULT             hr;

    DBG_ASSERT( CheckSignature() );

    //
    //  if cbData is -1 then assume the data is zero terminated
    //

    if ( cbData == -1 )
    {
        cbData = strlen( pbData );
    }

    //
    //  Convert the string from shift_jis to iso-2022-jp or euc-jp
    //

    if ( CODE_ONLY_SBCS != _nCharset )
    {
        int cbUNIXSize;
        int nResult;

        //
        //  Get the size after Conversion
        //

        cbUNIXSize = PC_to_UNIX( GetACP(),
                                 _nCharset,
                                 (UCHAR *)pbData,
                                 (int)cbData,
                                 NULL,
                                 0 );

        hr = strTemp.Resize( cbUNIXSize + sizeof(CHAR) );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error resizing string buffer, hr = 0x%x.\n",
                hr ));

            return hr;
        }

        //
        //  Do conversion
        //

        nResult = PC_to_UNIX( GetACP(),
                              _nCharset,
                              (UCHAR *)pbData,
                              (int)cbData,
                              (UCHAR *)strTemp.QueryStr(),
                              cbUNIXSize );
        if ( -1 == nResult || nResult != cbUNIXSize )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error converting data.\n" ));

            return E_FAIL;
        }

        //
        //  update the string pointer and count
        //

        pbData = strTemp.QueryStr();
        cbData = cbUNIXSize;

        *(strTemp.QueryStr() + cbUNIXSize) = '\0';
    }

    //
    //  Append the new data onto the old data
    //

    cbToCopy = min( cbData, OUTPUT_BUFFER_SIZE - *pcbOut );

    memcpy( (BYTE *) pbufOut->QueryPtr() + *pcbOut,
            pbData,
            cbToCopy );

    *pcbOut += cbToCopy;
    cbData  -= cbToCopy;
    pbData  += cbToCopy;

    //
    //  If we filled up the buffer, send the data
    //

    if ( cbData )
    {
        err = pfnCallback( pvContext,
                           (CHAR *) pbufOut->QueryPtr(),
                           *pcbOut );

        if ( err )
        {
            hr = HRESULT_FROM_WIN32( err );
            
            DBGPRINTF(( DBG_CONTEXT,
                "Error sending the data, hr = 0x%x.\n",
                hr ));

            return hr;
        }

        *pcbOut = 0;
    }
    else
    {
        return S_OK;
    }

    //
    //  We know at this point the output buffer is empty
    //

    while ( cbData )
    {
        //
        //  If the input data will fill the output buffer, send the
        //  data directly from the input buffer
        //

        if ( cbData > OUTPUT_BUFFER_SIZE  )
        {
            err = pfnCallback( pvContext,
                               pbData,
                               OUTPUT_BUFFER_SIZE );

            if ( err )
            {
                hr = HRESULT_FROM_WIN32( err );
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending the data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            cbData -= OUTPUT_BUFFER_SIZE;
            pbData += OUTPUT_BUFFER_SIZE;
        }
        else
        {
            //
            //  We don't have enough to send so put it in the output buffer
            //

            memcpy( pbufOut->QueryPtr(),
                    pbData,
                    cbData );

            *pcbOut = cbData;
            break;
        }
    }

    return S_OK;
}


BOOL
ODBC_REQ::SkipConditionalBlock(
    const CHAR * *  ppchIn,
    const CHAR *    pchEOF,
    const CHAR *    pchSearchTag
    )
/*++

Routine Description:

    Skip a conditional block delimited by ENDIF or specified Tag
    returns TRUE if specified Tag found instead of ENDIF or end 
    of text

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchIf;
    const CHAR * pchEndif;
    const CHAR * pchTag;
    int cLev = 0;

    DBG_ASSERT( CheckSignature() );

    for ( ; pchIn < pchEOF ; )
    {
        pchEndif = pchIf = pchIn;
        SkipToTag( &pchIf, IF_TEXT );
        SkipToTag( &pchEndif, END_IF_TEXT );
        if ( pchSearchTag == NULL )
        {
            pchTag = pchEOF;
        }
        else
        {
            pchTag = pchIn;
            SkipToTag( &pchTag,  pchSearchTag );
        }
        if ( pchIf < pchTag && pchIf < pchEndif )
        {
            ++cLev;
            pchIn = pchIf;
        }
        else if ( pchTag < pchIf && pchTag < pchEndif )
        {
            if ( !cLev )
            {
                *ppchIn = pchTag;
                return TRUE;
            }
            pchIn = pchTag;
        }
        else    // END_IF_TEXT or nothing found
        {
            if ( !cLev )
            {
                *ppchIn = pchEndif;
                return FALSE;
            }
            --cLev;
            pchIn = pchEndif;
        }
    }

    // else/endif not found

    *ppchIn = pchEOF;

    return FALSE;
}


VOID
ODBC_REQ::SkipToTag(
    const CHAR * *  ppchIn,
    const CHAR *    pchTag
    )
/*++

Routine Description:

    Given the name of a tag, skips to the first character after the tag

Arguments:

    ppchIn - Text stream to scan for tag
    pchTag - Name of tag (w/o '<%%>') to find and skip

--*/
{
    const CHAR * pchIn = *ppchIn;
    DWORD  cchTag;

    DBG_ASSERT( CheckSignature() );

    cchTag = strlen( pchTag );

    while ( pchIn = strchr( pchIn, '<' ))
    {
        if ( (!memcmp( pchIn, "<!--%", 5 ) ||
              !memcmp( pchIn, "<%", 2 ))   &&
              !_strnicmp( pchIn + (pchIn[1] == '!' ? 5 : 2),
                         pchTag,
                         cchTag ))
        {
            goto Found;
        }
        else
            pchIn++;
    }

    //
    //  Not found, return the end of file
    //

    *ppchIn += strlen( *ppchIn );

    return;

Found:

    pchIn = strchr( pchIn + cchTag, '>' );
    if ( !pchIn )
    {
        *ppchIn += strlen( *ppchIn );
    }
    else
    {
        *ppchIn = pchIn + 1;
    }

    return;
}

BOOL
ODBC_REQ::IsEqual(
    ODBC_REQ * podbcreq
    )
/*++

Routine Description:

    Determines if the passed query's parameter would make it equivalent
    to this query

    A query is deemed equal if:

        1) The query has the same number of parameters passed from the 
           client
        2) The query's parameters match

    Note parameter comparison is case insensitive for both the field 
    and the value

    The template can be different if it's parameterized, but we'll pick 
    up the difference in the parameter list in this case.

    Since podbcreq is a query that has already been processed, it may 
    contain additional values from the .wdg default list.

Arguments:

    podbcreq - Query to check for equality

--*/
{
    VOID * pCookie = NULL;
    CHAR * pszField;
    CHAR * pszValue1, * pszValue2;

    DBG_ASSERT( CheckSignature() );

    //
    //  First compare the number of parameters passed from the client
    //

    if ( QueryClientParamCount() != podbcreq->QueryClientParamCount() )
    {
        return FALSE;
    }

    //
    //  Walk the list of parameters making sure they all match
    //

    while ( pCookie = podbcreq->_plParams.NextPair( pCookie,
                                                    &pszField,
                                                    &pszValue1 ))
    {
        if ( !(pszValue2 = _plParams.FindValue( pszField )) ||
             lstrcmpiA( pszValue1, pszValue2 ) )
        {
            //
            //  Either the value wasn't found or it doesn't match,
            //  the queries are not equal
            //

            return FALSE;
        }
    }

    //
    //  The queries are equal
    //

    return TRUE;
}

HRESULT
ODBC_REQ::AppendHeaders(
    STRA * pstrHeaders
    )
/*++

Routine Description:

    Adds any headers required for this query, this will generally be
    the content type and an Expires header if this query is cached

Arguments:

    pstrHeaders - String to append headers to

--*/
{
    CHAR *     pszTail;
    HRESULT    hr;

    DBG_ASSERT( CheckSignature() );

    //
    // The length of the content type is less than 255
    //
    hr = pstrHeaders->Resize( 255 );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error resizing the header string buffer, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    pszTail = pstrHeaders->QueryStr();


    pszTail += wsprintfA( pszTail,
                          "Content-Type: %s\r\n\r\n",
                          QueryContentType() );

    return S_OK;
}

BOOL
ODBC_REQ::GetLastErrorText(
    STRA * pstrError
    )
{
    DBG_ASSERT( CheckSignature() );

    //
    //  If we stored an error explanation return that, otherwise fall back
    //  to an ODBC error
    //

    if ( !_strErrorText.IsEmpty() )
    {
        if( FAILED( pstrError->Copy( _strErrorText ) ) )
        {
            return FALSE;
        }

        return TRUE;
    }
    else if ( _podbcstmt )
    {
        return _podbcstmt->GetLastErrorTextAsHtml( pstrError );
    }
    else
    {
        return QueryOdbcConnection()->GetLastErrorTextAsHtml( pstrError,
                                       SQL_NULL_HSTMT,
                                       QueryOdbcConnection()->QueryErrorCode() );
    }
}

//static
HRESULT
ODBC_REQ::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize ODBC_REQ lookaside

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;

    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( ODBC_REQ );

    DBG_ASSERT( sm_pachOdbcRequests == NULL );
    
    sm_pachOdbcRequests = new ALLOC_CACHE_HANDLER( "ODBC_REQ",  
                                                   &acConfig );

    if ( sm_pachOdbcRequests == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
ODBC_REQ::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate ODBC_REQ lookaside

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pachOdbcRequests != NULL )
    {
        delete sm_pachOdbcRequests;
        sm_pachOdbcRequests = NULL;
    }
}

BOOL
EXPR_VALUE::ConvertToInteger(
    VOID )
{
    if ( _tagType == TAG_TYPE_STRING )
    {
        PSTR pS =_strValue.QueryStr();
        if ( *pS == '-' || isdigit(*(UCHAR *)pS) )
        {
            _dwValue = atoi( pS );
            _tagType = TAG_TYPE_INTEGER;

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
EXPR_VALUE::Evaluate(
    const CHAR * * ppchIn
    )
/*++

Routine Description:

    Determines the type of value and retrieves the value appropriately

Arguments:

    ppchIn - Pointer to first character of value on way in, next token
        on they way out

--*/
{
    const CHAR * pchIn = *ppchIn;
    const CHAR * pchEnd;
    const CHAR * pchValue;
    DWORD        cbValue;
    STRA         strError;
    DWORD        cchToCopy;

    if ( isdigit( *(UCHAR *)pchIn ) )
    {
        //
        //  Simple number
        //

        _tagType = TAG_TYPE_INTEGER;
        _dwValue = atoi( pchIn );
        while ( isdigit( *(UCHAR *)pchIn ) )
        {
            pchIn++;
        }

        *ppchIn  = SkipWhite( pchIn );
    }
    else if ( *pchIn == '"' )
    {
        //
        //  Simple string, find the closing quote
        //

        pchEnd = strchr( ++pchIn, '\"' );

        if ( !pchEnd )
        {
            strError.FormatString( ODBCMSG_UNBALANCED_STRING,
                                   NULL,
                                   HTTP_ODBC_DLL );
            _podbcreq->SetErrorText( strError.QueryStr());

            return FALSE;
        }

        cchToCopy = DIFF(pchEnd - pchIn);

        if ( FAILED( _strValue.Copy( pchIn, 
                                     cchToCopy * sizeof(CHAR) ) ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "Error copying the value." ));

            return FALSE;
        }

        _tagType = TAG_TYPE_STRING;
        *ppchIn = SkipWhite( pchEnd + 1 );
    }
    else
    {
        STACK_STRA( strSymbol, 64 );

        //
        //  This is a keyword we need to interpret
        //

        //
        //  These fields are delimited with either white space
        //  or '\'' or the closing %>
        //

        pchEnd = pchIn;

        if ( *pchEnd == '\'' )
        {
            ++pchIn;
            ++pchEnd;
            while ( *pchEnd && *pchEnd != '\'' && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }
        else
        {
            while ( *pchEnd && !ISWHITE( *pchEnd ) && *pchEnd != '%' )
            {
                pchEnd++;
            }
        }

        if ( COMP_FIELD( "MaxRecords", pchIn, 10 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryMaxRecords();
        }
        else if ( COMP_FIELD( "CurrentRecord", pchIn, 12 ))
        {
            _tagType = TAG_TYPE_INTEGER;
            _dwValue = _podbcreq->QueryCurrentRecordNum();
        }
        else
        {
            //
            //  Isolate the symbol name
            //

            cchToCopy = DIFF(pchEnd - pchIn);

            if ( FAILED( strSymbol.Copy( pchIn, 
                                         cchToCopy * sizeof(CHAR) ) ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error copying symbol name." ));

                return FALSE;
            }

            //
            //  Look up the symbol
            //

            if ( FAILED( _podbcreq->LookupSymbol( 
                                           strSymbol.QueryStr(),
                                           &_tagType,
                                           &pchValue,
                                           &cbValue ) ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Error in LookupSymbol()." ));

                return FALSE;
            }

            if ( _tagType == TAG_TYPE_VALUE ||
                 _tagType == TAG_TYPE_STRING )
            {
                if ( FAILED( _strValue.Copy( pchValue ) ) )
                { 
                    DBGPRINTF(( DBG_CONTEXT,
                                "Error copying tag value." ));
        
                    return FALSE;
                }

                _tagType = TAG_TYPE_STRING;
            }
        }

        if ( *pchEnd == '\'' )
        {
            ++pchEnd;
        }

        *ppchIn = SkipWhite( pchEnd );
    }

    return TRUE;
}

BOOL
EXPR_VALUE::GT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Greater Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() > v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) > 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::LT(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Less Then v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() < v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) < 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::EQ(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this is Equal to v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() == TAG_TYPE_INTEGER )
    {
        return QueryInteger() == v1.QueryInteger();
    }
    else
    {
        return lstrcmpiA( QueryStr(), v1.QueryStr() ) == 0;
    }

    return FALSE;
}

BOOL
EXPR_VALUE::CONTAINS(
    EXPR_VALUE & v1
    )
/*++

Routine Description:

    Returns TRUE if *this contains the string in v1

Arguments:

    v1 - Value for right side of the expression

--*/
{
    if ( QueryType() != TAG_TYPE_STRING     ||
         v1.QueryType() != TAG_TYPE_STRING )
    {
        return FALSE;
    }

    //
    //  Upper case the strings then do a search
    //

    UpperCase();
    v1.UpperCase();

    return strstr( QueryStr(), v1.QueryStr() ) != NULL;
}


const CHAR * SkipNonWhite( const CHAR * pch )
{
    while ( *pch && !ISWHITE( *pch ) && *pch != '\n' )
        pch++;

    return pch;
}

const CHAR * SkipTo( const CHAR * pch, CHAR ch )
{
    while ( *pch && *pch != '\n' && *pch != ch )
        pch++;

    return pch;
}

const CHAR * SkipWhite( const CHAR * pch )
{
    while ( ISWHITE( *pch ) )
    {
        pch++;
    }

    return pch;
}

struct _ODBC_OPTIONS
{
    CHAR *   pszOptionName;
    DWORD    dwOption;
    BOOL     fNumeric;
}

OdbcOptions[] =
{
    //
    //  Order roughly in order of likelihood of being used
    //

    "SQL_OPT_TRACEFILE",       SQL_OPT_TRACEFILE,     FALSE,
    "SQL_QUERY_TIMEOUT",       SQL_QUERY_TIMEOUT,     TRUE,
    "SQL_MAX_ROWS",            SQL_MAX_ROWS,          TRUE,
    "SQL_LOGIN_TIMEOUT",       SQL_LOGIN_TIMEOUT,     TRUE,
    "SQL_PACKET_SIZE",         SQL_PACKET_SIZE,       TRUE,

    "SQL_NOSCAN",              SQL_NOSCAN,            TRUE,
    "SQL_MAX_LENGTH",          SQL_MAX_LENGTH,        TRUE,
    "SQL_ASYNC_ENABLE",        SQL_ASYNC_ENABLE,      TRUE,
    "SQL_ACCESS_MODE",         SQL_ACCESS_MODE,       TRUE,
    "SQL_OPT_TRACE",           SQL_OPT_TRACE,         TRUE,
    "SQL_TRANSLATE_OPTION",    SQL_TRANSLATE_OPTION,  TRUE,
    "SQL_TXN_ISOLATION",       SQL_TXN_ISOLATION,     TRUE,
    "SQL_TRANSLATE_DLL",       SQL_TRANSLATE_DLL,     FALSE,
    "SQL_CURRENT_QUALIFIER",   SQL_CURRENT_QUALIFIER, FALSE,
    NULL,                      0,                     0
};

HRESULT
SetOdbcOptions(
    ODBC_CONNECTION * pOdbcConn,
    STRA *            pStrOptions
    )
/*++

Routine Description:

    Sets the options specified in the OdbcOptions: keyword of the 
    .idc file

Arguments:

    pOdbcConn - ODBC connection to set options on
    pStrOptions - List of options in "v=f,y=z" format.  

--*/
{
    PARAM_LIST OptionList;
    VOID *     pvCookie = NULL;
    CHAR *     pszField;
    CHAR *     pszValue;
    DWORD      dwOption;
    SQLULEN    dwValue;
    DWORD      i;
    HRESULT    hr;

    hr = OptionList.ParsePairs( pStrOptions->QueryStr(),
                                FALSE,
                                FALSE );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error in ParsePairs(), hr = 0x%x.\n",
            hr ));

        return hr;
    }

    while ( pvCookie = OptionList.NextPair( pvCookie,
                                            &pszField,
                                            &pszValue ))
    {
        //
        //  If the field is a digit, then this is a driver specific 
        //  option. convert the value and field as appropriate,
        //  otherwise look it up in our option table
        //

        if ( isdigit( *(UCHAR *)pszField ))
        {
            dwOption = atoi( pszField );

            if ( isdigit( *(UCHAR *)pszValue ))
            {
                dwValue = ( SQLULEN )atoi( pszValue );
            }
            else
            {
                dwValue = ( SQLULEN ) pszValue;    
            }
        }
        else
        {
            i = 0;

            while ( OdbcOptions[i].pszOptionName )
            {
                if ( !_stricmp( OdbcOptions[i].pszOptionName,
                               pszField ))
                {
                    goto Found;
                }

                i++;
            }

            //
            //  Not found, skip this value
            //

            continue;

Found:
            dwOption = OdbcOptions[i].dwOption;

            if ( OdbcOptions[i].fNumeric )
            {
                //
                //  Numeric option, convert the value
                //

                dwValue = ( SQLULEN )atoi( pszValue );
            }
            else
            {
                dwValue = ( SQLULEN ) pszValue;     
            }
        }

        pOdbcConn->SetConnectOption( ( UWORD ) dwOption, 
                                     dwValue );
    }

    return S_OK;
}

HRESULT
BuildMultiValue(
    const CHAR * pchValue,
    STRA *        pstrMulti,
    BOOL         fQuoteElements
    )
{
    CHAR *  pchtmp = (CHAR *) pchValue;
    DWORD   cElements = 0;
    HRESULT hr;

    //
    //  If we're going to have to expand the size of the string, 
    //  figure out the total size we'll need now
    //

    if ( fQuoteElements )
    {
        while ( pchtmp = strchr( pchtmp, '\t' ))
        {
            cElements++;
            pchtmp++;
        }

        hr = pstrMulti->Resize( strlen( pchValue ) + 1 + 2 * cElements );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    hr = pstrMulti->Copy( pchValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error copying value, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    //
    //  Replace tabs with "','" if fQuoteElements is TRUE, 
    //  otherwise just ','
    //

    pchtmp = pstrMulti->QueryStr();

    while ( pchtmp = strchr( pchtmp, '\t' ))
    {
        if ( fQuoteElements )
        {
            memmove( pchtmp + 3,
                     pchtmp + 1,
                     strlen( pchtmp + 1 ) + sizeof(CHAR));

            memcpy( pchtmp, "','", 3 );
        }
        else
        {
            *pchtmp = ',';
        }
    }

    return S_OK;
}


//
//  Converts a value between zero and fifteen to the appropriate hex digit
//

#define HEXDIGIT( nDigit )                              \
     (CHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + 'A'                           \
        : (nDigit) + '0')


HRESULT 
ODBC_REQ::SendEscapedData(
    ODBC_REQ_CALLBACK pfnCallback,
    PVOID             pvContext,
    PCSTR             pch,
    DWORD             cbIn,
    LPDWORD           pcbOut 
    )
/*++

Routine Description:

    This method escape the outgoing data and then send it to the
    SendData() function

Arguments:

    pfnCallback - Send callback function
    pvContext - Context for send callback
    pch - Pointer to data to send
    cbIn - Number of bytes to send
    pcbOut - Number of valid bytes in output buffer

Return Value:

    HRESLUT

--*/
{
    CHAR    ch;
    int     cNonEscaped = 0;
    DWORD   cbOut;
    HRESULT hr;

    #define SEND_DATA2( pchData, cbData )  SendData( pfnCallback,  \
                                                    pvContext,     \
                                                    (pchData),     \
                                                    (cbData),      \
                                                    &_pbufOut,     \
                                                    pcbOut )

    if ( cbIn == (DWORD)-1 )
    {
        cbIn = strlen( pch );
    }

    while ( cbIn-- )
    {
        ch = *pch;

        //
        //  Escape characters that are in the non-printable range
        //  but ignore CR and LF
        //

        if ( (((ch >= 0)   && (ch <= 32)) ||
              ((ch >= 128) && (ch <= 159))||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&')) 
              && !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            CHAR achTmp[3];

            //
            //  Insert the escape character
            //

            achTmp[0] = TEXT('%');

            //
            //  Convert the low then the high character to hex
            //

            UINT nDigit = (UINT)(ch % 16);

            achTmp[2] = HEXDIGIT( nDigit );

            ch /= 16;
            nDigit = (UINT)(ch % 16);

            achTmp[1] = HEXDIGIT( nDigit );

            hr = SEND_DATA2( pch-cNonEscaped, cNonEscaped );
            if ( cNonEscaped && FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            hr = SEND_DATA2( achTmp, sizeof(achTmp) );
            if ( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Error sending data, hr = 0x%x.\n",
                    hr ));

                return hr;
            }

            cNonEscaped = 0;
        }
        else
        {
            ++cNonEscaped;
        }

        ++pch;
    }

    hr = SEND_DATA2( pch-cNonEscaped, cNonEscaped );
    if ( cNonEscaped && FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
            "Error sending data, hr = 0x%x.\n",
            hr ));

        return hr;
    }

    return S_OK;
}

HRESULT
GetFileData(
    IN     const CHAR *             pchFile,
    OUT    BYTE * *                 ppbData,
    OUT    DWORD *                  pcbData,
    IN     int                      nCharset,
    IN     BOOL                     fUseWin32Canon
    )
/*++
    Description:

        Attempts to retrieve the passed file from the cache.  If it's 
        not cached, then we read the file and add it to the cache.

    Arguments:

        pchFile - Fully qualified file to retrieve
        pcbData - Receives pointer to first byte of data, used as handle 
                  to free data
        pcbSize - Size of output buffer
        pCacheFileInfo - File cache information
        nCharset - Charset (if this isn't SJIS, we convert it to SJIS
            before Check-In)
        ppSecDesc - Returns security descriptor if not null
        fUseWin32Canon - The resource has not been canonicalized and 
                         it's ok to use the win32 canonicalization code

    Returns:
        HRESULT

    Notes:

        The file is extended by two bytes and is appended with two zero 
        bytes,thus callers are guaranteed of a zero terminated text file.

--*/
{
    DWORD                   cbLow, cbHigh;
    BYTE *                  pbData = NULL;
    BYTE *                  pbBuff = NULL;
    int                     cbSJISSize;
    HRESULT                 hr;

    HANDLE hFile = CreateFileA( pchFile,
                                GENERIC_READ,
                                FILE_SHARE_READ  | 
                                FILE_SHARE_WRITE | 
                                FILE_SHARE_DELETE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN | 
                                FILE_FLAG_OVERLAPPED      | 
                                FILE_FLAG_BACKUP_SEMANTICS,
                                NULL );

	if ( hFile == INVALID_HANDLE_VALUE)
	{
		hr = HRESULT_FROM_WIN32( GetLastError() );

		goto ErrorExit;
	}
	else
	{
		WIN32_FILE_ATTRIBUTE_DATA    FileAttributes; 		
		
		if ( !GetFileAttributesExA( pchFile,
							        GetFileExInfoStandard, 
								    &FileAttributes ) )
		{
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                "Error in GetFileAttributesExA, hr = 0x%x.\n",
                hr ));

			goto ErrorExit;
		}
	
		cbHigh = FileAttributes.nFileSizeHigh;
		cbLow = FileAttributes.nFileSizeLow;
	}
    //
    //  Limit the file size to 128k
    //

    if ( cbHigh || cbLow > 131072L )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto ErrorExit;
    }

    if ( CODE_ONLY_SBCS != nCharset )
    {
        if ( !( pbBuff = pbData = (BYTE *) LocalAlloc( LPTR, cbLow ) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY);
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
    }
    else 
	{
        if ( !(pbData = (BYTE *) LocalAlloc( LPTR, 
                                             cbLow + sizeof(WCHAR)) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
    }        

    //
    //  Read the file data
    //

    hr = DoSynchronousReadFile( hFile,
                                ( PCHAR )pbData,
                                cbLow,
                                pcbData,
                                NULL );
    if ( FAILED( hr ) ) 
	{
        DBGPRINTF(( DBG_CONTEXT,
        "Error in DoSynchronousReadFile(), hr = 0x%x.\n",
        hr ));

        goto ErrorExit;
    }
	
	if ( CODE_ONLY_SBCS != nCharset )
    {
        pbData = NULL;

        //
        //  get the length after conversion
        //

        cbSJISSize = UNIX_to_PC( GetACP(),
                                 nCharset,
                                 pbBuff,
                                 *pcbData,
                                 NULL,
                                 0 );
        DBG_ASSERT( cbSJISSize <= (int)cbLow );
		
        if ( !(pbData = (BYTE *) LocalAlloc( 
                                      LPTR, 
                                      cbSJISSize + sizeof(WCHAR)) ) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                "Error allocating memory, hr = 0x%x.\n",
                hr ));

            goto ErrorExit;
        }
        
        //
        //  conversion
        //

        UNIX_to_PC( GetACP(),
                    nCharset,
                    pbBuff,
                    *pcbData,
                    pbData,
                    cbSJISSize );
        *pcbData = cbLow = cbSJISSize;
    }

    DBG_ASSERT( *pcbData <= cbLow );

    //
    //  Zero terminate the file for both ANSI and Unicode files
    //

    *((WCHAR UNALIGNED *)(pbData + cbLow)) = L'\0';

    *pcbData += sizeof(WCHAR);

	*ppbData = pbData;

	DBG_REQUIRE( CloseHandle(hFile) );

    if ( pbBuff )
    {
        LocalFree( pbBuff );
    }

    return S_OK;

ErrorExit:

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        DBG_REQUIRE( CloseHandle(hFile) );
    }

    if ( pbBuff )
    {
        if ( pbBuff == pbData )
        {
             pbData = NULL;
        }
        LocalFree( pbBuff );
    }

    if ( pbData )
    {
       DBG_REQUIRE( LocalFree(pbData));
    }

    return hr;
}

HRESULT
DoSynchronousReadFile(
    IN HANDLE hFile,
    IN PCHAR  Buffer,
    IN DWORD  nBuffer,
    OUT PDWORD nRead,
    IN LPOVERLAPPED Overlapped
    )
/*++

    Description:
        Does Asynchronous file reads.  Assumes that NT handles are
        opened for OVERLAPPED I/O, win95 handles are not.

    Arguments:
        hFile - Handle to use for the read
        Buffer - Buffer to read with
        nBuffer - size of buffer
        nRead - returns the number of bytes read
        Overlapped - user supplied overlapped structure

    Returns:
        TRUE/FALSE
--*/
{
    BOOL        fNewEvent = FALSE;
    OVERLAPPED  ov;
    BOOL        fRet = FALSE;
    DWORD       err = NO_ERROR;
    
	if ( Overlapped == NULL ) 
	{

        Overlapped = &ov;
        ov.Offset = 0;
        ov.OffsetHigh = 0;
        ov.hEvent = IIS_CREATE_EVENT(
                        "OVERLAPPED::hEvent",
                        &ov,
                        TRUE,
                        FALSE
                        );

        if ( ov.hEvent == NULL ) 
        {    
            err = GetLastError();
            DBGPRINTF( ( DBG_CONTEXT,
                         "CreateEvent failed with %d\n",
                         err ) );
            goto ErrorExit;
        }

        fNewEvent = TRUE;
    }

    if ( !ReadFile( hFile,
                    Buffer,
                    nBuffer,
                    nRead,
                    Overlapped )) 
	{

        err = GetLastError();

        if ( ( err != ERROR_IO_PENDING ) &&
             ( err != ERROR_HANDLE_EOF ) ) 
		{

            DBGPRINTF( ( DBG_CONTEXT,
                         "Error %d in ReadFile\n",
                         err));

            goto ErrorExit;
        }
    }

    if ( err == ERROR_IO_PENDING ) 
	{

        if ( !GetOverlappedResult( hFile,
                                   Overlapped,
                                   nRead,
                                   TRUE )) 
		{

            err = GetLastError();

            DBGPRINTF( ( DBG_CONTEXT,
                         "Error %d in GetOverlappedResult\n",
                         err ) );

            if ( err != ERROR_HANDLE_EOF ) 
			{
                goto ErrorExit;
            }
        }
    }

    return S_OK;

ErrorExit:

    if ( fNewEvent ) {
        DBG_REQUIRE( CloseHandle( ov.hEvent ) );
    }

    return HRESULT_FROM_WIN32( err );

} // DoSynchronousReadFile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\parmlist.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parmlist.cxx

Abstract:

    Simple class for parsing and storing parameter list pairs

Author:

    John Ludeman (johnl)   22-Feb-1995

Revision History:

--*/

//
//  System include files.
//

#include "precomp.hxx"

inline
HRESULT
UnescapeStr( 
    STRA * pstr 
    )
{
    CHAR * pch;

    pch = pstr->QueryStr();
    while ( pch = strchr( pch, '+' ) )
    {
        *pch = ' ';
    }

    return pstr->Unescape();
}

PARAM_LIST::~PARAM_LIST(
    VOID
    )
/*++

Routine Description:

    Param list destructor

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ) )
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
        pFVP = NULL;
    }

    while ( !IsListEmpty( &_FreeHead ))
    {
        pFVP = CONTAINING_RECORD( _FreeHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        delete( pFVP );
        pFVP = NULL;
    }
}

VOID
PARAM_LIST::Reset(
    VOID
    )
/*++

Routine Description:

    Resets the parameter list back to its initially constructed state

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    while ( !IsListEmpty( &_FieldListHead ) )
    {
        pFVP = CONTAINING_RECORD( _FieldListHead.Flink,
                                  FIELD_VALUE_PAIR,
                                  ListEntry );

        DBG_ASSERT( pFVP != NULL );

        RemoveEntryList( &pFVP->ListEntry );

        //
        //  Put the removed item on the end so the same entry will 
        //  tend to be used for the same purpose on the next use
        //

        InsertTailList( &_FreeHead, &pFVP->ListEntry );
    }

    _fCanonicalized = FALSE;
}

HRESULT
PARAM_LIST::ParsePairs(
    const CHAR * pszList,
    BOOL         fDefaultParams,
    BOOL         fAddBlankValues,
    BOOL         fCommaIsDelim
    )
/*++

Routine Description:

    Puts the text list into a linked list of field/value pairs

    This can be used to parse lists in the form of:

    "a=b,c=d,e=f" (with fCommaIsDelim = TRUE)
    "name=Joe, Billy\nSearch=tom, sue, avery"(with fCommaIsDelim = FALSE)

    Duplicates will be appended and tab separated

Arguments:

    pszList - list of comma separated field/value pairs
    fDefaultParams - If TRUE, means these parameters are only defaults 
                     and shouldn't be added to the list if the field 
                     name is already in the list and the value is 
                     non-empty.
    fAddBlankValues - if TRUE, allow fields with empty values to be 
                      added to the list, else ignore empty values.
    fCommaIsDelim - if TRUE, a comma acts as a separator between two 
                    sets of fields values, otherwise the comma is 
                    ignored

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    DWORD              cParams = 0;
    DWORD              i;
    BOOL               fRet;
    STRA               strParams;
    STRA               strField;
    HRESULT            hr;

    //
    //  Make a copy we can muck with
    //

    hr = strParams.Copy( pszList );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field/value pairs list, hr = 0x%x.\n",
                   hr ));

        return hr;
    }

    //
    //  Replace all of the equal signs and commas with '\n's for 
    //  easier parsing
    //

    pch = strParams.QueryStr();
    while ( pch = strchr( pch, '=' ) )
    {
        *pch = '\n';
        cParams++;
    }

    if ( fCommaIsDelim )
    {
        pch = strParams.QueryStr();
        while ( pch = strchr( pch, ',' ) )
        {
            *pch = '\n';
            cParams++;
        }
    }

    //
    //  Pick out the fields and values and build the associative list
    //

    ODBC_PARSER Parser( strParams.QueryStr() );

    for ( i = 0; i < cParams; i++ )
    {
        hr = strField.Copy( Parser.QueryToken() );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "Error copying token, hr = 0x%x.\n",
                       hr ));
            return hr;
        }

        Parser.NextLine();

        pch = Parser.QueryToken();

        //
        //  If we aren't supposed to add blanks, then just go to the next
        //  line
        //

        if ( !fAddBlankValues && !*pch )
        {
            Parser.NextLine();
            continue;
        }

        if ( !fDefaultParams )
        {
            FIELD_VALUE_PAIR * pFVP;
            LIST_ENTRY *       ple;

            //
            //  Look for an existing field with this name and append
            //  the value there if we find it, otherwise add a new entry
            //

            for ( ple  = _FieldListHead.Flink;
                  ple != &_FieldListHead;
                  ple  = ple->Flink )
            {
                pFVP = CONTAINING_RECORD( ple, 
                                          FIELD_VALUE_PAIR, 
                                          ListEntry );

                if ( !_stricmp( pFVP->QueryField(),
                               strField.QueryStr() ))
                {
                    //
                    //  CODEWORK - Remove this allocation
                    //

                    STRA strtmp;

                    hr = strtmp.Copy( pch );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "Error copying, hr = 0x%x.\n",
                                    hr ));
                        return hr;
                    }

                    //
                    //  Found this header, append the new value
                    //

                    pFVP->_cValues++;

                    hr = UnescapeStr( &strtmp );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error unescaping string, hr = 0x%x.\n",
                            hr ));

                        return hr;
                    }       
                    
                    hr = pFVP->_strValue.Append( "\t" );
                    if( FAILED( hr ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "Error appending '\t', hr = 0x%x.\n",
                            hr ));
                        return hr;
                    } 
                         
                    hr = pFVP->_strValue.Append( strtmp );

                    goto Found;
                }
            }

            hr = AddEntry( strField.QueryStr(),
                           pch,
                           TRUE );
Found:
            ;
        }
        else
        {
            //
            //  Don't add if already in list
            //

            hr = AddParam( strField.QueryStr(),
                             pch );
        }

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error parsing pairs list, hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        Parser.NextLine();
    }

    return hr;
}

HRESULT
PARAM_LIST::AddEntryUsingConcat(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL  fPossibleFastMap
)
/*++

Routine Description:

    Concatenate value with existing entry of same name
    or call AddEntry if none exists

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                       in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    //
    //  Look for an existing field with this name
    //  and add the value there
    //

    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    HRESULT            hr;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            //
            //  Found this header, append the new value
            //

            pFVP->_cValues++;

            hr = pFVP->_strValue.Append( "," );
            if( FAILED( hr ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                   "Error appending ',', hr = 0x%x.\n",
                   hr ));

                return hr;
            } 
            
            hr = pFVP->_strValue.Append( pszValue );

            goto Found;
        }
    }

    hr = AddEntry( pszField,
                   pszValue,
                   FALSE,
                   fPossibleFastMap );

Found:

    return hr;
}



HRESULT
PARAM_LIST::ParseSimpleList(
    const CHAR * pszList
    )
/*++

Routine Description:

    Puts the comma separated list into a linked list of field/value pairs
    where the value is always NULL

Arguments:

    pszList - list of comma separated fields

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    CHAR *             pch;
    HRESULT            hr = S_OK;

    //
    //  Pick out the fields and values and build the associative list
    //

    ODBC_PARSER Parser( (CHAR *) pszList );

    Parser.SetListMode( TRUE );

    while ( *(pch = Parser.QueryToken()) )
    {
        hr = AddEntry( pch,
                       NULL,
                       TRUE );

        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error AddEntry, hr = 0x%x.\n",
                   hr ));

            return hr;
        }

        Parser.NextItem();
    }

    return hr;
}

CHAR *
PARAM_LIST::FindValue(
    const CHAR * pszField,
    BOOL *       pfIsMultiValue  OPTIONAL,
    DWORD *      pcbValue OPTIONAL
    )
/*++

Routine Description:

    Returns the value associated with pszField or NULL of no value was
    found

Arguments:

    pszField - field to search for value for
    pfIsMultiValue - Set to TRUE if this value is a composite of multiple fields
    pcbValue - Set to size of value (excluding nul terminator)


Return Value:

    Pointer to value or NULL if not found

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszField ))
        {
            if ( pfIsMultiValue )
            {
                *pfIsMultiValue = pFVP->IsMultiValued();
            }

            if ( pcbValue )
            {
                *pcbValue = pFVP->_strValue.QueryCB();
            }

            return pFVP->QueryValue();
        }
    }


    return NULL;
}

HRESULT
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    const CHAR * pszValue,
    BOOL         fUnescape,
    BOOL         fPossibleFastMap
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

Arguments:

    pszField         - Field to add
    pszValue         - Value to add
    fPossibleFastMap - TRUE if entry is not known not to be
                   in the fast map


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    CHAR *             pch;
    HRESULT            hr;

    if ( !IsListEmpty( &_FreeHead ) )
    {
        LIST_ENTRY * pEntry;

        pEntry = _FreeHead.Flink;

        RemoveEntryList( _FreeHead.Flink );

        pFVP = CONTAINING_RECORD( pEntry, FIELD_VALUE_PAIR, ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                   "Error creating new FIELD_VALUE_PAIR, hr = 0x%x.\n",
                   hr ));

            return hr;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    hr = pFVP->_strField.Copy( pszField );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = pFVP->_strValue.Copy( pszValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying value, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    if ( fUnescape )
    {
        //
        //  Normalize the fields and values (unescape and replace
        //  '+' with ' ')
        //

        hr = UnescapeStr( &pFVP->_strField );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error unescaping field, hr = 0x%x.\n",
                   hr ));
            return hr;
        }

        hr = UnescapeStr( &pFVP->_strValue );
        if( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                   "Error unescaping value, hr = 0x%x.\n",
                   hr ));
            return hr;
        }
    }

    return hr;
}

HRESULT
PARAM_LIST::AddEntry(
    const CHAR * pszField,
    DWORD        cbField,
    const CHAR * pszValue,
    DWORD        cbValue
    )
/*++

Routine Description:

    Unconditionally adds the field/value pair to the end of the list

    The fast map is not used and the fields are not unescaped

Arguments:

    pszField         - Field to add
    cbField          - Number of bytes in pszField
    pszValue         - Value to add
    cbValue          - Number of bytes in pszValue

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR *  pFVP;
    CHAR *              pch;
    PLIST_ENTRY         listEntry;
    HRESULT             hr;

    listEntry = RemoveHeadList( &_FreeHead );

    if ( listEntry != &_FreeHead )
    {
        pFVP = CONTAINING_RECORD(
                            listEntry,
                            FIELD_VALUE_PAIR,
                            ListEntry );

        pFVP->_strField.Reset();
        pFVP->_strValue.Reset();
    }
    else
    {
        pFVP = new FIELD_VALUE_PAIR;

        if ( !pFVP )
        {
            hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            DBGPRINTF(( DBG_CONTEXT,
                   "Error creating new FIELD_VALUE_PAIR, hr = 0x%x.\n",
                   hr ));

            return hr;
        }
    }

    pFVP->_cValues = 1;

    //
    //  Add it to the list now so we don't have to worry about deleting it
    //  if one of the below copies fail
    //

    InsertTailList( &_FieldListHead, &pFVP->ListEntry );

    hr = pFVP->_strField.Copy( pszField, cbField );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying field, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    hr = pFVP->_strValue.Copy( pszValue, cbValue );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "Error copying value, hr = 0x%x.\n",
                   hr ));
        return hr;
    }

    return hr;
}

HRESULT 
PARAM_LIST::AddParam(
    const CHAR * pszField,
    const CHAR * pszValue
    )
/*++

Routine Description:

    Adds a field/value pair to the list if the field isn't already in the list
    or the value is empty

    The fields added through this method will be escaped

Arguments:

    pszField - Field to add
    pszValue - Value to add


Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = ple->Flink )
    {
        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                        pszField ) )
        {
            //
            //  We found the field, replace the value if it is empty
            //

            if ( !*pFVP->QueryValue() )
            {
                return pFVP->_strValue.Copy( pszValue );
            }

            return S_OK;
        }
    }

    //
    //  The field name wasn't found, add it
    //

    return AddEntry( pszField,
                     pszValue,
                     TRUE );
}

BOOL
PARAM_LIST::RemoveEntry(
    const CHAR * pszFieldName
    )
/*++

Routine Description:

    Removes all occurrences of the specified fieldname from the list

Arguments:

    pszField - Field to remove

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    FIELD_VALUE_PAIR * pFVP;
    LIST_ENTRY *       ple;
    LIST_ENTRY *       pleNext;
    BOOL               fFound = FALSE;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  Find the field
    //

    for ( ple  = _FieldListHead.Flink;
          ple != &_FieldListHead;
          ple  = pleNext )
    {
        pleNext = ple->Flink;

        pFVP = CONTAINING_RECORD( ple, FIELD_VALUE_PAIR, ListEntry );

        if ( !_stricmp( pFVP->QueryField(),
                       pszFieldName ))
        {
            //
            //  We found a matching field, remove it
            //

            RemoveEntryList( ple );

            InsertHeadList( &_FreeHead, ple );

            fFound = TRUE;
        }
    }

    return (fFound);
}


VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    CHAR * * ppszValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    ppszValue - Receives corresponding value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //
    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *ppszValue = pFVP->QueryValue();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

VOID *
PARAM_LIST::NextPair(
    VOID *   pCookie,
    CHAR * * ppszField,
    DWORD *  pcbField,
    CHAR * * ppszValue,
    DWORD *  pcbValue
    )
/*++

Routine Description:

    Enumerates the field and values in this parameter list

Arguments:

    pCookie - Stores location in enumeration, set to NULL for new enumeration
    ppszField - Receives field
    pcbField -  Receives pointer to length of field
    ppszValue - Receives corresponding value
    pcbValue -  Receives pointer to length of value

Return Value:

    NULL when the enumeration is complete

--*/
{
    FIELD_VALUE_PAIR * pFVP;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    //
    //  pCookie points to the ListEntry in the FIELD_VALUE_PAIR class
    //

    if ( pCookie == NULL )
    {

        if ( IsListEmpty( &_FieldListHead ))
        {
            return NULL;
        }

        //
        //  Start a new enumeration
        //

        pCookie = (VOID *) _FieldListHead.Flink;
    }
    else
    {
        //
        //  Have we finished the current enumeration?
        //

        if ( pCookie == (VOID *) &_FieldListHead )
        {
            return NULL;
        }
    }

    pFVP = CONTAINING_RECORD( pCookie, FIELD_VALUE_PAIR, ListEntry );

    *ppszField = pFVP->QueryField();
    *pcbField  = pFVP->_strField.QueryCB();

    *ppszValue = pFVP->QueryValue();
    *pcbValue  = pFVP->_strValue.QueryCB();

    pCookie = pFVP->ListEntry.Flink;

    return pCookie;
}

DWORD
PARAM_LIST::GetCount(
    VOID
    )
{
    LIST_ENTRY * pEntry;
    DWORD        cParams = 0;

    //
    // Do we need to canon?
    //

    if ( !IsCanonicalized() )
    {
        CanonList( );
    }

    for ( pEntry = _FieldListHead.Flink;
          pEntry != &_FieldListHead;
          pEntry = pEntry->Flink )
    {
        cParams++;
    }

    return cParams;
}


VOID
PARAM_LIST::CanonList(
    VOID
    )
{
    FIELD_VALUE_PAIR * pFVP;
    PLIST_ENTRY        listEntry;
    PLIST_ENTRY        nextEntry;
    PLIST_ENTRY        tmpEntry;

    DBG_ASSERT(!_fCanonicalized);

    //
    // Go through the list and make sure that there are no dups.
    // if there are, convert them into comma separated lists.
    //

    for ( listEntry  = _FieldListHead.Flink;
          listEntry != &_FieldListHead;
          listEntry  = nextEntry
          )
    {
        DWORD fieldLen;
        PCHAR fieldName;

        nextEntry = listEntry->Flink;

        pFVP = CONTAINING_RECORD( listEntry, FIELD_VALUE_PAIR, ListEntry );


        //
        // if field or value is empty, zap it
        //

        if ( (*pFVP->QueryField() == '\0') ||
             (*pFVP->QueryValue() == '\0') )
        {

            RemoveEntryList( listEntry );
            InsertHeadList( &_FreeHead, listEntry );
            continue;
        }

        fieldName = pFVP->QueryField();
        fieldLen = pFVP->_strField.QueryCB();

        //
        // Walk the rest of the list and look for dup fields
        //

        tmpEntry = nextEntry;

        while ( tmpEntry != &_FieldListHead )
        {

            FIELD_VALUE_PAIR * pTmpFVP;
            pTmpFVP = CONTAINING_RECORD(
                                tmpEntry,
                                FIELD_VALUE_PAIR,
                                ListEntry );

            //
            // combine the two fields
            //

            if ( (pTmpFVP->_strField.QueryCB() == fieldLen) &&
                 (_stricmp(pTmpFVP->QueryField(), fieldName) == 0) &&
                 (*pTmpFVP->QueryValue() != '\0') )
            {

                pFVP->_cValues++;

                pFVP->_strValue.Append( "," );
                pFVP->_strValue.Append( pTmpFVP->QueryValue() );

                pTmpFVP->_strField.Reset();
            }

            tmpEntry = tmpEntry->Flink;
        }
    }

    _fCanonicalized = TRUE;
    return;

} // PARAM_LIST::CanonList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\odbc\parse.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        parse.hxx

   Abstract:

        Simple parser class for extrapolating HTTP headers information

   Author:
           John Ludeman     (JohnL)    18-Jan-1995

   Project:
           HTTP server

   Revision History:

--*/

#include "precomp.hxx"

ODBC_PARSER::ODBC_PARSER(
    CHAR * pszStart
    )
/*++

Routine Description:

    Sets the initial position of the buffer for parsing

Arguments:

    pszStart - start of character buffer
    pszEnd - End of buffer

Return Value:

--*/
    : m_fListMode   ( FALSE ),
      m_pszPos      ( pszStart ),
      m_pszTokenTerm( NULL ),
      m_pszLineTerm ( NULL )
{
    DBG_ASSERT( pszStart );

    //
    //  Chew up any initial white space at the beginning of the buffer
    //  and terminate the first token in the string.
    //

    EatWhite();

    TerminateToken();
}


ODBC_PARSER::~ODBC_PARSER(
    VOID
    )
/*++

Routine Description:

    Restores any changes we made to the string while parsing

Arguments:

--*/
{
    RestoreBuffer();
}


CHAR *
ODBC_PARSER::QueryPos(
    VOID
    )
/*++

Routine Description:

    Removes the terminators and returns the current parser position

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();
    RestoreLine();

    return m_pszPos;
}

VOID
ODBC_PARSER::SetPtr(
    CHAR * pch
    )
/*++

Routine Description:

    Sets the parser to point at a new location

Arguments:

    pch - New position for parser to start parsing from

Return Value:

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = pch;
}


CHAR *
ODBC_PARSER::QueryToken(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated token

    If list mode is on, then a comma is considered a delimiter.

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    if ( !m_pszTokenTerm )
    {
        TerminateToken( m_fListMode ? ',' : '\0' );
    }

    return m_pszPos;
}


CHAR *
ODBC_PARSER::QueryLine(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the current zero terminated line

Arguments:

Return Value:

    Zero terminated string if we've reached the end of the buffer

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    return m_pszPos;
}


HRESULT
ODBC_PARSER::CopyToken(
    STRA * pStr,
    BOOL  fAdvanceToken
    )
/*++

Routine Description:

    Copies the token at the current position to *pStr

Arguments:

    pStr - Receives token
    fAdvanceToken - True if we should advance to the next token

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    HRESULT hr;

    DBG_ASSERT( pStr );

    if ( !m_pszTokenTerm )
    {
        TerminateToken();
    }

    hr = pStr->Copy( m_pszPos );

    if ( fAdvanceToken )
    {
        NextToken();
    }

    return hr;
}


HRESULT
ODBC_PARSER::CopyToEOL(
    STRA   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Copies the token at the current character position

Arguments:

--*/
{
    HRESULT hr;

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    hr = pstr->Copy( m_pszPos );

    if ( fAdvance )
    {
        NextLine();
    }

    return hr;
}

HRESULT
ODBC_PARSER::AppendToEOL(
    STRA   * pstr,
    BOOL    fAdvance
    )
/*++

Routine Description:

    Same as CopyToEOL except the text from the current line is appended to
    pstr

Arguments:

--*/
{
    HRESULT hr;

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    hr = pstr->Append( m_pszPos );

    if ( fAdvance )
    {
        NextLine();
    }

    return hr;
}


CHAR *
ODBC_PARSER::NextLine(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the first non-white character after the
    next '\n' (or terminating '\0').

--*/
{
    RestoreToken();
    RestoreLine();

    m_pszPos = AuxSkipTo( '\n' );

    if ( *m_pszPos )
    {
        m_pszPos++;
    }

    return EatWhite();
}

CHAR *
ODBC_PARSER::NextToken(
    VOID
    )
/*++

Routine Description:

    Sets the current position to the next non-white character after the
    current token

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    //
    //  Skip the current token
    //

    EatNonWhite();

    EatWhite();

    TerminateToken();

    return m_pszPos;
}


CHAR *
ODBC_PARSER::NextToken(
    CHAR ch
    )
/*++

Routine Description:

    Advances the position to the next token after ch (stopping
    at the end of the line)

--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    //
    //  Look for the specified character (generally ',' or ';')
    //

    SkipTo( ch );

    if ( *m_pszPos )
    {
        m_pszPos++;
    }

    EatWhite();

    TerminateToken( ch );

    return m_pszPos;
}


CHAR *
ODBC_PARSER::SkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    //
    //  Make sure the line is terminated so a '\0' will be returned after
    //  the last token is found on this line
    //

    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    m_pszPos = AuxSkipTo( ch );

    return m_pszPos;
}


VOID
ODBC_PARSER::SetListMode(
    BOOL fListMode
    )
/*++

Routine Description:

    Resets the parser mode to list mode or non-list mode

Arguments:

--*/
{
    RestoreToken();

    if ( !m_pszLineTerm )
    {
        TerminateLine();
    }

    m_fListMode = fListMode;
}

VOID
ODBC_PARSER::TerminateToken(
    CHAR ch
    )
/*++

Routine Description:

    Zero terminates after the white space of the current token

Arguments:

--*/
{
    DBG_ASSERT( !m_pszTokenTerm );

    m_pszTokenTerm = AuxEatNonWhite( ch );

    m_chTokenTerm = *m_pszTokenTerm;

    *m_pszTokenTerm = '\0';
}

VOID
ODBC_PARSER::RestoreToken(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszTokenTerm )
    {
        *m_pszTokenTerm = m_chTokenTerm;
        m_pszTokenTerm = NULL;
    }
}

VOID
ODBC_PARSER::TerminateLine(
    VOID
    )
/*++

Routine Description:

    Zero terminates at the end of this line

Arguments:

--*/
{
    DBG_ASSERT( !m_pszLineTerm );

    m_pszLineTerm = AuxSkipTo( '\n' );

    //
    //  Now trim any trailing white space on the line
    //

    if ( m_pszLineTerm > m_pszPos )
    {
        m_pszLineTerm--;

        while ( m_pszLineTerm >= m_pszPos &&
                ISWHITEA( *m_pszLineTerm ) )
        {
            m_pszLineTerm--;
        }
    }

    //
    //  Go forward one (trimming found the last non-white
    //  character)
    //

    if ( *m_pszLineTerm &&
         *m_pszLineTerm != '\n' &&
         !ISWHITEA( *m_pszLineTerm ))
    {
        m_pszLineTerm++;
    }

    m_chLineTerm = *m_pszLineTerm;

    *m_pszLineTerm = '\0';
}

VOID
ODBC_PARSER::RestoreLine(
    VOID
    )
/*++

Routine Description:

    Restores the character replaced by the zero terminator

Arguments:

--*/
{
    if ( m_pszLineTerm )
    {
        *m_pszLineTerm = m_chLineTerm;
        m_pszLineTerm = NULL;
    }
}




CHAR *
ODBC_PARSER::AuxEatNonWhite(
    CHAR ch
    )
/*++

Routine Description:

    In non list mode returns the first white space character after 
    the current parse position
    In list mode returns the first delimiter ( "';\n" ) character after 
    the current parse position

Arguments:

    ch - Optional character that is considered white space (such as ',' or ';'
        when doing list processing).

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'.  In list mode, comma and semi-colon
    //  are considered delimiters
    //

    if ( !m_fListMode )
    {
        while ( *psz           &&
                *psz != '\n'   &&
                !ISWHITEA(*psz)&&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
    else
    {
        while ( *psz           &&
                *psz != '\n'   &&
                *psz != ','    &&
                *psz != ';'    &&
                *psz != ch )
        {
            psz++;
        }

        return psz;
    }
}


CHAR *
ODBC_PARSER::AuxEatWhite(
    VOID
    )
/*++

Routine Description:

    Returns the first non-white space character after the current parse
    position

Arguments:

--*/
{
    CHAR * psz = m_pszPos;

    //
    //  Note that ISWHITEA includes '\r'
    //

    while ( *psz           &&
            *psz != '\n'   &&
            ISWHITEA(*psz))
    {
        psz++;
    }

    return psz;
}


CHAR *
ODBC_PARSER::AuxSkipTo(
    CHAR ch
    )
/*++

Routine Description:

    Skips to the specified character or returns a null terminated string
    if the end of the line is reached


--*/
{
    CHAR * psz = m_pszPos;

    while ( *psz           &&
            *psz != '\n'   &&
            *psz != ch )
    {
        psz++;
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )


// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_SCHANNEL_CALLS       0x00010000
# define    DEBUG_CLIENT_CERT_INFO     0x00020000
# define    DEBUG_APP_RAW_READWRITE    0x00080000



//# define    DEBUG_TRACE                0x10000000
//# define    DEBUG_DUMPS                0x20000000



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\certstore.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     certstore.cxx

   Abstract:
     Wrapper of a certificate store
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

CERT_STORE_HASH *       CERT_STORE::sm_pCertStoreHash;

CERT_STORE::CERT_STORE()
    : _cRefs( 1 ),
      _hStore( NULL ),
      _hWaitHandle( NULL ),
      _hStoreChangeEvent( NULL )
{
    _dwSignature = CERT_STORE_SIGNATURE;
}

CERT_STORE::~CERT_STORE()
{
    _dwSignature = CERT_STORE_SIGNATURE_FREE;
    
    if ( _hWaitHandle != NULL )
    {
        UnregisterWait( _hWaitHandle );
        _hWaitHandle = NULL;
    }
    
    if ( _hStoreChangeEvent != NULL )
    {
        CloseHandle( _hStoreChangeEvent );
        _hStoreChangeEvent = NULL;
    }
    
    if ( _hStore != NULL )
    {
        CertCloseStore( _hStore, 0 );
        _hStore = NULL;
    }
}

//static
VOID
WINAPI
CERT_STORE::CertStoreChangeRoutine(
    VOID *                  pvContext,
    BOOLEAN                 fTimedOut
)
/*++

Routine Description:

    Called when a certificate store has changed

Arguments:

    pvContext - Points to CERT_STORE which changed
    fTimedOut - Should always be FALSE since our wait is INFINITE

Return Value:

    HRESULT

--*/
{
    CERT_STORE *            pCertStore;
    HRESULT                 hr;
    
    DBG_ASSERT( pvContext != NULL );
    DBG_ASSERT( fTimedOut == FALSE );
    
    pCertStore = (CERT_STORE*) pvContext;
    DBG_ASSERT( pCertStore->CheckSignature() );
    
    //
    // Reference before we calling to DeleteRecord() so that we maintain
    // a record for use with flushing the server cert cache
    //
    
    pCertStore->ReferenceStore();
    
    //
    // Remove the thing from the hash table for one
    //
    
    sm_pCertStoreHash->DeleteRecord( pCertStore );

    //
    // Instruct the server certificate cache to flush any certs which 
    // were referencing this cert store.  
    //
    // That will, in turn, flush any site configurations which were referencing
    // the given server cert
    //
    
    SERVER_CERT::FlushByStore( pCertStore );

    //
    // Should be the last dereference of the object
    //
    
    pCertStore->DereferenceStore();
}

HRESULT
CERT_STORE::Open(    
    STRU &              strStoreName
)
/*++

Routine Description:

    Open specified certificate store

Arguments:

    strStoreName - name of certificate store to open

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    BOOL                fRet = TRUE;
    
    DBG_ASSERT( CheckSignature() );

    //
    // Remember the name
    //
    
    hr = _strStoreName.Copy( strStoreName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    DBG_ASSERT( _hStore == NULL );

    //
    // Get the handle
    //
 
    _hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                             0,
                             NULL,
                             CERT_SYSTEM_STORE_LOCAL_MACHINE,
                             strStoreName.QueryStr() );
    if ( _hStore == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // Setup a change notification so that we are informed the cert store
    // has changed
    //
    
    _hStoreChangeEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    if ( _hStoreChangeEvent == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = RegisterWaitForSingleObject( &_hWaitHandle,
                                        _hStoreChangeEvent,
                                        CERT_STORE::CertStoreChangeRoutine,
                                        this,
                                        INFINITE,
                                        WT_EXECUTEONLYONCE );
    if ( !fRet )
    {
        DBG_ASSERT( _hWaitHandle == NULL );
        
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    fRet = CertControlStore( _hStore,
                             0,
                             CERT_STORE_CTRL_NOTIFY_CHANGE,
                             &_hStoreChangeEvent );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
                             
    return NO_ERROR;
}

//static
HRESULT
CERT_STORE::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize CERT_STORE globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pCertStoreHash == NULL );
    
    sm_pCertStoreHash = new CERT_STORE_HASH();
    if ( sm_pCertStoreHash == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return NO_ERROR;
}

//static
VOID
CERT_STORE::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate CERT_STORE globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pCertStoreHash != NULL )
    {
        delete sm_pCertStoreHash;
        sm_pCertStoreHash = NULL;
    }
}

//static
HRESULT
CERT_STORE::OpenStore(
    STRU &              strStoreName,
    CERT_STORE **       ppStore
)
/*++

Routine Description:

    Open certificate store from cache

Arguments:

    strStoreName - Store name to open
    ppStore - Filled with store on success

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;
    CERT_STORE *        pCertStore = NULL;
    LK_RETCODE          lkrc;
    
    if ( ppStore == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }
    *ppStore = NULL;
    
    //
    // Lookup in cache first
    //
    
    DBG_ASSERT( sm_pCertStoreHash != NULL );
    
    lkrc = sm_pCertStoreHash->FindKey( strStoreName.QueryStr(),
                                       &pCertStore );
    if ( lkrc != LK_SUCCESS )
    {
        //
        // OK.  Create one and add to cache
        //
        
        pCertStore = new CERT_STORE();
        if ( pCertStore == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Finished;
        }
        
        hr = pCertStore->Open( strStoreName );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }
        
        lkrc = sm_pCertStoreHash->InsertRecord( pCertStore );

        //
        // Ignore the error.  We will do the right thing if we couldn't 
        // add to hash (i.e. no extra reference happens and callers deref
        // will delete the object as desired)
        //        
    }
    
    DBG_ASSERT( pCertStore != NULL );
    
    *ppStore = pCertStore;

    return NO_ERROR;
    
Finished:
    if ( pCertStore != NULL )
    {
        pCertStore->DereferenceStore();
        pCertStore = NULL;
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\servercert.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     servercert.cxx

   Abstract:
     Server Certificate wrapper
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SERVER_CERT_HASH *      SERVER_CERT::sm_pServerCertHash;

SERVER_CERT::SERVER_CERT( 
    CREDENTIAL_ID *         pCredentialId 
) : _pCredentialId( pCredentialId ),
    _pCertContext( NULL ),
    _pCertStore( NULL ),
    _cRefs( 1 ),
    _usPublicKeySize( 0 )
{
    _dwSignature = SERVER_CERT_SIGNATURE;
}

SERVER_CERT::~SERVER_CERT()
{
    if ( _pCertContext != NULL )
    {
        CertFreeCertificateContext( _pCertContext );
        _pCertContext = NULL;
    }
    
    if ( _pCertStore != NULL )
    {
        _pCertStore->DereferenceStore();
        _pCertStore = NULL;
    }
    
    _dwSignature = SERVER_CERT_SIGNATURE_FREE;
}

//static
HRESULT
SERVER_CERT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize server certificate globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    sm_pServerCertHash = new SERVER_CERT_HASH();
    if ( sm_pServerCertHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
SERVER_CERT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup server certificate globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pServerCertHash != NULL )
    {
        delete sm_pServerCertHash;
        sm_pServerCertHash = NULL;
    }
}

//static
HRESULT
SERVER_CERT::GetServerCertificate(
    DWORD                   dwSiteId,
    SERVER_CERT **          ppServerCert
)
/*++

Routine Description:

    Find a suitable server certificate for use with the site represnented by
    given site id

Arguments:

    dwSiteId - Site to find cert for
    ppServerCert - Filled with a pointer to server certificate

Return Value:

    HRESULT

--*/
{
    SERVER_CERT *           pServerCert = NULL;
    CREDENTIAL_ID *         pCredentialId = NULL;
    HRESULT                 hr = NO_ERROR;
    LK_RETCODE              lkrc;
    STACK_STRU(             strMBPath, 64 );
    WCHAR                   achNum[ 64 ];
    DWORD                   cchTrunc = 0;
    
    if ( ppServerCert == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *ppServerCert = NULL;
    
    //
    // First build up a Crednential ID to use in looking up in our
    // server cert cache
    //
    
    pCredentialId = new CREDENTIAL_ID;
    if ( pCredentialId == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    //
    // First try the site level configuration
    //
    
    hr = strMBPath.Copy( L"/LM/W3SVC/" );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    cchTrunc = strMBPath.QueryCCH();
    
    _ultow( dwSiteId, achNum, 10 );
    
    hr = strMBPath.Append( achNum );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = SERVER_CERT::BuildCredentialId( strMBPath,
                                         pCredentialId );
    if ( FAILED( hr ) )
    {
        //
        // OK.  If we failed because of not found, then look up at service
        // level
        //
        
        if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            DBG_ASSERT( cchTrunc != 0 );
        
            strMBPath.SetLen( cchTrunc );
        
            hr = SERVER_CERT::BuildCredentialId( strMBPath,
                                                 pCredentialId );
        }
        
        if ( FAILED( hr ) )
        {
            //
            // Regardless of error, we are toast because we couldn't find
            // a server cert
            //
            
            delete pCredentialId;
            return hr;
        }
    }
    
    DBG_ASSERT( sm_pServerCertHash != NULL );
    
    lkrc = sm_pServerCertHash->FindKey( pCredentialId,
                                        &pServerCert );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // Server already contains a credential ID
        //
        
        delete pCredentialId;
        
        *ppServerCert = pServerCert; 
        
        return NO_ERROR;
    }    
    
    //
    // Ok.  It wasn't in our case, we need to it there
    //
    
    pServerCert = new SERVER_CERT( pCredentialId );
    if ( pServerCert == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        delete pCredentialId;
        
        return hr;
    }
    
    hr = pServerCert->SetupCertificate( strMBPath );
    if ( FAILED( hr ) )
    {
        //
        // Server certificate owns the reference to pCredentialId now
        //
        
        delete pServerCert;
        
        return hr;
    }
    
    //
    // Now try to add cert to hash.  
    //
    
    lkrc = sm_pServerCertHash->InsertRecord( pServerCert );

    //
    // Ignore the error.  If it didn't get added then we will naturally 
    // clean it up on the callers dereference
    //

    *ppServerCert = pServerCert;    
    
    return NO_ERROR;
}

//static
HRESULT
SERVER_CERT::BuildCredentialId(
    STRU &                  strMBPath,
    CREDENTIAL_ID *         pCredentialId
)
/*++

Routine Description:

    Read the configured server cert and CTL hash.  This forms the identifier
    for the credentials we need for this site

Arguments:

    strMBPath - Metabase path
    pCredentialId - Filled with credential ID 

Return Value:

    HRESULT

--*/
{
    MB                  mb( g_pStreamFilter->QueryMDObject() );
    BOOL                fRet;
    DWORD               cbRequired;
    BYTE                abBuff[ 64 ];
    BUFFER              buff( abBuff, sizeof( abBuff ) );
    HRESULT             hr = NO_ERROR;

    if ( pCredentialId == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    fRet = mb.Open( strMBPath.QueryStr(),
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Find the server certificate hash
    //

    cbRequired = buff.QuerySize();
    
    fRet = mb.GetData( NULL,
                       MD_SSL_CERT_HASH,
                       IIS_MD_UT_SERVER,
                       BINARY_METADATA,
                       buff.QueryPtr(),
                       &cbRequired,
                       METADATA_NO_ATTRIBUTES );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !buff.Resize( cbRequired ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }   
            
            fRet = mb.GetData( NULL,
                               MD_SSL_CERT_HASH,
                               IIS_MD_UT_SERVER,
                               BINARY_METADATA,
                               buff.QueryPtr(),
                               &cbRequired,
                               METADATA_NO_ATTRIBUTES );
            if ( !fRet )
            {
                DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                
                return HRESULT_FROM_WIN32( GetLastError() );
            }
        }
        
        //
        // No server cert.  Then we can't setup SSL
        //
        
        return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
    }        
    
    //
    // Add to our credential ID
    //
    
    hr = pCredentialId->Append( (PBYTE) buff.QueryPtr(),
                                cbRequired );
    if ( FAILED( hr ) )
    {
        return hr;
    }    
    
    //
    // Look for an optional CTL to add to ID
    //

    cbRequired = buff.QuerySize();
    
    fRet = mb.GetData( NULL,
                       MD_SSL_CTL_IDENTIFIER,
                       IIS_MD_UT_SERVER,
                       STRING_METADATA,
                       buff.QueryPtr(),
                       &cbRequired,
                       METADATA_NO_ATTRIBUTES );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            if ( !buff.Resize( cbRequired ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }   
            
            fRet = mb.GetData( NULL,
                               MD_SSL_CTL_IDENTIFIER,
                               IIS_MD_UT_SERVER,
                               STRING_METADATA,
                               buff.QueryPtr(),
                               &cbRequired,
                               METADATA_NO_ATTRIBUTES );
        }
    }        
    
    if ( fRet )
    {
        hr = pCredentialId->Append( (PBYTE) buff.QueryPtr(),
                                    cbRequired );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return NO_ERROR;
}

HRESULT
SERVER_CERT::SetupCertificate(
    STRU &                  strMBPath
)
/*++

Routine Description:

    Do the SChannel go to setup the credentials for the server certificate
    setup at the metabase path specified
    
Arguments:

    strMBPath - Metabase path for SSL configuration.  

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    MB                      mb( g_pStreamFilter->QueryMDObject() );
    BYTE                    abBuff[ 128 ];
    BUFFER                  buff( abBuff, sizeof( abBuff ) );
    DWORD                   cbRequired = 0;
    DWORD                   cbHash = 0;
    STACK_STRU(             strStoreName, 256 );
    CERT_STORE *            pCertStore = NULL;
    CRYPT_HASH_BLOB         hashBlob;
    PCERT_PUBLIC_KEY_INFO   pPublicKey;
    DWORD                   cbX500Name = 0;
    BOOL                    fRet;
    
    
    if ( !mb.Open( strMBPath.QueryStr() ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Get the required server certificate hash
    //
    
    cbRequired = buff.QuerySize();
    if ( !mb.GetData( NULL,
                      MD_SSL_CERT_HASH,
                      IIS_MD_UT_SERVER,
                      BINARY_METADATA,
                      buff.QueryPtr(),
                      &cbRequired,
                      METADATA_NO_ATTRIBUTES ) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // Try again with a bigger buffer
            //
            
            if ( !buff.Resize( cbRequired ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
            
            if ( !mb.GetData( NULL,
                              MD_SSL_CERT_HASH,
                              IIS_MD_UT_SERVER,
                              BINARY_METADATA,
                              buff.QueryPtr(),
                              &cbRequired,
                              METADATA_NO_ATTRIBUTES ) )
            {
                DBG_ASSERT( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
                
                hr = HRESULT_FROM_WIN32( GetLastError() );
                goto Finished;
            }
        }
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    cbHash = cbRequired;
    DBG_ASSERT( cbHash != 0 );
    
    //
    // Get the required certificate store
    //
    
    if ( !mb.GetStr( NULL,
                     MD_SSL_CERT_STORE_NAME,
                     IIS_MD_UT_SERVER,
                     &strStoreName,
                     METADATA_NO_ATTRIBUTES,
                     NULL ) )
    {
        //
        // No store, no play
        //
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // OK.  We are ready to retrieve the certificate using CAPI APIs
    //
    
    //
    // First get the desired store and store it away for later!
    //
    
    hr = CERT_STORE::OpenStore( strStoreName,
                                &pCertStore );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    DBG_ASSERT( pCertStore != NULL );
    _pCertStore = pCertStore;
    
    //
    // Now find the certificate hash in the store
    //
    
    hashBlob.cbData = cbHash;
    hashBlob.pbData = (PBYTE) buff.QueryPtr();

    _pCertContext = CertFindCertificateInStore( _pCertStore->QueryStore(),
                                                X509_ASN_ENCODING,
                                                0,
                                                CERT_FIND_SHA1_HASH,
                                                (VOID*) &hashBlob,
                                                NULL );
    if ( _pCertContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    } 


    //
    // Get certificate public key size
    //
    
    DBG_ASSERT( _usPublicKeySize == 0 );
    
    pPublicKey = &(_pCertContext->pCertInfo->SubjectPublicKeyInfo);

    _usPublicKeySize = (USHORT) CertGetPublicKeyLength( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, 
                                                        pPublicKey );

    if ( _usPublicKeySize == 0 )
    {
        //
        // Failed to receive public key size
        //
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 

    }

    //
    // Get issuer string
    //
    
    DBG_ASSERT( _pCertContext->pCertInfo != NULL );

    //
    // First find out the size of buffer required for issuer
    //

    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Issuer,
                                CERT_X500_NAME_STR,
                                NULL,
                                0);
    if(!buff.Resize(cbX500Name))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 
    }    
    
    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Issuer,
                                CERT_X500_NAME_STR,
                                (LPSTR) buff.QueryPtr(),
                                buff.QuerySize() );

    hr = _strIssuer.Copy( (LPSTR) buff.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto Finished; 
    }
    
    //
    // Get subject string
    //
    
    //
    // First find out the size of buffer required for subject
    //

    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR,
                                NULL,
                                0);
    if(!buff.Resize(cbX500Name))
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished; 
    }    
    cbX500Name = CertNameToStrA( PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                &_pCertContext->pCertInfo->Subject,
                                CERT_X500_NAME_STR,
                                (LPSTR) buff.QueryPtr(),
                                buff.QuerySize() );
    
    hr = _strSubject.Copy( (LPSTR) buff.QueryPtr() );
    if ( FAILED( hr ) )
    {
        goto Finished; 
    }
    
Finished:
        
    return hr;    
}

//static
LK_PREDICATE
SERVER_CERT::CertStorePredicate(
    SERVER_CERT *           pServerCert,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    CERT_STORE pointed to by pvState    

  Arguments:

    pServerCert - Server cert
    pvState - Points to CERT_STORE

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    CERT_STORE *          pCertStore;

    DBG_ASSERT( pServerCert != NULL );
    
    pCertStore = (CERT_STORE*) pvState;
    DBG_ASSERT( pCertStore != NULL );
    
    if ( pServerCert->_pCertStore == pCertStore ) 
    {
        //
        // Before we delete the cert, flush any site which is referencing
        // it
        //
        
        SITE_CONFIG::FlushByServerCert( pServerCert );
        
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
SERVER_CERT::FlushByStore(
    CERT_STORE *            pCertStore
)
/*++

Routine Description:

    Flush any server certs which reference the given store
    
Arguments:

    pCertStore - Cert store to check

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pServerCertHash != NULL );
    
    sm_pServerCertHash->DeleteIf( SERVER_CERT::CertStorePredicate, 
                                  pCertStore );
                                  
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\isapicontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     isapicontext.cxx

   Abstract:
     ISAPI stream context
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

PFN_PROCESS_RAW_READ         ISAPI_STREAM_CONTEXT::sm_pfnRawRead;
PFN_PROCESS_RAW_WRITE        ISAPI_STREAM_CONTEXT::sm_pfnRawWrite;
PFN_PROCESS_CONNECTION_CLOSE ISAPI_STREAM_CONTEXT::sm_pfnConnectionClose;
PFN_PROCESS_NEW_CONNECTION   ISAPI_STREAM_CONTEXT::sm_pfnNewConnection;

//static
HRESULT
ISAPI_STREAM_CONTEXT::Initialize(
    STREAM_FILTER_CONFIG *      pConfig
)
/*++

Routine Description:

    Global initialization for ISAPI raw filtering support

Arguments:

    pConfig - Configuration from W3CORE

Return Value:

    HRESULT

--*/
{
    if ( pConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    sm_pfnRawRead = pConfig->pfnRawRead;
    sm_pfnRawWrite = pConfig->pfnRawWrite;
    sm_pfnConnectionClose = pConfig->pfnConnectionClose;
    sm_pfnNewConnection = pConfig->pfnNewConnection;
    
    return NO_ERROR;
}

//static
VOID
ISAPI_STREAM_CONTEXT::Terminate(
    VOID
)
{
}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessNewConnection(
    CONNECTION_INFO *           pConnectionInfo
)
/*++

Routine Description:

    Handle a new raw connection

Arguments:

    pConnectionInfo - Raw connection info

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    PVOID                   pContext;
    
    if ( pConnectionInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = sm_pfnNewConnection( pConnectionInfo,
                              &pContext );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _pvContext = pContext;
    
    return NO_ERROR;
}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessRawReadData(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Handle data being read from the client

Arguments:

    pRawStreamInfo - Raw stream info describing incoming data
    pfReadMode - Set to TRUE if we want to read more data
    pfComplete - Set to TRUE if we should just disconnect

Return Value:

    HRESULT

--*/
{
    PVOID               pvOldContext;
    HRESULT             hr;
    DWORD               cbNextReadSize = 0;
    
    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pfnRawRead != NULL );
    
    hr = sm_pfnRawRead( pRawStreamInfo,
                        _pvContext,
                        pfReadMore,
                        pfComplete,
                        &cbNextReadSize );

    if ( cbNextReadSize )
    {
        QueryUlContext()->SetNextRawReadSize( cbNextReadSize );
    }

    return hr;
}

HRESULT
ISAPI_STREAM_CONTEXT::ProcessRawWriteData(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Handle data being sent to the client

Arguments:

    pRawStreamInfo - Raw stream info describing incoming data
    pfComplete - Set to TRUE if we should just disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    
    if( pRawStreamInfo == NULL ||
        pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( sm_pfnRawWrite != NULL );
    
    hr = sm_pfnRawWrite( pRawStreamInfo,
                         _pvContext,
                         pfComplete );
    
    return hr;
}
    
VOID
ISAPI_STREAM_CONTEXT::ProcessConnectionClose(
    VOID
)
/*++

Routine Description:

    Handle connection closure

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pfnConnectionClose != NULL );
    
    sm_pfnConnectionClose( _pvContext );
}

//static
HRESULT
ISAPI_STREAM_CONTEXT::SendDataBack(
    PVOID                       pvStreamContext,
    RAW_STREAM_INFO *           pRawStreamInfo
)
{
    UL_CONTEXT *            pUlContext;
    
    if ( pRawStreamInfo == NULL || 
         pvStreamContext == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    pUlContext = (UL_CONTEXT*) pvStreamContext;
    DBG_ASSERT( pUlContext->CheckSignature() );
    
    return pUlContext->SendDataBack( pRawStreamInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\sitebinding.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     sitebinding.cxx

   Abstract:
     Given a ip-address/port, determine the site ID
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SITE_BINDING_HASH *  SITE_BINDING::sm_pSiteBindingHash;
BOOL                 SITE_BINDING::sm_fAllWildcardBindings;

//static
HRESULT
SITE_BINDING::ParseSiteBinding(
    WCHAR *             pszBinding,
    DWORD *             pLocalAddress,
    USHORT *            pLocalPort
)
/*++

Routine Description:

    Parse a metabase site binding into an address/port

Arguments:

    pszBinding - Binding in metabase (in form ip:port)
    pLocalAddress - Filled with ip address of binding on success
    pLocalPort - Filled with port of binding on success

Return Value:

    HRESULT

--*/
{
    LPWSTR              pszPort;
    LPWSTR              pszEnd;
    HRESULT             hr = NO_ERROR;
    ULONG               LocalPort;
    STACK_STRA(         strIpAddress, 64 );
    
    if ( pszBinding == NULL ||
         pLocalAddress == NULL ||
         pLocalPort == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // Binding is of form "IP-Address:Port:Host"
    //
    // For our purposes (SSL), we'll ignore the Host
    // For wildcard IP addresss, the parameter is empty (example :443:)
    //  
    
    pszEnd = wcschr( pszBinding, L':' );
    if ( pszEnd == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto Finished;
    }

    //
    // Handle the IP address
    //

    if ( pszBinding[ 0 ] == L'\0' )
    {
        *pLocalAddress = WILDCARD_ADDRESS;
    }
    else
    {
        hr = strIpAddress.CopyW( pszBinding,
                                 DIFF( pszEnd - pszBinding ) );
        if ( FAILED( hr ) )
        {
            goto Finished;
        }

        *pLocalAddress = inet_addr( strIpAddress.QueryStr() );
    }
    
    //
    // Handle the port
    //
    
    pszBinding = pszEnd + 1;
    if ( *pszBinding == L'\0' )
    {
        goto Finished;
    }
    
    LocalPort = wcstoul( pszBinding, NULL, 10 );
    if ( LocalPort > 0xFFFF ||
         LocalPort == 0 )
    {
        goto Finished;
    }
    
    *pLocalPort = (USHORT) LocalPort;
    
Finished:
    return hr;
}

//static
HRESULT
SITE_BINDING::Initialize(
    VOID
)
/*++

Routine Description:

    Read all the site bindings and insert them into hash table

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{
    MB              mb( g_pStreamFilter->QueryMDObject() );
    BOOL            fRet;
    HRESULT         hr = NO_ERROR;
    DWORD           dwIndex;
    DWORD           dwSiteId;
    WCHAR           achSitePath[ METADATA_MAX_NAME_LEN ];
    DWORD           LocalAddress;
    USHORT          LocalPort;
    LPWSTR          pszBinding;
    MULTISZ         mszBindings;
    LK_RETCODE      lkRet;
    SITE_BINDING *  pSiteBinding;
    
    DBG_ASSERT( sm_pSiteBindingHash == NULL );

    sm_fAllWildcardBindings = TRUE;

    //
    // First create a hash table to store all site bindings
    //
    
    sm_pSiteBindingHash = new SITE_BINDING_HASH();
    if ( sm_pSiteBindingHash == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    //
    // Iterate all sites in metabase and populate the table
    //
    
    fRet = mb.Open( L"/LM/W3SVC",
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    dwIndex = 0;
    while ( mb.EnumObjects( L"", 
                            achSitePath,
                            dwIndex++ ) )
    {
        //
        // We only want the sites (w3svc/<number>)
        //
        
        dwSiteId = wcstoul( achSitePath, NULL, 10 );
        if ( dwSiteId == 0 )
        {
            continue;
        }

        fRet = mb.GetMultisz( achSitePath,
                              MD_SECURE_BINDINGS,
                              IIS_MD_UT_SERVER,
                              &mszBindings,
                              0 );
        if ( fRet )
        {
            //
            // We have a secure binding (and thus a SSL site)
            // Iterate thru the site bindings and make an entry (and add
            // to hash table) to each one
            //
            
            pszBinding = (LPWSTR) mszBindings.First();           
            do
            {
                if ( pszBinding == NULL )
                {
                    //
                    // An empty site binding was set.  Just bail
                    //
                    
                    break;
                }
                
                hr = SITE_BINDING::ParseSiteBinding( pszBinding,
                                                     &LocalAddress,
                                                     &LocalPort );
                if ( FAILED( hr ) )
                {
                    break;
                }
                
                //
                // Keep track if we have encountered a non-wildcard bound
                // site.  This will speed up our lookup of site bindings
                // at "run-time"
                //
                
                if ( sm_fAllWildcardBindings &&
                     LocalAddress != WILDCARD_ADDRESS )
                {
                    sm_fAllWildcardBindings = FALSE;
                }
                
                //
                // Add to hash table
                //
                
                pSiteBinding = new SITE_BINDING( LocalAddress,
                                                 LocalPort,
                                                 dwSiteId );
                if ( pSiteBinding == NULL )
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    goto Finished;
                }    
                
                lkRet = sm_pSiteBindingHash->InsertRecord( pSiteBinding );
                if ( lkRet != LK_SUCCESS )
                {
                    //
                    // ISSUE:  What to do
                    //
                }
                else
                {
                    //
                    // The hash table owns the reference
                    //
                    
                    pSiteBinding->DereferenceSiteBinding();
                }
            }
            while ( pszBinding = (LPWSTR) mszBindings.Next( pszBinding ) );
        }
    }

Finished:
    if ( FAILED( hr ) )
    {
        if ( sm_pSiteBindingHash != NULL )
        {
            delete sm_pSiteBindingHash;
            sm_pSiteBindingHash = NULL;
        }
    }
    
    return hr;
}


//static
VOID
SITE_BINDING::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup global binding table

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pSiteBindingHash != NULL )
    {
        delete sm_pSiteBindingHash;
        sm_pSiteBindingHash = NULL;
    }
}

//static
HRESULT
SITE_BINDING::HandleSiteBindingChange(
    DWORD                   dwSiteId,
    WCHAR *                 pszSitePath
)
/*++

Routine Description:

    Handle site binding change by updating our table accordingly

Arguments:

    dwSiteId - Site ID whose binding has changed
    pszSitePath - Metabase path for site
    
Return Value:

    HRESULT

--*/
{
    BOOL                fRet;
    LPWSTR              pszBinding;
    MULTISZ             mszBindings;
    HRESULT             hr = NO_ERROR;
    DWORD               LocalAddress;
    USHORT              LocalPort;
    SITE_BINDING_KEY    bindingKey;
    SITE_BINDING *      pSiteBinding = NULL;
    LK_RETCODE          lkRet;
    MB                  mb( g_pStreamFilter->QueryMDObject() );

    fRet = mb.Open( pszSitePath,
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    fRet = mb.GetMultisz( NULL,
                          MD_SECURE_BINDINGS,
                          IIS_MD_UT_SERVER,
                          &mszBindings,
                          0 );
    if ( fRet )
    {
        //
        // With the secure binding, find any existing sites with this binding
        // and remove them.
        //
            
        pszBinding = (LPWSTR) mszBindings.First();           
        do
        {
            if ( pszBinding == NULL )
            {
                //
                // An empty site binding was set.  Just bail
                //
                
                break;
            }
                
            hr = SITE_BINDING::ParseSiteBinding( pszBinding,
                                                 &LocalAddress,
                                                 &LocalPort );
            if ( FAILED( hr ) )
            {
                break;
            }
                
            //
            // Keep track if we have encountered a non-wildcard bound
            // site.  This will speed up our lookup of site bindings
            // at "run-time"
            //
                
            if ( sm_fAllWildcardBindings &&
                 LocalAddress != WILDCARD_ADDRESS )
            {
                sm_fAllWildcardBindings = FALSE;
            }
            
            //
            // Delete the site for the given binding
            //

            bindingKey = GenerateBindingKey( LocalAddress, LocalPort );

            sm_pSiteBindingHash->DeleteKey( bindingKey );
            
            //
            // Now insert a new entry 
            //
            
            pSiteBinding = new SITE_BINDING( LocalAddress,
                                             LocalPort,
                                             dwSiteId );
            if ( pSiteBinding == NULL )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }    
                
            lkRet = sm_pSiteBindingHash->InsertRecord( pSiteBinding );
            if ( lkRet != LK_SUCCESS )
            {
                //
                // ISSUE:  What to do
                //
            }
            else
            {
                //
                // The hash table owns the reference
                //
                    
                pSiteBinding->DereferenceSiteBinding();
            }
        }
        while ( pszBinding = (LPWSTR) mszBindings.Next( pszBinding ) );
    }
    
    return NO_ERROR;
}

//static
HRESULT
SITE_BINDING::GetSiteId(
    DWORD               LocalAddress,
    USHORT              LocalPort,
    DWORD *             pdwSiteId
)
/*++

Routine Description:

    Given an ip-address/port, determine the matching site id

Arguments:

    LocalAddress - Local IP address
    LocalPort - Local Port
    pdwSiteId - Filled with site id on success
    
Return Value:

    HRESULT

--*/
{
    SITE_BINDING_KEY            bindingKey;
    LK_RETCODE                  lkrc;
    SITE_BINDING *              pSiteBinding = NULL;
    
    if ( pdwSiteId == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    *pdwSiteId = 0;
    
    DBG_ASSERT( sm_pSiteBindingHash != NULL );
    
    //
    // Do we have an non-wildcard bindings in the table?  If so start by 
    // looking up the specific ip-address/port pair
    //
    
    if ( !sm_fAllWildcardBindings )
    {
        bindingKey = GenerateBindingKey( LocalAddress, LocalPort );
        
        lkrc = sm_pSiteBindingHash->FindKey( bindingKey, &pSiteBinding );
        if ( lkrc == LK_SUCCESS )
        {
            //
            // We're done!  
            //
            
            DBG_ASSERT( pSiteBinding != NULL );
            
            *pdwSiteId = pSiteBinding->QuerySiteId();
            
            pSiteBinding->DereferenceSiteBinding();
            
            return NO_ERROR;
        }
    }
    
    //
    // Now we try to find a wildcard binding
    //
    
    bindingKey = GenerateBindingKey( WILDCARD_ADDRESS, LocalPort );
    
    lkrc = sm_pSiteBindingHash->FindKey( bindingKey, &pSiteBinding );
    if ( lkrc == LK_SUCCESS )
    {
        //
        // We're done!  
        //
            
        DBG_ASSERT( pSiteBinding != NULL );
            
        *pdwSiteId = pSiteBinding->QuerySiteId();
            
        pSiteBinding->DereferenceSiteBinding();
            
        return NO_ERROR;
    }
    
    //
    // Could not find a binding.
    //
    
    return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\sitecred.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     sitecred.cxx

   Abstract:
     SChannel site credentials
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SITE_CREDENTIALS::SITE_CREDENTIALS()
    : _fInitCreds( FALSE ),
      _fInitCredsDSMapper( FALSE )
{
    ZeroMemory( &_hCreds, sizeof( _hCreds ) );
    ZeroMemory( &_hCredsDSMapper, sizeof( _hCredsDSMapper ) );
}

SITE_CREDENTIALS::~SITE_CREDENTIALS()
{
    if ( _fInitCreds )
    {
        FreeCredentialsHandle( &_hCreds );
        _fInitCreds = FALSE;
    }
    
    if ( _fInitCredsDSMapper )
    {
        FreeCredentialsHandle( &_hCredsDSMapper );
        _fInitCredsDSMapper = FALSE;
    }
}

//static
HRESULT
SITE_CREDENTIALS::Initialize(
    VOID
)
/*++

Routine Description:

    Credentials global init

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    return NO_ERROR;
}

//static
VOID
SITE_CREDENTIALS::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup globals

Arguments:

    None

Return Value:

    None

--*/
{
}

HRESULT
SITE_CREDENTIALS::AcquireCredentials(
    SERVER_CERT *           pServerCert,
    BOOL                    fUseDsMapper
)
/*++

Routine Description:

    Acquire SChannel credentials for the given server certificate and 
    certificate mapping configuration

Arguments:

    pServerCert - Server certificate
    pCertMapping - Certificate mapping configuration

Return Value:

    HRESULT

--*/
{
    SCHANNEL_CRED               schannelCreds;
    SECURITY_STATUS             secStatus;
    TimeStamp                   tsExpiry;
    
    if ( pServerCert == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    //
    // First setup credentials to work with no mapping
    // 
    
    ZeroMemory( &schannelCreds, sizeof( schannelCreds ) );
    schannelCreds.dwVersion = SCHANNEL_CRED_VERSION;
    schannelCreds.cCreds = 1;
    schannelCreds.paCred = pServerCert->QueryCertContext();
    schannelCreds.cMappers = 0;
    schannelCreds.aphMappers = NULL;
    schannelCreds.hRootStore = NULL;
    schannelCreds.dwFlags = SCH_CRED_NO_SYSTEM_MAPPER;

    secStatus = AcquireCredentialsHandle( NULL,
                                          UNISP_NAME_W,
                                          SECPKG_CRED_INBOUND,
                                          NULL,
                                          &schannelCreds,
                                          NULL,
                                          NULL,
                                          &_hCreds,
                                          &tsExpiry ); 
    
    if ( FAILED( secStatus ) )
    {
        //
        // If we can't even establish plain-jane credentials, then bail
        //
        
        return secStatus;
    }
    _fInitCreds = TRUE;
    
    //
    // Now setup credentials which enable DS certificate mapping
    //
    
    if ( fUseDsMapper )
    {
        schannelCreds.dwFlags = 0;

        ZeroMemory( &schannelCreds, sizeof( schannelCreds ) );
        schannelCreds.dwVersion = SCHANNEL_CRED_VERSION;
        schannelCreds.cCreds = 1;
        schannelCreds.paCred = pServerCert->QueryCertContext();
        schannelCreds.hRootStore = NULL;


        secStatus = AcquireCredentialsHandle( NULL,
                                              UNISP_NAME_W,
                                              SECPKG_CRED_INBOUND,
                                              NULL,
                                              &schannelCreds,
                                              NULL,
                                              NULL,
                                              &_hCredsDSMapper,
                                              &tsExpiry ); 
        if ( SUCCEEDED( secStatus ) )
        {
            _fInitCredsDSMapper = TRUE;
        }
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\siteconfig.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     siteconfig.cxx

   Abstract:
     SSL configuration for a given site
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

SITE_CONFIG_HASH *   SITE_CONFIG::sm_pSiteConfigHash;

//static
HRESULT
SITE_CONFIG::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize site configuration globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    sm_pSiteConfigHash = new SITE_CONFIG_HASH();
    if ( sm_pSiteConfigHash == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
SITE_CONFIG::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup site configuration globals

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pSiteConfigHash != NULL )
    {
        //
        // Clear hash table before deleting it
        //
        sm_pSiteConfigHash->Clear();
        delete sm_pSiteConfigHash;
        sm_pSiteConfigHash = NULL;
    }
}

//static
HRESULT
SITE_CONFIG::GetSiteConfig(
    DWORD                   dwSiteId,
    SITE_CONFIG **          ppSiteConfig
)
/*++

Routine Description:

    Lookup site configuration in hash table.  If not there then create it
    and add it to table

Arguments:

    dwSiteId - Site ID to lookup
    ppSiteConfig - Filled with pointer to site config on success

Return Value:

    HRESULT

--*/
{
    LK_RETCODE              lkrc; 
    SITE_CONFIG *           pSiteConfig = NULL;
    SERVER_CERT *           pServerCert = NULL;
    HRESULT                 hr = NO_ERROR;
    WCHAR                   achNum[ 64 ];
    STACK_STRU(             strMBPath, 64 );
    
    if ( ppSiteConfig == NULL ||
         dwSiteId == 0 )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppSiteConfig = NULL;
    
    //
    // First lookup in the cache
    //

    DBG_ASSERT( sm_pSiteConfigHash != NULL );

    lkrc = sm_pSiteConfigHash->FindKey( dwSiteId,
                                        &pSiteConfig );

    if ( lkrc == LK_SUCCESS )
    {
        DBG_ASSERT( pSiteConfig != NULL );
        *ppSiteConfig = pSiteConfig;
        return NO_ERROR;
    }
    
    //
    // Ok.  We will have to make a new config object and add it to cache.  
    // Start by getting the server certificate.
    //

    
    //
    // Check if Client certificates are required on the site's root level
    //
    
    MB                      mb( g_pStreamFilter->QueryMDObject() );
    WCHAR                   achMBPath[ 256 ];
    DWORD                   dwSslAccessPerm = 0;
    BOOL                    fRequireClientCert = FALSE;
    DWORD                   dwUseDsMapper = 0;
    BOOL                    fUseDSMapper = FALSE;
    DWORD                   dwCertCheckMode = 0;
    DWORD                   dwRevocationFreshnessTime = 86400;   // 1 day in seconds
    DWORD                   dwRevocationUrlRetrievalTimeout = 0; // default timeout
        
    if ( mb.Open( L"/LM/W3SVC/",
                  METADATA_PERMISSION_READ ) )
    {
        //
        // Lookup SSLUseDsMapper 
        // SSLUseDsMapper is global setting that is not inherited to sites (IIS5 legacy)
        // We have to read it from lm/w3svc
        //    

        mb.GetDword( L"",
                     MD_SSL_USE_DS_MAPPER,
                     IIS_MD_UT_SERVER,
                     &dwUseDsMapper );
                     
        fUseDSMapper = !!dwUseDsMapper;

        //
        // lookup if client certificates are required on site (or site's root level)
        //
        
        _snwprintf( achMBPath,
                sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                L"/%d/root/",
                dwSiteId );
    
        mb.GetDword( achMBPath,
                     MD_SSL_ACCESS_PERM,
                     IIS_MD_UT_FILE,
                     &dwSslAccessPerm );
                     
        fRequireClientCert = ( ( dwSslAccessPerm & MD_ACCESS_REQUIRE_CERT ) &&
                                ( dwSslAccessPerm & MD_ACCESS_NEGO_CERT ) );

        //
        // lookup Certificate revocation related parameters
        //
        
        _snwprintf( achMBPath,
                    sizeof( achMBPath ) / sizeof( WCHAR ) - 1,
                    L"/%d/",
                    dwSiteId );
        
        mb.GetDword( achMBPath,
                     MD_CERT_CHECK_MODE,
                     IIS_MD_UT_SERVER,
                     &dwCertCheckMode );
        
        mb.GetDword( achMBPath,
                     MD_REVOCATION_FRESHNESS_TIME,
                     IIS_MD_UT_SERVER,
                     &dwRevocationFreshnessTime );
        
        mb.GetDword( achMBPath,
                     MD_REVOCATION_URL_RETRIEVAL_TIMEOUT,
                     IIS_MD_UT_SERVER,
                     &dwRevocationUrlRetrievalTimeout );
        
        mb.Close();
    }

   
    //
    // We have enough to lookup in SERVER_CERT cache
    //
    
    hr = SERVER_CERT::GetServerCertificate( dwSiteId,
                                            &pServerCert );
    if ( FAILED( hr ) )
    {
        //
        // If we couldn't get a server cert, then we're toast and SSL will
        // not be enablable for this site.
        //
        
        return hr;
    }
    
    DBG_ASSERT( pServerCert != NULL );

    
    //
    // OK.  Create the config and attempt to add it to the cache
    //

    pSiteConfig = new SITE_CONFIG( dwSiteId, 
                                   pServerCert,
                                   fRequireClientCert,
                                   fUseDSMapper,
                                   dwCertCheckMode,
                                   dwRevocationFreshnessTime,
                                   dwRevocationUrlRetrievalTimeout );
    if ( pSiteConfig == NULL )
    {
        pServerCert->DereferenceServerCert();
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    //
    // Acquire credentials
    //
    
    hr = pSiteConfig->AcquireCredentials();
    if ( FAILED( hr ) )
    {
        delete pSiteConfig;
        return hr;
    }
    
    //
    // We don't care what the success of the insertion was.  If it failed,
    // then the pSiteConfig will not be extra referenced and the caller
    // will clean it up when it derefs
    //
     
    sm_pSiteConfigHash->InsertRecord( pSiteConfig ); 
    
    *ppSiteConfig = pSiteConfig;
    
    return NO_ERROR;
}

//static
LK_PREDICATE
SITE_CONFIG::ServerCertPredicate(
    SITE_CONFIG *           pSiteConfig,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate used to find items which reference the 
    SERVER_CERT pointed to by pvState    

  Arguments:

    pSiteConfig - Site config (duh)
    pvState - SERVER_CERT to check for

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE          lkpAction;
    SERVER_CERT *         pServerCert;

    DBG_ASSERT( pSiteConfig != NULL );
    
    pServerCert = (SERVER_CERT*) pvState;
    DBG_ASSERT( pServerCert != NULL );
    
    if ( pSiteConfig->QueryServerCert() == pServerCert )
    {
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
SITE_CONFIG::FlushByServerCert(
    SERVER_CERT *           pServerCert
)
/*++

Routine Description:

    Flush the SITE_CONFIG cache of anything referecing the given server
    certificate

Arguments:

    pServerCert - Server certificate to reference

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pSiteConfigHash != NULL );
    
    sm_pSiteConfigHash->DeleteIf( SITE_CONFIG::ServerCertPredicate,
                                  pServerCert );
    
    return NO_ERROR;
}

//static
LK_PREDICATE
SITE_CONFIG::SiteIdPredicate(
    SITE_CONFIG *           pSiteConfig,
    void *                  pvState
)
/*++

  Description:

    DeleteIf() predicate to delete config specified by site id (pvState)

  Arguments:

    pSiteConfig - Site config (duh)
    pvState - Site ID

  Returns:

    LK_PREDICATE   - LKP_PERFORM indicates removing the current 
                                 token from token cache

                     LKP_NO_ACTION indicates doing nothing.

--*/
{
    LK_PREDICATE            lkpAction;
    DWORD                   dwSiteId;

    DBG_ASSERT( pSiteConfig != NULL );
    
    dwSiteId = PtrToUlong(pvState);
    
    if ( pSiteConfig->QuerySiteId() == dwSiteId ||
         dwSiteId == 0 )
    {
        lkpAction = LKP_PERFORM;
    }
    else
    {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
} 

//static
HRESULT
SITE_CONFIG::FlushBySiteId(
    DWORD                   dwSiteId
)
/*++

Routine Description:

    Flush specified site configuration.  If dwSiteId is 0, then flush all

Arguments:

    dwSiteId - Site ID to flush (0 for all)

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( sm_pSiteConfigHash != NULL );
    
    sm_pSiteConfigHash->DeleteIf( SITE_CONFIG::SiteIdPredicate,
                                  (PVOID) UIntToPtr(dwSiteId) );

    return NO_ERROR;
}

SITE_CONFIG::~SITE_CONFIG()
{
    if ( _pServerCert != NULL )
    {
        _pServerCert->DereferenceServerCert();
        _pServerCert = NULL;
    }
    
    _dwSignature = SITE_CONFIG_SIGNATURE_FREE;
}

HRESULT
SITE_CONFIG::AcquireCredentials(
    VOID
)
/*++

Routine Description:

    To the Schannel thing to get credentials handles representing the 
    server cert/mapping configuration of this site

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _pServerCert != NULL );
    
    return _SiteCreds.AcquireCredentials( _pServerCert,
                                          _fUseDSMapper );
                                        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\sslcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     sslcontext.cxx

   Abstract:
     SSL stream context
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"


//static
HRESULT
SSL_STREAM_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize all SSL global data

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    
    hr = CERT_STORE::Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = SERVER_CERT::Initialize();
    if ( FAILED( hr ) )
    {
        CERT_STORE::Terminate();
        return hr;
    }
        
    hr = SITE_CREDENTIALS::Initialize();
    if ( FAILED( hr ) )
    {
        SERVER_CERT::Terminate();
        CERT_STORE::Terminate();
        return hr;
    }
    
    hr = SITE_BINDING::Initialize();
    if ( FAILED( hr ) ) 
    {
        SITE_CREDENTIALS::Terminate();
        SERVER_CERT::Terminate();
        CERT_STORE::Terminate();
        return hr;
    }

    //
    // SITE_CONFIG uses 
    //      SERVER_CERT, 
    //      SITE_CREDENTIALS and 
    //

    hr = SITE_CONFIG::Initialize();
    if ( FAILED( hr ) )
    {
        SITE_BINDING::Terminate();
        SITE_CREDENTIALS::Terminate();
        SERVER_CERT::Terminate();
        CERT_STORE::Terminate();
        return hr;
    }
    
    return hr;
}


//static
VOID
SSL_STREAM_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate SSL

Arguments:

    None

Return Value:

    None

--*/
{
    SITE_CONFIG::Terminate();

    SITE_BINDING::Terminate();
    
    SITE_CREDENTIALS::Terminate();
    
    SERVER_CERT::Terminate();
    
    CERT_STORE::Terminate();
}    


SSL_STREAM_CONTEXT::SSL_STREAM_CONTEXT(
    UL_CONTEXT *            pUlContext
)
    : STREAM_CONTEXT( pUlContext ),
      _pSiteConfig( NULL ),
      _sslState( SSL_STATE_HANDSHAKE_START ),
      _fRenegotiate( FALSE ),
      _fValidContext( FALSE ),
      _cbReReadOffset( 0 ),
      _pClientCert( NULL ),
      _fDoCertMap( FALSE ),
      _hDSMappedToken( NULL ),
      _cbDecrypted( 0 )      
{
    //
    // Initialize security buffer structs
    //
    
    //
    // Setup buffer to hold incoming raw data
    //
    
    _Message.ulVersion = SECBUFFER_VERSION;
    _Message.cBuffers = 4;
    _Message.pBuffers = _Buffers;

    _Buffers[0].BufferType = SECBUFFER_EMPTY;
    _Buffers[1].BufferType = SECBUFFER_EMPTY;
    _Buffers[2].BufferType = SECBUFFER_EMPTY;
    _Buffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Setup buffer for ASC to return raw data to be sent to client
    //

    _MessageOut.ulVersion = SECBUFFER_VERSION;
    _MessageOut.cBuffers = 4;
    _MessageOut.pBuffers = _OutBuffers;

    _OutBuffers[0].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[1].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[2].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[3].BufferType = SECBUFFER_EMPTY;

    //
    // Setup buffer for app data to be encrypted
    //
    
    _EncryptMessage.ulVersion = SECBUFFER_VERSION;
    _EncryptMessage.cBuffers = 4;
    _EncryptMessage.pBuffers = _EncryptBuffers;
     
    _EncryptBuffers[0].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[1].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[2].BufferType = SECBUFFER_EMPTY;
    _EncryptBuffers[3].BufferType = SECBUFFER_EMPTY;

    ZeroMemory( &_hContext, sizeof( _hContext ) );
    ZeroMemory( &_ulSslInfo, sizeof( _ulSslInfo ) );
    ZeroMemory( &_ulCertInfo, sizeof( _ulCertInfo ) );
}

SSL_STREAM_CONTEXT::~SSL_STREAM_CONTEXT()
{
    if ( _fValidContext ) 
    {
        DeleteSecurityContext( &_hContext );
        _fValidContext = FALSE;
    }
    
    if ( _pSiteConfig != NULL )
    {
        _pSiteConfig->DereferenceSiteConfig();
        _pSiteConfig = NULL;
    }

    if( _hDSMappedToken != NULL )
    {
        CloseHandle( _hDSMappedToken );
        _hDSMappedToken = NULL;
    }

    if( _pClientCert != NULL )
    {
        CertFreeCertificateContext( _pClientCert );
        _pClientCert = NULL;
    }
}


HRESULT
SSL_STREAM_CONTEXT::ProcessNewConnection(
    CONNECTION_INFO *           pConnectionInfo
)
/*++

Routine Description:

    Handle a new raw connection

Arguments:

    pConnectionInfo - The magic connection information

Return Value:

    HRESULT

--*/
{
    DWORD                   dwSiteId = 0;
    HRESULT                 hr = S_OK;
    SITE_CONFIG *           pSiteConfig = NULL;
   
    DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_START );
    DBG_ASSERT( _pSiteConfig == NULL );

    //
    // Determine the site for this request
    //
    
    hr = SITE_BINDING::GetSiteId( pConnectionInfo->LocalAddress,
                                  pConnectionInfo->LocalPort,
                                  &dwSiteId );
    if ( FAILED( hr ) )
    {
        if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            //
            // Not finding the site just means this is not an SSL site
            //
            
            return S_OK;
        }
        
        return hr;
    }
    
    QueryUlContext()->SetIsSecure( TRUE );
    
    DBG_ASSERT( dwSiteId != 0 );
    
    //
    // Now find a server cert.  If we can't this connection is toast!
    //
   
    hr = SITE_CONFIG::GetSiteConfig( dwSiteId,
                                     &pSiteConfig );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Store away the site config for this connection
    //
    
    DBG_ASSERT( pSiteConfig != NULL );
    _pSiteConfig = pSiteConfig;
    
    return S_OK;
}

    
HRESULT
SSL_STREAM_CONTEXT::ProcessRawReadData(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfReadMore,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Handle an SSL read completion off the wire

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfReadMore - Set to TRUE if we should read more
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = S_OK;
    BOOL                    fSecureConnection;
    BOOL                    fExtraData = FALSE;
    //
    // Do we have site config?  If not, then this isn't an SSL connection
    //
    
    if ( _pSiteConfig == NULL )
    {
        return S_OK;
    }

    //
    // Loop for extra data 
    // Sometimes one RawStreamInfo buffer may contain multiple blobs 
    // some to be processed by DoHandshake() and some by DoDecrypt()
    // The do-while loop enables switching between these 2 functions as needed
    //

    do
    {
        fExtraData  = FALSE;
        *pfReadMore = FALSE;
        *pfComplete = FALSE;
        //
        // Either continue handshake or immediate decrypt data
        // 

        switch ( _sslState )
        {
        case  SSL_STATE_HANDSHAKE_START:
        case  SSL_STATE_HANDSHAKE_IN_PROGRESS:

            hr = DoHandshake( pRawStreamInfo,
                              pfReadMore,
                              pfComplete,
                              &fExtraData );
            break;                              
        case  SSL_STATE_HANDSHAKE_COMPLETE:
        
            hr = DoDecrypt( pRawStreamInfo,
                            pfReadMore,
                            pfComplete,
                            &fExtraData );
            break;
        default:
            DBG_ASSERT( FALSE );
        }

        if ( FAILED( hr ) )
        {
            break;
        }

    //
    // Is there still some extra data to be processed?
    //
    
    }while( fExtraData ); 
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::ProcessRawWriteData(
    RAW_STREAM_INFO *               pRawStreamInfo,
    BOOL *                          pfComplete
)
/*++

Routine Description:

    Called on read completion from app. Data received 
    from application must be encrypted and sent to client
    using RawWrite.
    Application may have also requested renegotiation 
    (with or without mapping) if client certificate
    is not yet present

Arguments:

    pRawStreamInfo - Points to input stream and size
    pfComplete - Set to TRUE if we should disconnect

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr;
    HTTP_FILTER_BUFFER_TYPE bufferType; 

    if ( _pSiteConfig == NULL )
    {
        //
        // We never found SSL to be relevent for this connection.  Do nothing
        //
        
        return S_OK;
    }
    
    DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_COMPLETE );

    bufferType = QueryUlContext()->QueryFilterBufferType();

    //
    // Is this data from the application, or a request for renegotiation?
    //
    
    if ( bufferType == HttpFilterBufferSslRenegotiate ||
         bufferType == HttpFilterBufferSslRenegotiateAndMap )
    {
        //
        // If we have already renegotiated a client certificate, then there
        // is nothing to do, but read again for stream data
        //
        
        if ( _fRenegotiate )
        {
            hr = S_OK;
        }
        else
        {
            if ( bufferType == HttpFilterBufferSslRenegotiateAndMap )
            {
                _fDoCertMap = TRUE;
            }

            hr = DoRenegotiate();
        }    
    }
    else
    {
        DBG_ASSERT( bufferType == HttpFilterBufferHttpStream );
        
        hr = DoEncrypt( pRawStreamInfo,
                        pfComplete );
    }
    
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::SendDataBack(
    RAW_STREAM_INFO *           pRawStreamInfo
)
/*++

Routine Description:

    Send back data (different then ProcessRawWrite because in this case
    the data was not received by the application, but rather a raw filter)

Arguments:

    pRawStreamInfo - Points to input stream and size

Return Value:

    HRESULT

--*/
{
    BOOL                    fComplete;
    HRESULT                 hr;
    
    if ( pRawStreamInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( _pSiteConfig != NULL )
    {
        //
        // We must have completed the handshake to get here, since this path
        // is only invoked by ISAPI filters 
        //
    
        DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_COMPLETE );
        
        hr = DoEncrypt( pRawStreamInfo,
                        &fComplete );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    
    //
    // Send back the data
    //

    return QueryUlContext()->DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                                         pRawStreamInfo->pbBuffer,
                                         pRawStreamInfo->cbData,
                                         NULL );
}


HRESULT
SSL_STREAM_CONTEXT::DoHandshake(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete,
    BOOL *                      pfExtraData

)
/*++

Routine Description:

    Do the handshake thing with AcceptSecurityContext()

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore - Set to true if more data should be read
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS             secStatus = SEC_E_OK;
    HRESULT                     hr = E_FAIL;
    SECURITY_STATUS             secInfo;
    DWORD                       dwFlags = SSL_ASC_FLAGS;
    DWORD                       dwContextAttributes;
    TimeStamp                   tsExpiry;
    CtxtHandle                  hOutContext;

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        goto ExitPoint;
    }
    
    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DoHandshake(): _cbDecrypted = %d, _cbReReadOffset=%d\n",
                    _cbDecrypted,
                    _cbReReadOffset
                 ));
    }



    DBG_ASSERT( _pSiteConfig != NULL );
    
    //
    // Setup a call to AcceptSecurityContext()
    //  

    
    _Buffers[ 0 ].pvBuffer = pRawStreamInfo->pbBuffer + _cbReReadOffset;
    _Buffers[ 0 ].cbBuffer = pRawStreamInfo->cbData - _cbReReadOffset;
    _Buffers[ 0 ].BufferType = SECBUFFER_TOKEN;
    _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[ 0 ].pvBuffer = NULL;

    //
    // Are we renegotiating for client cert?
    // if _pSiteConfig->QueryRequireClientCert() is TRUE
    // it means that Client certificates are enabled on root level
    // of the site. In that case we enable optimization where
    // client certificates are negotiated right away to eliminate
    // expensive renegotiation

    DBG_ASSERT( _pSiteConfig != NULL );
    if ( _fRenegotiate || _pSiteConfig->QueryRequireClientCert() )
    {
        dwFlags |= ASC_REQ_MUTUAL_AUTH;
    }

    if ( _sslState == SSL_STATE_HANDSHAKE_START )
    {
        secStatus = AcceptSecurityContext( QueryCredentials(),
                                           NULL,
                                           &_Message,
                                           dwFlags,
                                           SECURITY_NATIVE_DREP,
                                           &_hContext,
                                           &_MessageOut,
                                           &dwContextAttributes,
                                           &tsExpiry );
        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AcceptSecurityContext() secStatus=0x%x\n",
                        secStatus
                        ));
        }

        if ( SUCCEEDED( secStatus ) )
        {
            _cbHeader = 0;
            _cbTrailer = 0;
            _cbBlockSize = 0;
            _cbMaximumMessage = 0;
                
            _fValidContext = TRUE;
            _sslState = SSL_STATE_HANDSHAKE_IN_PROGRESS;
        }                                               
    }
    else
    {
        DBG_ASSERT( _sslState == SSL_STATE_HANDSHAKE_IN_PROGRESS );
        
        //
        // We already have a valid context.  We can directly call 
        // AcceptSecurityContext()!
        //
            
        hOutContext = _hContext;
        
        DBG_ASSERT( _fValidContext );
        
        secStatus = AcceptSecurityContext( QueryCredentials(),
                                           &_hContext,
                                           &_Message,
                                           dwFlags,
                                           SECURITY_NATIVE_DREP,
                                           &hOutContext,
                                           &_MessageOut,
                                           &dwContextAttributes,
                                           &tsExpiry );
                                           
        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "AcceptSecurityContext() secStatus=0x%x\n",
                        secStatus
                        ));
        }

        
        if ( SUCCEEDED( secStatus ) )
        {
            //
            // Store the context (LAME)
            //
            
            _hContext = hOutContext;
        }
    }
    
    //
    // Either way, the secStatus tells us how to proceed
    //

    if ( SUCCEEDED( secStatus ) )
    {
        //
        // We haven't failed yet.  But we may not be complete.  First 
        // send back any data to the client
        //  

        if ( _OutBuffers[ 0 ].pvBuffer )
        {   
            DBG_ASSERT( _OutBuffers[ 0 ].cbBuffer != 0 );
            hr = QueryUlContext()->DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                                               _OutBuffers[ 0 ].pvBuffer,
                                               _OutBuffers[ 0 ].cbBuffer,
                                               NULL );
    
            if ( FAILED( hr ) )
            {
                goto ExitPoint;
            }
        }
        
        if ( secStatus == SEC_E_OK )
        {
            //
            // We must be done with handshake
            //

            hr = DoHandshakeCompleted();

            if ( FAILED( hr ) )
            {
                goto ExitPoint;
            }
        }
        
        //
        // If the input buffer has more info to be SChannel'ized, then do 
        // so now.  If we haven't completed handshake, then call DoHandShake
        // again.  Otherwise, call DoDecrypt
        //
        
        if ( _Buffers[ 1 ].BufferType == SECBUFFER_EXTRA )
        {

            IF_DEBUG( SCHANNEL_CALLS )
            {
                for ( int i = 1; i < 4; i++ )
                {
                    if( _Buffers[ i ].BufferType != 0 )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "AcceptSecurityContext returned extra buffer"
                                    " - %d bytes buffer type: %d\n",
                                    _Buffers[ i ].cbBuffer,
                                    _Buffers[ i ].BufferType
                        ));
                    }
                }
            }

            //
            // We better have valid extra data
            // only cbBuffer is used, pvBuffer is not used with SECBUFFER_EXTRA 
            //
            DBG_ASSERT( _Buffers[ 1 ].cbBuffer != 0 );

            //    
            // Move extra data right after decrypted data (if any)
            //
            
            memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                     pRawStreamInfo->pbBuffer + pRawStreamInfo->cbData 
                     - _Buffers[ 1 ].cbBuffer,
                     _Buffers[ 1 ].cbBuffer
                   );

            //
            // Now we have to adjust pRawStreamInfo->cbData and _cbReReadOffset
            // 
            
            pRawStreamInfo->cbData = ( _cbDecrypted +
                                       _Buffers[ 1 ].cbBuffer );

            _cbReReadOffset = _cbDecrypted;
            
            *pfExtraData = TRUE;

            //
            // caller has to detect that some data is
            // still in the buffer not processed and
            //
            hr = S_OK;
            goto ExitPoint;
        }
        else  // no extra buffer
        {
            //
            // There is no extra data to be processed
            // If we got here as the result of renegotiation
            // there may be some decrypted data in StreamInfo buffer already

            //
            // (without renegotiation _cbDecryted must always be 0
            // because SEC_I_RENEGOTIATE is the only way to get 
            // from DoDecrypt() to DoHandshake() )
            //
            
            DBG_ASSERT ( _fRenegotiate || _cbDecrypted == 0 );
            
            pRawStreamInfo->cbData = _cbDecrypted;
            _cbReReadOffset = _cbDecrypted;
          

            if ( _sslState != SSL_STATE_HANDSHAKE_COMPLETE )
            {
                //
                // If we have no more data, and we still haven't completed the
                // handshake, then read some more data
                //
        
                *pfReadMore = TRUE;
                hr = S_OK;
                goto ExitPoint;
            }
        }
        //
        // final return from DoHandshake on handshake completion
        // Cleanup _cbDecrypted and _cbReReadOffset to make 
        // sure that next ProcessRawReadData() will work fine    
        //
        
        _cbReReadOffset = 0;
        _cbDecrypted = 0;
        
        hr = S_OK;
        goto ExitPoint;
    }
    else
    {
        //
        // AcceptSecurityContext() failed!
        //
        
        if ( secStatus == SEC_E_INCOMPLETE_MESSAGE )
        {
            *pfReadMore = TRUE;
            hr = S_OK;
            goto ExitPoint;
        }
        else
        {
            //
            // Maybe we can send a more useful message to the client
            //
        
            if ( dwContextAttributes & ASC_RET_EXTENDED_ERROR )
            {
                if ( _OutBuffers[ 0 ].pvBuffer!= NULL &&
                     _OutBuffers[ 0 ].cbBuffer != 0 )
                {    
                    hr = QueryUlContext()->DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                                                  _OutBuffers[ 0 ].pvBuffer,
                                                  _OutBuffers[ 0 ].cbBuffer,
                                                  NULL );

                    if( FAILED( hr ) )
                    {
                        goto ExitPoint;
                    }
                }
            }
        }
        hr = secStatus;
    }
    
ExitPoint:    
    if ( _OutBuffers[ 0 ].pvBuffer != NULL )
    {   
        FreeContextBuffer( _OutBuffers[ 0 ].pvBuffer );
        _OutBuffers[ 0 ].pvBuffer = NULL;
    
    }    
    return hr;    
}


HRESULT
SSL_STREAM_CONTEXT::DoHandshakeCompleted()
{
    HRESULT                     hr          = S_OK;
    SECURITY_STATUS             secStatus   = SEC_E_OK;
    SecPkgContext_StreamSizes   StreamSizes;
    HTTP_FILTER_BUFFER          ulFilterBuffer;


    _sslState = SSL_STATE_HANDSHAKE_COMPLETE;

    //
    // Get some buffer size info for this connection.  We only need
    // to do this on completion of the initial handshake, and NOT
    // subsequent renegotiation handshake (if any)
    //             

    if ( !_cbHeader && !_cbTrailer )
    {
        secStatus = QueryContextAttributes( &_hContext,
                                            SECPKG_ATTR_STREAM_SIZES,
                                            &StreamSizes );
        if ( FAILED( secStatus ) )
        {
            return secStatus;
        }            
    
        _cbHeader = StreamSizes.cbHeader;
        _cbTrailer = StreamSizes.cbTrailer;
        _cbBlockSize = StreamSizes.cbBlockSize;
        _cbMaximumMessage = StreamSizes.cbMaximumMessage;
    }

    //
    // Build up a message for the application indicating stuff
    // about the negotiated connection
    //
    // If this is a renegotiate request, then we have already sent
    // and calculated the SSL_INFO, so just send the CERT_INFO
    //

    if ( !_fRenegotiate )
    {
        hr = BuildSslInfo();
        if ( FAILED( hr ) )
        {
            return hr;
        }
    
        ulFilterBuffer.BufferType = HttpFilterBufferSslInitInfo;
        ulFilterBuffer.pBuffer = (PBYTE) &_ulSslInfo;
        ulFilterBuffer.BufferSize = sizeof( _ulSslInfo );
    }
    else
    {
        if ( SUCCEEDED( RetrieveClientCertAndToken() ) )
        {
            hr = BuildClientCertInfo();
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
    
        if ( _fDoCertMap )
        {
            ulFilterBuffer.BufferType = HttpFilterBufferSslClientCertAndMap;
        }
        else
        {
            ulFilterBuffer.BufferType = HttpFilterBufferSslClientCert;
        }
    
        ulFilterBuffer.pBuffer = (PBYTE) &_ulCertInfo;
        ulFilterBuffer.BufferSize = sizeof( _ulCertInfo );
    }

    //
    // Write the message to the application
    //

    hr = QueryUlContext()->DoAppWrite( UL_CONTEXT_FLAG_SYNC,
                                       &ulFilterBuffer,
                                       NULL );
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::DoRenegotiate(
    VOID
)
/*++

Routine Description:

    Trigger a renegotiate for a client certificate

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS             secStatus = SEC_E_OK;
    CtxtHandle                  hOutContext;
    DWORD                       dwContextAttributes = 0;
    TimeStamp                   tsExpiry;
    DWORD                       dwFlags = SSL_ASC_FLAGS | 
                                          ASC_REQ_MUTUAL_AUTH;
    HRESULT                     hr = S_OK;
    
    STACK_BUFFER(               buffOutBuffer, 100 );
    DWORD                       cbOutBuffer = 0;

    
    DBG_ASSERT( _pSiteConfig != NULL );
    
    //
    // Remember that we're renegotiating since we now have to pass the 
    // MUTUAL_AUTH flag into AcceptSecurityContext() from here on out.  Also
    // we can only request renegotiation once per connection
    //

    DBG_ASSERT( _fRenegotiate == FALSE );
    _fRenegotiate = TRUE;

    //
    // Try to get the client certificate.  If we don't, that's OK. We will 
    // renegotiate
    //

    hr = RetrieveClientCertAndToken();
    if ( SUCCEEDED ( hr ) )
    {
        //
        // we have client certificate available for this session
        // there is no need to continue with renegotiation
        //
        
        hr = DoHandshakeCompleted();
        return hr;
    }

    //
    // Reset the HRESULT 
    // Previous error failing to retrieve client certificate is OK,
    // it just means that renegotiation is necessary since
    // no client certificate is currently available
    
    hr = S_OK;
    
    //
    // Restart the handshake
    //

    _Buffers[ 0 ].BufferType = SECBUFFER_TOKEN;
    _Buffers[ 0 ].pvBuffer = "";
    _Buffers[ 0 ].cbBuffer = 0;
    _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;
    _OutBuffers[ 0 ].pvBuffer = NULL;
    
    hOutContext = _hContext;
    
    secStatus = AcceptSecurityContext( QueryCredentials(),
                                       &_hContext,
                                       &_Message,
                                       dwFlags,
                                       SECURITY_NATIVE_DREP,
                                       &hOutContext,
                                       &_MessageOut,
                                       &dwContextAttributes,
                                       &tsExpiry );
    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AcceptSecurityContext() secStatus=0x%x\n",
                    secStatus
                    ));
    }

    //
    // We need to make local copy of _OutBuffers[0] and call FreeContextBuffer()
    // before sending output of AcceptSecurityContext() to client 
    // by calling DoRawWrite because there is one pending asynchronous 
    // raw read launched already and after calling DoRawWrite
    // there could be other thread using the same SSL_STREAM_CONTEXT 
    // and SSL Context handle while this thread hasn't finished yet. 
    // That could cause AV (see NTBug 313774)
    //


    if ( _OutBuffers[ 0 ].pvBuffer != NULL )
    {
        if ( !buffOutBuffer.Resize(_OutBuffers[ 0 ].cbBuffer ) )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy( buffOutBuffer.QueryPtr(),
                    _OutBuffers[ 0 ].pvBuffer,
                    _OutBuffers[ 0 ].cbBuffer
                    );
            cbOutBuffer = _OutBuffers[ 0 ].cbBuffer;
        }

        FreeContextBuffer( _OutBuffers[ 0 ].pvBuffer );
        _OutBuffers[ 0 ].pvBuffer = NULL;
    }

    if ( FAILED (hr ) )
    {
        return hr;
    }
    
    if ( secStatus == SEC_E_UNSUPPORTED_FUNCTION )
    {
        //
        //  Renegotiation is not suppported for current protocol
        //  Change state to HandhakeCompleted        
        //
        hr = DoHandshakeCompleted();
    }
    else if ( SUCCEEDED( secStatus ) )
    {
        _hContext = hOutContext;
       
        _cbHeader = 0;
        _cbTrailer = 0;
        _cbBlockSize = 0;
        
        if ( buffOutBuffer.QueryPtr() != NULL &&
             cbOutBuffer != 0 )
        {   
            QueryUlContext()->DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                                          buffOutBuffer.QueryPtr(),
                                          cbOutBuffer,
                                          NULL );
        }
        hr = secStatus;
    }
    else
    {
        if ( dwContextAttributes & ASC_RET_EXTENDED_ERROR )
        {
            if ( buffOutBuffer.QueryPtr() != NULL &&
                 cbOutBuffer != 0 )
            {    
                QueryUlContext()->DoRawWrite( UL_CONTEXT_FLAG_SYNC,
                                              buffOutBuffer.QueryPtr(),
                                              cbOutBuffer,
                                              NULL );
            }
        }
        hr = secStatus;
    }

    
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::DoDecrypt(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfReadMore,
    BOOL *                      pfComplete,
    BOOL *                      pfExtraData
)
/*++

Routine Description:

    Decrypt some data

Arguments:

    pRawStreamInfo - Raw data buffer
    pfReadMore - Set to true if we should read more data
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    HRESULT                 hr = S_OK;
    INT                     iExtra;
    HTTP_FILTER_BUFFER      ulFilterBuffer;
    UCHAR                   FirstByte = 0;   //used only for debug output 

    if ( pRawStreamInfo == NULL ||
         pfReadMore == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfReadMore  = FALSE;
    *pfComplete  = FALSE;
    *pfExtraData = FALSE;

    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DoDecrypt(): _cbDecrypted = %d, _cbReReadOffset=%d\n",
                    _cbDecrypted,
                    _cbReReadOffset
                 ));
    }

    //
    // Setup an DecryptMessage call.  The input buffer is the _buffRaw plus 
    // an offset.  The offset is non-zero if we had to do another read to
    // get more data for a previously incomplete message
    //

    DBG_ASSERT( pRawStreamInfo->cbData > _cbReReadOffset );

    _Buffers[ 0 ].pvBuffer = pRawStreamInfo->pbBuffer + _cbReReadOffset;
    _Buffers[ 0 ].cbBuffer = pRawStreamInfo->cbData - _cbReReadOffset;
    _Buffers[ 0 ].BufferType = SECBUFFER_DATA;
    
    _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
    _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

DecryptAgain:

    IF_DEBUG( SCHANNEL_CALLS )
    {
        //
        // remember first byte because Decrypt will alter it
        //
        FirstByte = (unsigned char) *((char *)_Buffers[ 0 ].pvBuffer);
    }

    secStatus = DecryptMessage( &_hContext,
                               &_Message,
                               0,
                               NULL );
    IF_DEBUG( SCHANNEL_CALLS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "DecryptMessage( bytes:%d, first byte:0x%x ) secStatus=0x%x\n",
                    pRawStreamInfo->cbData - _cbReReadOffset,
                    FirstByte,
                    secStatus
                    ));
    }

    if ( FAILED( secStatus ) )
    {
        if ( secStatus == SEC_E_INCOMPLETE_MESSAGE )
        {
            //
            // Setup another read since the message is incomplete.  Remember
            // where the new data is going to since we only pass this data
            // to the next DecryptMessage call
            //
            
            _cbReReadOffset = DIFF( (BYTE *)_Buffers[ 0 ].pvBuffer -
                                    pRawStreamInfo->pbBuffer );

            QueryUlContext()->SetNextRawReadSize( _Buffers[ 1 ].cbBuffer );
            
            *pfReadMore = TRUE;
            
            return S_OK; 
        }                

        return secStatus;
    }

    if ( secStatus == SEC_E_OK )
    { 
        //
        // Take decrypted data and fit it into read buffer
        //
    
        memmove( pRawStreamInfo->pbBuffer + _cbDecrypted,
                 _Buffers[ 1 ].pvBuffer,
                 _Buffers[ 1 ].cbBuffer );
             
        _cbDecrypted += _Buffers[ 1 ].cbBuffer;
    }

    //
    // Locate extra data (may be available)
    //
    
    iExtra = 0;
    for ( int i = 1; i < 4; i++ )
    {     
        IF_DEBUG( SCHANNEL_CALLS )
        {
            if( _Buffers[ i ].BufferType != 0 )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "DecryptMessage returned extra buffer"
                            " - %d bytes buffer type: %d\n",
                            _Buffers[ i ].cbBuffer,
                            _Buffers[ i ].BufferType
                            ));
            }
        }
        
        if ( _Buffers[ i ].BufferType == SECBUFFER_EXTRA )
        {
            iExtra = i;
            break;
        }
    }
    
    if ( iExtra != 0 )
    {
        //
        // process extra buffer
        //
        
        _cbReReadOffset = DIFF( (PBYTE) _Buffers[ iExtra ].pvBuffer - 
                                pRawStreamInfo->pbBuffer );
        
        if ( secStatus != SEC_I_RENEGOTIATE )
        {
            _Buffers[ 0 ].pvBuffer = _Buffers[ iExtra ].pvBuffer;
            _Buffers[ 0 ].cbBuffer = _Buffers[ iExtra ].cbBuffer;
            _Buffers[ 0 ].BufferType = SECBUFFER_DATA;
            _Buffers[ 1 ].BufferType = SECBUFFER_EMPTY;
            _Buffers[ 2 ].BufferType = SECBUFFER_EMPTY;
            _Buffers[ 3 ].BufferType = SECBUFFER_EMPTY;

            goto DecryptAgain;
        }     
        else    // secStatus == SEC_I_RENEGOTIATE 
        {
            //
            // If a renegotiation is triggered, resume the handshake state
            //

            _sslState = SSL_STATE_HANDSHAKE_IN_PROGRESS;
    
            //
            // Caller has to detect that some data is
            // still in the buffer not processed and
            // That will signal to call DoHandshake() 
            // for that extra data
            //

            *pfExtraData = TRUE;
            return S_OK;
        }
    }

    //
    // there would have been extra data with SEC_I_RENEGOTIATE
    // so we must never get here when renegotiating
    //
    DBG_ASSERT( secStatus != SEC_I_RENEGOTIATE );

    //
    // Adjust cbData to include only decrypted data
    //
    pRawStreamInfo->cbData = _cbDecrypted;

    //
    // We have final decrypted buffer and no extra data left
    // Cleanup _cbDecrypted and _cbReReadOffset to make sure that 
    // next ProcessRawReadData() will work fine.    
    //
    
    _cbDecrypted = 0;
    _cbReReadOffset = 0;

 
    return S_OK;
}


HRESULT
SSL_STREAM_CONTEXT::DoEncrypt(
    RAW_STREAM_INFO *           pRawStreamInfo,
    BOOL *                      pfComplete
)
/*++

Routine Description:

    Encrypt data from the application

Arguments:

    pRawStreamInfo - Raw data buffer
    pfComplete - Set to true if we should disconnect

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS         secStatus = SEC_E_OK;
    HRESULT                 hr = S_OK;
    // number of chunks the data to be encrypted will be split to
    DWORD                   dwChunks = 0;
    // current Data chunk size to be encrypted
    DWORD                   cbDataChunk = 0;
    // bytes already encrypted from the source
    DWORD                   cbDataProcessed = 0;
    // offset to _buffRawWrite where new chunk should be placed
    DWORD                   cbRawWriteOffset = 0;


    if ( pRawStreamInfo == NULL ||
         pfComplete == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *pfComplete = FALSE;

    //
    // Each protocol has limit on maximum size of message 
    // that can be encrypted with one EncryptMessage() call
    //

    DBG_ASSERT( _cbMaximumMessage != 0 );

    //
    // Calculate number of chunks based on _cbMaximumMessage
    //

    dwChunks = pRawStreamInfo->cbData / _cbMaximumMessage;
    if ( pRawStreamInfo->cbData % _cbMaximumMessage != 0 )
    {
        dwChunks++;
    }

    //
    // Allocate a large enough buffer for encrypted data
    // ( remember that each chunk needs header and trailer )
    //
    
    if ( !_buffRawWrite.Resize( pRawStreamInfo->cbData + 
                                dwChunks  * _cbHeader + 
                                dwChunks  * _cbTrailer ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // Loop to encrypt required data in chunks each not exceeding _cbMaximumMessage
    //
    
    for ( DWORD dwCurrentChunk = 0; dwCurrentChunk < dwChunks; dwCurrentChunk++ )
    {
        DBG_ASSERT( _buffRawWrite.QuerySize() > cbRawWriteOffset );
    
        cbDataChunk = min( pRawStreamInfo->cbData - cbDataProcessed, 
                           _cbMaximumMessage ); 


        memcpy( (PBYTE) _buffRawWrite.QueryPtr() + _cbHeader + cbRawWriteOffset,
                pRawStreamInfo->pbBuffer + cbDataProcessed,
                cbDataChunk );
    
        _EncryptBuffers[ 0 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        cbRawWriteOffset;
        _EncryptBuffers[ 0 ].cbBuffer = _cbHeader;
        _EncryptBuffers[ 0 ].BufferType = SECBUFFER_STREAM_HEADER;
    
        _EncryptBuffers[ 1 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        _cbHeader +
                                        cbRawWriteOffset; 
        _EncryptBuffers[ 1 ].cbBuffer = cbDataChunk;
        _EncryptBuffers[ 1 ].BufferType = SECBUFFER_DATA;
    
        _EncryptBuffers[ 2 ].pvBuffer = (PBYTE) _buffRawWrite.QueryPtr() +
                                        _cbHeader +
                                        cbDataChunk +
                                        cbRawWriteOffset;
        _EncryptBuffers[ 2 ].cbBuffer = _cbTrailer;
        _EncryptBuffers[ 2 ].BufferType = SECBUFFER_STREAM_TRAILER;

        _EncryptBuffers[ 3 ].BufferType = SECBUFFER_EMPTY;

        secStatus = EncryptMessage( &_hContext,
                                 0,
                                 &_EncryptMessage,
                                 0 );

        IF_DEBUG( SCHANNEL_CALLS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "EncryptMessage() secStatus=0x%x\n",
                        secStatus
                        ));
        }
    

        if(SUCCEEDED(secStatus))
        {
            //
            // next chunk was successfully encrypted
            //
            
            cbDataProcessed  += cbDataChunk;
            cbRawWriteOffset += _EncryptBuffers[ 0 ].cbBuffer +
                                _EncryptBuffers[ 1 ].cbBuffer +
                                _EncryptBuffers[ 2 ].cbBuffer;
        }
        else
        {
            //
            // Set cbData to 0 just for the case that caller ignored error 
            // and tried to send not encrypted data to client 
            //

            pRawStreamInfo->cbData = 0;
            return secStatus;
        }
    }

    //
    // Replace the raw stream buffer with the encrypted data
    //

    pRawStreamInfo->pbBuffer = (PBYTE) _buffRawWrite.QueryPtr();
    pRawStreamInfo->cbBuffer = _buffRawWrite.QuerySize();
    pRawStreamInfo->cbData   = cbRawWriteOffset;
   
    return S_OK;
}


HRESULT
SSL_STREAM_CONTEXT::BuildSslInfo(
    VOID
)
/*++

Routine Description:

    Build UL_SSL_INFO structure based on Schannel context handle

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS         secStatus;
    SecPkgContext_KeyInfo   keyInfo;
    SERVER_CERT *           pServerCert = NULL;
    HRESULT                 hr = S_OK;

    //
    // Negotiated key size
    // 
    
    if ( _ulSslInfo.ConnectionKeySize == 0 )
    {
        secStatus = QueryContextAttributes( &_hContext,
                                            SECPKG_ATTR_KEY_INFO,
                                            &keyInfo );
        if ( SUCCEEDED( secStatus ) )
        {
            _ulSslInfo.ConnectionKeySize = (USHORT) keyInfo.KeySize;
            
            if ( keyInfo.sSignatureAlgorithmName != NULL )
            {
                FreeContextBuffer( keyInfo.sSignatureAlgorithmName );
            }
            
            if ( keyInfo.sEncryptAlgorithmName )
            {
                FreeContextBuffer( keyInfo.sEncryptAlgorithmName );
            }
        }
    }
    
    //
    // A bunch of parameters are based off the server certificate.  Get that
    // cert now
    //
    
    DBG_ASSERT( _pSiteConfig != NULL );
    
    pServerCert = _pSiteConfig->QueryServerCert();
    DBG_ASSERT( pServerCert != NULL );
    
    //
    // Server cert strength
    //
    
    if ( _ulSslInfo.ServerCertKeySize == 0 )
    {
        _ulSslInfo.ServerCertKeySize = pServerCert->QueryPublicKeySize();
    }

    //
    // Server Cert Issuer
    //
    
    if ( _ulSslInfo.pServerCertIssuer == NULL )
    {
        DBG_ASSERT( _ulSslInfo.ServerCertIssuerSize == 0 );
        
        _ulSslInfo.pServerCertIssuer = pServerCert->QueryIssuer()->QueryStr();
        _ulSslInfo.ServerCertIssuerSize = pServerCert->QueryIssuer()->QueryCCH();
    }
    
    //
    // Server Cert subject
    //
    
    if ( _ulSslInfo.pServerCertSubject == NULL )
    {
        DBG_ASSERT( _ulSslInfo.ServerCertSubjectSize == 0 );
        
        _ulSslInfo.pServerCertSubject = pServerCert->QuerySubject()->QueryStr(),
        _ulSslInfo.ServerCertSubjectSize = pServerCert->QuerySubject()->QueryCCH();
    }
    
    return hr;
}


HRESULT
SSL_STREAM_CONTEXT::RetrieveClientCertAndToken(
    VOID
)
/*++

Routine Description:

    Query client certificate and token from the SSL context

Arguments:

    none
    
Return Value:

    HRESULT

--*/
{
    SECURITY_STATUS secStatus = SEC_E_OK;
    HRESULT hr = S_OK;

    //
    // If client certificate has already been retrieved then simply return
    // with success
    //
    
    if ( _pClientCert != NULL )
    {
        return SEC_E_OK;
    }

    secStatus = QueryContextAttributes( &_hContext,
                                        SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                        &_pClientCert );
    if ( SUCCEEDED( secStatus ) )
    {
        DBG_ASSERT( _pClientCert != NULL );
    }
    else
    {
        goto ExitPoint;
    }

    //
    // If we got a client cert and mapping is enabled, then
    // request Schannel mapping
    //

    if( _hDSMappedToken != NULL )
    {
        CloseHandle( _hDSMappedToken );
        _hDSMappedToken = NULL;
    }

    if ( _fDoCertMap )
    {
        //
        // Only DS mapper is executed in streamfilt
        // IIS mapper is executed in w3core as part of IISCertmap Auth Provider
        //
        
        DBG_ASSERT( _pSiteConfig != NULL );
        if ( _pSiteConfig->QueryUseDSMapper() )
        {
            secStatus = QuerySecurityContextToken( &_hContext,
                                                      &_hDSMappedToken );
            if ( SUCCEEDED( secStatus ) )
            {
                DBG_ASSERT( _hDSMappedToken != NULL );
            }
        }

        if ( FAILED ( secStatus ) )
        {
           //
           // if token from mapping is not available
           // it is OK, no mapping was found or 
           // denied access mapping was used
           //
           // BUGBUG - some errors should probably be logged
           //
           secStatus = SEC_E_OK;
        }
    }
    
ExitPoint:
    return secStatus;
}


HRESULT
SSL_STREAM_CONTEXT::BuildClientCertInfo(
    VOID
)
/*++

Routine Description:

    Get client certificate info

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HCERTCHAINENGINE            hCertEngine = NULL;
    HRESULT                     hr = S_OK;
    CERT_CHAIN_PARA             chainPara;
    BOOL                        fRet;
    DWORD                       dwRet = ERROR_SUCCESS;
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    CERT_TRUST_STATUS           certStatus;
    const DWORD                 cbDefaultEnhKeyUsage = 100;
    STACK_BUFFER(               buffEnhKeyUsage, cbDefaultEnhKeyUsage );
    PCERT_ENHKEY_USAGE          pCertEnhKeyUsage = NULL;
    DWORD                       cbEnhKeyUsage = cbDefaultEnhKeyUsage;
    BOOL                        fEnablesClientAuth = FALSE;
    DWORD                       dwRevocationFlags = 0;

    DBG_ASSERT( _pClientCert != NULL );
    
    //
    // Do the easy stuff!
    //
    
    _ulCertInfo.CertEncodedSize = _pClientCert->cbCertEncoded;
    _ulCertInfo.pCertEncoded = _pClientCert->pbCertEncoded;

    //
    // Now for the hard stuff.  We need to validate the server does indeed
    // accept the client certificate.  Accept means we trusted the 
    // transitive trust chain to the CA, that the cert isn't revoked, etc.
    //
    // We use CAPI chaining functionality to check the certificate.
    //
    
    DBG_ASSERT( _pSiteConfig != NULL );
    
    //
    // If there is a CTL configured, then we'll need to build our own
    // Certificate Chain engine to do verification.  This is incredibly
    // expensive (memory/resource) wise so we will avoid it when possible
    // and just use the default CAPI engine
    //
    
    if ( _pSiteConfig->QueryHasCTL() )
    {
        hr = _pSiteConfig->GetCTLChainEngine( &hCertEngine );
        if ( FAILED( hr ) )
        {
            goto ExitPoint;;
        }
    }
    else
    {
        //
        // Default chain engine
        //
        
        hCertEngine = HCCE_LOCAL_MACHINE;
    }

    if ( !( _pSiteConfig->QueryCertCheckMode() & 
            MD_CERT_NO_REVOC_CHECK ) )
    {
        dwRevocationFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    }
    if ( _pSiteConfig->QueryCertCheckMode() & 
         MD_CERT_CACHE_RETRIEVAL_ONLY )
    {
        dwRevocationFlags |= CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY;
    }
    
    //
    // Let'r rip
    //

    ZeroMemory( &chainPara, sizeof( chainPara ) );
    chainPara.cbSize = sizeof( chainPara );    
    chainPara.dwUrlRetrievalTimeout = 
                            _pSiteConfig->QueryRevocationUrlRetrievalTimeout();
    chainPara.dwRevocationFreshnessTime = 
                            _pSiteConfig->QueryRevocationFreshnessTime();
    chainPara.fCheckRevocationFreshnessTime =
                            !!( _pSiteConfig->QueryCertCheckMode() & 
                            MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME );
   
    fRet = CertGetCertificateChain( hCertEngine,
                                    _pClientCert,
                                    NULL,
                                    NULL,
                                    &chainPara,
                                    dwRevocationFlags,
                                    NULL,
                                    &pChainContext );
    if ( !fRet )
    {
        //
        // Bad.  Couldn't get the chain at all.
        //
        
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }    
    
    //
    // Now validate the chain
    //

    _ulCertInfo.CertFlags = pChainContext->TrustStatus.dwErrorStatus;


    //
    // Now verify extended usage flags (only for the end certificate)
    //

    if ( !(_pSiteConfig->QueryCertCheckMode() & 
                            MD_CERT_NO_USAGE_CHECK ) )
    {
    
        fRet = CertGetEnhancedKeyUsage( _pClientCert,
                                        0,             //dwFlags,
                                        (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                        &cbEnhKeyUsage );
        dwRet = GetLastError();
                                        
        if ( !fRet && ( dwRet == ERROR_MORE_DATA ) )
        {
            //
            // Resize buffer
            //
            if ( !buffEnhKeyUsage.Resize( cbEnhKeyUsage ) ) 
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto ExitPoint;
            }
            fRet = CertGetEnhancedKeyUsage( _pClientCert,
                                            0,             //dwFlags,
                                            (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                            &cbEnhKeyUsage );
            dwRet = GetLastError();
        }
        if ( !fRet )
        {
            //
            // Bad.  Couldn't get the Enhanced Key Usage
            //
            
            hr = HRESULT_FROM_WIN32( dwRet );
            goto ExitPoint;
        } 

        pCertEnhKeyUsage = (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr();

        //
        // If the cUsageIdentifier member is zero (0), the certificate might be 
        // valid for all uses or the certificate it might have no valid uses. 
        // The return from a call to GetLastError can be used to determine 
        // whether the certificate is good for all uses or for no uses. 
        // If GetLastError returns CRYPT_E_NOT_FOUND then the certificate 
        // is good for all uses. If it returns zero (0), the certificate 
        // has no valid uses 
        //
        
        if ( pCertEnhKeyUsage->cUsageIdentifier == 0 )
        {
            if ( dwRet == CRYPT_E_NOT_FOUND )
            {
                //
                // Certificate valid for any use
                //
                fEnablesClientAuth = TRUE; 
            }
            else
            {
                //
                // Certificate NOT valid for any use
                //
            }
        }
        else
        {
            //
            // Find out if pCertEnhKeyUsage enables CLIENT_AUTH
            //
            for ( DWORD i = 0; i < pCertEnhKeyUsage->cUsageIdentifier; i++ )
            {
                DBG_ASSERT( pCertEnhKeyUsage->rgpszUsageIdentifier[i] != NULL );

                if ( strcmp( pCertEnhKeyUsage->rgpszUsageIdentifier[i], 
                             szOID_PKIX_KP_CLIENT_AUTH ) == 0 )
                {
                    //
                    // certificate enables CLIENT_AUTH
                    //
                    fEnablesClientAuth = TRUE; 
                    break;
                }
            }
        }

        //
        // If ExtendedKeyUsage doesn't enable CLIENT_AUTH then add 
        // flag to CertFlags
        //
        
        if ( !fEnablesClientAuth )
        {
            _ulCertInfo.CertFlags = _ulCertInfo.CertFlags | 
                                    CERT_TRUST_IS_NOT_VALID_FOR_USAGE;
        }
    }    

    IF_DEBUG( CLIENT_CERT_INFO )
    {
  
        DBGPRINTF(( DBG_CONTEXT,
                "CertFlags = %d\n",
                _ulCertInfo.CertFlags ));

        //
        // Dump out some debug info about the certificate
        //  
    
        #if DBG
        DumpCertDebugInfo();
        #endif
    }

    //
    // Finally set the mapped user token if it exists
    // (it is accepted to assign NULL to _ulCertInfo.Token 
    // if mapping didn't succeed
    //

    _ulCertInfo.Token = NULL;
    //
    // BUGBUG - remove CertDeniedByMapper from HTTP structure
    //
    _ulCertInfo.CertDeniedByMapper = FALSE;
    
    if ( _fDoCertMap )
    {
        if ( _pSiteConfig->QueryUseDSMapper() )
        {
            _ulCertInfo.Token = _hDSMappedToken; 
        }
    }
    
    hr = S_OK;

ExitPoint:

    if ( pChainContext != NULL )
    {
        CertFreeCertificateChain( pChainContext );
    }
    return hr;
    
}


VOID
SSL_STREAM_CONTEXT::DumpCertDebugInfo(
    VOID
)
/*++

Routine Description:

    On checked builds, dumps certificate (and chain) information to
    debugger

Arguments:

    None

Return Value:

    None

--*/
{
    PCERT_PUBLIC_KEY_INFO   pPublicKey;
    DWORD                   cbKeyLength;
    WCHAR                   achBuffer[ 512 ];
    
    //
    // Get certificate public key size
    //
    
    pPublicKey = &(_pClientCert->pCertInfo->SubjectPublicKeyInfo);

    cbKeyLength = CertGetPublicKeyLength( X509_ASN_ENCODING, 
                                          pPublicKey );
    
    DBGPRINTF(( DBG_CONTEXT,
                "Client cert key length = %d bits\n",
                cbKeyLength ));
                
    //
    // Get issuer string
    //
    
    if ( CertGetNameString( _pClientCert,
                             CERT_NAME_SIMPLE_DISPLAY_TYPE,
                             CERT_NAME_ISSUER_FLAG,
                             NULL,
                             achBuffer,
                             sizeof( achBuffer ) / sizeof( WCHAR ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Client cert issuer = %ws\n",
                    achBuffer ));
    }    
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error determining client cert issuer.  Win32 = %d\n",
                    GetLastError() ));
    }
    
    //
    // Get subject string
    //
    
    if ( CertGetNameString( _pClientCert,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            0,
                            NULL,
                            achBuffer,
                            sizeof( achBuffer ) / sizeof( WCHAR ) ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Client cert subject = %ws\n",
                    achBuffer ));
    }    
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error determining client cert subject.  Win32 = %d\n",
                    GetLastError() ));
    }
    
    //
    // Dump chain stats
    //
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_IS_NOT_TIME_VALID )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert is not time valid\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_CTL_IS_NOT_TIME_VALID )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert CTL is not time valid\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_IS_UNTRUSTED_ROOT )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert is not trusted\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_IS_NOT_SIGNATURE_VALID )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert has invalid signature\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_IS_REVOKED )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert is revoked\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_REVOCATION_STATUS_UNKNOWN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert revocation status is unknown\n" ));
    }
    
    if ( _ulCertInfo.CertFlags & CERT_TRUST_IS_PARTIAL_CHAIN )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Cert is not trusted\n" ));
    }
}


CredHandle *
SSL_STREAM_CONTEXT::QueryCredentials(
    VOID
)
/*++

Routine Description:

    Get the applicable credentials (depending on whether we're mapping or not)

Arguments:

    None

Return Value:

    CredHandle *

--*/
{
    DBG_ASSERT( _pSiteConfig != NULL );
    
    if ( _fDoCertMap && _pSiteConfig->QueryUseDSMapper() )
    {
        return _pSiteConfig->QueryDSMapperCredentials();
    }
    else
    {
        return _pSiteConfig->QueryCredentials();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\streamcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     streamcontext.cxx

   Abstract:
     Implementation of STREAM_CONTEXT.  One such object for every connection
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

LIST_ENTRY          STREAM_CONTEXT::sm_ListHead;
CRITICAL_SECTION    STREAM_CONTEXT::sm_csContextList;
DWORD               STREAM_CONTEXT::sm_cContexts;

STREAM_CONTEXT::STREAM_CONTEXT(
    UL_CONTEXT *                pContext
)
{
    DBG_ASSERT( pContext != NULL );
    _pUlContext = pContext;
    
    EnterCriticalSection( &sm_csContextList );
    InsertHeadList( &sm_ListHead, &_ListEntry );
    sm_cContexts++;
    LeaveCriticalSection( &sm_csContextList );
    
    _dwSignature = STREAM_CONTEXT_SIGNATURE;
}

STREAM_CONTEXT::~STREAM_CONTEXT()
{
    _dwSignature = STREAM_CONTEXT_SIGNATURE_FREE;
    
    EnterCriticalSection( &sm_csContextList );
    sm_cContexts--;
    RemoveEntryList( &_ListEntry );
    LeaveCriticalSection( &sm_csContextList );
    
}
   
//static
HRESULT
STREAM_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Global Initialization

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    INITIALIZE_CRITICAL_SECTION( &sm_csContextList );
    InitializeListHead( &sm_ListHead );
    return NO_ERROR;
}

//static
VOID
STREAM_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Global termination    

Arguments:

    None

Return Value:

    None

--*/
{
    DeleteCriticalSection( &sm_csContextList );
}

//static
VOID
STREAM_CONTEXT::WaitForContextDrain(    
    VOID
)
/*++

Routine Description:

    Wait for all contexts to go away

Arguments:

    None

Return Value:

    None

--*/
{
    while ( sm_cContexts != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d STREAM_CONTEXTs to drain\n",
                    sm_cContexts ));
                    
        Sleep( 1000 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\ulcontext.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ulcontext.cxx

   Abstract:
     Implementation of UL_CONTEXT.  One such object for every connection
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

#define DEFAULT_RAW_READ_SIZE 32768
#define DEFAULT_APP_READ_SIZE 32768



LIST_ENTRY          UL_CONTEXT::sm_ListHead;
CRITICAL_SECTION    UL_CONTEXT::sm_csUlContexts;
DWORD               UL_CONTEXT::sm_cUlContexts;
HANDLE              UL_CONTEXT::sm_hFilterHandle = NULL;
THREAD_POOL *       UL_CONTEXT::sm_pThreadPool = NULL;
LONG                UL_CONTEXT::sm_cDesiredOutstanding;
LONG                UL_CONTEXT::sm_cOutstandingContexts;
PTRACE_LOG          UL_CONTEXT::sm_pTraceLog;

UL_CONTEXT::UL_CONTEXT()
    : _RawWriteOverlapped( OVERLAPPED_CONTEXT_RAW_WRITE ),
      _RawReadOverlapped( OVERLAPPED_CONTEXT_RAW_READ ),
      _AppWriteOverlapped( OVERLAPPED_CONTEXT_APP_WRITE ),
      _AppReadOverlapped( OVERLAPPED_CONTEXT_APP_READ ),
      _buffConnectionInfo( _abConnectionInfo, sizeof( _abConnectionInfo ) ),
      _fCloseConnection( FALSE ),
      _cRefs( 1 ),
      _cbReadData( 0 ),
      _fNewConnection( TRUE ),
      _pSSLContext( NULL ),
#ifdef ISAPI
      _pISAPIContext( NULL ),
#endif
      _cbNextRawReadSize( DEFAULT_RAW_READ_SIZE ),
      _ulFilterBufferType( (HTTP_FILTER_BUFFER_TYPE) -1 )
{
    _RawWriteOverlapped.SetContext( this );
    _RawReadOverlapped.SetContext( this );
    _AppWriteOverlapped.SetContext( this );
    _AppReadOverlapped.SetContext( this );
    
    EnterCriticalSection( &sm_csUlContexts );
    InsertHeadList( &sm_ListHead, &_ListEntry );
    sm_cUlContexts++;
    LeaveCriticalSection( &sm_csUlContexts );

    _pConnectionInfo = (HTTP_RAW_CONNECTION_INFO*) _buffConnectionInfo.QueryPtr();   
    _pConnectionInfo->pInitialData = (PBYTE)_pConnectionInfo + 
                                     sizeof(HTTP_RAW_CONNECTION_INFO);
    _pConnectionInfo->InitialDataSize = _buffConnectionInfo.QuerySize() - 
                                        sizeof(HTTP_RAW_CONNECTION_INFO);

    _dwSignature = UL_CONTEXT_SIGNATURE;
}

UL_CONTEXT::~UL_CONTEXT()
{
    _dwSignature = UL_CONTEXT_SIGNATURE_FREE;

    //
    // Cleanup any attached stream context
    //
   
#ifdef ISAPI 
    if ( _pISAPIContext != NULL )
    {
        delete _pISAPIContext;
        _pISAPIContext = NULL;
    }
#endif
    
    if ( _pSSLContext != NULL )
    {
        delete _pSSLContext;
        _pSSLContext = NULL;
    }
   
    //
    // Manage the list of active UL_CONTEXTs
    //
    
    EnterCriticalSection( &sm_csUlContexts );
    sm_cUlContexts--;
    RemoveEntryList( &_ListEntry );
    LeaveCriticalSection( &sm_csUlContexts );
}

VOID
UL_CONTEXT::ReferenceUlContext(
    VOID
)
/*++

Routine Description:

    Reference the UL_CONTEXT

Arguments:

    none

Return Value:

    none

--*/
{
    LONG                cRefs;
    
    cRefs = InterlockedIncrement( &_cRefs );

    //
    // Log the reference ( sm_pTraceLog!=NULL if DBG=1)
    //

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }
}

VOID
UL_CONTEXT::DereferenceUlContext(
    VOID
)
/*++

Routine Description:

    Dereference (and possible destroy) the UL_CONTEXT

Arguments:

    none

Return Value:

    none

--*/
{
    LONG                cRefs;
    
    cRefs = InterlockedDecrement( &_cRefs );

    if ( sm_pTraceLog != NULL ) 
    {
        WriteRefTraceLog( sm_pTraceLog, 
                          cRefs,
                          this );
    }
    
    if ( cRefs == 0 )
    {
        delete this;
    }
}

HRESULT
UL_CONTEXT::OnAppReadCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Completion for reads from an application

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    HTTP_FILTER_BUFFER *        pFilterBuffer;
    HRESULT                     hr;
    RAW_STREAM_INFO             rawStreamInfo;
    BOOL                        fComplete = FALSE;
    
    //
    // Just bail on errors
    //
    
    if ( dwCompletionStatus != NO_ERROR )
    {
        return HRESULT_FROM_WIN32( dwCompletionStatus );
    }
    
    pFilterBuffer = (HTTP_FILTER_BUFFER *) _ulFilterBuffer.pBuffer;
    _ulFilterBufferType = pFilterBuffer->BufferType;
   
    DBG_ASSERT( !_fNewConnection );

    //
    // If UL is telling us to close the connection, then do so now
    //
    
    if ( _ulFilterBufferType == HttpFilterBufferCloseConnection )
    {
        StartClose();
        return NO_ERROR;
    }
    
    //
    // Setup raw stream descriptor
    //
    
    rawStreamInfo.pbBuffer = (PBYTE) pFilterBuffer->pBuffer;
    rawStreamInfo.cbBuffer = pFilterBuffer->BufferSize;
    rawStreamInfo.cbData = pFilterBuffer->BufferSize;

#ifdef ISAPI
    //
    // First notify ISAPI filters if this is a stream from the application
    //    
    
    DBG_ASSERT( g_pStreamFilter != NULL );
    
    if ( _ulFilterBufferType == HttpFilterBufferHttpStream && 
         g_pStreamFilter->QueryNotifyISAPIFilters() )
    {
        DBG_ASSERT( _pISAPIContext != NULL );
        
        hr = _pISAPIContext->ProcessRawWriteData( &rawStreamInfo,
                                                  &fComplete );
                                                   
        if ( FAILED( hr ) )
        {
            return hr;
        } 
        
        if ( fComplete )
        {
            StartClose();
            return NO_ERROR;
        }
    }
#endif
    
    //
    // Next notify SSL filter always
    //
    
    DBG_ASSERT( _pSSLContext != NULL );
    
    hr = _pSSLContext->ProcessRawWriteData( &rawStreamInfo,
                                            &fComplete );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    if ( fComplete )
    {   
        StartClose();
        return NO_ERROR;
    }
    
    //
    // If there is data to send to the client, then do so now.  
    // This check is done because the filter may decide to eat up all the 
    // data to be sent
    //
    
    if ( _ulFilterBufferType == HttpFilterBufferHttpStream &&
         rawStreamInfo.pbBuffer != NULL &&
         rawStreamInfo.cbData != 0 )
    {
        //
        // If we got to here, then we have processed data to send to the client
        //
    
        hr = DoRawWrite( UL_CONTEXT_FLAG_ASYNC,
                         rawStreamInfo.pbBuffer,
                         rawStreamInfo.cbData,
                         NULL );
        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // New app read will be kicked off in OnRawWriteCompletion
        //
    }
    else
    {
        //
        // Kick off another app read
        //
    
        _ulFilterBuffer.pBuffer = (PBYTE) _buffAppReadData.QueryPtr();
        _ulFilterBuffer.BufferSize = _buffAppReadData.QuerySize();
    
        return DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                          &_ulFilterBuffer,
                          NULL );
    }    
    return NO_ERROR;
}

HRESULT
UL_CONTEXT::OnRawReadCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    Get read completions off the wire.  This includes the initial
    completion for the UlFilterAccept()

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    HTTP_NETWORK_ADDRESS_IPV4 * pLocalAddress;
    HTTP_NETWORK_ADDRESS_IPV4 * pRemoteAddress;
    HRESULT                     hr;
    BOOL                        fReadMore = FALSE;
    BOOL                        fComplete = FALSE;
    HTTP_FILTER_BUFFER          ulFilterBuffer;
    DWORD                       cbWritten;
    RAW_STREAM_INFO             rawStreamInfo;

    //
    // Handle errors
    //

    if ( dwCompletionStatus != NO_ERROR )
    {
        if ( _fNewConnection )
        {
            InterlockedDecrement( &sm_cOutstandingContexts );  
        }
        return HRESULT_FROM_WIN32( dwCompletionStatus );
    }

    //
    // If this is a new connection, then grok connection information, and
    // maintain pending count
    //

    if ( _fNewConnection )
    {
        _fNewConnection = FALSE;
        
        //
        // This is a new connection.  We have one less UL_CONTEXT to 
        // listen for incoming requests.  Correct that if necessary.
        //
        
        InterlockedDecrement( &sm_cOutstandingContexts );

        ManageOutstandingContexts();        

        //
        // Convert the UL addresses into something nicer!
        //

        HTTP_TRANSPORT_ADDRESS *pAddress = &_pConnectionInfo->Address;
        
        DBG_ASSERT( pAddress->LocalAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
        pLocalAddress = (HTTP_NETWORK_ADDRESS_IPV4 *)pAddress->pLocalAddress;

        _connectionContext.LocalAddress = pLocalAddress->IpAddress;
        _connectionContext.LocalPort = pLocalAddress->Port;

        DBG_ASSERT( pAddress->RemoteAddressType == HTTP_NETWORK_ADDRESS_TYPE_IPV4 );
        pRemoteAddress = (HTTP_NETWORK_ADDRESS_IPV4 *) pAddress->pRemoteAddress;

        _connectionContext.RemoteAddress = pRemoteAddress->IpAddress;
        _connectionContext.RemotePort = pRemoteAddress->Port;
        _connectionContext.fIsSecure = FALSE;
        _connectionContext.RawConnectionId = _pConnectionInfo->ConnectionId;
#ifdef ISAPI
        _connectionContext.pfnSendDataBack = ISAPI_STREAM_CONTEXT::SendDataBack;
#endif
        _connectionContext.pvStreamContext = this;

        //
        // copy out the server name.
        //
        _connectionContext.ServerNameLength = 
            _pConnectionInfo->ServerNameLength;
        _connectionContext.pServerName = _pConnectionInfo->pServerName;

        //
        // Fill in our read buffer (as if we had read it in directly)
        //

        _cbReadData = _pConnectionInfo->InitialDataSize;

        if ( !_buffReadData.Resize( max( _pConnectionInfo->InitialDataSize, 
                                         QueryNextRawReadSize() ) ) ) 
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }

        memcpy( _buffReadData.QueryPtr(),
                _pConnectionInfo->pInitialData,
                _pConnectionInfo->InitialDataSize );

        //
        // First indicate a new connection
        //
        
        DBG_ASSERT( _pSSLContext != NULL );
        
        hr = _pSSLContext->ProcessNewConnection( &_connectionContext );
        if ( FAILED( hr ) )
        {
            return hr;
        }

#ifdef ISAPI
        
        if ( g_pStreamFilter->QueryNotifyISAPIFilters() )
        {
            DBG_ASSERT( _pISAPIContext != NULL );
            
            hr = _pISAPIContext->ProcessNewConnection( &_connectionContext );
            if ( FAILED( hr ) )
            {
                return hr;
            }
        }
#endif

        //
        // Kick off an app read now. 
        //
        
        if ( !_buffAppReadData.Resize( DEFAULT_APP_READ_SIZE ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
        
        _ulFilterBuffer.pBuffer = (PBYTE) _buffAppReadData.QueryPtr();
        _ulFilterBuffer.BufferSize = _buffAppReadData.QuerySize();
        
        hr = DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                        &_ulFilterBuffer,
                        NULL );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    else
    {
        _cbReadData += cbCompletion;
    }

    //
    // reset default raw read size
    //

    SetNextRawReadSize( DEFAULT_RAW_READ_SIZE );

    
    rawStreamInfo.pbBuffer = (PBYTE) _buffReadData.QueryPtr();
    rawStreamInfo.cbBuffer = _buffReadData.QuerySize();
    rawStreamInfo.cbData = _cbReadData;
    
    //
    // First, we will notify SSL
    // 
    
    DBG_ASSERT( _pSSLContext != NULL );
    
    hr = _pSSLContext->ProcessRawReadData( &rawStreamInfo,
                                           &fReadMore,
                                           &fComplete );
    if ( FAILED( hr ) )
    {
        return hr;
    }                   
    
    _cbReadData = rawStreamInfo.cbData;
    
    //
    // If we need to read more data, then do so now
    //
    
    if ( fReadMore )
    {

        //
        // rawStreamInfo.pbBuffer may have been replaced by different buffer
        // in ProcessRawReadData() call.
        // copy data back to _buffReadData
        //
        
        if ( rawStreamInfo.pbBuffer != _buffReadData.QueryPtr() )
        {
            DBG_ASSERT( rawStreamInfo.cbData <= _buffReadData.QuerySize() );

            memmove( _buffReadData.QueryPtr(),
                     rawStreamInfo.pbBuffer,
                     rawStreamInfo.cbData
                   );
        }

        if ( !_buffReadData.Resize( rawStreamInfo.cbData + 
                                        QueryNextRawReadSize() ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
            
        return DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                          (PBYTE) _buffReadData.QueryPtr() + _cbReadData,
                          QueryNextRawReadSize(),
                          NULL );
    }
    
    if ( fComplete )
    {
        StartClose();
        return NO_ERROR;
    }
    
    //
    // Reset the next read size before calling into filters since SSL may
    // have done a really small read, just previous to this.
    //

    SetNextRawReadSize( DEFAULT_RAW_READ_SIZE );
   
#ifdef ISAPI 
    //
    // Now we can start notifying ISAPI filters if needed (and there is
    // data to process)
    //
    
    DBG_ASSERT( g_pStreamFilter != NULL );
    if ( g_pStreamFilter->QueryNotifyISAPIFilters() )
    {
        fComplete = FALSE;
        fReadMore = FALSE;

        DBG_ASSERT( _pISAPIContext != NULL );
        
        hr = _pISAPIContext->ProcessRawReadData( &rawStreamInfo,
                                                 &fReadMore,
                                                 &fComplete );
        
        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        _cbReadData = rawStreamInfo.cbData;
        
        //
        // If we need to read more data, then do so now
        //
    
        if ( fReadMore )
        {
            //
            // rawStreamInfo may have been replaced by different buffer
            // in ProcessRawReadData() call.
            // copy data back to _buffReadData
            //

            if ( rawStreamInfo.pbBuffer != _buffReadData.QueryPtr() )
            {
                DBG_ASSERT( rawStreamInfo.cbData <= _buffReadData.QuerySize() );
                
                memmove( _buffReadData.QueryPtr(),
                         rawStreamInfo.pbBuffer,
                         rawStreamInfo.cbData
                       );
            }
        
            if ( !_buffReadData.Resize( rawStreamInfo.cbData + 
                                        QueryNextRawReadSize() ) )
            {
                return HRESULT_FROM_WIN32( GetLastError() );
            }
            
           
            return DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                              (PBYTE) _buffReadData.QueryPtr() + _cbReadData,
                              QueryNextRawReadSize(),
                              NULL );
        }
    
        if ( fComplete )
        {
            StartClose();
            return NO_ERROR;
        }
    }
#endif

    //
    // If after filtering there is data remaining in our buffer, then that
    // data is destined to the application.  Send it asynchronously because
    // there is a risk that synchronous call gets blocked for a long time
    //

    _cbReadData = 0;
    
    if ( rawStreamInfo.cbData != 0 )
    {
        ulFilterBuffer.BufferType = HttpFilterBufferHttpStream;
        ulFilterBuffer.BufferSize = rawStreamInfo.cbData;
        ulFilterBuffer.pBuffer = rawStreamInfo.pbBuffer;

        hr = DoAppWrite( UL_CONTEXT_FLAG_ASYNC,
                         &ulFilterBuffer,
                         &cbWritten );    

        if ( FAILED( hr ) )
        {
            return hr;
        }
        
        //
        // new raw read will be kicked off in OnAppWriteCompletion()
        //

    }
    else
    {
        //
        // Kick off another raw read
        //

        //
        // reset default raw read size
        //
        SetNextRawReadSize( DEFAULT_RAW_READ_SIZE );
    
        if ( !_buffReadData.Resize( QueryNextRawReadSize() ) )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
       
        hr = DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                        _buffReadData.QueryPtr(),
                        QueryNextRawReadSize() ,
                        NULL );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    
    return NO_ERROR;
}

HRESULT
UL_CONTEXT::OnRawWriteCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    after raw write completes, this routine has to assure that new asynchronous AppRead request is
    made to continue properly in communication
    
    Note: This completion should be caused only by asynchronous DoRawWrite started in completion routine 
    of AppRead (OnAppReadCompletion()).
    Please assure that NO RawWrite that is initiated by data coming from RawRead (SSL handshake) 
    will be called asynchronously. That could cause race condition (multiple threads using the same buffer 
    eg. for SSL data encryption)
    

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    if ( dwCompletionStatus != NO_ERROR )
    {
        return HRESULT_FROM_WIN32( dwCompletionStatus );
    }

    //
    // Kick off another app read
    //
    
    _ulFilterBuffer.pBuffer = (PBYTE) _buffAppReadData.QueryPtr();
    _ulFilterBuffer.BufferSize = _buffAppReadData.QuerySize();
    
    return DoAppRead( UL_CONTEXT_FLAG_ASYNC,
                      &_ulFilterBuffer,
                      NULL );    

}


HRESULT
UL_CONTEXT::OnAppWriteCompletion(
    DWORD                   cbCompletion,
    DWORD                   dwCompletionStatus
)
/*++

Routine Description:

    after app write completes we need to make another RawRead that is 
    the source of data for another asynchronous AppWrite.

    Note: AppWrite should be called asynchronously only from OnRawReadCompletion()
    Otherwise it would be necessary to change logic of this function

Arguments:

    cbCompletion - Bytes of completion
    dwCompletionStatus - Completion error

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;

    if ( dwCompletionStatus != NO_ERROR )
    {
        return HRESULT_FROM_WIN32( dwCompletionStatus );
    }

    //
    // Kick off another raw read
    //

    //
    // reset default raw read size
    //
    SetNextRawReadSize( DEFAULT_RAW_READ_SIZE );
    
    if ( !_buffReadData.Resize( QueryNextRawReadSize() ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
       
    hr = DoRawRead( UL_CONTEXT_FLAG_ASYNC,
                    _buffReadData.QueryPtr(),
                    QueryNextRawReadSize() ,
                    NULL );
    return hr;
}

HRESULT
UL_CONTEXT::DoRawWrite(
    DWORD                   dwFlags,
    PVOID                   pvBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pcbWritten
)
/*++

Routine Description:

    Write some bytes to the wire

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pvBuffer - Buffer to send
    cbBuffer - bytes in buffer
    pcbWritten - Bytes written

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;
    
    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoRawWrite( async:%d, bytes:%d )\n",
                    fAsync, 
                    cbBuffer
                    ));
    }

    if ( fAsync )
    {
        ReferenceUlContext();
    }

    ulRet = HttpFilterRawWrite( sm_hFilterHandle,
                                _pConnectionInfo->ConnectionId,
                                pvBuffer,
                                cbBuffer,
                                pcbWritten,
                                fAsync ? QueryRawWriteOverlapped() : NULL );

    if ( fAsync )
    {
        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceUlContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoRawWrite( async:%d, bytes:%d ) hr=0x%x\n",
                    fAsync, 
                    cbBuffer,
                    hr
                    ));
    }

    return hr;
}

HRESULT
UL_CONTEXT::DoAppRead(
    DWORD                   dwFlags,
    HTTP_FILTER_BUFFER *    pFilterBuffer,
    DWORD *                 pcbRead
)
/*++

Routine Description:

    Read data from application

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pFilterBuffer - Filter buffer
    pcbRead - Bytes read

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoAppRead( async:%d )\n",
                    fAsync 
                    ));
    }

    if ( fAsync )
    {
        ReferenceUlContext();
    }

    ulRet = HttpFilterAppRead( sm_hFilterHandle,
                               _pConnectionInfo->ConnectionId,
                               pFilterBuffer,
                               pFilterBuffer->BufferSize, 
                               pcbRead,
                               fAsync ? QueryAppReadOverlapped() : NULL );

    if ( fAsync )
    {
        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceUlContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoAppRead( async:%d )\n",
                    fAsync 
                    ));
    }

    
    return hr;
}

HRESULT
UL_CONTEXT::DoAppWrite(
    DWORD                   dwFlags,
    HTTP_FILTER_BUFFER *    pFilterBuffer,
    DWORD *                 pcbWritten
)
/*++

Routine Description:

    Write data to the application

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pFilterBuffer - Filter buffer
    pcbWritten - Bytes written

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;

    DBG_ASSERT( pFilterBuffer != NULL );

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoAppWrite( async:%d, bytes:%d, buffertype:%d )\n",
                    fAsync,
                    pFilterBuffer->BufferSize,
                    pFilterBuffer->BufferType
                    ));
    }

    if ( fAsync )
    {
        ReferenceUlContext();
    }

    ulRet = HttpFilterAppWrite( sm_hFilterHandle,
                                _pConnectionInfo->ConnectionId,
                                pFilterBuffer,
                                pFilterBuffer->BufferSize,
                                pcbWritten,
                                fAsync ? QueryAppWriteOverlapped() : NULL );
    
    if ( fAsync )
    {
        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceUlContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "LEAVE DoAppWrite( async:%d, bytes:%d, buffertype:%d ) hr=0x%x\n",
                    fAsync,
                    pFilterBuffer->BufferSize,
                    pFilterBuffer->BufferType,
                    hr
                    ));
    }

    return hr;
}

HRESULT
UL_CONTEXT::DoRawRead(
    DWORD                   dwFlags,
    PVOID                   pvBuffer,
    DWORD                   cbBuffer,
    DWORD *                 pcbWritten
)
/*++

Routine Description:

    Read some bytes from the wire

Arguments:

    dwFlags - UL_CONTEXT_ASYNC for async
    pvBuffer - buffer
    cbBuffer - bytes in buffer
    pcbWritten - Bytes written

Return Value:

    HRESULT

--*/
{
    BOOL            fAsync = !!( dwFlags & UL_CONTEXT_FLAG_ASYNC );
    ULONG           ulRet = ERROR_SUCCESS;
    HRESULT         hr = NO_ERROR;
    DWORD           cbImmediate = 0;

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "ENTER DoRawRead( async:%d )\n",
                    fAsync 
                    ));
    }

    if ( fAsync )
    {
        ReferenceUlContext();
    }
    
    ulRet = HttpFilterRawRead( sm_hFilterHandle,
                               _pConnectionInfo->ConnectionId,
                               pvBuffer,
                               cbBuffer,
                               pcbWritten,
                               fAsync ? QueryRawReadOverlapped() : NULL );
    
    if ( fAsync )
    {
        if ( ulRet != ERROR_IO_PENDING )
        {
            DereferenceUlContext();
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }
    else
    {
        if ( ulRet != NO_ERROR )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
        }
    }

    IF_DEBUG( APP_RAW_READWRITE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "LEAVE DoRawRead( async:%d )\n",
                    fAsync 
                    ));
    }

    return hr;
}

VOID
UL_CONTEXT::StartClose(
    VOID
)
/*++

Routine Description:

    Start the process of closing the connection (and cleaning up UL_CONTEXT)

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL                    fOld;
    
    fOld = (BOOL) InterlockedCompareExchange( (PLONG) &_fCloseConnection,
                                              TRUE,
                                              FALSE );

    if ( fOld == FALSE )
    {
        HttpFilterClose( sm_hFilterHandle,
                         _pConnectionInfo->ConnectionId,
                         NULL );

#ifdef ISAPI
        //
        // Notify ISAPIs of the close
        //
        
        if ( g_pStreamFilter->QueryNotifyISAPIFilters() )
        {
            DBG_ASSERT( _pISAPIContext != NULL );
            
            _pISAPIContext->ProcessConnectionClose();
        }
#endif

        //
        // We were the ones to set the flag.  Do the final dereference
        //
            
        DereferenceUlContext();
    }        
    else
    {
        //
        // Someone else has set the flag.  Let them dereference
        //
    }
}

HRESULT
UL_CONTEXT::Create(
    VOID
)
/*++

Routine Description:

    Initialize a UL_CONTEXT

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    DBG_ASSERT( _pSSLContext == NULL );
#ifdef ISAPI
    DBG_ASSERT( _pISAPIContext == NULL );
#endif
    
    _pSSLContext = new SSL_STREAM_CONTEXT( this );
    if ( _pSSLContext == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

#ifdef ISAPI
    DBG_ASSERT( g_pStreamFilter != NULL );
    if ( g_pStreamFilter->QueryNotifyISAPIFilters() )
    {
        _pISAPIContext = new ISAPI_STREAM_CONTEXT( this );
        if ( _pISAPIContext == NULL )
        {
            delete _pSSLContext;
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }    
#endif
    
    return NO_ERROR;
}

HRESULT
UL_CONTEXT::DoAccept(
    VOID
)
/*++

Routine Description:

    Accept an incoming connection by calling UlFilterAccept()

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ULONG               ulRet;
    HRESULT             hr = NO_ERROR;
    
    ReferenceUlContext();
        
    ulRet = HttpFilterAccept( sm_hFilterHandle,
                              _pConnectionInfo,
                              _buffConnectionInfo.QuerySize(),
                              NULL,
                              QueryRawReadOverlapped() );

    if ( ulRet != ERROR_IO_PENDING )
    {
        hr = HRESULT_FROM_WIN32( ulRet );
        
        DereferenceUlContext();
    
        DBGPRINTF(( DBG_CONTEXT,
                    "Error calling UlFilterAccept().  hr = %x\n",
                    hr ));
    }
    else
    {   
        //
        // Another outstanding context available!
        //
        
        InterlockedIncrement( &sm_cOutstandingContexts );
    }
    
    return hr;
}

HRESULT
UL_CONTEXT::SendDataBack(
    RAW_STREAM_INFO *       pRawStreamInfo
)
/*++

Routine Description:

    Sends given data back to client, while going with the ssl filter
    if necessary

Arguments:

    pRawStreamInfo - Raw data to send back

Return Value:

    HRESULT

--*/
{
    HRESULT             hr;
    BOOL                fComplete;
    
    if ( pRawStreamInfo == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( _pSSLContext != NULL );
    
    //
    // ISAPI filter has sent back some data in a raw notification.  
    // Have SSL process it and then send it here
    //
    
    return _pSSLContext->SendDataBack( pRawStreamInfo );
}
   
//static
HRESULT
UL_CONTEXT::Initialize(
    LPWSTR SslFilterChannelName
)
/*++

Routine Description:

    Global Initialization

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    ULONG                   ulRet = ERROR_SUCCESS;
    HRESULT                 hr = NO_ERROR;
    BOOL                    fRet = FALSE;
    //
    // Get a UL handle to the RawStreamPool (or whatever)
    //
    
    ulRet = HttpCreateFilter( &sm_hFilterHandle,
                                SslFilterChannelName,
                                NULL, 
                                HTTP_OPTION_OVERLAPPED );
    if ( ulRet != ERROR_SUCCESS )
    {
        //
        // W3SSL service may have created Filter already
        // try just open it then
        //
        ulRet = HttpOpenFilter( &sm_hFilterHandle,
                                  SslFilterChannelName,
                                  HTTP_OPTION_OVERLAPPED );
        if ( ulRet != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( ulRet );
            goto Finished;
        }
    }

    //
    // Create private thread pool for streamfilt
    //
    
    fRet = THREAD_POOL::CreateThreadPool(&sm_pThreadPool);
    if (FALSE == fRet)
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create ThreadPool for Streamfilt\n" ));
  
        hr = E_FAIL;
        goto Finished;
    }
    
    DBG_ASSERT( sm_pThreadPool != NULL );
    
    //
    // Associate a completion routine with the thread pool
    //
    
    DBG_ASSERT( sm_hFilterHandle != INVALID_HANDLE_VALUE );
    DBG_ASSERT( sm_hFilterHandle != NULL );
    
    if ( !sm_pThreadPool->BindIoCompletionCallback( sm_hFilterHandle,
                                                    OverlappedCompletionRoutine,
                                                    0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }  
    
    INITIALIZE_CRITICAL_SECTION( &sm_csUlContexts );
    InitializeListHead( &sm_ListHead );

    //
    // Keep a set number of filter accepts outstanding
    //
    
    sm_cDesiredOutstanding = UL_CONTEXT_DESIRED_OUTSTANDING;

#if DBG
    sm_pTraceLog = CreateRefTraceLog( 2000, 0 );
#endif

Finished:
    if ( FAILED( hr ) )
    {
        if ( sm_hFilterHandle != NULL )
        {
            CloseHandle( sm_hFilterHandle );
            sm_hFilterHandle = NULL;
        }
        if ( sm_pThreadPool != NULL )
        {
            sm_pThreadPool->TerminateThreadPool();
            sm_pThreadPool = NULL;
        }
    }
    return hr;
}

//static
VOID
UL_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Global termination    

Arguments:

    None

Return Value:

    None

--*/
{
    if ( sm_pTraceLog != NULL )
    {
        DestroyRefTraceLog( sm_pTraceLog );
        sm_pTraceLog = NULL;
    }

    if ( sm_hFilterHandle != NULL )
    {
        CloseHandle( sm_hFilterHandle );
        sm_hFilterHandle = NULL;
    }
    
    if ( sm_pThreadPool != NULL )
    {
        sm_pThreadPool->TerminateThreadPool();
        sm_pThreadPool = NULL;
    }
    
    DeleteCriticalSection( &sm_csUlContexts );
}

//static
VOID
UL_CONTEXT::WaitForContextDrain(    
    VOID
)
/*++

Routine Description:

    Wait for all contexts to go away

Arguments:

    None

Return Value:

    None

--*/
{
    while ( sm_cUlContexts != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d UL_CONTEXTs to drain\n",
                    sm_cUlContexts ));
                    
        Sleep( 1000 );
    }

    //
    // there should be no outstanding contexts left
    //
    
    DBG_ASSERT( sm_cOutstandingContexts == 0 );
    
}

//static
VOID
UL_CONTEXT::StopListening(
    VOID
)
/*++

Routine Description:

    Stop listening and wait for contexts to drain

Arguments:

    None

Return Value:

    None

--*/
{
    CloseHandle( sm_hFilterHandle );
    sm_hFilterHandle = NULL;
    
    WaitForContextDrain();
}

//static
HRESULT
UL_CONTEXT::ManageOutstandingContexts(
    VOID
)
{
    LONG                cRequired;
    UL_CONTEXT *        pContext;
    HRESULT             hr = NO_ERROR;
    
    if ( sm_cOutstandingContexts < sm_cDesiredOutstanding )
    {
        cRequired = sm_cDesiredOutstanding - sm_cOutstandingContexts;
        
        //
        // Make sure the value is not negative
        //
        
        cRequired = max( 0, cRequired );
        
        for ( LONG i = 0; i < cRequired; i++ )
        {
            pContext = new UL_CONTEXT();
            if ( pContext == NULL )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
            
            hr = pContext->Create();
            if ( FAILED( hr ) )
            {
                pContext->DereferenceUlContext();
                break;
            }
            
            hr = pContext->DoAccept();
            if ( FAILED( hr ) )
            {
                pContext->DereferenceUlContext();
                break;
            }
        }
    }
    
    return hr;
}

VOID
OverlappedCompletionRoutine(
    DWORD               dwErrorCode,
    DWORD               dwNumberOfBytesTransfered,
    LPOVERLAPPED        lpOverlapped
)
/*++

Routine Description:

    Magic completion routine 

Arguments:

    None

Return Value:

    None

--*/
{
    OVERLAPPED_CONTEXT *            pContextOverlapped = NULL;
    HRESULT                         hr;
    
    DBG_ASSERT( lpOverlapped != NULL );
   
    pContextOverlapped = CONTAINING_RECORD( lpOverlapped,
                                            OVERLAPPED_CONTEXT,
                                            _Overlapped );

    DBG_ASSERT( pContextOverlapped != NULL );

    pContextOverlapped->QueryContext()->ReferenceUlContext();

    //
    // Make up for reference which posted async operation in first place
    //

    pContextOverlapped->QueryContext()->DereferenceUlContext();

    //
    // Call the appropriate completion routine
    //

    switch( pContextOverlapped->QueryType() )
    {
    case OVERLAPPED_CONTEXT_RAW_READ:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnRawReadCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode 
                        )); 
        }
        
        hr = pContextOverlapped->QueryContext()->OnRawReadCompletion(
                                                dwNumberOfBytesTransfered,
                                                dwErrorCode );
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnRawReadCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }
        break;
    
    case OVERLAPPED_CONTEXT_RAW_WRITE:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnRawWriteCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode 
                        ));
        }
      
        hr = pContextOverlapped->QueryContext()->OnRawWriteCompletion(
                                                dwNumberOfBytesTransfered,
                                                dwErrorCode );

        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnRawWriteCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }
        break;
    
    case OVERLAPPED_CONTEXT_APP_READ:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnAppReadCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode 
                        ));
        }
        
        hr = pContextOverlapped->QueryContext()->OnAppReadCompletion(
                                                dwNumberOfBytesTransfered,
                                                dwErrorCode );
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnAppReadCompletion ( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }

        break;
    
    case OVERLAPPED_CONTEXT_APP_WRITE:
        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "ENTER OnAppWriteCompletion( bytes:%d, dwErr:%d )\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode 
                        ));
        }
        
        hr = pContextOverlapped->QueryContext()->OnAppWriteCompletion(
                                                dwNumberOfBytesTransfered,
                                                dwErrorCode );

        IF_DEBUG( APP_RAW_READWRITE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "LEAVE OnAppWriteCompletion( bytes:%d, dwErr:%d ) hr=0x%x\n",
                        dwNumberOfBytesTransfered,
                        dwErrorCode,
                        hr
                        ));
        }

        break;
    
    default:
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( FALSE );
    }    
    
    //
    // As long as completion routine returned success, just bail.  However,
    // if not then we should begin the process of closing connection
    //
    
    if ( FAILED( hr ) )
    {   
        pContextOverlapped->QueryContext()->StartClose();
    }
    
    pContextOverlapped->QueryContext()->DereferenceUlContext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\exe\sfwp.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     sfwp.cxx

   Abstract:
     Main module for Stream Filter process
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


//
// IIS 101
//

#include <iis.h>
#include "dbgutil.h"
#include <objbase.h>
#include <iadmw.h>
#include <mb.hxx>
#include <stdio.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>

//
// System related headers
//

#include <windows.h>
#include <winsock2.h>
#include <mswsock.h>
#include <wincrypt.h>

//
// Other IISPLUS stuff
//

#include <wpif.h>
#include <streamfilt.h>

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();

//
// Configuration parameters registry key.
//

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\iisw3adm"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszWpRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\SFWP";

class DEBUG_WRAPPER {

public:
    DEBUG_WRAPPER( IN LPCSTR pszModule)
    {
#if DBG
        CREATE_DEBUG_PRINT_OBJECT( pszModule);
#else
        UNREFERENCED_PARAMETER(pszModule);
#endif
        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszWpRegLocation, DEBUG_ERROR );
    }

    ~DEBUG_WRAPPER(void)
    { DELETE_DEBUG_PRINT_OBJECT(); }
};

extern "C" INT
__cdecl
wmain(
    INT                     argc,
    PWSTR                   argv[]
    )
{
    HRESULT                 hr;
    DEBUG_WRAPPER           dbgWrapper( "sfwp" );
    ULONG                   rcRet = CLEAN_WORKER_PROCESS_EXIT_CODE;
    BOOL                    fCoInit = FALSE;
    BOOL                    fStreamInit = FALSE;
    STREAM_FILTER_CONFIG    sfConfig;

    //
    // Do that COM thing
    //

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    fCoInit = TRUE;

    //
    // Set security impersonation level to impersonate so metabase sink 
    // notifications will work.
    //
    
    hr = CoInitializeSecurity( NULL,
                               -1,
                               NULL,
                               NULL,
                               RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               EOAC_NONE,
                               NULL );
    
    //
    // Initialize stream filter
    //
    
    sfConfig.fSslOnly = TRUE;
    sfConfig.pfnRawRead = NULL;
    sfConfig.pfnRawWrite = NULL;
    sfConfig.pfnConnectionClose = NULL;
    
    hr = StreamFilterInitialize( &sfConfig );
    if ( FAILED( hr ) )
    {
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    fStreamInit = TRUE;
    
    //
    // Start listening
    //
    
    hr = StreamFilterStart();
    if ( FAILED( hr ) )
    {
        rcRet = ERROR_WORKER_PROCESS_EXIT_CODE;
        goto Finished;
    }
    
    Sleep( INFINITE );

    StreamFilterStop();

Finished:    

    if ( fStreamInit )
    {
        StreamFilterTerminate();
    }

    if ( fCoInit )
    {
        CoUninitialize();
    }

    return rcRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\dll\streamfilter.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     streamfilter.cxx

   Abstract:
     Wraps all the globals of the stream filter process
 
   Author:
     Bilal Alam         (BAlam)         29-March-2000

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

#include "precomp.hxx"

// BUGBUG
#undef INET_INFO_KEY
#undef INET_INFO_PARAMETERS_KEY

//
//  Configuration parameters registry key.
//
#define INET_INFO_KEY \
            "System\\CurrentControlSet\\Services\\w3svc"

#define INET_INFO_PARAMETERS_KEY \
            INET_INFO_KEY "\\Parameters"

const CHAR g_pszStrmfiltRegLocation[] =
    INET_INFO_PARAMETERS_KEY "\\strmfilt";

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();

STREAM_FILTER *         g_pStreamFilter;

STREAM_FILTER::STREAM_FILTER( BOOL fNotifyISAPIs )
{
    _InitStatus = INIT_NONE;
    _pAdminBase = NULL;
    _pListener = NULL;
    _fNotifyISAPIFilters = fNotifyISAPIs;
}

STREAM_FILTER::~STREAM_FILTER( VOID )
{
    DBG_ASSERT( _pAdminBase == NULL );
}

HRESULT
STREAM_FILTER::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize the stream filter globals

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    HRESULT             hr = NO_ERROR;

    CREATE_DEBUG_PRINT_OBJECT("strmfilt");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszStrmfiltRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    DBG_ASSERT( _InitStatus == INIT_NONE );
    
    //
    // Initialize the thread pool
    //
    
    hr = ThreadPoolInitialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing thread pool.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    _InitStatus = INIT_THREAD_POOL;
    
    //
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *)&(_pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    _InitStatus = INIT_METABASE;

    //
    // Initialize the metabase sink
    //

    _pListener = new MB_LISTENER( this );
    if ( _pListener == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Finished;
    }   
    _InitStatus = INIT_MB_LISTENER;

    //
    // Initialize UL_CONTEXTs
    //
    
    hr = UL_CONTEXT::Initialize(HTTP_SSL_SERVER_FILTER_CHANNEL_NAME);
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing UL_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }   
    _InitStatus = INIT_UL_CONTEXT;

    //
    // Initialize STREAM_CONTEXTs
    //
    
    hr = STREAM_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing STREAM_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }   
    _InitStatus = INIT_STREAM_CONTEXT;

    //
    // Initialize all SSL goo
    //
    
    hr = SSL_STREAM_CONTEXT::Initialize();
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error initializing SSL_CONTEXT globals.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    _InitStatus = INIT_SSL_STREAM_CONTEXT;

    DBG_ASSERT( hr == NO_ERROR );

    return hr;    

Finished:
    return hr;
}

VOID
STREAM_FILTER::Terminate(
    VOID
)
/*++

Routine Description:

    Terminate the stream filter globals

Arguments:

    None

Return Value:

    None

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
                "Terminating STREAM_FILTER object\n" ));
    
    switch( _InitStatus )
    {
    case INIT_SSL_STREAM_CONTEXT:
        SSL_STREAM_CONTEXT::Terminate();
        
    case INIT_STREAM_CONTEXT:
        STREAM_CONTEXT::Terminate();
        
    case INIT_UL_CONTEXT:
        UL_CONTEXT::Terminate();
        
    case INIT_MB_LISTENER:
        if ( _pListener != NULL )
        {
            _pListener->Release();
            _pListener = NULL;
        }
    
    case INIT_METABASE:
        if ( _pAdminBase != NULL )
        {
            _pAdminBase->Release();
            _pAdminBase = NULL;
        } 
        
    case INIT_THREAD_POOL:
        ThreadPoolTerminate();

    }

    DELETE_DEBUG_PRINT_OBJECT();
}

HRESULT
STREAM_FILTER::MetabaseChangeNotification(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
)
/*++

Routine Description:

    Handle metabase change notifications

Arguments:

    dwMDNumElements - Number of elements changed
    pcoChangeList - Elements changed

Return Value:

    HRESULT

--*/
{
    LPWSTR                  pszSiteString;
    DWORD                   dwSiteId;
    LPWSTR                  pszAfter;
    BOOL                    fDoSiteConfigUpdate;
    BOOL                    fDoSiteBindingUpdate;
    
    DBG_ASSERT( dwMDNumElements != 0 );
    DBG_ASSERT( pcoChangeList != NULL );

    //
    // Only handle the W3SVC changes
    //
    
    for( DWORD i = 0; i < dwMDNumElements; ++i )
    {
        if( _wcsnicmp( pcoChangeList[i].pszMDPath,
                       W3_SERVER_MB_PATH,
                       W3_SERVER_MB_PATH_CCH ) == 0 )
        {
            fDoSiteConfigUpdate = FALSE;
            fDoSiteBindingUpdate = FALSE;
            
            //
            // Was this change made for a site, or for all of W3SVC
            //
    
            pszSiteString = pcoChangeList[i].pszMDPath + W3_SERVER_MB_PATH_CCH;
            if ( *pszSiteString != L'\0' )
            {
                dwSiteId = wcstoul( pszSiteString, &pszAfter, 10 );
            }
            else
            {
                //
                // A site id of 0 means we will flush all site config
                //
                
                dwSiteId = 0;
            }
            
            //
            // Now check whether the changed property was an SSL prop
            //
            
            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( fDoSiteConfigUpdate )
                {
                    break;
                }
                
                switch( pcoChangeList[ i ].pdwMDDataIDs[ j ] )
                {
                case MD_SSL_CERT_HASH:
                case MD_SSL_CERT_CONTAINER:
                case MD_SSL_CERT_PROVIDER:
                case MD_SSL_CERT_OPEN_FLAGS:
                case MD_SSL_CERT_STORE_NAME:
                case MD_SSL_CERT_IS_FORTEZZA:
                case MD_SSL_CERT_FORTEZZA_PIN:
                case MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER:
                case MD_SSL_CERT_FORTEZZA_PERSONALITY:
                case MD_SSL_CERT_FORTEZZA_PROG_PIN:
                case MD_SSL_CTL_IDENTIFIER:
                case MD_SSL_CTL_CONTAINER:
                case MD_SSL_CTL_PROVIDER:
                case MD_SSL_CTL_PROVIDER_TYPE:
                case MD_SSL_CTL_OPEN_FLAGS:
                case MD_SSL_CTL_STORE_NAME:
                case MD_SSL_CTL_SIGNER_HASH:
                case MD_SSL_USE_DS_MAPPER:
                case MD_SERIAL_CERT11:
                case MD_SERIAL_CERTW:
                case MD_SSL_ACCESS_PERM:
                case MD_CERT_CHECK_MODE:
                case MD_REVOCATION_FRESHNESS_TIME:
                case MD_REVOCATION_URL_RETRIEVAL_TIMEOUT:
                    fDoSiteConfigUpdate = TRUE;
                    break;
                    
                case MD_SECURE_BINDINGS:
                    fDoSiteBindingUpdate = TRUE;
                    break;
                }
            }
            
            //
            // Update the site bindings if necessary
            //
            
            if ( fDoSiteBindingUpdate )
            {
                SITE_BINDING::HandleSiteBindingChange( dwSiteId,
                                                       pcoChangeList[i].pszMDPath );
            }
            
            //
            // Update the site configurations if necessary
            //
            
            if ( fDoSiteConfigUpdate )
            {
                //
                // dwSiteId == 0 means flush all sites
                //
                
                SITE_CONFIG::FlushBySiteId( dwSiteId );
                
                if ( dwSiteId == 0 )
                {
                    //
                    // If we've already flushed every site, then no 
                    // reason to read any more changes
                    //
                    
                    break;
                }
            }
        }   
    }
    
    return NO_ERROR;
}
   
HRESULT
STREAM_FILTER::StopListening(
    VOID
)
/*++

Routine Description:

    Stop listening for UL filter channel

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    UL_CONTEXT::StopListening();
    
    _pListener->StopListening( _pAdminBase );
    
    return NO_ERROR;
}

HRESULT
STREAM_FILTER::StartListening(
    VOID
)
/*++

Routine Description:

    Start listening for incoming connections

Arguments:

    None

Return Value:

    None

--*/
{
    HRESULT                 hr = NO_ERROR;
  
    //
    // Start listening for metabase changes
    //
   
    DBG_ASSERT( _pAdminBase != NULL );
    
    hr = _pListener->StartListening( _pAdminBase );
    if ( FAILED( hr ) )  
    {
        return hr;
    }
   
    //
    // This will kick off enough filter accepts to keep our threshold
    // of outstanding accepts avail 
    //
    
    hr = UL_CONTEXT::ManageOutstandingContexts();
    if ( FAILED( hr ) )
    {
        _pListener->StopListening( _pAdminBase );
        return hr;
    }
    
    return hr;
}

//
// Some export stuff which allows the stream filter to be used by both
// inetinfo.exe and sfwp.exe
//

HRESULT
StreamFilterInitialize(
    STREAM_FILTER_CONFIG *      pStreamConfig
)
/*++

Routine Description:

    Initialize the stream filter

Arguments:

    pStreamConfig - Stream configuration

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = NO_ERROR;
    
    if ( pStreamConfig == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    DBG_ASSERT( g_pStreamFilter == NULL );
    
    //
    // Global global STREAM_FILTER object
    //
    
    g_pStreamFilter = new STREAM_FILTER( !pStreamConfig->fSslOnly );
    if ( g_pStreamFilter == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto Finished;
    }
    
    hr = ISAPI_STREAM_CONTEXT::Initialize( pStreamConfig );
    if ( FAILED( hr ) )
    {
        goto Finished;
    }
    
    hr = g_pStreamFilter->Initialize();
    if ( FAILED( hr ) )
    {
        g_pStreamFilter->Terminate();
        
        delete g_pStreamFilter;
        g_pStreamFilter = NULL;
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to initialize global STREAM_FILTER object.  hr = %x\n",
                    hr ));
        goto Finished;
    }

Finished:
    return hr;    
}

HRESULT
StreamFilterStart(
    VOID
)
/*++

Routine Description:

    Start listening for filter requests

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    return g_pStreamFilter->StartListening();
}

HRESULT
StreamFilterStop( 
    VOID
)
/*++

Routine Description:

    Stop listening for filter requests

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( g_pStreamFilter == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    return g_pStreamFilter->StopListening(); 
}

VOID
StreamFilterTerminate(
    VOID
)
/*++

Routine Description:

    Cleanup filter

Arguments:

    None

Return Value:

    None

--*/
{
    if ( g_pStreamFilter != NULL )
    {
        g_pStreamFilter->Terminate();
    
        delete g_pStreamFilter;
        g_pStreamFilter = NULL;
    }
    else
    {   
        DBG_ASSERT( FALSE );
    }
}

extern "C"
BOOL 
WINAPI
DllMain(
    HINSTANCE                   hInstance,
    DWORD                       dwReason,
    LPVOID                      lpvReserved
)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls( hInstance );

        CREATE_DEBUG_PRINT_OBJECT("streamfilt");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\client\sslconfigchangeprovclient.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigchangeprovclient.cxx

   Abstract:
     SSL CONFIG CHANGE PROV client

     Receives SSL configuration change parameters detected by server side

     User of this class shold inherit it class and implement 
     PipeListener() to process notifications

 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?
// Well typically


#include "precomp.hxx"

HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::StartListeningForChanges(
    IN SSL_CONFIG_CHANGE_CALLBACK * pSslConfigChangeCallback,
    IN OPTIONAL PVOID  pvParam
    )
/*++

Routine Description:
    Create thread to handle SSL configuration change notification
    
Arguments:
    pSslConfigChangeCallback - callback function that receives change details
    pvParam  - optional parameter that will be passed as first param to callback

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_CHANGE_PROV_CLIENT::StartListeningForChanges()\n"
                    ));
    }

    if ( pSslConfigChangeCallback == NULL )
    {
        DBG_ASSERT( pSslConfigChangeCallback != NULL );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    //
    // store the callback function pointer, and first parameter
    //
    _pSslConfigChangeCallback = pSslConfigChangeCallback;
    _pSslConfigChangeCallbackParameter = pvParam;
    
    //
    // Initialize parent (it will handle all the pipe initialization)
    //
    return SSL_CONFIG_PIPE::PipeInitializeClient( WSZ_SSL_CONFIG_CHANGE_PIPE );
    

}
   
HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::StopListeningForChanges(
    VOID
    )
/*++

Routine Description:
    Close named pipe for SSL config change notifications
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_CHANGE_PROV_CLIENT::StopListeningForChanges\n"
                    ));
    }
    return SSL_CONFIG_PIPE::PipeTerminateClient( );
}

//virtual
HRESULT
SSL_CONFIG_CHANGE_PROV_CLIENT::PipeListener(
    VOID
    )

/*++

Routine Description:

    Pipe listener on the client side handles SSL Config change notifications

    Function is started on private thread launched by 
    base class SSL_CONFIG_PIPE during pipe initialization
    
Arguments:

Return Value:

    HRESULT

--*/
{
    SSL_CONFIG_PIPE_COMMAND     Command;
    HRESULT                     hr = E_FAIL;
    DWORD                       dwSiteId;

    //
    // Listen on pipe to receive commands
    // and handle them
    //
    while ( TRUE )
    {
        hr = PipeReceiveCommand( &Command );
        if ( FAILED( hr ) )
        {
           //
           // failure may simply mean that 
           // termination has started and
           // pipe handle was closed
           //
           DBG_ASSERT( QueryPipeIsTerminating() );
           goto  Cleanup;
        }
        
        
        dwSiteId = Command.dwParameter1;

        //
        // make the callback
        //
        DBG_ASSERT( _pSslConfigChangeCallback != NULL );
        (* _pSslConfigChangeCallback) (
                _pSslConfigChangeCallbackParameter,
                static_cast<SSL_CONFIG_CHANGE_COMMAND_ID> 
                                ( Command.dwCommandId ),
                dwSiteId );
    }
    
    return S_OK;
Cleanup:
    DBG_ASSERT( FAILED( hr ) );
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\client\sslconfigprovclient.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigprovclient.cxx

   Abstract:
     SSL CONFIG PROV client

     Client provides easy way of retrieving SSL related parameters
     through named pipes.
     Only one pipe connection is currently supported and 
     all client threads have to share it 
     ( exclusive access is maintained by locking )

     
     Client side is guaranteed not to use any COM stuff.
     Not using COM was requirement from NT Security folks
     to enable w3ssl be hosted in lsass
 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/

// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?
// Well typically


#include "precomp.hxx"




HRESULT
SSL_CONFIG_PROV_CLIENT::Initialize(
    VOID
    )
/*++

Routine Description:
    Connect to SSL_CONFIG_PIPE
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_PROV_CLIENT::Initialize()\n"
                    ));
    }

    //
    // Initialize parent (it will handle all the pipe initialization)
    //
    return SSL_CONFIG_PIPE::PipeInitializeClient( WSZ_SSL_CONFIG_PIPE );
    

}
   
HRESULT
SSL_CONFIG_PROV_CLIENT::Terminate(
    VOID
    )
/*++

Routine Description:
    Cleanup
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "SSL_CONFIG_PROV_CLIENT::Terminate()\n"
                    ));
    }
    return SSL_CONFIG_PIPE::PipeTerminateClient();
}

HRESULT 
SSL_CONFIG_PROV_CLIENT::GetOneSiteSecureBindings(
    IN  DWORD     dwSiteId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    Retrieve secure bindings for specified site
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    DWORD dwReturnedSiteId = 0;
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetOneSiteSecureBindings( %d )\n",
                    dwSiteId ));
    }

    SSL_CONFIG_PIPE_COMMAND   Command;
    HRESULT                   hr = E_FAIL;

    DBG_ASSERT( pSecureBindings != NULL );
    
    Command.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    Command.dwParameter1 = dwSiteId;

    PipeLock();
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }
    
    hr = ReceiveOneSiteSecureBindings( &dwReturnedSiteId , 
                                       pSecureBindings );

Cleanup:
    if( FAILED( hr ) )
    {
        IF_DEBUG( TRACE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "GetOneSiteSecureBindings( %d ) leaving with error. hr = 0x%x\n",
                        hr ));
        }
    }
    PipeUnlock();
    return hr;

}

HRESULT 
SSL_CONFIG_PROV_CLIENT::ReceiveOneSiteSecureBindings(
    OUT DWORD *   pdwSiteId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    read secure bindings from pipe

    Note: it's caller's responsibility to have pipe access locked
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_RESPONSE_HEADER   ResponseHeader;
    HRESULT                           hr = E_FAIL;

    DBG_ASSERT( pSecureBindings != NULL );
    DBG_ASSERT( pdwSiteId != NULL );
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto failed;
    }
    DBG_ASSERT( ResponseHeader.dwCommandId == CMD_GET_ONE_SITE_SECURE_BINDINGS );
    *pdwSiteId = ResponseHeader.dwParameter1;
    
    if ( FAILED ( ResponseHeader.hrErrorCode ) )
    {
        //
        // return error reported by ssl configuration info provider
        //
        //BUGBUG always read data to clean up pipe
        
        hr = ResponseHeader.hrErrorCode;
        goto failed;
    }
    if ( !pSecureBindings->Resize( ResponseHeader.dwResponseSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        goto failed;
    }

    hr = PipeReceiveData( ResponseHeader.dwResponseSize,
                          reinterpret_cast<BYTE *>(pSecureBindings->QueryPtr()) );
    if ( FAILED( hr ) )
    {
        goto failed;
    }    
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    return hr;    
    
}

HRESULT
SSL_CONFIG_PROV_CLIENT::StartAllSitesSecureBindingsEnumeration(
    VOID
    )
/*++

Routine Description:
    Lock named pipe for exclusive access
    Send command over named pipe to read all secure bindings

    Note: StopSiteSecureBindingsEnumeration() must be called
    to unlock named pipe (after successfull
    StartAllSitesSecureBindingsEnumeration() call )
Arguments:

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_COMMAND            Command;
    SSL_CONFIG_PIPE_RESPONSE_HEADER    ResponseHeader;
    HRESULT                            hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StartAllSitesSecureBindingsEnumeration\n",
                    hr ));
    }
   
    Command.dwCommandId = CMD_GET_ALL_SITES_SECURE_BINDINGS;
    Command.dwParameter1 = 0;

    PipeLock();
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto Failure;
    }
    DBG_ASSERT( ResponseHeader.dwCommandId == Command.dwCommandId );
    //
    // Response size 0 means that reponse will be terminated by 
    // special termination record 
    //
    DBG_ASSERT( ResponseHeader.dwResponseSize == 0 );

    if ( FAILED( ResponseHeader.hrErrorCode ) )
    {
        hr = ResponseHeader.hrErrorCode;
        goto Failure;
    }
    
    hr = S_OK;
    return hr;
   
Failure:
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StartAllSitesSecureBindingsEnumeration() leaving with error. hr = 0x%x\n",
                    hr ));
    }

    PipeUnlock();
    return hr;
}

HRESULT
SSL_CONFIG_PROV_CLIENT::StopAllSitesSecureBindingsEnumeration(
    VOID
    )
/*++

Routine Description:
    If all enumerated data was not read using GetNextSiteSecureBindings()
    it will read the leftover. Then unlock access to named pipe

    Note: call only after successful StartAllSitesSecureBindingsEnumeration()

Arguments:

Return Value:

    HRESULT

--*/    
{
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "StopAllSitesSecureBindingsEnumeration\n"
                   ));
    }
    
    PipeUnlock();
    return S_OK;
}

HRESULT
SSL_CONFIG_PROV_CLIENT::GetNextSiteSecureBindings( 
    OUT DWORD *   pdwId,
    OUT MULTISZ * pSecureBindings
    )
/*++

Routine Description:
    Enumerate all Secure Bindings after StartSiteSecureBindingsEnumeration()
    was called

    Note: StopSiteSecureBindingsEnumeration() must always be called
    afterwards to unlock named pipe

    Note: only those sites that contain secure bindings will be enumerated

Arguments:
    pdwId - ID of the enumerated site
    pSecureBindings - secure bindings

Return Value:

    HRESULT  
             HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) means that all Sites
             have been enumerated already. This signals the end of enumeration

--*/    
{
    return ReceiveOneSiteSecureBindings ( pdwId,
                                          pSecureBindings );
}

HRESULT
SSL_CONFIG_PROV_CLIENT::GetOneSiteSslConfiguration(
    IN  DWORD dwSiteId,
    OUT SITE_SSL_CONFIGURATION * pSiteSslConfiguration
    )
/*++

Routine Description:
    Get all SSL configuration parameters for specified site
    
Arguments:
    dwSiteId
    SiteSslConfiguration

Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_COMMAND         Command;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;

    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetOneSiteSslConfiguration( %d )\n",
                    dwSiteId ));
    }

    Command.dwCommandId = CMD_GET_SSL_CONFIGURATION;
    Command.dwParameter1 = dwSiteId;

    //
    // Get exclusive access to pipe
    //
    PipeLock();

    //
    // Send command to request SSL CONFIGURATION
    //
    
    hr = PipeSendCommand( &Command );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    //
    // Receive response header and later addition response data if available
    //
    
    hr = PipeReceiveResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }

    if ( ResponseHeader.dwCommandId != CMD_GET_SSL_CONFIGURATION ||
         ResponseHeader.dwResponseSize != sizeof(*pSiteSslConfiguration) )
    {
        DBG_ASSERT( FALSE );
        hr = E_FAIL;
        goto Cleanup;
    }

    if ( FAILED ( ResponseHeader.hrErrorCode ) )
    {
        //
        // return error reported by ssl configuration info provider
        //
        
        hr = ResponseHeader.hrErrorCode;
        //
        // Read data to cleanup the pipe 
        //
        PipeReceiveData( sizeof(*pSiteSslConfiguration),
                          reinterpret_cast<BYTE *>(pSiteSslConfiguration) );
    
        goto Cleanup;
    }
    
    //
    // Receive additional data
    //
    
    hr = PipeReceiveData( sizeof(*pSiteSslConfiguration),
                          reinterpret_cast<BYTE *>(pSiteSslConfiguration) );
    if ( FAILED( hr ) )
    {
        goto Cleanup;
    }    
    
    hr = S_OK;

Cleanup:
    if ( FAILED( hr ) )
    {
        IF_DEBUG( TRACE )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "GetOneSiteSslConfiguration( %d ) leaving with error. hr = 0x%x\n",
                        dwSiteId,
                        hr ));
        }
    }
    //
    // Done with pipe
    //
    PipeUnlock();
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\iisadminextension\iisadminextension.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    extcom.cxx

Abstract:

    IIS Services IISADMIN Extension
    Main COM interface.
    Class CadmExt
    CLSID = CLSID_W3EXTEND
    IID = IID_IADMEXT

Author:

    Michael W. Thomas            16-Sep-97

--*/

#include "precomp.hxx"

//
//  Debug parameters registry key.
//

static const CHAR s_pszDebugRegLocation[] =
                "System\\CurrentControlSet\\Services\\w3svc\\Parameters\\sslconfigprov";


#include <initguid.h>


CAdmExt::CAdmExt():
    m_dwRefCount(0)
{
}

CAdmExt::~CAdmExt()
{
}

HRESULT
CAdmExt::QueryInterface(REFIID riid, void **ppObject) {
    if (riid==IID_IUnknown || riid==IID_IADMEXT) {
        *ppObject = (IADMEXT *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExt::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExt::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // This is now a member of class factory.
    // It is not dynamically allocated, so don't delete it.
    //
/*
    if (dwRefCount == 0) {
        delete this;
        return 0;
    }
*/
    return dwRefCount;
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Initialize(void)
{
    HRESULT hr = E_FAIL;
    CREATE_DEBUG_PRINT_OBJECT("sslcfg");
    if (!VALID_DEBUG_PRINT_OBJECT())
    {
        return E_FAIL;
    }

    LOAD_DEBUG_FLAGS_FROM_REG_STR( s_pszDebugRegLocation, DEBUG_ERROR );

    INITIALIZE_PLATFORM_TYPE();

    hr = m_SslConfigProvServer.Initialize();
    if ( FAILED( hr ) )
    {
        return hr;
    } 

    hr = m_SslConfigChangeProvServer.Initialize();
    return hr;	    
}


HRESULT STDMETHODCALLTYPE
CAdmExt::EnumDcomCLSIDs(
    /* [size_is][out] */ CLSID *pclsidDcom,
    /* [in] */ DWORD dwEnumIndex)
{
    return HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
}

HRESULT STDMETHODCALLTYPE
CAdmExt::Terminate(void)
{
    HRESULT   hr = E_FAIL;
    hr = m_SslConfigChangeProvServer.Terminate();	
    DBG_ASSERT( SUCCEEDED( hr ) );

    hr = m_SslConfigProvServer.Terminate();	
    DBG_ASSERT( SUCCEEDED( hr ) );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\inc\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )


// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//


# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000


// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\iisadminextension\classfactory.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    classfactory.cxx

Abstract:

    starts/stops SSL configuration provider 

Author:

    Michael W. Thomas            16-Sep-97

--*/

#define INITGUID
#include "precomp.hxx"


//
// Globals
//
ULONG g_dwRefCount;
CAdmExtSrvFactory g_aesFactory;


DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();



#define SZ_EXTENSION_DESCRIPTION  TEXT("SSL CONFIG PROVIDER - IISAdmin extension")
#define SZ_DLLNAME		  TEXT("sslcfg.dll")

CAdmExtSrvFactory::CAdmExtSrvFactory()
    :m_admextObject()
{
    m_dwRefCount=0;
    g_dwRefCount = 0;
    //
    // Addref object, so refcount doesn't go to 0 if all clients release.
    //
    m_admextObject.AddRef();
}

CAdmExtSrvFactory::~CAdmExtSrvFactory()
{
    m_admextObject.Release();
}
HRESULT
CAdmExtSrvFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void ** ppObject)
{
    if (pUnkOuter != NULL) {
        return CLASS_E_NOAGGREGATION;
    }
    if (FAILED(m_admextObject.QueryInterface(riid, ppObject))) {
        return E_NOINTERFACE;
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        InterlockedIncrement((long *)&g_dwRefCount);
    }
    else {
        InterlockedDecrement((long *)&g_dwRefCount);
    }
    return NO_ERROR;
}

HRESULT
CAdmExtSrvFactory::QueryInterface(REFIID riid, void **ppObject)
{
    if (riid==IID_IUnknown || riid == IID_IClassFactory) {
            *ppObject = (IClassFactory *) this;
    }
    else {
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}

ULONG
CAdmExtSrvFactory::AddRef()
{
    DWORD dwRefCount;
    InterlockedIncrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedIncrement((long *)&m_dwRefCount);
    return dwRefCount;
}

ULONG
CAdmExtSrvFactory::Release()
{
    DWORD dwRefCount;
    InterlockedDecrement((long *)&g_dwRefCount);
    dwRefCount = InterlockedDecrement((long *)&m_dwRefCount);
    //
    // There must only be one copy of this. So keep the first one around regardless.
    //
    //    if (dwRefCount == 0) {
    //        delete this;
    //    }
    return dwRefCount;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void** ppObject)
{
    if (rclsid != CLSID_SSLCONFIGPROV) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    if (FAILED(g_aesFactory.QueryInterface(riid, ppObject))) {
        *ppObject = NULL;
        return E_INVALIDARG;
    }
    return NO_ERROR;
}

HRESULT _stdcall DllCanUnloadNow() {
        if (g_dwRefCount) {
                return S_FALSE;
                }
        else {
                return S_OK;
                }
}


STDAPI DllRegisterServer(void)
{
    HKEY hKeyCLSID, hKeyInproc32;
    DWORD dwDisposition;
    HMODULE hModule;
    DWORD dwReturn = ERROR_SUCCESS;

    dwReturn = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                              TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV,
                              NULL,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hKeyCLSID,
                              &dwDisposition);
    if (dwReturn == ERROR_SUCCESS) {
        dwReturn = RegSetValueEx(hKeyCLSID,
                                 TEXT(""),
                                 NULL,
                                 REG_SZ,
                                 (BYTE*) SZ_EXTENSION_DESCRIPTION ,
                                 sizeof(SZ_EXTENSION_DESCRIPTION ));
        if (dwReturn == ERROR_SUCCESS) {
            dwReturn = RegCreateKeyEx(hKeyCLSID,
                TEXT("InprocServer32"),
                NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                &hKeyInproc32, &dwDisposition);

            if (dwReturn == ERROR_SUCCESS) {
                hModule=GetModuleHandle(SZ_DLLNAME);
                if (!hModule) {
                    dwReturn = GetLastError();
                }
                else {
                    TCHAR szName[MAX_PATH+1];
                    if (GetModuleFileName(hModule,
                                          szName,
                                          sizeof(szName)/sizeof(szName[0])) == NULL) {
                        dwReturn = GetLastError();
                    }
                    else {
                        dwReturn = RegSetValueEx(hKeyInproc32,
                                                 TEXT(""),
                                                 NULL,
                                                 REG_SZ,
                                                 (BYTE*) szName,
                                                 sizeof(TCHAR)*(lstrlen(szName)+1));
                        if (dwReturn == ERROR_SUCCESS) {
                            dwReturn = RegSetValueEx(hKeyInproc32,
                                                     TEXT("ThreadingModel"),
                                                     NULL,
                                                     REG_SZ,
                                                     (BYTE*) TEXT("Both"),
                                                     sizeof(TEXT("Both")));
                        }
                    }
                }
                RegCloseKey(hKeyInproc32);
            }
        }
        RegCloseKey(hKeyCLSID);
    }

    if (dwReturn == ERROR_SUCCESS) {

        dwReturn = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                  IISADMIN_EXTENSIONS_REG_KEY
                                  TEXT("\\") SZ_CLSID_SSLCONFIGPROV,
                                  NULL,
                                  TEXT(""),
                                  REG_OPTION_NON_VOLATILE,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &hKeyCLSID,
                                  &dwDisposition);

        if (dwReturn == ERROR_SUCCESS) {
            RegCloseKey(hKeyCLSID);
        }

    }

    return HRESULT_FROM_WIN32(dwReturn);
}

STDAPI DllUnregisterServer(void)
{
    DWORD dwReturn = ERROR_SUCCESS;
    DWORD dwTemp;

    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV TEXT("\\InprocServer32"));
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_CLASSES_ROOT,
                          TEXT("CLSID\\") SZ_CLSID_SSLCONFIGPROV);
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    dwTemp = RegDeleteKey(HKEY_LOCAL_MACHINE,
                          IISADMIN_EXTENSIONS_REG_KEY
                          TEXT("\\") SZ_CLSID_SSLCONFIGPROV );
    if (dwTemp != ERROR_SUCCESS) {
        dwReturn = dwTemp;
    }
    return HRESULT_FROM_WIN32(dwReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\pipe\sslconfigpipe.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigpipe.cxx

   Abstract:
     SSL CONFIG PIPE implementation

     simple blocking pipe implementation
     that enables 
     - sending/receiving commands, 
     - sending/receiving response headers
     - sending/receiving arbitrary data blocks
     - implementing pipe listener that runs on dedicated thread
     - safe cleanup for thread running pipe listener
 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?
// Well typically


#include "precomp.hxx"


//static 
DWORD
SSL_CONFIG_PIPE::PipeListenerThread(
    LPVOID ThreadParam
    )
/*++

Routine Description:
    start PipeListener() method on listener thread
Arguments:

Return Value:

    HRESULT

--*/    

{
    DBG_ASSERT( ThreadParam != NULL );
    
    HRESULT                     hr = E_FAIL;
    SSL_CONFIG_PIPE *           pConfigPipe 
                    = reinterpret_cast<SSL_CONFIG_PIPE *>(ThreadParam);

    hr = pConfigPipe->PipeListener();
    if ( FAILED( hr ) )
    {
        return WIN32_FROM_HRESULT( hr );
    }
    return NO_ERROR;
}


HRESULT
SSL_CONFIG_PIPE::PipeInitialize(
    IN const WCHAR * wszPipeName,
    IN BOOL          fServer
    )
/*++

Routine Description:
    Create/connect named pipe
    Create listener thread ( if PipeListener() implemented )

Arguments:

    wszPipeName - pipe name to create/connect
    fServer    - indicate server side pipe (determines whether to create
                 or connect to pipe )

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    HANDLE          hEvent = NULL;
    INITIALIZE_CRITICAL_SECTION( &_csPipeLock );

    // 
    // Setup overlapped
    //
    
    ZeroMemory( &_OverlappedR,
                sizeof( _OverlappedR ) );

    ZeroMemory( &_OverlappedW,
                sizeof( _OverlappedW ) );

    
    // Create an event object for this instance. 
 
    _OverlappedR.hEvent = CreateEvent( 
                 NULL,    // no security attribute 
                 TRUE,    // manual-reset event 
                 TRUE,    // initial state = signaled 
                 NULL);   // unnamed event object 

    if ( _OverlappedR.hEvent == NULL ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create Event.  hr = %x\n",
                    hr ));
      
        goto Cleanup;
    }  
    // Create an event object for this instance. 
 
    _OverlappedW.hEvent = CreateEvent( 
                 NULL,    // no security attribute 
                 TRUE,    // manual-reset event 
                 TRUE,    // initial state = signaled 
                 NULL);   // unnamed event object 

    if ( _OverlappedW.hEvent == NULL ) 
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create Event.  hr = %x\n",
                    hr ));
      
        goto Cleanup;
    }  
    
    
    if( fServer )
    {
        //
        // create a named pipe
        //
        
       _hSslConfigPipe = CreateNamedPipe(
                    wszPipeName,
                    PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED ,
                    PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
                    1, // number of instances
                    4096,
                    4096,
                    0,
                    NULL /* pSa */ );
    }
    else
    {
        //
        // Client (connect to existing pipe)
        //
        _hSslConfigPipe = CreateFile( wszPipeName,
                                    GENERIC_READ | GENERIC_WRITE,
                                    0,
                                    NULL,//&sa,
                                    OPEN_EXISTING,
                                    FILE_FLAG_OVERLAPPED,
                                    NULL );
    }                

                            
    if ( _hSslConfigPipe == INVALID_HANDLE_VALUE )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to create SSL_CONFIG_PIPE pipe.  hr = %x\n",
                    wszPipeName,
                    hr ));
      
        goto Cleanup;
    }
    
    if ( QueryEnablePipeListener() )
    {
        _hPipeListenerThread = 
              ::CreateThread( 
                      NULL,     // default security descriptor
                      0,        // default process stack size
                      SSL_CONFIG_PIPE::PipeListenerThread,
                      this,     // thread argument - pointer to this class
                      0,        // create running
                      NULL      // don't care for thread identifier
                      );
        if ( _hPipeListenerThread == NULL )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                            "Failed to create thread for SSL_CONFIG_PIPE. hr=0x%x\n",
                            hr ));
            goto Cleanup;
        }
    }
    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        PipeTerminate( fServer );
    }
    return hr;    
}
   
HRESULT
SSL_CONFIG_PIPE::PipeTerminate(
    IN BOOL          /*fServer*/
    )
/*++

Routine Description:
    close pipe, handle proper cleanup ot the listener thread
    
Arguments:
    fServer - not used

Return Value:

    HRESULT

--*/    
{
    DWORD dwRet = 0;

    SetPipeIsTerminating();

    //
    // _SSLConfigucationPipe is created before
    // _hSslConfigurationPipeHandlingThread is created
    // and based on typical cleanup logic it would be expected
    // that will be closed closed after thread completed
    // However, we have to close _SSLConfigucationPipe beforehand
    // because that will actually trigger thread to complete
    //
    
    if ( _hSslConfigPipe != INVALID_HANDLE_VALUE )
    {
        CloseHandle( _hSslConfigPipe );
        _hSslConfigPipe = INVALID_HANDLE_VALUE;
    }
        
    if ( _hPipeListenerThread != NULL )
    {
        //
        // Wait till worker thread has completed
        //
        dwRet = WaitForSingleObject( _hPipeListenerThread, 
                                     INFINITE );

        DBG_ASSERT( dwRet == WAIT_OBJECT_0 );
        CloseHandle( _hPipeListenerThread );
        _hPipeListenerThread = NULL;
    }
   
    //
    // Cleanup overlapped 
    //

    if ( _OverlappedR.hEvent == NULL ) 
    {
        CloseHandle( _OverlappedR.hEvent );
        _OverlappedR.hEvent = NULL;
    }

    if ( _OverlappedW.hEvent == NULL ) 
    {
        CloseHandle( _OverlappedW.hEvent );
        _OverlappedW.hEvent = NULL;
    }

    DeleteCriticalSection( &_csPipeLock );
    return S_OK;
}


VOID
SSL_CONFIG_PIPE::PipeLock(
    VOID
    )
/*++

Routine Description:
    Lock named pipe to guarantee exclusive access
    
Arguments:

Return Value:

    VOID

--*/    
{
    EnterCriticalSection( &_csPipeLock );
}

VOID
SSL_CONFIG_PIPE::PipeUnlock(
    VOID
    )
/*++

Routine Description:
    Unlock named pipe
    
Arguments:

Return Value:

    VOID

--*/    
{
    LeaveCriticalSection( &_csPipeLock );
}


HRESULT
SSL_CONFIG_PIPE::PipeConnectServer(
    VOID
    )
/*++

Routine Description:
    Connect pipe on the server side
    Call is blocking until pipe connected

    
Arguments:

Return Value:

    VOID

--*/            
{
    BOOL    fRet = FALSE;
    DWORD   cbBytes = 0;
    HRESULT hr = E_FAIL;
    
    // Start an overlapped connection for this pipe instance. 
    fRet = ConnectNamedPipe( _hSslConfigPipe, 
                             &_OverlappedR ); 
 
    // Overlapped ConnectNamedPipe should return zero. 
    if ( fRet ) 
    {
        return S_OK;
    }
    
    hr = HRESULT_FROM_WIN32( GetLastError() );
    hr = PipeWaitForCompletion( hr,
                                &_OverlappedR,
                                &cbBytes );
    if ( FAILED( hr ) && !QueryPipeIsTerminating() )
    {
         DBGPRINTF(( DBG_CONTEXT,
                    "Failed on ConnectNamedPipe().  hr = %x\n",
                    hr ));
    }
    return hr;
}

HRESULT
SSL_CONFIG_PIPE::PipeDisconnectServer(
        VOID
        )
/*++

Routine Description:
    Disconnect server side pipe

Arguments:

Return Value:

    VOID

--*/            
{
    if( ! DisconnectNamedPipe( _hSslConfigPipe ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}

HRESULT
SSL_CONFIG_PIPE::PipeSendData(
    IN DWORD  cbNumberOfBytesToWrite,
    IN BYTE * pbBuffer
    )
/*++

Routine Description:
      Send specified number of bytes from named pipe
    
Arguments:
    cbNumberOfBytesToWrite - bytes to write
    pbBuffer - data 
Return Value:

    HRESULT

--*/    
{
    DWORD                     cbNumberOfBytesWritten;
    BOOL                      fRet = FALSE;
    HRESULT                   hr = E_FAIL;

    fRet = WriteFile ( _hSslConfigPipe,
                       pbBuffer,
                       cbNumberOfBytesToWrite,
                       &cbNumberOfBytesWritten,
                       &_OverlappedW );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        hr = PipeWaitForCompletion( hr,
                                    &_OverlappedW,
                                    &cbNumberOfBytesWritten );    
        if ( FAILED( hr )  )
        {
            if ( !QueryPipeIsTerminating() && 
                 hr != HRESULT_FROM_WIN32( ERROR_PIPE_LISTENING ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to send response over named pipe SSL_CONFIG_PIPE.  hr = %x\n",
                            hr ));
            }
            return hr;
        }
    }
    if ( cbNumberOfBytesToWrite != cbNumberOfBytesWritten )
    {
        //
        // BUGBUG: better error code
        //
        hr = E_FAIL;
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to send response over named pipe SSL_CONFIG_PIPE.  hr = %x\n",
                    hr ));
        return hr;

    }
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Sent %d bytes\n",
                    cbNumberOfBytesWritten ));
    }
    return S_OK;
}

HRESULT
SSL_CONFIG_PIPE::PipeReceiveData(
    IN  DWORD  cbBytesToRead,
    OUT BYTE * pbBuffer
    )
/*++

Routine Description:
    Receive specified number of bytes from named pipe
    
Arguments:
    cbNumberOfBytesToRead - number of bytes to read - 
                            function will not return success unless
                            specified number of bytes was read
    pbBuffer              - allocated by caller  
    
Return Value:
    HRESULT

--*/    
{
    DWORD                     cbNumberOfBytesRead = 0;
    DWORD                     cbTotalNumberOfBytesRead = 0;
    BOOL                      fRet = FALSE;
    HRESULT                   hr = E_FAIL;

    DBG_ASSERT ( cbBytesToRead != 0 );

    do
    {
        fRet = ReadFile(   _hSslConfigPipe,
                           pbBuffer,
                           cbBytesToRead - cbTotalNumberOfBytesRead,
                           &cbNumberOfBytesRead,
                           &_OverlappedR );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            hr = PipeWaitForCompletion( hr,
                                        &_OverlappedR,
                                        &cbNumberOfBytesRead );    
            if ( FAILED( hr ) )
            {
                if ( !QueryPipeIsTerminating() && 
                     ( hr != HRESULT_FROM_WIN32( ERROR_BROKEN_PIPE ) ) )
                {
                    //
                    // do not dump broken pipe errors
                    //
                    DBGPRINTF(( DBG_CONTEXT,
                                "Failed to receive request over named pipe SSL_INFO_PROV.  hr = %x\n",
                                hr ));
                }
                return hr;
            }

        }
        if ( cbNumberOfBytesRead == 0 )
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
            DBGPRINTF(( DBG_CONTEXT,
                    "Failed to receive request over named pipe SSL_INFO_PROV - end of pipe.  hr = %x\n",
                    hr ));
            return hr;

        }
        cbTotalNumberOfBytesRead += cbNumberOfBytesRead;
        
    } while ( cbTotalNumberOfBytesRead != cbBytesToRead );
    IF_DEBUG( TRACE )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "PipeReceiveData: %d bytes\n",
                    cbTotalNumberOfBytesRead ));
    }

    return S_OK;
}

HRESULT
SSL_CONFIG_PIPE::PipeWaitForCompletion(
    IN  HRESULT     hrLastError,
    IN OVERLAPPED * pOverlapped,   
    OUT DWORD *     pcbTransferred
        )
/*++

Routine Description:
    Wait for completion of nonblocking operation
    used for CreateNamedPipe, ReadFile and WriteFile

    Note: To outside world this pipe implementation is blocking
    but internally we use OVERLAPPED and that wait for completion.
    That way it is possible to terminate pipe by closing handle
    
Arguments:

Return Value:

    VOID

--*/            
{
    BOOL    fRet = FALSE;
    DWORD   dwRet = 0;
    HRESULT hr = E_FAIL;
    
    switch ( hrLastError ) 
    { 
    case HRESULT_FROM_WIN32( ERROR_IO_PENDING ): 
         //
         // The overlapped connection in progress. 
         // wait for event to be signalled
         //
         dwRet = WaitForSingleObject( pOverlapped->hEvent,
                                      INFINITE );
         DBG_ASSERT( dwRet == WAIT_OBJECT_0 );

         fRet = GetOverlappedResult( 
                        _hSslConfigPipe,              // handle to pipe 
                        pOverlapped,                // OVERLAPPED structure 
                        pcbTransferred,             // bytes transferred 
                        FALSE );                    // do not wait 
         if ( !fRet )
         {
             hr = HRESULT_FROM_WIN32( GetLastError() );
             return hr;

         }
         return S_OK;
         
    case HRESULT_FROM_WIN32( ERROR_PIPE_CONNECTED ): 
         // Client is already connected
         return S_OK;
         
    default: 
         // If an error occurs during the operation... 
         hr = HRESULT_FROM_WIN32( GetLastError() );
         return hr;
         
    } 
}

   
HRESULT
SSL_CONFIG_PIPE::PipeReceiveCommand(
    OUT SSL_CONFIG_PIPE_COMMAND * pCommand
    )
/*++

Routine Description:
    Receive command to execute
    
Arguments:
    pCommand
    
Return Value:
    HRESULT

--*/    
{
    return PipeReceiveData( sizeof(SSL_CONFIG_PIPE_COMMAND),
                            reinterpret_cast<BYTE *>(pCommand) );
    
}

HRESULT
SSL_CONFIG_PIPE::PipeReceiveResponseHeader(
    OUT SSL_CONFIG_PIPE_RESPONSE_HEADER * pResponseHeader
    )
/*++

Routine Description:
    after command was sent over named pipe, use PipeReceiveResponseHeader
    to retrieve initial header of the response (it contains all the relevant
    information to complete reading the whole response)
    
Arguments:
    ResponseHeader
    
Return Value:
    HRESULT

--*/    
{
    return PipeReceiveData( sizeof(SSL_CONFIG_PIPE_RESPONSE_HEADER),
                            reinterpret_cast<BYTE *>(pResponseHeader) );
    
}

HRESULT
SSL_CONFIG_PIPE::PipeSendCommand(
    OUT SSL_CONFIG_PIPE_COMMAND * pCommand
    )
/*++

Routine Description:
    Send command to execute
    
Arguments:
    pCommand
    
Return Value:
    HRESULT

--*/    
{
    return PipeSendData( sizeof(SSL_CONFIG_PIPE_COMMAND),
                         reinterpret_cast<BYTE *>(pCommand) );
    
}

HRESULT
SSL_CONFIG_PIPE::PipeSendResponseHeader(
    OUT SSL_CONFIG_PIPE_RESPONSE_HEADER * pResponseHeader
    )
/*++

Routine Description:
    send response header
    
Arguments:
    pResponseHeader
    
Return Value:
    HRESULT

--*/    
{
    return PipeSendData( sizeof(SSL_CONFIG_PIPE_RESPONSE_HEADER),
                         reinterpret_cast<BYTE *>(pResponseHeader) );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\server\sslconfigchangeprov.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigchangeprov.cxx

   Abstract:
     SSL CONFIG PROV server

     Listens for metabase notifications related to SSL
     and informs connected client appropriately

 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?
// Well typically


#include "precomp.hxx"

//
// Constants
//

#define W3_SERVER_MB_PATH       L"/LM/W3SVC/"
#define W3_SERVER_MB_PATH_CCH   10

//
// private declarations
//

class MB_LISTENER
    : public MB_BASE_NOTIFICATION_SINK
{
public:

    MB_LISTENER( SSL_CONFIG_CHANGE_PROV_SERVER * pSslConfigChangeProv  )
        :
        _pSslConfigChangeProv( pSslConfigChangeProv )
    {
    }

    STDMETHOD( SynchronizedSinkNotify )( 
        DWORD               dwMDNumElements,
        MD_CHANGE_OBJECT    pcoChangeList[]
        )
    {
        DBG_ASSERT( _pSslConfigChangeProv != NULL );
        return _pSslConfigChangeProv->MetabaseChangeNotification(
                                        dwMDNumElements,
                                        pcoChangeList );
    }

private:
    SSL_CONFIG_CHANGE_PROV_SERVER * _pSslConfigChangeProv;
};



//virtual
HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::PipeListener(
    VOID
    )
/*++

Routine Description:
    Listens on SslConfigPipe and executes commands
    
Arguments:

Return Value:

    HRESULT

--*/        
{
    HRESULT                     hr = E_FAIL;
    SSL_CONFIG_PIPE_COMMAND     Command;
    do
    {
        if ( FAILED( hr = PipeConnectServer() ) )
        {
            goto Cleanup;
        }
        //
        // Even though change notification pipe doesn't expect 
        // any data received from client
        // we will use PipeReceiveCommand() for detection when pipe
        // get's closed so that we can recycle it
        //
        
        hr = PipeReceiveCommand( &Command );
        if ( FAILED( hr ) )
        {
           goto  Cleanup;
        }
        //
        // client should never send data over the change notification pipe
        //
        DBG_ASSERT( FAILED( hr ) );
    Cleanup: 
        //
        // disconnect must always be called before trying to reconnect again
        //
        PipeDisconnectServer();
       
        //
        // Cleanup may occur due to 2 reasons
        // - client have disconnected ( this is OK )
        // - there was some other error executing command
        // - SSL_INFO_PROVIDER_SERVER is terminating (pipe handle was closed)
        //
    }while ( !QueryPipeIsTerminating() );
    
    return S_OK;
}
 

 

HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::Initialize(
    VOID
    )
/*++

Routine Description:
    Initialize named pipe
    Connect to metabase
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    HANDLE          hEvent = NULL;

    // 
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           reinterpret_cast<LPVOID *>(&_pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }
    
    //
    // Initialize the metabase sink
    // (it will not start listening yet)
    //

    _pListener = new MB_LISTENER( this );
    if ( _pListener == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating metabase listener.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }   

    //
    // Initialize parent - it will create pipe and
    // start listener thread ( thread will execute PipeListener() )
    //
    hr = SSL_CONFIG_PIPE::PipeInitializeServer( WSZ_SSL_CONFIG_CHANGE_PIPE );
    if( FAILED(hr) )
    {
        goto Cleanup;
    }

    //
    // Start listening for metabase changes
    //
   
    DBG_ASSERT( _pAdminBase != NULL );
    
    hr = _pListener->StartListening( _pAdminBase );
    if ( FAILED( hr ) )  
    {
        return hr;
    }
    

    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
    return hr;    
}
   
HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::Terminate(
    VOID
    )
/*++

Routine Description:
    Close named pipe for metabase change notifications
    Close metabase named pipe
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;
    
    //
    // Stop listening for metabase changes
    //

    _pListener->StopListening( _pAdminBase );

    //
    // Terminate parent first (it will close the pipe 
    // and stop listener thread)
    //
    hr = SSL_CONFIG_PIPE::PipeTerminateServer();
    DBG_ASSERT( SUCCEEDED( hr ) );

    //
    // Terminate metabase listener
    //

    if ( _pListener != NULL )
    {
        _pListener->Release();
        _pListener = NULL;
    }
    
    // 
    // Terminate the metabase access (ABO)
    //
    
    if ( _pAdminBase != NULL )
    {
        _pAdminBase->Release();
        _pAdminBase = NULL;
    } 
    return S_OK;
}

HRESULT
SSL_CONFIG_CHANGE_PROV_SERVER::MetabaseChangeNotification(
    DWORD               dwMDNumElements,
    MD_CHANGE_OBJECT    pcoChangeList[]
)
/*++

Routine Description:

    Handle metabase change notifications

Arguments:

    dwMDNumElements - Number of elements changed
    pcoChangeList - Elements changed

Return Value:

    HRESULT

--*/
{
    LPWSTR                  pszSiteString;
    DWORD                   dwSiteId;
    LPWSTR                  pszAfter;
    BOOL                    fDoSiteConfigUpdate;
    BOOL                    fDoSiteBindingUpdate;
    SSL_CONFIG_PIPE_COMMAND Command;
    HRESULT                 hr = E_FAIL;

    
    DBG_ASSERT( dwMDNumElements != 0 );
    DBG_ASSERT( pcoChangeList != NULL );

    //
    // Only handle the W3SVC changes
    //
    
    for( DWORD i = 0; i < dwMDNumElements; ++i )
    {
        if( _wcsnicmp( pcoChangeList[i].pszMDPath,
                       W3_SERVER_MB_PATH,
                       W3_SERVER_MB_PATH_CCH ) == 0 )
        {
            fDoSiteConfigUpdate = FALSE;
            fDoSiteBindingUpdate = FALSE;
            
            //
            // Was this change made for a site, or for all of W3SVC
            //
    
            pszSiteString = pcoChangeList[i].pszMDPath + W3_SERVER_MB_PATH_CCH;
            if ( *pszSiteString != L'\0' )
            {
                dwSiteId = wcstoul( pszSiteString, &pszAfter, 10 );
            }
            else
            {
                //
                // A site id of 0 means we will flush all site config
                //
                
                dwSiteId = 0;
            }
            
            //
            // Now check whether the changed property was an SSL prop
            //
            
            for ( DWORD j = 0; j < pcoChangeList[ i ].dwMDNumDataIDs; j++ )
            {
                if ( fDoSiteConfigUpdate )
                {
                    break;
                }
                
                switch( pcoChangeList[ i ].pdwMDDataIDs[ j ] )
                {
                case MD_SSL_CERT_HASH:
                case MD_SSL_CERT_CONTAINER:
                case MD_SSL_CERT_PROVIDER:
                case MD_SSL_CERT_OPEN_FLAGS:
                case MD_SSL_CERT_STORE_NAME:
                case MD_SSL_CERT_IS_FORTEZZA:
                case MD_SSL_CERT_FORTEZZA_PIN:
                case MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER:
                case MD_SSL_CERT_FORTEZZA_PERSONALITY:
                case MD_SSL_CERT_FORTEZZA_PROG_PIN:
                case MD_SSL_CTL_IDENTIFIER:
                case MD_SSL_CTL_CONTAINER:
                case MD_SSL_CTL_PROVIDER:
                case MD_SSL_CTL_PROVIDER_TYPE:
                case MD_SSL_CTL_OPEN_FLAGS:
                case MD_SSL_CTL_STORE_NAME:
                case MD_SSL_CTL_SIGNER_HASH:
                case MD_SSL_USE_DS_MAPPER:
                case MD_SERIAL_CERT11:
                case MD_SERIAL_CERTW:
                case MD_SSL_ACCESS_PERM:
                case MD_CERT_CHECK_MODE:
                case MD_REVOCATION_FRESHNESS_TIME:
                case MD_REVOCATION_URL_RETRIEVAL_TIMEOUT:
                    fDoSiteConfigUpdate = TRUE;
                    break;
                    
                case MD_SECURE_BINDINGS:
                    fDoSiteBindingUpdate = TRUE;
                    break;
                }
            }
            
            //
            // Update the site bindings if necessary
            //
            
            if ( fDoSiteBindingUpdate )
            {
                ZeroMemory( &Command,
                            sizeof( Command ) );
                Command.dwCommandId = CMD_CHANGED_SECURE_BINDINGS;
                Command.dwParameter1 = dwSiteId;

                hr = PipeSendCommand( &Command );
                if ( FAILED( hr ) )
                {
                    goto failed;
                }
            }
            
            //
            // Update the site configurations if necessary
            //
            
            if ( fDoSiteConfigUpdate )
            {
                //
                // dwSiteId == 0 means flush all sites
                //
                ZeroMemory( &Command,
                            sizeof( Command ) );
                Command.dwCommandId = CMD_CHANGED_SSL_CONFIGURATION;
                Command.dwParameter1 = dwSiteId;

                hr = PipeSendCommand( &Command );
                if ( FAILED( hr ) )
                {
                    goto failed;
                }
                
                if ( dwSiteId == 0 )
                {
                    //
                    // If we've already flushed every site, then no 
                    // reason to read any more changes
                    //
                    
                    break;
                }
            }
        }   
    }
    return S_OK;
failed:
    DBG_ASSERT( FAILED( hr ) );
    //
    // failure may have been caused by the fact 
    // that there is no client connected yet
    //
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\sslconfigprov\server\sslconfigprov.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     sslconfigprovserver.cxx

   Abstract:
     SSL CONFIG PROV server

     Listens to commands sent from clients and executes
     SSL parameter lookups in the metabase
 
   Author:
     Jaroslav Dunajsky      April-24-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


// BUGBUG - how to handle errors during pipe operations
// if there is some data left over on pipe unread then all subsequent
// users of the pipe will be toast. Should we just close and reopen pipe connection?
// Well typically


#include "precomp.hxx"


//virtual
HRESULT
SSL_CONFIG_PROV_SERVER::PipeListener(
    VOID
    )
/*++

Routine Description:
    Listens on SslConfigPipe and executes commands
    
Arguments:

Return Value:

    HRESULT

--*/        
{
    SSL_CONFIG_PIPE_COMMAND   Command;
    HRESULT                     hr = E_FAIL;
    
    do
    {
        if ( FAILED( hr = PipeConnectServer() ) )
        {
            goto Cleanup;
        }
        hr = S_OK;
        //
        // Listen on pipe to receive commands
        // and handle them
        //
        while ( TRUE )
        {
            hr = PipeReceiveCommand( &Command );
            if ( FAILED( hr ) )
            {
               goto  Cleanup;
            }
            switch( Command.dwCommandId )
            {
            case CMD_GET_SSL_CONFIGURATION:
                hr = SendSiteSslConfiguration( Command.dwParameter1 );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
                break;
            case CMD_GET_ONE_SITE_SECURE_BINDINGS:
                hr = SendOneSiteSecureBindings( Command.dwParameter1 );
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
                break;
            case CMD_GET_ALL_SITES_SECURE_BINDINGS:
                hr = SendAllSitesSecureBindings();
                if ( FAILED( hr ) )
                {
                    goto Cleanup;
                }
                break;
            case INVALID_SSL_CONFIGURATION_COMMAND:
            default:
                DBG_ASSERT(FALSE);
            }
        }
    Cleanup: 
        PipeDisconnectServer();
       
        //
        // Cleanup may occur due to 2 reasons
        // - client have disconnected ( this is OK )
        // - there was some other error executing command
        // - SSL_INFO_PROVIDER_SERVER is terminating (pipe handle was closed)
        //
    }   while ( !QueryPipeIsTerminating() );
    
    return S_OK;
}
 

HRESULT
SSL_CONFIG_PROV_SERVER::Initialize(
    VOID
)
/*++

Routine Description:
    Initialize named pipe
    Connect to metabase
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT         hr = E_FAIL;
    HANDLE          hEvent = NULL;

    // 
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           reinterpret_cast<LPVOID *>(&_pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Cleanup;
    }

    //
    // Initialize parent - it will create pipe and
    // start listener thread ( thread will execute PipeListener() )
    //
    hr = SSL_CONFIG_PIPE::PipeInitializeServer( WSZ_SSL_CONFIG_PIPE );
    if( FAILED(hr) )
    {
        goto Cleanup;
    }
    hr = S_OK;
Cleanup:
    if ( FAILED( hr ) )
    {
        Terminate();
    }
    return hr;    
}
   
HRESULT
SSL_CONFIG_PROV_SERVER::Terminate(
    VOID
    )
/*++

Routine Description:
    Close named pipe for metabase change notifications
    Close metabase named pipe
    
Arguments:

Return Value:

    HRESULT

--*/    
{
    HRESULT hr = E_FAIL;

    //
    // Terminate parent first (it will close the pipe 
    // and stop listener thread)
    //
    hr = SSL_CONFIG_PIPE::PipeTerminateServer();
    DBG_ASSERT( SUCCEEDED( hr ) );
    
    // 
    // Terminate the metabase access (ABO)
    //
    
    if ( _pAdminBase != NULL )
    {
        _pAdminBase->Release();
        _pAdminBase = NULL;
    } 
    return S_OK;
}


HRESULT 
SSL_CONFIG_PROV_SERVER::SendOneSiteSecureBindings(
    IN          DWORD     dwSiteId,
    OPTIONAL IN BOOL      fNoResponseOnNotFoundError,
    OPTIONAL IN MB *      pMb     
    )
/*++

Routine Description:
    Read secure bindings for the site from metabase and send them over 
    named pipe
    
Arguments:
    dwSiteId - site ID
    fNoResponseOnNotFoundError - in the case of error don't send response to client
                         it is used for multisite enumeration to not to send 
                         MD_ERROR_DATA_NOT_FOUND
    pMb - already opened metabase (used for multisite enumeration)


Return Value:

    HRESULT

--*/    
{
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;
    MB                                mb( _pAdminBase );
    BOOL                              fOpenedMetabase = FALSE;
    MULTISZ                           mszBindings;
    WCHAR                             achSitePath[10];
    DWORD                             dwNumberOfStringsInMultisz;
    DWORD                             cbBindings;
    BOOL                              fRet = FALSE;

    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );
 
    //
    // Read secure bindings from metabase
    //

    if ( pMb == NULL )
    {
        fRet = mb.Open( L"/LM/W3SVC",
                        METADATA_PERMISSION_READ );
        if ( !fRet )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to open metabase.  hr = %x\n",
                        hr ));

            goto SendResponse;
        }
        pMb = &mb;
        fOpenedMetabase = TRUE;
    }
    

    _snwprintf( achSitePath,
                sizeof( achSitePath ) / sizeof( WCHAR ) - 1,
                L"/%d/",
                dwSiteId );

    fRet = pMb->GetMultisz( achSitePath,
                            MD_SECURE_BINDINGS,
                            IIS_MD_UT_SERVER,
                            &mszBindings,
                            0 );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if ( !( fNoResponseOnNotFoundError && 
              ( hr == MD_ERROR_DATA_NOT_FOUND ) ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Failed to Get Multisz.  hr = %x\n",
                        hr ));
        }
        goto SendResponse;
    }

    hr = S_OK;
    
SendResponse:

    // 
    // Close metabase handle
    //
    if ( fOpenedMetabase )
    {
        mb.Close();
    }
    if ( fNoResponseOnNotFoundError && 
         ( hr == MD_ERROR_DATA_NOT_FOUND ) )
    {
        //
        // MD_ERROR_DATA_NOT_FOUND is OK
        // it is OK for site not to have secure bindings configured
        //
        return S_OK;
    }


    //
    // Prepare and send ResponseHeader
    //
    
    if ( FAILED( hr ) )
    {
        cbBindings = 0;
    }
    else
    {
        cbBindings =  sizeof(WCHAR) *
                        ( MULTISZ::CalcLength( 
                                reinterpret_cast<WCHAR *>(mszBindings.QueryPtr()),
                                &dwNumberOfStringsInMultisz ) +
                                   0 /*for Terminating 0*/);

    }
    
    ResponseHeader.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = dwSiteId;
    ResponseHeader.hrErrorCode = hr;
    ResponseHeader.dwResponseSize = cbBindings;
    
    hr = PipeSendResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    if ( cbBindings != 0 )
    {
        //
        // Send Bindings data
        //

        hr = PipeSendData( 
                        cbBindings,
                        reinterpret_cast<BYTE *>(mszBindings.QueryPtr()) );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }
    hr = S_OK;
    return hr;

}

HRESULT
SSL_CONFIG_PROV_SERVER::SendAllSitesSecureBindings( 
    )
/*++

Routine Description:
    Enumerate all Secure Bindings and write it to named pipe

Arguments:

Return Value:
    HRESULT  
             

--*/    
{
    DWORD                           dwSiteId = 0;
    MB                              mb( _pAdminBase );
    DWORD                           dwIndex = 0;
    WCHAR                           achSitePath[ METADATA_MAX_NAME_LEN ];
    WCHAR *                         pchEndPtr;
    HRESULT                         hr = E_FAIL;
    HRESULT                         hrMB = E_FAIL;
    BOOL                            fRet = FALSE;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;

    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );

    fRet = mb.Open( L"/LM/W3SVC",
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hrMB = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open metabase.  hr = %x\n",
                    hrMB ));
        // Don't do goto Cleanup;
        //
        // Before returning from the function
        // report error over named pipe
        //
    }
    else
    {
        hrMB = S_OK;
    }

    //
    // First part of the response
    // - in the case of previous error this is the only response sent to client
    // - in the case of success, CMD_GET_ONE_SITE_SECURE_BINDINGS response will
    //   be returned for each site )
    //
    
    ResponseHeader.dwCommandId = CMD_GET_ALL_SITES_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = 0;
    ResponseHeader.hrErrorCode = hrMB;
    ResponseHeader.dwResponseSize = 0; // 0 indicates that

    hr = PipeSendResponseHeader( &ResponseHeader );

    if ( FAILED( hr ) || FAILED( hrMB ) )
    {
        goto Cleanup;
    }

    //
    // Enumerate all sites
    //
    dwIndex = 0;
    while ( mb.EnumObjects( L"", 
                            achSitePath,
                            dwIndex++ ) )
    {
        //
        // We only want the sites (w3svc/<number>)
        //
        
        dwSiteId = wcstoul( achSitePath, 
                            &pchEndPtr, 
                            10 );
        if ( * pchEndPtr != L'\0' )
        {
            //
            // Correct Site node must consist of digits only
            // if pchEndPtr is pointing to anything but 0, it means
            // invalid value. We will ignore
            continue;
        }
        
        //
        // Send bindings for current site
        //
        hr = SendOneSiteSecureBindings ( dwSiteId,
                                         TRUE, /*fNoResponseOnError*/
                                         &mb );
        if ( FAILED( hr ) )
        {
            goto Cleanup;
        }
    }
    //
    // Terminating record
    // if everything went OK then EnumObjects() returned
    // ERROR_NO_MORE_ITEMS - That is indication for client
    // that all data has been retrieved
    //
    
    ResponseHeader.dwCommandId = CMD_GET_ONE_SITE_SECURE_BINDINGS;
    ResponseHeader.dwParameter1 = 0;
    ResponseHeader.hrErrorCode = HRESULT_FROM_WIN32( GetLastError() );
    ResponseHeader.dwResponseSize = 0;

    hr = PipeSendResponseHeader( &ResponseHeader );

    if ( FAILED( hr ) || FAILED( hrMB ) )
    {
        goto Cleanup;
    }
    
    hr = S_OK;
Cleanup:    
    mb.Close();
    return hr;
}

HRESULT
SSL_CONFIG_PROV_SERVER::SendSiteSslConfiguration(
    IN  DWORD dwSiteId
    )
/*++

Routine Description:
    Get all SSL configuration parameters for specified site
    
Arguments:
    dwSiteId
    SiteSslConfiguration

Return Value:

    HRESULT

--*/    
{
    SITE_SSL_CONFIGURATION            SiteSslConfig;
    SSL_CONFIG_PIPE_RESPONSE_HEADER ResponseHeader;
    HRESULT                           hr = E_FAIL;
    MB                                mb( _pAdminBase );
    WCHAR                             achMBSitePath[ 256 ];
    WCHAR                             achMBSiteRootPath[ 256 ];
    DWORD                             dwUseDsMapper = 0;
    DWORD                             cbRequired = 0;
    BOOL                              fRet = FALSE;


    ZeroMemory( &SiteSslConfig, 
                sizeof(SiteSslConfig) );
    //
    // set configuration defaults
    //
    SiteSslConfig._dwRevocationFreshnessTime = 
                        DEFAULT_REVOCATION_FRESHNESS_TIME;
    
    ZeroMemory( &ResponseHeader,
                sizeof( SSL_CONFIG_PIPE_RESPONSE_HEADER ) );

    
    fRet = mb.Open( L"/LM/W3SVC/",
                    METADATA_PERMISSION_READ );
    if ( !fRet )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open metabase.  hr = %x\n",
                    hr ));
        goto SendResponse;
    }

    _snwprintf( achMBSitePath,
                sizeof( achMBSitePath ) / sizeof( WCHAR ) - 1,
                L"/%d/",
                dwSiteId );

    _snwprintf( achMBSiteRootPath,
            sizeof( achMBSiteRootPath ) / sizeof( WCHAR ) - 1,
            L"/%d/root/",
            dwSiteId );

    //
    // Lookup MD_SSL_USE_DS_MAPPER
    // SSLUseDsMapper is global setting that is not inherited to sites (IIS5 legacy)
    // We have to read it from lm/w3svc
    //    

    mb.GetDword( L"",
                 MD_SSL_USE_DS_MAPPER,
                 IIS_MD_UT_SERVER,
                 &dwUseDsMapper );
                 
    SiteSslConfig._fSslUseDsMapper = !!dwUseDsMapper;

    // MD_SSL_ACCESS_PERM
    mb.GetDword( achMBSiteRootPath,
                 MD_SSL_ACCESS_PERM,
                 IIS_MD_UT_FILE,
                 &SiteSslConfig._dwSslAccessPerm );
    // Lookup MD_SSL_CERT_HASH
    SiteSslConfig._cbSslCertHash= 
                sizeof(SiteSslConfig._SslCertHash);
    hr = ReadMetabaseBinary( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_HASH,
                             &SiteSslConfig._cbSslCertHash,
                             SiteSslConfig._SslCertHash );
  
    // MD_SSL_CERT_STORE_NAME
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_STORE_NAME,
                             sizeof(SiteSslConfig._SslCertStoreName),
                             SiteSslConfig._SslCertStoreName );
    // MD_SSL_CERT_CONTAINER
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CERT_CONTAINER,
                             sizeof(SiteSslConfig._SslCertContainer),
                             SiteSslConfig._SslCertContainer );
    // MD_SSL_CERT_PROVIDER
    mb.GetDword( achMBSitePath,
                 MD_SSL_CERT_PROVIDER,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCertProvider );
    // MD_SSL_CERT_OPEN_FLAGS
    mb.GetDword( achMBSitePath,
                 MD_SSL_CERT_OPEN_FLAGS,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCertOpenFlags );
    // MD_CERT_CHECK_MODE
    mb.GetDword( achMBSitePath,
                 MD_CERT_CHECK_MODE,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwCertCheckMode );
    // MD_REVOCATION_FRESHNESS_TIME
    mb.GetDword( achMBSitePath,
                 MD_REVOCATION_FRESHNESS_TIME,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwRevocationFreshnessTime );
    // MD_REVOCATION_URL_RETRIEVAL_TIMEOUT
    mb.GetDword( achMBSitePath,
                 MD_REVOCATION_URL_RETRIEVAL_TIMEOUT,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwRevocationUrlRetrievalTimeout );
    // MD_SSL_CTL_IDENTIFIER
    SiteSslConfig._cbSslCtlIdentifier = 
            sizeof(SiteSslConfig._SslCtlIdentifier);
    hr = ReadMetabaseBinary( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_IDENTIFIER,
                             &SiteSslConfig._cbSslCtlIdentifier,
                             SiteSslConfig._SslCtlIdentifier ); 
    // MD_SSL_CTL_PROVIDER
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_PROVIDER,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlProvider );
    // MD_SSL_CTL_PROVIDER_TYPE
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_PROVIDER_TYPE,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlProviderType );
    // MD_SSL_CTL_OPEN_FLAGS
    mb.GetDword( achMBSitePath,
                 MD_SSL_CTL_OPEN_FLAGS,
                 IIS_MD_UT_SERVER,
                 &SiteSslConfig._dwSslCtlOpenFlags );
    // MD_SSL_CTL_STORE_NAME
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_STORE_NAME,
                             sizeof(SiteSslConfig._SslCtlStoreName),
                             SiteSslConfig._SslCtlStoreName );
    // MD_SSL_CTL_CONTAINER
    hr = ReadMetabaseString( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_CONTAINER,
                             sizeof(SiteSslConfig._SslCtlContainerName),
                             SiteSslConfig._SslCtlContainerName );
    // MD_SSL_CTL_SIGNER_HASH
    SiteSslConfig._cbSslCtlSignerHash =
        sizeof(SiteSslConfig._SslCtlSignerHash);
    hr = ReadMetabaseBinary( &mb,
                             achMBSitePath,
                             MD_SSL_CTL_SIGNER_HASH,
                             &SiteSslConfig._cbSslCtlSignerHash,
                             SiteSslConfig._SslCtlSignerHash ); 
    hr = S_OK;
  SendResponse:

    // 
    // Close metabase handle
    //
    mb.Close();

    //
    // Prepare and send ResponseHeader
    //
    
    ResponseHeader.dwCommandId = CMD_GET_SSL_CONFIGURATION;
    ResponseHeader.dwParameter1 = dwSiteId;
    ResponseHeader.hrErrorCode = hr;
    ResponseHeader.dwResponseSize = sizeof(SiteSslConfig);

    hr = PipeSendResponseHeader( &ResponseHeader );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    // Send Bindings data
    //

    hr = PipeSendData( ResponseHeader.dwResponseSize,
                       reinterpret_cast<BYTE *>(&SiteSslConfig) );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    return S_OK;
}

//static 
HRESULT 
SSL_CONFIG_PROV_SERVER::SiteSslConfigChangeNotifProc(
    VOID
    )
/*++

Routine Description:
    Procedure executed by thread dedicated to listen on named pipe
    that reports parameter change notifications 
Arguments:

Return Value:

    HRESULT

--*/    
{
    return S_OK;
}

//static
HRESULT 
SSL_CONFIG_PROV_SERVER::ReadMetabaseString(
    IN      MB *        pMb,
    IN      WCHAR *     pszPath,
    IN      DWORD       dwPropId,
    IN      DWORD       cchMetabaseString,
    OUT     WCHAR *     pszMetabaseString
    )    
{
    DWORD cbRequired;
    BOOL  fRet = FALSE;
    
    cbRequired = cchMetabaseString;
    
    fRet = pMb->GetData( pszPath,
                         dwPropId,
                         IIS_MD_UT_SERVER,
                         STRING_METADATA,
                         pszMetabaseString,
                         &cbRequired,
                         METADATA_NO_ATTRIBUTES );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
        }
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}

//static
HRESULT 
SSL_CONFIG_PROV_SERVER::ReadMetabaseBinary(
    IN      MB *        pMb,
    IN      WCHAR *     pszPath,
    IN      DWORD       dwPropId,
    IN OUT  DWORD *     pcbMetabaseBinary,
    OUT     BYTE *      pbMetabaseBinary
    )    
{
    BOOL  fRet = FALSE;
    
    fRet = pMb->GetData( pszPath,
                         dwPropId,
                         IIS_MD_UT_SERVER,
                         BINARY_METADATA,
                         pbMetabaseBinary,
                         pcbMetabaseBinary,
                         METADATA_NO_ATTRIBUTES  );
    if ( !fRet )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
        }
        else
        {
            *pcbMetabaseBinary = 0;
        }
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\w3ssl\scmmanager.cxx ===
/*++

   Copyright    (c)    1999    Microsoft Corporation

   Module Name :
     scmmanager.cxx

   Abstract:
     Manage SCM
 
   Author:
     Bilal Alam (balam)             6-June-2000
     
   Environment:
     Win32 - User Mode

   Project:
     W3SSL.DLL
--*/

#include "precomp.hxx"

SCM_MANAGER::~SCM_MANAGER( VOID )
{
    DeleteCriticalSection( &_csSCMLock );
}

HRESULT
SCM_MANAGER::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize SCM_MANAGER 

Arguments:

    pszServiceName - Name of service
    pfnShutdown - Function to call on service shutdown

Return Value:

    HRESULT

--*/
{
    //
    // Open SCM
    //
    
    _hService = RegisterServiceCtrlHandlerEx( _strServiceName.QueryStr(),
                                              GlobalServiceControlHandler,
                                              this );
    if ( _hService == 0 )
    {
        return HRESULT_FROM_WIN32( GetLastError() ); 
    }
    
    //
    // Setup a timer queue for start/stop pending pings
    //
    
    _hTimerQueue = CreateTimerQueue();
    if ( _hTimerQueue == NULL )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    

    //
    // create the event object. The control handler function signals
    // this event when it receives the "stop" control code.
    //
    _hServiceStopEvent = CreateEvent( NULL,    // no security attributes
                                     TRUE,    // manual reset event
                                     FALSE,   // not-signalled
                                     NULL );   // no name


    if ( _hServiceStopEvent == NULL )
    { 
        HRESULT hr = E_FAIL;
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CreateEvent().  hr = %x\n",
                    hr ));
        return hr;
    }
    return NO_ERROR;
}

VOID
SCM_MANAGER::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    if ( _hTimerQueue != NULL )
    {
         DeleteTimerQueueEx( _hTimerQueue,
                             INVALID_HANDLE_VALUE //wait for all callbacks to complete
                          );
        _hTimerQueue = NULL;
    }

    if ( _hServiceStopEvent != NULL )
    {
        CloseHandle( _hServiceStopEvent );
        _hServiceStopEvent = NULL;
    }
}

HRESULT
SCM_MANAGER::IndicatePending(
    DWORD                dwPendingState
)
/*++

Routine Description:

    Indicate (peridically) that we starting/stopping

Arguments:

    dwPendingState - One of 2 values: SERVICE_START_PENDING, SERVICE_STOP_PENDING 

Return Value:

    HRESULT

--*/
{
    BOOL                fRet;
    HKEY                hKey;
    DWORD               dwError = NO_ERROR;
    
    DBG_ASSERT( _hTimerQueue != NULL );
    DBG_ASSERT( _hTimer == NULL );

    DWORD dwWaitHint = W3SSL_SERVICE_STARTUP_WAIT_HINT;

    if ( dwPendingState != SERVICE_START_PENDING && 
         dwPendingState != SERVICE_STOP_PENDING )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    if ( dwPendingState == SERVICE_START_PENDING )
    {
        //
        // set default value
        //
        
        dwWaitHint = W3SSL_SERVICE_STARTUP_WAIT_HINT;
        
        //
        // read wait hint from registry
        //
    
        dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                REGISTRY_KEY_W3SSL_PARAMETERS_W,
                                0,
                                KEY_READ,
                                &hKey );
        if ( dwError == NO_ERROR )
        {
            DWORD dwValue = 0;
            DWORD dwType = 0;
            DWORD cbData = 0;
            DBG_ASSERT( hKey != NULL );
    
        
            cbData = sizeof( dwValue );
            dwError = RegQueryValueEx( hKey,
                                       REGISTRY_VALUE_W3SSL_STARTUP_WAIT_HINT,
                                       NULL,
                                       &dwType,
                                       (LPBYTE) &dwValue,
                                       &cbData );
            if ( dwError == NO_ERROR && dwType == REG_DWORD )
            {
                dwWaitHint = dwValue;
            }
            RegCloseKey( hKey );
        }
    }
    else if ( dwPendingState == SERVICE_STOP_PENDING )
    {
        dwWaitHint = W3SSL_SERVICE_STATE_CHANGE_WAIT_HINT;
    }
    else
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }

    EnterCriticalSection( &_csSCMLock );
    if( _serviceStatus.dwCurrentState == dwPendingState )
    {
        //
        // if last reported status is the same as the one to report now
        // then increment the checkpoint
        //
        _serviceStatus.dwCheckPoint ++;
    }
    else
    {
        _serviceStatus.dwCheckPoint = 1;
    }

    _serviceStatus.dwCurrentState = dwPendingState;
    _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
    _serviceStatus.dwWin32ExitCode = NO_ERROR;
    _serviceStatus.dwWaitHint = dwWaitHint;
    
    SetServiceStatus( _hService, 
                      &_serviceStatus );
    
    LeaveCriticalSection( &_csSCMLock );    
    
    if ( dwPendingState == SERVICE_STOP_PENDING )
    {
        //
        // Use timer to update Service State only when stopping
        //
        
        fRet = CreateTimerQueueTimer( &_hTimer,
                                      _hTimerQueue,
                                      PingCallback,
                                      this,
                                      W3SSL_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                      W3SSL_SERVICE_STATE_CHANGE_TIMER_PERIOD,
                                      0 );
        if ( !fRet )
        {
            return HRESULT_FROM_WIN32( GetLastError() );
        }
    }
    return NO_ERROR;
}

HRESULT
SCM_MANAGER::IndicateComplete(
    DWORD                   dwState,
    HRESULT                 hrErrorToReport
)
/*++

Routine Description:

    Indicate the service has started/stopped 
    This means stopping the periodic ping (if any)

Arguments:
    dwState      - new service state
    dwWin32Error - Win32 Error to report to SCM with completion

Return Value:

    HRESULT

--*/
{
    HRESULT     hr = E_FAIL;
    
    if ( dwState != SERVICE_RUNNING && 
         dwState != SERVICE_STOPPED  )
    {
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( _hTimer != NULL )
    {
        DBG_ASSERT( _hTimerQueue != NULL );
    
        DeleteTimerQueueTimer( _hTimerQueue,
                               _hTimer,
                               INVALID_HANDLE_VALUE 
                               // wait for completion of all callbacks
                               );
        
        _hTimer = NULL;
    }
    
    EnterCriticalSection( &_csSCMLock );
    
    _serviceStatus.dwCurrentState = dwState;
    _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
    _serviceStatus.dwWin32ExitCode = ( FAILED( hrErrorToReport ) ? 
                                        WIN32_FROM_HRESULT( hrErrorToReport ) : 
                                        NO_ERROR );
    _serviceStatus.dwCheckPoint = 0;
    _serviceStatus.dwWaitHint = 0;
    
    if ( _serviceStatus.dwCurrentState == SERVICE_RUNNING )
    {
        _serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                            SERVICE_ACCEPT_PAUSE_CONTINUE |
                                            SERVICE_ACCEPT_SHUTDOWN;
    }
    
    DBG_ASSERT( _hService != NULL );
   
    if ( SetServiceStatus( _hService,
                           &_serviceStatus ) )
    {
        hr = S_OK;
    }
    else
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Address = %x\n",
                    &_serviceStatus ));
        hr = HRESULT_FROM_WIN32( GetLastError() );
    }
    
    LeaveCriticalSection( &_csSCMLock );
    
    return hr;
    
}

DWORD
SCM_MANAGER::ControlHandler(
    DWORD                   dwControlCode
)
/*++

Routine Description:

    Handle SCM command

Arguments:

    dwControlCode - SCM command

Return Value:

    None

--*/
{
    switch( dwControlCode )
    {
    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:
        
        EnterCriticalSection( &_csSCMLock );

        if( _serviceStatus.dwCurrentState == SERVICE_STOP_PENDING )
        {
            // if last reported state was STOP_PENDING
            // then increment checkpoint
            _serviceStatus.dwCheckPoint ++;
        }
        else
        {
            _serviceStatus.dwCheckPoint = 1;
        }
        _serviceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        _serviceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;                                                                       
        _serviceStatus.dwWin32ExitCode = NO_ERROR;

        _serviceStatus.dwWaitHint = W3SSL_SERVICE_STATE_CHANGE_WAIT_HINT;

        SetServiceStatus( _hService, &_serviceStatus );
        
        LeaveCriticalSection( &_csSCMLock );
        
        //
        // Initiate shutdown
        //
        if ( _hServiceStopEvent != NULL )
        {
            SetEvent( _hServiceStopEvent );
        }
        break;
    
    case SERVICE_CONTROL_INTERROGATE:
        UpdateServiceStatus();
        break;
        
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
        UpdateServiceStatus();
        break;
    
    default:
        break;
    }

    return NO_ERROR;
}


HRESULT SCM_MANAGER::RunService(
    VOID
)
/*++

Routine Description:

    Executes the service (initialize, startup, stopping, reporting to SCM

    SERVICE implementation class that inherits from SCM_MANAGER 
    must implement OnStart() and OnStop()

Arguments:

    VOID

Return Value:

    None

--*/
{
    HRESULT     hr= E_FAIL;
    DWORD       dwRet = 0;
    
    hr = Initialize();
    if ( FAILED ( hr ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in SCM_MANAGER::Initialize().  hr = %x\n",
                    hr ));
        goto Finished;
    }
  
    hr = IndicatePending( SERVICE_START_PENDING );

    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in SCM_MANAGER::IndicatePending().  hr = %x\n",
                    hr ));
        goto Finished;
    }

    hr = OnServiceStart();
    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in OnStart().  hr = %x\n",
                    hr ));
        goto Finished;
    }

    hr = IndicateComplete( SERVICE_RUNNING );

    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in SCM_MANAGER::IndicateComplete().  hr = %x\n",
                    hr ));
        
        goto Finished;
    }

    //
    // Wait till service stop is requested
    //
    dwRet = WaitForSingleObject( _hServiceStopEvent, INFINITE );

    DBG_ASSERT( dwRet == WAIT_OBJECT_0 );

    //
    // Indicate stop pending
    //
        
    hr = IndicatePending( SERVICE_STOP_PENDING );
    if ( FAILED( hr ) )
    {
         DBGPRINTF(( DBG_CONTEXT,
                     "Error in IndicatePending().  hr = %x\n",
                     hr ));
         goto Finished;
    }

    hr = OnServiceStop();
    if ( FAILED ( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in OnStop().  hr = %x\n",
                    hr ));
        goto Finished;
    }

    hr = S_OK;
    
Finished:
    
    //
    // Error means that we must report SCM that service is stopping
    // SCM will be notified of error that occured
    // Note: even though IndicateComplete received HRESULT for error
    // SCM accepts only Win32 errors and it truncates the upper word 
    // of HRESULT errors sent to it. Hence IndicateComplete
    // calls WIN32_FROM_HRESULT to convert hr, but that may mean
    // loss of error
    //
    hr = IndicateComplete( SERVICE_STOPPED,
                      hr );
    
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                "Error in IndicateComplete().  hr = %x\n",
                hr ));
    }
    
    Terminate();
    return hr;
}

//static
DWORD
WINAPI
SCM_MANAGER::GlobalServiceControlHandler(
    DWORD               dwControl,
    DWORD               /*dwEventType*/,
    LPVOID              /*pEventData*/,
    LPVOID              pServiceContext
)
/*++

Routine Description:

    SCM callback passed to RegisterServiceCtrlHandlerEx
    
Arguments:

    for details see LPHANDLER_FUNCTION_EX in MSDN

Return Value:

    DWORD - we always return success

--*/

{
    SCM_MANAGER *  pManager = reinterpret_cast<SCM_MANAGER*>(pServiceContext);
        
    DBG_ASSERT( pManager != NULL );

    return pManager->ControlHandler( dwControl );
    
}

//static
VOID
WINAPI
SCM_MANAGER::PingCallback(
    VOID *              pvContext,
    BOOLEAN             /*fUnused*/
)
/*++

Routine Description:

    Timer callbacks used to update service pending status checkpoints
    
Arguments:

    for details see WAITFORTIMERCALLBACK in MSDN

Return Value:

    None

--*/
{
    SCM_MANAGER *       pManager = reinterpret_cast<SCM_MANAGER*>(pvContext);
        
    DBG_ASSERT( pManager != NULL );

    pManager->UpdateServiceStatus( TRUE /*fUpdateCheckpoint*/ );
}

VOID
SCM_MANAGER::UpdateServiceStatus(
    BOOL    fUpdateCheckpoint
) 
/*++

Routine Description:

    Resend the last serviceStatus
    
Arguments:

Return Value:

    None

--*/

{
    DBG_ASSERT( _hService != 0 );

    EnterCriticalSection( &_csSCMLock ); 
    if( fUpdateCheckpoint )
    {
        _serviceStatus.dwCheckPoint ++;
    }
    SetServiceStatus( _hService, 
                      &_serviceStatus ); 
    LeaveCriticalSection( &_csSCMLock ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\tokencache\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_DIRMON               0x00010000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ssinc\ssinc.cxx ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ssinc.cxx

Abstract:

    This module contains the server side include processing code.  We 
    aim for support as specified by iis\spec\ssi.doc.  The code is based 
    on existing SSI support done in iis\svcs\w3\server\ssinc.cxx.

Author:

    Ming Lu (MingLu)            10-Apr-2000

--*/

#include "precomp.hxx"

//
// Globals
//

UINT g_MonthToDayCount[] = {
    0,
    31,
    31 + 28,
    31 + 28 + 31,
    31 + 28 + 31 + 30,
    31 + 28 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31,
    31 + 28 + 31 + 30 + 31 + 30 + 31 + 31 + 30 + 31 + 30,
} ;

//
//  Prototypes
//

extern "C" {

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    );
}

class SSI_ELEMENT_LIST;


VOID
InitializeSSIGlobals( VOID );

//
//  Global Data
//

DECLARE_DEBUG_PRINTS_OBJECT()
DECLARE_DEBUG_VARIABLE();

//
//  This is the list of supported commands
//

struct _SSI_CMD_MAP
{
    CHAR *       pszCommand;
    DWORD        cchCommand;
    SSI_COMMANDS ssiCmd;
}
SSICmdMap[] =
{
    "#include ",  9,  SSI_CMD_INCLUDE,
    "#echo ",     6,  SSI_CMD_ECHO,
    "#fsize ",    7,  SSI_CMD_FSIZE,
    "#flastmod ",10,  SSI_CMD_FLASTMOD,
    "#config ",   8,  SSI_CMD_CONFIG,
    "#exec ",     6,  SSI_CMD_EXEC,
    NULL,         0,  SSI_CMD_UNKNOWN
};

//
//  This is the list of supported tags
//

struct _SSI_TAG_MAP
{
    CHAR *    pszTag;
    DWORD     cchTag;
    SSI_TAGS  ssiTag;
}
SSITagMap[] =
{
    "var",      3,  SSI_TAG_VAR,
    "file",     4,  SSI_TAG_FILE,
    "virtual",  7,  SSI_TAG_VIRTUAL,
    "errmsg",   6,  SSI_TAG_ERRMSG,
    "timefmt",  7,  SSI_TAG_TIMEFMT,
    "sizefmt",  7,  SSI_TAG_SIZEFMT,
    "cmd",      3,  SSI_TAG_CMD,
    "cgi",      3,  SSI_TAG_CGI,
    "isa",      3,  SSI_TAG_ISA,
    NULL,       0,  SSI_TAG_UNKNOWN
};

//
//   This is a list of #ECHO variables not supported by ISAPI
//

struct _SSI_VAR_MAP
{
    CHAR *      pszMap;
    DWORD       cchMap;
    SSI_VARS    ssiMap;
}
SSIVarMap[] =
{
    "DOCUMENT_NAME",            13, SSI_VAR_DOCUMENT_NAME,
    "DOCUMENT_URI",             12, SSI_VAR_DOCUMENT_URI,
    "QUERY_STRING_UNESCAPED",   22, SSI_VAR_QUERY_STRING_UNESCAPED,
    "DATE_LOCAL",               10, SSI_VAR_DATE_LOCAL,
    "DATE_GMT",                 8,  SSI_VAR_DATE_GMT,
    "LAST_MODIFIED",            13, SSI_VAR_LAST_MODIFIED,
    NULL,                       0,  SSI_VAR_UNKNOWN
};

//
// #EXEC CMD is BAD.  Disable it by default
//

BOOL fEnableCmdDirective = FALSE;

//
// Pointer to file cache
//

W3_FILE_INFO_CACHE *    g_pFileCache = NULL;

//
// Class Definitions
//

// class SSI_FILE
//
// File structure.  All high level functions should use this
// structure instead of dealing with handle specifics themselves.

class SSI_FILE
{
private:
    STRU                            _strFilename;
    W3_FILE_INFO *                  _hHandle;
    HANDLE                          _hMapHandle;
    PVOID                           _pvMappedBase;
    BOOL                            _fValid;
    BOOL                            _fCloseOnDestroy;

    //
    //  Track the current number of open handles for this file.
    //

    DWORD                           _cRefCount;
    CRITICAL_SECTION                _csRef;

public:

    SSI_FILE( 
        IN STRU *                 pstrFilename,
        IN W3_FILE_INFO *         pOpenFile
        ) : _hHandle      ( pOpenFile ),
            _hMapHandle   ( NULL ),
            _pvMappedBase ( NULL ),
            _fValid       ( FALSE ),
            _cRefCount    ( 0),
            _fCloseOnDestroy( FALSE )
    {
        InitializeCriticalSection( &_csRef );
       
        if ( FAILED( _strFilename.Copy( pstrFilename->QueryStr() ) ) )
        {
            return;
        } 
        _fValid = TRUE;
    }
    
    SSI_FILE( 
        IN STRU *           pstrFilename,
        IN HANDLE           hUser
        ) : _hHandle      ( NULL ),
            _hMapHandle   ( NULL ),
            _pvMappedBase ( NULL ),
            _fValid       ( FALSE ),
            _cRefCount    ( 0),
            _fCloseOnDestroy( TRUE )
    {
        FILE_CACHE_USER         fileUser;
        HRESULT                 hr;
        
        InitializeCriticalSection( &_csRef );
       
        if ( FAILED( _strFilename.Copy( pstrFilename->QueryStr() ) ) )
        {
            return;
        }
        
        fileUser._hToken = hUser; 
       
        hr = g_pFileCache->GetFileInfo( _strFilename,
                                        NULL,
                                        &fileUser,
                                        TRUE,
                                        &_hHandle );
        if ( FAILED( hr ) )
        {
            return;
        }

        _fValid = TRUE;
    }

    ~SSI_FILE()
    {
        if ( _fCloseOnDestroy )
        {
            if ( _hHandle )
            {
                _hHandle->DereferenceCacheEntry();
            }
        }
        DeleteCriticalSection( &_csRef );
    }
    
    VOID 
    Lock( 
        VOID 
        )
    { 
        EnterCriticalSection( &_csRef ); 
    }

    VOID 
    UnLock( 
        VOID 
        )
    { 
        LeaveCriticalSection( &_csRef ); 
    }
    
    BOOL 
    IsValid( 
        VOID 
        ) const
    {
        return _fValid;
    }

    PSECURITY_DESCRIPTOR 
    GetSecDesc(
        VOID
        ) const
    {
        return _hHandle->QuerySecDesc();
    }

    BOOL 
    SSICreateFileMapping( 
        VOID 
        )
    /*++

      Creates a mapping to a file

    --*/
    {
        HANDLE              hHandle;

        if ( _hHandle->QueryFileBuffer() )
        {
            return TRUE;
        }
        
        hHandle = _hHandle->QueryFileHandle();
        if ( _hMapHandle != NULL )
        {
            if ( !SSICloseMapHandle() )
            {
                return FALSE;
            }
        }
        _hMapHandle = ::CreateFileMapping( hHandle,
                                           NULL,
                                           PAGE_READONLY,
                                           0,
                                           0,
                                           NULL );

        if ( _hMapHandle == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "CreateFileMapping failed with %d\n",
                        GetLastError() ));
        }

        return _hMapHandle != NULL;
    }

    BOOL 
    SSICloseMapHandle( 
        VOID 
        )
    /*++

      Closes mapping to a file

    --*/
    {
        if ( _hMapHandle != NULL )
        {
            ::CloseHandle( _hMapHandle );
            _hMapHandle = NULL;
        }
        return TRUE;
    }

    BOOL 
    SSIMapViewOfFile( 
        VOID 
        )
    /*++

     Maps file to address

    --*/
    {
        if ( _hHandle->QueryFileBuffer() )
        {
            _pvMappedBase = _hHandle->QueryFileBuffer();
            return TRUE;
        }
        
        if ( _pvMappedBase != NULL )
        {
            if ( !SSIUnmapViewOfFile() )
            {
                return FALSE;
            }
        }
        _pvMappedBase = ::MapViewOfFile( _hMapHandle,
                                         FILE_MAP_READ,
                                         0,
                                         0,
                                         0 );
        if ( _pvMappedBase == NULL )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "MapViewOfFile() failed with %d\n",
                        GetLastError() ));
        }
        return _pvMappedBase != NULL;
    }

    BOOL 
    SSIUnmapViewOfFile( 
        VOID 
        )
    /*++

     Unmaps file

    --*/
    {
        if ( !_hHandle->QueryFileBuffer() && _pvMappedBase != NULL )
        {
            ::UnmapViewOfFile( _pvMappedBase );
            _pvMappedBase = NULL;
        }
        return TRUE;
    }

    DWORD 
    SSIGetFileAttributes( 
        VOID 
        )
    /*++

     Gets the attributes of a file

    --*/
    {
        return _hHandle->QueryAttributes();
    }

    BOOL 
    SSIGetFileSize( 
        OUT DWORD *   pdwLowWord,
        OUT DWORD *   pdwHighWord 
        )
    /*++

     Gets the size of the file.

    --*/
    {
        LARGE_INTEGER           liSize;
        
        _hHandle->QuerySize( &liSize );
        
        *pdwLowWord = liSize.LowPart;
        *pdwHighWord = liSize.HighPart;
        
        return TRUE;
    }

    BOOL 
    SSIGetLastModTime( 
        OUT FILETIME * ftTime 
        )
    /*++

     Gets the Last modification time of a file.

    --*/
    {
        _hHandle->QueryLastWriteTime( ftTime );
        return TRUE;
    }

    PVOID 
    GetMappedBase( 
        VOID 
        )
    {
        return _pvMappedBase;
    }

    STRU & 
    GetFilename( 
        VOID 
        )
    {
        return _strFilename;
    }
};

// Class SSI_ELEMENT_ITEM
//
// Represents a SSI command or block of static text in the document

class SSI_ELEMENT_ITEM
{
private:
    DWORD               _Signature;
    SSI_COMMANDS        _ssiCmd;
    SSI_TAGS            _ssiTag;
    STRA *              _pstrTagValue;

    DWORD               _cbBegin;   // Only used for Byte range command
    DWORD               _cbLength;  // Only used for Byte range command
public:

    LIST_ENTRY          _ListEntry;

    SSI_ELEMENT_ITEM( VOID )
        : _ssiCmd   ( SSI_CMD_UNKNOWN ),
          _ssiTag   ( SSI_TAG_UNKNOWN ),
          _Signature( SIGNATURE_SEI ),
          _pstrTagValue( NULL )
    {
        _ListEntry.Flink = NULL;
    }

    ~SSI_ELEMENT_ITEM()
    {
        if ( _pstrTagValue != NULL )
        {
            delete _pstrTagValue;
        }

        DBG_ASSERT( _ListEntry.Flink == NULL );

        _Signature = SIGNATURE_SEI_FREE;
    }

    VOID 
    SetByteRange( 
        IN DWORD cbBegin,
        IN DWORD cbLength 
        )
    {
        _ssiCmd   = SSI_CMD_BYTERANGE;
        _cbBegin  = cbBegin;
        _cbLength = cbLength;
    }

    BOOL 
    SetCommand( 
        IN SSI_COMMANDS ssiCmd,
        IN SSI_TAGS     ssiTag,
        IN CHAR *       achTag 
        )
    {
        _ssiCmd = ssiCmd;
        _ssiTag = ssiTag;
        
        _pstrTagValue = new STRA();
        if( _pstrTagValue == NULL )
        {
            return FALSE;
        }

        if( FAILED( _pstrTagValue->Copy( achTag ) ) )
        {
            return FALSE;
        }

        return TRUE;
    }

    SSI_COMMANDS 
    QueryCommand( 
        VOID 
        ) const
    { 
        return _ssiCmd; 
    }

    SSI_TAGS 
    QueryTag( 
        VOID 
        ) const
    { 
        return _ssiTag; 
    }

    STRA * 
    QueryTagValue( 
        VOID 
        ) const
    { 
        return _pstrTagValue; 
    }

    BOOL 
    CheckSignature( 
        VOID 
        ) const
    { 
        return _Signature == SIGNATURE_SEI; 
    }

    DWORD 
    QueryBegin( 
        VOID 
        ) const
    { 
        return _cbBegin; 
    }

    DWORD 
    QueryLength( 
        VOID 
        ) const
    { 
        return _cbLength; 
    }
};

//  Class SSI_ELEMENT_LIST
//
//  This object sits as a cache blob under a file to be processed as a
//  server side include.  It represents an interpreted list of data 
//  elements that make up the file itself.
//

class SSI_ELEMENT_LIST : public ASSOCIATED_FILE_OBJECT
{
    
private:
    DWORD               _Signature;
    LIST_ENTRY          _ListHead;

    //
    //  These are for tracking the memory mapped file
    //

    DWORD               _cRefCount;
    CRITICAL_SECTION    _csRef;

    //
    //  Provides the utilities needed to open/manipulate files
    //

    SSI_FILE *          _pssiFile;

    //
    //  Name of URL.  Used to resolve FILE="xxx" filenames
    //

    STRU                _strURL;


public:
    SSI_ELEMENT_LIST()
      : _Signature   ( SIGNATURE_SEL ),
        _pssiFile( NULL ),
        _cRefCount( 0 )
    {
        InitializeListHead( &_ListHead );
        INITIALIZE_CRITICAL_SECTION( &_csRef );
    }

    ~SSI_ELEMENT_LIST()
    {
        SSI_ELEMENT_ITEM * pSEI;

        while ( !IsListEmpty( &_ListHead ))
        {
            pSEI = CONTAINING_RECORD( _ListHead.Flink,
                                      SSI_ELEMENT_ITEM,
                                      _ListEntry );

            RemoveEntryList( &pSEI->_ListEntry );
            pSEI->_ListEntry.Flink = NULL;
            delete pSEI;
        }
        UnMap();

        if( _pssiFile != NULL )
        {
            delete _pssiFile;
        }

        DeleteCriticalSection( &_csRef );
        _Signature = SIGNATURE_SEL_FREE;
    }
    
    VOID
    Cleanup(
        VOID
    )
    {
        delete this;
    } 

    LIST_ENTRY *
    QueryListHead( 
        VOID
        )
    {
        return &_ListHead;
    };

    BOOL 
    AppendByteRange( 
        IN DWORD  cbStart,
        IN DWORD  cbLength 
        )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        pSEI->SetByteRange( cbStart,
                            cbLength );
        AppendItem( pSEI );

        return TRUE;
    }

    BOOL 
    AppendCommand( 
        IN SSI_COMMANDS  ssiCmd,
        IN SSI_TAGS      ssiTag,
        IN CHAR *        pszTag 
        )
    {
        SSI_ELEMENT_ITEM * pSEI;

        pSEI = new SSI_ELEMENT_ITEM;

        if ( !pSEI )
        {
            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            return FALSE;
        }

        if ( !pSEI->SetCommand( ssiCmd,
                                ssiTag,
                                pszTag ))
        {
            return FALSE;
        }

        AppendItem( pSEI );

        return TRUE;
    }

    VOID 
    AppendItem( 
        IN SSI_ELEMENT_ITEM * pSEI 
        )
    {
        InsertTailList( &_ListHead,
                        &pSEI->_ListEntry );
    }

    CHAR * QueryData( 
        VOID 
        ) const
    { 
        return ( CHAR * ) _pssiFile->GetMappedBase(); 
    }

    PSECURITY_DESCRIPTOR 
    QuerySecDesc( 
        VOID 
        )
    { 
        return _pssiFile->GetSecDesc(); 
    }

    BOOL 
    CheckSignature( 
        VOID 
        ) const
    { 
        return _Signature == SIGNATURE_SEL; 
    }

    VOID 
    Lock( 
        VOID 
        )
    { 
        EnterCriticalSection( &_csRef ); 
    }

    VOID 
    UnLock( 
        VOID 
        )
    { 
        LeaveCriticalSection( &_csRef ); 
    }

    BOOL 
    UnMap( 
        VOID 
        )
    {
        Lock();
        if ( _cRefCount && !--_cRefCount )
        {
            DBG_REQUIRE( _pssiFile->SSIUnmapViewOfFile() );
            DBG_REQUIRE( _pssiFile->SSICloseMapHandle() );
        }
        UnLock();
        return TRUE;
    }

    BOOL 
    Map( 
        VOID 
        )
    {
        Lock();
        if ( _cRefCount++ == 0 )
        {
            if ( !_pssiFile->SSICreateFileMapping() )
            {
                UnLock();
                return FALSE;
            }
            if ( !_pssiFile->SSIMapViewOfFile() )
            {
                UnMap();
                UnLock();
                return FALSE;
            }
        }
        UnLock();
        return TRUE;
    }

    VOID 
    SetFile( 
        IN SSI_FILE * pssiFile 
        )
    { 
        _pssiFile = pssiFile; 
    }

    SSI_FILE * 
    GetFile( 
        VOID 
        )
    { 
        return _pssiFile; 
    }

    HRESULT 
    SetURL( 
        IN STRU * pstrURL 
        )
    {
        return _strURL.Copy( pstrURL->QueryStr() );
    }


    static
    BOOL
    SSIFreeContextRoutine( 
        VOID *              pvContext
    )
    {
        DBG_ASSERT( ( ( SSI_ELEMENT_LIST * ) pvContext) -> CheckSignature() ); 

        delete ( SSI_ELEMENT_LIST * ) pvContext;
        return TRUE;
    }
};

//
// SSI_REQUEST methods implementation
//

//static 
ALLOC_CACHE_HANDLER * SSI_REQUEST::sm_pachSSIRequests = NULL;

SSI_REQUEST::SSI_REQUEST( EXTENSION_CONTROL_BLOCK * pECB )
    : _pECB( pECB ),
      _fBaseFile( TRUE ),
      _fValid( FALSE ),
      _pchErrorBuff ( NULL )
/*++

Routine Description:

    Constructor

--*/

{
    DBG_ASSERT( _pECB != NULL );
    STACK_BUFFER (buffTemp, 512);
    DWORD cbSize = buffTemp.QuerySize();

    if (!_pECB->GetServerVariable(_pECB->ConnID,
                                  "UNICODE_URL",
                                  buffTemp.QueryPtr(),
                                  &cbSize))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
            !buffTemp.Resize(cbSize))
        {
            return;
        }

        //
        // Now, we should have enough buffer, try again
        //
        if (!_pECB->GetServerVariable(_pECB->ConnID,
                                      "UNICODE_URL",
                                      buffTemp.QueryPtr(),
                                      &cbSize))
        {
            return;
        }
    }
    if (FAILED(_strURL.Copy( (LPWSTR)buffTemp.QueryPtr() )))
    {
        return;
    }

    cbSize = buffTemp.QuerySize();
    if (!_pECB->GetServerVariable(_pECB->ConnID,
                                  "UNICODE_SCRIPT_TRANSLATED",
                                  buffTemp.QueryPtr(),
                                  &cbSize))
    {
        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER ||
            !buffTemp.Resize(cbSize))
        {
            return;
        }

        //
        // Now, we should have enough buffer, try again
        //
        if (!_pECB->GetServerVariable(_pECB->ConnID,
                                      "UNICODE_SCRIPT_TRANSLATED",
                                      buffTemp.QueryPtr(),
                                      &cbSize))
        {
            return;
        }
    }
    if (FAILED(_strFilename.Copy( (LPWSTR)buffTemp.QueryPtr() )))
    {
        return;
    }

    if ( !_pECB->ServerSupportFunction( 
                              _pECB->ConnID,
                              HSE_REQ_GET_IMPERSONATION_TOKEN,
                              &_hUser,
                              NULL,
                              NULL ) )
    {
        return;
    }

    _pSIF = new SSI_INCLUDE_FILE ( this, _strFilename, _strURL, NULL );

   
    if ( _pSIF == NULL || !_pSIF->IsValid() ) 
    {
        return;
    }

    if( !_IOBuffer.Resize(MAX_PATH) )
    {
        return;
    }   
    
    if( FAILED( _IOString.Resize(MAX_PATH) ) )
    {
        return;
    }   


    _fValid = TRUE;
}

SSI_REQUEST::~SSI_REQUEST()
/*++

Routine Description:

    Destructor

--*/

{
    
    if ( _pSIF != NULL )
    {
        //
        // There should be no nested stm files
        // State Machine was supposed to complete and cleanup child SSI_INCLUDE_FILES 
        // (also in the case of error)
        //

        DBG_ASSERT( _pSIF->GetParent() == NULL );
        delete _pSIF;
    }

    if ( _pchErrorBuff != NULL )
    {
        ::LocalFree( ( VOID * )_pchErrorBuff );
    }

}

HRESULT
SSI_REQUEST::SSISendError(
    IN DWORD            dwMessageID,
    IN LPSTR            apszParms[] 
)
/*++

Routine Description:

    Send an SSI error

Arguments:

    dwMessageId - Message ID
    apszParms - Array of parameters

Return Value:

    HRESULT (if couldn't find a custom error, this will fail)

--*/
{
    DWORD           cbSent;

    if ( *( ( CHAR * )_strUserMessage.QueryStr() ) != '\0'  )
    {
        //
        // user specified message with #CONFIG ERRMSG=
        //
    
        return WriteToClient( _strUserMessage.QueryStr(),
                              _strUserMessage.QueryCCH(),
                              &cbSent );
    }
    else
    {
        DWORD            cch;
        HRESULT          hr = E_FAIL;
        CHAR             chTemp1 = '\0';
        CHAR             chTemp2 = '\0';

        if( _pchErrorBuff )
        {
            ::LocalFree( ( VOID * )_pchErrorBuff );
            _pchErrorBuff = NULL;
        }
        
        //
        // Lame.  I need to validate the parameters for being <1024 
        // otherwise FormatMessage uses SEH to determine when to resize and
        // this will cause debuggers to break on the 1st change exception
        //
        
        if ( apszParms[ 0 ] != NULL &&
             strlen( apszParms[ 0 ] ) > SSI_MAX_FORMAT_LEN )
        {
            chTemp1 = apszParms[ 0 ][ SSI_MAX_FORMAT_LEN ];
            apszParms[ 0 ][ SSI_MAX_FORMAT_LEN ] = '\0';
        }
        
        if ( apszParms[ 1 ] != NULL &&
             strlen( apszParms[ 1 ] ) > SSI_MAX_FORMAT_LEN )
        {
            chTemp2 = apszParms[ 1 ][ SSI_MAX_FORMAT_LEN ];
            apszParms[ 1 ][ SSI_MAX_FORMAT_LEN ] = '\0';
        }

        cch = ::FormatMessageA( FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                GetModuleHandle( SSI_DLL_NAME ),
                                dwMessageID,
                                0,
                                ( LPSTR ) &_pchErrorBuff,
                                0,
                                ( va_list *) apszParms );

        if ( chTemp1 != '\0' )
        {
            apszParms[ 0 ][ SSI_MAX_FORMAT_LEN ] = chTemp1;
        }
        
        if ( chTemp2 != '\0' )
        {
            apszParms[ 1 ][ SSI_MAX_FORMAT_LEN ] = chTemp2;
        }

        if( cch != 0 )
        {
            //
            // WriteToClient will execute asynchronously so do not
            // free _pchErrorBuffer before I/O completion
            //
                
            hr = WriteToClient( _pchErrorBuff,
                                cch,
                                &cbSent );
            return hr;
        }
        else
        {
            return HRESULT_FROM_WIN32(GetLastError());        
        }
    }
}

HRESULT
SSI_REQUEST::SendCustomError(
    HSE_CUSTOM_ERROR_INFO * pCustomErrorInfo
)
/*++

Routine Description:

    Try to have IIS send custom error on our behalf

Arguments:

    pCustomErrorInfo - Describes custom error

Return Value:

    HRESULT (if couldn't find a custom error, this will fail)

--*/
{
    BOOL                    fRet;
    
    fRet = _pECB->ServerSupportFunction( _pECB->ConnID,
                                         HSE_REQ_SEND_CUSTOM_ERROR,
                                         pCustomErrorInfo,
                                         NULL,
                                         NULL );
    if ( !fRet )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return NO_ERROR; 
    }
}

HRESULT
SSI_REQUEST::DoFLastMod(
    IN STRU *               pstrFilename,
    IN STRA *               pstrTimeFmt,
    IN SSI_ELEMENT_LIST *   pList
)
/*++

Routine Description:

    Send the LastModTime of file to HTML stream

Arguments:

    pstrFilename - Filename
    pstrTimeFmt - Format of time -> follows strftime() convention

Return Value:

    HRESULT

--*/
{
    FILETIME        ftTime;
    FILETIME        ftLocalTime;
    SYSTEMTIME      sysLocal;

    if ( ( NULL == pList ) || 
         wcscmp( pstrFilename->QueryStr(), 
                 ( pList->GetFile()->GetFilename().QueryStr() ) ) )
    {
        SSI_FILE ssiFile( pstrFilename, GetUserToken() );

        if ( !ssiFile.IsValid() ||
            ( !ssiFile.SSIGetLastModTime( &ftTime ))
           )
        {
            return E_FAIL;
        }
    }
    else
    {
        pList->GetFile()->SSIGetLastModTime( &ftTime );
    }

    if ( ( !FileTimeToLocalFileTime( &ftTime, &ftLocalTime ) ) ||
        ( !FileTimeToSystemTime( &ftLocalTime, &sysLocal ) ) )
    {
        return E_FAIL;
    }

    return SendDate( &sysLocal,
                     pstrTimeFmt );
}

HRESULT
SSI_REQUEST::SendDate(
    IN SYSTEMTIME *         psysTime,
    IN STRA *               pstrTimeFmt
)
/*++

Routine Description:

    Sends a SYSTEMTIME in appropriate format to HTML stream

Arguments:

    psysTime - SYSTEMTIME containing time to send
    pstrTimeFmt - Format of time (follows strftime() convention)
    fCalcDays - TRUE if days since the beginning of the year should be
        calculated

Return Value:

    HRESULT

--*/
{
    struct tm                   tm;
    
    // Convert SYSTEMTIME to 'struct tm'

    tm.tm_sec = psysTime->wSecond;
    tm.tm_min = psysTime->wMinute;
    tm.tm_hour = psysTime->wHour;
    tm.tm_mday = psysTime->wDay;
    tm.tm_mon = psysTime->wMonth - 1;
    tm.tm_year = psysTime->wYear - 1900;
    tm.tm_wday = psysTime->wDayOfWeek;
    tm.tm_yday = g_MonthToDayCount[ tm.tm_mon ] + tm.tm_mday - 1;

    //
    // Adjust for leap year - note that we do not handle 2100
    //

    if ( ( tm.tm_mon ) > 1 && !( psysTime->wYear & 3 ) )
    {
        ++tm.tm_yday;
    }

    tm.tm_isdst = -1;   // Daylight savings time flag - have crt compute

    _cbTimeBufferLen = strftime( _achTimeBuffer,
                         SSI_MAX_TIME_SIZE + 1,
                         ( CHAR * )pstrTimeFmt->QueryStr(),
                         &tm );

    if ( _cbTimeBufferLen == 0 )
    {
        return E_FAIL;
    }

    return WriteToClient( _achTimeBuffer,
                          _cbTimeBufferLen,
                          &_cbTimeBufferLen );
}

HRESULT
SSI_REQUEST::LookupVirtualRoot( IN WCHAR *       pszVirtual,
                                OUT STRU *       pstrPhysical,
                                IN DWORD         dwAccess )
/*++

Routine Description:

    Lookup the given virtual path.  Optionally ensure that its access
    flags are valid for the require request.

Arguments:

    pszVirtual = Virtual path to lookup
    pstrPhysical = Contains the physical path
    dwAccess = Access flags required for a valid request

Return Value:

    HRESULT

--*/
{
    HSE_URL_MAPEX_INFO      URLMap;
    DWORD                   dwMask;
    STACK_STRA              (strURL, 128);
    HRESULT                 hr = E_FAIL;

    //
    // ServerSupportFunction doesn't accept unicode strings. Convert    
    //

    if ( FAILED(hr = strURL.CopyW(pszVirtual)))
    {
        return hr;

    }

    if ( !_pECB->ServerSupportFunction( _pECB->ConnID,
                                        HSE_REQ_MAP_URL_TO_PATH_EX,
                                        strURL.QueryStr(),
                                        NULL,
                                        (PDWORD) &URLMap ) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    dwMask = URLMap.dwFlags;

    if ( dwAccess & HSE_URL_FLAGS_READ )
    {
        //
        // BUGBUG-MING: Add IsSecurePort()
        //
        /*
        if ( !( dwMask & HSE_URL_FLAGS_READ ) ||
             ( ( dwMask & HSE_URL_FLAGS_SSL ) && 
               !_pReq->IsSecurePort() ) )
        */

        if ( !( dwMask & HSE_URL_FLAGS_READ ) ||
             ( dwMask & HSE_URL_FLAGS_SSL ) )
        {
            return HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        }
    }

    if( FAILED( pstrPhysical->CopyA( URLMap.lpszPath ) ) )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return NO_ERROR;
}

HRESULT
SSI_REQUEST::DoEchoISAPIVariable(
    IN STRA *            pstrVariable
)
/*++

Routine Description:

    Get ISAPI variable and if successful, send it to HTML stream

Arguments:

    pstrVariable - Variable

Return Value:

    HRESULT

--*/
{
   
    HRESULT              hr = E_FAIL;

    if ( FAILED( hr = GetVariable( ( CHAR * )pstrVariable->QueryStr(),
                       &_IOBuffer ) ) )
    {
        return hr;
    }

    return WriteToClient( _IOBuffer.QueryPtr(),
                          strlen( ( CHAR * )_IOBuffer.QueryPtr() ),
                          &_cbIOLen );
}

HRESULT
SSI_REQUEST::DoEchoDateLocal(
    IN STRA *            pstrTimeFmt
)
/*++

Routine Description:

    Sends local time (#ECHO VAR="DATE_LOCAL")

Arguments:

    pstrTimefmt - Format of time (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              sysTime;

    ::GetLocalTime( &sysTime );
    return SendDate( &sysTime,
                     pstrTimeFmt );
}

HRESULT
SSI_REQUEST::DoEchoDateGMT(
    IN STRA *            pstrTimeFmt
)
/*++

Routine Description:

    Sends GMT time (#ECHO VAR="DATE_GMT")

Arguments:

    pstrTimefmt - Format of time (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    SYSTEMTIME              sysTime;

    ::GetSystemTime( &sysTime );
    return SendDate( &sysTime,
                     pstrTimeFmt );
}

HRESULT
SSI_REQUEST::DoEchoDocumentName(
    IN STRU *            pstrFilename
)
/*++

Routine Description:

    Sends filename of current SSI document (#ECHO VAR="DOCUMENT_NAME")

Arguments:

    pstrFilename - filename to print

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;

    if ( FAILED( hr = (_IOString.CopyW(pstrFilename->QueryStr() ) ) ) )
    {
        return hr;
    }

    return WriteToClient( _IOString.QueryStr(),
                          _IOString.QueryCCH(),
                          &_cbIOLen);
}

HRESULT
SSI_REQUEST::DoEchoDocumentURI(
    IN STRU *            pstrURL
)
/*++

Routine Description:

    Sends URL of current SSI document (#ECHO VAR="DOCUMENT_URI")

Arguments:

    pstrURL - URL to print

Return Value:

    HRESULT
--*/
{
    HRESULT hr = E_FAIL;

    if ( FAILED( hr = _IOString.CopyW(pstrURL->QueryStr() ) ) )
    {
        return hr;
    }

    return WriteToClient( _IOString.QueryStr(),
                          _IOString.QueryCCH(),
                          &_cbIOLen );
}

HRESULT
SSI_REQUEST::DoEchoQueryStringUnescaped(
    VOID
    )
/*++

Routine Description:

    Sends unescaped querystring to HTML stream (#ECHO VAR="QUERY_STRING_UNESCAPED")

Arguments:

    none

Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = E_FAIL;

    if ( FAILED( hr = _IOString.Copy( _pECB->lpszQueryString ) ) )
    {
        return hr;
    }

    if ( FAILED( hr = _IOString.Unescape()) )
    {
        return hr;
    }

    return WriteToClient( _IOString.QueryStr(),
                          _IOString.QueryCCH(),
                          &_cbIOLen );
}

HRESULT
SSI_REQUEST::DoEchoLastModified(
    IN STRU *             pstrFilename,
    IN STRA *             pstrTimeFmt,
    IN SSI_ELEMENT_LIST * pList
)
/*++

Routine Description:

    Sends LastModTime of current document (#ECHO VAR="LAST_MODIFIED")

Arguments:

    pstrFilename - Filename of current SSI document
    pstrTimeFmt - Time format (follows strftime() convention)

Return Value:

    HRESULT

--*/
{
    return DoFLastMod( pstrFilename,
                       pstrTimeFmt,
                       pList);
}

HRESULT
SSI_REQUEST::DoFSize(
    IN STRU *                pstrFilename,
    IN BOOL                  bSizeFmtBytes,
    IN SSI_ELEMENT_LIST    * pList
)
/*++

Routine Description:

    Sends file size of file to HTML stream

Arguments:

    pstrfilename - Filename
    bSizeFmtBytes - TRUE if count is in Bytes, FALSE if in KBytes

Return Value:

    HRESULT

--*/
{
    BOOL                bRet;
    DWORD               cbSizeLow;
    DWORD               cbSizeHigh;
    WCHAR               achInputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    WCHAR               achOutputNumber[ SSI_MAX_NUMBER_STRING + 1 ];
    NUMBERFMT           nfNumberFormat;
    int                 iOutputSize;
    DWORD               dwActualLen;
    HRESULT             hr = E_FAIL;

    if ( ( NULL == pList ) || 
         wcscmp( pstrFilename->QueryStr(), 
         ( pList->GetFile()->GetFilename().QueryStr() ) ) )
    {
        SSI_FILE ssiFile( pstrFilename, GetUserToken() );

        if ( !ssiFile.IsValid() ||
             ( !ssiFile.SSIGetFileSize( &cbSizeLow,
                                        &cbSizeHigh ) )
           )
        {
            return E_FAIL;
        }
    }
    else
    {
        if (!pList->GetFile()->SSIGetFileSize( &cbSizeLow,
                                               &cbSizeHigh ) )
        {
            return E_FAIL;
        }
    }

    if ( cbSizeHigh )
    {
        //BUGBUG-jaro: do we ignore extra large files intentionaly?
        return E_FAIL;
    }

    if ( !bSizeFmtBytes )
    {
        // express in terms of KB
        cbSizeLow /= 1000;
    }

    nfNumberFormat.NumDigits = 0;
    nfNumberFormat.LeadingZero = 0;
    nfNumberFormat.Grouping = 3;
    nfNumberFormat.lpThousandSep = L",";
    nfNumberFormat.lpDecimalSep = L".";
    nfNumberFormat.NegativeOrder = 2;

    _snwprintf( achInputNumber,
                SSI_MAX_NUMBER_STRING + 1,
                L"%ld",
                cbSizeLow );

    iOutputSize = GetNumberFormat( LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   achInputNumber,
                                   &nfNumberFormat,
                                   achOutputNumber,
                                   SSI_MAX_NUMBER_STRING + 1 );
    if ( !iOutputSize )
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Do not count trailing '\0' 
    //
    
    iOutputSize--;

    //
    // Convert from Unicode before sending to client
    //

    if ( FAILED( hr = _IOString.CopyW(achOutputNumber) ) )
    {
        return hr;
    }
    

    return WriteToClient( _IOString.QueryStr(),
                          iOutputSize,
                          &_cbIOLen );
}


HRESULT
SSI_REQUEST::PrepareSSI( 
    VOID 
    )
/*++

Routine Description:

    Prepare esential data structures 
    
Arguments:

    none

Return Value:

    HRESULT

--*/
{
    return _pSIF->Prepare();
}


HRESULT
SSI_REQUEST::DoWork( 
    DWORD dwError 
    )
/*++

Routine Description:

    This is the top level routine for retrieving a server side include
    file.

Arguments:

    dwError - error of the last asynchronous operation (the one received by completion routine)

Return Value:

    HRESULT

--*/
{
    HRESULT hr = E_FAIL;

    DBG_ASSERT ( _pSIF != NULL );
    
    while( _pSIF != NULL )
    {
        //
        // In the case that dwError != NO_ERROR
        // _pSIF->DoWork() may be called multiple times to unwind state machine
        // We will pass the same dwError in the case of multiple calls
        // since that error is the primary reason why processing of this request
        // must finish 
        //
        hr = _pSIF->DoWork(dwError);
        if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING) )
        {
            //
            // If there is pending IO return to caller
            //
            return hr;
        }
        else
        {
            //
            // Either SSI_INCLUDE_FILE processing completed
            // or there is nested include
            //
            // In the case of error this block is used to unwind state machine
            //
            if ( _pSIF->IsCompleted() )
            {
                //
                // SSI_INCLUDE_FILE processing completed            
                // Cleanup and if there is parent SSI_INCLUDE_FILE continue with that one
                //

                SSI_INCLUDE_FILE * pParent = _pSIF->GetParent();
                delete _pSIF;
                _pSIF = pParent;
                
            }
            else
            {
                //
                // Current SSI_INCLUDE_FILE _pSIF hasn't been completed yet. Continue
                //
            }
        }
    } 
    return hr;
}

//static
VOID WINAPI
SSI_REQUEST::HseIoCompletion(
                IN EXTENSION_CONTROL_BLOCK * pECB,
                IN PVOID    pContext,
                IN DWORD    cbIO,
                IN DWORD    dwError
                )
/*++

 Routine Description:

   This is the callback function for handling completions of asynchronous IO.
   This function performs necessary cleanup and resubmits additional IO
    (if required).

 Arguments:

   pecb          pointer to ECB containing parameters related to the request.
   pContext      context information supplied with the asynchronous IO call.
   cbIO          count of bytes of IO in the last call.
   dwError       Error if any, for the last IO operation.

 Return Value:

   None.
--*/
{
    SSI_REQUEST *           pRequest = (SSI_REQUEST *) pContext;
    HRESULT                 hr = E_FAIL;

    //
    //  Continue processing SSI file
    //

    hr = pRequest->DoWork(dwError);
    if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING) )
    {
        //
        // pending IO operation
        //

        return;
    }

    //
    // Processing of current SSI request completed
    // Do Cleanup
    //

    delete pRequest;

    //
    // Notify IIS that we are done with processing
    //
    
    pECB->ServerSupportFunction( pECB->ConnID,
                                 HSE_REQ_DONE_WITH_SESSION,
                                 NULL, 
                                 NULL, 
                                 NULL);
    
    return;

}


//
// SSI_INCLUDE_FILE methods implementation
//

//static 
ALLOC_CACHE_HANDLER * SSI_INCLUDE_FILE::sm_pachSSI_IncludeFiles = NULL;


SSI_INCLUDE_FILE::~SSI_INCLUDE_FILE( VOID )
/*++

Routine Description:

    Destructor

--*/

{
    if ( !_fSELCached && _pSEL )
    {
        delete _pSEL;
        _pSEL = NULL;
    }
        
    if ( _pOpenFile )
    {
        _pOpenFile->DereferenceCacheEntry();
        _pOpenFile = NULL;
    }
}    


HRESULT
SSI_INCLUDE_FILE::Prepare( VOID )
    
/*++

Routine Description:

    This method builds the Server Side Include Element List the first 
    time a .stm file is sent.  Subsequently, the element list is 
    checked out from the associated cache blob.

    Note:  The HTTP headers have already been sent at this point so for 
    any subsequent non-catastrophic errors, we have to insert them into 
    the output stream.

Arguments:

    
Return Value:

    HRESULT

--*/
{
    HRESULT                 hr = E_FAIL;
    DWORD                   dwError;
    LPSTR                   apszParms[ 2 ] = { NULL, NULL };
    CHAR                    pszNumBuf[ SSI_MAX_NUMBER_STRING ];
    FILE_CACHE_USER         fileUser;
    HSE_CUSTOM_ERROR_INFO   customErrorInfo;

    DBG_ASSERT( _State == SIF_STATE_INITIALIZED );

    DBG_ASSERT( _pRequest != NULL );
    
    fileUser._hToken = _pRequest->GetUserToken();
    
    hr = g_pFileCache->GetFileInfo( _strFilename,
                                    NULL,
                                    &fileUser,
                                    TRUE,
                                    &_pOpenFile );
    if ( FAILED( hr ) )
    {
        goto failed;
    }

    //
    // The source file is in the cache.  Check whether we have 
    // associated a SSI_ELEMENT_LIST with it.
    //

    _fFileCached = _pOpenFile->QueryFileBuffer() != NULL;

    _pSEL = ( SSI_ELEMENT_LIST * )_pOpenFile->QueryAssociatedObject();
    if ( _pSEL )
    {
        _fSELCached = TRUE;
    }
    else
    {
        //
        // build SSI_ELEMENT_LIST _pSEL
        //
         hr = BuildSEL();
         if ( FAILED( hr ) )
         {
            goto failed;
         }
    }

    //
    // Only bother to cache SEL if the file is cached
    // 
    
    if ( !_fSELCached && _fFileCached )
    {
        if ( !_pOpenFile->SetAssociatedObject( _pSEL ) )
        {
            delete _pSEL;
            _pSEL = (SSI_ELEMENT_LIST*) _pOpenFile->QueryAssociatedObject();
            if ( !_pSEL )
            {
                DBG_ASSERT( FALSE );
                hr = E_FAIL;
                goto failed;
            }
            else
            {
                _fSELCached = TRUE;
            }
        }
        else
        {
            _fSELCached = TRUE;
        }
    }
 

    //
    // adjust State
    //

    SetState( SIF_STATE_READY );

    //
    // If we got this far and this is the base file, we can send the 
    // 200 OK
    //

    if ( IsBaseFile() )
    {
        return _pRequest->SendResponseHeader( NULL,
                                              SSI_HEADER );
      
    }
    else
    {
        return NO_ERROR;
    }

        
failed:
    dwError = WIN32_FROM_HRESULT(hr);            
    
    if ( IsBaseFile() )
    {
        //
        // First try to have IIS send custom error
        //
        
        switch( dwError )
        {
        case ERROR_ACCESS_DENIED:
        
            customErrorInfo.pszStatus = "401 Access Denied";
            customErrorInfo.uHttpSubError = MD_ERROR_SUB401_LOGON_ACL;
            customErrorInfo.fAsync = FALSE;
            
            hr = _pRequest->SendCustomError( &customErrorInfo );

            break;
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:

            customErrorInfo.pszStatus = "404 Object Not Found";
            customErrorInfo.uHttpSubError = 0;
            customErrorInfo.fAsync = FALSE;
            
            hr = _pRequest->SendCustomError( &customErrorInfo );
            
            break;
            
        default:
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
        }
        
        //
        // If IIS could not send custom error, then send our own legacy
        // error response
        //
        
        if ( hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) )
        {
            switch( dwError )
            {
            case ERROR_ACCESS_DENIED:
                _pRequest->SendResponseHeader( SSI_ACCESS_DENIED,
                                              SSI_HEADER
                                              "<body><h1>"
                                              SSI_ACCESS_DENIED
                                              "</h1></body>" );
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                _pRequest->SendResponseHeader( SSI_OBJECT_NOT_FOUND,
                                              SSI_HEADER
                                              "<body><h1>"
                                              SSI_OBJECT_NOT_FOUND
                                              "</h1></body>" );
                break;  
            default:
    
                STACK_STRA (strURL, 128);
                if (FAILED( hr = strURL.CopyW(_strURL.QueryStr())))
                {
                    break;
                }
    
                _pRequest->SendResponseHeader( NULL,
                                              SSI_HEADER );
    
                _ultoa( dwError, pszNumBuf, 10 );
                apszParms[ 0 ] = strURL.QueryStr();
                apszParms[ 1 ] = pszNumBuf;
    
                hr = _pRequest->SSISendError( SSINCMSG_ERROR_HANDLING_FILE,
                                              apszParms );
                       
            }
        }
    }
    else
    {
        STACK_STRA (strURL, 128);
        if (SUCCEEDED( hr = strURL.CopyW(_strURL.QueryStr())))
        {
            _ultoa( dwError, pszNumBuf, 10 );
            apszParms[ 0 ] = strURL.QueryStr();
            apszParms[ 1 ] = pszNumBuf;

            hr = _pRequest->SSISendError( SSINCMSG_ERROR_HANDLING_FILE,
                                          apszParms );
        }
    }
    
    //
    // In the case of error set state to Completed
    //
    SetState( SIF_STATE_COMPLETED );
    
    return ( ( FAILED(hr) ) ? hr : E_FAIL);
}    


HRESULT
SSI_INCLUDE_FILE::BuildSEL( VOID )
/*++

Routine Description:

    This method opens and parses the specified server side include file and 
    builds SSI_ELEMENT_LIST (SEL)

    Note:  The HTTP headers have already been sent at this point so for any
    subsequent non-catastrophic errors, we have to insert them into the output
    stream.

    We keep the file open but that's ok because if a change dir notification
    occurs, the cache blob will get decached at which point we will close
    all of our open handles.

Arguments:


Return Value:

    HRESULT
    
--*/
{
    SSI_FILE *          pssiFile = NULL;
    SSI_ELEMENT_LIST *  pSEL  = NULL;
    CHAR *              pchBeginRange = NULL;
    CHAR *              pchFilePos = NULL;
    CHAR *              pchBeginFile = NULL;
    CHAR *              pchEOF = NULL;
    DWORD               cbSizeLow, cbSizeHigh;
    HRESULT             hr = E_FAIL;

    //
    //  Create the element list
    //

    _pSEL = new SSI_ELEMENT_LIST;

    if ( _pSEL == NULL )
    {
        hr = E_FAIL;
        goto failed;
    }

    //
    //  Set the URL (to be used in calculating FILE="xxx" paths
    //

    _pSEL->SetURL( &_strURL );

    //
    //  Open the file
    //

    pssiFile = new SSI_FILE( &_strFilename, _pOpenFile );
    if ( pssiFile == NULL || !pssiFile->IsValid() )
    {
        if (pssiFile)
        {
            delete pssiFile;
            pssiFile = NULL;
        }
        hr = E_FAIL;
        goto failed;
    }

    _pSEL->SetFile( pssiFile );

    //
    //  Make sure a parent doesn't try and include a directory
    //

    if ( pssiFile->SSIGetFileAttributes() & FILE_ATTRIBUTE_DIRECTORY )
    {
        hr = E_FAIL;
        goto failed;
    }

    if ( !pssiFile->SSIGetFileSize( &cbSizeLow, &cbSizeHigh ) )
    {
        hr = E_FAIL;
        goto failed;
    }

    if ( cbSizeHigh )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_SUPPORTED );
        goto failed;
    }

    //
    //  Create a file mapping, we shouldn't need to impersonate as we already
    //  have the file open
    //

    if ( !_pSEL->Map() )
    {
        hr = E_FAIL;
        goto failed;
    }

    pchFilePos = pchBeginFile = pchBeginRange = _pSEL->QueryData();
    pchEOF     = pchFilePos + cbSizeLow;

    //
    //  Scan for "<!--" or "<%"
    //

    while ( TRUE )
    {
        while ( pchFilePos < pchEOF && *pchFilePos != '<' )
        {
            pchFilePos++;
        }

        if ( pchFilePos + 4 >= pchEOF )
        {
            break;
        }

        //
        //  Is this one of our tags?
        //

        if ( pchFilePos[1] == '%' ||
             !strncmp( pchFilePos, "<!--", 4 ))
        {
            CHAR *        pchBeginTag = pchFilePos;
            SSI_COMMANDS  CommandType;
            SSI_TAGS      TagType;
            CHAR          achTagString[ SSI_MAX_PATH + 1 ];
            BOOL          fValidTag;

            //
            //  Get the tag info.  The file position will be advanced to the
            //  first character after the tag
            //

            if ( !ParseSSITag( &pchFilePos,
                               pchEOF,
                               &fValidTag,
                               &CommandType,
                               &TagType,
                               achTagString ) )
            {
                break;
            }

            //
            //  If it's a tag we don't recognize then ignore it
            //

            if ( !fValidTag )
            {
                pchFilePos++;
                continue;
            }

            //
            //  Add the data up to the tag as a byte range
            //

            if ( pchBeginRange != pchBeginTag )
            {
                if ( !_pSEL->AppendByteRange( 
                                  DIFF(pchBeginRange - pchBeginFile),
                                  DIFF(pchBeginTag - pchBeginRange) ) )
                {
                    hr = E_FAIL;
                    goto failed;
                }
            }

            pchBeginRange = pchFilePos;

            //
            //  Add the tag
            //

            if ( !_pSEL->AppendCommand( CommandType,
                                       TagType,
                                       achTagString ))
            {
                hr = E_FAIL;
                goto failed;
            }
        }
        else
        {
            //
            //  Not one of our tags, skip the openning angle bracket
            //

            pchFilePos++;
        }
    }

    //
    //  Tack on the last byte range
    //

    if ( pchFilePos > pchBeginRange )
    {
        if ( !_pSEL->AppendByteRange( DIFF(pchBeginRange - pchBeginFile),
                                     DIFF(pchFilePos - pchBeginRange) ))
        {
            hr = E_FAIL;
            goto failed;
        }
    }

    
    return NO_ERROR;

failed:

    if ( _pSEL != NULL )
    {
        //
        // also deletes pssiFile if SetFile has been called.
        //
        delete _pSEL; 
        _pSEL = NULL;
    }

    return hr;
}

//static
BOOL
SSI_INCLUDE_FILE::ParseSSITag(
    IN OUT CHAR * *        ppchFilePos,
    IN     CHAR *          pchEOF,
    OUT    BOOL *          pfValidTag,
    OUT    SSI_COMMANDS  * pCommandType,
    OUT    SSI_TAGS *      pTagType,
    OUT    CHAR *          pszTagString
    )
/*++

Routine Description:

    This function picks apart an NCSA style server side include 
    expression

    The general form of a server side include directive is:

    <[!-- or %]#[command] [tag]="[value]"[-- or %]>

    For example:

    <!--#include file="myfile.txt"-->
    <%#echo var="HTTP_USER_AGENT"%>
    <!--#fsize virtual="/dir/bar.htm"-->

    For valid commands and tags see \iis\specs\ssi.doc

Arguments:

    ppchFilePos - Pointer to first character of tag on way in, pointer
        to first character after tag on way out if the tag is valid
    pchEOF - Points to first byte beyond the end of the file
    pfValidTag - Set to TRUE if this is a tag we support and all of the
        parameters have been supplied
    pCommandType - Receives SSI command
    pTagType - Receives SSI tag
    pszTagString - Receives value of pTagType.  Must be > SSI_MAX_PATH.

Return Value:

    TRUE if no errors occurred.

--*/
{
    CHAR * pchFilePos = *ppchFilePos;
    CHAR * pchEOT;
    CHAR * pchEndQuote;
    DWORD   i;
    DWORD   cbToCopy;
    DWORD   cbJumpLen = 0;
    BOOL    fNewStyle;           // <% format

    DBG_ASSERT( *pchFilePos == '<' );

    //
    //  Assume this is bad tag
    //

    *pfValidTag = FALSE;

    if ( !strncmp( pchFilePos, "<!--", 4 ) )
    {
        fNewStyle = FALSE;
    }
    else if ( !strncmp( pchFilePos, "<%", 2 ) )
    {
        fNewStyle = TRUE;
    }
    else
    {
        return TRUE;
    }

    //
    //  Find the closing comment token (either --> or %>).  The reason
    //  why we shouldn't simply look for a > is because we want to allow
    //  the user to embed HTML <tags> in the directive
    //  (ex. <!--#CONFIG ERRMSG="<B>ERROR!!!</B>-->)
    //

    pchEOT = strstr( pchFilePos, fNewStyle ? "%>" : "-->" );
    if ( !pchEOT )
    {
        return FALSE;
    }
    cbJumpLen = fNewStyle ? 2 : 3;

    //
    //  Find the '#' that prefixes the command
    //

    pchFilePos = SSISkipTo( pchFilePos, '#', pchEOT );

    if ( !pchFilePos )
    {
        //
        //  No command, bail for this tag
        //
        //  CODEWORK - Check for if expression here
        //

        return TRUE;
    }

    //
    //  Lookup the command
    //

    i = 0;
    while ( SSICmdMap[i].pszCommand )
    {
        if ( *SSICmdMap[i].pszCommand == towlower( *pchFilePos ) &&
             !_strnicmp( SSICmdMap[i].pszCommand,
                         pchFilePos,
                         SSICmdMap[i].cchCommand ))
        {
            *pCommandType = SSICmdMap[i].ssiCmd;

            //
            //  Note the space after the command is included in 
            //  cchCommand
            //

            pchFilePos += SSICmdMap[i].cchCommand;
            goto FoundCommand;
        }

        i++;
    }

    //
    //  Unrecognized command, bail
    //

    return TRUE;

FoundCommand:

    //
    //  Next, find the tag name
    //

    pchFilePos = SSISkipWhite( pchFilePos, pchEOT );

    if ( !pchFilePos )
        return TRUE;

    i = 0;
    while ( SSITagMap[i].pszTag )
    {
        if ( *SSITagMap[i].pszTag == tolower( *pchFilePos ) &&
             !_strnicmp( SSITagMap[i].pszTag,
                         pchFilePos,
                         SSITagMap[i].cchTag ))
        {
            *pTagType = SSITagMap[i].ssiTag;
            pchFilePos += SSITagMap[i].cchTag;
            goto FoundTag;
        }

        i++;
    }

    //
    //  Tag not found, bail
    //

    return TRUE;

FoundTag:

    //
    //  Skip to the quoted tag value, then find the close quote
    //

    pchFilePos = SSISkipTo( pchFilePos, '"', pchEOT );

    if ( !pchFilePos )
        return TRUE;

    pchEndQuote = SSISkipTo( ++pchFilePos, '"', pchEOT );

    if ( !pchEndQuote )
        return TRUE;

    cbToCopy = min( DIFF( pchEndQuote - pchFilePos ), SSI_MAX_PATH );

    memcpy( pszTagString,
            pchFilePos,
            cbToCopy );

    pszTagString[ cbToCopy ] = '\0';

    *pfValidTag = TRUE;

    *ppchFilePos = pchEOT + cbJumpLen;

    return TRUE;
}

//static
CHAR *
SSI_INCLUDE_FILE::SSISkipTo(
    IN CHAR * pchFilePos,
    IN CHAR   ch,
    IN CHAR * pchEOF
    )
{
    return ( CHAR * ) memchr( pchFilePos, 
                              ch, 
                              DIFF( pchEOF - pchFilePos ) );
}

//static
CHAR *
SSI_INCLUDE_FILE::SSISkipWhite(
    IN CHAR * pchFilePos,
    IN CHAR * pchEOF
    )
{
    while ( pchFilePos < pchEOF )
    {
        if ( !SAFEIsSpace( *pchFilePos ) )
            return pchFilePos;

        pchFilePos++;
    }

    return NULL;
}

HRESULT
SSI_INCLUDE_FILE::DoWork(
    DWORD dwError
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:
    
    dwError - error of the last asynchronous operation

Return Value:

    HRESULT
--*/
{
    HSE_EXEC_URL_STATUS     ExecUrlStatus;
    SSI_ELEMENT_ITEM *      pSEI;
    DWORD                   dwID;
    LPSTR                   apszParms[ 2 ] = { NULL, NULL };
    CHAR                    achNumberBuffer[ SSI_MAX_NUMBER_STRING ];
    HRESULT                 hr = E_FAIL;

    DBG_ASSERT( _pRequest != NULL );

    if ( dwError != NO_ERROR )
    {
        //
        // Last asynchronous operation failed
        // only in the state: SIF_STATE_EXEC_CHILD_PENDING we will proceed if error occured
        //

        if ( _State != SIF_STATE_EXEC_CHILD_PENDING )
        {
            //
            // Completion error means that we are forced to finish processing
            //
            SetState( SIF_STATE_COMPLETED );
        }
    }

    while( _State !=  SIF_STATE_COMPLETED )
    {
        switch( _State )
        {
        case SIF_STATE_INITIALIZED:
            //
            // Prepare data structures when called for the first time
            // and send initial headers or errors
            //

            hr = Prepare();
            if( FAILED( hr ) )
            {
                return hr;
            }
            break;

        case SIF_STATE_READY:
            //
            // Auxiliary state to flag that all the necessary date structures
            // were prepared but actual processing hasn't started yet.
            // Switch to PROCESSING state
            //

            SetState( SIF_STATE_PROCESSING );
            break;

        case SIF_STATE_PROCESSING:
            //
            // There are few cases when Process returns
            // a) request completed
            // b) pending operation
            // c) child include file to be processed
            //
            // any any case return back to caller
            //

            hr = Process();
            return hr;

        case SIF_STATE_INCLUDE_CHILD_PENDING:
            //
            // Child include completed. Restore processing of current include file
            //
            SetState( SIF_STATE_PROCESSING );
            break;

        case SIF_STATE_EXEC_CHILD_PENDING:
            
            //
            // We were able to spawn child request.  Get the status
            //
            pSEI = CONTAINING_RECORD( _pCurrentEntry, SSI_ELEMENT_ITEM, _ListEntry );    
            if( _pRequest->GetECB()->ServerSupportFunction(
                                _pRequest->GetECB()->ConnID,
                                HSE_REQ_GET_EXEC_URL_STATUS,
                                &ExecUrlStatus,
                                NULL,
                                NULL
                                ) )
            {
                if ( ExecUrlStatus.uHttpStatusCode >= 400 )
                {
                    switch( ExecUrlStatus.uHttpStatusCode )
                    {
                    case 403:
                        dwID = SSINCMSG_NO_EXECUTE_PERMISSION;
                        break;
                    default:
                        dwID = SSINCMSG_CANT_EXEC_CGI_REPORT_HTTP_STATUS;
                        break;
                    }
                        
                    _itoa( ExecUrlStatus.uHttpStatusCode, achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR* )pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                }
                else
                {
                    dwID = 0;
                }
            }
            else
            {
                _ultoa( GetLastError(), achNumberBuffer, 10 );
                apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->QueryStr();
                apszParms[ 1 ] = achNumberBuffer;
                dwID = SSINCMSG_CANT_EXEC_CGI;
            }

            //
            //  EXEC_URL completed. Adjust State back to PROCESSING
            //

            SetState( SIF_STATE_PROCESSING );

            if ( dwID != 0 )
            {
                hr = _pRequest->SSISendError( dwID, apszParms );
                if ( FAILED (hr) )
                {
                    //
                    // This doesn't mean necessarily fatal error
                    // ERROR_IO_PENDING was likely returned
                    // so we have to simply return and wait for completion
                    //
                    return hr;
                }
            }
            break;

        default:
            //
            // Unexpected State
            //
            DBG_ASSERT( _State > SIF_STATE_UNINITIALIZED && _State < SIF_STATE_UNKNOWN );
            return E_FAIL;
        } // switch( _State )
    } 
    return NO_ERROR;
}

HRESULT
SSI_INCLUDE_FILE::Process(
    VOID
    )
/*++

Routine Description:

    This method walks the element list sending the appropriate chunks of
    data

Arguments:


Return Value:

    HRESULT
--*/
{
    DWORD                   cbSent;
    STACK_STRU(             strPath, MAX_PATH);
    SSI_ELEMENT_ITEM *      pSEI;
    HSE_EXEC_URL_STATUS     ExecUrlStatus;
    DWORD                   dwID;
    LPSTR                   apszParms[ 2 ];
    CHAR                    achNumberBuffer[ SSI_MAX_NUMBER_STRING ];
    HRESULT                 hr = E_FAIL;

    DBG_ASSERT( _pRequest != NULL );

   
    if( _pCurrentEntry == NULL )
    {
        _pCurrentEntry = _pSEL->QueryListHead();
    }

    //
    // Move CurrentEntry pointer to next element
    //
    _pCurrentEntry = _pCurrentEntry->Flink;
    
    //
    //  Loop through each element and take the appropriate action
    //

    while( _pCurrentEntry != _pSEL->QueryListHead() )
    {

        DBG_ASSERT( _State == SIF_STATE_PROCESSING );

        pSEI = CONTAINING_RECORD( _pCurrentEntry, SSI_ELEMENT_ITEM, _ListEntry );

        DBG_ASSERT( pSEI->CheckSignature() );

        dwID = 0;

        switch ( pSEI->QueryCommand() )
        {
        case SSI_CMD_BYTERANGE:
            if ( FAILED( hr = _pRequest->WriteToClient( 
                                 _pSEL->QueryData() + pSEI->QueryBegin(),
                                 pSEI->QueryLength(),
                                 &cbSent ) ) )
            {
                //
                // This doesn't mean necessarily fatal error
                // ERROR_IO_PENDING was likely returned
                // so we have to simply return and wait for completion
                //
                return hr;
            }
            break;

        case SSI_CMD_INCLUDE:
            switch ( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
            {
                STACK_STRU(    strFullURL, MAX_PATH );

                if ( FAILED ( hr = GetFullPath( pSEI,
                                   &strPath,
                                   HSE_URL_FLAGS_READ,
                                   &_strURL,
                                   &strFullURL ) ) )
                {
                    _ultoa( WIN32_FROM_HRESULT(hr), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;
                }

                if ( IsRecursiveInclude( strPath ) )
                {
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = NULL;
                    dwID = SSINCMSG_ERROR_RECURSIVE_INCLUDE;
                    break;
                }

                //
                // Nested STM include
                //
                
                SSI_INCLUDE_FILE * pChild = new SSI_INCLUDE_FILE( _pRequest, strPath, strFullURL, this );
                
                if ( pChild == NULL || !pChild->IsValid() )
                {
                    _ultoa( WIN32_FROM_HRESULT(ERROR_OUTOFMEMORY), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_ERROR_HANDLING_FILE;
                    break;

                }

                _pRequest->SetCurrentIncludeFile( pChild );

                SetState( SIF_STATE_INCLUDE_CHILD_PENDING );

                //
                // Return back to SSI_REQUEST (_pRequest)
                // SSI_REQUEST will start executing it just added SSI_INCLUDE_FILE (pChild)
                //
                // This way recursive function calls that were used in the previous
                // implementation can be avoided (to makes possible to implement 
                // asynchronous processing)
                //
                
                return NO_ERROR;
            }
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_FLASTMOD:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( FAILED( hr = GetFullPath( pSEI,
                                   &strPath,
                                   0,
                                   &_strURL ) ) ||
                     FAILED( hr = _pRequest->DoFLastMod( &strPath,
                                            &_strTimeFmt,
                                            _pSEL ) ) )
                {
                    if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING ) )
                    {
                        return hr;
                    }
                 
                    _ultoa( WIN32_FROM_HRESULT(hr), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FLASTMOD;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_CONFIG:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_ERRMSG:
                if ( !_pRequest->SetUserErrorMessage( 
                                       pSEI->QueryTagValue() ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            case SSI_TAG_TIMEFMT:
                if ( FAILED( _strTimeFmt.Resize( 
                                pSEI->QueryTagValue()->QueryCCH() ) ) )
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }

                if ( FAILED( hr = _strTimeFmt.Copy( pSEI->QueryTagValue()->QueryStr() ) ) )
                {
                    return hr;
                }
                                
                break;
            case SSI_TAG_SIZEFMT:
                if ( _strnicmp( SSI_DEF_BYTES,
                             ( CHAR * )pSEI->QueryTagValue()->QueryStr(),
                             SSI_DEF_BYTES_LEN ) == 0 )
                {
                    _fSizeFmtBytes = TRUE;
                }
                else if ( _strnicmp( SSI_DEF_ABBREV,
                             ( CHAR * )pSEI->QueryTagValue()->QueryStr(),
                                     SSI_DEF_ABBREV_LEN ) == 0 )
                {
                    _fSizeFmtBytes = FALSE;
                }
                else
                {
                    dwID = SSINCMSG_INVALID_TAG;
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
            break;

        case SSI_CMD_FSIZE:
            switch( pSEI->QueryTag() )
            {
            case SSI_TAG_FILE:
            case SSI_TAG_VIRTUAL:
                if ( FAILED ( hr = GetFullPath( pSEI,
                                   &strPath,
                                   0,
                                   &_strURL ) ) ||
                     FAILED ( hr = _pRequest->DoFSize( &strPath,
                                         _fSizeFmtBytes,
                                         _pSEL) ) )
                {
                    if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING ) )
                    {
                        return hr;
                    }
                    _ultoa( WIN32_FROM_HRESULT(hr), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                     QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_DO_FSIZE;
                                   
                }
                break;
            default:
                dwID = SSINCMSG_INVALID_TAG;
            }
        
            break;

        case SSI_CMD_ECHO:
            if ( pSEI->QueryTag() == SSI_TAG_VAR )
            {
                // First let ISAPI try to evaluate variable.
                hr = _pRequest->DoEchoISAPIVariable( 
                                     pSEI->QueryTagValue() );
                if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING ) )
                {
                    return hr;
                }
                                  
                if ( SUCCEEDED (hr ) )                     
                {
                    break;
                }
                else
                {
                    DWORD               dwVar;
                    HRESULT             hrEcho = E_FAIL;

                    // if ISAPI couldn't resolve var, try internal list
                    if ( !FindInternalVariable( pSEI->QueryTagValue(),
                                               &dwVar ) )
                    {
                        apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->
                                                        QueryStr();
                        apszParms[ 1 ] = NULL;
                        dwID = SSINCMSG_CANT_FIND_VARIABLE;
                    }
                    else
                    {
                        switch( dwVar )
                        {
                        case SSI_VAR_DOCUMENT_NAME:
                            hrEcho = _pRequest->DoEchoDocumentName( 
                                            &_pSEL->GetFile()->GetFilename() );
                            break;
                        case SSI_VAR_DOCUMENT_URI:
                            hrEcho = _pRequest->DoEchoDocumentURI( 
                                            &_strURL );
                            break;
                        case SSI_VAR_QUERY_STRING_UNESCAPED:
                            hrEcho = _pRequest->DoEchoQueryStringUnescaped();
                            break;
                        case SSI_VAR_DATE_LOCAL:
                            hrEcho = _pRequest->DoEchoDateLocal( 
                                            &_strTimeFmt );
                            break;
                        case SSI_VAR_DATE_GMT:
                            hrEcho = _pRequest->DoEchoDateGMT( 
                                            &_strTimeFmt );
                            break;
                        case SSI_VAR_LAST_MODIFIED:
                            hrEcho = _pRequest->DoEchoLastModified( 
                                            &_pSEL->GetFile()->GetFilename(),
                                            &_strTimeFmt, 
                                            _pSEL );
                            break;
                        default:
                            apszParms[ 0 ] = ( CHAR * )pSEI->
                                             QueryTagValue()->QueryStr();
                            apszParms[ 1 ] = NULL;
                            dwID = SSINCMSG_CANT_FIND_VARIABLE;
                        }
                        if ( hrEcho == HRESULT_FROM_WIN32(ERROR_IO_PENDING ) )
                        {
                            return hrEcho;
                        }
               
                        if ( FAILED ( hrEcho ) )
                        {
                            apszParms[ 0 ] = ( CHAR * )pSEI->
                                             QueryTagValue()->QueryStr();
                            apszParms[ 1 ] = NULL;
                            dwID = SSINCMSG_CANT_EVALUATE_VARIABLE;
                        }
                    }
                }
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            break;

        case SSI_CMD_EXEC:
        {
            SSI_EXEC_TYPE ssiExecType = SSI_EXEC_UNKNOWN;

            if ( _pRequest->IsExecDisabled() )
            {
                dwID = SSINCMSG_EXEC_DISABLED;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CMD )
            {
                if ( !fEnableCmdDirective )
                {
                    dwID = SSINCMSG_CMD_NOT_ENABLED;
                }
                else
                {
                    ssiExecType = SSI_EXEC_CMD;
                }
            }
            else if ( pSEI->QueryTag() == SSI_TAG_CGI )
            {
                ssiExecType = SSI_EXEC_CGI;
            }
            else if ( pSEI->QueryTag() == SSI_TAG_ISA )
            {
                ssiExecType = SSI_EXEC_ISA;
            }
            else
            {
                dwID = SSINCMSG_INVALID_TAG;
            }

            if ( ssiExecType != SSI_EXEC_UNKNOWN )
            {
                BOOL fOk = FALSE;

                ZeroMemory( &_ExecUrlInfo, sizeof( _ExecUrlInfo ) );

                //
                // Make asynchronous Child Execute
                //
                _ExecUrlInfo.dwExecUrlFlags = HSE_EXEC_URL_NO_HEADERS |
                                             HSE_EXEC_URL_ASYNC |
                                             HSE_EXEC_URL_IGNORE_APPPOOL |
                                             HSE_EXEC_URL_DISABLE_CUSTOM_ERROR |
                                             HSE_EXEC_URL_IGNORE_VALIDATION_AND_RANGE;

                if ( ssiExecType == SSI_EXEC_CMD )
                {
                    _ExecUrlInfo.dwExecUrlFlags |= HSE_EXEC_URL_SSI_CMD;
                }
                
                _ExecUrlInfo.pszUrl = (LPSTR) pSEI->QueryTagValue()->QueryStr();

                DBG_ASSERT( _ExecUrlInfo.pszUrl != NULL );
                
                //
                // Avoid execution of empty URL
                //

                SetState( SIF_STATE_EXEC_CHILD_PENDING );
                
                if ( _ExecUrlInfo.pszUrl[0] != '\0' )
                {
                    fOk = _pRequest->GetECB()->ServerSupportFunction(
                                _pRequest->GetECB()->ConnID,
                                HSE_REQ_EXEC_URL,
                                &_ExecUrlInfo,
                                NULL,
                                NULL
                                );
                }
                if ( !fOk )
                {
                    SetState( SIF_STATE_PROCESSING );
                    _ultoa( GetLastError(), achNumberBuffer, 10 );
                    apszParms[ 0 ] = ( CHAR * )pSEI->QueryTagValue()->QueryStr();
                    apszParms[ 1 ] = achNumberBuffer;
                    dwID = SSINCMSG_CANT_EXEC_CGI;
                }
                else
                {
                    return HRESULT_FROM_WIN32( ERROR_IO_PENDING );
                }
            }
            break;
        }
        default:
            dwID = SSINCMSG_NOT_SUPPORTED;
            break;
        }
        if ( dwID )
        {
            hr = _pRequest->SSISendError( dwID, apszParms );
            if ( FAILED (hr) )
            {
                //
                // This doesn't mean necessarily fatal error
                // ERROR_IO_PENDING was likely returned
                // so we have to simply return and wait for completion
                //
            
                return hr;
            }
        }

        //
        // Move to next element of SSI_ELEMENT_LIST
        //
        
        _pCurrentEntry = _pCurrentEntry->Flink;
    }
    //
    // End of the list has been reached
    // It means that processing of the current SSI_INCLUDE_FILE has completed
    //

    SetState( SIF_STATE_COMPLETED );
    return NO_ERROR;
}

HRESULT
SSI_INCLUDE_FILE::GetFullPath(
    IN SSI_ELEMENT_ITEM *   pSEI,
    OUT STRU *              pstrPath,
    IN DWORD                dwPermission,
    IN STRU  *              pstrCurrentURL,
    OUT STRU *              pstrURL
)
/*++

Routine Description:

    Used to resolve FILE= and VIRTUAL= references.  Fills in the physical
    path of such file references and optionally checks the permissions
    of the virtual directory.

Arguments:

    pSEI - Element item ( either FILE or VIRTUAL )
    pstrPath - Filled in with physical path of file
    dwPermission - Contains permissions that the virtual
                   path must satisfy. For example HSE_URL_FLAGS_READ.
                   If 0, then no permissions are checked
    pstrCurrentURL - Current .STM URL being parsed
    pstrURL - Full URL filled in here (may be NULL if only pstrPath is to be retrieved)

Return Value:

    HRESULT
--*/
{
    WCHAR *             pszValue;
    STRU                strValue;
    DWORD               dwMask;
    DWORD               cbBufLen;
    WCHAR               achPath[ SSI_MAX_PATH + 1 ];
    HRESULT             hr = E_FAIL;

    //
    //  We recalc the virtual root each time in case the root
    //  to directory mapping has changed
    //

    if ( FAILED( hr = strValue.CopyA( pSEI->QueryTagValue()->QueryStr() ) ) )
    {
        return hr;
    }

    pszValue = strValue.QueryStr();

    if ( *pszValue == L'/' )
    {
        wcscpy( achPath, pszValue );
    }
    else if ( ( int )pSEI->QueryTag() == ( int )SSI_TAG_FILE )
    {
        wcscpy( achPath, pstrCurrentURL->QueryStr() );
        LPWSTR pL = achPath + wcslen( achPath );
        while ( pL > achPath && pL[ -1 ] != L'/' )
        {
            --pL;
        }

        if ( pL == achPath )
        {
            *pL++ = L'/';
        }
        wcscpy( pL, pszValue );
    }
    else
    {
        achPath[ 0 ] = L'/';
        wcscpy( achPath + 1, pszValue );
    }

    //
    //  First canonicalize the URL to be #included
    //
    // BUGBUG-MING
    //CanonURL( achPath, g_fIsDBCS );

    //
    //  Map to a physical directory
    //

    if ( FAILED( hr =_pRequest->LookupVirtualRoot( achPath,
                                       pstrPath,
                                       dwPermission ) ) )
    {
        return hr;
    }
    
    if( pstrURL == NULL )
    {
        return NO_ERROR;
    }

    if( FAILED( hr = pstrURL->Copy( achPath ) ) )
    {
        return hr;
    }

    return NO_ERROR;
}

//static
BOOL
SSI_INCLUDE_FILE::FindInternalVariable(
    IN STRA *              pstrVariable,
    OUT PDWORD              pdwID
)
/*++

Routine Description:

    Lookup internal list of SSI variables that aren't supported by ISAPI.
    These include "DOCUMENT_NAME", "DATE_LOCAL", etc.

Arguments:

    pstrVariable - Variable to check
    pdwID - Variable ID (or SSI_VAR_UNKNOWN if not found)

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    DWORD                   dwCounter = 0;

    while ( ( SSIVarMap[ dwCounter ].pszMap != NULL ) &&
            _strnicmp( SSIVarMap[ dwCounter ].pszMap,
                       ( CHAR * )pstrVariable->QueryStr(),
                       SSIVarMap[ dwCounter ].cchMap ) )
    {
        dwCounter++;
    }
    if ( SSIVarMap[ dwCounter ].pszMap != NULL )
    {
        *pdwID = SSIVarMap[ dwCounter ].ssiMap;
        return TRUE;
    }
    else
    {
        *pdwID = SSI_VAR_UNKNOWN;
        return FALSE;
    }
}


VOID
InitializeSSIGlobals( VOID )
/*++

Routine Description:

    Initialize global variables

Return Value:

    none

--*/
{
    HKEY                hKeyParam;
    DWORD               dwType;
    DWORD               nBytes;
    DWORD               dwValue;
    DWORD               err;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMETERS_KEY,
                       0,
                       KEY_READ,
                       &hKeyParam ) == NO_ERROR )
    {
        nBytes = sizeof( dwValue );
        err = RegQueryValueExA( hKeyParam,
                                "SSIEnableCmdDirective",
                                NULL,
                                &dwType,
                                ( LPBYTE )&dwValue,
                                &nBytes
                                );

        if ( ( err == ERROR_SUCCESS ) && ( dwType == REG_DWORD ) ) 
        {
            fEnableCmdDirective = !!dwValue;
        }

        RegCloseKey( hKeyParam );
    }
}

//
// ISAPI DLL Required Entry Points
//

DWORD
WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK * pecb
    )
{
    BOOL                    fRet;
    HRESULT                 hr = E_FAIL;

    SSI_REQUEST *           pssiReq = new SSI_REQUEST(pecb);

    if( pssiReq == NULL || !pssiReq->IsValid())
    {
        goto failed;
    }

    if ( !pecb->ServerSupportFunction( pecb->ConnID,
                                       HSE_REQ_IO_COMPLETION,
                                       SSI_REQUEST::HseIoCompletion,
                                       0,
                                       (LPDWORD ) pssiReq)
        ) 
    {
        goto failed;
    }

    hr = pssiReq->DoWork();
    if ( hr == HRESULT_FROM_WIN32(ERROR_IO_PENDING) )
    {
        //
        // No Cleanup, there is pending IO request.
        // completion routine is responsible perform proper cleanup
        //
        return HSE_STATUS_PENDING;
    }

    if ( SUCCEEDED( hr ) )
    {
        //
        // This request is completed. Do Cleanup before returning
        //
        delete pssiReq;
        return HSE_STATUS_SUCCESS;
    }
    
failed:
    {
        LPCSTR                  apsz[ 1 ];
        DWORD                   cch;
        LPSTR                   pchBuff;
        CHAR                    chTemp = '\0';

        apsz[ 0 ] = pecb->lpszPathInfo;
        
        //
        // Since FormatMessage() is lame and actually uses SEH and an
        // AV to determine when to resize its buffers, we have to truncate
        // the URL here.  Otherwise, on a machine with a UM debugger attached
        // , we will break on the 1st chance exception (unless debugger is
        // configured to ignore these exceptions which isn't the case.
        //
        
        if ( strlen( pecb->lpszPathInfo ) > SSI_MAX_FORMAT_LEN )
        {
            chTemp = pecb->lpszPathInfo[ SSI_MAX_FORMAT_LEN ];
            pecb->lpszPathInfo[ SSI_MAX_FORMAT_LEN ] = '\0';
        }

        cch = ::FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY  |
                                FORMAT_MESSAGE_FROM_HMODULE,
                                GetModuleHandle( SSI_DLL_NAME ),
                                SSINCMSG_LOG_ERROR,
                                0,
                                ( LPSTR ) &pchBuff,
                                0,
                                ( va_list *) apsz );

        if ( chTemp != '\0' )
        {
            pecb->lpszPathInfo[ SSI_MAX_FORMAT_LEN ] = chTemp;
        }

        if( cch )
        {
            strncpy( pecb->lpszLogData,
                     pchBuff,
                     (cch>HSE_LOG_BUFFER_LEN)?HSE_LOG_BUFFER_LEN:cch );
            pecb->lpszLogData[HSE_LOG_BUFFER_LEN-1] = 0;
            ::LocalFree( ( VOID * )pchBuff );
        }
        
        //
        // This request is completed. Do Cleanup before returning
        //
        delete pssiReq;
        return HSE_STATUS_ERROR;
    }
 }

BOOL
WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO * pver
    )
{
    pver->dwExtensionVersion = MAKELONG( 0, 1 );
    strcpy( pver->lpszExtensionDesc,
            "Server Side Include Extension DLL" );

    //
    // Get the cache instance for W3CORE.DLL
    //
    
    g_pFileCache = W3_FILE_INFO_CACHE::GetFileCache();
    if ( g_pFileCache == NULL )
    {
        return FALSE;
    }
            
    if ( FAILED( SSI_REQUEST::Initialize() ) )
    {
        return FALSE;
    }
    if ( FAILED( SSI_INCLUDE_FILE::Initialize() ) )
    {
        SSI_REQUEST::Terminate();
        return FALSE;
    }
        
    return TRUE;
}

BOOL
WINAPI
TerminateExtension(
    DWORD dwFlags
    )
{
    SSI_REQUEST::Terminate();
    SSI_INCLUDE_FILE::Terminate();
    
    W3CacheFlushAllCaches();
    
    return TRUE;
}

BOOL
WINAPI
DLLEntry(
    HINSTANCE hDll,
    DWORD     dwReason,
    LPVOID    lpvReserved
    )
{
    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        CREATE_DEBUG_PRINT_OBJECT( "ssinc" );

        DisableThreadLibraryCalls( hDll );
        InitializeSSIGlobals();
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        break;

    default:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\sfwp\w3ssl\w3ssl_service.cxx ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :
     w3ssl.cxx

   Abstract:
     SSL service for W3SVC.
     New SSL service is introduced to IIS6. 
     In the dedicated (new process mode) it will run 
     in lsass. That should boost ssl performance by eliminating
     context switches and interprocess communication during
     SSL handshakes.
     
     In the backward compatibility mode it will not do much.
     Service will register with http for ssl processing, but w3svc
     will register it's strmfilt and http.sys always uses the
     last registered filter so that the one loaded by inetinfo.exe 
     will be used.
 
   Author:
     Jaroslav Dunajsky  (Jaroslad)      04-16-2001

   Environment:
     Win32 - User Mode

   Project:
     Stream Filter Worker Process
--*/


#include "precomp.hxx"

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_DEBUG_VARIABLE();
DECLARE_PLATFORM_TYPE();


//
// instance of W3SSL_SERVICE
// must be static so that NotifyOfIISAdminFailureCallback() gets access
// to it.
//
W3SSL_SERVICE * s_pW3SSLServiceInstance = NULL;


//static
HRESULT
W3SSL_SERVICE::NotifyOfIISAdminFailure(
    INETINFO_CRASH_ACTION CrashAction
    )
/*++

Routine Description:

    Callback function to handle the different issues arrising from inetinfo
    crashing.

    StartIISAdminMonitor() takes pointer to this function

Arguments:

    INETINFO_CRASH_ACTION CrashAction

Return Value:

    HRESULT.

--*/

{
    HRESULT hr = S_OK;

    switch ( CrashAction )
    {
        case NotifyAfterInetinfoCrash:
            //
            // Inetinfo crashed. W3SSL will not be able to read SSL parameters from metabase
            //
            // CODEWORK - handle notification
            //
            DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Notification received that inetinfo crashed\n"
                    ));
            break;

        case ShutdownAfterInetinfoCrash:
            //
            // Call shutdown
            //
        
            DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Stopping the service because inetinfo crashed\n"
                    ));

            DBG_ASSERT( s_pW3SSLServiceInstance != NULL );
            s_pW3SSLServiceInstance->ControlHandler( SERVICE_CONTROL_STOP );
            
            break;           
            
        case  RehookAfterInetinfoCrash:
            //
            // CODEWORK - rehook to metabase without restarting the service
            //

            DBGPRINTF(( 
                    DBG_CONTEXT,
                    "Recovering from inetinfo crash was requested\n"
                    ));
            break;
        default:
            DBG_ASSERT( FALSE );
    }

    return hr;
}


//
// Implementation of W3SSL_SERVICE methods
//

//virtual
HRESULT
W3SSL_SERVICE::OnServiceStart(
    VOID
    )
/*++

    Routine:
        Initialize W3SSL and start service. 
        It initializes necessary structures and modules. If there is no error then
        after returning from function W3SSL service will be in SERVICE_STARTED state
                
    Arguments:
        
    Returns:
        None. 

--*/
{
    HRESULT                 hr = S_OK;
    STREAM_FILTER_CONFIG    sfConfig;
    IMSAdminBase *          pAdminBase = NULL;

    DBG_ASSERT( _InitStatus == INIT_NONE );

    

    //
    // Do that COM thing
    //

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( FAILED( hr ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));

        goto Finished;
    }
    _InitStatus = INIT_COM;

    //
    // Set security impersonation level to impersonate so metabase sink 
    // notifications will work.
    //
    
    hr = CoInitializeSecurity( NULL,
                               -1,
                               NULL,
                               NULL,
                               RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IMPERSONATE,
                               NULL,
                               EOAC_NONE,
                               NULL );

    //
    // Don't check for error since CoInitializeSecurity may have been called already
    //
    // if ( FAILED( hr ) )
    //{
    //    DBGPRINTF(( DBG_CONTEXT,
    //                "Error in CoInitializeSecurity().  hr = %x\n",
    //                hr ));
    //
    //    goto Finished;
    // }

    //
    // Start monitoring IIS Admin
    //
    
    hr = StartIISAdminMonitor( W3SSL_SERVICE::NotifyOfIISAdminFailure );

    if ( FAILED ( hr ) )
    {
        goto Finished;
    }
    _InitStatus = INIT_IISADMIN_MONITORING_STARTED;
   

    //
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *)&(pAdminBase) );
    if( FAILED(hr) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Finished;
    }
    else
    {
        MB mb( pAdminBase );
            
        if ( mb.Open( L"/LM/W3SVC/",
                  METADATA_PERMISSION_READ ) )
        {
            DWORD dwBackwardCompatibilityEnabled = 1;  // default is enabled
        
            //
            // lookup metabase is BackwardCompatibility is enabled 
            // if we fail to access metabase then we assume 
            // the default Backward compatibility mode
            //    

            mb.GetDword( L"",
                         MD_GLOBAL_STANDARD_APP_MODE_ENABLED,
                         IIS_MD_UT_SERVER,
                         &dwBackwardCompatibilityEnabled );
                     
            _fBackwardCompatibilityEnabled = !!dwBackwardCompatibilityEnabled;
            mb.Close();
        }

        //
        // Done with accessing metabase
        //  
    
        pAdminBase->Release();
        pAdminBase = NULL;
    }
    
    //
    // Initialize StreamFilter only in the New (dedicated) mode 
    //
    // CODEWORK: W3SSL needs to establish communication channel
    // so that W3SSL will be able to learn when w3svc is restarted and
    // changing modes (currently w3ssl is required to be restarted
    // along with w3svc when mode is changed)
    //
    
    if ( ! _fBackwardCompatibilityEnabled )
    {
    
        //
        // Initialize stream filter
        // ( enable only SSL )
        //
    
        sfConfig.fSslOnly = TRUE;
        sfConfig.pfnRawRead = NULL;
        sfConfig.pfnRawWrite = NULL;
        sfConfig.pfnConnectionClose = NULL;
    
        hr = StreamFilterInitialize( &sfConfig );
        if ( FAILED( hr ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in StreamFilterInitialize().  hr = %x\n",
                        hr ));

            goto Finished;
        }

        _InitStatus = INIT_STREAMFILTER;

    
        //
        // Start listening
        //
    
        hr = StreamFilterStart();
        if ( FAILED( hr ) )
        {
             DBGPRINTF(( DBG_CONTEXT,
                        "Error in StreamFilterStart().  hr = %x\n",
                        hr ));
         
            goto Finished;
        }
        _InitStatus = INIT_STREAMFILTER_STARTED;
    }
    
Finished:
    
    if (FAILED ( hr ) )
    {
        //
        // OnServiceStop() will assure proper cleanup
        //
        OnServiceStop();
    }
    
    return hr;
}


//virtual
HRESULT
W3SSL_SERVICE::OnServiceStop(
    VOID
)
/*++

    Routine:
        Terminate W3SSL service. Performs cleanup
        
        _InitStatus is used to determine where to start with cleanup.

        OnServiceStop() is also used in OnServiceStart() for cleanup in the error case
                
    Arguments:
    
        
    Returns:
        HRESULT - will be reported to SCM 

--*/
{
    HRESULT     hr = S_OK;

    //
    // Cases in the switch command don't have "break" command
    // on purpose. _InitStatus indicates how for the initialization has gone
    // and that indicates where cleanup should start
    //

    switch( _InitStatus )
    {
       
    case INIT_STREAMFILTER_STARTED:
        if ( !_fBackwardCompatibilityEnabled )
        {

            //
            // Stop Listening
            //
            hr = StreamFilterStop();
            if ( FAILED( hr ) )
            {
                 DBGPRINTF(( DBG_CONTEXT,
                            "Error in StreamFilterStop().  hr = %x\n",
                            hr ));
            }
        }   
    case INIT_STREAMFILTER:
        if ( !_fBackwardCompatibilityEnabled )
        {
            StreamFilterTerminate();        
        }    
    case INIT_IISADMIN_MONITORING_STARTED:
        //
        // Stop monitoring IIS Admin
        //

        StopIISAdminMonitor();
          
    case INIT_COM:
        CoUninitialize();
        
    case INIT_NONE:        
        break;
    default:
        DBG_ASSERT( FALSE );
    }    
   
    return hr;
    
}

VOID 
W3SSLServiceMain(
    DWORD                   /*argc*/,
    LPWSTR                  /*argv*/[]
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
        the Service Controller dispatcher is requested to
        start a service, it creates a thread that will begin
        executing this routine.
                
        Note: W3SSLServiceMain name is recognized by lsass as entrypoint 
        for w3ssl service
                
    Arguments:
        argc - Number of command line arguments to this service.
        argv - Pointers to the command line arguments.
        
    Returns:
        None.  Does not return until service is stopped.

--*/
{
    HRESULT hr = E_FAIL;

    //
    // Code work - there is probably possibility that after service is stopped
    // that starting service may cause new thread to enter this function 
    // before previous one fully cleaned up and returned
    //
    DBG_ASSERT( s_pW3SSLServiceInstance == NULL );
    
    s_pW3SSLServiceInstance = new W3SSL_SERVICE;
    if( s_pW3SSLServiceInstance != NULL )
    {
        hr = s_pW3SSLServiceInstance->RunService();

        //
        // hr will be ignored.
        // Return value has only informational value in this moment
        // if anything failed, SCM would be informed about the error
        //

        delete s_pW3SSLServiceInstance;
        s_pW3SSLServiceInstance = NULL;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\makefile.inc ===
$(O)\iiswp.res: iiswp.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\tokencache\tokencache.cxx ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      tokencache.cxx

   Abstract:

      Ming's token cache refactored for general consumption

   Author:

      Bilal Alam            (balam)         May-4-2000

   Revision History:

--*/

#include <iis.h>
#include "dbgutil.h"
#include <acache.hxx>
#include <string.hxx>
#include <tokencache.hxx>
#include <irtltoken.h>
#include <ntsecapi.h>
#include <wincrypt.h>

ALLOC_CACHE_HANDLER * TOKEN_CACHE_ENTRY::sm_pachTokenCacheEntry = NULL;

//
// Handle of a cryptographic service provider 
//
    
HCRYPTPROV            g_hCryptProv = NULL;

//static
HRESULT
TOKEN_CACHE_ENTRY::Initialize(
    VOID
)
/*++

  Description:

    Token entry lookaside initialization

  Arguments:

    None
    
  Return:

    HRESULT

--*/
{
    ALLOC_CACHE_CONFIGURATION   acConfig;
    HRESULT                     hr;    

    //
    // Initialize allocation lookaside
    //    
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold   = 100;
    acConfig.cbSize       = sizeof( TOKEN_CACHE_ENTRY );

    DBG_ASSERT( sm_pachTokenCacheEntry == NULL );
    
    sm_pachTokenCacheEntry = new ALLOC_CACHE_HANDLER( "TOKEN_CACHE_ENTRY",  
                                                      &acConfig );

    if ( sm_pachTokenCacheEntry == NULL )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

        DBGPRINTF(( DBG_CONTEXT,
                   "Error initializing sm_pachTokenCacheEntry. hr = 0x%x\n",
                   hr ));

        return hr;
    }
    
    return NO_ERROR;
}

//static
VOID
TOKEN_CACHE_ENTRY::Terminate(
    VOID
)
/*++

  Description:

    Token cache cleanup

  Arguments:

    None
    
  Return:

    None

--*/
{
    if ( sm_pachTokenCacheEntry != NULL )
    {
        delete sm_pachTokenCacheEntry;
        sm_pachTokenCacheEntry = NULL;
    }
}

HRESULT 
TOKEN_CACHE_ENTRY::Create(
    IN HANDLE                   hToken,
    IN LARGE_INTEGER           *pliPwdExpiry,
    IN BOOL                     fImpersonation
)
/*++

  Description:

    Initialize a cached token

  Arguments:

    hToken - Token
    liPwdExpiry - Password expiration time
    fImpersonation - Is hToken an impersonation token?

  Return:

    HRESULT

--*/
{
    if ( hToken == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    if ( fImpersonation )
    {
        m_hImpersonationToken = hToken;
    }
    else
    {
        m_hPrimaryToken = hToken;
    }
    
    if (pliPwdExpiry)
    {
        memcpy( ( VOID * )&m_liPwdExpiry,
                ( VOID * )pliPwdExpiry,
                sizeof( LARGE_INTEGER ) );
    }
                              
    return NO_ERROR;
}

HANDLE
TOKEN_CACHE_ENTRY::QueryImpersonationToken(
    VOID
)
/*++

  Description:

    Get impersonation token

  Arguments:

    None

  Return:

    Handle to impersonation token

--*/
{
    if ( m_hImpersonationToken == NULL )
    {
        LockCacheEntry();
        
        if ( m_hImpersonationToken == NULL )
        {
            DBG_ASSERT( m_hPrimaryToken != NULL );
            
            if ( !DuplicateTokenEx( m_hPrimaryToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenImpersonation,
                                    &m_hImpersonationToken ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                          "DuplicateTokenEx failed, GetLastError = %lx\n",
                          GetLastError() ));
            } 
            else
            {
                DBG_ASSERT( m_hImpersonationToken != NULL );

                //
                // Tweak the token so that all member of the worker process group
                // can access it, and so that it works correctly for OOP requests
                //

                HRESULT hr = GrantWpgAccessToToken( m_hImpersonationToken );

                DBG_ASSERT( SUCCEEDED( hr ) );

                hr = AddWpgToTokenDefaultDacl( m_hImpersonationToken );

                DBG_ASSERT( SUCCEEDED( hr ) );
            }
        }

        UnlockCacheEntry();    
    }
    
    return m_hImpersonationToken;
}
    
HANDLE
TOKEN_CACHE_ENTRY::QueryPrimaryToken(
    VOID
)
/*++

  Description:

    Get primary token

  Arguments:

    None

  Return:

    Handle to primary token

--*/
{
    if ( m_hPrimaryToken == NULL )
    {
        LockCacheEntry();
        
        if ( m_hPrimaryToken == NULL )
        {
            DBG_ASSERT( m_hImpersonationToken != NULL );
            
            if ( !DuplicateTokenEx( m_hImpersonationToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &m_hPrimaryToken ) )
            {
                DBGPRINTF(( DBG_CONTEXT,
                          "DuplicateTokenEx failed, GetLastError = %lx\n",
                          GetLastError() ));
            } 
            else
            {
                DBG_ASSERT( m_hPrimaryToken != NULL );
            }
        }
    
        UnlockCacheEntry();
    }
    
    return m_hPrimaryToken;
}

PSID
TOKEN_CACHE_ENTRY::QuerySid(
    VOID
)
/*++

  Description:

    Get the sid for this token

  Arguments:

    None

  Return:

    Points to SID buffer owned by this object

--*/
{
    BYTE                abTokenUser[ SID_DEFAULT_SIZE + sizeof( TOKEN_USER ) ];
    TOKEN_USER *        pTokenUser = (TOKEN_USER*) abTokenUser;
    BOOL                fRet;
    HANDLE              hImpersonation;
    DWORD               cbBuffer;
    
    hImpersonation = QueryImpersonationToken();
    if ( hImpersonation == NULL )
    {
        return NULL;
    }
      
    if ( m_pSid == NULL )
    {
        LockCacheEntry();
    
        fRet = GetTokenInformation( hImpersonation,
                                    TokenUser,
                                    pTokenUser,
                                    sizeof( abTokenUser ),
                                    &cbBuffer );
        if ( fRet )
        {
            //
            // If we can't get the sid, then that is OK.  We're return NULL
            // and as a result we will do the access check always
            //
            
            memcpy( m_abSid,
                    pTokenUser->User.Sid,
                    sizeof( m_abSid ) );
                    
            m_pSid = m_abSid;
        }
        
        UnlockCacheEntry();
    }
    
    return m_pSid;
}

HRESULT
TOKEN_CACHE_KEY::GenMD5HashKey(
    IN  STRU & strKey,
    OUT STRA * strHashKey
)
/*++

  Description:

    Generate MD5 hash key used for token cache

  Arguments:

    strKey - string to be MD5 hashed
    strHashKey - MD5 hashed string

  Return:

    HRESULT

--*/
{
    HRESULT       hr;
    DWORD         dwError;
    HCRYPTHASH    hHash = NULL;
    DWORD         dwHashDataLen;
    STACK_BUFFER( buffHashData, DEFAULT_MD5_HASH_SIZE );

    if ( !CryptCreateHash( g_hCryptProv,
                           CALG_MD5,
                           0,
                           0,
                           &hHash ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptCreateHash() failed : hr = 0x%x\n", 
                   hr ));

        return hr;
    }

    if ( !CryptHashData( hHash,
                         ( BYTE * )strKey.QueryStr(),
                         strKey.QueryCB(),
                         0 ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF((DBG_CONTEXT,
                   "CryptHashData() failed : hr = 0x%x\n", 
                   hr ));
        
        goto exit;
    }

    dwHashDataLen = DEFAULT_MD5_HASH_SIZE;
    
    if ( !CryptGetHashParam( hHash,
                             HP_HASHVAL,
                             ( BYTE * )buffHashData.QueryPtr(),
                             &dwHashDataLen,
                             0 ) )
    {
        dwError = GetLastError();

        if( dwError == ERROR_MORE_DATA )
        {
            if( !buffHashData.Resize( dwHashDataLen ) )
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            if( !CryptGetHashParam( hHash,
                                    HP_HASHVAL,
                                    ( BYTE * )buffHashData.QueryPtr(),
                                    &dwHashDataLen,
                                    0 ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() ); 

                goto exit;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32( dwError );

            goto exit;
        }
    }

    //
    // Convert binary data to ASCII hex representation
    //

    hr = ToHex( buffHashData, _strHashKey );

exit:

    CryptDestroyHash( hHash );

    ZeroMemory( ( VOID * )strKey.QueryStr(), strKey.QueryCB() );

    return hr;    
}    

HRESULT
TOKEN_CACHE_KEY::CreateCacheKey(
    WCHAR *                 pszUserName,
    WCHAR *                 pszDomainName,
    WCHAR *                 pszPassword,
    DWORD                   dwLogonMethod
)
/*++

  Description:

    Build the key used for token cache

  Arguments:

    pszUserName - User name
    pszDomainName - Domain name
    pszPassword - Password
    dwLogonMethod - Logon method

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    WCHAR               achNum[ 64 ];
    STACK_STRU(         strKey, 64 ); 
    
    if ( pszUserName == NULL ||
         pszDomainName == NULL ||
         pszPassword == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    hr = strKey.Copy( pszUserName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = strKey.Append( pszDomainName );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    hr = strKey.Append( pszPassword );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    _ultow( dwLogonMethod, achNum, 10 );
    
    hr = strKey.Append( achNum );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    return GenMD5HashKey( strKey, &_strHashKey );
}

HRESULT
TOKEN_CACHE::Initialize(
    VOID
)
/*++

  Description:

    Initialize token cache

  Arguments:

    None

  Return:

    HRESULT

--*/
{
    HRESULT             hr;
    DWORD               dwData;
    DWORD               dwType;
    DWORD               cbData = sizeof( DWORD );
    DWORD               csecTTL = DEFAULT_CACHED_TOKEN_TTL;
    HKEY                hKey;

    //
    // What is the TTL for the token cache
    //
    
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       L"System\\CurrentControlSet\\Services\\inetinfo\\Parameters",
                       0,
                       KEY_READ,
                       &hKey ) == ERROR_SUCCESS )
    {
        DBG_ASSERT( hKey != NULL );
        
        if ( RegQueryValueEx( hKey,
                              L"LastPriorityUPNLogon",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            m_dwLastPriorityUPNLogon = dwData;
        }

        if ( RegQueryValueEx( hKey,
                              L"UserTokenTTL",
                              NULL,
                              &dwType,
                              (LPBYTE) &dwData,
                              &cbData ) == ERROR_SUCCESS &&
             dwType == REG_DWORD )
        {
            csecTTL = dwData;
        }

        RegCloseKey( hKey );
    }                      
    
    //
    // We'll use TTL for scavenge period, and expect two inactive periods to
    // flush
    //
    
    hr = SetCacheConfiguration( csecTTL * 1000,
                                csecTTL * 1000,
                                0,
                                NULL );
    if ( FAILED( hr ) )
    {
        return hr;
    }

    //
    //  Get a handle to the CSP we'll use for our MD5 hash functions.
    //
    
    if ( !CryptAcquireContext( &g_hCryptProv,
                               NULL,
                               NULL,
                               PROV_RSA_FULL,
                               CRYPT_VERIFYCONTEXT ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        DBGPRINTF(( DBG_CONTEXT,
                    "CryptAcquireContext() failed. hr = 0x%x\n", 
                    hr ));

        return hr;
    }
        
    return TOKEN_CACHE_ENTRY::Initialize();
}

VOID
TOKEN_CACHE::Terminate(
    VOID
)
/*++

  Description:

    Terminate token cache

  Arguments:

    None

  Return:

    None

--*/
{
    if ( g_hCryptProv )
    {
        CryptReleaseContext( g_hCryptProv, 0 );

        g_hCryptProv = NULL;
    }

    return TOKEN_CACHE_ENTRY::Terminate();
}

HRESULT
TOKEN_CACHE::GetCachedToken(
    IN LPWSTR                   pszUserName,
    IN LPWSTR                   pszDomain,
    IN LPWSTR                   pszPassword,
    IN DWORD                    dwLogonMethod,
    IN BOOL                     fPossibleUPNLogon,
    OUT TOKEN_CACHE_ENTRY **    ppCachedToken,
    OUT DWORD *                 pdwLogonError,
    BOOL                        fAllowLocalSystem  /* = FALSE */
)
/*++

  Description:

    Get cached token (the friendly interface for the token cache)

  Arguments:

    pszUserName - User name
    pszDomain - Domain name
    pszPassword - Password
    dwLogonMethod - Logon method (batch, interactive, etc)
    fPossibleUPNLogon - TRUE if we may need to do UPN logon, 
                        otherwise FALSE
    ppCachedToken - Filled with cached token on success
    pdwLogonError - Set to logon failure if *ppCacheToken==NULL
    pszDefaultDomain - Default domain specified in metabase

  Return:

    HRESULT

--*/
{
    TOKEN_CACHE_KEY             tokenKey;
    TOKEN_CACHE_ENTRY *         pCachedToken;
    HRESULT                     hr;
    HANDLE                      hToken = NULL;
    LARGE_INTEGER               liPwdExpiry;
    LPVOID                      pProfile        = NULL;
    DWORD                       dwProfileLength = 0;
    WCHAR *                     pszAtSign       = NULL;
    WCHAR *                     pDomain[2];

    if ( pszUserName == NULL ||
         pszDomain == NULL ||
         pszPassword == NULL ||
         ppCachedToken == NULL ||
         pdwLogonError == NULL )
    {
        DBG_ASSERT( FALSE );
        return HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
    }
    
    *ppCachedToken = NULL;
    *pdwLogonError = ERROR_SUCCESS;

    //
    // Find the key to look for
    //

    hr = tokenKey.CreateCacheKey( pszUserName,
                                  pszDomain,
                                  pszPassword,
                                  dwLogonMethod );
    if ( FAILED( hr ) )
    {
        return hr;
    }
    
    //
    // Look for it
    //
    
    hr = FindCacheEntry( &tokenKey,
                         (CACHE_ENTRY**) ppCachedToken );
    if ( SUCCEEDED( hr ) )
    {
        DBG_ASSERT( *ppCachedToken != NULL );
        return hr;
    }

    //
    // Ok.  It wasn't in the cache, create a token and add it
    //
    
    if ( fAllowLocalSystem && 
         0 == _wcsicmp(L"LocalSystem", pszUserName) )
    {        
        if (!OpenProcessToken(
                        GetCurrentProcess(),                // handle to process
                        TOKEN_ALL_ACCESS,                   // desired access
                        &hToken                             // returned token
                        ) )
        {
            //
            // If we couldn't logon, then return no error.  The caller will
            // determine failure due to *ppCachedToken == NULL
            //
            
            *pdwLogonError = GetLastError();            
            hr = NO_ERROR;
            goto ExitPoint;
        }

        //
        // OpenProcessToken gives back a primary token
        // Below in the call to pCachedToken->Create we decide
        // if the token is an impersonation token or not based
        // on the LogonMethod.  We know this is a primary token
        // therefor we set the LogonMethod here
        //
        dwLogonMethod = LOGON32_LOGON_SERVICE;
    }
    else 
    {
        pszAtSign = wcschr( pszUserName, L'@' );
        if( pszAtSign != NULL && fPossibleUPNLogon )
        { 
            if( !m_dwLastPriorityUPNLogon )
            {
                //
                // Try UPN logon first
                //
                pDomain[0] = L"";
                pDomain[1] = pszDomain;
            }
            else
            {
                //
                // Try default domain logon first
                //
                pDomain[0] = pszDomain;
                pDomain[1] = L"";
            }

            if(!LogonUserEx( pszUserName,
                             pDomain[0],
                             pszPassword,
                             dwLogonMethod,
                             LOGON32_PROVIDER_DEFAULT,
                             &hToken,
                             NULL,              // Logon sid
                             &pProfile,
                             &dwProfileLength,
                             NULL               // Quota limits 
                             ) )
            {
                *pdwLogonError = GetLastError();
                if( *pdwLogonError == ERROR_LOGON_FAILURE )
                {
                    if(!LogonUserEx( pszUserName,
                                     pDomain[1],
                                     pszPassword,
                                     dwLogonMethod,
                                     LOGON32_PROVIDER_DEFAULT,
                                     &hToken,
                                     NULL,              // Logon sid
                                     &pProfile,
                                     &dwProfileLength,
                                     NULL               // Quota limits 
                                     ) )
                    {                            
                        //
                        // If we couldn't logon, then return no error.  The caller will
                        // determine failure due to *ppCachedToken == NULL
                        //
    
                        *pdwLogonError = GetLastError();
                        hr = NO_ERROR;
                        goto ExitPoint;
                    }
                }
            }
        }
        else
        {
            //
            // The user name is absolutely not in UPN format 
            //

            if(!LogonUserEx( pszUserName,
                             pszDomain,
                             pszPassword,
                             dwLogonMethod,
                             LOGON32_PROVIDER_DEFAULT,
                             &hToken,
                             NULL,              // Logon sid
                             &pProfile,
                             &dwProfileLength,
                             NULL               // Quota limits 
                             ) )
            {
                //
                // If we couldn't logon, then return no error.  The caller will
                // determine failure due to *ppCachedToken == NULL
                //
        
                *pdwLogonError = GetLastError();
                hr = NO_ERROR;
                goto ExitPoint;
            }
        }
    }

    //
    // Create the entry
    //

    pCachedToken = new TOKEN_CACHE_ENTRY( this );
    if ( pCachedToken == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }
    
    //
    // Set the cache key
    //
    
    hr = pCachedToken->SetCacheKey( &tokenKey );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }

    if ( dwLogonMethod == LOGON32_LOGON_NETWORK )
    {
        //
        // Tweak the token so that all member of the worker process group
        // can access it, and so that it works correctly for OOP requests
        //
        // Note that we only do this for impersonation tokens.  In the case
        // of a primary token, the TOKEN_CACHE_ENTRY::QueryImpersonationToken
        // will do it.
        //

        hr = GrantWpgAccessToToken( hToken );

        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }

        hr = AddWpgToTokenDefaultDacl( hToken );

        if ( FAILED( hr ) )
        {
            goto ExitPoint;
        }
    }
   
    //
    // Get the password expiration information for the current user
    //

    //
    // Set the token/properties
    //
    
    hr = pCachedToken->Create( hToken,
                               pProfile ? 
                               &(( ( PMSV1_0_INTERACTIVE_PROFILE )pProfile )->PasswordMustChange) :
                               NULL,
                               dwLogonMethod == LOGON32_LOGON_NETWORK );
    if ( FAILED( hr ) )
    {
        goto ExitPoint;
    }
    
    AddCacheEntry( pCachedToken );

    //
    // Return it
    //
    
    *ppCachedToken = pCachedToken;

ExitPoint:
    if ( FAILED( hr ) )
    {
        if ( pCachedToken != NULL )
        {
            pCachedToken->DereferenceCacheEntry();
        }
        if ( hToken != NULL )
        {
            CloseHandle( hToken );
        }
    }

    if ( pProfile != NULL )
    {
        LsaFreeReturnBuffer( pProfile );
    }
        
    return hr;
}

HRESULT
ToHex(
    IN  BUFFER & buffSrc,
    OUT STRA   & strDst
)
/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    buffSrc - binary data to convert
    strDst - buffer receiving ASCII representation of pSrc

Return Value:

    HRESULT

--*/
{
#define TOHEX(a) ( (a) >= 10 ? 'a' + (a) - 10 : '0' + (a) )

    HRESULT hr = S_OK;
    PBYTE   pSrc;
    PCHAR   pDst;

    hr = strDst.Resize( 2 * buffSrc.QuerySize() + 1 );
    if( FAILED( hr ) )
    {
        goto exit;
    }

    pSrc = ( PBYTE ) buffSrc.QueryPtr();
    pDst = strDst.QueryStr();

    for ( UINT i = 0, j = 0 ; i < buffSrc.QuerySize() ; i++ )
    {
        UINT v;
        v = pSrc[ i ] >> 4;
        pDst[ j++ ] = TOHEX( v );
        v = pSrc[ i ] & 0x0f;
        pDst[ j++ ] = TOHEX( v );
    }

    DBG_REQUIRE( strDst.SetLen( j ) );

exit:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\dbgutil.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation

Module Name:

    dbgutil.h

Abstract:

    This module declares the macros to wrap around DEBUG_PRINTS class
    defined in pudebug.h    
  
    This is the exported header file, that the users are allowed to modify.
    If there are no custom definitions, please use the templated version
    in the root iisrearc\inc\dbgutil.h
 
Author:

    Murali R. Krishnan (MuraliK)    22-Sept-1994

--*/


# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_



// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputKdb )

// end_user_modifiable


//
// include standard debug support
//
// note: define DEFAULT_OUTPUT_FLAGS before including pudebug.h
//

# include <pudebug.h>


// begin_user_modifiable

// Use the default constants from pudebug.h: 0x00000001 to 0x00000100

//
//  Define the debugging constants as bit-flag values
//  Example: # define DEBUG_FOOBAR 0x00010000
//  Note: All debugging bit-values below 0x00001000 are reserved!
// 
//  If you add or change a flag, please update FlagTableWp
//  in core\common\dtflags\dtflags.c
//

# define    DEBUG_UL_CALLS             0x00010000

# define    DEBUG_NREQ                 0x00040000
# define    DEBUG_WPIPM                0x00080000
# define    DEBUG_WPRECYCLER           0x00100000

# define    DEBUG_TRACE                0x10000000
# define    DEBUG_DUMPS                0x20000000

#if DBG

//
// handy trace macro
//
#define WpTrace(a, _b_)     \
do {                        \
    IF_DEBUG(##a)           \
    {                       \
        PuDbgPrint _b_ ;      \
    }                       \
}while (0)

#else // !DBG

#define WpTrace(a, _b_)        ((void) 0)  /* do nothing */

#endif



// end_user_modifiable


# endif  /* _DBGUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\apppool.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     AppPool.cxx

   Abstract:
     Defines the functions used to access the data channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     20-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/

#include "precomp.hxx"
#include "AppPool.hxx"

UL_APP_POOL::UL_APP_POOL(
    VOID
) : _hAppPool( NULL )
{
}

UL_APP_POOL::~UL_APP_POOL(
    VOID
)
{
    Cleanup();
}

HRESULT
UL_APP_POOL::Initialize( 
    LPCWSTR             pwszAppPoolName
)
/*++

Routine Description:

    Initialize UL AppPool

Arguments:

    pwszAppPoolName - AppPool Name
    
Return Value:

    HRESULT

--*/
{
    ULONG               rc;
    
    if ( _hAppPool != NULL )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "AppPool already open!\n" ));
        
        return HRESULT_FROM_WIN32( ERROR_DUP_NAME );
    }
    
    rc = HttpOpenAppPool( &_hAppPool,
                          pwszAppPoolName,               
                          HTTP_OPTION_OVERLAPPED );
    if ( rc != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Failed to open AppPool '%ws'.  rc = %d\n",
                    pwszAppPoolName,
                    rc ));
        
        return HRESULT_FROM_WIN32( rc );
    }

    return NO_ERROR;
}

HRESULT
UL_APP_POOL::Cleanup(
    VOID
)
/*++

Routine Description:

    Close data channel

Arguments:

    None
    
Return Value:

    HRESULT

--*/
{ 
    HRESULT             hr = NO_ERROR;

    if ( _hAppPool != NULL )  
    {
        if ( !CloseHandle( _hAppPool ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
        }
        else 
        {
            _hAppPool = NULL;
        }
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\ipm_io_c.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    ipm_io_c.hxx

Abstract:

    This module contains classes for doing async io in the
    worker process.
    
Author:

    Michael Courage (MCourage)  22-Feb-1999

Revision History:

--*/


#include "precomp.hxx"
#include "ipm.hxx"  
#include "ipm_io_c.hxx"


/**
 *  IPMOverlappedCompletionRoutine()
 *  Callback function provided in ThreadPoolBindIoCompletionCallback.
 *  This function is called by NT thread pool.
 *
 *  dwErrorCode                 Error Code
 *  dwNumberOfBytesTransfered   Number of Bytes Transfered
 *  lpOverlapped                Overlapped structure
 */
VOID
WINAPI
IPMOverlappedCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    )
{
    IO_CONTEXT_C * pIoContext = NULL;
    HRESULT        hr = HRESULT_FROM_WIN32(dwErrorCode);
    
    //
    // get the context object
    //
    if (lpOverlapped != NULL)
    {
        pIoContext = CONTAINING_RECORD(lpOverlapped, 
                                    IO_CONTEXT_C,
                                    m_Overlapped);
    }
    if ( pIoContext != NULL) 
    { 
        WpTrace(WPIPM, (
            DBG_CONTEXT,
            "\n    IPMOverlappedCompletionRoutine(%d, %x, pIoContext %x) %s\n",
            dwNumberOfBytesTransfered,
            dwErrorCode,
            pIoContext,
            pIoContext->m_IoType == IPM_IO_WRITE ? "WRITE" : "READ"
            ));
        
        //
        // do the notification
        //
        switch (pIoContext->m_IoType) {
        case IPM_IO_WRITE:
            pIoContext->m_pContext->NotifyWriteCompletion(
                pIoContext->m_pv,
                dwNumberOfBytesTransfered,
                hr
                );
            break;

        case IPM_IO_READ:
            pIoContext->m_pContext->NotifyReadCompletion(
                pIoContext->m_pv,
                dwNumberOfBytesTransfered,
                hr
                );
            break;

        default:
            DBG_ASSERT(FALSE);
            break;
        }

        delete pIoContext;
    } 

    return;
}

/**
 *
 *  Routine Description:
 *   
 *   
 *  Creates an i/o handler
 *   
 *  Arguments:
 *
 *   hPipe           - A handle to the named pipe to be handled
 *   ppPipeIoHandler - receives a pointer to the handler on success
 *   
 *  Return Value:
 *
 *   HRESULT
 */
HRESULT
IO_FACTORY_C::CreatePipeIoHandler(
    IN  HANDLE             hPipe,
    OUT PIPE_IO_HANDLER ** ppPipeIoHandler
    )
{
    HRESULT        hr = S_OK;
    IO_HANDLER_C * pHandler;
    //
    // create the object
    //

    pHandler = new IO_HANDLER_C(hPipe);
    
    if (pHandler) 
    {
        BOOL           fBind;
        //
        // bind handle to completion port
        //
        
        fBind = ThreadPoolBindIoCompletionCallback(
                        pHandler->GetAsyncHandle(),        
                        IPMOverlappedCompletionRoutine,        
                        0 );
        if (fBind) {
            *ppPipeIoHandler = pHandler;
            InterlockedIncrement(&m_cPipes);

            pHandler->Reference();

            WpTrace(WPIPM, (
                DBG_CONTEXT,
                "Created IO_HANDLER_C (%x) - m_cPipes = %d\n",
                pHandler,
                m_cPipes
                ));                
        } 
        else 
        {
            // Error in XspBindIoCompletionCallback()
            LONG   rc = GetLastError();
            delete pHandler;
            pHandler = NULL;

            
            WpTrace(WPIPM, (DBG_CONTEXT, "Create IO_HANDLER_C failed, %d\n", rc));
            hr = HRESULT_FROM_WIN32(rc);
        }
    } 
    else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    return hr;
}


/**
 *
 *  Routine Description:
 *
 *   Closes an i/o handler
 *   
 *   Arguments:
 *
 *   pPipeIoHandler - pointer to the handler to be closed
 *   
 *   Return Value:
 *
 *   HRESULT
 */
HRESULT
IO_FACTORY_C::ClosePipeIoHandler(
    IN PIPE_IO_HANDLER * pPipeIoHandler
    )
{
    IO_HANDLER_C * pIoHandler = (IO_HANDLER_C *) pPipeIoHandler;
    LONG           cPipes;

    if (pIoHandler) {
        cPipes = InterlockedDecrement(&m_cPipes);

        WpTrace(WPIPM, (
            DBG_CONTEXT,
            "Closed IO_HANDLER_C (%x) - m_cPipes = %d\n",
            pPipeIoHandler,
            m_cPipes
            ));

        DBG_ASSERT( cPipes >= 0 );
        
        pIoHandler->Dereference();

        return S_OK;
    } else {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }
}


/**
 * Disconnect()
 * Routine Description:
 *
 *   Disconnects the named pipe
 *   
 * Arguments:
 *
 *   None.
 *
 * Return Value:
 *
 *   HRESULT
 *
 */
HRESULT
IO_HANDLER_C::Disconnect(
    VOID
    )
{
    HRESULT hr = S_OK;

    CheckSignature();

    if (!CloseHandle(GetHandle())) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/**
 *
 *Routine Description:
 *
 *    Writes data to the pipe
 *    
 *Arguments:
 *
 *    pContext - the context to be notified on completion
 *    pv       - a parameter passed to the context
 *    pBuff    - the data to send
 *    cbBuff   - number of bytes in the data
 *    
 *Return Value:
 *
 *    HRESULT
 */
HRESULT
IO_HANDLER_C::Write(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN const BYTE * pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_WRITE;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // write to the pipe
        //
        hr = IpmWriteFile(
                    GetHandle(),
                    (PVOID) pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );

        if (FAILED(hr))
        {
            Dereference();              
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}


/**
 *
 *Routine Description:
 *
 *    Reads data from the pipe
 *    
 *Arguments:
 *
 *    pContext - the context to be notified on completion
 *    pv       - a parameter passed to the context
 *    pBuff    - the buffer that receives the data
 *    cbBuff   - size of the buffer
 *    
 *Return Value:
 *
 *    HRESULT
 */
HRESULT
IO_HANDLER_C::Read(
    IN IO_CONTEXT * pContext,
    IN PVOID        pv,
    IN BYTE *       pBuff,
    IN DWORD        cbBuff
    )
{
    HRESULT        hr = S_OK;
    IO_CONTEXT_C * pIoContext;

    CheckSignature();

    //
    // create a context
    //
    pIoContext = new IO_CONTEXT_C;
    if (pIoContext) {
        pIoContext->m_pContext = pContext;
        pIoContext->m_pv       = pv;
        pIoContext->m_IoType   = IPM_IO_READ;

        memset(&pIoContext->m_Overlapped, 0, sizeof(OVERLAPPED));

        Reference();
        //
        // read from the pipe
        //
        hr = IpmReadFile(
                    GetHandle(),
                    pBuff,
                    cbBuff,
                    &pIoContext->m_Overlapped
                    );

        if (FAILED(hr))
        {
            Dereference();
        }
    } else {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (FAILED(hr)) {
        delete pIoContext;
    }

    return hr;
}

//
// end ipm_io_c.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\controlchannel.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :
     ControlChannel.cxx

   Abstract:
     Defines the functions used to access the control channel.

   Author:

       Murali R. Krishnan    ( MuraliK )     15-Oct-1998
       Lei Jin               ( leijin  )     13-Apr-1999    Porting

   Project:

       IIS Worker Process

--*/


# include "precomp.hxx"
# include "ControlChannel.hxx"

/********************************************************************++

  UL_CONTROL_CHANNEL::Initialize()

  Description:
     This function initializes the control channel for given address, NSGO, 
     and host name. It opens the control channel, registers a virtual host,
     and NSGO. After that it registers the URL for which notifications are 
     to be handled within the NSGO.

  Arguments:


  Returns:

++********************************************************************/

ULONG 
UL_CONTROL_CHANNEL::Initialize( 
    IN MULTISZ& mszURLList,
    IN LPCWSTR  pwszAppPoolName
    )
{
    ULONG   rc;
    LPCWSTR pwszURL;

    if ( m_hControlChannel != NULL) 
    {
        //
        // There is already a control channel
        //
        
        DBGPRINTF(( DBG_CONTEXT, "Duplicate open of control channel\n"));
        return ERROR_DUP_NAME;
    }
    
    //
    // 1. Open a control channel object from the UL driver
    //
    
    rc = HttpOpenControlChannel( &m_hControlChannel, 0);

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG( ERROR)
        {
            DBGPRINTF(( DBG_CONTEXT, 
                        "UlOpenControlChannel() failed. Error = %08x. Returning\n", 
                        rc
                        ));
        }

        return (rc);
    }

    //
    // 2. Create a Config Group on this control channel
    //
    
    rc = HttpCreateConfigGroup( m_hControlChannel, &m_ConfigGroupId );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateConfigGroup failed. Error=%08x. Returning\n",
                       rc
                       ));
        }

        return rc;
    }

    //
    // 3. Insert all specified URLs into the config group
    //

    pwszURL = mszURLList.First();

    while (NULL != pwszURL)
    {
        rc = AddURLToConfigGroup(pwszURL);

        if (NO_ERROR != rc)
        {
            return rc;
        }

        pwszURL = mszURLList.Next(pwszURL);
    }

    //
    // 4. Activate the Control Channel and the Config Group
    //

    HTTP_ENABLED_STATE    ccState = HttpEnabledStateActive;

    rc = HttpSetControlChannelInformation( m_hControlChannel,
                                           HttpControlChannelStateInformation,
                                           &ccState,
                                           sizeof(ccState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate ControlChannel. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    HTTP_CONFIG_GROUP_STATE   cgState;

    cgState.Flags.Present = 1;
    cgState.State         = HttpEnabledStateActive;  
                                         
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupStateInformation,
                                        &cgState,
                                        sizeof(cgState));

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "Unable to activate Config Group. Error=%08x. Returning\n", rc
                        ));
        }

        return rc;
    }

    //
    // 5. Create an AppPool 
    //

    rc = HttpCreateAppPool( &m_hAppPool,
                            pwszAppPoolName,
                            0,
                            HTTP_OPTION_OVERLAPPED
                          );

    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlCreateAppPool failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }

        return rc;
    }
    
    //
    // 6. Associate AppPool with the config group
    //

    HTTP_CONFIG_GROUP_APP_POOL    AppPoolConfig;

    AppPoolConfig.Flags.Present = 1;
    AppPoolConfig.AppPoolHandle = m_hAppPool;
    
    rc = HttpSetConfigGroupInformation( m_hControlChannel,
                                        m_ConfigGroupId,
                                        HttpConfigGroupAppPoolInformation,
                                        &AppPoolConfig,
                                        sizeof(AppPoolConfig)
                                      );
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG(ERROR) 
        {
            DBGPRINTF(( DBG_CONTEXT, 
                       "UlSetConfigGroupInformation failed for AppPool '%ws'. Error=%08x. Returning\n",
                       pwszAppPoolName, rc
                        ));
        }
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Initialize()

/********************************************************************++
++********************************************************************/


ULONG 
UL_CONTROL_CHANNEL::Cleanup(void)
{ 
    ULONG rc = NO_ERROR;

    if ( m_hControlChannel != NULL) 
    {
        if ( ! HTTP_IS_NULL_ID(&m_ConfigGroupId) )
        {
            rc = HttpDeleteConfigGroup( m_hControlChannel, m_ConfigGroupId);
            HTTP_SET_NULL_ID(&m_ConfigGroupId);
        }

        if ( NULL != m_hAppPool )
        {
            if ( !::CloseHandle( m_hAppPool))
            {
                rc = GetLastError();
            }
        }

        m_hAppPool = NULL;
        
        if (!::CloseHandle( m_hControlChannel)) 
        {
            rc = GetLastError();
        }
        
        m_hControlChannel = NULL;
    }
    
    return (rc);
    
} // UL_CONTROL_CHANNEL::Cleanup()

/********************************************************************++
++********************************************************************/

ULONG
UL_CONTROL_CHANNEL::AddURLToConfigGroup( IN LPCWSTR  pwszURL)
{
    //
    //  Add the URL to the Config Group
    //

    ULONG rc;

    rc = HttpAddUrlToConfigGroup( m_hControlChannel,
                                  m_ConfigGroupId,
                                  pwszURL,
                                  0
                                );
    
    if ( NO_ERROR != rc) 
    {
        IF_DEBUG (ERROR)
        {
            DBGPRINTF((DBG_CONTEXT, 
                       "UlAddUrlToConfigGroup() failed. Error=%08x\n",
                       rc));
        }
    }

    return (rc);
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\uldisconnect.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     uldisconnect.cxx

   Abstract:
     UL_DISCONNECT_CONTEXT implementation
 
   Author:
     Bilal Alam             (balam)         15-Feb-2000

   Environment:
     Win32 - User Mode

   Project:
     W3DT.DLL
--*/

#include "precomp.hxx"

extern PFN_ULATQ_DISCONNECT         g_pfnDisconnect;

//
// UL_DISCONNECT_CONTEXT statics
//

LONG                    UL_DISCONNECT_CONTEXT::sm_cOutstanding;
ALLOC_CACHE_HANDLER *   UL_DISCONNECT_CONTEXT::sm_pachDisconnects;

VOID
UL_DISCONNECT_CONTEXT::DoWork( 
    DWORD                       cbData,
    DWORD                       dwError,
    LPOVERLAPPED                lpo
)
/*++

Routine Description:

    Handles async calls to UlWaitForDisconnect

Arguments:

    cbData - Amount of data on the completion (should be 0)
    dwError - Error on the completion
    lpo - overlapped
    
Return Value:

    None

--*/
{
    DBG_ASSERT( CheckSignature() );
    
    //
    // Our handling is simple.  We just call the disconnection completion
    // routine with the context passed thru UlAtqWaitForDisconnect
    //
    
    DBG_ASSERT( g_pfnDisconnect != NULL );
    
    g_pfnDisconnect( _pvContext );   
    
    //
    // We're done with the context, delete it now
    // 
    
    delete this;
}   

//static
VOID
UL_DISCONNECT_CONTEXT::WaitForOutstandingDisconnects(
    VOID
)
/*++

Routine Description:

    Wait for the outstanding UL_DISCONNECT_CONTEXTs to drain.  This will 
    happen when we close the AppPool handle to begin shutdown

Arguments:

    None
    
Return Value:

    None

--*/
{
    while ( sm_cOutstanding != 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "Waiting for %d disconnect contexts to drain\n",
                    sm_cOutstanding ));
        
        Sleep( 1000 );
    }
}

//static
HRESULT
UL_DISCONNECT_CONTEXT::Initialize(
    VOID
)
/*++

Routine Description:

    Initialize disconnect globals

Arguments:

    None
    
Return Value:

    HRESULT 

--*/
{
    ALLOC_CACHE_CONFIGURATION       acConfig;
    HRESULT                         hr = NO_ERROR;
    
    //
    // Setup allocation lookaside
    //
    
    acConfig.nConcurrency = 1;
    acConfig.nThreshold = 100;
    acConfig.cbSize = sizeof( UL_DISCONNECT_CONTEXT );

    DBG_ASSERT( sm_pachDisconnects == NULL );
    
    sm_pachDisconnects = new ALLOC_CACHE_HANDLER( "UL_DISCONNECT_CONTEXT",  
                                                   &acConfig );

    if ( sm_pachDisconnects == NULL )
    {
        return HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
    }
    
    return NO_ERROR;
}

//static
VOID
UL_DISCONNECT_CONTEXT::Terminate(
    VOID
)
/*++

Routine Description:

    Cleanup disconnect globals

Arguments:

    None
    
Return Value:

    None

--*/
{
    if ( sm_pachDisconnects != NULL )
    {
        delete sm_pachDisconnects;
        sm_pachDisconnects = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\iisplus\ulatq\workerrequest.cxx ===
/*++

   Copyright    (c)    2000    Microsoft Corporation

   Module Name :
     workerrequest.cxx

   Abstract:
     UL_NATIVE_REQUEST implementation
 
   Author:
     Murali R. Krishnan    ( MuraliK )     23-Oct-1998
     Lei Jin               ( leijin  )     13-Apr-1999    (Porting)

   Environment:
     Win32 - User Mode

   Project:
     ULATQ.DLL
--*/

#include "precomp.hxx"

//
// User supplied completion routines
//

extern PFN_ULATQ_NEW_REQUEST        g_pfnNewRequest;
extern PFN_ULATQ_IO_COMPLETION      g_pfnIoCompletion;

//
// UL_NATIVE_REQUEST statics
//

ULONG            UL_NATIVE_REQUEST::sm_cRequestsServed;
ULONG            UL_NATIVE_REQUEST::sm_cRestart;
LONG             UL_NATIVE_REQUEST::sm_RestartMsgSent;
LIST_ENTRY       UL_NATIVE_REQUEST::sm_RequestListHead;
CRITICAL_SECTION UL_NATIVE_REQUEST::sm_csRequestList;
DWORD            UL_NATIVE_REQUEST::sm_cRequests;
PTRACE_LOG       UL_NATIVE_REQUEST::sm_pTraceLog;
DWORD            UL_NATIVE_REQUEST::sm_cRequestsPending;
DWORD            UL_NATIVE_REQUEST::sm_cDesiredPendingRequests;
BOOL             UL_NATIVE_REQUEST::sm_fAddingRequests;
ALLOC_CACHE_HANDLER * UL_NATIVE_REQUEST::sm_pachNativeRequests;
SLIST_HEADER     UL_NATIVE_REQUEST::sm_ReadRequestListHead;
HANDLE           UL_NATIVE_REQUEST::sm_hReadRequestEvent = NULL;
HANDLE           UL_NATIVE_REQUEST::sm_hReadRequestThread = NULL;

UL_NATIVE_REQUEST::UL_NATIVE_REQUEST(
    VOID
) : _pbBuffer( _achBuffer ),
    _cbBuffer( sizeof( _achBuffer ) ),
    _cRefs( 1 )
{
    InitializeListHead( &_ListEntry );

    AddToRequestList();

    Reset();
    
    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE;
}

UL_NATIVE_REQUEST::~UL_NATIVE_REQUEST(
    VOID
)
{
    DBG_ASSERT( CheckSignature() );
    
    if ( !IsListEmpty( &_ListEntry ) )
    {
        RemoveFromRequestList();
    }
    
    DBG_ASSERT( _cRefs == 0 );
    
    if ( _pbBuffer != _achBuffer )
    {
        LocalFree( _pbBuffer );
        _pbBuffer = NULL;
    }

    _dwSignature = UL_NATIVE_REQUEST_SIGNATURE_FREE;
}

VOID
UL_NATIVE_REQUEST::Reset(
    VOID
)
/*++

Routine Description:

    Reset a UL_NATIVE_REQUEST for use in the request state machine

Arguments:

    None
    
Return Value:

    None

--*/
{
    _ExecState          = NREQ_STATE_START;
    _pvContext          = NULL;
    _cbAsyncIOData      = 0;
    _dwAsyncIOError     = NO_ERROR;
    _dwClientCertFlags  = 0;
    
    if ( _pbBuffer != _achBuffer )
    {
        LocalFree( _pbBuffer );
    }
    _pbBuffer           = _achBuffer;
    _cbBuffer           = sizeof( _achBuffer );

    ZeroMemory( &_Overlapped, sizeof(_Overlapped) );
}

VOID
UL_NATIVE_REQUEST::DoWork(
    DWORD                   cbData,
    DWORD                   dwError,
    LPOVERLAPPED            lpo
)
/*++

Routine Description:

    The driver of the state machine.  It is called off async completions and
    initially (with lpo=NULL) to kick off the state machine.

Arguments:

    cbData - Bytes completed
    dwError - Win32 Error of completion
    lpo - Pointer to OVERLAPPED passed in async call
    
Return Value:

    None

--*/
{
    NREQ_STATUS             Status = NSTATUS_NEXT;
    BOOL                    fError = FALSE;
       
    ReferenceWorkerRequest();
    
    if ( lpo != NULL )
    {
        //
        // This is an async completion.  Dereference the request to match 
        // the reference before posting async operation
        //
        
        DereferenceWorkerRequest();

        //
        // Save away the completion data for state handler use and debugging
        // purposes
        //
        
        _cbAsyncIOData = cbData;
        _dwAsyncIOError = dwError;
        
        ZeroMemory( &_Overlapped, sizeof( _Overlapped ) );
    }
    
    //
    // Keep on executing the state machine until a state handler returns
    // pending.  If so, the IO completion will continue the machine
    //
    // We also break out on error (typical case will be shutdown)
    //
    
    while ( !fError && Status == NSTATUS_NEXT )
    {
        switch ( _ExecState )
        {
        case NREQ_STATE_START:
            Status = DoStateStart();
            break;
        
        case NREQ_STATE_READ:
            Status = DoStateRead();
            break;
        
        case NREQ_STATE_PROCESS:
            Status = DoStateProcess();
            break;
            
        case NREQ_STATE_ERROR:
            fError = TRUE;
            DereferenceWorkerRequest( FALSE );
            break;
            
        case NREQ_STATE_CLIENT_CERT:
            Status = DoStateClientCertificate();
            break;
        
        default:
            fError = TRUE;
            DBG_ASSERT( FALSE );
            break;
        }
    }
    
    DereferenceWorkerRequest();
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateStart(
    VOID
)
/*++

Routine Description:

    The NREQ_START state.  This state does the initial read for a new HTTP 
    request (it passes a NULL request ID).  Continuing the read process (
    for example if the buffer is too small) happens in the NREQ_READ state.

Arguments:

    None
    
Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    //
    // If we are in shutdown, then just bail with error
    //

    if ( g_pwpContext->IsInShutdown() )
    {
        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }
    
    //
    // Have we served enough requests?
    //
    
    if ( sm_cRestart &&
         sm_cRequestsServed >= sm_cRestart )
    {
        //
        // Indicate to WAS such and the error out
        //

        if ( NeedToSendRestartMsg() )
        {
            g_pwpContext->SendMsgToAdminProcess( IPM_WP_RESTART_COUNT_REACHED );
        }
        
        _ExecState = NREQ_STATE_ERROR;
        return NSTATUS_NEXT;
    }

    //
    // Make an async call to HttpReceiveHttpRequest (on the ReadRequest
    // thread) to get the next request
    //
    
    _ExecState = NREQ_STATE_READ;

    InterlockedIncrement( (LPLONG) &sm_cRequestsPending );
    
    ReferenceWorkerRequest();

    //
    // Set the event only if the list was empty to start with, basically
    // try to get some batching
    //
    if (InterlockedPushEntrySList( &sm_ReadRequestListHead,
                                   &_ReadRequestListEntry ) == NULL)
    {
        SetEvent( sm_hReadRequestEvent );
    }

    return NSTATUS_PENDING;
}

// static
DWORD WINAPI
UL_NATIVE_REQUEST::ReadRequestThread(LPVOID)
/*++
    The thread which makes all the HttpReceiveHttpRequest calls so that
    on shutdown, we can cancel all of them by exiting this thread
--*/
{
    ULONG               rc;
    ULONG               cbRequired;
    PSINGLE_LIST_ENTRY  pListEntry;
    UL_NATIVE_REQUEST  *pRequest;
    HTTP_REQUEST_ID     RequestId;

    //
    // This is the initial read, therefore we don't know the request ID
    //

    HTTP_SET_NULL_ID( &RequestId );

    while (!g_pwpContext->IsInShutdown())
    {
        WaitForSingleObject( sm_hReadRequestEvent, INFINITE );

        while ( ( pListEntry = InterlockedPopEntrySList( &sm_ReadRequestListHead )) != NULL )
        {
            pRequest = CONTAINING_RECORD( pListEntry,
                                          UL_NATIVE_REQUEST,
                                          _ReadRequestListEntry );

            rc = HttpReceiveHttpRequest( g_pwpContext->GetAsyncHandle(),
                                         RequestId,
                                         HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                         (HTTP_REQUEST *) pRequest->_pbBuffer,
                                         pRequest->_cbBuffer,
                                         NULL,
                                         &pRequest->_Overlapped );

            if ( rc != ERROR_IO_PENDING )
            {
                //
                // Some error happened, basically kill this request
                //
                DBG_ASSERT( rc != NO_ERROR );

                //
                // Corresponding to AddRef before calling into this thread
                // (would have been deref'ed in the completion routine normally)
                //
                pRequest->DereferenceWorkerRequest( FALSE );

                InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

                pRequest->_ExecState = NREQ_STATE_ERROR;

                //
                // One more deref to kill this request
                //
                pRequest->DereferenceWorkerRequest( FALSE );
            }
        }
    }

    return 0;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateRead(
    VOID
)
/*++

Routine Description:

    The NREQ_READ state.  This state is responsible for producing a complete
    UL_HTTP_REQUEST for consumption by the NREQ_PROCESS state.  Note that 
    this may require another UlReceiveHttpRequest() if the initial was not
    supplied a large enough buffer.

Arguments:

    None
    
Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    HTTP_REQUEST_ID     RequestId;
    ULONG               cbRequired;
    DWORD               cCurrentRequestsPending;

    //
    // The initial read is complete.  If the error is ERROR_MORE_DATA, then
    // our buffer was not large enough.  Resize and try again
    //

    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // Remember the request ID to retry the the UlReceiveHttpRequest
        //
        RequestId = QueryRequestId();
        DBG_ASSERT( RequestId != HTTP_NULL_ID );

        //
        // We need to allocate a larger buffer :(
        //

        if ( _pbBuffer != _achBuffer )
        {
            //
            // We shouldn't be getting ERROR_MORE_DATA if we already 
            // resized due to an earlier ERROR_MORE_DATA
            //

            DBG_ASSERT( FALSE );
            LocalFree( _pbBuffer );
            _pbBuffer = NULL;
        }

        //
        // The completed bytes tells us the required size of our input 
        // buffer
        //

        _cbBuffer = _cbAsyncIOData; 
        _pbBuffer = (UCHAR*) LocalAlloc( LPTR, _cbBuffer );
        if ( _pbBuffer == NULL )
        {
            _ExecState = NREQ_STATE_ERROR;
            return NSTATUS_NEXT;
        }

        //
        // Read the HTTP request again (better to do it sychronously, since
        // it is all ready now)
        //

        _dwAsyncIOError = HttpReceiveHttpRequest(
                                 g_pwpContext->GetAsyncHandle(),
                                 RequestId,
                                 HTTP_RECEIVE_REQUEST_FLAG_COPY_BODY,
                                 (HTTP_REQUEST *)_pbBuffer,
                                 _cbBuffer,
                                 &cbRequired,
                                 NULL );

        //
        // No reason this should fail
        // BUGBUG: But it is failing with ERROR_MORE_DATA, need to let UL
        // folks investigate before I can turn this assert on
        //
        // DBG_ASSERT( _dwAsyncIOError == NO_ERROR );
    }

    if ( _dwAsyncIOError == NO_ERROR )
    {
        //
        // We're done.  The read was successful and we have a full
        // UL_HTTP_REQUEST.  We can now pass off to the NREQ_PROCESS state
        //

        cCurrentRequestsPending = InterlockedDecrement( (LPLONG)
                                                        &sm_cRequestsPending );

        if ( cCurrentRequestsPending < sm_cDesiredPendingRequests / 4 )
        {
            if ( !sm_fAddingRequests )
            {
                if ( InterlockedCompareExchange( (LPLONG) &sm_fAddingRequests,
                                                 TRUE,
                                                 FALSE ) == FALSE )
                {
                    AddPendingRequests( sm_cDesiredPendingRequests );

                    sm_fAddingRequests = FALSE;
                }
            }
        }        

        _ExecState = NREQ_STATE_PROCESS;
    }
    else
    {
        //
        // Some other error.  Lose the context.
        // 

        InterlockedDecrement( (LPLONG) &sm_cRequestsPending );

        _ExecState = NREQ_STATE_ERROR;
    }

    return NSTATUS_NEXT;
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateProcess(
    VOID
)
/*++

Routine Description:

    The NREQ_PROCESS state.  This state actually calls consumer of the 
    NewRequests and IoCompletions.  This state calls the set routines in
    W3CORE.DLL

Arguments:

    None
    
Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    WP_IDLE_TIMER *         pTimer;

    //
    // Reset idle tick since we're not idle if we're processing
    //
    
    pTimer = g_pwpContext->QueryIdleTimer();
    if ( pTimer != NULL )
    {
        pTimer->ResetCurrentIdleTick();
    }

    ReferenceWorkerRequest();
    
    if ( _pvContext == NULL )
    {
        //
        // Extra reference here.  The consumer must call UlAtqResetContext()
        // to finally cleanup.  This complication is brought on by 
        // scenarios where non-IO-completions are required to finish a request
        // (example: async ISAPI)
        //
        
        ReferenceWorkerRequest();
        
        DBG_ASSERT( g_pfnNewRequest != NULL );
        
        g_pfnNewRequest( this );
    }
    else
    {
        DBG_ASSERT( g_pfnIoCompletion != NULL );
        
        g_pfnIoCompletion( _pvContext,
                           _cbAsyncIOData,
                           _dwAsyncIOError,
                           &_Overlapped );
    }
    
    DereferenceWorkerRequest(); 
    
    return NSTATUS_PENDING; 
}

NREQ_STATUS
UL_NATIVE_REQUEST::DoStateClientCertificate(
    VOID
)
/*++

Routine Description:

    Handle a completion for receiving a client certificate

Arguments:

    None
    
Return Value:

    NSTATUS_PENDING if async IO pending, else NSTATUS_NEXT

--*/
{
    ULONG                   Status;
    HTTP_REQUEST    *       pRequest;
    
    DBG_ASSERT( _ExecState == NREQ_STATE_CLIENT_CERT );

    //
    // Is our buffer too small.  If so retry the request synchronously with
    // a bigger buffer
    // Note: STATUS_BUFFER_OVERFLOW is translated to WIN32 Error - ERROR_MORE_DATA
    
    if ( _dwAsyncIOError == ERROR_MORE_DATA )
    {
        //
        // If buffer is not big enough, HTTP.sys will return only HTTP_SSL_CLIENT_CERT_INFO
        // structure that contains the size of the client certificate
        // The following assert is to assure that HTTP.SYS returns back that
        // HTTP_SSL_CLIENT_CERT_INFO structure and nothing more
        
        DBG_ASSERT( _cbAsyncIOData == sizeof( HTTP_SSL_CLIENT_CERT_INFO ) );
        
        HTTP_SSL_CLIENT_CERT_INFO * pClientCertInfo = 
                        (HTTP_SSL_CLIENT_CERT_INFO*) _buffClientCertInfo.QueryPtr();
        //
        // We need to allocate enough memory to contain HTTP_SSL_CLIENT_CERT_INFO  
        // and certificate blob
        //
        DWORD dwRequiredSize = pClientCertInfo->CertEncodedSize + 
                              sizeof( HTTP_SSL_CLIENT_CERT_INFO );
                              
        DBG_ASSERT(  dwRequiredSize > _buffClientCertInfo.QuerySize() );
                            
        if ( !_buffClientCertInfo.Resize( dwRequiredSize ) )
        {
            //
            // Funnel the fatal error to the complete
            //
            
            _dwAsyncIOError = GetLastError();
        }
        else
        {
            //
            // Retry the request for client cert synchronously
            //
            
            Status = HttpReceiveClientCertificate( g_pwpContext->GetAsyncHandle(),
                                                   QueryConnectionId(),
                                                   _dwClientCertFlags,
                                                   (HTTP_SSL_CLIENT_CERT_INFO*) _buffClientCertInfo.QueryPtr(),
                                                   _buffClientCertInfo.QuerySize(),
                                                   NULL,
                                                   NULL );
            if ( Status != NO_ERROR )
            {
                DBG_ASSERT( _dwAsyncIOError != ERROR_MORE_DATA );
            }

            _dwAsyncIOError = Status;
            _cbAsyncIOData = dwRequiredSize;

        }
    }
    
    if ( _dwAsyncIOError == NO_ERROR )
    {
        pRequest = QueryHttpRequest();
        
        DBG_ASSERT( pRequest->pSslInfo != NULL );
        DBG_ASSERT( pRequest->pSslInfo->pClientCertInfo == NULL );
        
        pRequest->pSslInfo->pClientCertInfo = (HTTP_SSL_CLIENT_CERT_INFO*)
                                              _buffClientCertInfo.QueryPtr();
    }
    
    //
    // Regardless of what happened, we are no longer processing a client cert
    //
    
    _ExecState = NREQ_STATE_PROCESS;

    DBG_ASSERT( g_pfnIoCompletion != NULL );
        
    g_pfnIoCompletion( _pvContext,
                       _cbAsyncIOData,
                       _dwAsyncIOError,
                       &_Overlapped );
                     