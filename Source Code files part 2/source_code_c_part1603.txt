    ASN1Free_BindRequest(&(val)->u.bindRequest);
	    break;
	case 2:
	    ASN1Free_BindResponse(&(val)->u.bindResponse);
	    break;
	case 4:
	    ASN1Free_SearchRequest(&(val)->u.searchRequest);
	    break;
	case 5:
	    ASN1Free_SearchResponse(&(val)->u.searchResponse);
	    break;
	case 6:
	    ASN1Free_ModifyRequest(&(val)->u.modifyRequest);
	    break;
	case 7:
	    ASN1Free_ModifyResponse(&(val)->u.modifyResponse);
	    break;
	case 8:
	    ASN1Free_AddRequest(&(val)->u.addRequest);
	    break;
	case 9:
	    ASN1Free_AddResponse(&(val)->u.addResponse);
	    break;
	case 10:
	    ASN1octetstring_free(&(val)->u.delRequest);
	    break;
	case 11:
	    ASN1Free_DelResponse(&(val)->u.delResponse);
	    break;
	case 12:
	    ASN1Free_ModifyRDNRequest(&(val)->u.modifyRDNRequest);
	    break;
	case 13:
	    ASN1Free_ModifyRDNResponse(&(val)->u.modifyRDNResponse);
	    break;
	case 14:
	    ASN1Free_CompareRequest(&(val)->u.compareDNRequest);
	    break;
	case 15:
	    ASN1Free_CompareResponse(&(val)->u.compareDNResponse);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_LDAPMessage(ASN1encoding_t enc, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncU32(enc, 0x2, (val)->messageID))
	return 0;
    if (!ASN1Enc_LDAPMessage_protocolOp(enc, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_LDAPMessage(ASN1decoding_t dec, ASN1uint32_t tag, LDAPMessage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecU32Val(dd, 0x2, (ASN1uint32_t *) &(val)->messageID))
	return 0;
    if (!ASN1Dec_LDAPMessage_protocolOp(dd, 0, &(val)->protocolOp))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_LDAPMessage(LDAPMessage *val)
{
    if (val) {
	ASN1Free_LDAPMessage_protocolOp(&(val)->protocolOp);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\intfc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
        intfc.h

Abstract:
        Declarations of data types and constants used to provide
        multiple-interface support in H.323/LDAP proxy.
        

Revision History:
        03/01/2000      File creation.      Ilya Kleyman (IlyaK)
    
--*/
#ifndef	__nath323_intfc_h
#define	__nath323_intfc_h

class PROXY_INTERFACE {
    
    friend class PROXY_INTERFACE_ARRAY;

private:

    H323_INTERFACE_TYPE InterfaceType;  // public or private
    ULONG               Index;
    DWORD			    Address;		// host order
    DWORD			    Mask;			// host order
    ULONG               AdapterIndex;

    HANDLE              Q931RedirectHandle;
    HANDLE              LdapRedirectHandle1;
    HANDLE              LdapRedirectHandle2;

    HANDLE              Q931LocalRedirectHandle;
    HANDLE              LdapLocalRedirectHandle1;
    HANDLE              LdapLocalRedirectHandle2;

    IP_NAT_PORT_MAPPING Q931PortMapping;
    IP_NAT_PORT_MAPPING LdapPortMapping;
    IP_NAT_PORT_MAPPING LdapAltPortMapping;

private:

    ULONG 
    StartNatRedirects (
        void
        );

    void 
    StopNatRedirects (
        void
        );

    ULONG
    StartQ931ReceiveRedirect (
        void
        );

    void
    StopQ931ReceiveRedirect (
        void
        );

public:

    PROXY_INTERFACE (
        IN ULONG ArgIndex,
        IN H323_INTERFACE_TYPE ArgInterfaceType,
        IN PIP_ADAPTER_BINDING_INFO BindingInfo
        );

    ~PROXY_INTERFACE (
        void
        );

    DWORD 
    GetIndex (
        void
        ) const 
    { 
        return Index; 
    }

    ULONG 
    Start (
        void
        );

    void 
    Stop ( 
        void
        );

    BOOL
    IsFirewalled (
        void
        );

    BOOL 
    IsPrivate (
        void
        );

    BOOL 
    IsPublic (
        void
        );

    BOOL
    HasQ931PortMapping (
        void
        );

    BOOL
    HasLdapPortMapping (
        void
        );

    BOOL
    HasLdapAltPortMapping (
        void
        );

    ULONG
    GetQ931PortMappingDestination (
        void
        );

    ULONG
    GetLdapPortMappingDestination (
        void
        );

    ULONG
    GetLdapAltPortMappingDestination (
        void
        );
};


class PROXY_INTERFACE_ARRAY :
public SIMPLE_CRITICAL_SECTION_BASE {
private:
    DYNAMIC_ARRAY <PROXY_INTERFACE *> Array;
    LONG Q931ReceiveRedirectStartCount; 

private:

    HRESULT 
    Add (
        IN PROXY_INTERFACE * Interface
        );

    PROXY_INTERFACE * 
    RemoveByIndex ( 
        IN DWORD Index
        );

    PROXY_INTERFACE ** 
    FindByIndex (
        IN DWORD InterfaceIndex
        );

public:

    PROXY_INTERFACE_ARRAY ()
    {

        Q931ReceiveRedirectStartCount = 0;

    }

	// only called during service shutdown to assert that all 
	// interfaces have been previously deactivated
	void 
    AssertShutdownReady (
        void
        ) 
    {
		assert (Array.GetLength() == 0);
	}

    HRESULT 
    IsPrivateAddress (
        IN	DWORD	Address,			// host order
        OUT BOOL  * IsPrivate
        );

    HRESULT 
    IsPublicAddress (
        IN	DWORD	Address,			// host order
        OUT BOOL *  IsPublic
        ); 

    ULONG 
    AddStartInterface (
        IN ULONG Index,
        IN H323_INTERFACE_TYPE InterfaceType,
        IN PIP_ADAPTER_BINDING_INFO BindingInfo
        );

    void 
    RemoveStopInterface (
        IN DWORD Index
        );

    void 
    Stop (
        void
        );

    void
    StartQ931ReceiveRedirects (
        void
        );

    void
    StopQ931ReceiveRedirects (
        void
        );
};

extern PROXY_INTERFACE_ARRAY InterfaceArray;

HRESULT
IsPrivateAddress (
    IN DWORD   Address,
    OUT BOOL * IsPrivate
    );

HRESULT
IsPublicAddress (
    IN DWORD   Address,
    OUT BOOL * IsPublic
    );

#endif // __nath323_intfc_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\ldap.h ===
#ifndef _LDAP_Module_H_
#define _LDAP_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct SearchResponse_entry_attributes_Seq_values * PSearchResponse_entry_attributes_Seq_values;

typedef struct ModifyRequest_modifications_Seq_modification_values * PModifyRequest_modifications_Seq_modification_values;

typedef struct AddRequest_attrs_Seq_values * PAddRequest_attrs_Seq_values;

typedef struct SearchResponse_entry_attributes * PSearchResponse_entry_attributes;

typedef struct SubstringFilter_attributes * PSubstringFilter_attributes;

typedef struct AddRequest_attrs * PAddRequest_attrs;

typedef struct ModifyRequest_modifications * PModifyRequest_modifications;

typedef struct SearchRequest_attributes * PSearchRequest_attributes;

typedef struct Filter_or * PFilter_or;

typedef struct Filter_and * PFilter_and;

typedef struct UnbindRequest {
    char placeholder;
} UnbindRequest;

typedef ASN1uint32_t MessageID;

typedef ASN1octetstring_t AttributeValue;

typedef ASN1octetstring_t LDAPString;

typedef MessageID AbandonRequest;

typedef LDAPString LDAPDN;

typedef LDAPString RelativeLDAPDN;

typedef LDAPString AttributeType;

typedef LDAPDN DelRequest;

typedef struct SearchResponse_entry_attributes_Seq_values {
    PSearchResponse_entry_attributes_Seq_values next;
    AttributeValue value;
} SearchResponse_entry_attributes_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification_values {
    PModifyRequest_modifications_Seq_modification_values next;
    AttributeValue value;
} ModifyRequest_modifications_Seq_modification_values_Element;

typedef struct AddRequest_attrs_Seq_values {
    PAddRequest_attrs_Seq_values next;
    AttributeValue value;
} AddRequest_attrs_Seq_values_Element;

typedef struct ModifyRequest_modifications_Seq_modification {
    AttributeType type;
    PModifyRequest_modifications_Seq_modification_values values;
} ModifyRequest_modifications_Seq_modification;

typedef struct SearchResponse_entry_attributes_Seq {
    AttributeType type;
    PSearchResponse_entry_attributes_Seq_values values;
} SearchResponse_entry_attributes_Seq;

typedef struct SearchResponse_entry_attributes {
    PSearchResponse_entry_attributes next;
    SearchResponse_entry_attributes_Seq value;
} SearchResponse_entry_attributes_Element;

typedef enum operation {
    add = 0,
    operation_delete = 1,
    replace = 2,
} operation;
typedef struct ModifyRequest_modifications_Seq {
    operation operation;
    ModifyRequest_modifications_Seq_modification modification;
} ModifyRequest_modifications_Seq;

typedef struct AddRequest_attrs_Seq {
    AttributeType type;
    PAddRequest_attrs_Seq_values values;
} AddRequest_attrs_Seq;

typedef struct SubstringFilter_attributes_Seq {
    ASN1choice_t choice;
    union {
#	define initial_choice 1
	LDAPString initial;
#	define any_choice 2
	LDAPString any;
#	define final_choice 3
	LDAPString final;
    } u;
} SubstringFilter_attributes_Seq;

typedef struct SubstringFilter_attributes {
    PSubstringFilter_attributes next;
    SubstringFilter_attributes_Seq value;
} SubstringFilter_attributes_Element;

typedef struct AddRequest_attrs {
    PAddRequest_attrs next;
    AddRequest_attrs_Seq value;
} AddRequest_attrs_Element;

typedef struct ModifyRequest_modifications {
    PModifyRequest_modifications next;
    ModifyRequest_modifications_Seq value;
} ModifyRequest_modifications_Element;

typedef struct SearchResponse_entry {
    LDAPDN objectName;
    PSearchResponse_entry_attributes attributes;
} SearchResponse_entry;

typedef struct SearchRequest_attributes {
    PSearchRequest_attributes next;
    AttributeType value;
} SearchRequest_attributes_Element;

typedef struct SaslCredentials {
    LDAPString mechanism;
    ASN1octetstring_t credentials;
} SaslCredentials;

typedef struct ModifyRequest {
    LDAPDN object;
    PModifyRequest_modifications modifications;
} ModifyRequest;

typedef struct AddRequest {
    LDAPDN entry;
    PAddRequest_attrs attrs;
} AddRequest;

typedef struct ModifyRDNRequest {
    LDAPDN entry;
    RelativeLDAPDN newrdn;
} ModifyRDNRequest;

typedef enum resultCode {
    success = 0,
    operationsError = 1,
    protocolError = 2,
    timeLimitExceeded = 3,
    sizeLimitExceeded = 4,
    compareFalse = 5,
    compareTrue = 6,
    authMethodNotSupported = 7,
    strongAuthRequired = 8,
    noSuchAttribute = 16,
    undefinedAttributeType = 17,
    inappropriateMatching = 18,
    constraintViolation = 19,
    attributeOrValueExists = 20,
    invalidAttributeSyntax = 21,
    noSuchObject = 32,
    aliasProblem = 33,
    invalidDNSyntax = 34,
    isLeaf = 35,
    aliasDereferencingProblem = 36,
    inappropriateAuthentication = 48,
    invalidCredentials = 49,
    insufficientAccessRights = 50,
    busy = 51,
    unavailable = 52,
    unwillingToPerform = 53,
    loopDetect = 54,
    namingViolation = 64,
    objectClassViolation = 65,
    notAllowedOnNonLeaf = 66,
    notAllowedOnRDN = 67,
    entryAlreadyExists = 68,
    objectClassModsProhibited = 69,
    other = 80,
} resultCode;
typedef struct LDAPResult {
    resultCode resultCode;
    LDAPDN matchedDN;
    LDAPString errorMessage;
} LDAPResult;

typedef struct AttributeValueAssertion {
    AttributeType attributeType;
    AttributeValue attributeValue;
} AttributeValueAssertion;

typedef struct SubstringFilter {
    AttributeType type;
    PSubstringFilter_attributes attributes;
} SubstringFilter;

typedef struct AuthenticationChoice {
    ASN1choice_t choice;
    union {
#	define simple_choice 1
	ASN1octetstring_t simple;
#	define sasl_choice 2
	SaslCredentials sasl;
#	define sicilyNegotiate_choice 3
	ASN1octetstring_t sicilyNegotiate;
#	define sicilyInitial_choice 4
	ASN1octetstring_t sicilyInitial;
#	define sicilySubsequent_choice 5
	ASN1octetstring_t sicilySubsequent;
    } u;
} AuthenticationChoice;

typedef LDAPResult BindResponse;

typedef struct SearchResponse {
    ASN1choice_t choice;
    union {
#	define entry_choice 1
	SearchResponse_entry entry;
#	define resultCode_choice 2
	LDAPResult resultCode;
    } u;
} SearchResponse;

typedef LDAPResult ModifyResponse;

typedef LDAPResult AddResponse;

typedef LDAPResult DelResponse;

typedef LDAPResult ModifyRDNResponse;

typedef struct CompareRequest {
    LDAPDN entry;
    AttributeValueAssertion ava;
} CompareRequest;

typedef LDAPResult CompareResponse;

typedef struct Filter {
    ASN1choice_t choice;
    union {
#	define and_choice 1
	PFilter_and and;
#	define or_choice 2
	PFilter_or or;
#	define equalityMatch_choice 3
	AttributeValueAssertion equalityMatch;
#	define substrings_choice 4
	SubstringFilter substrings;
#	define greaterOrEqual_choice 5
	AttributeValueAssertion greaterOrEqual;
#	define lessOrEqual_choice 6
	AttributeValueAssertion lessOrEqual;
#	define present_choice 7
	AttributeType present;
#	define approxMatch_choice 8
	AttributeValueAssertion approxMatch;
    } u;
} Filter;

typedef struct Filter_or {
    PFilter_or next;
    Filter value;
} Filter_or_Element;

typedef struct Filter_and {
    PFilter_and next;
    Filter value;
} Filter_and_Element;

typedef struct BindRequest {
    ASN1uint16_t version;
    LDAPDN name;
    AuthenticationChoice authentication;
} BindRequest;

typedef enum scope {
    baseObject = 0,
    singleLevel = 1,
    wholeSubtree = 2,
} scope;
typedef enum derefAliases {
    neverDerefAliases = 0,
    derefInSearching = 1,
    derefFindingBaseObj = 2,
    alwaysDerefAliases = 3,
} derefAliases;
typedef struct SearchRequest {
    LDAPDN baseObject;
    scope scope;
    derefAliases derefAliases;
    ASN1uint32_t sizeLimit;
    ASN1uint32_t timeLimit;
    ASN1bool_t attrsOnly;
    Filter filter;
    PSearchRequest_attributes attributes;
} SearchRequest;

typedef struct LDAPMessage_protocolOp {
    ASN1choice_t choice;
    union {
#	define bindRequest_choice 1
	BindRequest bindRequest;
#	define bindResponse_choice 2
	BindResponse bindResponse;
#	define unbindRequest_choice 3
	UnbindRequest unbindRequest;
#	define searchRequest_choice 4
	SearchRequest searchRequest;
#	define searchResponse_choice 5
	SearchResponse searchResponse;
#	define modifyRequest_choice 6
	ModifyRequest modifyRequest;
#	define modifyResponse_choice 7
	ModifyResponse modifyResponse;
#	define addRequest_choice 8
	AddRequest addRequest;
#	define addResponse_choice 9
	AddResponse addResponse;
#	define delRequest_choice 10
	DelRequest delRequest;
#	define delResponse_choice 11
	DelResponse delResponse;
#	define modifyRDNRequest_choice 12
	ModifyRDNRequest modifyRDNRequest;
#	define modifyRDNResponse_choice 13
	ModifyRDNResponse modifyRDNResponse;
#	define compareDNRequest_choice 14
	CompareRequest compareDNRequest;
#	define compareDNResponse_choice 15
	CompareResponse compareDNResponse;
#	define abandonRequest_choice 16
	AbandonRequest abandonRequest;
    } u;
} LDAPMessage_protocolOp;

typedef struct LDAPMessage {
    MessageID messageID;
    LDAPMessage_protocolOp protocolOp;
} LDAPMessage;
#define LDAPMessage_ID 0
#define SIZE_LDAP_Module_ID_0 sizeof(LDAPMessage)

extern ASN1int32_t maxInt;

extern ASN1module_t LDAP_Module;
extern void ASN1CALL LDAP_Module_Startup(void);
extern void ASN1CALL LDAP_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _LDAP_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\logchan.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"

void LOGICAL_CHANNEL::IncrementLifetimeCounter (void)  { GetCallBridge().AddRef (); }
void LOGICAL_CHANNEL::DecrementLifetimeCounter (void) { GetCallBridge().Release (); }

// Code common for both RTP and T.120 logical channels
// Only OpenLogicalChannel and OpenLogicalChannelAck need to
// be handled differently for RTP and T.120 logical channels


HRESULT
LOGICAL_CHANNEL::CreateTimer(DWORD TimeoutValue)
{
    DWORD RetCode;
	
    RetCode = TimprocCreateTimer (TimeoutValue);

    return HRESULT_FROM_WIN32(RetCode);
}

// the event manager tells us about timer expiry via this method
/* virtual */ void 
LOGICAL_CHANNEL::TimerCallback (void)
{
    CALL_BRIDGE *pCallBridge = &GetCallBridge();

    ///////////////////////////////
    //// LOCK the CALL_BRIDGE
    ///////////////////////////////
    pCallBridge->Lock ();

    // Clear the timer - Note that Terminate () will try to
    // cancel all the timers in this CALL_BRIDGE
    TimprocCancelTimer();
    DebugF (_T("LC  : 0x%x cancelled timer.\n"),
         &GetCallBridge ());
    
    // Don't do anything if the CALL_BRIDGE is already terminated.
    if (!pCallBridge->IsTerminated ())
    { 
		// CODE WORK *** TO DO
		// if the current state is LC_STATE_OPEN_RCVD, send close LC PDU to
		// both the source and the destination
    
		// if the current state is LC_STATE_CLOSE_RCVD or 
		// LC_STATE_OPENED_CLOSE_RCVD, send close LC PDU to just
		// the destination
    
		// delete self and remove the pointer from the logical channel array
		DeleteAndRemoveSelf ();
	}
    
    ///////////////////////////////
    //// UNLOCK the CALL_BRIDGE
    ///////////////////////////////
    pCallBridge -> Unlock ();

	pCallBridge -> Release ();

}



HRESULT
LOGICAL_CHANNEL::HandleCloseLogicalChannelPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
	HRESULT HResult = E_FAIL;
	switch(m_LogicalChannelState)
	{
	case LC_STATE_OPEN_RCVD:
	case LC_STATE_OPEN_ACK_RCVD:
		{
#if 0  // 0 ******* Region Commented Out Begins *******
			// start timer, if we don't receive a response in this time,
			// we must close this logical channel
			HResult = CreateTimer(LC_POST_CLOSE_TIMER_VALUE);
			if (FAILED(HResult))
			{
				DebugF( _T("LOGICAL_CHANNEL::HandleCloseLogicalChannelPDU, ")
					_T("couldn't create timer, returning 0x%x\n"),
					HResult));
				return HResult;
			}
#endif // 0 ******* Region Commented Out Ends   *******

			// save the reason for closing the logical channel

			// forward the PDU to the other H245 instance
			HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(pH245pdu);
			if (FAILED(HResult))
			{
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

            // Don't wait for CLCAck. Just CLC is sufficient to delete the
            // logical channel. CLCAck is just forwarded without doing anything.
            // delete self and remove the pointer from the logical channel array
            DeleteAndRemoveSelf();

#if 0  // 0 ******* Region Commented Out Begins *******
			// state trasition
			if (LC_STATE_OPEN_ACK_RCVD == m_LogicalChannelState)
			{
				// we had opened the logical channel
				m_LogicalChannelState = LC_STATE_OPENED_CLOSE_RCVD;
			}
			else
			{
				// the logical channel was never opened
				m_LogicalChannelState = LC_STATE_CLOSE_RCVD;
			}
#endif // 0 ******* Region Commented Out Ends   *******

		}
		break;

	case LC_STATE_CLOSE_RCVD:
	case LC_STATE_OPENED_CLOSE_RCVD:
		{
			return E_INVALIDARG;
		}
		break;

	case LC_STATE_NOT_INIT:
	default:
		{
            _ASSERTE(FALSE);
			return E_UNEXPECTED;
		}
		break;
	};

    return HResult;
}


HRESULT
LOGICAL_CHANNEL::ProcessOpenLogicalChannelRejectPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
    // delete self and remove the pointer from the logical channel array
    DeleteAndRemoveSelf();

    // shouldn't access any members of the logical channel as it may have
    // been destroyed already
	// NOTE: Since we return S_OK, the PDU gets forwarded to the other end

    return S_OK;
}


// Unused.

HRESULT
LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
{
    DebugF( _T("LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(&%x) called ")
            _T("m_LogicalChannelState: %d, LCN: %d\n"),
            pH245pdu,
            m_LogicalChannelState, m_LogicalChannelNumber);


    // cancel timer

    // CODEWORK: Make some checks on the PDU and current state ??
    
    // delete self and remove the pointer from the logical channel array
    DeleteAndRemoveSelf();

    // shouldn't access any members of the logical channel as it may have
    // been destroyed already
    DebugF( _T("LOGICAL_CHANNEL::ProcessCloseLogicalChannelAckPDU(&%x) ")
        _T("returning S_OK\n"),
        pH245pdu);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\ldappx.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:
    ldappx.h

Abstract:
    Declares abstract data types and constants used in LDAP portion of the H.323/LDAP proxy.

    LDAP Proxy is designed as an addition to H.323 proxy. The main purpose of the
    LDAP proxy is to maintain LDAP Address Translation Table, which is used to map
    aliases of H.323 endpoints to their IP addresses. The proxy adds an entry when it
    intercepts an LDAP PDU from a client to directory server, and the PDU matches all
    predefined criteria.

Author(s):          ArlieD, IlyaK   14-Jul-1999

Revision History:
    07/14/1999      File creation                                  Arlie Davis  (ArlieD)
    08/20/1999      Improvement of processing of LDAP              Ilya Kleyman (IlyaK)
                    LDAP SearchRequests
    12/20/1999      Added prediction of receive sizes in           Ilya Kleyman (IlyaK)
                    non-interpretative data transfer mode
    02/20/2000      Added expiration policy of the entries         Ilya Kleyman (IlyaK)
                    in LDAP Address Translation Table
    03/12/2000      Added support for multiple private and         Ilya Kleyman (IlyaK)
                    multiple public interface for RRAS

--*/
#ifndef    __h323ics_ldappx_h
#define    __h323ics_ldappx_h

#define    LDAP_PATH_EQUAL_CHAR    '='
#define    LDAP_PATH_SEP_CHAR      ','

extern BOOLEAN NhIsLocalAddress      (ULONG Address);
extern ULONG   NhMapAddressToAdapter (ULONG Address);

typedef    MessageID    LDAP_MESSAGE_ID;

#define ASN_SEQUENCE_TAG                0x30
#define ASN_LONG_HEADER_BIT             0x80
#define ASN_MIN_HEADER_LEN              2          // This value is fixed

#define LDAP_STANDARD_PORT              389        // Well-known LDAP port
#define LDAP_ALTERNATE_PORT             1002       // Alternate (ILS) LDAP port
#define LDAP_BUFFER_RECEIVE_SIZE        0x400
#define LDAP_BUFFER_MAX_RECV_SIZE       0x80000UL  // Limit on maximum one-time receive size
#define LDAP_MAX_TRANSLATION_TABLE_SIZE 100000     // Maximum number of entries in translation table
#define LDAP_MAX_CONNECTIONS            50000      // Maximum number of concurrent connections through the proxy

// data structures -------------------------------------------------------------------

class    LDAP_SOCKET;
class    LDAP_CONNECTION;

struct   LDAP_TRANSLATION_ENTRY
{
// An entry in the LDAP Address Translation Table is 
// to be identified by three components:
// 1. Registered alias
// 2. Registered address
// 3. Directory server the alias is registered with
// 4. Directory path on the server
// 
// Currently only first three are used.
// 
    ANSI_STRING  Alias;                // Memory owned, use FreeAnsiString
    ANSI_STRING  DirectoryPath;        // Memory owned, use FreeAnsiString
    ANSI_STRING  CN;                   // Subset of DirectoryPath, NOT owned, do NOT free
    IN_ADDR      ClientAddress;
    SOCKADDR_IN  ServerAddress;
    DWORD        TimeStamp;            // In seconds, since the last machine reboot

    void    
    FreeContents (
        void
        )
    {
        FreeAnsiString (&Alias);
        FreeAnsiString (&DirectoryPath);

        CN.Buffer = NULL;
    }

    HRESULT 
    IsRegisteredViaInterface (
        IN DWORD InterfaceAddress,     // host order
        OUT BOOL *Result
        );
};

class    LDAP_TRANSLATION_TABLE :
public    SIMPLE_CRITICAL_SECTION_BASE
{
// LDAP Address Translation Table is a serialized 
// container for translation entries. The Table
// can conduct various types of searches, and has
// an expiration policy on old entries. The expiration
// is done by means of a periodic timer thread and
// timestamps on each entry. Entries are added when
// successful AddResponses are received in reply to
// valid AddRequests. Entries are refreshed when
// successful refresh SearchResponses are received for
// valid refresh SearchRequests (for NetMeeting); or when
// successful refresh ModifyResponses are received for
// valid refresh ModifyRequests (for Phone Dialer).
private:

    DYNAMIC_ARRAY <LDAP_TRANSLATION_ENTRY>        Array;
    HANDLE                  GarbageCollectorTimerHandle;
    BOOL                    IsEnabled;

private:

    HRESULT
    InsertEntryLocked (
        IN  ANSI_STRING * Alias,
        IN  ANSI_STRING * DirectoryPath,
        IN  IN_ADDR       ClientAddress,
        IN  SOCKADDR_IN * ServerAddress,
        IN  DWORD         TimeToLive    // in seconds
        );

    HRESULT
    FindEntryByPathServer (
        IN  ANSI_STRING * DirectoryPath,
        IN  SOCKADDR_IN * ServerAddress,
        OUT LDAP_TRANSLATION_ENTRY ** ReturnTranslationEntry
        );

    HRESULT    FindEntryByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress,
        OUT LDAP_TRANSLATION_ENTRY ** ReturnTranslationEntry
        );

public:

    LDAP_TRANSLATION_TABLE (
        void
        );

    ~LDAP_TRANSLATION_TABLE (
        void
        );

    HRESULT 
    Start (
        void
        );

    void 
    Stop (
        void
        );

#if DBG
    void 
    PrintTable (
        void
        );
#endif

#define LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD    (10 * 60 * 1000)   // Milliseconds
#define LDAP_TRANSLATION_TABLE_ENTRY_INITIAL_TIME_TO_LIVE   (10 * 60)          // Seconds

    static
    void
    GarbageCollectorCallback (
        IN PVOID Context,
        IN BOOLEAN TimerOrWaitFired
        );

    HRESULT
    RefreshEntry (
        IN ANSI_STRING * Alias,
        IN ANSI_STRING * DirectoryPath,
        IN IN_ADDR       ClientAddress,
        IN SOCKADDR_IN * ServerAddress,
        IN DWORD         TimeToLive
        );

    void
    RemoveOldEntries (
        void
        );

    HRESULT
    QueryTableByAlias (
        IN  ANSI_STRING * Alias,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByCN (
        IN  ANSI_STRING * CN,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    QueryTableByCNServer (
        IN  ANSI_STRING * CN,
        IN  SOCKADDR_IN * ServerAddress,
        OUT IN_ADDR     * ReturnClientAddress
        );

    HRESULT
    InsertEntry (
        IN  ANSI_STRING * Alias,
        IN  ANSI_STRING * DirectoryPath,
        IN  IN_ADDR       ClientAddress,
        IN  SOCKADDR_IN * ServerAddress,
        IN  DWORD         TimeToLive        // in seconds
        );

    HRESULT 
    RemoveEntry (
        IN  SOCKADDR_IN * ServerAddress,
        IN  ANSI_STRING * DirectoryPath
        );

    HRESULT 
    RemoveEntryByAliasServer (
        IN  ANSI_STRING * Alias,
        IN  SOCKADDR_IN * ServerAddress
        );

    void 
    OnInterfaceShutdown (
        IN DWORD          InterfaceAddress
        );

    BOOL  
    ReachedMaximumSize (
        void
        );
};


class    LDAP_BUFFER
{
// LDAP_BUFFER is a simple structure
// that can hold raw data and be chained
// to other LDAP_BUFFERs
public:
    LDAP_BUFFER (
        void
        );

    ~LDAP_BUFFER (
        void
        );

public:
    DYNAMIC_ARRAY <BYTE>  Data;
    LIST_ENTRY            ListEntry;
};

enum NOTIFY_REASON
{
    SOCKET_SEND_COMPLETE,
    SOCKET_RECEIVE_COMPLETE,
};

struct LDAP_OVERLAPPED
{
    OVERLAPPED    Overlapped;
    BOOL          IsPending;
    DWORD         BytesTransferred;
    LDAP_SOCKET * Socket;
};

class LDAP_PUMP
{
    friend    class    LDAP_CONNECTION;
    friend    class    LDAP_SOCKET;

private:
    LDAP_CONNECTION * Connection;
    LDAP_SOCKET     * Source;
    LDAP_SOCKET     * Dest;
    // When set, the pump works in raw data
    // transfer mode without modifications to
    // the payload
    BOOL              IsPassiveDataTransfer;

public:
    LDAP_PUMP (
        IN    LDAP_CONNECTION * ArgConnection,
        IN    LDAP_SOCKET     * ArgSource,
        IN    LDAP_SOCKET     * ArgDest
        );

    ~LDAP_PUMP (
        void
        );

    void Start (
        void
        );

    void Stop  (
        void
        );

    // source is indicating that it has received data
    void
    OnRecvBuffer (
        LDAP_BUFFER *
        );

    // destination is indicating that it has finished sending data
    void 
    OnSendDrain (
        void
        );

    void  
    SendQueueBuffer (
        IN  LDAP_BUFFER * Buffer
        );

    BOOL    
    CanIssueRecv (
        void
        );

    void
    Terminate (
        void
        );

    void 
    EncodeSendMessage (
        IN LDAPMessage * Message
        );

    void 
    StartPassiveDataTransfer (
        void
        );

    BOOL IsActivelyPassingData (
        void
        ) const;
};

class    LDAP_SOCKET
{
// LDAP_SOCKET is a wrapper class
// around Windows asynchrounous socket.
// An instance of LDAP_SOCKET can 
// asynchronously connect, send and receive

    friend class LDAP_CONNECTION;
    friend class LDAP_PUMP;

public:
    enum STATE {
        STATE_NONE,
        STATE_ISSUING_CONNECT,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };


private:

    SOCKADDR_IN          ActualDestinationAddress;
    SOCKADDR_IN          RealSourceAddress;

    BOOL                 IsNatRedirectActive;

    LDAP_CONNECTION    * LdapConnection;
    LDAP_PUMP          * RecvPump;
    LDAP_PUMP          * SendPump;
    SOCKET               Socket;
    STATE                State;

    // receive state
    LDAP_OVERLAPPED      RecvOverlapped;
    LDAP_BUFFER *        RecvBuffer;             // must be valid if RecvOverlapped.IsPending, must be null otherwise
    DWORD                RecvFlags;
    LIST_ENTRY           RecvBufferQueue;        // contains LDAP_BUFFER.ListEntry
    DWORD                BytesToReceive;
    SAMPLE_PREDICTOR <5> RecvSizePredictor;

    // send stat
    LDAP_OVERLAPPED      SendOverlapped;
    LDAP_BUFFER *        SendBuffer;             // must be valid if SendOverlapped.IsPending, must be null otherwise
    LIST_ENTRY           SendBufferQueue;        // contains LDAP_BUFFER.ListEntry

    // async connect state
    HANDLE               ConnectEvent;
    HANDLE               ConnectWaitHandle;
    BOOL                 AttemptAnotherConnect;

private:

    inline 
    void 
    Lock (
        void
        );

    inline 
    void 
    Unlock (
        void
        );

    inline 
    void 
    AssertLocked (
        void
        );

    void 
    OnConnectCompletionLocked (
        void
        );

    void 
    FreeConnectResources (
        void
        );

    HRESULT 
    AttemptAlternateConnect (
        void
        );

    void 
    OnIoComplete (
        IN  DWORD Status, 
        IN  DWORD BytesTransferred,
        IN  LDAP_OVERLAPPED *
        );

    void 
    OnRecvComplete (
        IN  DWORD Status
        );

    void
    OnSendComplete (
        IN  DWORD Status
        );

    void
    RecvBuildBuffer (
        IN  LPBYTE Data,
        IN  DWORD  Length
        );

    void DeleteBufferList (
        IN  LIST_ENTRY * ListHead
        );

    BOOL RecvRemoveBuffer (
        OUT LDAP_BUFFER ** ReturnBuffer
        );

    // returns TRUE if a message was dequeued
    BOOL SendNextBuffer (
        void
        );

public:

    LDAP_SOCKET (
        IN  LDAP_CONNECTION * ArgLdapConnection,
        IN  LDAP_PUMP       * ArgRecvPump,
        IN  LDAP_PUMP       * ArgSendPump
        );

    ~LDAP_SOCKET (
        void
        );

    HRESULT 
    RecvIssue (
        void
        );

    // may queue the buffer
    void
    SendQueueBuffer(
        IN LDAP_BUFFER * Buffer
        );

    static
    void
    IoCompletionCallback (
        IN DWORD Status,
        IN DWORD Length,
        IN LPOVERLAPPED Overlapped
        );

    static 
    void 
    OnConnectCompletion (
        IN PVOID Context,
        IN BOOLEAN TimerOrWaitFired
        );

    HRESULT 
    AcceptSocket (
        IN SOCKET LocalClientSocket
        );

    HRESULT 
    IssueConnect (
        IN SOCKADDR_IN * DestinationAddress
        );

    void
    OnIoCompletion  (
        IN LDAP_BUFFER * Message,
        IN DWORD Status,
        IN DWORD BytesTransferred
        );

    void 
    Terminate (
        void
        );

    STATE
    GetState (void) {

        AssertLocked ();

        return State;
    }

    // retrieve the remote address of the connection
    BOOL 
    GetRemoteAddress (
        OUT SOCKADDR_IN * ReturnAddress
        );

    // retrieve the local address of the connection
    BOOL    
    GetLocalAddress (
        OUT SOCKADDR_IN * ReturnAddress
        );
};


// this represents a single outstanding operation that the client has initiated.

enum    LDAP_OPERATION_TYPE
{
    LDAP_OPERATION_ADD,
    LDAP_OPERATION_SEARCH,
    LDAP_OPERATION_MODIFY,
    LDAP_OPERATION_DELETE,
};

struct    LDAP_OPERATION
{
// LDAP_OPERATIONs are created and queued when 
// a client issues a request to the server.
// The actual processing of the operation
// starts when server sends back response
// with data and/or status code.

    LDAP_MESSAGE_ID MessageID;
    DWORD           Type;
    ANSI_STRING     DirectoryPath;            // owned by process heap
    ANSI_STRING     Alias;                    // owned by process heap
    IN_ADDR         ClientAddress;
    SOCKADDR_IN     ServerAddress;
    DWORD           EntryTimeToLive;          // in seconds

    void 
    FreeContents (
        void
        )
    {

        FreeAnsiString (&DirectoryPath);

        FreeAnsiString (&Alias);
    }
};


class  LDAP_CONNECTION :
public SIMPLE_CRITICAL_SECTION_BASE,
public LIFETIME_CONTROLLER
{
// LDAP_CONNECTION represents two parts
// (public and private) of the connection
// being proxied by the LDAP proxy. In reflection
// of this it has easily distinguishable Server
// part and Client part
    friend class LDAP_SOCKET;

public:

    enum    STATE {
        STATE_NONE,
        STATE_CONNECT_PENDING,
        STATE_CONNECTED,
        STATE_TERMINATED,
    };

    LIST_ENTRY     ListEntry;

private:

    LDAP_SOCKET    ClientSocket;
    LDAP_SOCKET    ServerSocket;
    DWORD          SourceInterfaceAddress;      // address of the interface on which the conection was accepted, host order
    DWORD          DestinationInterfaceAddress; // address of the interface on which the conection was accepted, host order
    SOCKADDR_IN    SourceAddress;               // address of the source (originator of the connection)
    SOCKADDR_IN    DestinationAddress;          // address of the destination (recipeint of the connection)

    LDAP_PUMP      PumpClientToServer;
    LDAP_PUMP      PumpServerToClient;

    STATE          State;

    DYNAMIC_ARRAY <LDAP_OPERATION>    OperationArray;

private:

    void 
    StartIo (
        void
        );

    BOOL 
    ProcessLdapMessage (
        IN  LDAP_PUMP             * Pump,
        IN  LDAPMessage           * LdapMessage
        );

    // client to server messages

    BOOL    
    ProcessAddRequest (
        IN  LDAPMessage           * Message
        );

    BOOL 
    ProcessModifyRequest (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ModifyRequest         * Request
        );

    BOOL 
    ProcessDeleteRequest (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  DelRequest            * Request
        );

    BOOL 
    ProcessSearchRequest (
        IN  LDAPMessage           * Message
        );

    // server to client messages

    void  
    ProcessAddResponse (
        IN  LDAPMessage           * Response
        );

    void    
    ProcessModifyResponse (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ModifyResponse        * Response
        );

    void    
    ProcessDeleteResponse (
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  DelResponse           * Response
        );

    BOOL    
    ProcessSearchResponse (
        IN  LDAPMessage           * Message
        );

    BOOL    
    FindOperationIndexByMessageID (
        IN  LDAP_MESSAGE_ID         MessageID,
        OUT DWORD                 * ReturnIndex
        );

    BOOL    
    FindOperationByMessageID    (
        IN  LDAP_MESSAGE_ID         MessageID,
        OUT LDAP_OPERATION       ** ReturnOperation
        );

    static 
    INT 
    BinarySearchOperationByMessageID (
        IN  const LDAP_MESSAGE_ID * SearchKey,
        IN  const LDAP_OPERATION  * Comparand
        );

    HRESULT    
    CreateOperation (
        IN  LDAP_OPERATION_TYPE     Type,
        IN  LDAP_MESSAGE_ID         MessageID,
        IN  ANSI_STRING           * DirectoryPath,
        IN  ANSI_STRING           * Alias,
        IN  IN_ADDR                 ClientAddress,
        IN  SOCKADDR_IN           * ServerAddress,
        IN  DWORD                   EntryTimeToLive // in seconds
        );

public:
    LDAP_CONNECTION (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    ~LDAP_CONNECTION (
        void
        );

    HRESULT 
    Initialize (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    HRESULT 
    InitializeLocked (
        IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
        );

    HRESULT 
    AcceptSocket (
        IN  SOCKET                  Socket,
        IN  SOCKADDR_IN           * LocalAddress,
        IN  SOCKADDR_IN           * RemoteAddress,
        IN  SOCKADDR_IN           * ArgActualDestinationAddress
        );

    // process a given LDAP message buffer
    // in the context of a given pump (direction)
    void 
    ProcessBuffer (
        IN  LDAP_PUMP             * Pump,
        IN  LDAP_BUFFER           * Buffer
        );

    void 
    OnStateChange (
        IN LDAP_SOCKET            * NotifyingSocket,
        IN LDAP_SOCKET::STATE       NewState
        );

    void 
    Terminate (
        void
        );

    void 
    TerminateExternal (
        void
        );

    BOOL 
    IsConnectionThrough (
        IN DWORD InterfaceAddress   // host order
        );

    // safe, external version
    STATE    
    GetState (
        void
        )
    {
        STATE    ReturnState;

        Lock ();

        ReturnState = State;

        Unlock ();

        return ReturnState;
    }
};

DECLARE_SEARCH_FUNC_CAST (LDAP_MESSAGE_ID, LDAP_OPERATION);

inline 
void 
LDAP_SOCKET::Lock (
    void
    )
{ 
    LdapConnection -> Lock ();
}

inline 
void 
LDAP_SOCKET::Unlock (
    void
    ) 
{ 
    LdapConnection -> Unlock ();      
}

inline 
void 
LDAP_SOCKET::AssertLocked (
    void
    ) 
{ 
    LdapConnection -> AssertLocked(); 
}

class   LDAP_CONNECTION_ARRAY :
public  SIMPLE_CRITICAL_SECTION_BASE {

private:

    // Contains set/array of LDAP_CONNECTION references
    DYNAMIC_ARRAY <LDAP_CONNECTION *> ConnectionArray;

    // Controls whether or not the structure will accept
    // new LDAP connections
    BOOL IsEnabled;

public:

    LDAP_CONNECTION_ARRAY (void);

    HRESULT 
    InsertConnection (
        IN LDAP_CONNECTION * LdapConnection
        );

    void  
    RemoveConnection (
        IN LDAP_CONNECTION * LdapConnection
        );

    void 
    OnInterfaceShutdown (
        IN DWORD InterfaceAddress // host order
        );

    void 
    Start (
        void
        );

    void 
    Stop (
        void
        );

};

class    LDAP_ACCEPT
{

private:

    // Contain accept context
    ASYNC_ACCEPT                    AsyncAcceptContext;

    // Handles for dynamic redirects from the standard and
    // alternate LDAP ports to the selected loopback port
    HANDLE                          LoopbackRedirectHandle1;
    HANDLE                          LoopbackRedirectHandle2;

private:

    HRESULT 
    CreateBindSocket (
        void
        );

    HRESULT 
    StartLoopbackNatRedirects (
        void
        );

    void 
    StopLoopbackNatRedirects (
        void
        );

    void 
    CloseSocket (
        void
        );

    static 
    void 
    AsyncAcceptFunction (
        IN  PVOID         Context,
        IN  SOCKET        Socket,
        IN  SOCKADDR_IN * LocalAddress,
        IN  SOCKADDR_IN * RemoteAddress
        );

    static
    HRESULT 
    LDAP_ACCEPT::AsyncAcceptFunctionInternal (
        IN    PVOID         Context,
        IN    SOCKET        Socket,
        IN    SOCKADDR_IN * LocalAddress,
        IN    SOCKADDR_IN * RemoteAddress
        );

public:

    LDAP_ACCEPT (
        void
        );

    HRESULT 
    Start (
        void
        );

    void 
    Stop(
        void
        );
};

class    LDAP_CODER :
public    SIMPLE_CRITICAL_SECTION_BASE
{
private:
    ASN1encoding_t                  Encoder;
    ASN1decoding_t                  Decoder;

public:
    LDAP_CODER  (
        void
        );

    ~LDAP_CODER (
        void
        );

    DWORD 
    Start (
        void
        );

    void 
    Stop (
        void
        );

    ASN1error_e Decode (
        IN  LPBYTE                  Data,
        IN  DWORD                   Length,
        OUT LDAPMessage          ** ReturnPduStructure,
        OUT DWORD                 * ReturnIndex
        );
};

struct    LDAP_PATH_ELEMENTS
{
    ANSI_STRING        CN;
    ANSI_STRING        C;
    ANSI_STRING        O;
    ANSI_STRING        ObjectClass;
};

struct    LDAP_OBJECT_NAME_ELEMENTS
{
    ANSI_STRING        CN;
    ANSI_STRING        O;
    ANSI_STRING        OU;
};

extern SYNC_COUNTER                 LdapSyncCounter;
extern LDAP_CONNECTION_ARRAY        LdapConnectionArray;
extern LDAP_TRANSLATION_TABLE       LdapTranslationTable;
extern LDAP_CODER                   LdapCoder;
extern LDAP_ACCEPT                  LdapAccept;
extern SOCKADDR_IN                  LdapListenSocketAddress;
extern DWORD                        EnableLocalH323Routing;

HRESULT 
LdapQueryTableByAlias (
  IN  ANSI_STRING               * Alias,
  OUT DWORD                     * ReturnClientAddress   // host order
    );

HRESULT 
LdapQueryTableByAliasServer (
  IN  ANSI_STRING               * Alias,
  IN  SOCKADDR_IN               * ServerAddress,
  OUT DWORD                     * ReturnClientAddress); // host order


#if    DBG
void 
LdapPrintTable (
    void
    );
#endif //    DBG

#endif // __h323ics_ldappx_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\main.cpp ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Contains:
        1. Module startup routines
        2. Component activation routines
        3. Component deactivation routines
        4. Module shutdown/cleanup routines
        5. Auxiliary routines

Revision History:
    
    1. 31-Jul-1998 -- File creation                     Ajay Chitturi (ajaych) 
    2. 15-Jul-1999 --                                   Arlie Davis   (arlied)    
    3. 14-Feb-2000 -- Added support for multiple        Ilya Kleyman  (ilyak)
                      private interfaces

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HANDLE NatHandle         = NULL;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Static declarations                                                       // 
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
static
void
QueryRegistry (
    void
    );

static
HRESULT
H323ProxyStartServiceInternal (
    void
    );

static
HRESULT
H323ProxyStart (
    void
    );

static
HRESULT
LdapProxyStart (
    void
    );

static
void
H323ProxyStop (
    void
    );

static
void
LdapProxyStop (
    void
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module startup routines                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C
BOOLEAN
H323ProxyInitializeModule (
    void
    )
/*++

Routine Description:
    Initializes module.
    
Arguments:
    None
    
Return Values:
    TRUE  - if initialization was successful
    FALSE - if initialization failed

Notes:
    Equivalent to DLL_PROCESS_ATTACH
--*/

{
    Debug (_T("H323: DLL_PROCESS_ATTACH.\n"));

    H323ASN1Initialize();

    return TRUE;
} // H323ProxyInitializeModule


EXTERN_C
ULONG
H323ProxyStartService (
    void
    )
/*++

Routine Description:
    Starts the service
    
Arguments:
    None
    
Return Values:
    Win32 error code

Notes:
    Module entry point
--*/

{
    HRESULT        Result;

    Debug (_T("H323: starting...\n"));

    Result = H323ProxyStartServiceInternal();

    if (Result == S_OK) {
        DebugF (_T("H323: H.323/LDAP proxy has initialized successfully.\n"));
        return ERROR_SUCCESS;
    }
    else {
        DebugError (Result, _T("H323: H.323/LDAP proxy has FAILED to initialize.\n"));
        return ERROR_CAN_NOT_COMPLETE;
    }
} // H323ProxyStartService

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Component activation routines                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


static
HRESULT
H323ProxyStartServiceInternal (
    void
    )
/*++

Routine Description:

    Initializes all components.

Arguments:
    
    None.

Return Values:

    Returns S_OK in case of success or an error in case of failure.

Notes:
    Internal version of DLL entry point

--*/

{
    WSADATA     WsaData;
    HRESULT     Result;

    QueryRegistry ();

    // Initialize WinSock
    Result = WSAStartup (MAKEWORD (2, 0), &WsaData);
    if (S_OK == Result) {

        // Initialize allocator of call reference values
        Result = InitCrvAllocator();
        if (S_OK == Result) {

            // initialize NAT
            Result = NatInitializeTranslator (&NatHandle);
            if (S_OK == Result) {

                // Initialize Port Pool
                Result = PortPoolStart ();
                if (S_OK == Result) {

                    // Initialize H.323 Proxy
                    Result = H323ProxyStart ();
                    if (S_OK == Result) {

                        // Initialize LDAP Proxy
                        Result = LdapProxyStart ();
                        if (S_OK == Result) {

                            return S_OK;
                        }
                        
                        H323ProxyStop ();
                    }

                    PortPoolStop ();
                }

                NatShutdownTranslator (NatHandle);
                NatHandle = NULL;
            }

            CleanupCrvAllocator ();
        }

        WSACleanup ();
    }

    return Result;
} // H323ProxyStartServiceInternal


HRESULT H323ProxyStart (
    void
    )
/*++

Routine Description:

    Initializes components of H.323 proxy

Arguments:

    None

Return Values:

    S_OK if successful, error code otherwise.

Notes:

--*/

{
	HRESULT		Result;

	Result = Q931SyncCounter.Start ();
	if (S_OK == Result) {

        CallBridgeList.Start ();
        Result = Q931CreateBindSocket ();
        if (S_OK == Result)  {

            Result = Q931StartLoopbackRedirect ();
            if (S_OK == Result) {

                return S_OK;

            }

            Q931CloseSocket ();
            CallBridgeList.Stop ();
        }

        Q931SyncCounter.Wait (INFINITE);
        Q931SyncCounter.Stop ();
    }

	return Result;
} // H323ProxyStart


HRESULT LdapProxyStart (
    void
    )
/*++

Routine Description:

    Initializes components of LDAP proxy

Arguments:

    None

Return Values:

    S_OK if successful, error code otherwise

Notes:

--*/

{
	HRESULT	Status;

	Status = LdapSyncCounter.Start ();
    if (S_OK == Status) {

        Status = LdapCoder.Start();
        if (S_OK == Status) {

            Status = LdapTranslationTable.Start ();
            if (S_OK == Status) {

                LdapConnectionArray.Start ();
                Status = LdapAccept.Start ();
                if (S_OK == Status) {

                    return S_OK;
                }

                LdapConnectionArray.Stop ();
                LdapTranslationTable.Stop ();
            }

            LdapCoder.Stop ();
        }
        
        LdapSyncCounter.Wait (INFINITE);

        LdapSyncCounter.Stop ();
    }

    return Status;
} // LdapProxyStart


EXTERN_C ULONG
H323ProxyActivateInterface(
    IN ULONG Index,
    IN H323_INTERFACE_TYPE InterfaceType,
    IN PIP_ADAPTER_BINDING_INFO BindingInfo
    )
/*++

Routine Description:

    Activates an interface for H.323/LDAP

Arguments:
    
    Index       - Interface index (for internal use)
    BindingInfo - Interface binding information

Return Values:

    Win32 error code

Notes:

    Module entry point

--*/

{
    ULONG   Error;

    DebugF (_T("H323: Request to activate interface with adapter index %d.\n"),
        Index);

    if (!BindingInfo->AddressCount ||
        !BindingInfo->Address[0].Address ||
         Index == INVALID_INTERFACE_INDEX) {

        return ERROR_INVALID_PARAMETER;
    }

    Error = InterfaceArray.AddStartInterface (Index, InterfaceType, BindingInfo);

    return Error;
} // H323ProxyActivateInterface

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module shutdown routines                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C void H323ProxyCleanupModule (
    void
    )
/*++

Routine Description:
    Shuts down module
    
Arguments:
    None
    
Return Values:
    None

Notes:
    Equivalent to DLL_PROCESS_DETACH
--*/

{
    Debug (_T("H323: DLL_PROCESS_DETACH\n"));

    H323ASN1Shutdown ();

} // H323ProxyCleanupModule


EXTERN_C
void H323ProxyStopService (
    void
    )
/*++

Routine Description:
    Stops the service
    
Arguments:
    None
    
Return Values:
    None

Notes:
    Module entry point
--*/

{
    LdapProxyStop ();

    H323ProxyStop ();

	InterfaceArray.AssertShutdownReady ();

    InterfaceArray.Stop ();

    PortPoolStop ();

    if (NatHandle) {
        NatShutdownTranslator (NatHandle);
        NatHandle = NULL;
    }

    CleanupCrvAllocator ();

    WSACleanup ();

    Debug (_T("H323: service has stopped\n"));
} // H323ProxyStopService


void
H323ProxyStop (
    void
    )
/*++

Routine Description:
    Stops H.323 proxy and waits until all call-bridges are deleted.
    
Arguments:
    None
    
Return Values:
    None

Notes:

--*/

{
    Q931StopLoopbackRedirect ();

    Q931CloseSocket ();

	CallBridgeList.Stop ();

	Q931SyncCounter.Wait (INFINITE);
    
    Q931SyncCounter.Stop ();
} // H323ProxyStop


void
LdapProxyStop (
    void)
/*++

Routine Description:
    LdapProxyStop is responsible for undoing all of the work that LdapProxyStart performed.
    It deletes the NAT redirect, deletes all LDAP connections (or, at least, it releases them
    -- they may not delete themselves yet if they have pending I/O or timer callbacks),
    and disables the creation of new LDAP connections.
    
Arguments:
    None
    
Return Values:
    None

Notes:

--*/

{
    LdapAccept.Stop ();

	LdapConnectionArray.Stop ();

	LdapTranslationTable.Stop ();

	LdapCoder.Stop();

	LdapSyncCounter.Wait (INFINITE);

    LdapSyncCounter.Stop ();
} // LdapProxyStop


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Component deactivation routines                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


EXTERN_C
VOID
H323ProxyDeactivateInterface (
    IN ULONG Index
    )
/*++

Routine Description:
    Deactivates interface for H.323/LDAP
    
Arguments:
    Index -- Interface index, previously passed to the 
             interface activation routine
    
Return Values:
    None

Notes:
    
    Module entry point
--*/

{
    DebugF (_T("H323: DeactivateInterface called, index %d\n"),
        Index);

    InterfaceArray.RemoveStopInterface (Index);
} // H323ProxyDeactivateInterface

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Auxiliary routines                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


static
void
QueryRegistry (
    void
    )
/*++

Routine Description:
    Queries Registry for the values needed in module operations
    
Arguments:
    None
    
Return Values:
    None

Notes:
    static
--*/

{
    HKEY    Key;
    HRESULT    Result;

    Result = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE, H323ICS_SERVICE_PARAMETERS_KEY_PATH,
        0, 
        KEY_READ, 
        &Key
        );

    if (ERROR_SUCCESS == Result) {

        Result = RegQueryValueDWORD (Key, H323ICS_REG_VAL_LOCAL_H323_ROUTING, &EnableLocalH323Routing);

        if (ERROR_SUCCESS != Result) {

            EnableLocalH323Routing = FALSE;

        }

        RegCloseKey (Key);

    } else {

        EnableLocalH323Routing = FALSE;

    }

    DebugF (_T("H323: Local H323 routing is %sabled.\n"),
            EnableLocalH323Routing ? _T("en") : _T("dis"));

} // QueryRegistry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\logchan.h ===
#ifndef __h323ics_logchan_h
#define __h323ics_logchan_h

// This decides the maximum number of T120 TCP/IP Connections
// to be allowed. We create so many NAT redirects.
#define MAX_T120_TCP_CONNECTIONS_ALLOWED 5

// Logical channel states. These are
// H245 related but there is one per
// logical channel
// NOTE: there is no enum value for the final closed state
// as the logical channel is destroyed when that state is reached
enum LOGICAL_CHANNEL_STATE
{
    LC_STATE_NOT_INIT = 0,
    LC_STATE_OPEN_RCVD,
    LC_STATE_OPEN_ACK_RCVD,
    LC_STATE_CLOSE_RCVD,
    LC_STATE_OPENED_CLOSE_RCVD
};


// Media Types of the logical channels

enum MEDIA_TYPE
{
    MEDIA_TYPE_UNDEFINED    = 0,
    MEDIA_TYPE_RTP          = 0x1000,
    MEDIA_TYPE_T120         = 0x2000,
    MEDIA_TYPE_AUDIO        = MEDIA_TYPE_RTP  | 0x1, //0x1001
    MEDIA_TYPE_VIDEO        = MEDIA_TYPE_RTP  | 0x2, //0x1002
    MEDIA_TYPE_DATA         = MEDIA_TYPE_T120 | 0x1, //0x2000
};

inline BOOL IsMediaTypeRtp(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_RTP);
}

inline BOOL IsMediaTypeT120(MEDIA_TYPE MediaType)
{
    return (MediaType & MEDIA_TYPE_T120);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// This is an abstract base class which defines the operations
// for different types of logical channels.
// RTP_LOGICAL_CHANNEL and T120_LOGICAL_CHANNEL are derived from
// this class.

// Only OpenLogicalChannel and OpenLogicalChannelAck PDUs need
// to be handled differently for the RTP and T.120 Logical channels
// So all the other methods are defined in this class.

class LOGICAL_CHANNEL :
    public TIMER_PROCESSOR
{
    
public:

    inline LOGICAL_CHANNEL();

    HRESULT CreateTimer(DWORD TimeoutValue);

    // the event manager tells us about timer expiry via this method
    virtual void TimerCallback();

    virtual HRESULT HandleCloseLogicalChannelPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // This is a pure virtual function which is different
    // for the RTP and T.120 logical channels.
    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        )= 0;

    virtual HRESULT ProcessOpenLogicalChannelRejectPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessCloseLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~LOGICAL_CHANNEL();

    inline BYTE GetSessionId();

    inline WORD GetLogicalChannelNumber();

    inline MEDIA_TYPE GetMediaType();

    inline LOGICAL_CHANNEL_STATE GetLogicalChannelState();
    
	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // Initializes member variables
    inline void InitLogicalChannel(
        IN H245_INFO               *pH245Info,
        IN MEDIA_TYPE               MediaType,
        IN WORD                     LogicalChannelNumber,
        IN BYTE                     SessionId,
        IN LOGICAL_CHANNEL_STATE    LogicalChannelState
        );
    
    // returns a reference to the source H245 info
    inline H245_INFO &GetH245Info();

    inline CALL_BRIDGE &GetCallBridge();

    inline void DeleteAndRemoveSelf();

    // the logical channel belongs to this H245 channel
    // this supplies the ip addresses needed for NAT redirect
    H245_INFO *m_pH245Info;

    // handle for any active timers
    // TIMER_HANDLE m_TimerHandle;

    // state of the logical channel
    LOGICAL_CHANNEL_STATE   m_LogicalChannelState;

    // logical channel number
    // cannot be 0 as that is reserved for the h245 channel
    WORD    m_LogicalChannelNumber;

    // The type of the media (currently Audio/Video/Data)
    MEDIA_TYPE m_MediaType;

    // session id - this is used to associate with a 
    // logical  channel from the other end if any
    BYTE    m_SessionId;
    
}; // class LOGICAL_CHANNEL

inline 
LOGICAL_CHANNEL::LOGICAL_CHANNEL(
    )
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline 
LOGICAL_CHANNEL::~LOGICAL_CHANNEL(
    )
{}

inline void
LOGICAL_CHANNEL::InitLogicalChannel(
    IN H245_INFO               *pH245Info,
    IN MEDIA_TYPE               MediaType,
    IN WORD                     LogicalChannelNumber,
    IN BYTE                     SessionId,
    IN LOGICAL_CHANNEL_STATE    LogicalChannelState
    )
{
    m_pH245Info             = pH245Info;
    m_MediaType             = MediaType;
    m_LogicalChannelNumber  = LogicalChannelNumber;
    m_SessionId             = SessionId;
    m_LogicalChannelState   = LogicalChannelState;
}


inline BYTE 
LOGICAL_CHANNEL::GetSessionId(
    )
{
    return m_SessionId;
}

inline WORD 
LOGICAL_CHANNEL::GetLogicalChannelNumber(
    )
{
    return m_LogicalChannelNumber;
}

inline MEDIA_TYPE 
LOGICAL_CHANNEL::GetMediaType(
    )
{

    return m_MediaType;
}

inline LOGICAL_CHANNEL_STATE 
LOGICAL_CHANNEL::GetLogicalChannelState(
    )
{
    return m_LogicalChannelState;
}

// returns a reference to the source H245 info
inline H245_INFO &
LOGICAL_CHANNEL::GetH245Info(
    )
{
    _ASSERTE(NULL != m_pH245Info);
    return *m_pH245Info;
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RTP Logical Channel                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class RTP_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline RTP_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // except the associated logical channel, which if supplied provides
    // the member m_Own*RTP/RTCP Ports. If not, these are allocated.
    // the association is implied by a matching session id in a logical
    // channel in the other call state
    // it modifies the RTCP address information in the OLC PDU
    // and passes it on to the other H245 instance for forwarding.
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN DWORD                                LocalIPv4Address,
        IN DWORD                                RemoteIPv4Address,
        IN DWORD                                OtherLocalIPv4Address,
        IN DWORD                                OtherRemoteIPv4Address,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN RTP_LOGICAL_CHANNEL                  *pAssocLogicalChannel,
		IN DWORD								SourceRTCPIPv4Address,
		IN WORD									SourceRTCPPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~RTP_LOGICAL_CHANNEL();

    inline DWORD GetSourceRTCPIPv4Address();

    inline WORD GetSourceRTCPPort();

    inline WORD GetOwnSourceSendRTCPPort();

    inline WORD GetOwnSourceRecvRTCPPort();

    inline WORD GetOwnSourceRecvRTPPort();

    inline WORD GetOwnDestSendRTCPPort();

    inline WORD GetOwnDestRecvRTCPPort();

    inline WORD GetOwnDestSendRTPPort();

    inline DWORD GetDestRTCPIPv4Address();

    inline WORD GetDestRTCPPort();

    inline DWORD GetDestRTPIPv4Address();

    inline WORD GetDestRTPPort();


protected:

    // points to the associated logical channel from the other end if any
    // non-NULL iff associated
    // need to ensure that the AssocLogicalChannel also points
    // to this logical channel
    // CODEWORK: Do assertion checks for this condition.
    RTP_LOGICAL_CHANNEL *m_pAssocLogicalChannel;

    // local and remote addresses for the h245 instance this logical
    // channel is associated with (source side)
    DWORD   m_OwnSourceIPv4Address;
    DWORD   m_SourceIPv4Address;

    // local and remote addresses for the other h245 instance 
    // (dest side)
    DWORD   m_OwnDestIPv4Address;
    DWORD   m_DestIPv4Address;

    // these ports are negotiated in h245 OpenLogicalChannel and
    // OpenLogicalChannelAck. They are given to NAT for redirecting
    // RTP and RTCP traffic
    // while the RTP packets flow only one way (source->dest), RTCP
    // packets flow both ways

    // we only know the source's receive RTCP port. the send port
    // is not known
    DWORD   m_SourceRTCPIPv4Address;
    WORD    m_SourceRTCPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a send RTP port
    WORD    m_OwnSourceSendRTCPPort;
    WORD    m_OwnSourceRecvRTCPPort;
    WORD    m_OwnSourceRecvRTPPort;

    // these are the send/recv RTP/RTCP ports on the interface that 
    // communicates with the source. since we don't deal with the
    // reverse RTP stream, we don't need a recv RTP port
    WORD    m_OwnDestSendRTCPPort;
    WORD    m_OwnDestSendRTPPort;
    WORD    m_OwnDestRecvRTCPPort;

    WORD    m_OwnAssocLCRecvRTPPort; // this is used to allocate consecutive
                                     // ports for RTP/RTCP.
    WORD    m_OwnAssocLCSendRTPPort;
    
    // destination's RTCP ip address, port
    DWORD   m_DestRTCPIPv4Address;
    WORD    m_DestRTCPPort;

    // destination's RTP ip address, port
    DWORD   m_DestRTPIPv4Address;
    WORD    m_DestRTPPort;


    // SetAssociationRef, ResetAssociationRef methods can be accessed
    // by other LOGICAL_CHANNEL instances but not by other instances of
    // classes that are not derived from LOGICAL_CHANNEL

    inline void SetAssociationRef(
        IN RTP_LOGICAL_CHANNEL &LogicalChannel
        );

    inline void ResetAssociationRef();

    inline void ReleaseAssociationAndPorts();

private:
    
    // set the RTP and RTCP ports. if there is an associated channel,
    // we must share the RTCP ports
    HRESULT SetPorts();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  MultimediaSystemControlMessage  &H245pdu,
        OUT BYTE                            &SessionId,
        OUT DWORD                           &DestRTPIPv4Address,
        OUT WORD                            &DestRTPPort,
        OUT DWORD                           &DestRTCPIPv4Address,
        OUT WORD                            &DestRTCPPort
        );

    // opens the forward RTP, forward RTCP and reverse RTCP streams
    HRESULT OpenNATMappings();

    // closes any NAT mappings
    void CloseNATMappings();
};

inline 
RTP_LOGICAL_CHANNEL::RTP_LOGICAL_CHANNEL(
    )
    : m_pAssocLogicalChannel(NULL),
      //m_TimerHandle(NULL),
      m_OwnSourceIPv4Address(0),
      m_SourceIPv4Address(0),
      m_OwnDestIPv4Address(0),
      m_DestIPv4Address(0),
      m_SourceRTCPIPv4Address(0),
      m_SourceRTCPPort(0),
      m_OwnSourceSendRTCPPort(0),
      m_OwnSourceRecvRTCPPort(0),
      m_OwnSourceRecvRTPPort(0),
      m_OwnDestSendRTCPPort(0),
      m_OwnDestRecvRTCPPort(0),
      m_OwnDestSendRTPPort(0),
      m_DestRTCPIPv4Address(0),
      m_DestRTCPPort(0),
      m_DestRTPIPv4Address(0),
      m_DestRTPPort(0)
{
    InitLogicalChannel(NULL, MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}

inline void 
RTP_LOGICAL_CHANNEL::SetAssociationRef(
    IN RTP_LOGICAL_CHANNEL &LogicalChannel
    )
{
    // if the source or dest terminal is generating two logical
    // channels (in the same direction) with the same session id, we'll
    // find a prior logical channel in the array with the same session id
    // and thus never reach here
    _ASSERTE(NULL == m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = &LogicalChannel;
}

inline void 
RTP_LOGICAL_CHANNEL::ResetAssociationRef(
    )
{
    _ASSERTE(NULL != m_pAssocLogicalChannel);
    m_pAssocLogicalChannel = NULL;

    // we, now, own the RTP/RTCP ports that were being shared so far
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPIPv4Address(
    )
{
    return m_SourceRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetSourceRTCPPort(
    )
{
    return m_SourceRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceSendRTCPPort(
    )
{
    return m_OwnSourceSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTCPPort(
    )
{
    return m_OwnSourceRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnSourceRecvRTPPort(
    )
{
    return m_OwnSourceRecvRTPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTCPPort(
    )
{
    return m_OwnDestSendRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestRecvRTCPPort(
    )
{
    return m_OwnDestRecvRTCPPort;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetOwnDestSendRTPPort(
    )
{
    return m_OwnDestSendRTPPort;
}


inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPIPv4Address(
    )
{
    return m_DestRTCPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTCPPort(
    )
{
    return m_DestRTCPPort;
}

inline DWORD 
RTP_LOGICAL_CHANNEL::GetDestRTPIPv4Address(
    )
{
    return m_DestRTPIPv4Address;
}

inline WORD 
RTP_LOGICAL_CHANNEL::GetDestRTPPort(
    )
{
    return m_DestRTPPort;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// T.120 Logical Channel                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class T120_LOGICAL_CHANNEL :
    public LOGICAL_CHANNEL
{
public:

    inline T120_LOGICAL_CHANNEL();

    // all of these are available in the OPEN LOGICAL CHANNEL message
    // it modifies the OLC PDU and passes it on to the other H245
    // instance for forwarding ???
    HRESULT HandleOpenLogicalChannelPDU(
        IN H245_INFO                            &H245Info,
        IN MEDIA_TYPE                           MediaType,
        IN WORD                                 LogicalChannelNumber,
        IN BYTE                                 SessionId,
        IN DWORD                                T120ConnectToIPAddr,
        IN WORD                                 T120ConnectToPort,
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    virtual HRESULT ProcessOpenLogicalChannelAckPDU(
        IN      MultimediaSystemControlMessage   *pH245pdu
        );

    // releases any pending associations
    virtual ~T120_LOGICAL_CHANNEL();


protected:

    // We store all the address and port information in host order.
    // We need to convert them to network order before we pass them
    // to the NAT functions.
    
    // These are the IP Address and port the T.120 end point is listening
    // on for the T.120 connection. We need to connect to this address.
    DWORD   m_T120ConnectToIPAddr;
    WORD    m_T120ConnectToPort;
    
    // These are the IP Address and port we will be listening on.
    // We send this information in the OLC or OLCAck PDU and the T.120
    // end point will connect to this address.
    DWORD   m_T120ListenOnIPAddr;
    WORD    m_T120ListenOnPort;

    // These are the IP Address and port we will be using in the NAT
    // redirect as the new source address of the TCP connection.
    // Once the remote T.120 end point receives a TCP conection,
    // it thinks that the connection is "from" this address.
    // CODEWORK: Any better names ??
    DWORD   m_T120ConnectFromIPAddr;
    WORD    m_T120ConnectFromPorts[MAX_T120_TCP_CONNECTIONS_ALLOWED];

    // Note that we do not know the actual source address and port
    // from which the T.120 endpoint connects. This address is only
    // established when the T.120 endpoint actually calls connect.
    // We pass 0 (wild card) for these fields in the NAT redirect.

private:
    // Allocate m_T120ConnectFromPorts and m_T120ListenOnPort
    HRESULT SetPorts(
        DWORD T120ConnectToIPAddr,
        WORD  T120ConnectToPort,
        DWORD T120ListenOnIPAddr,
        DWORD T120ConnectFromIPAddr
        );

    // Free m_T120ConnectFromPorts and m_T120ListenOnPort
    // if they have been allocated.
    HRESULT FreePorts();
    
    // opens the bidirectional NAT redirect for the TCP stream
    HRESULT CreateNatRedirect();

    // closes any NAT redirect
    void CancelNatRedirect();

    HRESULT CheckOpenLogicalChannelAckPDU(
        IN  OpenLogicalChannelAck   &OlcPDU,
        OUT DWORD                   &T120ConnectToIPAddr,
        OUT WORD                    &T120ConnectToPort
        );
};


inline 
T120_LOGICAL_CHANNEL::T120_LOGICAL_CHANNEL(
    )
    : m_T120ConnectToIPAddr(INADDR_NONE),
      m_T120ConnectToPort(0),
      m_T120ListenOnIPAddr(INADDR_NONE),
      m_T120ListenOnPort(0),
      m_T120ConnectFromIPAddr(INADDR_NONE)
{
    for (int i = 0; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i++)
    {
        m_T120ConnectFromPorts[i] = 0;
    }
    
    InitLogicalChannel(NULL,MEDIA_TYPE_UNDEFINED,
                       0,0,LC_STATE_NOT_INIT);
}


// expandable array of pointer values
template <class T>
class DYNAMIC_POINTER_ARRAY
{
public:

    // number of blocks allocated for a new addition
    // when the array becomes full
#define DEFAULT_BLOCK_SIZE 4

	inline DYNAMIC_POINTER_ARRAY();

    // assumption: other member variables are all 0/NULL
    inline void Init(
        IN DWORD BlockSize = DEFAULT_BLOCK_SIZE
        );

    virtual ~DYNAMIC_POINTER_ARRAY();

    inline T **GetData()
    {
        return m_pData;
    }

    inline DWORD GetSize()
    {
        return m_NumElements;
    }

    DWORD Find(
        IN T& Val
        ) const;

    HRESULT Add(
        IN T &NewVal
        );

    inline T *Get(
        IN  DWORD   Index
        );
    
    inline HRESULT RemoveAt(
        IN DWORD Index
        );

    inline HRESULT Remove(
        IN  T   &Val
        );

protected:

    T       **m_pData;
    DWORD   m_NumElements;

    DWORD   m_AllocElements;

    DWORD   m_BlockSize;
};


template <class T>
inline 
DYNAMIC_POINTER_ARRAY<T>::DYNAMIC_POINTER_ARRAY(
	)
	: m_pData(NULL),
	  m_NumElements(0),
	  m_AllocElements(0),
	  m_BlockSize(0)
{
}

template <class T>
inline void 
DYNAMIC_POINTER_ARRAY<T>::Init(
    IN DWORD BlockSize /* = DEFAULT_BLOCK_SIZE */
    )
{
	_ASSERTE(NULL == m_pData);
    if (0 != BlockSize)
    {
        m_BlockSize = BlockSize;
    }
    else
    {
        m_BlockSize = DEFAULT_BLOCK_SIZE;
    }
}


// NOTE: uses realloc and free to grow/manage the array of pointers.
// This is better than new/delete as the additional memory is allocated
// in-place (i.e. the array ptr remains same) eliminating the need to copy
// memory from the old block to the new block and also reduces 
// heap fragmentation
template <class T>
HRESULT
DYNAMIC_POINTER_ARRAY<T>::Add(
    IN T &NewVal
    )
{
	if(m_NumElements == m_AllocElements)
    {
        typedef T *T_PTR;
        T** ppT = NULL;
        DWORD NewAllocElements = m_NumElements + m_BlockSize;
        ppT = (class LOGICAL_CHANNEL **) 
				realloc(m_pData, NewAllocElements * sizeof(T_PTR));
        if(NULL == ppT)
        {
            return E_OUTOFMEMORY;
        }

		// set the m_pData member to the newly allocated memory
        m_pData = ppT;
		m_AllocElements = NewAllocElements;
    }

    m_pData[m_NumElements] = &NewVal;
    m_NumElements++;
    return S_OK;
}

template <class T>
inline T *
DYNAMIC_POINTER_ARRAY<T>::Get(
    IN  DWORD   Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index < m_NumElements)
    {
        return m_pData[Index];
    }
    else
    {
        return NULL;
    }
}
    
template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::RemoveAt(
    IN DWORD Index
    )
{
    _ASSERTE(Index < m_NumElements);
    if (Index >= m_NumElements)
    {
        return E_FAIL;
    }

    // move all elements (to the right), left by one block
    memmove(
        (void*)&m_pData[Index], 
        (void*)&m_pData[Index + 1], 
        (m_NumElements - (Index + 1)) * sizeof(T *)
        );
    m_NumElements--;    
    return S_OK;
}

template <class T>
inline HRESULT 
DYNAMIC_POINTER_ARRAY<T>::Remove(
    IN  T   &Val
    )
{
    DWORD Index = Find(Val);
    if(Index >= m_NumElements)
    {
        return E_FAIL;
    }

    return RemoveAt(Index);
}

template <class T>
DWORD 
DYNAMIC_POINTER_ARRAY<T>::Find(
    IN T& Val
    ) const
{
    // search for an array element thats same as the passed
	// in value
    for(DWORD Index = 0; Index < m_NumElements; Index++)
    {
        if(m_pData[(DWORD)Index] == &Val)
        {
            return Index;
        }
    }

    return m_NumElements;      // not found
}

template <class T>
/* virtual */
DYNAMIC_POINTER_ARRAY<T>::~DYNAMIC_POINTER_ARRAY(
    )
{
    if (NULL != m_pData)
    {
        // delete each of the elements in the array
        for(DWORD Index = 0; Index < m_NumElements; Index++)
        {
            _ASSERTE(NULL != m_pData[Index]);
            delete m_pData[Index];
        }

        // free the array memory block
		free(m_pData);
    }
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Logical Channel Array                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


class LOGICAL_CHANNEL_ARRAY :
    public DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL>
{
    typedef DYNAMIC_POINTER_ARRAY<LOGICAL_CHANNEL> BASE_CLASS;

public:

    inline LOGICAL_CHANNEL *FindByLogicalChannelNum(
        IN WORD LogicalChannelNumber
        );

    inline LOGICAL_CHANNEL *FindBySessionId(
        IN BYTE SessionId
        );

    inline void CancelAllTimers();
};


inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindByLogicalChannelNum(
    IN WORD LogicalChannelNumber
    )
{
    // check the logical channel number for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        if (m_pData[Index]->GetLogicalChannelNumber()
             == LogicalChannelNumber)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

// SessionID is meaningful only for RTP logical channels.
// We look for only RTP logical channels.

inline LOGICAL_CHANNEL *
LOGICAL_CHANNEL_ARRAY::FindBySessionId(
    IN BYTE SessionId
    )
{
    // 0 is used by a slave terminal to request a session id from the master
    // hence, we shouldn't be searching for a match with 0
    _ASSERTE(0 != SessionId);

    // check the session for each element in the array
    // search from back
    if (0 == m_NumElements) return NULL;
    for(DWORD Index = m_NumElements-1; Index < m_NumElements; Index--)
    {
        _ASSERTE(NULL != m_pData[Index]);
        // SessionID is meaningful only for RTP logical channels.
        // We look for only RTP logical channels.
        if (IsMediaTypeRtp(m_pData[Index]->GetMediaType()) &&
            m_pData[Index]->GetSessionId() == SessionId)
        {
            return m_pData[Index];
        }
    }

    // nothing found
    return NULL;
}

inline void LOGICAL_CHANNEL_ARRAY::CancelAllTimers (void)
{
    for (DWORD Index = 0; Index < m_NumElements; Index++)
    {
        m_pData[(DWORD)Index]->TimprocCancelTimer();
    }
}

#endif // __h323ics_logchan_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\ldappx.cpp ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:
    ldappx.cpp

Abstract:
    Defines methods utilized by abstract data types used in LDAP portion of the H.323/LDAP proxy.

    LDAP Proxy is designed as an addition to H.323 proxy. The main purpose of the
    LDAP proxy is to maintain LDAP Address Translation Table, which is used to map
    aliases of H.323 endpoints to their IP addresses. The proxy adds an entry when it
    intercepts an LDAP PDU from a client to directory server, and the PDU matches all
    predefined criteria.

Author(s):          ArlieD, IlyaK   14-Jul-1999

Revision History:
    07/14/1999      File creation                                  Arlie Davis  (ArlieD)
    08/20/1999      Improvement of processing of LDAP              Ilya Kleyman (IlyaK)
                    LDAP SearchRequests
    12/20/1999      Added prediction of receive sizes in           Ilya Kleyman (IlyaK)
                    non-interpretative data transfer mode
    02/20/2000      Added expiration policy of the entries         Ilya Kleyman (IlyaK)
                    in LDAP Address Translation Table
    03/12/2000      Added support for multiple private and         Ilya Kleyman (IlyaK)
                    multiple public interface for RRAS

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "ber.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Constants                                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

static    const    ANSI_STRING        LdapText_C                        = ANSI_STRING_INIT("c");
static    const    ANSI_STRING        LdapText_CN                       = ANSI_STRING_INIT("cn");
static    const    ANSI_STRING        LdapText_ObjectClass              = ANSI_STRING_INIT("objectClass");
static    const    ANSI_STRING        LdapText_O                        = ANSI_STRING_INIT("o");
static    const    ANSI_STRING        LdapText_OU                       = ANSI_STRING_INIT("ou");

static    const    ANSI_STRING        LdapText_RTPerson                 = ANSI_STRING_INIT("RTPerson");
static    const    ANSI_STRING        LdapText_Attribute_sipaddress     = ANSI_STRING_INIT("sipaddress");
static    const    ANSI_STRING        LdapText_Attribute_ipAddress      = ANSI_STRING_INIT("ipAddress");
static    const    ANSI_STRING        LdapText_Attribute_sttl           = ANSI_STRING_INIT("sttl");
static    const    ANSI_STRING        LdapText_Attribute_comment        = ANSI_STRING_INIT("comment");
static    const    ANSI_STRING        LdapText_Modify_EntryTTL          = ANSI_STRING_INIT("EntryTTL");

static    const    ANSI_STRING        LdapText_GeneratedByTAPI          = ANSI_STRING_INIT("Generated by TAPI3");
static    const    ANSI_STRING        LdapText_ModifiedByICS            = ANSI_STRING_INIT("Made possible by ICS");
static    const    ANSI_STRING        LdapText_TableSizeExceededMessage = ANSI_STRING_INIT("Resources on proxy used up.");

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

SYNC_COUNTER           LdapSyncCounter;
LDAP_CONNECTION_ARRAY  LdapConnectionArray;
LDAP_TRANSLATION_TABLE LdapTranslationTable;
LDAP_CODER             LdapCoder;
LDAP_ACCEPT            LdapAccept;
SOCKADDR_IN            LdapListenSocketAddress;
DWORD                  EnableLocalH323Routing;

// utility functions ------------------------------------------------------------------

#if DBG
static BOOL BerDumpStopFn (VOID)
{
    return FALSE;
}

static void BerDumpOutputFn (char * Format, ...)
{
    if (DebugLevel > 0) {
        va_list    Va;
        CHAR    Text    [0x200];

        va_start (Va, Format);
        _vsnprintf (Text, 0x200, Format, Va);
        va_end (Va);

        OutputDebugStringA (Text);
    }
}

static void BerDump (IN LPBYTE Data, IN DWORD Length)
{
    ber_decode (BerDumpOutputFn, BerDumpStopFn, Data,
        0, // DECODE_NEST_OCTET_STRINGS,
        0, 0, Length, 0);
}

#endif // DBG

// LdapQueryTable queries the LDAP translation table for a given alias.
// The alias was one that was previously registered by a LDAP endpoint.
// We do not care about the type of the alias (h323_ID vs emailID, etc.) --
// the semantics of the alias type are left to the Q.931 code.
//
// returns S_OK on success
// returns S_FALSE if no entry was found
// returns an error code if an actual error occurred.

HRESULT LdapQueryTableByAlias (
    IN    ANSI_STRING *    Alias,
    OUT    DWORD *    ReturnClientAddress) // host order
{
    HRESULT        Result;
    IN_ADDR     Address;

    assert (Alias);
    assert (ReturnClientAddress);

    Result = LdapTranslationTable.QueryTableByAlias (Alias, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    Result = LdapTranslationTable.QueryTableByCN (Alias, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    return Result;
}

HRESULT LdapQueryTableByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    DWORD *    ReturnClientAddress) // host order
{
    HRESULT        Result;
    IN_ADDR     Address;

    assert (Alias);
    assert (ReturnClientAddress);

    Result = LdapTranslationTable.QueryTableByAliasServer (Alias, ServerAddress, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    Result = LdapTranslationTable.QueryTableByCNServer (Alias, ServerAddress, &Address);
    if (Result == S_OK) {
        *ReturnClientAddress = ntohl (Address.s_addr);
        return Result;
    }

    return Result;
}
#if    DBG
void LdapPrintTable (void) {
    LdapTranslationTable.PrintTable ();
}
#endif // DBG

static DWORD LdapDeterminePacketBoundary (
    IN   LDAP_BUFFER * Buffer,
    IN   DWORD         PacketOffset,   
    OUT  DWORD *       NextPacketOffset,   // Points to the beginning of next packet only if function returns ERROR_SUCCESS 
    OUT     DWORD *       NextReceiveSize)    // Is only meaningful when function returns any value other than ERROR_SUCCESS
{
    DWORD    PayloadLength;
    DWORD    ASNHeaderLength = ASN_MIN_HEADER_LEN;
    DWORD    PacketSize;
    DWORD    ByteIndex;
    DWORD   Length;
    LPBYTE  Data;

    assert (Buffer);
    assert (Buffer -> Data.Data);

    Length = Buffer -> Data.Length - PacketOffset;
    Data   = Buffer -> Data.Data;
    
    // Pick reasonable default for the size of
    // next receive request. Will be changed if necessary

    *NextReceiveSize = LDAP_BUFFER_RECEIVE_SIZE;

    if (Length != 0) {

        if (Data [PacketOffset] == ASN_SEQUENCE_TAG) {

            if (Length >= ASN_MIN_HEADER_LEN) {
            
                if (Data [PacketOffset + 1] & ASN_LONG_HEADER_BIT) {
                    // Long (more than ASN_MIN_HEADER_LEN bytes) ASN header
                    // Size of the payload length field is indicated in the
                    // second nybble of second byte

                    ASNHeaderLength += Data [PacketOffset + 1] & ~ASN_LONG_HEADER_BIT;

                    // This is where the limit on payload length is established.
                    // The test below assures it won't be greater than 2 ^ sizeof (DWORD) (4 GBytes)
                    if (ASNHeaderLength <= ASN_MIN_HEADER_LEN + sizeof (DWORD)) {

                        if (Length >= ASNHeaderLength) {

                            PayloadLength  = 0;

                            for (ByteIndex = ASN_MIN_HEADER_LEN;
                                 ByteIndex < ASNHeaderLength; 
                                 ByteIndex++) {
                                
                                 PayloadLength *= 1 << CHAR_BIT;
                                 PayloadLength += (DWORD) Data [PacketOffset + ByteIndex];  
                            }

                        } else {

                            // Not enough data to even read the ASN header
                            return ERROR_MORE_DATA;

                        }

                    } else {

                        DebugF (_T("LDAP: Payload size field (%d bytes) is too big.\n"), ASNHeaderLength - ASN_MIN_HEADER_LEN);

                        return ERROR_INVALID_DATA;
                    }

                } else  {

                    // Short (Exactly ASN_MIN_HEADER_LEN bytes) ASN header
                    // Payload length is indicated in the second byte

                    PayloadLength = (DWORD) Data [PacketOffset + 1];
                }

                PacketSize = ASNHeaderLength + PayloadLength;

                if (Length >= PacketSize) {

                    *NextPacketOffset = PacketOffset + PacketSize;

                    return ERROR_SUCCESS;

                 } else {
                    
                    *NextReceiveSize = PacketSize - Length;
                }
            }

        } else {

            Debug (_T("LDAP: Failed to find ASN sequence tag.\n"));
            
            return ERROR_INVALID_DATA;
        }
    }

    return ERROR_MORE_DATA;
}

static BOOL FindChar (
    IN    ANSI_STRING *    String,
    IN    CHAR            Char,
    OUT    USHORT *        ReturnIndex)
{
    LPSTR    Pos;
    LPSTR    End;

    assert (String);
    assert (ReturnIndex);

    Pos = String -> Buffer;
    End = String -> Buffer + String -> Length / sizeof (CHAR);

    for (; Pos < End; Pos++) {
        if (*Pos == Char) {
            *ReturnIndex = (USHORT) (Pos - String -> Buffer);
            return TRUE;
        }
    }

    return FALSE;
}

static void ParseDirectoryPathElement (
    IN        ANSI_STRING *            Element,
    IN    OUT    LDAP_PATH_ELEMENTS *    PathElements)
{
    ANSI_STRING        Tag;
    ANSI_STRING        Value;
    USHORT            Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        if (RtlEqualStringConst (&Tag, &LdapText_C, TRUE))
            PathElements -> C = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            PathElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_ObjectClass, TRUE))
            PathElements -> ObjectClass = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            PathElements -> O = Value;
    }
}

static void ParseDirectoryPath (
    IN    ANSI_STRING *            DirectoryPath,
    OUT    LDAP_PATH_ELEMENTS *    ReturnData)
{
    ANSI_STRING        SubString;
    USHORT            Index;
    ANSI_STRING        Element;

    assert (DirectoryPath);
    assert (ReturnData);
    assert (DirectoryPath -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_PATH_ELEMENTS));

    SubString = *DirectoryPath;

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseDirectoryPathElement (&Element, ReturnData);
    }

    ParseDirectoryPathElement (&SubString, ReturnData);
}

static void ParseObjectNameElement (
    IN        ANSI_STRING *                Element,
    IN    OUT    LDAP_OBJECT_NAME_ELEMENTS *    ObjectNameElements)
{
    ANSI_STRING        Tag;
    ANSI_STRING        Value;
    USHORT            Index;

    if (FindChar (Element, LDAP_PATH_EQUAL_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < Element -> Length);

        Tag.Buffer = Element -> Buffer;
        Tag.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        Value.Buffer = Element -> Buffer + Index;
        Value.Length = Element -> Length - Index * sizeof (CHAR);

        if (RtlEqualStringConst (&Tag, &LdapText_CN, TRUE))
            ObjectNameElements -> CN = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_O, TRUE))
            ObjectNameElements -> O = Value;
        else if (RtlEqualStringConst (&Tag, &LdapText_OU, TRUE))
            ObjectNameElements -> OU = Value;
    }
}

static void ParseObjectName (
    IN    ANSI_STRING *                ObjectName,
    OUT    LDAP_OBJECT_NAME_ELEMENTS *    ReturnData)
{
    ANSI_STRING        SubString;
    USHORT            Index;
    ANSI_STRING        Element;

    assert (ObjectName);
    assert (ReturnData);
    assert (ObjectName -> Buffer);

    ZeroMemory (ReturnData, sizeof (LDAP_OBJECT_NAME_ELEMENTS));

    SubString = *ObjectName;

    while (FindChar (&SubString, LDAP_PATH_SEP_CHAR, &Index)) {
        assert (Index * sizeof (CHAR) < SubString.Length);

        Element.Buffer = SubString.Buffer;
        Element.Length = Index * sizeof (CHAR);

        Index++;        // step over separator

        SubString.Buffer += Index;
        SubString.Length -= Index * sizeof (CHAR);

        ParseObjectNameElement (&Element, ReturnData);
    }

    ParseObjectNameElement (&SubString, ReturnData);
}

// LDAP_TRANSLATION_ENTRY ------------------------------------------------


HRESULT 
LDAP_TRANSLATION_ENTRY::IsRegisteredViaInterface (
    IN DWORD InterfaceAddress,      // host order
    OUT BOOL *Result
    )
/*++

Routine Description:
    Determines whether the entry is registered via the
    interface specified

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

    Result (out)     - TRUE if entry was registered via the interface
                       FALSE if entry was not registered via the interface

Return Values:
    TRUE - if determination succeeded

    FALSE - if determination failed

Notes:

--*/

{
    DWORD BestInterfaceAddress;
    ULONG Error;

    Error = GetBestInterfaceAddress (ntohl (ClientAddress.s_addr), &BestInterfaceAddress);

    *Result = FALSE;

    if (ERROR_SUCCESS == Error) {

        *Result = (BestInterfaceAddress == InterfaceAddress);
    }

    return HRESULT_FROM_WIN32 (Error);
}

// LDAP_TRANSLATION_TABLE ------------------------------------------------

LDAP_TRANSLATION_TABLE::LDAP_TRANSLATION_TABLE (void)
{
    IsEnabled = FALSE;
    GarbageCollectorTimerHandle = NULL;
}

LDAP_TRANSLATION_TABLE::~LDAP_TRANSLATION_TABLE (void)
{
    assert (!IsEnabled);
    assert (Array.Length == 0);
}

void LDAP_TRANSLATION_TABLE::Stop (void)
{
    HRESULT Result;

    Lock();

    IsEnabled = FALSE;

    if (GarbageCollectorTimerHandle) {

        if (DeleteTimerQueueTimer(NATH323_TIMER_QUEUE, 
                                  GarbageCollectorTimerHandle,
                                  INVALID_HANDLE_VALUE))
        {

            DebugF (_T("LDAP: Garbage collection is deactivated.\n"));

        }
        else {

            Result = GetLastError ();

            DebugError (Result, _T("LDAP: Could not deactivate garbage collection.\n"));

        }

        GarbageCollectorTimerHandle = NULL;
    }

    Array.Free();

    Unlock ();
}

HRESULT LDAP_TRANSLATION_TABLE::Start (void)
{
    HRESULT Result;

    Lock ();

    assert (!GarbageCollectorTimerHandle);

    if (CreateTimerQueueTimer(&GarbageCollectorTimerHandle,
                               NATH323_TIMER_QUEUE,
                               GarbageCollectorCallback,
                               this,
                               LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD,
                               LDAP_TRANSLATION_TABLE_GARBAGE_COLLECTION_PERIOD,    // periodic timer
                               WT_EXECUTEINIOTHREAD)) {

        DebugF (_T("LDAP: Successfully activated garbage collection.\n"));

        IsEnabled = TRUE;

        Result = S_OK;
    }
    else {

        Result = GetLastError ();

        DebugLastError (_T("LDAP: Failed to activate garbage collection.\n"));
    }

    Unlock ();

    return Result;
}

// static
void LDAP_TRANSLATION_TABLE::GarbageCollectorCallback (
    PVOID Context,
    BOOLEAN TimerOrWaitFired) 
{
    LDAP_TRANSLATION_TABLE * Table;

    Table = (LDAP_TRANSLATION_TABLE *) Context;

    Table -> RemoveOldEntries ();
}

HRESULT LDAP_TRANSLATION_TABLE::RefreshEntry (
    IN ANSI_STRING * Alias,
    IN ANSI_STRING * DirectoryPath,
    IN IN_ADDR       ClientAddress,
    IN SOCKADDR_IN * ServerAddress,
    IN DWORD         TimeToLive) // in seconds
{
    DebugF (_T("LDAP: Refreshing local entry for (%.*S) @ %08X:%04X.\n"), 
                ANSI_STRING_PRINTF (Alias),
                SOCKADDR_IN_PRINTF (ServerAddress));

    return InsertEntry (Alias, DirectoryPath, ClientAddress, ServerAddress, TimeToLive);
}

void LDAP_TRANSLATION_TABLE::RemoveOldEntries (void)
{
    DWORD CurrentTime;

    DWORD  Index;

    Lock ();

    if (IsEnabled) {

        CurrentTime = GetTickCount () / 1000;

        DebugF (_T("LDAP: Garbage collection commenced at %d.\n"), CurrentTime);

        Index = 0;

        while (Index < Array.Length) {

            if (CurrentTime > Array [Index].TimeStamp) {

                DebugF (_T("LDAP: Expiring entry @%d, alias -- (%.*S) from translation table.\n"),
                     Index, ANSI_STRING_PRINTF (&Array [Index].Alias));

                Array[Index].FreeContents ();
                Array.DeleteAtPos (Index);

                InterfaceArray.StopQ931ReceiveRedirects ();

            } else {
                
                Index++;
            }
        }

        DebugF (_T("LDAP: Garbage collection completed.\n"));
    }

    Unlock ();
}
    
HRESULT LDAP_TRANSLATION_TABLE::QueryTableByAlias (
    IN    ANSI_STRING *    Alias,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    DWORD        Index;
    HRESULT        Result;
    
    assert (Alias);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> Alias, Alias, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }

    }
    else {
        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByCN (
    IN    ANSI_STRING *    CN,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    assert (CN);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            if (RtlEqualStringConst (&Pos -> CN, CN, TRUE)) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    DWORD        Index;
    HRESULT        Result;
    BOOL        ServerIsSame;
    BOOL        AliasIsSame;
    
    assert (Alias);
    assert (ServerAddress);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {

            AliasIsSame = RtlEqualStringConst (&Pos -> Alias, Alias, TRUE); 
            ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                           ||
                           (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                             && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine

            if (AliasIsSame && ServerIsSame) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }

    }
    else {
        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::QueryTableByCNServer (
    IN    ANSI_STRING *    CN,
    IN  SOCKADDR_IN *   ServerAddress,
    OUT    IN_ADDR *        ReturnClientAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    BOOL        ServerIsSame;
    BOOL        CN_IsSame;

    assert (CN);
    assert (ServerAddress);
    assert (ReturnClientAddress);

    Lock();

    if (IsEnabled) {

        Result = S_FALSE;

        Array.GetExtents (&Pos, &End);
        for (; Pos < End; Pos++) {
            CN_IsSame = RtlEqualStringConst (&Pos -> CN, CN, TRUE); 
            ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                           ||
                           (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                             && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine

            if (CN_IsSame && ServerIsSame) {
                *ReturnClientAddress = Pos -> ClientAddress;
                Result = S_OK;
                break;
            }
        }
    }
    else {

        Result = S_FALSE;
    }

    Unlock();

    return Result;
}

#if DBG
void LDAP_TRANSLATION_TABLE::PrintTable (void)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;

    DebugF (_T("LDAP: Printing out Address Translation Table.\n"));
 
    Lock();

    if (IsEnabled) {

        Array.GetExtents (&Pos, &End);

        DebugF (_T("\n"));

        for (; Pos < End; Pos++) {
            DebugF (_T("\tEntry at %x:\n"), Pos);
            DebugF (_T ("\t\tAlias - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> Alias)); 
            DebugF (_T ("\t\tDirectoryPath - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> DirectoryPath)); 
            DebugF (_T ("\t\tCN - %.*S\n"),
                 ANSI_STRING_PRINTF (&Pos -> CN)); 
            DebugF (_T("\t\tClientAddress - %x\n"), ntohl(Pos->ClientAddress.s_addr));
            DebugF (_T("\t\tServerAddress - %x:%x\n"),
                SOCKADDR_IN_PRINTF (&Pos -> ServerAddress));
            DebugF (_T("\t\tTimeStamp - %u\n"), Pos -> TimeStamp);
        }

        DebugF (_T("\n"));
    }

    Unlock();
}
#endif

HRESULT LDAP_TRANSLATION_TABLE::InsertEntry (
    IN    ANSI_STRING *    Alias,
    IN    ANSI_STRING *    DirectoryPath,
    IN    IN_ADDR            ClientAddress,
    IN    SOCKADDR_IN *    ServerAddress,
    IN    DWORD            TimeToLive) // in seconds
{
    HRESULT  Result;

    assert (Alias);
    assert (Alias -> Buffer);
    assert (DirectoryPath);
     assert (DirectoryPath -> Buffer);
    assert (ServerAddress);

    Lock();

    Result = InsertEntryLocked (Alias, DirectoryPath, ClientAddress, ServerAddress, TimeToLive);

    Unlock();

#if DBG
    if (DebugLevel > 1) 
    {

        LdapPrintTable ();

    }
#endif // DBG

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::FindEntryByPathServer (
    IN    ANSI_STRING *    DirectoryPath,
    IN    SOCKADDR_IN *    ServerAddress,
    OUT    LDAP_TRANSLATION_ENTRY **    ReturnTranslationEntry)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualStringConst (&Pos -> DirectoryPath, DirectoryPath, TRUE)
            && IsEqualSocketAddress (&Pos -> ServerAddress, ServerAddress)) {

            *ReturnTranslationEntry = Pos;
            Result = S_OK;
            break;
        }
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::FindEntryByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN    SOCKADDR_IN *    ServerAddress,
    OUT    LDAP_TRANSLATION_ENTRY **    ReturnTranslationEntry)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualStringConst (&Pos -> Alias, Alias, TRUE)
            // && IsEqualSocketAddress (&Pos -> ServerAddress, ServerAddress)) {
            && Pos -> ServerAddress.sin_addr.s_addr == ServerAddress -> sin_addr.s_addr) {

            *ReturnTranslationEntry = Pos;
            Result = S_OK;
            break;
        }
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::InsertEntryLocked (
    IN    ANSI_STRING *    Alias,
    IN    ANSI_STRING *    DirectoryPath,
    IN    IN_ADDR            ClientAddress,
    IN    SOCKADDR_IN *    ServerAddress,
    IN    DWORD            TimeToLive) // in seconds
{
    LDAP_TRANSLATION_ENTRY *    TranslationEntry;
    LDAP_PATH_ELEMENTS    PathElements;
    HRESULT            Result;
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;

    assert (Alias);
    assert (DirectoryPath);
    assert (ServerAddress);

    if (!IsEnabled)
        return S_FALSE;

    // locate any existing entry
    // the identity of the entry is determined by the tuple:
    //        < ServerAddress ClientAlias >

    if (FindEntryByAliasServer (Alias, ServerAddress, &TranslationEntry) == S_OK) {
        Debug (_T("LDAP: Replacing existing translation entry.\n"));

        TranslationEntry -> FreeContents();
    }
    else {
        Debug (_T("LDAP: Allocating new translation entry.\n"));

        TranslationEntry = Array.AllocAtEnd();
        if (!TranslationEntry) {
            Debug (_T("LDAP: Failed to allocate translation entry.\n"));
            return E_OUTOFMEMORY;
        }
    }

    TranslationEntry -> ClientAddress = ClientAddress;
    TranslationEntry -> ServerAddress = *ServerAddress;
    TranslationEntry -> TimeStamp  = GetTickCount () / 1000 + TimeToLive;

    // copy the strings
    CopyAnsiString (Alias, &TranslationEntry -> Alias);
    CopyAnsiString (DirectoryPath, &TranslationEntry -> DirectoryPath);

    if (TranslationEntry -> DirectoryPath.Buffer) {
        ParseDirectoryPath (&TranslationEntry -> DirectoryPath, &PathElements);
        if (PathElements.CN.Buffer) {
            TranslationEntry -> CN = PathElements.CN;
        }
        else {
            Debug (_T("LDAP: Cannot insert translation entry -- CN is not specified.\n"));
            TranslationEntry -> CN.Buffer = NULL;
        }
    }
    else {
        TranslationEntry -> CN.Buffer = NULL;
    }

    // test and make sure all allocation code paths succeeded
    if (TranslationEntry -> Alias.Buffer
        && TranslationEntry -> DirectoryPath.Buffer
        && TranslationEntry -> CN.Buffer) {

        Result = S_OK;

    } else {
        Debug (_T("LDAP: Failed to allocate memory (or failed to find CN).\n"));

        FreeAnsiString (&TranslationEntry -> Alias);
        FreeAnsiString (&TranslationEntry -> DirectoryPath);

        Array.DeleteEntry (TranslationEntry);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntry (
    IN    SOCKADDR_IN *    ServerAddress,
    IN    ANSI_STRING *    DirectoryPath)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    
    Lock();

    assert (ServerAddress);
    assert (DirectoryPath);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {

        if (RtlEqualString (DirectoryPath, &Pos -> DirectoryPath, TRUE)
            && Compare_SOCKADDR_IN (ServerAddress, &Pos -> ServerAddress) == 0) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            InterfaceArray.StopQ931ReceiveRedirects ();

            Result = S_OK;

            break;
        }
    }

    Unlock();

    return Result;
}

HRESULT LDAP_TRANSLATION_TABLE::RemoveEntryByAliasServer (
    IN    ANSI_STRING *    Alias,
    IN  SOCKADDR_IN *   ServerAddress)
{
    LDAP_TRANSLATION_ENTRY *    Pos;
    LDAP_TRANSLATION_ENTRY *    End;
    HRESULT        Result;
    BOOL        AliasIsSame;
    BOOL        ServerIsSame;
    
    Lock ();

    assert (Alias);

    Result = S_FALSE;

    Array.GetExtents (&Pos, &End);
    for (; Pos < End; Pos++) {
        AliasIsSame = RtlEqualStringConst (&Pos -> Alias, Alias, TRUE); 
        ServerIsSame = (ServerAddress -> sin_addr.s_addr == Pos -> ServerAddress.sin_addr.s_addr) // addresses are literally equal
                       ||
                       (    ::NhIsLocalAddress (ServerAddress -> sin_addr.s_addr)
                         && ::NhIsLocalAddress (Pos -> ServerAddress.sin_addr.s_addr));         // two addresses of the local machine


        if (AliasIsSame && ServerIsSame) {

            Pos -> FreeContents();

            Array.DeleteEntry (Pos);

            InterfaceArray.StopQ931ReceiveRedirects ();

            Result = S_OK;

            break;
        }
    }

    Unlock ();

    return Result;
}
 

void 
LDAP_TRANSLATION_TABLE::OnInterfaceShutdown (
    IN DWORD          InterfaceAddress
    )
/*++

Routine Description:
    Removes all entries registered by the clients reachable
    thorough the interface specified, except for entries registered by
    a local client.

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

Return Values:
    None

Notes:

--*/

{
    DWORD ArrayIndex = 0;
    LDAP_TRANSLATION_ENTRY * Entry;
    BOOL  IsEntryToBeDeleted;
    HRESULT Result;

    Lock ();
    
    if (IsEnabled) {

        DebugF (_T("LDAP: Forcibly removing non-local translation entries registered via %08X.\n"), InterfaceAddress);

        while (ArrayIndex < Array.GetLength ()) {
            Entry = &Array [ArrayIndex];

            Result = Entry -> IsRegisteredViaInterface (InterfaceAddress, &IsEntryToBeDeleted);

            // Don't delete the entry if it was registered by a local client. This is because
            // the client will still be available for H.323 calls.
            IsEntryToBeDeleted = IsEntryToBeDeleted && !::NhIsLocalAddress (Entry -> ClientAddress.s_addr);

            if (S_OK == Result) {

                if (IsEntryToBeDeleted) {

                    DebugF (_T("LDAP: Forcibly removing entry (%.*S:%08X) @ %08X:%04X.\n"), 
                        ANSI_STRING_PRINTF (&Entry -> Alias), 
                        ntohl (Entry -> ClientAddress.s_addr),
                        SOCKADDR_IN_PRINTF (&Entry -> ServerAddress));

                    Entry -> FreeContents();

                    Array.DeleteEntry (Entry);

                    InterfaceArray.StopQ931ReceiveRedirects ();

                } else {

                    ArrayIndex++;

                }

            } else {
            
                // There probably was something wrong with just this entry. Skip it and continue 
                // searching for entries registered via the interface

                ArrayIndex++;

                DebugF (_T("LDAP: Failed to determine whether entry (%.*S:%08X) @ %08X:%04X was registered via interface %08X. Error=0x%x\n"),
                        ANSI_STRING_PRINTF (&Entry -> Alias), 
                        ntohl (Entry -> ClientAddress.s_addr),
                        SOCKADDR_IN_PRINTF (&Entry -> ServerAddress),
                        InterfaceAddress,
                        Result);
            }
        }
    }

    Unlock ();

} // LDAP_TRANSLATION_TABLE::RemoveEntriesForClientsOnInterface

BOOL LDAP_TRANSLATION_TABLE::ReachedMaximumSize (void) {
    DWORD NumberOfEntries;

    Lock ();

    NumberOfEntries = Array.Length;

    Unlock ();

    return NumberOfEntries >= LDAP_MAX_TRANSLATION_TABLE_SIZE;
}

// LDAP_SOCKET ----------------------------------------------

LDAP_SOCKET::LDAP_SOCKET (
    IN    LDAP_CONNECTION    *    ArgLdapConnection,
    IN    LDAP_PUMP *            ArgRecvPump,
    IN    LDAP_PUMP *            ArgSendPump)
{
    assert (ArgLdapConnection);
    assert (ArgRecvPump);
    assert (ArgSendPump);

    LdapConnection = ArgLdapConnection;
    RecvPump = ArgRecvPump;
    SendPump = ArgSendPump;

    State = STATE_NONE;
    BytesToReceive = LDAP_BUFFER_RECEIVE_SIZE;
    Socket = INVALID_SOCKET;

    ZeroMemory (&RecvOverlapped, sizeof RecvOverlapped);
    RecvOverlapped.Socket = this;
    RecvBuffer = NULL;
    InitializeListHead (&RecvBufferQueue);

    ZeroMemory (&SendOverlapped, sizeof SendOverlapped);
    SendOverlapped.Socket = this;
    SendBuffer = NULL;
    InitializeListHead (&SendBufferQueue);

    ConnectEvent = NULL;
    ConnectWaitHandle = NULL;
    AttemptAnotherConnect = TRUE;

    IsNatRedirectActive = FALSE;
}

LDAP_SOCKET::~LDAP_SOCKET (void)
{
    DeleteBufferList (&RecvBufferQueue);
    DeleteBufferList (&SendBufferQueue);

    if (RecvBuffer) {

        delete RecvBuffer;

        RecvBuffer = NULL;
    }

    assert (IsListEmpty (&RecvBufferQueue));
    assert (IsListEmpty (&SendBufferQueue));
    assert (!SendBuffer);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);
}

void LDAP_SOCKET::DeleteBufferList (LIST_ENTRY * ListHead)
{
    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *    Buffer;

    while (!IsListEmpty (ListHead)) {
        ListEntry = RemoveHeadList (ListHead);
        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        delete Buffer;
    }
}

BOOL LDAP_SOCKET::RecvRemoveBuffer (
    OUT    LDAP_BUFFER **    ReturnBuffer)
{
    LIST_ENTRY *    ListEntry;

    assert (ReturnBuffer);

    if (IsListEmpty (&RecvBufferQueue))
        return FALSE;
    else {
        ListEntry = RemoveHeadList (&RecvBufferQueue);
        *ReturnBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);
        return TRUE;
    }
}

void LDAP_SOCKET::RecvBuildBuffer (
    IN    LPBYTE    Data,
    IN    DWORD    Length)
{
    LDAP_BUFFER *    Buffer;

    assert (Data);
    AssertLocked();

    Buffer = new LDAP_BUFFER;

    if (!Buffer) {
        Debug (_T("LDAP: RecvBuildBuffer, allocation failure #1.\n"));
        return;
    }

    if (Buffer -> Data.Grow (Length)) {
        memcpy (Buffer -> Data.Data, Data, Length);
        Buffer -> Data.Length = Length;

        InsertTailList (&RecvBufferQueue, &Buffer -> ListEntry);
    }
    else {
        Debug (_T("LDAP: RecvBuildBuffer, allocation failure #2.\n"));

        delete Buffer;
    }
}

HRESULT LDAP_SOCKET::AcceptSocket (
    SOCKET LocalClientSocket)
{
    if (State != STATE_NONE) {

        Debug (_T("LDAP: Not in a valid state for AcceptSocket (State != STATE_NONE).\n"));
        return E_UNEXPECTED;
    }

    State  = STATE_CONNECTED;
    Socket = LocalClientSocket;

    // notify parent about state change
    LdapConnection -> OnStateChange (this, State);
    
    if (!BindIoCompletionCallback ((HANDLE) Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {

        DebugLastError (_T("LDAP: Failed to bind I/O completion callback.\n"));

        return GetLastErrorAsResult ();
    }
        
    return S_OK;
}

HRESULT LDAP_SOCKET::IssueConnect (
    SOCKADDR_IN * DestinationAddress)
{

    HRESULT Status;
    HRESULT Result;
    ULONG   Error;
    INT     RealSourceAddrSize = sizeof (SOCKADDR_IN);
    DWORD   BestInterfaceAddress; // host order
    int     ConnectError;
    BOOL    KeepaliveOption;

    assert (DestinationAddress);

    if (State != STATE_NONE) {

        Debug (_T("LDAP: Not in a valid state for IssueConnect (State != STATE_NONE).\n"));
        
        return E_UNEXPECTED;
    }

    assert (Socket == INVALID_SOCKET);
    assert (!ConnectEvent);
    assert (!ConnectWaitHandle);

    ActualDestinationAddress = *DestinationAddress;

    // If ILS runs on a remote (public) machine, we need to determine on which public
    // interface we will connect to the server. This is so to override global interface-restricted
    // NAT redirect by creating a trivial NAT redirect to the server's address from
    // the address of the public interface determined.
    //
    // If server happens to run on the local machine, then we use loopback address
    // as this is the address from where we will be "connecting" to the server.
    if (!::NhIsLocalAddress (DestinationAddress -> sin_addr.s_addr)) {

        Error = GetBestInterfaceAddress (
                    ntohl (DestinationAddress -> sin_addr.s_addr),
                    &BestInterfaceAddress);
            
        if (ERROR_SUCCESS != Error) {
            
            Result = HRESULT_FROM_WIN32 (Error); 
        
            DebugErrorF (Error, _T("LDAP: Failed to get best interface address for %08X.\n"), 
                    ntohl (DestinationAddress -> sin_addr.s_addr));

            return Result;
        }

    } else {

        BestInterfaceAddress = INADDR_LOOPBACK;
    }

    RealSourceAddress.sin_family      = AF_INET;
    RealSourceAddress.sin_addr.s_addr = htonl (BestInterfaceAddress);
    RealSourceAddress.sin_port        = htons (0); 

    Socket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (Socket == INVALID_SOCKET) {

        Result = GetLastErrorAsResult ();

        DebugLastError (_T("LDAP: Failed to create destination socket.\n"));

    } else {

        // At this point we actually start the connect procedures. Everything before that
        // was just a preparation, so the socket stayed in the STATE_NONE.
        State = STATE_ISSUING_CONNECT;
    
        if (SOCKET_ERROR == bind(Socket, (PSOCKADDR)&RealSourceAddress, RealSourceAddrSize)) {

            Result = GetLastErrorAsResult();

            DebugLastError (_T("LDAP: Failed to bind destination socket.\n"));

        } else {

            // Set keepalive on the socket
            KeepaliveOption = TRUE;
            if (SOCKET_ERROR == setsockopt (Socket, SOL_SOCKET, SO_KEEPALIVE,
                                           (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
            {
                Result = GetLastErrorAsResult ();
                DebugLastError (_T("LDAP: Failed to set keepalive on destination socket.\n"));

            }  else {

                if (getsockname (Socket, (struct sockaddr *)&RealSourceAddress, &RealSourceAddrSize)) {

                    Result = GetLastErrorAsResult ();

                    DebugLastError (_T("LDAP: Failed to get name of TCP socket.\n"));

                } else {

                    DebugF (_T("LDAP: 0x%x setting up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                        LdapConnection,
                        SOCKADDR_IN_PRINTF(&RealSourceAddress), SOCKADDR_IN_PRINTF(DestinationAddress),
                        SOCKADDR_IN_PRINTF(&RealSourceAddress), SOCKADDR_IN_PRINTF(DestinationAddress));

                    if( NO_ERROR != NatCreateRedirectEx ( 
                            NatHandle, 
                            NatRedirectFlagLoopback,
                            IPPROTO_TCP, 
                            DestinationAddress -> sin_addr.s_addr,
                            DestinationAddress -> sin_port,
                            RealSourceAddress.sin_addr.s_addr, 
                            RealSourceAddress.sin_port,
                            DestinationAddress -> sin_addr.s_addr,
                            DestinationAddress -> sin_port,
                            RealSourceAddress.sin_addr.s_addr, 
                            RealSourceAddress.sin_port, 
                            NULL,
                            NULL, 
                            NULL, 
                            NULL)) {
                        
                        Result = GetLastErrorAsResult();

                        DebugLastErrorF (_T("LDAP: 0x%x failed to create trivial redirect.\n"),  
                            LdapConnection);
                
                    } else {

                        // we have successfully created a redirect
                        IsNatRedirectActive = TRUE;

                        do
                        {
                            ConnectEvent = CreateEvent (NULL, FALSE, FALSE, NULL); 

                            if (!ConnectEvent) { 

                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to create connect-event.\n"),
                                    LdapConnection);

                                break;
                            }

                            Status = WSAEventSelect (Socket, ConnectEvent, FD_CONNECT);

                            if (Status) {
                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to select events on the socket.\n"),
                                    LdapConnection);
                                break;
                            }

                            LdapConnection -> AddRef ();

                            if (!RegisterWaitForSingleObject (
                                    &ConnectWaitHandle, 
                                    ConnectEvent, 
                                    LDAP_SOCKET::OnConnectCompletion,
                                    this,
                                    INFINITE,
                                    WT_EXECUTEDEFAULT)) {

                                Result = GetLastErrorAsResult();

                                DebugLastErrorF (_T("LDAP: 0x%x failed to RegisterWaitForSingleObject.\n"),
                                    LdapConnection);
                                
                                LdapConnection -> Release ();

                                break;
                            } 
                            
                            if (connect (Socket, (SOCKADDR *)DestinationAddress, sizeof (SOCKADDR_IN))) {

                                ConnectError = WSAGetLastError ();

                                if(ConnectError == WSAEWOULDBLOCK) {

                                    State = STATE_CONNECT_PENDING;

                                    LdapConnection->OnStateChange (this, State);

                                    Result = S_OK;

                                } else {

                                    // a real error
                        
                                    Result = GetLastErrorAsResult();
                                        
                                    DebugLastErrorF (_T("LDAP: 0x%x failed to issue async connect.\n"),
                                        LdapConnection);
                                    
                                    FreeConnectResources ();

                                    // If remote server refused to connect, make an attempt to 
                                    // connect on a different port. Don't try to do so 
                                    // for any other error.

                                    if ((WSAECONNREFUSED == ConnectError || WSAECONNRESET == ConnectError)
                                         && AttemptAnotherConnect) {

                                        AttemptAnotherConnect = FALSE;

                                        DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                                                    LdapConnection,
                                                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                                                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                                                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                                                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

                                        NatCancelRedirect ( 
                                            NatHandle, 
                                            IPPROTO_TCP, 
                                            ActualDestinationAddress.sin_addr.s_addr,
                                            ActualDestinationAddress.sin_port,
                                            RealSourceAddress.sin_addr.s_addr, 
                                            RealSourceAddress.sin_port,
                                            ActualDestinationAddress.sin_addr.s_addr,
                                            ActualDestinationAddress.sin_port,
                                            RealSourceAddress.sin_addr.s_addr, 
                                            RealSourceAddress.sin_port); 

                                        IsNatRedirectActive = FALSE;

                                        closesocket (Socket);
                                        Socket = INVALID_SOCKET;
                                        
                                        State = STATE_NONE;

                                        Result = AttemptAlternateConnect (); // calls IssueConnect internally
                                    }

                                    LdapConnection -> Release ();
                                }

                                break;

                            } else {
                                // connect completed synchronously
                                // this should never occur

                                DebugF (_T("LDAP: 0x%x completed synchronously -- this should never occur.\n"),
                                    LdapConnection);

                                FreeConnectResources ();
                               
                                LdapConnection -> Release ();

                                Result = E_UNEXPECTED;

                            }
                       } while(FALSE);
                   }
                }
            }
        }
    }
            
    return Result;
}

// static
void LDAP_SOCKET::IoCompletionCallback (
    DWORD            Status, 
    DWORD            BytesTransferred, 
    LPOVERLAPPED    Overlapped)
{
    LDAP_OVERLAPPED *    LdapOverlapped;
    LDAP_CONNECTION *    Connection;

    LdapOverlapped = CONTAINING_RECORD (Overlapped, LDAP_OVERLAPPED, Overlapped);

    assert (LdapOverlapped -> Socket);

    Connection = LdapOverlapped -> Socket -> LdapConnection;

    LdapOverlapped -> Socket -> OnIoComplete (Status, BytesTransferred, LdapOverlapped);

    Connection -> Release();
}

void LDAP_SOCKET::OnIoComplete (
    DWORD                Status, 
    DWORD                BytesTransferred, 
    LDAP_OVERLAPPED *    Overlapped)
{
    Lock();

    assert (Overlapped -> IsPending);

    Overlapped -> IsPending = FALSE;
    Overlapped -> BytesTransferred = BytesTransferred;

    if (Overlapped == &RecvOverlapped)
        OnRecvComplete (Status);
    else if (Overlapped == &SendOverlapped)
        OnSendComplete (Status);
    else {
        AssertNeverReached();
    }

    Unlock();
}

// static
void LDAP_SOCKET::OnConnectCompletion (
    PVOID        Context,
    BOOLEAN        TimerOrWaitFired)
{
    LDAP_SOCKET *    LdapSocket;

    assert (Context);

    LdapSocket = (LDAP_SOCKET *) Context;

    LdapSocket -> Lock ();
    LdapSocket -> OnConnectCompletionLocked ();
    LdapSocket -> Unlock ();

    LdapSocket -> LdapConnection -> Release ();
}

void LDAP_SOCKET::OnRecvComplete (DWORD Status)
{
    DWORD StartOffset;
    DWORD NextPacketOffset;
    DWORD NextReceiveSize = 0;
    DWORD Result;

    LIST_ENTRY *    ListEntry;
    LDAP_BUFFER *    Buffer;


    if (Status != ERROR_SUCCESS) {

        if (State != STATE_TERMINATED) {

            Terminate();
        }

        return;
    }

    if (RecvOverlapped.BytesTransferred == 0) {

#if    DBG
        if (this == &LdapConnection -> ClientSocket)
        {
            DebugF (_T("LDAP: 0x%x client has closed transport socket.\n"), LdapConnection);
        }
        else if (this == &LdapConnection -> ServerSocket)
        {
            DebugF (_T("LDAP: 0x%x server has closed transport socket.\n"), LdapConnection);
        }
        else
            AssertNeverReached();
#endif

        Terminate();

        return;
    }

    assert (RecvBuffer);

    assert (RecvBuffer -> Data.Length + RecvOverlapped.BytesTransferred
        <= RecvBuffer -> Data.MaxLength);

    RecvBuffer -> Data.Length += RecvOverlapped.BytesTransferred;

    if (State == STATE_TERMINATED) {

        DebugF (_T("LDAP: 0x%x is terminating, no further processing will occur.\n"), LdapConnection);

        return;
    }

    if (RecvPump -> IsActivelyPassingData ()) {

        StartOffset = 0;

        for (;;) {

            assert (StartOffset <= RecvBuffer -> Data.Length);

            Result = LdapDeterminePacketBoundary (
                            RecvBuffer,
                            StartOffset, 
                            &NextPacketOffset,
                            &NextReceiveSize);

            if (Result == ERROR_SUCCESS) {

                RecvBuildBuffer (&RecvBuffer -> Data.Data [StartOffset], NextPacketOffset - StartOffset);

                StartOffset = NextPacketOffset;

            } else {

                RecvBuffer -> Data.DeleteRangeAtPos (0, StartOffset);

                if (Result == ERROR_INVALID_DATA) {

                    RecvPump -> StartPassiveDataTransfer ();

                    DebugF (_T("LDAP: 0x%x starts non-interpreting data transfer.\n"), LdapConnection);

                    InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);

                    RecvBuffer = NULL;

                } 

                BytesToReceive = NextReceiveSize;

                break;

            } 

        }

    } else {
        LONG    PreviousRecvSize;
        LONG    PredictedRecvSize;
        HRESULT QueryResult;
        DWORD   BytesPreviouslyRequested = BytesToReceive;
        
        QueryResult = RecvSizePredictor.RetrieveOldSample (0, &PreviousRecvSize);

        if (ERROR_SUCCESS != RecvSizePredictor.AddSample ((LONG) RecvOverlapped.BytesTransferred)) {

            delete RecvBuffer;
            RecvBuffer = NULL;

            DebugErrorF (Status, _T("LDAP: 0x%x could not add sample to SamplePredictor.\n"), LdapConnection);

            Terminate();

            return;
        }

        if (BytesPreviouslyRequested == RecvOverlapped.BytesTransferred) {
            // Exact receive

            if (ERROR_SUCCESS != QueryResult) {

                BytesToReceive = (DWORD) (RecvOverlapped.BytesTransferred * 1.5);

            } else {

                PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

                if (PredictedRecvSize < (LONG) RecvOverlapped.BytesTransferred) {

                    if ((DWORD) PreviousRecvSize < RecvOverlapped.BytesTransferred) {

                        BytesToReceive =  RecvOverlapped.BytesTransferred * 1000 / (DWORD) PreviousRecvSize * 
                                          RecvOverlapped.BytesTransferred        / 1000;

                    } else {

                        BytesToReceive = (DWORD) PreviousRecvSize;
                    }

                } else {
                    
                    BytesToReceive = (DWORD) PredictedRecvSize;
                }

            }

        } else {
            // Inexact receive
        
            PredictedRecvSize = RecvSizePredictor.PredictNextSample ();

            BytesToReceive = (PredictedRecvSize < LDAP_BUFFER_RECEIVE_SIZE) ? 
                              LDAP_BUFFER_RECEIVE_SIZE :
                             (DWORD) PredictedRecvSize;

        }

        if (BytesToReceive > LDAP_BUFFER_MAX_RECV_SIZE)  {

            DebugF (_T("LDAP: 0x%x intended to receive %d bytes. Lowering the number to %d bytes.\n"),
                    LdapConnection, BytesToReceive, LDAP_BUFFER_MAX_RECV_SIZE);

            BytesToReceive = LDAP_BUFFER_MAX_RECV_SIZE;
        }

        InsertTailList (&RecvBufferQueue, &RecvBuffer -> ListEntry);
            
        RecvBuffer = NULL;
    }


    while (!IsListEmpty (&RecvBufferQueue)) {

        ListEntry = RemoveHeadList (&RecvBufferQueue);

        Buffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

        RecvPump -> OnRecvBuffer (Buffer);
    }

    RecvIssue ();
}

void LDAP_SOCKET::OnSendComplete (DWORD Status)
{
    assert (SendBuffer);

    delete SendBuffer;
    SendBuffer = NULL;

    // before notifying the owning context, transmit any buffers
    // that are queued for send.

    if (SendNextBuffer())
        return;

    SendPump -> OnSendDrain();
}

void LDAP_SOCKET::OnConnectCompletionLocked (void) {

    WSANETWORKEVENTS NetworkEvents;
    HRESULT Result;
    int     ConnectError;

    AssertLocked();

    if (State != STATE_CONNECT_PENDING) {
        DebugF (_T("LDAP: 0x%x connect request completed, but socket is no longer interested.\n"), LdapConnection);
        return;
    }

    if (WSAEnumNetworkEvents (Socket, ConnectEvent, &NetworkEvents)) {

        DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve network events.\n"), LdapConnection);

        Terminate();

        return;
    }

    if (!(NetworkEvents.lNetworkEvents & FD_CONNECT)) {

        DebugF (_T("LDAP: 0x%x connect event fired, but event mask does not indicate that connect completed -- internal error.\n"),
                LdapConnection);
        
        Terminate();

        return;
    }

    ConnectError = S_OK;

    if (NetworkEvents.iErrorCode [FD_CONNECT_BIT]) {
     
        ConnectError = NetworkEvents.iErrorCode [FD_CONNECT_BIT];
        DebugErrorF (ConnectError, _T("LDAP: 0x%x failed async connect request. "), LdapConnection);

        // If remote host refused to connect, we may attempt
        // a connection to an alternate port later, so we don't terminate 
        // the socket. All other error codes result in termination.
        if (WSAECONNRESET != ConnectError && WSAECONNREFUSED != ConnectError) {

            Terminate ();
            
            return;

        }
    }

    FreeConnectResources ();

    // If first attempt to connect fail, try to connect using an alternate port
    if ((WSAECONNREFUSED == ConnectError || WSAECONNRESET == ConnectError)
         && AttemptAnotherConnect) {

        AttemptAnotherConnect = FALSE;

        DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                    LdapConnection,
                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                    SOCKADDR_IN_PRINTF (&RealSourceAddress),
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

        NatCancelRedirect ( 
            NatHandle, 
            IPPROTO_TCP, 
            ActualDestinationAddress.sin_addr.s_addr,
            ActualDestinationAddress.sin_port,
            RealSourceAddress.sin_addr.s_addr, 
            RealSourceAddress.sin_port,
            ActualDestinationAddress.sin_addr.s_addr,
            ActualDestinationAddress.sin_port,
            RealSourceAddress.sin_addr.s_addr, 
            RealSourceAddress.sin_port); 

        IsNatRedirectActive = FALSE;

        closesocket (Socket);
        Socket = INVALID_SOCKET;
        
        State = STATE_NONE;

        Result = AttemptAlternateConnect ();

        if (S_OK != Result) {

            Terminate ();
        }

        return;
    }

    DebugF (_T("LDAP: 0x%x established connection to server %08X:%04X.\n"), LdapConnection, SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

    if (!BindIoCompletionCallback ((HANDLE)Socket, LDAP_SOCKET::IoCompletionCallback, 0)) {
        DebugLastErrorF (_T("LDAP: 0x%x failed to bind I/O completion callback.\n"), LdapConnection);

        Terminate();

        return;
    }
    
    // Asynchronous connect succeeded
    State = STATE_CONNECTED;

    LdapConnection -> OnStateChange (this, State);
}

void LDAP_SOCKET::FreeConnectResources (void) {

    // refrain from receiving notifications of further transport events
    WSAEventSelect (Socket, ConnectEvent, 0);

    assert (ConnectWaitHandle);
    UnregisterWaitEx (ConnectWaitHandle, NULL);
    ConnectWaitHandle = NULL;

    assert (ConnectEvent);
    CloseHandle(ConnectEvent);
    ConnectEvent = NULL;
}


// assumes that connect resources for previous
// connect attempt were freed
HRESULT LDAP_SOCKET::AttemptAlternateConnect (void) {

    HRESULT Result;

    // switch connection port to the other alternative

    ActualDestinationAddress.sin_port = 
        (ActualDestinationAddress.sin_port == htons (LDAP_STANDARD_PORT)) ?
        htons (LDAP_ALTERNATE_PORT) :
        htons (LDAP_STANDARD_PORT);

    DebugF (_T("LDAP: 0x%x will try to connect on an alternate address %08X:%04X.\n"),
                LdapConnection,
                SOCKADDR_IN_PRINTF (&ActualDestinationAddress));

    // attempting to connect on an alternate port
    Result = IssueConnect (&ActualDestinationAddress);
    
    if (S_OK != Result) {

        DebugF (_T("LDAP: 0x%x failed to issue connect on an alternate address %08X:%04X.\n"),
                    LdapConnection,
                    SOCKADDR_IN_PRINTF (&ActualDestinationAddress));
    }

    return Result;
}

void LDAP_SOCKET::Terminate (void)
{
    switch (State) {

    case    STATE_TERMINATED:
        // nothing to do
        return;

    case    STATE_NONE:
        // a different kind of nothing to do
        break;

    default:
        // in all other states, the socket handle must be set
        assert (Socket != INVALID_SOCKET);

        State = STATE_TERMINATED;

        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);
            Socket = INVALID_SOCKET;

        }

        if (IsNatRedirectActive) {
                DebugF (_T ("LDAP: 0x%x cancels trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                            LdapConnection,
                            SOCKADDR_IN_PRINTF (&RealSourceAddress),
                            SOCKADDR_IN_PRINTF (&ActualDestinationAddress),
                            SOCKADDR_IN_PRINTF (&RealSourceAddress),
                            SOCKADDR_IN_PRINTF (&ActualDestinationAddress));
             NatCancelRedirect ( 
                NatHandle, 
                IPPROTO_TCP, 
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port,
                ActualDestinationAddress.sin_addr.s_addr,
                ActualDestinationAddress.sin_port,
                RealSourceAddress.sin_addr.s_addr, 
                RealSourceAddress.sin_port); 

            IsNatRedirectActive = FALSE;
        }

        if (ConnectWaitHandle) {

            if (UnregisterWaitEx (ConnectWaitHandle, NULL)) {

                // Take care of the case when the connection was terminated AFTER
                // async connect has been issued, but BEFORE the connect was completed. 
                // 
                // This should not normally happen.
                LdapConnection -> Release ();
                
            }

            ConnectWaitHandle = NULL;
        }

        if (ConnectEvent) {
            CloseHandle (ConnectEvent);
            ConnectEvent = NULL;
        }

        SendPump -> Terminate ();
        RecvPump -> Terminate ();

        break;
    }
    

    LdapConnection -> OnStateChange (this, State);
}

HRESULT LDAP_SOCKET::RecvIssue (void)
{
    WSABUF    BufferArray    [1];
    DWORD    Status;
    DWORD    BytesRequested;

    if (RecvOverlapped.IsPending) {
        DebugF (_T("LDAP: 0x%x receive is already pending.\n"), LdapConnection);
        return S_OK;
    }

    if (!RecvPump -> CanIssueRecv()) {
        // we gate the rate at which we receive data from the network on the
        // rate at which the other network connection consumes it.
        // this is how we preserve flow control.

        return S_OK;
    }

    if (!RecvBuffer) {

        RecvBuffer = new LDAP_BUFFER;

        if (!RecvBuffer) {

            DebugF (_T("LDAP: 0x%x RecvIssue allocation failure.\n"), LdapConnection);

            Terminate();

            return E_OUTOFMEMORY;
        }
    }

    BytesRequested = RecvBuffer -> Data.Length + BytesToReceive;

    if (!RecvBuffer -> Data.Grow (BytesRequested)) {

        DebugF (_T("LDAP: 0x%x failed to expand receive buffer to %d bytes.\n"), 
                LdapConnection, BytesRequested);

        Terminate();

        return E_OUTOFMEMORY;
    }

    BufferArray [0].len = BytesToReceive;
    BufferArray [0].buf = reinterpret_cast <char *>(RecvBuffer -> Data.Data) + RecvBuffer -> Data.Length;


    ZeroMemory (&RecvOverlapped.Overlapped, sizeof (OVERLAPPED));

    RecvFlags = 0;

    LdapConnection -> AddRef ();

    if (WSARecv (Socket, BufferArray, 1,
        &RecvOverlapped.BytesTransferred, &RecvFlags,
        &RecvOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {
            // a true error, probably a transport failure
            
            LdapConnection -> Release ();

            DebugErrorF (Status, _T("LDAP: 0x%x failed to issue receive.\n"), LdapConnection);
            return HRESULT_FROM_WIN32 (Status);
        }
    }

    RecvOverlapped.IsPending = TRUE;

    return S_OK;
}

void LDAP_SOCKET::SendQueueBuffer (
    IN    LDAP_BUFFER *    Buffer)
{
    AssertLocked();

    assert (!IsInList (&SendBufferQueue, &Buffer -> ListEntry));
    InsertTailList (&SendBufferQueue, &Buffer -> ListEntry);

    SendNextBuffer();
}

BOOL LDAP_SOCKET::SendNextBuffer (void)
{
    WSABUF            BufferArray [1];
    LIST_ENTRY *    ListEntry;
    DWORD            Status;

    if (SendOverlapped.IsPending) {
        assert (SendBuffer);

//        Debug (_T("LDAP_SOCKET::SendNextMessage: already sending a message, must wait.\n"));
        return FALSE;
    }

    assert (!SendBuffer);

    // remove the next buffer to be sent from the queue

    if (IsListEmpty (&SendBufferQueue))
        return FALSE;

    ListEntry = RemoveHeadList (&SendBufferQueue);
    SendBuffer = CONTAINING_RECORD (ListEntry, LDAP_BUFFER, ListEntry);

    BufferArray [0].buf = reinterpret_cast<char *> (SendBuffer -> Data.Data);
    BufferArray [0].len = SendBuffer -> Data.Length;

    ZeroMemory (&SendOverlapped.Overlapped, sizeof (OVERLAPPED));

    LdapConnection -> AddRef ();

    if (WSASend (Socket, BufferArray, 1,
        &SendOverlapped.BytesTransferred, 0,
        &SendOverlapped.Overlapped, NULL)) {

        Status = WSAGetLastError();

        if (Status != WSA_IO_PENDING) {

            LdapConnection -> Release ();

            DebugError (Status, _T("LDAP: Failed to issue send.\n"));

            delete SendBuffer;
            SendBuffer = NULL;

            Terminate();

            // we return TRUE, because we did dequeue a buffer,
            // even if that buffer could not be transmitted.
            return TRUE;
        }
    }

    SendOverlapped.IsPending = TRUE;

    return TRUE;
}

BOOL LDAP_SOCKET::GetLocalAddress (
    OUT    SOCKADDR_IN *    ReturnAddress)
{
    INT            AddressLength;

    AssertLocked();

    if (State == STATE_CONNECTED) {
        AddressLength = sizeof (SOCKADDR_IN);

        if (getsockname (Socket, (SOCKADDR *) ReturnAddress, &AddressLength)) {
            DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve socket address.\n"), LdapConnection);
            ZeroMemory (&ReturnAddress, sizeof (SOCKADDR_IN));

            return FALSE;
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}

BOOL LDAP_SOCKET::GetRemoteAddress (
    OUT    SOCKADDR_IN *    ReturnAddress)
{
    INT            AddressLength;

    AssertLocked();

    if (State == STATE_CONNECTED) {
        AddressLength = sizeof (SOCKADDR_IN);

        if (getpeername (Socket, (SOCKADDR *) ReturnAddress, &AddressLength)) {
            DebugLastErrorF (_T("LDAP: 0x%x failed to retrieve peer address.\n"), LdapConnection);
            ZeroMemory (&ReturnAddress, sizeof (SOCKADDR_IN));

            return FALSE;
        }

        return TRUE;
    }
    else {
        return FALSE;
    }
}

// LDAP_CONNECTION ---------------------------------------------------

LDAP_CONNECTION::LDAP_CONNECTION (NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation)
: LIFETIME_CONTROLLER (&LdapSyncCounter) ,
    ClientSocket (this, &PumpClientToServer, &PumpServerToClient),
    ServerSocket   (this, &PumpServerToClient, &PumpClientToServer),
    PumpClientToServer    (this, &ClientSocket, &ServerSocket),
    PumpServerToClient    (this, &ServerSocket, &ClientSocket)
{
    SourceInterfaceAddress      = 0;
    DestinationInterfaceAddress = 0;

    State = STATE_NONE;

    DestinationAddress.sin_family      = AF_INET;
    DestinationAddress.sin_addr.s_addr = RedirectInformation -> DestinationAddress;
    DestinationAddress.sin_port        = RedirectInformation -> DestinationPort;

    SourceAddress.sin_family           = AF_INET;
    SourceAddress.sin_addr.s_addr      = RedirectInformation -> SourceAddress;
    SourceAddress.sin_port             = RedirectInformation -> SourcePort;

    DebugF (_T("LDAP: 0x%x created.\n"), this);
}

HRESULT LDAP_CONNECTION::Initialize (
    IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
    )
{
    
    HRESULT Result;

    Lock ();

    Result = InitializeLocked (RedirectInformation);

    Unlock ();

    return Result;
}

HRESULT LDAP_CONNECTION::InitializeLocked (
    IN NAT_KEY_SESSION_MAPPING_EX_INFORMATION * RedirectInformation
    )
{
    ULONG Error;

    DebugF (_T ("LDAP: 0x%x connection accepted on adapter %d.\n"), this, RedirectInformation -> AdapterIndex);

    SourceInterfaceAddress = H323MapAdapterToAddress (RedirectInformation -> AdapterIndex);

    if (INADDR_NONE == SourceInterfaceAddress) {

        DebugF (_T ("LDAP: 0x%x failed to get source interface address (via H323MapAdapterToAddress).\n"), this);

        return E_FAIL;

    }

    Error = GetBestInterfaceAddress (ntohl (DestinationAddress.sin_addr.s_addr), &DestinationInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        DebugErrorF (Error, _T ("LDAP: 0x%x failed to get destination interface address.\n"), this);

        return HRESULT_FROM_WIN32 (Error);

    }

    DebugF (_T("LDAP: 0x%x arrived on interface %08X.\n"), this, SourceInterfaceAddress);

    return S_OK;
}

LDAP_CONNECTION::~LDAP_CONNECTION (void)
{    
    DebugF (_T("LDAP: 0x%x destroyed.\n"), this);
}

void LDAP_CONNECTION::StartIo (void)
{
    PumpClientToServer.Start ();
    PumpServerToClient.Start ();
}

HRESULT LDAP_CONNECTION::AcceptSocket (
    IN    SOCKET           Socket,
    IN    SOCKADDR_IN *    LocalAddress,
    IN    SOCKADDR_IN *    RemoteAddress,
    IN    SOCKADDR_IN *    ArgActualDestinationAddress)
{
    HRESULT        Result;

    Lock();

    if (State == STATE_NONE) {

        Result = ClientSocket.AcceptSocket (Socket);

        if (Result == S_OK) {

            Result = ServerSocket.IssueConnect (ArgActualDestinationAddress);

            if (Result != S_OK) {

                DebugErrorF (Result, _T("LDAP: 0x%x failed to issue async connect to %08X:%04X.\n"),
                    this,
                    SOCKADDR_IN_PRINTF (ArgActualDestinationAddress));

                Terminate ();
            }
        }
        else {

            DebugErrorF (Result, _T("LDAP: 0x%x could not successfully complete accept.\n"), this);

            Terminate ();
        }            
    }
    else {

        DebugF (_T("LDAP: 0x%x is not in a valid state for accept (state != STATE_NONE).\n"), this);

        Result = E_UNEXPECTED;
    }

    Unlock();
        
    return Result;
}
    
HRESULT LDAP_CONNECTION::CreateOperation (
    IN    LDAP_OPERATION_TYPE        Type,
    IN    LDAP_MESSAGE_ID            MessageID,
    IN    ANSI_STRING *            DirectoryPath,
    IN    ANSI_STRING *            Alias,
    IN    IN_ADDR                    ClientAddress,
    IN    SOCKADDR_IN *            ServerAddress,
    IN    DWORD                    EntryTimeToLive  // in seconds
    )
{
    LDAP_OPERATION *    Operation;
    DWORD                Index;
    HRESULT                Result;

    if (FindOperationIndexByMessageID (MessageID, &Index)) {
        DebugF (_T("LDAP: 0x%x - an operation with message ID (%u) is already pending.\n"),
            this, 
            MessageID);
        return E_FAIL;
    }

    Operation = OperationArray.AllocAtPos (Index);
    if (!Operation) {
        DebugF (_T("LDAP: 0x%x - CreateOperation allocation failure #1.\n"), this);
        return E_OUTOFMEMORY;
    }

    Operation -> Type = Type;
    Operation -> MessageID = MessageID;
    Operation -> ClientAddress = ClientAddress;
    Operation -> ServerAddress = *ServerAddress;
    Operation -> EntryTimeToLive = EntryTimeToLive;

    CopyAnsiString (DirectoryPath, &Operation -> DirectoryPath);
    CopyAnsiString (Alias, &Operation -> Alias);

    if ((Operation -> DirectoryPath.Buffer
        && Operation -> Alias.Buffer)) {
        // all is well

        Result = S_OK;
    }
    else {
        DebugF (_T("LDAP: 0x%x - CreateOperation allocation failure #2.\n"), this);

        FreeAnsiString (&Operation -> DirectoryPath);
        FreeAnsiString (&Operation -> Alias);

        Result = E_OUTOFMEMORY;
    }

    return Result;
}


// Processing of LDAP messages ---------------------------------------

BOOL LDAP_CONNECTION::ProcessAddRequest (
    IN    LDAPMessage *    Message)
{
    AddRequest *        Request;
    ANSI_STRING            DirectoryPath;
    LDAP_PATH_ELEMENTS    PathElements;
    ANSI_STRING            AttributeTag;
    IN_ADDR                OldClientAddress;        // the address the client submitted in AddRequest
    IN_ADDR                NewClientAddress;        // the address we are replacing it with
    LDAP_OPERATION *    Operation;
    DWORD                OperationInsertionIndex;
    ASN1octetstring_t    IPAddressOldValue;
    SOCKADDR_IN            LocalToServerAddress;
    SOCKADDR_IN            LocalToClientAddress;
    SOCKADDR_IN            ServerAddress;
    INT                    AddressLength;
    BOOL                NeedObjectClass;
    ANSI_STRING            ClientAlias;

    AddRequest_attrs *                Iter;
    AddRequest_attrs_Seq *            Attribute;
    AddRequest_attrs_Seq_values *    ValueSequence;
    AttributeValue *                Attribute_Alias;
    AttributeValue *                Attribute_IPAddress;
    AttributeValue *                Attribute_ObjectClass;
    AttributeValue *                Attribute_Comment;
    AttributeValue                    Attribute_Comment_Old;
    ANSI_STRING            String;
                
    CHAR    IPAddressText    [0x20];
    USHORT    IPAddressTextLength;

    Request = &Message -> protocolOp.u.addRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            Message -> messageID);

        return FALSE;
    }

    // NetMeeting supplies the objectClass in the directory path.
    // TAPI supplies the objectClass in the attribute set.
    // Don't you just love standards?

    InitializeAnsiString (&DirectoryPath, &Request -> entry);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    // make sure that the alias is present
    if (!PathElements.CN.Buffer) { 
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no alias present).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 
        return FALSE;
    }

    ClientAlias = PathElements.CN;

    if (PathElements.ObjectClass.Buffer) {
        if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {
            NeedObjectClass = FALSE;
        }
        else {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no object class (1)).\n"),
                        this,
                        ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }
    }
    else {

        NeedObjectClass = TRUE;
    }

    // first, determine if the attributes of this object
    // match the set of objects we wish to modify.

    // scan through the set of attributes
    // find interesting data

    Attribute_IPAddress   = NULL;
    Attribute_ObjectClass = NULL;
    Attribute_Comment     = NULL;

    for (Iter = Request -> attrs; Iter; Iter = Iter -> next) {
        Attribute = &Iter -> value;

        InitializeAnsiString (&AttributeTag, &Attribute -> type);

        if (Attribute -> values) {
            // we are only concerned with single-value attributes
            // if it's one of the attributes that we want,
            // then store in local variable

            if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE))
                Attribute_IPAddress = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_ObjectClass, TRUE))
                Attribute_ObjectClass = &Attribute -> values -> value;
            else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_comment, TRUE))
                Attribute_Comment = &Attribute -> values -> value;
            // else, we aren't interested in the attribute
        }
        else {
            // else, the attribute has no values
        }
    }

    // make sure that we found an objectClass value.
    // make sure that the objectClass = RTPerson

    if (NeedObjectClass) {

        if (!Attribute_ObjectClass) {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (no object class (2)).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }

        InitializeAnsiString (&String, Attribute_ObjectClass);
        if (!RtlEqualStringConst (&String, &LdapText_RTPerson, TRUE)) {
            DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (not for RTPerson).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;
        }
    }

    // if a comment field is present, and the comment is "Generated by TAPI3"
    // modify it so that it says "Generated by TAPI3, modified by ICS"

    if (Attribute_Comment) {
        Attribute_Comment_Old = *Attribute_Comment;

        InitializeAnsiString (&String, Attribute_Comment);
        if (RtlEqualStringConst (&String, &LdapText_GeneratedByTAPI, TRUE)) {
            Attribute_Comment -> value = (PUCHAR) LdapText_ModifiedByICS.Buffer;
            Attribute_Comment -> length = LdapText_ModifiedByICS.Length * sizeof (CHAR);
        }
    }

    // make sure ip address attribute is present
    // parse the address, build replacement address

    if (!Attribute_IPAddress) {
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified AddRequest (IP address not present).\n"),
                this,
                ntohl (SourceAddress.sin_addr.s_addr)); 
        return FALSE;
    }

    if (LdapTranslationTable.ReachedMaximumSize ()) {
        LDAPMessage AddRequestFailed;

        DebugF(_T("LDAP: Size of LDAP Address Translation Table exceeded limit. Sending back AddResponse with an error code.\n"));

        AddRequestFailed.messageID = Message -> messageID;
        AddRequestFailed.protocolOp.choice = addResponse_choice;

        AddRequestFailed.protocolOp.u.addResponse.resultCode = sizeLimitExceeded;
        AddRequestFailed.protocolOp.u.addResponse.matchedDN.length = 0;
        AddRequestFailed.protocolOp.u.addResponse.matchedDN.value = NULL;
        AddRequestFailed.protocolOp.u.addResponse.errorMessage.length = LdapText_TableSizeExceededMessage.Length * sizeof (CHAR);
        AddRequestFailed.protocolOp.u.addResponse.errorMessage.value = (PUCHAR) LdapText_TableSizeExceededMessage.Buffer;

        PumpServerToClient.EncodeSendMessage (&AddRequestFailed);

    } else {

        if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
            return FALSE;
        }

        IPAddressTextLength = min (0x1F, (USHORT) Attribute_IPAddress -> length);
        IPAddressText [IPAddressTextLength] = 0;
        memcpy (IPAddressText, Attribute_IPAddress -> value, IPAddressTextLength * sizeof (CHAR));

        if (RtlCharToInteger (IPAddressText, 10, &OldClientAddress.s_addr) != STATUS_SUCCESS) {
            DebugF (_T("LDAP: 0x%x - AddRequest: bogus IP address value (%.*S).\n"),
                this,
                Attribute_IPAddress -> length,
                Attribute_IPAddress -> value);

            return FALSE;
        }

        // If ILS is running locally, we will not modify AddRequest sent by any private client.
        // Instead, we will later modify SearchResponse PDU if it turned out that
        // the name of the client being searched for is stored in LDAP Address Translation Table, and
        // the matching SearchRequest PDU came from a machine external to the client's local subnet.
        // The address we will put into the modified SearchResponse PDU will be that of the
        // interface on which SearchRequest was received (public interface, or another local interface)
        // If SearchRequest came from a private client located on the same subnet as the client we
        // are registering here, we won't modify it as those two clients can communicate directly 
        // and don't require any proxying by the NAT machine.
        
        if (!::NhIsLocalAddress (ServerAddress.sin_addr.s_addr)) {

            // get the address that we want to substitute (our external interface address)

            if (!ServerSocket.GetLocalAddress (&LocalToServerAddress)) {

                DebugF (_T("LDAP: 0x%x failed to get local address to server -- internal error.\n"), this);
                return FALSE;

            }

            // Convoluted code alert!
            // NetMeeting stores its IP address as an attribute on an LDAP object on an ILS server.
            // Makes sense. The attribute is encoded as a textual string, so they had to convert
            // the IP address to text.  Any sane person would have chosen the standard dotted-quad
            // format, but they chose to interpret the IP address as a 32-bit unsigned integer,
            // which is fair enough, and then to convert that integer to a single decimal text string.

            // That's all great, that's just fine.  But NetMeeting stores the attribute byte-swapped
            // -- they used ntohl one too many times.  Grrrrrrrr....  The value should have been stored
            // without swapping the bytes, since the interpretation was "unsigned integer" and not "octet sequence".

            OldClientAddress.s_addr = htonl (ByteSwap (OldClientAddress.s_addr));

            NewClientAddress = LocalToServerAddress.sin_addr;
                                            
            // believe me, this IS CORRECT.
            // see the long note above for more info. -- arlied

            if (RtlIntegerToChar (ByteSwap (ntohl (NewClientAddress.s_addr)),
                10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
                DebugF (_T("LDAP: 0x%x failed to convert IP address to text -- internal error.\n"), this);

                return FALSE;
            }

            DebugF (_T("LDAP: 0x%x will register %08X on the ILS.\n"), this, ntohl (NewClientAddress.s_addr));

        } else {

            DebugF (_T("LDAP: 0x%x will register %08X on the ILS.\n"), this, ntohl (OldClientAddress.s_addr));

        }

        // allocate and build an LDAP_OPERATION structure.

        DebugF (_T("LDAP: 0x%x inserts valid AddRequest into operation table.\n"), this);

        CreateOperation (
            LDAP_OPERATION_ADD,
            Message -> messageID,
            &DirectoryPath,
            &ClientAlias,
            OldClientAddress,
            &ServerAddress,
            LDAP_TRANSLATION_TABLE_ENTRY_INITIAL_TIME_TO_LIVE);

        // the entry is now in the operation array
        // later, when the server sends the AddResponse,
        // we'll match the response with the request,
        // and modify the LDAP_TRANSLATION_TABLE

        // now, in-place, we modify the PDU structure,
        // reencode it, send it, undo the modification
        // (so ASN1Free_AddRequest doesn't act up)

        assert (Attribute_IPAddress);
        IPAddressOldValue = *Attribute_IPAddress;

        Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
        Attribute_IPAddress -> length = strlen (IPAddressText);

        PumpClientToServer.EncodeSendMessage (Message);

        // switch back so we don't a/v when decoder frees pdu
        *Attribute_IPAddress = IPAddressOldValue;
        if (Attribute_Comment)
            *Attribute_Comment = Attribute_Comment_Old;
    }

    return TRUE;
}

BOOL LDAP_CONNECTION::ProcessModifyRequest (
    IN    LDAP_MESSAGE_ID    MessageID,
    IN    ModifyRequest *    Request)
{
    ModifyRequest_modifications *        ModificationIterator;
    ModifyRequest_modifications_Seq *    Modification;
    PModifyRequest_modifications_Seq_modification_values ModificationValue;

    LPCTSTR                  Op;
    ANSI_STRING              ModificationType;
    ANSI_STRING              TimeToLive;
    ANSI_STRING              DirectoryPath;
    ANSI_STRING              ClientAlias;

    DWORD                    OperationInsertionIndex;
    LDAP_PATH_ELEMENTS       PathElements;
    BOOL                     IsValidRefreshRequest = FALSE;
    SOCKADDR_IN              ServerAddress;

    DWORD                    EntryTimeToLive = 0;
    CHAR                     EntryTimeToLiveText [11];
    USHORT                   EntryTimeToLiveLength;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (MessageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - ModifyRequest: client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            MessageID);

        return FALSE;
    }

    // Cover the case when ModifyRequest does not supply baseObject 
    if (Request -> object.value == NULL || Request -> object.length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (no base object).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    InitializeAnsiString (&DirectoryPath, &Request -> object);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    ClientAlias = PathElements.CN;

    for (ModificationIterator = Request -> modifications; ModificationIterator; ModificationIterator = ModificationIterator -> next) {

        Modification = &ModificationIterator -> value;
        
        InitializeAnsiString (&ModificationType, &Modification -> modification.type);

        if (RtlEqualStringConst (&ModificationType, &LdapText_Modify_EntryTTL, TRUE) && Modification -> operation == replace) {
            IsValidRefreshRequest = TRUE;

            assert (Modification -> modification.values);

            ModificationValue = Modification -> modification.values;

            InitializeAnsiString (&TimeToLive, &ModificationValue -> value);

            EntryTimeToLiveLength = min (10, (USHORT) ModificationValue -> value.length);
            EntryTimeToLiveText [EntryTimeToLiveLength] = 0;
            memcpy (EntryTimeToLiveText, ModificationValue -> value.value, EntryTimeToLiveLength * sizeof (CHAR));

            if (RtlCharToInteger (&EntryTimeToLiveText [0], 10, &EntryTimeToLive) != STATUS_SUCCESS) {

                DebugF (_T("LDAP: 0x%x - ModifyRequest: bogus Time-To-Live value (%.*S).\n"),
                    this,
                    EntryTimeToLiveLength,
                    EntryTimeToLiveText);

                return FALSE;

            }

            DebugF (_T("LDAP: 0x%x %08X requested lifetime increase of %d seconds for (%.*S).\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr), 
                 EntryTimeToLive, // in seconds 
                 ANSI_STRING_PRINTF (&ClientAlias));

        }
    }

    // If type of the modification was 'replace', and the attribute to be modified was 'EntryTTL'
    // then we have just received a valid refresh request from PhoneDialer
    //
    if (!IsValidRefreshRequest) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (not a refresh request).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (!ClientAlias.Buffer || ClientAlias.Length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified ModifyRequest (no client alias in refresh request).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
        DebugF (_T("LDAP: 0x%x ModifyRequest: failed to get server address -- internal error.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    DebugF (_T("LDAP: 0x%x inserts valid ModifyRequest into operation table.\n"), this);

    // Allocate and build an LDAP_OPERATION structure.
    CreateOperation (
        LDAP_OPERATION_MODIFY,
        MessageID,
        &DirectoryPath,
        &ClientAlias,
        SourceAddress.sin_addr,
        &ServerAddress,
        EntryTimeToLive
        );

    // The entry is now in the operation array
    // later, when the server sends the ModifyResponse,
    // we'll check whether it was successful.
    // If so, we will find and refresh matching
    // entry in the LDAP Address Translation Table
    
    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessDeleteRequest (
    IN    LDAP_MESSAGE_ID    MessageID,
    IN    DelRequest *    Request)
{
    ANSI_STRING  DirectoryPath;
    HRESULT Result = S_FALSE;
    LDAP_PATH_ELEMENTS    PathElements;

    assert (Request);

    DirectoryPath.Buffer = (PCHAR) Request -> value;
    DirectoryPath.Length = (USHORT) Request -> length;
    DirectoryPath.MaximumLength = (USHORT) Request -> length;

    ParseDirectoryPath (&DirectoryPath, &PathElements);

    if (RtlEqualStringConst (&PathElements.ObjectClass, &LdapText_RTPerson, TRUE)) {

        Result = LdapTranslationTable.RemoveEntryByAliasServer (&PathElements.CN, &DestinationAddress);

        if (Result == S_OK) {

            DebugF (_T("LDAP: 0x%x removed entry (%.*S) from LDAP table.\n"),
                this,
                ANSI_STRING_PRINTF (&DirectoryPath));

        } else {
            
            DebugF (_T("LDAP: 0x%x attempted to remove entry (%.*S) from LDAP table, but it was not there.\n"),
                this,
                ANSI_STRING_PRINTF (&DirectoryPath));
        
        }

    } else {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified DeleteRequest.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 
    }

    return FALSE;
}

BOOL LDAP_CONNECTION::ProcessSearchRequest (
    IN    LDAPMessage *    Message)
{
    SearchRequest            * Request;

    ANSI_STRING                DirectoryPath;
    ANSI_STRING                AttributeTag;
    ANSI_STRING                AttributeType;
    ANSI_STRING                AttributeValue;
    ANSI_STRING                RequestedForAlias;

    LDAP_PATH_ELEMENTS         PathElements;
    LDAP_OPERATION           * Operation;

    Filter                   * SearchFilter;
    Filter_and               * FilterIterator;
    SearchRequest_attributes * Iterator;
    AttributeValueAssertion  * EqualityAssertion;
                
    BOOL IsRequestForIPAddress     = FALSE;
    BOOL IsRequestForRTPerson      = FALSE;
    BOOL IsRequestForSttl          = FALSE;
    BOOL IsQualifiedRequest        = FALSE;
    BOOL IsRequestForSpecificAlias = FALSE;

    DWORD                      EntryTimeToLive = 0;
    CHAR                       EntryTimeToLiveText [11];
    USHORT                     EntryTimeToLiveLength;
                
    DWORD OperationInsertionIndex;

    Request = &Message -> protocolOp.u.searchRequest;

    // check to see if an existing operation with the same message id is pending.
    // if so, the client is in violation of the LDAP spec.
    // we'll just ignore the packet in this case.
    // at the same time, compute the insertion position for the new operation (for use later).

    if (FindOperationIndexByMessageID (Message -> messageID, &OperationInsertionIndex)) {
        DebugF (_T("LDAP: 0x%x - SearchRequest - client has issued two requests with the same message ID (%u), LDAP protocol violation, packet will not be processed.\n"),
            this,
            Message -> messageID);

        return FALSE;
    }

    // Cover the case when SearchRequest does not supply baseObject 
    if (Request -> baseObject.value == NULL || Request -> baseObject.length == 0) {

        DebugF (_T("LDAP: 0x%x client %08X issued unqualified SearchRequest (no base object).\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

            return FALSE;

    }

    InitializeAnsiString (&DirectoryPath, &Request -> baseObject);
    ParseDirectoryPath (&DirectoryPath, &PathElements);

    // Determine whether we are interested in this request. 
    // 
    // This is what we are interested in from SearchRequests originated by NetMeeting:
    //    1. It searches for IP address (query to the server), or
    //    2. It searches for Sttl attribute, AND for RTPerson attribute (refresh request)
    //

    for (Iterator = Request -> attributes; Iterator; Iterator = Iterator -> next) {
       
        InitializeAnsiString (&AttributeValue, &Iterator -> value);

        if (RtlEqualStringConst (&AttributeValue, &LdapText_Attribute_sipaddress, TRUE)
            || RtlEqualStringConst (&AttributeValue, &LdapText_Attribute_ipAddress, TRUE)) {

            IsRequestForIPAddress = TRUE;

        }

        // else not interesting attribute
    }

    // Look closer at the composition of the filter. 
    //
    // NetMeeting specifies the following filter in SearchRequest:
    //
    // FilterType = AND
    //     FilterType = EqualityMatch
    //         AttributeType  = objectClass
    //         AttributeValue = RTPerson
    //     FilterType = EqualityMatch
    //         AttributeType  = cn
    //         AttributeValue = <...alias, for which IP address is searched, or refresh is requested...>
    //
    // NetMeeting may also add the following 'EqualityMatch' clause to the filter
    // if a Time-To-Live increase is requested
    //
    //     FilterType = EqualityMatch
    //         AttributeType  = sttl
    //         AttributeValue = <...increase in Time-To-Live, in minutes...>
    //
    // Phone Dialer DOES NOT query directory server to determine IP address of the called party.
    // It does the determination by some other means (DNS lookup, most certainly).

    SearchFilter = &Request -> filter;

    switch (SearchFilter -> choice) {
    case and_choice:
        for (FilterIterator = SearchFilter -> u.and; FilterIterator; FilterIterator = FilterIterator -> next) {
            switch (FilterIterator -> value.choice) {
            case equalityMatch_choice:

                EqualityAssertion = &FilterIterator -> value.u.equalityMatch;

                InitializeAnsiString (&AttributeType,  &EqualityAssertion -> attributeType);
                InitializeAnsiString (&AttributeValue, &EqualityAssertion -> attributeValue);

                if (RtlEqualStringConst (&AttributeType, &LdapText_Attribute_sttl, TRUE)) {

                    IsRequestForSttl = TRUE;

                    EntryTimeToLiveLength = min (10, (USHORT) AttributeValue.Length);
                    EntryTimeToLiveText [EntryTimeToLiveLength] = 0;
                    memcpy (EntryTimeToLiveText, AttributeValue.Buffer, EntryTimeToLiveLength * sizeof (CHAR));

                    if (RtlCharToInteger (&EntryTimeToLiveText [0], 10, &EntryTimeToLive) != STATUS_SUCCESS) {

                        DebugF (_T("LDAP: 0x%x - SearchRequest: bogus Time-To-Live value (%.*S).\n"),
                            this,
                            EntryTimeToLiveLength,
                            EntryTimeToLiveText);

                        return FALSE;

                    }

                }

                if (RtlEqualStringConst (&AttributeType, &LdapText_ObjectClass, TRUE)
                    || RtlEqualStringConst (&AttributeValue, &LdapText_RTPerson, TRUE)) {

                    IsRequestForRTPerson = TRUE;
                }

                if (RtlEqualStringConst (&AttributeType, &LdapText_CN, TRUE)) {

                    RequestedForAlias = AttributeValue;

                    IsRequestForSpecificAlias = TRUE;

                }
                
                break;

            default:

                break;
            }
        }
                
        break;

    default:

        break;
    }

    IsQualifiedRequest = IsRequestForIPAddress || (IsRequestForRTPerson && IsRequestForSttl);
        
    if (!IsQualifiedRequest) {
        DebugF (_T("LDAP: 0x%x client %08X issued unqualified SearchRequest.\n"),
                    this,
                    ntohl (SourceAddress.sin_addr.s_addr)); 

        return FALSE;
    }

    if (IsRequestForSttl) {

        DebugF (_T("LDAP: 0x%x %08X requested lifetime increase of %d seconds for (%.*S).\n"),
             this, 
             ntohl (SourceAddress.sin_addr.s_addr), 
             EntryTimeToLive * 60, // in seconds
             ANSI_STRING_PRINTF (&RequestedForAlias));
    }

    if (IsRequestForIPAddress) {

        if (IsRequestForSpecificAlias) {

            DebugF (_T("LDAP: 0x%x %08X requested IP address for (%.*S).\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr), 
                 ANSI_STRING_PRINTF (&RequestedForAlias));

        } else {

            DebugF (_T("LDAP: 0x%x %08X issued unspecified request for IP address.\n"),
                 this, 
                 ntohl (SourceAddress.sin_addr.s_addr) );
        }
    }

    DebugF (_T("LDAP: 0x%x inserts valid SearchRequest into operation table.\n"), this);

    // allocate and build an LDAP_OPERATION structure.
    CreateOperation (
        LDAP_OPERATION_SEARCH,
        Message -> messageID,
        &DirectoryPath,
        &PathElements.CN,
        SourceAddress.sin_addr,
        &DestinationAddress,
        EntryTimeToLive * 60); // in seconds

    // the entry is now in the operation array
    // later, when the server sends the SearchResponse,
    // we'll match the response with the request,
    // and modify the IP address if an entry with
    // the matching alias happens to be in the 
    // LDAP_TRANSLATION_TABLE. This would mean that 
    // the client running on the proxy machine itself
    // wishes to connect to a private subnet client.

    PumpClientToServer.EncodeSendMessage (Message);

    return TRUE;
}

// server to client messages

void LDAP_CONNECTION::ProcessAddResponse (
    IN    LDAPMessage *    Message)
{
    AddResponse *        Response;
    LDAP_OPERATION *    Operation;

    Response = &Message -> protocolOp.u.addResponse;

    AssertLocked();

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {

        return;
    }

    if (Operation -> Type == LDAP_OPERATION_ADD) {

        if (Response -> resultCode == success) {
            DebugF (_T("LDAP: 0x%x server has approved AddRequest for (%.*S).\n"), 
                this, ANSI_STRING_PRINTF (&Operation -> Alias));

            assert (Operation -> Alias.Buffer);
            assert (Operation -> DirectoryPath.Buffer);

            InterfaceArray.StartQ931ReceiveRedirects ();

            LdapTranslationTable.InsertEntry (
                &Operation -> Alias,
                &Operation -> DirectoryPath,
                Operation -> ClientAddress,
                &Operation -> ServerAddress,
                 Operation -> EntryTimeToLive);

        }
        else {
            DebugF (_T("LDAP: 0x%x Server has rejected AddRequest, result code (%u).\n"),
                this,
                Response -> resultCode);
        }
    }
    else {
        DebugF (_T("LDAP: 0x%x received AddResponse with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
            this,
            Message -> messageID,
            Operation -> Type);
    }

    Operation -> FreeContents ();
                
    OperationArray.DeleteEntry (Operation);
}

void LDAP_CONNECTION::ProcessModifyResponse (
    IN    LDAP_MESSAGE_ID        MessageID,
    IN    ModifyResponse *    Response)
{
    LDAP_OPERATION *    Operation;

    AssertLocked();

    if (!FindOperationByMessageID (MessageID, &Operation)) {

        return;
    }

    if (Operation -> Type == LDAP_OPERATION_MODIFY) {

        if (Response -> resultCode == success) {
            assert (Operation -> Alias.Buffer);
            assert (Operation -> DirectoryPath.Buffer);

            DebugF (_T("LDAP: 0x%x server %08X has approved increase in lifetime of entry (%.*S) by %d seconds.\n"),
                    this,
                    ntohl (Operation -> ServerAddress.sin_addr.s_addr),
                    ANSI_STRING_PRINTF (&Operation -> Alias),
                    Operation -> EntryTimeToLive);

            LdapTranslationTable.RefreshEntry (&Operation -> Alias,
                                               &Operation -> DirectoryPath,
                                                Operation -> ClientAddress,
                                               &Operation -> ServerAddress,
                                                Operation -> EntryTimeToLive);

        }
        else {
            DebugF (_T("LDAP: 0x%x server %08X has rejected ModifyRequest, result code (%u).\n"),
                this,
                ntohl (Operation -> ServerAddress.sin_addr.s_addr), Response -> resultCode);
        }
    }
    else {
        DebugF (_T("LDAP: 0x%x received with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
            this,
            MessageID,
            Operation -> Type);
    }

    Operation -> FreeContents ();
                
    OperationArray.DeleteEntry (Operation);
}

void LDAP_CONNECTION::ProcessDeleteResponse (
    IN    LDAP_MESSAGE_ID        MessageID,
    IN    DelResponse *        Response)
{
}

BOOL LDAP_CONNECTION::ProcessSearchResponse (
    IN    LDAPMessage *    Message)
{
    SearchResponse *    Response;
    ANSI_STRING         ObjectName;
    LDAP_OBJECT_NAME_ELEMENTS    ObjectNameElements = { 0 };
    ANSI_STRING         AttributeTag;
    ASN1octetstring_t   IPAddressOldValue;
    ANSI_STRING         ClientAlias;
    ANSI_STRING         String;
    ANSI_STRING         ErrorMessage;
    HRESULT             TranslationTableLookupResult;
    DWORD               LookupAddress;           // host order
    SOCKADDR_IN         ServerAddress;
    DWORD               LocalToRequestedAddress; // host order
    DWORD               AddressToReport;

    SearchResponse_entry_attributes             * Iter;
    SearchResponse_entry_attributes_Seq_values  * ValueSequence;
    SearchResponse_entry_attributes_Seq         * Attribute;
    AttributeValue *    Attribute_IPAddress;
    AttributeValue *    Attribute_Sttl;

    CHAR                IPAddressText    [0x20];
    BOOL                Result = FALSE;
    LDAP_OPERATION *    Operation;

    SOCKET UDP_Socket      = INVALID_SOCKET;

    assert (Message);

    Response = &Message -> protocolOp.u.searchResponse;

    AssertLocked();

    if (!FindOperationByMessageID (Message -> messageID, &Operation)) {

        return FALSE;
    }

    switch (Response -> choice) {
    case entry_choice:

        // Determine address of the server
        if (!ServerSocket.GetRemoteAddress (&ServerAddress)) {
            return FALSE;
        }
        
        if(Response -> choice == entry_choice) {

            if (Operation -> Type == LDAP_OPERATION_SEARCH) {
                // Parse this object's name to get alias and IP address
                InitializeAnsiString (&ObjectName, &Response -> u.entry.objectName);
                ParseObjectName (&ObjectName, &ObjectNameElements);

                // scan through the set of attributes
                // find the ones of interest

                Attribute_IPAddress = NULL;
                Attribute_Sttl      = NULL;

                for (Iter = Response -> u.entry.attributes; Iter; Iter = Iter -> next) {
                    Attribute = &Iter -> value;

                    InitializeAnsiString (&AttributeTag, &Attribute -> type);

                    if (Attribute -> values) {
                        if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sipaddress, TRUE)
                            || RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_ipAddress, TRUE)) {

                            Attribute_IPAddress = &Attribute -> values -> value;

                        } else if (RtlEqualStringConst (&AttributeTag, &LdapText_Attribute_sttl, TRUE)) {

                            Attribute_Sttl = &Attribute -> values -> value;
                        }

                        // else, we aren't interested in the attribute
                    }
                    else {
                        // else, the attribute has no values
                    }
                }

                // make sure that the alias is present
                ClientAlias = ObjectNameElements.CN;

                if (ClientAlias.Length == 0) {
                    Result = FALSE;
                } else {
                    
                    if (Attribute_Sttl) {

                        // NetMeeting refreshes its registrations on an ILS by periodically sending a SearchRequest with 
                        // attribute "sttl"

                        DebugF (_T ("LDAP: 0x%x server %08X has approved increase in lifetime of entry (%.*S) by %d seconds.\n"),
                                    this, 
                                    ntohl (ServerAddress.sin_addr.s_addr), 
                                    ANSI_STRING_PRINTF (&ClientAlias), 
                                    Operation -> EntryTimeToLive);

                        LdapTranslationTable.RefreshEntry (&ClientAlias,
                                                           &ObjectName,
                                                            Operation -> ClientAddress,
                                                           &Operation -> ServerAddress, 
                                                            Operation -> EntryTimeToLive);

                    } else {
                        // make sure ip address attribute is present
                        if (!Attribute_IPAddress) {
                            Result = FALSE;
                        } else {
                            // see whether there is a registration entry in the translation table
                            // with the same alias
                            TranslationTableLookupResult = LdapQueryTableByAliasServer (&ClientAlias,
                                                                                   &Operation -> ServerAddress,
                                                                                   &LookupAddress);
                            // If an entry with the same alias is not in the table, 
                            // then we send the SearchResponse PDU unmodified to the requestor
                            if (S_OK != TranslationTableLookupResult) {

                                Result = FALSE;
                            
                            } else {
                                // Otherwise, we decide what would be the correct address
                                // to report to the requestor. We will either report the address
                                // read from the Address Translation Table, or the address
                                // of the interface requestor used to reach us. The decision will be
                                // made based on the interface address requestor used to reach us, and
                                // address of the interface we would use to reach the requestee.

                                if (INADDR_NONE == SourceInterfaceAddress) {
                                    DebugF (_T("LDAP: 0x%x failed to get best interface address for the requestor.\n"), this);
                                    return FALSE;
                                }

                                // Determine on which interface we would connect to the entity whose address was requested
                                if (GetBestInterfaceAddress (LookupAddress, &LocalToRequestedAddress)) {
                                    DebugF (_T("LDAP: 0x%x failed to get best interface address for the requestee.\n"), this);
                                    return FALSE;
                                }

                                // The default reporting behaviour is to report the address of the best interface to reach the requestor,
                                // thus shielding the requestor from the knowledge of the network internals.
                                //
                                // However, there are three exceptions to this rule, when we report the actual address stored
                                // in the Address Translation Table. These exceptions are as follows:
                                //
                                // 1. If the requestor is local.
                                //    In this case we assume that the requestor can directly reach the requestee, and thus
                                //    an H.323 call between them doesn't have to be routed via us.
                                //
                                // 2. If local H323 routing is enabled, AND the requestor and the requestee have the same address
                                //    This is necessary to allow the requestor to do something special with the calls to itself
                                //    (NetMeeting, for example, prohibits such calls).
                                // 
                                // 3. If local H323 routing is disabled, and requestor and requestee are reachable through the
                                //    same interface.
                                //    In these case we assume that the requestor and the requestee can directly reach one another,
                                //    and thus an H.323 call between them doesn't have to be routed via us.
                                //   
                        
                                if (::NhIsLocalAddress (SourceAddress.sin_addr.s_addr)) {

                                    AddressToReport = LookupAddress;

                                } else {

                                    if (EnableLocalH323Routing) {
                                    
                                        AddressToReport = (ntohl (SourceAddress.sin_addr.s_addr) == LookupAddress)  ?
                                                    LookupAddress            :
                                                    SourceInterfaceAddress;
                                    } else {

                                        AddressToReport = (SourceInterfaceAddress == LocalToRequestedAddress)       ?
                                                    LookupAddress            :
                                                    SourceInterfaceAddress;

                                    }
                                }

                                assert (Attribute_IPAddress);

                                if (RtlIntegerToChar (htonl (AddressToReport),
                                    10, 0x1F, IPAddressText) != STATUS_SUCCESS) {
                                    DebugF (_T("LDAP: 0x%x failed to convert IP address to text -- internal error.\n"), this);
                                    Result = FALSE;
                                } else {

                                    DebugF (_T("LDAP: 0x%x read %08X in table. Reporting  %08X to requestor %08X.\n"),
                                         this,
                                         LookupAddress, AddressToReport, ntohl (SourceAddress.sin_addr.s_addr));

                                    // Save the old value of the IP address, - we will need to restore
                                    // the PDU structure later.
                                    IPAddressOldValue = *Attribute_IPAddress;

                                    // now, in-place, we modify the PDU structure,
                                    // reencode it, send it, undo the modification
                                    // (so ASN1Free_SearchResponse doesn't act up)
                                    Attribute_IPAddress -> value = (PUCHAR) IPAddressText;
                                    Attribute_IPAddress -> length = strlen (IPAddressText);

                                    PumpServerToClient.EncodeSendMessage (Message);

                                    // switch back so we don't a/v when decoder frees pdu
                                    *Attribute_IPAddress = IPAddressOldValue;

                                    Result = TRUE;
                                }
                            }
                        }
                    }
                }
            } else {
                DebugF (_T("LDAP: 0x%x received response with message ID (%u), and found matching pending request, but the type of the request does not match (%d).\n"),
                    this,
                    Message -> messageID,
                    Operation -> Type);

                Result = FALSE;
            }
        } 
    break;

    case resultCode_choice:

        // We free the operation and associated memory on SearchResponses containing result
        // code, no matter whether the code indicated success or failure
        InitializeAnsiString (&ErrorMessage, &Response -> u.resultCode.errorMessage);

        DebugF (_T("LDAP: 0x%x result in SearchResponse (%d) (code=%d message=(%*.S)).\n"),
             this,
             Message -> messageID,
             Response -> u.resultCode.resultCode,
             ANSI_STRING_PRINTF (&ErrorMessage));

        Operation -> FreeContents ();
                
        OperationArray.DeleteEntry (Operation);

    break;

    default:

        AssertNeverReached ();
    }

    return Result;
}

// this method does not assume ownership of the LdapMessage structure,
// which has scope only of this call stack.

BOOL LDAP_CONNECTION::ProcessLdapMessage (
    IN    LDAP_PUMP *        Pump,
    IN    LDAPMessage *    LdapMessage)
{
    assert (Pump);
    assert (LdapMessage);

    if (Pump == &PumpClientToServer) {

        switch (LdapMessage -> protocolOp.choice) {
        case addRequest_choice:
            DebugF (_T("LDAP: 0x%x received AddRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessAddRequest (LdapMessage);

        case modifyRequest_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessModifyRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyRequest);

        case delRequest_choice:
            DebugF (_T("LDAP: 0x%x received DeleteRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessDeleteRequest (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delRequest);

        case searchRequest_choice:
            DebugF (_T("LDAP: 0x%x received SearchRequest (%d).\n"), this, LdapMessage -> messageID);
            return ProcessSearchRequest (LdapMessage);

        case bindRequest_choice:
            DebugF (_T("LDAP: 0x%x received BindRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case abandonRequest_choice:
            DebugF (_T("LDAP: 0x%x received AbandonRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case unbindRequest_choice:
            DebugF (_T("LDAP: 0x%x received UnbindRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case modifyRDNRequest_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRDNRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case compareDNRequest_choice:
            DebugF (_T("LDAP: 0x%x received CompareDNRequest (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        default:
            return FALSE;
        }

        return FALSE;
    }
    else if (Pump == &PumpServerToClient) {

        switch (LdapMessage -> protocolOp.choice) {
        case    addResponse_choice:
            DebugF (_T("LDAP: 0x%x received AddResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessAddResponse (LdapMessage);
            break;

        case    modifyResponse_choice:
            DebugF (_T("LDAP: 0x%x received ModifyResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessModifyResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.modifyResponse);
            break;

        case    delResponse_choice:
            DebugF (_T("LDAP: 0x%x received DeleteResponse (%d).\n"), this, LdapMessage -> messageID);
            ProcessDeleteResponse (LdapMessage -> messageID, &LdapMessage -> protocolOp.u.delResponse);
            break;

        case    searchResponse_choice:
            DebugF (_T("LDAP: 0x%x received SearchResponse (%d).\n"), this, LdapMessage -> messageID);
            return ProcessSearchResponse (LdapMessage);
            break;

        case bindResponse_choice:
            DebugF (_T("LDAP: 0x%x received BindResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case modifyRDNResponse_choice:
            DebugF (_T("LDAP: 0x%x received ModifyRDNResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        case compareDNResponse_choice:
            DebugF (_T("LDAP: 0x%x received CompareDNResponse (%d).\n"), this, LdapMessage -> messageID);
            return FALSE;

        default:
            break;
        }

        return FALSE;

    }
    else {
        AssertNeverReached();
        return FALSE;
    }
}

void LDAP_CONNECTION::ProcessBuffer (
    IN    LDAP_PUMP *        Pump,
    IN    LDAP_BUFFER *    Buffer)
{
    ASN1error_e        Error;
    LDAPMessage *    PduStructure;
    ASN1decoding_t    Decoder;

    assert (Pump);
    assert (Buffer);
        
    // decode the PDU

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, Buffer -> Data.Data, Buffer -> Data.Length, NULL);

    if (Error == ASN1_SUCCESS) {

        PduStructure = NULL;
        Error = ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, NULL, 0);

        if (ASN1_SUCCEEDED (Error)) {
            if (ProcessLdapMessage (Pump, PduStructure)) {
                // a TRUE return value indicates that ProcessLdapMessage interpreted
                // and acted on the contents of PduStructure.  therefore, the
                // original PDU is no longer needed, and is destroyed.

                delete Buffer;
            }
            else {
                // a FALSE return value indicates that ProcessLdapMessage did NOT
                // interpret the contents of PduStructure, and that no data has been
                // sent to the other socket.  In this case, we forward the original PDU.

                Pump -> SendQueueBuffer (Buffer);
            }

            ASN1_FreeDecoded (Decoder, PduStructure, LDAPMessage_ID);
        }
        else {
            DebugF (_T("LDAP: 0x%x failed to decode pdu, ASN.1 error %d, forwarding pdu without interpreting contents.\n"),
                this,
                Error);

#if    DBG
        if (DebugLevel > 1) {
            DumpMemory (Buffer -> Data.Data, Buffer -> Data.Length);
            BerDump (Buffer -> Data.Data, Buffer -> Data.Length);
            ASN1_Decode (Decoder, (PVOID *) &PduStructure, LDAPMessage_ID, 0, Buffer -> Data.Data, Buffer -> Data.Length);
        }
#endif
            Pump -> SendQueueBuffer (Buffer);
        }

        ASN1_CloseDecoder (Decoder);
    }
    else {
        DebugF (_T("LDAP: 0x%x failed to create ASN.1 decoder, ASN.1 error %08X, forwarding pdu without interpreting contents.\n"),
            this,
            Error);

        Pump -> SendQueueBuffer (Buffer);
    }
}

// static
INT LDAP_CONNECTION::BinarySearchOperationByMessageID (
    IN    const    LDAP_MESSAGE_ID *    SearchKey,
    IN    const    LDAP_OPERATION *    Comparand)
{
    if (*SearchKey < Comparand -> MessageID) return -1;
    if (*SearchKey > Comparand -> MessageID) return 1;

    return 0;
}

BOOL LDAP_CONNECTION::FindOperationIndexByMessageID (
    IN    LDAP_MESSAGE_ID    MessageID,
    OUT    DWORD *            ReturnIndex)
{
    return OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, ReturnIndex);
}

BOOL LDAP_CONNECTION::FindOperationByMessageID (
    IN    LDAP_MESSAGE_ID    MessageID,
    OUT    LDAP_OPERATION **    ReturnOperation)
{
    DWORD    Index;

    if (OperationArray.BinarySearch ((SEARCH_FUNC_LDAP_OPERATION)BinarySearchOperationByMessageID, &MessageID, &Index)) {
        *ReturnOperation = &OperationArray[Index];
        return TRUE;
    }
    else {
        *ReturnOperation = NULL;
        return FALSE;
    }
}

void LDAP_CONNECTION::OnStateChange (
    LDAP_SOCKET *        ContainedSocket,
    LDAP_SOCKET::STATE    NewSocketState)
{
    assert (ContainedSocket == &ClientSocket || ContainedSocket == &ServerSocket);

    AssertLocked();

    switch (NewSocketState) {

    case    LDAP_SOCKET::STATE_CONNECT_PENDING:
        // Client socket transitions directly from
        // STATE_NONE to STATE_CONNECTED
        assert (ContainedSocket != &ClientSocket);

        State = STATE_CONNECT_PENDING;

        break;

    case    LDAP_SOCKET::STATE_CONNECTED:

        if (ClientSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED
            && ServerSocket.GetState() == LDAP_SOCKET::STATE_CONNECTED) {
            
            State = STATE_CONNECTED;

            StartIo();
        }

        break;

    case    LDAP_SOCKET::STATE_TERMINATED:

        Terminate ();

        break;
    }
}


void LDAP_CONNECTION::Terminate (void)
{
    switch (State) {
        
    case    STATE_TERMINATED:
        // nothing to do
        break;

    default:
        State = STATE_TERMINATED;

        ClientSocket.Terminate();
        ServerSocket.Terminate();
        PumpClientToServer.Terminate();
        PumpServerToClient.Terminate();

        LdapConnectionArray.RemoveConnection (this);
        
        break;
    }
}

void LDAP_CONNECTION::TerminateExternal (void) 
{
    Lock ();
    
    Terminate ();

    Unlock ();
}


BOOL
LDAP_CONNECTION::IsConnectionThrough (
    IN DWORD InterfaceAddress // host order
    )
/*++

Routine Description:
    Determines whether the connection goes through the
    interface specified

Arguments:
    InterfaceAddress - address of the interface for which
        the determination is to be made.

Return Values:
    TRUE - if the connection being proxied goes through the
        interface specified

    FALSE - if the connection being proxied does not go through the
        interface specified

Notes:

--*/

{
    BOOL IsThrough;
    
    IsThrough = (InterfaceAddress == SourceInterfaceAddress) || 
                (InterfaceAddress == DestinationInterfaceAddress);

    return IsThrough;

} // LDAP_CONNECTION::IsConnectionThrough

// LDAP_CONNECTION_ARRAY ----------------------------------------------
LDAP_CONNECTION_ARRAY::LDAP_CONNECTION_ARRAY (void) {        
    IsEnabled = FALSE;
}

void LDAP_CONNECTION_ARRAY::RemoveConnection (
    LDAP_CONNECTION *    LdapConnection)
{
    LDAP_CONNECTION **    Pos;
    LDAP_CONNECTION **    End;
    BOOL                DoRelease;

    Lock();

    // linear scan, yick

    DoRelease = FALSE;

    ConnectionArray.GetExtents (&Pos, &End);

    for (; Pos < End; Pos++) {
        if (*Pos == LdapConnection) {

            // swap with last entry
            // quick way to delete entry from table
            *Pos = *(End - 1);
            ConnectionArray.Length--;

            DoRelease = TRUE;
            break;
        }
    }

    Unlock();

    if (DoRelease) {

        LdapConnection -> Release();
    }
    else {
        // when could this happen?
        // perhaps a harmless race condition?

        DebugF (_T("LDAP: 0x%x could not be removed from table -- was not in table to begin with.\n"), LdapConnection);
    }
}

void LDAP_CONNECTION_ARRAY::OnInterfaceShutdown (
    IN DWORD InterfaceAddress) { // host order
    
    DWORD ArrayIndex = 0;
    LDAP_CONNECTION * Connection;
    LDAP_CONNECTION ** ConnectionHolder = NULL;
    DYNAMIC_ARRAY <LDAP_CONNECTION *> TempArray;

    Lock ();

    while (ArrayIndex < ConnectionArray.GetLength ()) {
        Connection = ConnectionArray [ArrayIndex];

        if (Connection -> IsConnectionThrough (InterfaceAddress)) {

            DebugF (_T("LDAP: 0x%x terminating (killing all connections through %08X).\n"), 
                Connection, InterfaceAddress);

            ConnectionHolder = TempArray.AllocAtEnd ();

            if (NULL == ConnectionHolder) {

                Debug (_T("LDAP_CONNECTION_ARRAY::OnInterfaceShutdown - unable to grow array.\n"));

            } else {

                Connection -> AddRef ();

                *ConnectionHolder = Connection;
            }
        }

        ArrayIndex++;
    }

    Unlock ();

    ArrayIndex = 0;

    while (ArrayIndex < TempArray.GetLength ()) {
        Connection = TempArray[ArrayIndex];

        Connection -> TerminateExternal ();

        Connection -> Release ();

        ArrayIndex++;
    }
}

void LDAP_CONNECTION_ARRAY::Start (void)
{        
    Lock ();

    IsEnabled = TRUE;

    Unlock ();
}

void LDAP_CONNECTION_ARRAY::Stop (void)
{
    LDAP_CONNECTION * LdapConnection;

    Lock ();

    IsEnabled = FALSE;

    while (ConnectionArray.GetLength()) {

        LdapConnection = ConnectionArray[0];

        LdapConnection -> AddRef ();

        Unlock ();

        LdapConnection -> TerminateExternal ();

        Lock ();

        LdapConnection -> Release ();
    }

    ConnectionArray.Free ();

    Unlock ();
}
    
HRESULT LDAP_CONNECTION_ARRAY::InsertConnection (
                                LDAP_CONNECTION * LdapConnection)
{
    LDAP_CONNECTION ** ConnectionHolder = NULL;
    HRESULT Result;

    Lock ();

    if (IsEnabled) {

        if (ConnectionArray.Length <= LDAP_MAX_CONNECTIONS) {

            ConnectionHolder = ConnectionArray.AllocAtEnd ();

            if (NULL == ConnectionHolder) {

                Result = E_OUTOFMEMORY;

            } else {

                LdapConnection -> AddRef ();

                *ConnectionHolder = LdapConnection;

                Result = S_OK;
            }

        } else {

            return E_ABORT;

        }

    } else {
    
        Result = E_FAIL;
    }

    Unlock ();

    return Result;
}

// LDAP_ACCEPT ----------------------------------------------

LDAP_ACCEPT::LDAP_ACCEPT (void)
{
}

// static
void 
LDAP_ACCEPT::AsyncAcceptFunction (
    IN    PVOID         Context,
    IN    SOCKET        Socket,
    IN    SOCKADDR_IN * LocalAddress,
    IN    SOCKADDR_IN * RemoteAddress
    )
{
    HRESULT Result;

    Result = AsyncAcceptFunctionInternal (
                Context,
                Socket,
                LocalAddress,
                RemoteAddress
                );

    if (S_OK != Result) {
    
        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);

            Socket = INVALID_SOCKET;
        }
    }
}
   
// static
HRESULT 
LDAP_ACCEPT::AsyncAcceptFunctionInternal (
    IN    PVOID         Context,
    IN    SOCKET        Socket,
    IN    SOCKADDR_IN * LocalAddress,
    IN    SOCKADDR_IN * RemoteAddress
    )
{
    LDAP_CONNECTION *   LdapConnection;
    HRESULT             Result;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION RedirectInformation;
    ULONG               RedirectInformationLength;
    ULONG               Error;
    DWORD               BestInterfaceAddress;
    SOCKADDR_IN         DestinationAddress;

    DebugF (_T("LDAP: ----------------------------------------------------------------------\n"));

#if DBG
    ExposeTimingWindow ();
#endif

    // a new LDAP connection has been accepted from the network.
    // first, we determine the original addresses of the transport connection.
    // if the connection was redirected to our socket (due to NAT),
    // then the query of the NAT redirect table will yield the original transport addresses.
    // if an errant client has connected to our service, well, we really didn't
    // intend for that to happen, so we just immediately close the socket.

    RedirectInformationLength = sizeof RedirectInformation;

    Result = NatLookupAndQueryInformationSessionMapping (
        NatHandle,
        IPPROTO_TCP,
        LocalAddress -> sin_addr.s_addr,
        LocalAddress -> sin_port,
        RemoteAddress -> sin_addr.s_addr,
        RemoteAddress -> sin_port,
        &RedirectInformation,
        &RedirectInformationLength,
        NatKeySessionMappingExInformation);

    if (STATUS_SUCCESS != Result) {

        DebugErrorF (Result, _T("LDAP: new connection was accepted from (%08X:%04X), but it is not in the NAT redirect table -- rejecting connection.\n"),
            ntohl (RemoteAddress -> sin_addr.s_addr),
            ntohs (RemoteAddress -> sin_port));

        return Result;
    }

    Error = GetBestInterfaceAddress (ntohl (RedirectInformation.DestinationAddress), &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        if (WSAEHOSTUNREACH == Error) {
    
            Error = RasAutoDialSharedConnection ();
        
            if (ERROR_SUCCESS != Error) {
                
                DebugF (_T("LDAP: RasAutoDialSharedConnection failed. Error=%d\n"), Error);
    
            }
    
        } else {

            DebugError (Error, _T("LDAP: Failed to get interface address for the destination.\n"));
            
            return HRESULT_FROM_WIN32 (Error);
        }
    }
    
#if DBG
    BOOL                IsPrivateOrLocalSource;
    BOOL                IsPublicDestination;

    Result = ::IsPrivateAddress (ntohl (RedirectInformation.SourceAddress), &IsPrivateOrLocalSource);

    if (S_OK != Result) {

        return Result;

    }

    IsPrivateOrLocalSource = IsPrivateOrLocalSource || ::NhIsLocalAddress (RedirectInformation.SourceAddress);

    Result = ::IsPublicAddress (ntohl (RedirectInformation.DestinationAddress), &IsPublicDestination);

    if (S_OK != Result) {

        return Result;

    }

    if (::NhIsLocalAddress (RedirectInformation.SourceAddress) &&
        ::NhIsLocalAddress (RedirectInformation.DestinationAddress))  {

        Debug (_T("LDAP: New LOCAL connection.\n"));

    } else {

        if (IsPrivateOrLocalSource && IsPublicDestination) {

            Debug (_T("LDAP: New OUTBOUND connection.\n"));

        } else {

            Debug (_T("LDAP: New INBOUND connection.\n"));
        }
    }
#endif // DBG

    DebugF (_T("LDAP: Connection redirected: (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
        ntohl (RedirectInformation.SourceAddress),
        ntohs (RedirectInformation.SourcePort),
        ntohl (RedirectInformation.DestinationAddress),
        ntohs (RedirectInformation.DestinationPort),
        ntohl (RedirectInformation.NewSourceAddress),
        ntohs (RedirectInformation.NewSourcePort),
        ntohl (RedirectInformation.NewDestinationAddress),
        ntohs (RedirectInformation.NewDestinationPort));

    // Create new LDAP_CONNECTION object
    LdapConnection = new LDAP_CONNECTION (&RedirectInformation);

    if (!LdapConnection) {

        DebugF(_T("LDAP: Failed to allocate LDAP_CONNECTION.\n"));

        return E_OUTOFMEMORY;
    }

    LdapConnection -> AddRef ();

    Result = LdapConnection -> Initialize (&RedirectInformation);

    if (S_OK == Result) {

        DestinationAddress.sin_family      = AF_INET;
        DestinationAddress.sin_addr.s_addr = RedirectInformation.DestinationAddress;
        DestinationAddress.sin_port        = RedirectInformation.DestinationPort; 

        if (S_OK == LdapConnectionArray.InsertConnection (LdapConnection)) {

            Result = LdapConnection -> AcceptSocket (Socket,
              LocalAddress,
              RemoteAddress,
              &DestinationAddress);

            if (S_OK != Result) {

                DebugF (_T("LDAP: 0x%x accepted new LDAP client, but failed to proceed.\n"), LdapConnection);

                // Probably there was something wrong with just this
                // Accept failure. Continue to accept more LDAP connections.
            }
        }

    } else {

        DebugF (_T("LDAP: 0x%x failed to initialize.\n"), LdapConnection);

    }

    LdapConnection -> Release (); 
    
    return Result;
}

HRESULT LDAP_ACCEPT::StartLoopbackNatRedirects (void) {

    NTSTATUS    Status;

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (LDAP_STANDARD_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &LoopbackRedirectHandle1);

    if (Status != STATUS_SUCCESS) {
        LoopbackRedirectHandle1 = NULL;

        DebugError (Status, _T("LDAP: Failed to create local dynamic redirect #1.\n"));

        return (HRESULT) Status;
    }

    DebugF (_T ("LDAP: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                LDAP_STANDARD_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (LDAP_ALTERNATE_PORT),
        LdapListenSocketAddress.sin_addr.s_addr,
        LdapListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &LoopbackRedirectHandle2); 

    if (Status != STATUS_SUCCESS) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle1);

        LoopbackRedirectHandle1 = NULL;
        LoopbackRedirectHandle2 = NULL;

        DebugError (Status, _T("LDAP: Failed to create local dynamic redirect #2.\n"));

        return (HRESULT) Status;
    }

    DebugF (_T ("LDAP: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                LDAP_ALTERNATE_PORT,
                ntohl (LdapListenSocketAddress.sin_addr.s_addr),
                ntohs (LdapListenSocketAddress.sin_port));

    return (HRESULT) Status; 
} 

HRESULT LDAP_ACCEPT::CreateBindSocket (
    void) {

    HRESULT            Result;
    SOCKADDR_IN        SocketAddress;

    SocketAddress.sin_family      = AF_INET;
    SocketAddress.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
    SocketAddress.sin_port        = htons (0);             // request dynamic port

    Result = AsyncAcceptContext.StartIo (
        &SocketAddress,
        AsyncAcceptFunction,
        NULL);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP: Failed to create and bind socket.\n"));

        return Result;
    }

    DebugF (_T("LDAP: Asynchronous Accept started.\n"));

    Result = AsyncAcceptContext.GetListenSocketAddress (&LdapListenSocketAddress);

    if (Result != S_OK) {

        DebugError (Result, _T("LDAP: Failed to get listen socket address.\n"));

        return Result;
    }

    return S_OK;
}

HRESULT LDAP_ACCEPT::Start (void)
{
    HRESULT        Result;

    Result = CreateBindSocket ();

    if (S_OK == Result) {

        Result = StartLoopbackNatRedirects ();

        if (S_OK == Result) {

            return  S_OK;

        }

        CloseSocket ();
    }

    return Result;
}

void LDAP_ACCEPT::Stop (void) {

    StopLoopbackNatRedirects ();

    CloseSocket ();
}

void LDAP_ACCEPT::StopLoopbackNatRedirects (void) {

    if (LoopbackRedirectHandle1) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle1);

        LoopbackRedirectHandle1 = NULL;

    }

    if (LoopbackRedirectHandle2) {

        NatCancelDynamicRedirect (LoopbackRedirectHandle2);

        LoopbackRedirectHandle2 = NULL;

    }
}

void LDAP_ACCEPT::CloseSocket (void) {

    ZeroMemory ((PVOID)&LdapListenSocketAddress, sizeof (SOCKADDR_IN));

    AsyncAcceptContext.StopWait ();
}

LDAP_BUFFER::LDAP_BUFFER (void) 
{
}

LDAP_BUFFER::~LDAP_BUFFER (void) 
{
}


// LDAP_CODER ---------------------------------------------------------------------

LDAP_CODER::LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Startup();
}

LDAP_CODER::~LDAP_CODER (void)
{
    Encoder = NULL;
    Decoder = NULL;

    LDAP_Module_Cleanup();
}

DWORD LDAP_CODER::Start (void)
{
    DWORD    Status;
    ASN1error_e    Error;

    Lock();

    Status = ERROR_SUCCESS;

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to initialize LDAP ASN.1 BER encoder, 0x%08X.\n"), Error);
        Encoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Error = ASN1_CreateDecoder (LDAP_Module, &Decoder, NULL, 0, NULL);

    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to initialize LDAP ASN.1 BER decoder, 0x%08X.\n"), Error);
        Decoder = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    Unlock();

    return Status;
}

void LDAP_CODER::Stop (void)
{
    Lock();

    if (Encoder) {
        ASN1_CloseEncoder (Encoder);
        Encoder = NULL;
    }

    if (Decoder) {
        ASN1_CloseDecoder (Decoder);
        Decoder = NULL;
    }

    Unlock();
}

ASN1error_e LDAP_CODER::Decode (
    IN    LPBYTE    Data,
    IN    DWORD    Length,
    OUT    LDAPMessage **    ReturnPduStructure,
    OUT    DWORD *    ReturnIndex)
{
    ASN1error_e        Error;

    assert (Data);
    assert (ReturnPduStructure);
    assert (ReturnIndex);

    Lock();

    if (Decoder) {

#if DBG
        BerDump (Data, Length);
#endif

        Error = ASN1_Decode (
            Decoder,
            (PVOID *) ReturnPduStructure,
            LDAPMessage_ID,
            ASN1DECODE_SETBUFFER,
            Data,
            Length);

        switch (Error) {
        case    ASN1_SUCCESS:
            // successfully decoded pdu

            *ReturnIndex = Decoder -> len;
            assert (*ReturnPduStructure);

            DebugF (_T("LDAP: Successfully decoded PDU, submitted buffer length %d, used %d bytes.\n"),
                Length,
                *ReturnIndex);

            break;

        case    ASN1_ERR_EOD:
            // not enough data has been accumulated yet

            *ReturnIndex = 0;
            *ReturnPduStructure = NULL;

            DebugF (_T("LDAP: Cannot yet decode PDU, not enough data submitted (%d bytes in buffer).\n"),
                Length);
            break;

        default:
            if (ASN1_FAILED (Error)) {
                DebugF (_T("LDAP: Failed to decode PDU, for unknown reasons, 0x%08X.\n"),
                    Error);
            }
            else {
                DebugF (_T("LDAP: PDU decoded, but with warning code, 0x%08X.\n"),
                    Error);
            
                *ReturnIndex = Decoder -> len;
            }
            break;
        }
    }
    else {
        Debug (_T("LDAP: cannot decode pdu, because decoder was not initialized.\n"));

        Error = ASN1_ERR_INTERNAL;
    }

    Unlock();

    return Error;
} 

// LDAP_PUMP --------------------------------------------------------------

LDAP_PUMP::LDAP_PUMP (
    IN    LDAP_CONNECTION *    ArgConnection,
    IN    LDAP_SOCKET *        ArgSource,
    IN    LDAP_SOCKET *        ArgDest)
{
    assert (ArgConnection);
    assert (ArgSource);
    assert (ArgDest);

    Connection = ArgConnection;
    Source = ArgSource;
    Dest = ArgDest;
    IsPassiveDataTransfer = FALSE;
}

LDAP_PUMP::~LDAP_PUMP (void)
{
}

void LDAP_PUMP::Terminate (void)
{
}

void LDAP_PUMP::Start (void)
{
    Source -> RecvIssue();
}

void LDAP_PUMP::Stop (void)
{
}

// called only by source socket OnRecvComplete
void LDAP_PUMP::OnRecvBuffer (
    IN    LDAP_BUFFER * Buffer)
{
    if (IsActivelyPassingData ()) {

        Connection -> ProcessBuffer (this, Buffer);
    
    } else {
        
        SendQueueBuffer (Buffer);
    }
}

void LDAP_PUMP::OnSendDrain (void)
{
    Source -> RecvIssue();
}

BOOL LDAP_PUMP::CanIssueRecv (void)
{
    return !Dest -> SendOverlapped.IsPending;
}

void LDAP_PUMP::SendQueueBuffer (
    IN    LDAP_BUFFER *    Buffer)
{
    Dest -> SendQueueBuffer (Buffer);
}

void LDAP_PUMP::EncodeSendMessage (
   IN    LDAPMessage *    Message)
{
    LDAP_BUFFER *    Buffer;
    ASN1encoding_t    Encoder;
    ASN1error_e        Error;

    Buffer = new LDAP_BUFFER;
    if (!Buffer) {
        Debug (_T("LDAP: EncodeSendMessage: allocation failure.\n"));
        return;
    }

    Error = ASN1_CreateEncoder (LDAP_Module, &Encoder, NULL, 0, NULL);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: EncodeSendMessage: failed to create ASN.1 encoder, error 0x%08X.\n"),
            Error);

        delete Buffer;
        return;
    }

    Error = ASN1_Encode (Encoder, Message, LDAPMessage_ID, ASN1ENCODE_ALLOCATEBUFFER, NULL, 0);
    if (ASN1_FAILED (Error)) {
        DebugF (_T("LDAP: Failed to encode LDAP message, error 0x%08X.\n"), Error);

        ASN1_CloseEncoder (Encoder);
        delete Buffer;
        return;
    }

    if (Buffer -> Data.Grow (Encoder -> len)) {

        memcpy (Buffer -> Data.Data, Encoder -> buf, Encoder -> len);
        Buffer -> Data.Length = Encoder -> len;

        ASN1_FreeEncoded (Encoder, Encoder -> buf);

        SendQueueBuffer (Buffer);
        Buffer = NULL;
    }
    else {

        delete Buffer;
    }

    ASN1_CloseEncoder (Encoder);
}

BOOL    LDAP_PUMP::IsActivelyPassingData (void) const {

    return !IsPassiveDataTransfer;

}

void LDAP_PUMP::StartPassiveDataTransfer (void) {

    IsPassiveDataTransfer = TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\main.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    main.h

Abstract:

    Contains:
        1. Prototypes for routines used in asynchrounous I/O
        2. Definitions of constants and macros used by the above routines
        3. Definitions of macros and inline routines for memory management

Environment:

    User Mode - Win32

History:
    
    1. 31-Jul-1998 -- File creation                     Ajay Chitturi (ajaych) 
    2. 15-Jul-1999 --                                   Arlie Davis   (arlied)    
    3. 14-Feb-2000 -- Added support for multiple        Ilya Kleyman  (ilyak)
                      private interfaces

--*/
#ifndef    __h323ics_main_h
#define    __h323ics_main_h

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Constants and macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define    DEFAULT_TRACE_FLAGS          LOG_TRCE

#define    MAX_LISTEN_BACKLOG           5

#define    LOCAL_INTERFACE_INDEX     ((ULONG)-2)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

extern HANDLE   NatHandle;
extern DWORD    EnableLocalH323Routing;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Prototypes for routines used in asynchrounous I/O                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
HRESULT
EventMgrIssueAccept (
    IN  DWORD                   BindIPAddress,          // in HOST order
    IN  OVERLAPPED_PROCESSOR &  OverlappedProcessor, 
    OUT WORD &                  BindPort,               // in HOST order
    OUT SOCKET &                ListenSocket
    );

HRESULT
EventMgrIssueSend(
    IN SOCKET                   Socket,
    IN OVERLAPPED_PROCESSOR &   OverlappedProcessor,
    IN BYTE                     *Buffer,
    IN DWORD                    BufferLength
    );
    
HRESULT
EventMgrIssueRecv(
    IN SOCKET                   Socket,
    IN OVERLAPPED_PROCESSOR &   OverlappedProcessor
    );

HRESULT
EventMgrBindIoHandle(
    IN SOCKET                   Socket
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Memory management support                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


__inline
void *EM_MALLOC (
    IN size_t Size
    )
/*++

Routine Description:

    Private memory allocator.

Arguments:

    Size - number of bytes to allocate

Return Values:
    - Pointer to allocated memory, if successful.
    - NULL otherwise.

Notes:

--*/

{
    return (HeapAlloc (GetProcessHeap (),
              0, /* no flags */
              (Size)));
} // EM_MALLOC


__inline
void
EM_FREE(
    IN void *Memory
    )
/*++

Routine Description:

    Private memory deallocator

Arguments:

    Memory -- pointer to allocated memory

Return Values:

    None

Notes:
    The memory should have previously been
    allocated via EM_MALLOC

--*/

{
    HeapFree (GetProcessHeap (),
         0, /* no flags */
         (Memory));
} // EM_FREE

#endif // __h323ics_main_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\ovioctx.h ===
/*
 * Copyright (c) 1998, Microsoft Corporation
 * File: timeout.cpp
 *
 * Purpose: 
 * 
 * Contains all the definitions
 * for the overlapped I/O context structures
 *
 * History:
 *
 *   1. created 
 *       Ajay Chitturi (ajaych)  26-Jun-1998
 *
 */

#ifndef _oviocontext_h_
#define _oviocontext_h_

/*
 * This file defines the structures used for overlapped I/O 
 */

#define ACCEPT_BUFFER_MAX       (sizeof (SOCKADDR_IN) * 2 + 0x20)
#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3

// Types of overlapped I/O requests
enum EMGR_OV_IO_REQ_TYPE
{
     EMGR_OV_IO_REQ_ACCEPT = 0,
     EMGR_OV_IO_REQ_SEND,
     EMGR_OV_IO_REQ_RECV
};



// This structure stores the I/O context for each Overlapped I/O request
// OVERLAPPED should always be the first member of this struct. 
// A pointer to the overlapped member of this structure is passed 
// for all overlapped I/O calls.
// When we receive an I/O completion packet, the IOContext pointer is 
// obtained by casting the OVERLAPPED pointer. 

typedef struct _IOContext {
    OVERLAPPED ov;
    EMGR_OV_IO_REQ_TYPE reqType;        // ACCEPT/SEND/RECV
    OVERLAPPED_PROCESSOR *pOvProcessor;   // callback called on this member
                                          // this gives us the socket and 
                                          // the call type (Q931/H245) as well
} IOContext, *PIOContext;

// This structure stores the I/O context 
// for each Overlapped Send/Recv request
typedef struct _SendRecvContext {
    IOContext ioCtxt;
    SOCKET sock;
    BYTE pbTpktHdr[TPKT_HEADER_SIZE];
    DWORD dwTpktHdrBytesDone;
    PBYTE pbData;
    DWORD dwDataLen;
    DWORD dwDataBytesDone;
} SendRecvContext, *PSendRecvContext;

// This structure stores the I/O context 
// for each Overlapped accept request
typedef struct _AcceptContext {
    IOContext ioCtxt;
    SOCKET listenSock;
    SOCKET acceptSock;
    BYTE addrBuf[ACCEPT_BUFFER_MAX]; 
} AcceptContext, *PAcceptContext;

#include "sockinfo.h"

// the PDU decode logic depends upon whether its targeted for
// a Q931 or H245 channel. Since we want to keep that logic
// in the event manager, the overlapped processor needs to
// expose its type via this 
enum OVERLAPPED_PROCESSOR_TYPE
{
	OPT_Q931 = 0,
	OPT_H245
};

// Classes (Q931 src, dest and H245) inheriting
// from this make async overlapped operations
// this class provides the callback methods and
// some of the parameters needed by the event manager
// to make the overlapped calls
class OVERLAPPED_PROCESSOR
{
protected:

    OVERLAPPED_PROCESSOR_TYPE  m_OverlappedProcessorType;

	// it belongs to this call state
	H323_STATE *	m_pH323State;
    SOCKET_INFO		m_SocketInfo;			// socket handle and remote/local address/ports

public:

	OVERLAPPED_PROCESSOR::OVERLAPPED_PROCESSOR (void)
		: m_OverlappedProcessorType	(OPT_Q931),
		  m_pH323State	(NULL)
	{}


	void Init (
		IN OVERLAPPED_PROCESSOR_TYPE	OverlappedProcessorType,
		IN H323_STATE					&H323State)
	{
		// an assert is sufficient as this shouldn't happen
		_ASSERTE(NULL == m_pH323State);

		m_OverlappedProcessorType	= OverlappedProcessorType;

		m_pH323State				= &H323State;
	}

	BOOLEAN IsSocketValid (void) { return m_SocketInfo.IsSocketValid(); }

    inline OVERLAPPED_PROCESSOR_TYPE GetOverlappedProcessorType() { return m_OverlappedProcessorType; }

    inline SOCKET_INFO &GetSocketInfo() { return m_SocketInfo; }

    inline H323_STATE &GetH323State() { return *m_pH323State; }

    inline CALL_BRIDGE &GetCallBridge();

    virtual HRESULT AcceptCallback (
		IN	DWORD	Status,
		IN	SOCKET	Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress) = 0;

    virtual HRESULT SendCallback(
        IN      HRESULT					  CallbackHResult
        ) = 0;

    virtual HRESULT ReceiveCallback(
        IN      HRESULT					 CallbackHResult,
        IN      BYTE                    *pBuffer,
        IN      DWORD                    BufLen
        ) = 0;
};

void
EventMgrFreeSendContext(
       IN PSendRecvContext			pSendCtxt
       );
void
EventMgrFreeRecvContext(
       IN PSendRecvContext			pRecvCtxt
       );
void
EventMgrFreeAcceptContext(
       IN PAcceptContext			pAcceptCtxt
       );

#endif //_oviocontext_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931io.h ===
#ifndef	__h323ics_q931io_h
#define	__h323ics_q931io_h



// this module DOES make use of the global sync counter (PxSyncCounter)
// declared in main.h


HRESULT	H323ProxyStart		(void);
void	H323ProxyStop		(void);
HRESULT H323Activate        (void);
void    H323Deactivate      (void);

#endif // __h323ics_q931io_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\portmgmt.cpp ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.cpp

Abstract:

    Functions for allocating and freeing ports from the Port pool

        PortPoolAllocRTPPort()
	PortPoolFreeRTPPort()

Environment:

    User Mode - Win32

--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Functions dealing with the TCP device to reserve/unreserve port ranges.   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

 
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Include files                                                             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


#define NUM_DWORD_BITS (sizeof(DWORD)*8)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define NUM_PORTS_PER_RANGE 100

struct	PORT_RANGE
{
	LIST_ENTRY		ListEntry;

    // This is the actual lower port. In case, the range allocated
    // by TCP starts with an odd port, we ignore the first port in
    // which case (low == AllocatedLow + 1). But when we free the
    // port range we should pass in AllocatedLow and not low.
    WORD  AllocatedLow;
    WORD  low;

    // high is the last port we can use and not the allocated high.
    // In some cases high will be one less than the actual allocated high.
    WORD  high;

    //Each bit in this bitmap indicates the status of 2 consecutive ports 

    DWORD *AllocList;
    DWORD dwAllocListSize;
};




class	PORT_POOL :
public	SIMPLE_CRITICAL_SECTION_BASE
{
private:
	HANDLE		TcpDevice;
	LIST_ENTRY	PortRangeList;		// contains PORT_RANGE.ListEntry

private:
	HRESULT		OpenTcpDevice	(void);
	HRESULT		StartLocked		(void);
	void		FreeAll			(void);

	HRESULT	CreatePortRange (
		OUT	PORT_RANGE **	ReturnPortRange);

	HRESULT	ReservePortRange (
		IN  ULONG	RangeLength,
		OUT WORD *	ReturnStartPort);

	HRESULT	UnReservePortRange (
		IN	WORD	StartPort);


public:

	PORT_POOL	(void);
	~PORT_POOL	(void);

	HRESULT		Start	(void);
	void		Stop	(void);

	HRESULT		AllocPort (
		OUT	WORD *	ReturnPort);

	void		FreePort (
		IN	WORD	Port);
};

// global data -------------------------------------------------------------------------

static	PORT_POOL	PortPool;

// extern code -----------------------------------------------------------------------

HRESULT PortPoolStart (void)
{
	return PortPool.Start();
}

void PortPoolStop (void)
{
	PortPool.Stop();
}

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort)
{
	return PortPool.AllocPort (ReturnPort);
}

HRESULT PortPoolFreeRTPPort (
	IN	WORD	Port)
{
	PortPool.FreePort (Port);

	return S_OK;
}





HRESULT PORT_POOL::ReservePortRange (
	IN  ULONG	RangeLength,
    OUT WORD *	ReturnStartPort)
{
    TCP_BLOCKPORTS_REQUEST	PortRequest;
    DWORD	BytesTransferred;
    ULONG	StartPort;

	AssertLocked();

    *ReturnStartPort = 0;

	if (!TcpDevice) {
		Debug (_T("H323: Cannot allocate port range, TCP device could not be opened.\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

    PortRequest.ReservePorts = TRUE;
    PortRequest.NumberofPorts = RangeLength;
    
    if (!DeviceIoControl (TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&StartPort, sizeof StartPort, 
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: Failed to allocate TCP port range.\n"));
        return GetLastError();
    }

	DebugF (_T("H323: Reserved port range: [%04X - %04X)\n"),
		StartPort, StartPort + PortRequest.NumberofPorts);

    *ReturnStartPort = (WORD) StartPort;
    return S_OK;
}



HRESULT PORT_POOL::UnReservePortRange (
	IN	WORD	StartPort)
{
	TCP_BLOCKPORTS_REQUEST	PortRequest;
	DWORD	BytesTransferred;
	DWORD	Status;

	AssertLocked();

	if (!TcpDevice) {
		Debug (_T("H323: Cannot free TCP port range, TCP device is not open.\n"));
		return E_UNEXPECTED;
	}

	assert (TcpDevice != INVALID_HANDLE_VALUE);

	PortRequest.ReservePorts = FALSE;
	PortRequest.StartHandle = (ULONG) StartPort;
    
	if (!DeviceIoControl(TcpDevice, IOCTL_TCP_BLOCK_PORTS,
		&PortRequest, sizeof PortRequest,
		&Status, sizeof Status,
		&BytesTransferred, NULL)) {

		DebugLastError (_T("H323: Failed to free TCP port range.\n"));

		return GetLastError();
    }

    return S_OK;
}




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Port Pool Functions.                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



// PORT_POOL -----------------------------------------------------------------------

PORT_POOL::PORT_POOL (void)
{
	TcpDevice = NULL;
	InitializeListHead (&PortRangeList);
}

PORT_POOL::~PORT_POOL (void)
{
	assert (!TcpDevice);
	assert (IsListEmpty (&PortRangeList));
}

HRESULT PORT_POOL::Start (void)
{
	HRESULT		Result;

	Lock();

	Result = OpenTcpDevice();

	Unlock();

	return Result;
}

HRESULT PORT_POOL::OpenTcpDevice (void)
{
    UNICODE_STRING		DeviceName;
    IO_STATUS_BLOCK		IoStatusBlock;
    OBJECT_ATTRIBUTES	ObjectAttributes;
    NTSTATUS			Status;

	if (TcpDevice)
		return S_OK;

    RtlInitUnicodeString (&DeviceName, (PCWSTR) DD_TCP_DEVICE_NAME);

	InitializeObjectAttributes (&ObjectAttributes, &DeviceName,
		OBJ_CASE_INSENSITIVE, NULL, NULL);

    Status = NtCreateFile (
		&TcpDevice,
		SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA ,
		&ObjectAttributes,
		&IoStatusBlock,
		NULL,
		FILE_ATTRIBUTE_NORMAL,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		FILE_OPEN_IF, 0, NULL, 0);

    if (Status != STATUS_SUCCESS) {
		TcpDevice = NULL;

		DebugError (Status, _T("H323: Failed to open TCP device.\n"));

		return (HRESULT) Status;
    }

    return S_OK;
}

void PORT_POOL::Stop (void)
{
	Lock();

	FreeAll();

	if (TcpDevice) {
		assert (TcpDevice != INVALID_HANDLE_VALUE);

		CloseHandle (TcpDevice);
		TcpDevice = NULL;
	}
    
	Unlock();
}

void PORT_POOL::FreeAll (void)
{
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	while (!IsListEmpty (&PortRangeList)) {
		ListEntry = RemoveHeadList (&PortRangeList);
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        // Free the port range PortRange->AllocatedLow
        UnReservePortRange (PortRange -> AllocatedLow);
        EM_FREE (PortRange);
    }
}

/*++

Routine Description:

    This function allocates a pair of RTP/RTCP ports from the 
    port pool.

Arguments:
    
    rRTPport - This is an OUT parameter. If the function succeeds
        rRTPport will contain the RTP port (which is even).
        rRTPport+1 should be used as the RTCP port.
        
Return Values:

    This function returns S_OK on success and E_FAIL if it
    fails to allocate a port range.

--*/

HRESULT PORT_POOL::AllocPort (
	OUT	WORD *	ReturnPort)
{
    DWORD i, j;
    DWORD bitmap = 0x80000000;
	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;
	WORD			Port;
	HRESULT			Result;

    Lock();

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

        for (i = 0; i < PortRange->dwAllocListSize; i++) {

            // traverse through AllocList of this portRange

            if ((PortRange->AllocList[i] & 0xffffffff) != 0xffffffff) {
				// at least one entry is free
				bitmap = 0x80000000;
            
				for (j = 0; j < NUM_DWORD_BITS; j++) {
					// traverse through each bit of the DWORD
					if ((PortRange->AllocList[i] & bitmap) == 0)
					{
						// found a free pair of ports
						Port = (WORD) (PortRange -> low + (i*NUM_DWORD_BITS*2) + (j*2));

						if (Port > PortRange -> high) {
							// This check is needed because the last DWORD
							// in the AllocList may contain bits which are
							// actually not included in the AllocList. 
							goto noports;
						}

						// set the bit to show the pair of ports is allocated
						PortRange -> AllocList[i] |= bitmap;
                    
						// Leave the global critical section for the Port pool 
						Unlock();

						DebugF (_T("H323: Allocated port pair (%04X, %04X).\n"), Port, Port + 1);

						*ReturnPort = Port;

						return S_OK;
					}

					bitmap = bitmap >> 1;
				}
            }
        }
    }
    
noports:
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // Allocate a new port range
    Result = CreatePortRange (&PortRange);

	if (PortRange) {
		InsertHeadList (&PortRangeList, &PortRange -> ListEntry);

		// allocate the first port in the range and 
		Port = PortRange -> low;
		PortRange->AllocList[0] |= 0x80000000;

		DebugF (_T("H323: Allocated port pair (%04X, %04X).\n"),
			Port, Port + 1);

		*ReturnPort = Port;
		Result = S_OK;
	}
	else {
		Debug (_T("H323: Failed to allocate port range.\n"));

		*ReturnPort = 0;
		Result = E_FAIL;
    }

	Unlock();

	return Result;

}


/*++

Routine Description:

    This function frees a pair of RTP/RTCP ports.
    The data structure is changed to show that the pair of ports
    is now available.

    CODEWORK: If an entire port range becomes free, do we release
    the port range to the operating system ? We probably need a
    heuristic to do this because allocating a port range again
    could be an expensive operation.

Arguments:
    
    wRTPport - This gives the RTP port to be freed.
        (RTCP port is RTPport+1 which is implicitly freed because
	 we use one bit store the status of both these ports.)

Return Values:

    Returns S_OK on success or E_FAIL if the port is not found in
    the port pool list.

--*/

void PORT_POOL::FreePort (
	IN	WORD	Port)
{
	HRESULT		Result;

    // assert RTP port is even
    _ASSERTE ((Port & 1) == 0);

    DWORD	Index = 0;
    DWORD	Bitmap = 0x80000000;

	LIST_ENTRY *	ListEntry;
    PORT_RANGE *	PortRange;

	Lock();

	// find the port range that this port belongs to
	// simple linear scan -- suboptimal

	Result = E_FAIL;

	for (ListEntry = PortRangeList.Flink; ListEntry != &PortRangeList; ListEntry = ListEntry -> Flink) {
		PortRange = CONTAINING_RECORD (ListEntry, PORT_RANGE, ListEntry);

		if (PortRange -> low <= Port && PortRange -> high >= Port) {
			Result = S_OK;
			break;
		}
    }
    
	if (Result == S_OK) {
		Index = (Port - PortRange -> low) / (NUM_DWORD_BITS * 2);
    
		// assert index is less than the size of the array
		_ASSERTE (Index < PortRange -> dwAllocListSize);

		// CODEWORK: make sure that the bit is set i.e. the port has
		// been previously allocated. Otherwise return an error and print
		// a warning.
    
		// zero the bit to show the pair of ports is now free

		PortRange -> AllocList [Index] &=
			~(Bitmap >> (((Port - PortRange -> low) / 2) % NUM_DWORD_BITS));
			
		DebugF (_T("H323: Deallocated port pair (%04X, %04X).\n"), Port, Port + 1);
	}
	else {
		DebugF (_T("H323: warning, attempted to free port pair (%04X, %04X), but it did not belong to any port range.\n"),
		        Port, Port + 1);
	}

	Unlock();
}

HRESULT PORT_POOL::CreatePortRange (
	OUT	PORT_RANGE **	ReturnPortRange)
{
    // CODEWORK: Once we get the new ioctl() for dynamically reserving
    // port ranges, we need to allocate a new port range here. If the
    // ioctl() fails we need to return E_FAIL or another error which
    // says we have run out of ports.

    // assert low is even and high is odd
    // _ASSERTE((low % 2) == 0);
    // _ASSERTE((high % 2) == 1);

    HRESULT			Result;
    WORD			AllocatedLowerPort;
    WORD			LowerPort;
    DWORD			NumPortsInRange;
    PORT_RANGE *	PortRange;
	DWORD			dwAllocListSize;

	assert (ReturnPortRange);
	*ReturnPortRange = NULL;

    Result = ReservePortRange (NUM_PORTS_PER_RANGE, &AllocatedLowerPort);
    if (FAILED (Result))
		return Result;

    // If the allocated lower port is odd we do not use the lower port
    // and the range we use starts with the next higher port.
    if ((AllocatedLowerPort & 1) == 1) {
		// the allocated region is ODD
		// don't use the first entry

        NumPortsInRange = NUM_PORTS_PER_RANGE - 1 - ((NUM_PORTS_PER_RANGE) & 1);
        LowerPort       = AllocatedLowerPort + 1;
    }
    else {
		// the allocated region is EVEN
		// don't use the last entry

        NumPortsInRange = NUM_PORTS_PER_RANGE;
        LowerPort       = AllocatedLowerPort;
    }

    // If NumPortsInRange is odd, we can not use the last port
    if ((NumPortsInRange & 1) == 1)
    {
        NumPortsInRange--;
    }
    
    // Each bit gives the status (free/allocated) of two consecutive
    // ports. So, each DWORD can store the status of NUM_DWORD_BITS*2
    // ports. We add (NUM_DWORD_BITS*2 - 1) to round up the number of
    // DWORDS required.
    dwAllocListSize = (NumPortsInRange + NUM_DWORD_BITS*2 - 1)
		/ (NUM_DWORD_BITS * 2);

    // allocate space for the AllocList also
    // Since we do not anticipate too many port ranges being allocated,
    // we do not require a separate heap for these structures.
	PortRange = (PORT_RANGE *) EM_MALLOC (
		sizeof (PORT_RANGE) + dwAllocListSize * sizeof (DWORD));

    if (PortRange == NULL) {
		Debug (_T("H323: Allocation failure, cannot allocate PORT_RANGE and associated bit map\n"));

		UnReservePortRange (AllocatedLowerPort);
        return E_OUTOFMEMORY;
    }

    _ASSERTE((LowerPort + NumPortsInRange - 1) <= 0xFFFF);

    PortRange -> AllocatedLow = AllocatedLowerPort;
    PortRange -> low = LowerPort;
    PortRange -> high = (WORD) (LowerPort + NumPortsInRange - 1);
    PortRange -> dwAllocListSize = dwAllocListSize;
    PortRange -> AllocList = (DWORD *) (PortRange + 1);

	DebugF (_T("H323: Allocated port block: [%04X - %04X].\n"),
		PortRange -> low,
		PortRange -> high,
		PortRange -> dwAllocListSize);
 
   // Initialize the AllocList to show all the ports are free
    ZeroMemory (PortRange -> AllocList, (PortRange -> dwAllocListSize) * sizeof (DWORD));

	*ReturnPortRange = PortRange;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\portmgmt.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    portmgmt.h

Abstract:

    Port pool management functions

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _portmgmt_h_
#define _portmgmt_h_

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public prototypes                                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

HRESULT	PortPoolStart	(void);
void	PortPoolStop	(void);

HRESULT PortPoolAllocRTPPort (
	OUT	WORD *	ReturnPort);

HRESULT PortPoolFreeRTPPort (
	IN	WORD	RtpPort);

#endif //_portmgmt_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931io.cpp ===
#include "stdafx.h"

SYNC_COUNTER          Q931SyncCounter;
ASYNC_ACCEPT          Q931AsyncAccept;
SOCKADDR_IN           Q931ListenSocketAddress;
HANDLE                Q931LoopbackRedirectHandle;

static
HRESULT
Q931AsyncAcceptFunctionInternal (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    );


void
Q931AsyncAcceptFunction (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    )
{
    HRESULT Result;

    Result = Q931AsyncAcceptFunctionInternal (
                 Context,
                 Socket,
                 LocalAddress,
                 RemoteAddress
                 );

    if (S_OK != Result) {

        if (INVALID_SOCKET != Socket) {

            closesocket (Socket);

            Socket = INVALID_SOCKET;

        }
    }
}
        

static
HRESULT
Q931AsyncAcceptFunctionInternal (
    IN  PVOID         Context,
    IN  SOCKET        Socket,
    IN  SOCKADDR_IN * LocalAddress,
    IN  SOCKADDR_IN * RemoteAddress
    )
{
    CALL_BRIDGE * CallBridge;
    HRESULT       Result;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION  RedirectInformation;
    ULONG         RedirectInformationLength;
    ULONG         Error;
    DWORD         BestInterfaceAddress;

    DebugF (_T("Q931: ----------------------------------------------------------------------\n"));

#if DBG
    ExposeTimingWindow ();
#endif

    // a new Q.931 connection has been accepted from the network.
    // first, we determine the original addresses of the transport connection.
    // if the connection was redirected to our socket (due to NAT),
    // then the query of the NAT redirect table will yield the original transport addresses.
    // if an errant client has connected to our service, well, we really didn't
    // intend for that to happen, so we just immediately close the socket.

    assert (NatHandle);

    RedirectInformationLength = sizeof (RedirectInformation);

    Result = NatLookupAndQueryInformationSessionMapping (
        NatHandle,
        IPPROTO_TCP,
        LocalAddress -> sin_addr.s_addr,
        LocalAddress -> sin_port,
        RemoteAddress -> sin_addr.s_addr,
        RemoteAddress -> sin_port,
        &RedirectInformation,
        &RedirectInformationLength,
        NatKeySessionMappingExInformation);

    if (STATUS_SUCCESS != STATUS_SUCCESS) {

        DebugError (Result, _T("Q931: New connection was accepted, but it is not in the NAT redirect table -- connection will be rejected.\n"));

        return Result;
    }

    Error = GetBestInterfaceAddress (ntohl (RedirectInformation.DestinationAddress), &BestInterfaceAddress);

    if (ERROR_SUCCESS != Error) {

        if (WSAEHOSTUNREACH == Error) {
    
            Error = RasAutoDialSharedConnection ();
    
            if (ERROR_SUCCESS != Error) {
                
                DebugF (_T("Q931: RasAutoDialSharedConnection failed. Error=%d\n"), Error);
    
            }
    
        } else {
    
            DebugError (Error, _T("LDAP: Failed to get interface address for the destination.\n"));
            
            return HRESULT_FROM_WIN32 (Error);
        }

    }
    
    // based on the source address of the socket, we decide whether the connection
    // came from an internal or external client.  this will govern later decisions
    // on how the call is routed.

#if DBG
    BOOL          IsPrivateOrLocalSource;
    BOOL          IsPublicDestination;

    Result = ::IsPrivateAddress (ntohl (RedirectInformation.SourceAddress), &IsPrivateOrLocalSource);

    if (S_OK != Result) {

        return Result;
    }

    IsPrivateOrLocalSource = IsPrivateOrLocalSource || ::NhIsLocalAddress (RedirectInformation.SourceAddress);

    Result = ::IsPublicAddress (ntohl (RedirectInformation.DestinationAddress), &IsPublicDestination);

    if (S_OK != Result) {

        return Result;

    }

    if (::NhIsLocalAddress (RedirectInformation.SourceAddress) &&
        ::NhIsLocalAddress (RedirectInformation.DestinationAddress)) {

        Debug (_T("Q931: New LOCAL connection.\n"));

    } else {

        if (IsPrivateOrLocalSource && IsPublicDestination) {

            Debug (_T("Q931: New OUTBOUND connection.\n"));

        } else {

            Debug (_T("Q931: New INBOUND connection.\n"));
        }
    }
#endif // DBG

    DebugF (_T("Q931: Connection redirected: (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
        ntohl (RedirectInformation.SourceAddress),
        ntohs (RedirectInformation.SourcePort),
        ntohl (RedirectInformation.DestinationAddress),
        ntohs (RedirectInformation.DestinationPort),
        ntohl (RedirectInformation.NewSourceAddress),
        ntohs (RedirectInformation.NewSourcePort),
        ntohl (RedirectInformation.NewDestinationAddress),
        ntohs (RedirectInformation.NewDestinationPort));

    CallBridge = new CALL_BRIDGE (&RedirectInformation);

    if (!CallBridge) {

        DebugF (_T("Q931: Failed to allocate CALL_BRIDGE.\n"));

        return E_OUTOFMEMORY;
    }

    CallBridge -> AddRef ();

    // Add the call-bridge to the list. Doing so makes an additional reference
    // to the object, which is retained until the object is destroyed by calling
    // RemoveCallBridge.

    if (CallBridgeList.InsertCallBridge (CallBridge) == S_OK) {

         // should we check the local address or the caller's address ?
         // The problem is that if someone tries to connect to the
         // external IP address from inside, they will still probably succeed

        Result = CallBridge -> Initialize (
                                    Socket,
                                    LocalAddress,
                                    RemoteAddress,
                                    &RedirectInformation
                                    );
        
        if (Result != S_OK) {

            CallBridge -> TerminateExternal ();

            DebugF (_T("Q931: 0x%x accepted new client, but failed to initialize.\n"), CallBridge);

            // Probably there was something wrong with just this
            // Init failure. Continue to accept more Q.931 connections.
        } 
    }

    CallBridge -> Release ();

    return Result;
}


HRESULT
Q931CreateBindSocket (
    void
    )
{
    HRESULT            Result;
    SOCKADDR_IN        SocketAddress;

    SocketAddress.sin_family      = AF_INET;
    SocketAddress.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
    SocketAddress.sin_port        = htons (0);  // request dynamic port

    Result = Q931AsyncAccept.StartIo (
        &SocketAddress,
        Q931AsyncAcceptFunction,
        NULL
        );

    if (Result != S_OK) {

        DebugError (Result, _T("Q931: Failed to create and bind socket.\n"));

        return Result;
    }

    DebugF (_T("Q931: Asynchronous Accept started.\n"));

    Result = Q931AsyncAccept.GetListenSocketAddress (&Q931ListenSocketAddress);

    if (Result != S_OK) {

        DebugError (Result, _T("Q931: Failed to get listen socket address.\n"));

        return Result;

    }

    return S_OK;
}

void 
Q931CloseSocket (
    void
    )
{
    ZeroMemory ((PVOID)&Q931ListenSocketAddress, sizeof (SOCKADDR_IN));

    Q931AsyncAccept.StopWait ();
    
}


HRESULT 
Q931StartLoopbackRedirect (
    void
    ) 
{
    NTSTATUS Status;

    Status = NatCreateDynamicAdapterRestrictedPortRedirect (
        NatRedirectFlagLoopback | NatRedirectFlagSendOnly,
        IPPROTO_TCP,
        htons (Q931_TSAP_IP_TCP),
        Q931ListenSocketAddress.sin_addr.s_addr,
        Q931ListenSocketAddress.sin_port,
        ::NhMapAddressToAdapter (htonl (INADDR_LOOPBACK)),
        MAX_LISTEN_BACKLOG,
        &Q931LoopbackRedirectHandle);

    if (Status != STATUS_SUCCESS) {

        Q931LoopbackRedirectHandle = NULL;

        DebugError (Status, _T("Q931: Failed to create local dynamic redirect.\n"));
        
        return (HRESULT)Status;
    }

    DebugF (_T("Q931: Connections traversing loopback interface to port %04X will be redirected to %08X:%04X.\n"),
                Q931_TSAP_IP_TCP,
                SOCKADDR_IN_PRINTF (&Q931ListenSocketAddress));

    return (HRESULT) Status;
}


void 
Q931StopLoopbackRedirect (
    void
    ) 
{
    if (Q931LoopbackRedirectHandle) {

        NatCancelDynamicRedirect (Q931LoopbackRedirectHandle);

        Q931LoopbackRedirectHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931defs.h ===
#ifndef	__iptel_q931defs_h
#define	__iptel_q931defs_h

// This module contains constants and enumerated types for values used in the Q.931 protocol.
// It does not contain any structures, definitions, or APIs relevant to any implementation.



	// Q931_PROTOCOL_DISCRIMINATOR identifies Q.931 PDUs on links that may carry
	// PDUs from more than one protocol, such as LAPD D-channel links on PRI.
#define	Q931_PROTOCOL_DISCRIMINATOR					0x08

	// the well-known Q.931 TSAP for TCP on IP is TCP port 1720
#define	Q931_TSAP_IP_TCP							1720
#define	Q931_TSAP_IP_TCP_SECURE						1300


enum	Q931_MESSAGE_TYPE
{
	// Call Establishment Message (000-----)
	Q931_MESSAGE_TYPE_ALERTING				= 0x01,
	Q931_MESSAGE_TYPE_CALL_PROCEEDING		= 0x02,
	Q931_MESSAGE_TYPE_CONNECT				= 0x07,
	Q931_MESSAGE_TYPE_CONNECT_ACKNOWLEDGE	= 0x0F,
	Q931_MESSAGE_TYPE_PROGRESS				= 0x03,
	Q931_MESSAGE_TYPE_SETUP					= 0x05,
	Q931_MESSAGE_TYPE_SETUP_ACKNOWLEDGE		= 0x0E,
	Q931_MESSAGE_TYPE_FACILITY				= 0x1C,

	// Call Information Phase message (001-----)
	Q931_MESSAGE_TYPE_RESUME				= 0x26,
	Q931_MESSAGE_TYPE_RESUME_ACKNOWLEDGE	= 0x2E,
	Q931_MESSAGE_TYPE_RESUME_REJECT			= 0x22,
	Q931_MESSAGE_TYPE_SUSPEND				= 0x25,
	Q931_MESSAGE_TYPE_SUSPEND_ACKNOWLEDGE	= 0x2D,
	Q931_MESSAGE_TYPE_SUSPEND_REJECT		= 0x21,
	Q931_MESSAGE_TYPE_USER_INFORMATION		= 0x20,

	// Call Clearing Messages (010-----)
	Q931_MESSAGE_TYPE_DISCONNECT			= 0x45,
	Q931_MESSAGE_TYPE_RELEASE				= 0x4D,
	Q931_MESSAGE_TYPE_RELEASE_COMPLETE		= 0x5A,
	Q931_MESSAGE_TYPE_RESTART				= 0x46,
	Q931_MESSAGE_TYPE_RESTART_ACKNOWLEDGE	= 0x4E,
	
	// Miscellaneous Message (011-----)
	Q931_MESSAGE_TYPE_SEGMENT				= 0x60,
	Q931_MESSAGE_TYPE_CONGESTION_CONTROL	= 0x79,
	Q931_MESSAGE_TYPE_INFORMATION			= 0x7B,
	Q931_MESSAGE_TYPE_NOTIFY				= 0x6E,
	Q931_MESSAGE_TYPE_STATUS				= 0x7D,
	Q931_MESSAGE_TYPE_STATUS_ENQUIRY		= 0x75,
};


enum	Q931_IE_IDENTIFIER
{
	// Single-Octet Information Elements
	Q931_IE_SHIFT							= 0x90,		// 1001----
	Q931_IE_RESERVED						= 0x80,		// 1000----
	Q931_IE_MORE_DATA						= 0xA0,		// 11000000
	Q931_IE_SENDING_COMPLETE				= 0xA1,		// 11000001
	Q931_IE_CONGESTION_CONTROL				= 0xB0,		// 1011----
	Q931_IE_REPEAT_INDICATOR				= 0xD0,		// 1101----

	// Variable-Length Information Elements
	Q931_IE_SEGMENTED_MESSAGE				= 0x00,
	Q931_IE_BEARER_CAPABILITY				= 0x04,
	Q931_IE_CAUSE							= 0x08,
	Q931_IE_CALL_IDENTITIY					= 0x10,
	Q931_IE_CALL_STATE						= 0x14,
	Q931_IE_CHANNEL_IDENTIFICATION			= 0x18,
	Q931_IE_PROGRESS_INDICATOR				= 0x1E,
	Q931_IE_NETWORK_SPECIFIC_FACILITIES		= 0x20,
	Q931_IE_NOTIFICATION_INDICATOR			= 0x27,
	Q931_IE_DISPLAY							= 0x28,
	Q931_IE_DATE_TIME						= 0x29,
	Q931_IE_KEYPAD_FACILITY					= 0x2A,
	Q931_IE_SIGNAL							= 0x34,
	Q931_IE_INFORMATION_RATE				= 0x40,
	Q931_IE_END_TO_END_TRANSIT_DELAY		= 0x42,
	Q931_IE_TRANSIT_DELAY_SELECTION			= 0x43,
	Q931_IE_PACKET_LAYER_BINARY_PARAMETERS	= 0x44,
	Q931_IE_PACKET_LAYER_WINDOW_SIZE		= 0x45,
	Q931_IE_PACKET_SIZE						= 0x46,
	Q931_IE_CLOSED_USER_GROUP				= 0x47,
	Q931_IE_REVERSE_CHARGE_INDICATION		= 0x4A,
	Q931_IE_CALLING_PARTY_NUMBER			= 0x6A,
	Q931_IE_CALLING_PARTY_SUBADDRESS		= 0x6B,
	Q931_IE_CALLED_PARTY_NUMBER				= 0x70,
	Q931_IE_CALLED_PARTY_SUBADDRESS			= 0x71,
	Q931_IE_REDIRECTING_NUMBER				= 0x74,
	Q931_IE_TRANSIT_NETWORK_SELECTION		= 0x78,
	Q931_IE_RESTART_INDICATOR				= 0x79,
	Q931_IE_LOW_LAYER_COMPATIBILITY			= 0x7C,
	Q931_IE_HIGH_LAYER_COMPATIBILITY		= 0x7D,
	Q931_IE_USER_TO_USER					= 0x7E,
	Q931_IE_ESCAPE_FOR_EXTENSION			= 0x7F,
};

enum	Q931_UUIE_TYPE
{
	Q931_UUIE_USER_SPECIFIC					= 0x00,
	Q931_UUIE_OSI							= 0x01,
	Q931_UUIE_X244							= 0x02,
	Q931_UUIE_IA5_TEXT						= 0x04,
	Q931_UUIE_X208							= 0x05,
	Q931_UUIE_V120_RATE_ADAPTION			= 0x07,
	Q931_UUIE_UNI_CALL_CONTROL				= 0x08,
};

#endif // __iptel_q931defs_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931msg.cpp ===
#include "stdafx.h"
#include "dynarray.h"
#include "q931msg.h"
#include "h323asn1.h"

struct	Q931_ENCODE_CONTEXT
{
	LPBYTE		Pos;			// next storage position, MAY EXCEED End!
	LPBYTE		End;			// end of storage buffer

	// if returns FALSE, then buffer is in overflow condition
	BOOL	StoreData	(
		IN	LPBYTE	Data,
		IN	DWORD	Length);

	BOOL	HasOverflowed (void) { return Pos > End; }

	// if returns FALSE, then buffer is in overflow condition, or would be
	BOOL	AllocData (
		IN	DWORD	Length,
		OUT	LPBYTE *	ReturnData);
};

BOOL Q931_ENCODE_CONTEXT::StoreData (
	IN	LPBYTE	Data,
	IN	DWORD	Length)
{
	if (Pos + Length > End) {
		Pos += Length;
		return FALSE;
	}

	memcpy (Pos, Data, Length);
	Pos += Length;

	return TRUE;
}

BOOL Q931_ENCODE_CONTEXT::AllocData (
	IN	DWORD		Length,
	OUT	LPBYTE *	ReturnData)
{
	if (Pos + Length > End) {
		Pos += Length;
		*ReturnData = NULL;
		return FALSE;
	}
	else {
		*ReturnData = Pos;
		Pos += Length;
		return TRUE;
	}
}

#if	DBG

void Q931TestDecoder (
	IN	LPBYTE		PduData,
	IN	DWORD		PduLength)
{
	Q931_MESSAGE	Message;
	HRESULT			Result;

	Q931_MESSAGE	NewMessage;
	BYTE			NewData	[0x400];
	DWORD			NewLength;

	Debug (_T("Q931TestDecoder --------------------------------------------------------------------\n"));
	DebugF (_T("- processing Q.931 PDU, length %d, contents:\n"), PduLength);
	DumpMemory (PduData, PduLength);


	Result = Message.AttachDecodePdu (PduData, PduLength, FALSE);

	if (Result != S_OK) {
		DebugError (Result, _T("- failed to decode Q.931 PDU\n"));
		return;
	}

	Debug (_T("- successfully decoded Q.931 PDU\n"));

	// now, try to re-encode the same PDU

	if (Message.MessageType == Q931_MESSAGE_TYPE_SETUP) {
		// there is an issue with decoding and re-encoding ASN.1 UUIE for Setup from TAPI
		// long, boring story

		Debug (_T("- it's a Setup PDU, will not attempt to re-encode (due to ASN.1 compatability issue)\n"));
	}
	else {
		Debug (_T("- will now attempt to re-encode\n"));

		NewLength = 0x400;
		Result = Message.EncodePdu (NewData, &NewLength);

		if (Result == S_OK) {
			DebugF (_T("- successfully re-encoded copy of Q.931 PDU, length %d, contents:\n"), NewLength);


			if (PduLength != NewLength) {
				DebugF (_T("- *** warning: original pdu length (%d) is different from re-encoded pdu length (%d), re-encoded contents:\n"),
					PduLength, NewLength);
					DumpMemory (NewData, NewLength);
			}
			else {
				if (memcmp (PduData, NewData, NewLength) != 0) {
					DebugF (_T("- *** warning: original pdu contents differ from re-encoded pdu contents, which follow:\n"));
					DumpMemory (NewData, NewLength);
				}
				else {
					DebugF (_T("- re-encoded pdu is identical to original pdu -- success!\n"));
				}
			}

			Debug (_T("- will now attempt to decode re-encoded PDU\n"));

			Result = NewMessage.AttachDecodePdu (NewData, NewLength, FALSE);

			if (Result == S_OK) {
				Debug (_T("- successfully decoded copy of Q.931 PDU\n"));
			}
			else {
				DebugError (Result, _T("- failed to decode copy of Q.931 PDU\n"));
			}
		}
		else {
			DebugError (Result, _T("- failed to re-encode Q.931 PDU\n"));
		}
	}

	Message.Detach();
	NewMessage.Detach();

	Debug (_T("\n"));
}

#endif

// Q931_MESSAGE -----------------------------------------------------------------------------

Q931_MESSAGE::Q931_MESSAGE (void)
{
	Buffer = NULL;
	BufferLength = 0;
}

Q931_MESSAGE::~Q931_MESSAGE (void)
{
	Detach();

	assert (!InfoElementArray.m_Length);
	assert (!Buffer);
}

void Q931_MESSAGE::Detach (void)
{
	FreeInfoElementArray();

	if (Buffer) {
		if (BufferIsOwner) {
			LocalFree (Buffer);
		}

		Buffer = NULL;
		BufferLength = 0;
		BufferIsOwner = FALSE;			
	}
}

HRESULT Q931_MESSAGE::Detach (
	OUT	LPBYTE *	ReturnBuffer,
	OUT	DWORD *		ReturnBufferLength)
{
	HRESULT		Result;

	assert (ReturnBuffer);
	assert (ReturnBufferLength);

	if (Buffer) {
		*ReturnBuffer = Buffer;
		*ReturnBufferLength = BufferLength;

		Result = S_OK;
	}
	else {
		Result = S_FALSE;
	}

	Detach();

	return Result;
}

void Q931_MESSAGE::FreeInfoElementArray (void)
{
	Q931_IE *	Pos;
	Q931_IE *	End;

	InfoElementArray.GetExtents (&Pos, &End);

	for (; Pos < End; Pos++) {
		FreeInfoElement (Pos);
	}

	InfoElementArray.Clear();
}

void Q931_MESSAGE::FreeInfoElement (Q931_IE * InfoElement)
{
    assert (InfoElement);

	switch (InfoElement -> Identifier) {
	case	Q931_IE_USER_TO_USER:

		assert (InfoElement -> Data.UserToUser.PduStructure);

		if (InfoElement -> Data.UserToUser.IsOwner) {

			H225FreePdu_H323_UserInformation (
				InfoElement -> Data.UserToUser.PduStructure);
		}
		break;
	}

			
}

HRESULT Q931_MESSAGE::DecodeInfoElement (
	IN	OUT	LPBYTE *	ArgPos,
	IN	LPBYTE			End,
	OUT	Q931_IE *		ReturnInfoElement)
{
	LPBYTE			Pos;
	BYTE			Identifier;
	DWORD			LengthLength;		// length of the IE length element, in bytes!
	LPBYTE			VariableData;		// payload of variable-length data
	DWORD			VariableDataLength;
	BYTE			FixedData;			// payload of fixed-length data
	HRESULT			Result;


	assert (ArgPos);
	assert (End);

	Pos = *ArgPos;

	if (Pos >= End) {
		Debug (_T("Q931_MESSAGE::DecodeInfoElement: should never have been called\n"));
		return E_INVALIDARG;
	}

	Identifier = *Pos;
	Pos++;

	// is it a single-byte IE?
	// if so, then bit 7 of the first byte = 1

	if (Identifier & 0x80) {

		// there are two types of single-byte IEs
		// Type 1 has a four-bit identifier and a four-bit value
		// Type 2 has only an identifier, and no value
		
		switch (Identifier & 0xF0) {
		case	Q931_IE_MORE_DATA:
		case	Q931_IE_SENDING_COMPLETE:
			// these IEs have an identifier, but no value

			ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) Identifier;

			DebugF (_T("Q931_MESSAGE::DecodeInfoElement: fixed-length IE, id %02XH, no value\n"),
				Identifier);

			break;

		default:
			// the other single-byte IEs have a value in the lower four bits
			ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) (Identifier & 0xF0);
			ReturnInfoElement -> Data.UnknownFixed.Value = Identifier & 0x0F;

			DebugF (_T("Q931_MESSAGE::DecodeInfoElement: fixed-length IE, id %02XH value %01XH\n"),
				ReturnInfoElement -> Identifier,
				ReturnInfoElement -> Data.UnknownFixed.Value);

			break;
		}

		// we don't currently parse any fixed-length IEs

		Result = S_OK;
	}
	else {
		// the next byte indicates the length of the info element

		// unfortunately, the number of octets that make up the length
		// depends on the identifier.
		// -XXX- is this because I don't understand the octet extension mechanism?

		ReturnInfoElement -> Identifier = (Q931_IE_IDENTIFIER) Identifier;

		switch (Identifier) {
		case	Q931_IE_USER_TO_USER:
			LengthLength = 2;
			break;

		default:
			LengthLength = 1;
			break;
		}

		if (Pos + LengthLength > End) {
			Debug (_T("Q931_MESSAGE::DecodeInfoElement: insufficient data for header of variable-length IE\n"));
			return E_INVALIDARG;
		}

		if (LengthLength == 1) {
			VariableDataLength = *Pos;
		}
		else {
			VariableDataLength = Pos [1] + (((WORD) Pos [0]) << 8);
		}
		Pos += LengthLength;

		if (Pos + VariableDataLength > End) {
			Debug (_T("Q931_MESSAGE::DecodeInfoElement: insufficient data for body of variable-length IE\n"));
			return E_INVALIDARG;
		}

		VariableData = (LPBYTE) Pos;
		Pos += VariableDataLength;

//		DebugF (_T("Q931_MESSAGE::DecodeInfoElement: variable-length IE, id %02XH length %d\n"),
//			Identifier, VariableDataLength);

		ReturnInfoElement -> Data.UnknownVariable.Data = VariableData;
		ReturnInfoElement -> Data.UnknownVariable.Length = VariableDataLength;

		Result = ParseIE (ReturnInfoElement);

		if (Result != S_OK) {
			DebugError (Result, _T("Q931_MESSAGE::DecodeInfoElement: IE was located, but failed to parse\n"));
		}
	}

	*ArgPos = Pos;

	return Result;
}

HRESULT Q931_MESSAGE::AppendInfoElement (
	IN	Q931_IE *	InfoElement)
{
	Q931_IE *	ArrayEntry;

	ArrayEntry = InfoElementArray.AllocAtEnd();

	if (ArrayEntry) {
		*ArrayEntry = *InfoElement;

		return S_OK;
	}
	else {
		Debug (_T("Q931_MESSAGE::AppendInfoElement: allocation failure\n"));

		return E_OUTOFMEMORY;
	}
}

HRESULT Q931_MESSAGE::ParseIE_UUIE (
	IN	Q931_IE *	InfoElement)
{
	LPBYTE	Data;
	DWORD	Length;
	DWORD	Status;

	// be careful to copy out all parameters from one branch of the union
	// before you start stomping on another branch
	Data = InfoElement -> Data.UnknownVariable.Data;
	Length = InfoElement -> Data.UnknownVariable.Length;

	if (Length < 1) {
		Debug (_T("Q931_MESSAGE::ParseIE_UUIE: IE payload is too short to contain UUIE\n"));
		return E_INVALIDARG;
	}

	InfoElement -> Data.UserToUser.Type = (Q931_UUIE_TYPE) *Data++;
	Length--;

	InfoElement -> Data.UserToUser.PduStructure = NULL;

	Status = H225DecodePdu_H323_UserInformation (Data, Length,
		&InfoElement -> Data.UserToUser.PduStructure);

	if (Status != ERROR_SUCCESS) {
		if (InfoElement -> Data.UserToUser.PduStructure) {
			// return value was a warning, not error

			H225FreePdu_H323_UserInformation (InfoElement -> Data.UserToUser.PduStructure);

			InfoElement -> Data.UserToUser.PduStructure = NULL;
		}


		InfoElement -> Data.UserToUser.PduStructure = NULL;
		DebugError (Status, _T("Q931_MESSAGE::ParseIE_UUIE: failed to decode UUIE / ASN.1\n"));
		return E_FAIL;
	}

	InfoElement -> Data.UserToUser.IsOwner = TRUE;

//	Debug (_T("Q931_MESSAGE::ParseIE_UUIE: successfully decoded UUIE\n"));

	return S_OK;
}

HRESULT Q931_MESSAGE::ParseIE (
	IN	Q931_IE *	InfoElement)
{
	assert (InfoElement);

	switch (InfoElement -> Identifier) {

	case	Q931_IE_USER_TO_USER:
		return ParseIE_UUIE (InfoElement);
		break;

	case	Q931_IE_CAUSE:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_CAUSE\n"));
		break;

	case	Q931_IE_DISPLAY:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_DISPAY\n"));
		break;

	case	Q931_IE_BEARER_CAPABILITY:
//		Debug (_T("Q931_MESSAGE::ParseInfoElement: Q931_IE_BEARER_CAPABILITY\n"));
		break;

	default:
		DebugF (_T("Q931_MESSAGE::ParseInfoElement: unknown IE identifier (%02XH), no interpretation will be imposed\n"),
			InfoElement -> Identifier);
		break;
	}

	return S_OK;
}

HRESULT Q931_MESSAGE::AttachDecodePdu (
	IN	LPBYTE		Data,
	IN	DWORD		Length,
	IN	BOOL		IsDataOwner)
{
	LPBYTE		Pos;
	LPBYTE		End;
	HRESULT		Result;

	Q931_IE *	ArrayEntry;

	assert (Data);

	Detach();

	if (Length < 5) {
		DebugF (_T("Q931_MESSAGE::Decode: header is too short (%d)\n"), Length);
		return E_INVALIDARG;
	}

	// octet 0 is the Protocol Discriminator

	if (Data [0] != Q931_PROTOCOL_DISCRIMINATOR) {
		DebugF (_T("Q931_MESSAGE::Decode: the pdu is not a Q.931 pdu, protocol discriminator = %02XH\n"),
			Data [0]);

		return E_INVALIDARG;
	}

	// octet 1: bits 0-3 contain the length, in octets of the Call Reference Value
	// octet 1: bits 4-7 should be zero

	if (Data [1] & 0xF0) {
		DebugF (_T("Q931_MESSAGE::Decode: the pdu has non-zero bits in octet 1: %02XH\n"),
			Data [1]);
	}

	// according to H.225, the Call Reference Value must be two octets in length

	if ((Data [1] & 0x0F) != 2) {
		DebugF (_T("Q931_MESSAGE::Decode: the call reference value size is invalid (%d), should be 2\n"),
			Data [1] & 0x0F);
		return E_INVALIDARG;
	}

	// since the Call Reference Value size is 2 octets, octets 2 and 3 are the CRV
	// octets are in network (big-endian) order.

	CallReferenceValue = (((WORD) Data [2]) << 8) | Data [3];

//	DebugF (_T("Q931_MESSAGE::Decode: crv %04XH\n"), CallReferenceValue);

	// Message Type is at octet offset 4

	if (Data [4] & 0x80) {
		DebugF (_T("Q931_MESSAGE::Decode: message type is invalid (%02XH)\n"), Data [4]);
		return E_INVALIDARG;
	}

	MessageType = (Q931_MESSAGE_TYPE) Data [4];

	// enumerate the Information Elements and extract the ones that we will use

	Pos = Data + 5;
	End = Data + Length;

	Result = S_OK;

	while (Pos < End) {
		ArrayEntry = InfoElementArray.AllocAtEnd();

		if (!ArrayEntry) {
			Result = E_OUTOFMEMORY;
			Debug (_T("Q931_MESSAGE::Decode: allocation failure\n"));
			break;
		}

		Result = DecodeInfoElement (&Pos, End, ArrayEntry);

		if (Result != S_OK) {
			DebugError (Result, _T("Q931_MESSAGE::Decode: failed to decode IE, packet may be corrupt, terminating (but not failing) decode\n"));
			Result = S_OK;

			InfoElementArray.DeleteEntry (ArrayEntry);
			break;
		}
	}

	if (Result == S_OK) {
		assert (!Buffer);

		Buffer = Data;
		BufferLength = Length;
		BufferIsOwner = IsDataOwner;
	}
	else {
		Detach();
	}

	return ERROR_SUCCESS;
}

HRESULT Q931_MESSAGE::EncodePdu (
	IN	OUT	LPBYTE			Data,
	IN	OUT	LPDWORD			Length)
{
	Q931_ENCODE_CONTEXT		Context;
	Q931_IE *		IePos;
	Q931_IE *		IeEnd;
	HRESULT			Result;
	DWORD			EncodeLength;

	assert (Data);
	assert (Length);

	Context.Pos = Data;
	Context.End = Data + *Length;

	SortInfoElementArray();

	Result = EncodeHeader (&Context);
	if (Result != S_OK)
		return Result;

	// walk IE array

	InfoElementArray.GetExtents (&IePos, &IeEnd);
	for (; IePos < IeEnd; IePos++) {
		Result = EncodeInfoElement (&Context, IePos);
		if (Result != S_OK) {
			return Result;
		}
	}

	EncodeLength = (DWORD)(Context.Pos - Data);

	if (Context.HasOverflowed()) {

		Result = HRESULT_FROM_WIN32 (ERROR_MORE_DATA);
	}
	else {

		Result = S_OK;

	}

	*Length = EncodeLength;

	return Result;
}

HRESULT Q931_MESSAGE::EncodeHeader (
	IN	Q931_ENCODE_CONTEXT *	Context)
{
	BYTE	Header	[5];

	Header [0] = Q931_PROTOCOL_DISCRIMINATOR;
	Header [1] = 2;
	Header [2] = (CallReferenceValue >> 8) & 0xFF;
	Header [3] = CallReferenceValue & 0xFF;
	Header [4] = MessageType;

	Context -> StoreData (Header, 5);

	return S_OK;
}

HRESULT Q931_MESSAGE::EncodeInfoElement (
	IN	Q931_ENCODE_CONTEXT *	Context,
	IN	Q931_IE *				InfoElement)
{
	BYTE		Header	[0x10];
	WORD		Length;
	DWORD		LengthLength;				// length of Length, in bytes
	LPBYTE		LengthInsertionPoint;
	LPBYTE		IeContents;
	DWORD		IeContentsLength;
	DWORD		ShiftCount;
	HRESULT		Result;

	if (InfoElement -> Identifier & 0x80) {
		// single-byte IE

		switch (InfoElement -> Identifier & 0xF0) {
		case	Q931_IE_MORE_DATA:
		case	Q931_IE_SENDING_COMPLETE:
			// these IEs have an identifier, but no value

			Header [0] = (BYTE) InfoElement -> Identifier;
			break;

		default:
			// these IEs have an identifier and a value, combined in a single byte
			Header [0] = (((BYTE) InfoElement -> Identifier) & 0xF0)
				| (InfoElement -> Data.UnknownFixed.Value & 0x0F);
			break;
		}

		Context -> StoreData (Header, 1);

		Result = S_OK;
	}
	else {
		// variable-length IE

		Header [0] = (BYTE) InfoElement -> Identifier;
		Context -> StoreData (Header, 1);

		// allocate data for the insertion point
		Context -> AllocData (2, &LengthInsertionPoint);

		// record the current buffer position, for use below in storing the content length
		IeContents = Context -> Pos;

		switch (InfoElement -> Identifier) {
		case	Q931_IE_USER_TO_USER:
			Result = EncodeIE_UUIE (Context, InfoElement);
			break;
			
		default:

			Context -> StoreData (
				InfoElement -> Data.UnknownVariable.Data,
				InfoElement -> Data.UnknownVariable.Length);

			if (InfoElement -> Data.UnknownVariable.Length >= 0x10000) {
				DebugF (_T("Q931_MESSAGE::EncodeInfoElement: payload is waaaaay too big (%d %08XH)\n"),
					InfoElement -> Data.UnknownVariable.Length,
					InfoElement -> Data.UnknownVariable.Length);

				Result = E_INVALIDARG;
			}
			else {
				Result = S_OK;
			}

			break;
		}

		if (Result == S_OK) {

			IeContentsLength = (DWORD)(Context -> Pos - IeContents);

			// this is such a hack
			// with little or no justification for when LengthLength = 1 and when LengthLength = 2
			// the octet group extension mechanism is poorly defined in Q.931

			if (InfoElement -> Identifier == Q931_IE_USER_TO_USER)
				LengthLength = 2;
			else
				LengthLength = 1;

			// if the storage context has not overflowed,
			// and if it is necessary to resize the Length parameter (we guessed pessimistically
			// that it would be 2), then move the buffer down one byte

			ShiftCount = 2 - LengthLength;

			if (ShiftCount > 0) {
				if (!Context -> HasOverflowed()) {
					memmove (
						LengthInsertionPoint + LengthLength,	// destination, where IE contents should be
						IeContents,				// source, where IE contents were actually stored
						IeContentsLength);		// length of the contents
				}

				// pull back the storage context's position pointer
				Context -> Pos -= ShiftCount;
			}

			// now store the actual count

			switch (LengthLength) {
			case	1:
				assert (IeContentsLength < 0x100);
				LengthInsertionPoint [0] = (BYTE) IeContentsLength;
				break;

			case	2:
				assert (IeContentsLength < 0x10000);
				LengthInsertionPoint [0] = (BYTE) (IeContentsLength >> 8);
				LengthInsertionPoint [1] = (BYTE) (IeContentsLength & 0xFF);
				break;

			default:
				assert (FALSE);
			}

		}

	}

	return Result;
}

HRESULT	Q931_MESSAGE::EncodeIE_UUIE (
	IN	Q931_ENCODE_CONTEXT *	Context,
	IN	Q931_IE *		InfoElement)
{
	DWORD	Status;
	LPBYTE	Buffer;
	DWORD	Length;
	BYTE	ProtocolDiscriminator;

	assert (Context);
	assert (InfoElement);
	assert (InfoElement -> Data.UserToUser.PduStructure);


	// store the UUIE protocol discriminator
	ProtocolDiscriminator = InfoElement -> Data.UserToUser.Type;
	Context -> StoreData (&ProtocolDiscriminator, 1);



	Buffer = NULL;
	Length = 0;

	Status = H225EncodePdu_H323_UserInformation (
		InfoElement -> Data.UserToUser.PduStructure,
		&Buffer, &Length);

	if (Status == ERROR_SUCCESS) {

		Context -> StoreData (Buffer, Length);
		H225FreeBuffer (Buffer);

		return S_OK;
	}
	else {
		// Status is not a real Win32 error code
		// it is an ASN.1 enum (
#if	DBG
		// we pull this in so source debuggers can show actual symbolic enum name
		tagASN1error_e	AsnError = (tagASN1error_e) Status;

		DebugF (_T("Q931_MESSAGE::EncodeIE_UUIE: failed to encode ASN.1 structure (%d)\n"),
			AsnError);

#endif

		// -XXX- one day, i'm going to convince Lon to use real Win32 error codes for ASN.1 return values
		// -XXX- on that day, the return value should reflect the actual ASN.1 error code

		return DIGSIG_E_ENCODE;
	}
}

void Q931_MESSAGE::SortInfoElementArray (void)
{
	InfoElementArray.QuickSort (CompareInfoElement);
}

// static
INT __cdecl Q931_MESSAGE::CompareInfoElement (
	const Q931_IE *		ComparandA,
	const Q931_IE *		ComparandB)
{
	if (ComparandA -> Identifier < ComparandB -> Identifier) return -1;
	if (ComparandA -> Identifier > ComparandB -> Identifier) return 1;

	return 0;
}

HRESULT Q931_MESSAGE::FindInfoElement (
	IN	Q931_IE_IDENTIFIER	Identifier,
	OUT	Q931_IE **			ReturnInfoElement)
{
	DWORD	Index;

	assert (ReturnInfoElement);

	if (InfoElementArray.BinarySearch ((SEARCH_FUNC_Q931_IE)InfoElementSearchFunc, &Identifier, &Index)) {
		*ReturnInfoElement = InfoElementArray.m_Array + Index;
		return S_OK;
	}
	else {
		*ReturnInfoElement = NULL;
		return E_FAIL;
	}
}


// static
INT Q931_MESSAGE::InfoElementSearchFunc (
	IN	const Q931_IE_IDENTIFIER *	SearchKey,
	IN	const Q931_IE *		Comparand)
{
	Q931_IE_IDENTIFIER	Identifier;

	assert (SearchKey);
	assert (Comparand);

	Identifier = * (Q931_IE_IDENTIFIER *) SearchKey;

	if (Identifier < Comparand -> Identifier) return -1;
	if (Identifier > Comparand -> Identifier) return 1;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931info.h ===
#ifndef __pxsvc_q931_h
#define __pxsvc_q931_h

#include "q931msg.h"
#include "ovioctx.h"
#include "crv.h"

/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: q931.h

Purpose: 

    Contains declarations specific to q931 processing that need
    not be present in cbridge.h.

History:

    1. created 
        Byrisetty Rajeev (rajeevb)  26-Aug-1998

---------------------------------------------------*/

// The H.225 spec calls for a 2 byte call reference value
typedef WORD    CALL_REF_TYPE;

// Q931 source side states
enum Q931_SOURCE_STATE
{
    Q931_SOURCE_STATE_NOT_INIT = 0,
    Q931_SOURCE_STATE_INIT,
    Q931_SOURCE_STATE_CON_ESTD,
    Q931_SOURCE_STATE_SETUP_RCVD,
    Q931_SOURCE_STATE_REL_COMP_RCVD
};

// Q931 destination side states
enum Q931_DEST_STATE
{
    Q931_DEST_STATE_NOT_INIT = 0,
    Q931_DEST_STATE_INIT,
    Q931_DEST_STATE_CON_ESTD,
    Q931_DEST_STATE_CALL_PROC_RCVD,
    Q931_DEST_STATE_ALERTING_RCVD,
    Q931_DEST_STATE_CONNECT_RCVD,
    Q931_DEST_STATE_REL_COMP_RCVD
};

#ifdef DBG
// CODEWORK: Define a static array of strings to use in dbg printfs
// where the array can be indexed by the state.

#endif DBG

// Q931_INFO


class Q931_INFO :
    public OVERLAPPED_PROCESSOR,
    public TIMER_PROCESSOR
{
public:

    inline Q931_INFO();

    inline void Init(
        IN H323_STATE   &H323State
        );

    inline CALL_REF_TYPE GetCallRefVal();

    virtual HRESULT SendCallback(
        IN      HRESULT                 CallbackHResult
        );

    virtual HRESULT ReceiveCallback(
        IN      HRESULT                 CallbackHResult,
        IN      BYTE                   *pBuf,
        IN      DWORD                   BufLen
        );

    // Implementation is provided by SOURCE_Q931_INFO and DEST_Q931_INFO
    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        ) = 0;
    
    HRESULT CreateTimer(DWORD TimeoutValue);
    
    virtual void TimerCallback();

    HRESULT SendReleaseCompletePdu();

    HRESULT QueueSend(
        IN  Q931_MESSAGE         *pQ931Message,
        IN  H323_UserInformation  *pH323UserInfo
        );
    
    // queue an asynchronous receive call back
    HRESULT QueueReceive();

	void IncrementLifetimeCounter  (void);
	void DecrementLifetimeCounter (void);

protected:

    // call reference value for this call (Q931 portion)
    // A Call Reference Value is generated for each outbound call.
    // The CRV in PDUs corresponding to outbound calls needs to be
    // replaced because the external H.323 endpoint sees the call
    // as coming from the proxy. No CRV replacement is required for inbound
    // calls. But we need to store the CRV so that we can send the
    // CallProceeding/ReleaseComplete PDUs.
    // This variable is initialized when we process the Setup PDU.
    // Note that the Call Reference Value also includes the Call Reference Flag
    // which indicates whether the PDU is sent by the originator (0) or
    // destination (1) of the call.
    // m_CallRefVal always stores the Call Reference Value that we send in
    // the PDUs. So, SOURCE_Q931_INFO CRV will have the CRV flag set (since
    // it sends to the source) and the DEST_Q931_INFO CRV will have this flag
    // zeroed (since it is the source from the destination's point of view.
    CALL_REF_TYPE       m_CallRefVal;
};

inline 
Q931_INFO::Q931_INFO(
    )
    : m_CallRefVal(0)
{
}

inline void
Q931_INFO::Init(
    IN H323_STATE   &H323State
    )
{
    // initialize the overlaped processor
    OVERLAPPED_PROCESSOR::Init(OPT_Q931, H323State);
}


class SOURCE_Q931_INFO :
    public Q931_INFO
{
public:

    inline SOURCE_Q931_INFO();

    inline void Init(
        IN SOURCE_H323_STATE   &SourceH323State
        );

    inline HRESULT SetIncomingSocket(
        IN	SOCKET			IncomingSocket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    inline DEST_Q931_INFO &GetDestQ931Info();

    inline SOURCE_H245_INFO &GetSourceH245Info();

    // TimerValue contains the timer value in seconds, for a timer event
    // to be created when a queued send completes
    HRESULT ProcessDestPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    virtual ~SOURCE_Q931_INFO();

protected:

    Q931_SOURCE_STATE  m_Q931SourceState;

	// this should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback(
        IN      Q931_MESSAGE            *pQ931Message,
        IN      H323_UserInformation    *pH323UserInfo
        );

private:
    
    // processes PDUs when in Q931_SRC_CON_EST state
    HRESULT HandleStateSrcConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // destination q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    // processes CONNECT PDU forwarded by the dest instance
    HRESULT ProcessConnectPDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );
};


inline 
SOURCE_Q931_INFO::SOURCE_Q931_INFO(
    )
    : m_Q931SourceState(Q931_SOURCE_STATE_NOT_INIT)
{
}

inline void
SOURCE_Q931_INFO::Init(
    IN SOURCE_H323_STATE   &SourceH323State
    )
{
    m_Q931SourceState = Q931_SOURCE_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)SourceH323State);
}


class DEST_Q931_INFO :
    public Q931_INFO
{
public:

    inline DEST_Q931_INFO();

    inline HRESULT Init(
        IN DEST_H323_STATE   &DestH323State
        );

    inline SOURCE_Q931_INFO &GetSourceQ931Info();

    inline DEST_H245_INFO &GetDestH245Info();

    // processes PDUs received from the source Q931 instance
    // and directs them to the method for processing the
    // specific PDU
    HRESULT ProcessSourcePDU(
        IN  Q931_MESSAGE             *pQ931Message,
        IN  H323_UserInformation     *pH323UserInfo
        );

    virtual ~DEST_Q931_INFO();

protected:

    // state for the dest instance
    Q931_DEST_STATE  m_Q931DestState;

	// this method should never be called
    virtual HRESULT AcceptCallback(
        IN	DWORD			Status,
        IN	SOCKET			Socket,
		IN	SOCKADDR_IN *	LocalAddress,
		IN	SOCKADDR_IN *	RemoteAddress);

    virtual HRESULT ReceiveCallback (
        IN      Q931_MESSAGE             *pQ931Message,
        IN      H323_UserInformation     *pH323UserInfo
        );

private:

    // the following methods handle PDUs when the instance
    // is in a certain Q931 state

    HRESULT HandleStateDestConEstd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestCallProcRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestAlertingRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleStateDestConnectRcvd(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );
        
    // the following methods handle a specific PDU for
    // any state of the Q931 instance. These are typically
    // called after the PDU has gone through one of the
    // HandleState* methods

    HRESULT HandleCallProceedingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleAlertingPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    HRESULT HandleConnectPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // handles the release complete PDU - sends it to the
    // source q931 instance, performs state transition and
    // initiates cleanup
    HRESULT HandleReleaseCompletePDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // the following methods process PDUs received from
    // the source Q931 instance

    // processes source Q.931 instance setup PDU
    HRESULT ProcessSourceSetupPDU(
        IN  Q931_MESSAGE            *pQ931Message,
        IN  H323_UserInformation    *pH323UserInfo
        );

    // other helper methods
    
    HRESULT ConnectToH323Endpoint(
		IN	SOCKADDR_IN *	DestinationAddress);

	HRESULT LookupDefaultDestination (
		OUT	DWORD *	ReturnAddress); // host order

	// if necessary, bring up the demand-dial interface
	HRESULT	ConnectDemandDialInterface	(void);

};


inline 
DEST_Q931_INFO::DEST_Q931_INFO(
    )
    : m_Q931DestState(Q931_DEST_STATE_NOT_INIT)
{   
}

inline HRESULT
DEST_Q931_INFO::Init(
    IN DEST_H323_STATE   &DestH323State
    )
{
    m_Q931DestState = Q931_DEST_STATE_INIT;
    Q931_INFO::Init((H323_STATE &)DestH323State);

    return S_OK;
}

void
Q931AsyncAcceptFunction (
    IN	PVOID	Context,
    IN	SOCKET	Socket,
    IN	SOCKADDR_IN *	LocalAddress,
    IN	SOCKADDR_IN *	RemoteAddress); 

HRESULT
Q931CreateBindSocket (
    void);

void Q931CloseSocket (
    void);

HRESULT Q931StartLoopbackRedirect (
    void);

void Q931StopLoopbackRedirect (
    void); 
 
extern SYNC_COUNTER	         Q931SyncCounter;
extern ASYNC_ACCEPT	         Q931AsyncAccept;
extern SOCKADDR_IN           Q931ListenSocketAddress;
extern HANDLE			     Q931LoopbackRedirectHandle;

#endif // __pxsvc_q931_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\q931msg.h ===
#ifndef	__iptel_q931msg_h
#define	__iptel_q931msg_h

// To use the Q931_MESSAGE class:
//
// To decode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Call the AssignDecodePdu method, supplying the buffer and length of the PDU data.
//			If the AssignDecodePdu succeeds, then the buffer is now "bound" to the
//			Q931_MESSAGE instance.  You may then examine the elements of Q931_MESSAGE:
//
//				MessageType - The type of Q.931 PDU received (Setup, etc.)
//				CallReferenceValue
//				InfoElementArray - An ordered array of IEs that were in the PDU
//				UserInformation - If an ASN.1 UUIE was present, this field will be non-NULL
//
//			You may also use the FindInfoElement method to locate a specific IE (cause code, etc.)
//
//		When you are done using the contents of the Q931_MESSAGE instance, you must call the
//		FreeAll method.  This destroys the association between the buffer and the Q931_MESSAGE class.
//		This step MUST be performed before destroying the instance of the Q931_MESSAGE class.
//
//
// To encode Q.931 PDUs:
//
//		Create an instance of the Q931_MESSAGE class.
//		Set the MessageType and CallReferenceValue fields.
//		For each IE that should be encoded, call AppendInfoElement.
//		(This includes the UUIE.)
//		Call EncodePdu.  The buffer on return contains the fully encoded PDU.
//
//		If the buffer supplied to EncodePdu is not long enough, then the ReturnLength
//		parameter will contain the required length, and the method will return
//		HRESULT_FROM_WIN32 (ERROR_MORE_DATA).
//
// When calling InsertInfoElement, you must insure that the buffer supplied in the
// Q931_IE structure is still valid when the EncodePdu call is made.  All IE buffers
// should remain valid until the Q931_MESSAGE::FreeAll method is called.



#include "q931defs.h"
#include "dynarray.h"

struct	H323_UserInformation;

struct	Q931_ENCODE_CONTEXT;

struct	Q931_BEARER_CAPABILITY
{
};

// Q931_IE_DATA contains the decoded contents of those information elements whose
// interpretation is known and implemented in this module.
// Not all IEs are supported.

union	Q931_IE_DATA
{
	// Q931_IE_USER_TO_USER
	struct	{
		Q931_UUIE_TYPE			Type;
		H323_UserInformation *	PduStructure;
		BOOL					IsOwner;		// if true, delete PduStructure on deletion
	}	UserToUser;

	// Q931_IE_CAUSE
	DWORD	CauseCode;

	// Q931_BEARER_CAPABILITY
	Q931_BEARER_CAPABILITY	BearerCapability;

	// Q931_DISPLAY
	struct	{
		LPSTR		String;
	}	Display;

	// IEs that are not implemented here, and are of variable length
	struct	{
		LPBYTE	Data;
		DWORD	Length;
	}	UnknownVariable;

	// IEs that are not implemented here, and are of fixed length
	struct	{
		BYTE	Value;
	}	UnknownFixed;
};

struct	Q931_IE
{
	Q931_IE_IDENTIFIER		Identifier;
	Q931_IE_DATA			Data;
};

// it is the responsibility of the user of this object to synchronize access
// and object lifetime.
//
// The Decode method builds the InfoElementArray.  Elements in this array
// may refer to the original buffer passed to Encode.  Therefore, users of
// Q931_MESSAGE::Decode must insure that the original buffer remains accessible
// and does not change, until the user no longer requires the use of this Q931_MESSAGE
// object, or calls Q931_MESSAGE::FreeAll.

struct	Q931_MESSAGE
{
public:

	Q931_MESSAGE_TYPE				MessageType;
	WORD							CallReferenceValue;
	DYNAMIC_ARRAY <Q931_IE>			InfoElementArray;

	LPBYTE							Buffer;
	DWORD							BufferLength;
	BOOL							BufferIsOwner;

private:

	HRESULT	DecodeInfoElement (
		IN OUT	LPBYTE *	Pos,
		IN		LPBYTE		End,
		OUT		Q931_IE *	ReturnInfoElement);

	void	FreeInfoElementArray	(void);

	// ParseInfoElement examines the contents of an IE that has already been decoded
	// (type and length determined), and for known IE types, decodes their contents
	// and assigns to data structures

	HRESULT	ParseIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	ParseIE_UUIE (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeIE_UUIE (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *		InfoElement);

	// for those IEs that have attached allocated data, free it

	void	FreeInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	EncodeHeader (
		IN	Q931_ENCODE_CONTEXT *	Context);

	HRESULT	EncodeInfoElement (
		IN	Q931_ENCODE_CONTEXT *	Context,
		IN	Q931_IE *				InfoElement);

	static INT __cdecl CompareInfoElement (const Q931_IE *, const Q931_IE *);

	static INT InfoElementSearchFunc (
		IN	const Q931_IE_IDENTIFIER *	SearchKey,
		IN	const Q931_IE *		Comparand);

public:

	// initializes array and UserInformation
	Q931_MESSAGE	(void);

	// will free the UserInformation field if present
	~Q931_MESSAGE	(void);


	HRESULT	EncodePdu	(
		IN	OUT	LPBYTE		Data,
		IN	OUT	LPDWORD		Length);

	HRESULT	AttachDecodePdu	(
		IN	LPBYTE		Data,
		IN	DWORD		Length,
		IN	BOOL		IsDataOwner);		// if TRUE, Q931_MESSAGE will free on dtor

	void	FreeAll	(void);

	// if Q931_MESSAGE currently has a Buffer, and it owns the Buffer,
	// then it will free it here, using GkHeapFree
	void	Detach	(void);

	// if Q931_MESSAGE currently has a Buffer, regardless of whether it owns the buffer,
	// then it will be returned here
	// returns S_OK if a buffer was returned
	// returns S_FALSE if no buffer was returned, and ReturnBuffer set to null
	HRESULT	Detach	(
		OUT	LPBYTE *	ReturnBuffer,
		OUT	DWORD *		ReturnBufferLength);

	void	SetUserInformation	(
		IN	H323_UserInformation *,
		IN	BOOL	FreeOnDelete);

	// information element manipulation

	HRESULT	AppendInfoElement (
		IN	Q931_IE *		InfoElement);

	HRESULT	DeleteInfoElement (
		IN	Q931_IE_IDENTIFIER	Identifier);

	HRESULT	FindInfoElement	(
		IN	Q931_IE_IDENTIFIER		Identifier,
		OUT	Q931_IE **				ReturnInfoElement);

	void	SortInfoElementArray	(void);

};

DECLARE_SEARCH_FUNC_CAST(Q931_IE_IDENTIFIER, Q931_IE);

#if	DBG

	// in debug builds, this function will take a Q.931 PDU buffer,
	// decode it, re-encode it, verify that the contents match,
	// and attempt to decode the re-encoded PDU.
	// this is good for verifying the integrity of the Q931_MESSAGE class.
void Q931TestDecoder (
	IN	LPBYTE		PduData,
	IN	DWORD		PduLength);

#else

#define	Q931TestDecoder(x,y)		0

#endif


#endif // __iptel_q931msg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\srcq931.cpp ===
#include "stdafx.h"
#include "cbridge.h"

// SOURCE_Q931_INFO methods

/* virtual */
SOURCE_Q931_INFO::~SOURCE_Q931_INFO(
    )
{
}


// this should never get called, but needs to be supported
// as the base class implementation is pure virtual
// virtual
HRESULT SOURCE_Q931_INFO::AcceptCallback (
    IN	DWORD			Status,
    IN	SOCKET			Socket,
	IN	SOCKADDR_IN *	LocalAddress,
	IN	SOCKADDR_IN *	RemoteAddress)
{
    // we should never receive an accept call back for the 
    // Q931 source instance
    _ASSERTE(FALSE);

    return E_UNEXPECTED;
}


// This function is called by the event manager.
// The caller will free the PDU. This function may modify
// some of the fields of the PDU.

// this is called when an async receive operation completes
// virtual
HRESULT SOURCE_Q931_INFO::ReceiveCallback (
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo
    )
{
    HRESULT HResult;
    
    // we must have valid decoded PDUs 
    _ASSERTE(NULL != pQ931Message);

    // The ASN.1 part is not present in the case of some PDUs
    //_ASSERTE(NULL != pH323UserInfo);

    // if RELEASE COMPLETE PDU
    if (pH323UserInfo != NULL &&
        releaseComplete_chosen ==
            pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
    {
        DebugF (_T("Q931: 0x%x caller sent 'Release Complete'.\n"), &GetCallBridge ());
        HResult = HandleReleaseCompletePDU(
                    pQ931Message,
                    pH323UserInfo
                    );

		return HResult;
    }

    // check current state and handle the incoming PDU
    switch(m_Q931SourceState)
    {
    case Q931_SOURCE_STATE_CON_ESTD:
        {
            // processes PDUs when in Q931_SOURCE_STATE_CON_ESTD state
            HResult = HandleStateSrcConEstd(
                        pQ931Message,
                        pH323UserInfo
                        );
        }
        break;

    case Q931_SOURCE_STATE_SETUP_RCVD:
        {
            // Pass on the PDU to the Q931 destination instance which
            // passes it on after due modifications
            HResult = GetDestQ931Info().ProcessSourcePDU(
                        pQ931Message,
                        pH323UserInfo
                        );
        }
        break;

    case Q931_SOURCE_STATE_INIT:
    case Q931_SOURCE_STATE_REL_COMP_RCVD:
    default:
        {
            // we can't be in Q931_SOURCE_STATE_INIT as we wouldn't have
            // queued an async receive by then

            // we can't be in Q931_SOURCE_STATE_REL_COMP_RCVD as we not have
            // queued this receive

          // I.K. 0819999  _ASSERTE(FALSE);
            HResult = E_UNEXPECTED;
        }
        break;
    };

    // if there is an error
    if (FAILED(HResult))
    {
        goto shutdown;
    }

    // we must queue an async receive irrespective of whether
    // the PDU was dropped (IPTEL_E_INVALID_PDU == HResult)
    // queue an async receive
    HResult = QueueReceive();
    if (FAILED(HResult))
    {
        goto shutdown;
    }

    return HResult;

shutdown:

    // initiate shutdown
    GetCallBridge().Terminate ();

    return HResult;
}


// handles RELEASE_COMPLETE PDUs
HRESULT 
SOURCE_Q931_INFO::HandleReleaseCompletePDU(
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo 
    )
{
    // it must be a release complete PDU
    _ASSERTE(releaseComplete_chosen == \
                pH323UserInfo->h323_uu_pdu.h323_message_body.choice);

    // we can handle a RELEASE COMPLETE PDU in any state except the following
    _ASSERTE(Q931_SOURCE_STATE_INIT             != m_Q931SourceState);
    _ASSERTE(Q931_SOURCE_STATE_REL_COMP_RCVD    != m_Q931SourceState);

    // pass on the pdu to the Q931 source instance
    // ignore return error code, if any
    GetDestQ931Info().ProcessSourcePDU(
        pQ931Message,
        pH323UserInfo
        );

    // state transition to Q931_SOURCE_STATE_REL_COMP_RCVD
    m_Q931SourceState = Q931_SOURCE_STATE_REL_COMP_RCVD;

    // initiate shutdown - this cancels the timers, but doesn't close
	// the sockets. the sockets are closed when the send callback is made
    GetCallBridge().TerminateCallOnReleaseComplete();

	GetSocketInfo ().Clear (TRUE);

    return S_OK;
}


// processes PDUs when in Q931_SOURCE_STATE_CON_EST state
HRESULT
SOURCE_Q931_INFO::HandleStateSrcConEstd(
    IN      Q931_MESSAGE            *pQ931Message,
    IN      H323_UserInformation    *pH323UserInfo 
    )
{
	if (!pH323UserInfo) {
		DebugF(_T("SOURCE_Q931_INFO::HandleStateSrcConEstd: no UUIE data!  ignoring message.\n"));
		return E_INVALIDARG;
	}

    // we can only handle a setup PDU in this state
    // all other PDUs are THROWN AWAY (as we don't know 
    // whom to pass it to)

    if (setup_chosen != pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
    {
		DebugF(
			_T("SOURCE_Q931_INFO::HandleStateSrcConEstd: received a pdu other than Setup before receiving a Setup, pdu cannot be processed\n"));
        return E_INVALIDARG;
    }

	// save the caller's call reference value now as we may reuse the
	// PDU structure in ProcessSourcePDU
    // The Setup PDU is sent by the originator and so the call reference flag
    // should not be set.
	// -XXX- this should not be an assert!!!! FIX THIS! -- arlied
    _ASSERTE(!(pQ931Message->CallReferenceValue & CALL_REF_FLAG));
	m_CallRefVal = pQ931Message->CallReferenceValue | CALL_REF_FLAG;

    // pass on the setup pdu to the Q931 destination instance
    HRESULT HResult = GetDestQ931Info().ProcessSourcePDU(
                        pQ931Message,
                        pH323UserInfo
                        );

    if (FAILED (HResult))
    {
        return HResult;
    }
    
    // state transition to Q931_SOURCE_STATE_SETUP_RCVD
    m_Q931SourceState = Q931_SOURCE_STATE_SETUP_RCVD;


	// try to create a CALL PROCEEDING PDU
	// if we fail, don't try to recover
	// Q.931 requires that gateways in the call path must identify 
	// themselves to the callee
	Q931_MESSAGE CallProcQ931Message;
	H323_UserInformation CallProcH323UserInfo;
	HResult = Q931EncodeCallProceedingMessage(
					m_CallRefVal,
				    &CallProcQ931Message,
				    &CallProcH323UserInfo
					);

	// try to send a CALL PROCEEDING PDU to the caller
	// if we fail, don't try to recover

    HResult = QueueSend(
				&CallProcQ931Message, 
				&CallProcH323UserInfo);

    return HResult;
}


// TimerValue contains the timer value in seconds, for a timer event
// to be created when a queued send completes
HRESULT 
SOURCE_Q931_INFO::ProcessDestPDU(
    IN      Q931_MESSAGE            *pQ931Message,
    IN      H323_UserInformation    *pH323UserInfo
    )
{
    HRESULT HResult = E_FAIL;

    // handle PDU from the source Q931 instance
    switch(m_Q931SourceState)
    {
    case Q931_SOURCE_STATE_SETUP_RCVD:
        {
			if (connect_chosen == 
				pH323UserInfo->h323_uu_pdu.h323_message_body.choice)
			{
                DebugF (_T("Q931: 0x%x forwarding 'Connect' to caller.\n"), &GetCallBridge ());
				HResult = ProcessConnectPDU(
							pQ931Message, 
							pH323UserInfo
							);
                if (FAILED(HResult))
                {
	                DebugF(_T("SOURCE_Q931_INFO::ProcessDestPDU: ProcessConnectPDU failed, returning %x\n"),
                        HResult);
                    return HResult;
                }
			}
        }
        break;

    case Q931_SOURCE_STATE_INIT:
    case Q931_SOURCE_STATE_CON_ESTD:
    case Q931_SOURCE_STATE_REL_COMP_RCVD:
    default:
        {
			DebugF( _T("SOURCE_Q931_INFO::ProcessDestPDU: bogus state, returning E_UNEXPECTED\n"));
            return E_UNEXPECTED;
        }
        break;
    };

	// Q931 Header - CallReferenceValue
	// pQ931Message->CallReferenceValue = GetCallRefVal();

    // queue async send for the PDU
    HResult = QueueSend(pQ931Message, pH323UserInfo);
    if (HResult != S_OK) {
	    DebugF( _T("SOURCE_Q931_INFO::ProcessDestPDU: failed to queue sendreturning %x\n"), HResult);
		return HResult;
    }
   
    return HResult;
}


// NOTE: CRV modification is handled in ProcessDestPDU
HRESULT 
SOURCE_Q931_INFO::ProcessConnectPDU(
    IN      Q931_MESSAGE             *pQ931Message,
    IN      H323_UserInformation     *pH323UserInfo 
    )
{
	Connect_UUIE *	Connect;
	HRESULT			Result;
	SOCKADDR_IN		H245ListenAddress;

	// it must be a CONNECT PDU
	_ASSERTE(connect_chosen == pH323UserInfo->h323_uu_pdu.h323_message_body.choice);

	Connect = &pH323UserInfo -> h323_uu_pdu.h323_message_body.u.connect;

	// we must have already checked to see if an h245 transport
	// address was specified by the callee in the dest instance
	_ASSERTE(Connect_UUIE_h245Address_present & Connect -> bit_mask);
	_ASSERTE(ipAddress_chosen & Connect -> h245Address.choice);

	// queue an overlapped accept, get ready to accept an incoming
	// connection on the local address/port

    H245ListenAddress.sin_addr.s_addr = htonl (GetCallBridge (). GetSourceInterfaceAddress ());
    H245ListenAddress.sin_port = htons (0);

	Result = GetSourceH245Info().ListenForCaller (&H245ListenAddress);
	if (FAILED (Result))
	{
		DebugF (_T("H245: 0x%x failed to listen for caller.\n"), &GetCallBridge ());

		return Result;
	}
    //_ASSERTE(S_FALSE != HResult);

	// replace the h245 address/port in the connect PDU
	FillTransportAddress (H245ListenAddress, Connect -> h245Address);

    DebugF (_T("H245: 0x%x listens for H.245 connection from caller on %08X:%04X.\n"),
                &GetCallBridge (),
                SOCKADDR_IN_PRINTF (&H245ListenAddress));
            
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\sockinfo.cpp ===
#include "stdafx.h"
#include "sockinfo.h"

SOCKET_INFO::SOCKET_INFO (void)
	: Socket (INVALID_SOCKET)
{
	ZeroMemory (&LocalAddress,  sizeof (SOCKADDR_IN));
	ZeroMemory (&RemoteAddress, sizeof (SOCKADDR_IN));
	ZeroMemory (&TrivialRedirectDestAddress, sizeof (SOCKADDR_IN));
   	ZeroMemory (&TrivialRedirectSourceAddress,  sizeof (SOCKADDR_IN));

    IsNatRedirectActive = FALSE;
}

void 
SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgLocalAddress,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
    assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);
	assert (ArgLocalAddress);
	assert (ArgRemoteAddress);

	Socket = ArgSocket;
	LocalAddress = *ArgLocalAddress;
	RemoteAddress = *ArgRemoteAddress;
}


int SOCKET_INFO::Init (
	IN	SOCKET			ArgSocket,
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
	INT		AddressLength;

	assert (Socket == INVALID_SOCKET);
	assert (ArgSocket != INVALID_SOCKET);

	AddressLength = sizeof (SOCKADDR_IN);

	if (getsockname (ArgSocket, (SOCKADDR *) &LocalAddress, &AddressLength)) {
		return WSAGetLastError();
	}

	Socket = ArgSocket;
	RemoteAddress = *ArgRemoteAddress;

    return ERROR_SUCCESS;
}

BOOLEAN
SOCKET_INFO::IsSocketValid (void) {
	return Socket != INVALID_SOCKET;
}

void
SOCKET_INFO::SetListenInfo (
	IN	SOCKET			ListenSocket,
	IN	SOCKADDR_IN *	ListenAddress)
{
	assert (Socket == INVALID_SOCKET);
	assert (ListenSocket != INVALID_SOCKET);
	assert (ListenAddress);

	Socket = ListenSocket;
	LocalAddress = *ListenAddress;
}

int
SOCKET_INFO::Connect(
	IN	SOCKADDR_IN *	ArgRemoteAddress)
{
	int Status;
    DWORD LocalToRemoteInterfaceAddress;

	INT   AddressSize = sizeof (SOCKADDR_IN);
    BOOL  KeepaliveOption;

	assert (Socket == INVALID_SOCKET);
	assert (ArgRemoteAddress);

    Status = GetBestInterfaceAddress (
            ntohl (ArgRemoteAddress -> sin_addr.s_addr), 
            &LocalToRemoteInterfaceAddress);

    if (ERROR_SUCCESS != Status) {
        DebugF (_T("Q931: Failed to get best interface for the destination %08X:%04X.\n"), 
                SOCKADDR_IN_PRINTF (ArgRemoteAddress));

        return Status;
    }

    LocalAddress.sin_family      = AF_INET;
    LocalAddress.sin_addr.s_addr = htonl (LocalToRemoteInterfaceAddress);
    LocalAddress.sin_port        = htons (0); 

    Socket = WSASocket (AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

    if (Socket == INVALID_SOCKET) {

        Status = WSAGetLastError ();

		DebugF( _T("Q931: Destination %08X:%04X, failed to create socket"),
            SOCKADDR_IN_PRINTF (ArgRemoteAddress));

		DumpError (Status);
		
		return Status;

    }

    if (SOCKET_ERROR == bind(Socket, (PSOCKADDR)&LocalAddress, AddressSize)) {

        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to bind dest socket.\n"));

        goto cleanup;
    }

    // Set keepalive on the socket
    KeepaliveOption = TRUE;
    if (SOCKET_ERROR == setsockopt (Socket, SOL_SOCKET, SO_KEEPALIVE,
                                   (PCHAR) &KeepaliveOption, sizeof (KeepaliveOption)))
    {
        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to set keepalive on the dest socket.\n"));

        goto cleanup;

    }

    if (getsockname (Socket, (struct sockaddr *)&LocalAddress, &AddressSize)) {

        Status = WSAGetLastError ();

        DebugLastError (_T("Q931: Failed to get name of TCP socket.\n"));

        goto cleanup;
    }

    // Create a trivial redirect. This is used to disallow interception of
    // Q.931 connect-attempts by more general Q.931 dynamic port redirect established
    // during initialization of the proxy. As a side effect it helps to puncture
    // the firewall for both H.245 and Q.931 if the firewall is enabled.

    Status = CreateTrivialNatRedirect(
        ArgRemoteAddress,
        &LocalAddress,
        0
        );

    if(Status != S_OK) {
    
        goto cleanup;
    }

    RemoteAddress = *ArgRemoteAddress;

    // connect to the target server
	// -XXX- make this asynchronous some day!!!
    Status =  connect (Socket, (SOCKADDR *) ArgRemoteAddress, sizeof (SOCKADDR_IN));

    if(Status) {
        Status = WSAGetLastError ();

		goto cleanup;
    }

	Status = EventMgrBindIoHandle (Socket);
	if (Status != S_OK) {
		goto cleanup;
	}

    return ERROR_SUCCESS;

cleanup:

	Clear(TRUE);

    return Status;
}

HRESULT SOCKET_INFO::CreateTrivialNatRedirect (
    IN SOCKADDR_IN * ArgTrivialRedirectDestAddress,
    IN SOCKADDR_IN * ArgTrivialRedirectSourceAddress,
    IN ULONG RestrictedAdapterIndex)
{
    HRESULT Status = S_OK;
    ULONG   ErrorCode;
    ULONG   RedirectFlags = NatRedirectFlagLoopback;    

    _ASSERTE(ArgTrivialRedirectDestAddress);
    _ASSERTE(ArgTrivialRedirectSourceAddress);

    // Save redirect information. It will be needed when time comes to cancel the redirect.
    TrivialRedirectDestAddress.sin_addr.s_addr = ArgTrivialRedirectDestAddress->sin_addr.s_addr;
    TrivialRedirectDestAddress.sin_port = ArgTrivialRedirectDestAddress->sin_port;
   
    TrivialRedirectSourceAddress.sin_addr.s_addr = ArgTrivialRedirectSourceAddress->sin_addr.s_addr;
    TrivialRedirectSourceAddress.sin_port = ArgTrivialRedirectSourceAddress->sin_port;

    if(RestrictedAdapterIndex) {
    
        RedirectFlags |= NatRedirectFlagRestrictAdapter;
    }

    ErrorCode = NatCreateRedirectEx ( 
            NatHandle, 
            RedirectFlags,
            IPPROTO_TCP,            
            TrivialRedirectDestAddress.sin_addr.s_addr,     // destination address
            TrivialRedirectDestAddress.sin_port,            // destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // source addresss
            TrivialRedirectSourceAddress.sin_port,          // source port
            TrivialRedirectDestAddress.sin_addr.s_addr,     // new destination address
            TrivialRedirectDestAddress.sin_port,            // new destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // new source address
            TrivialRedirectSourceAddress.sin_port,          // new source port
            RestrictedAdapterIndex,                         // restricted adapter index
            NULL,                                           // completion routine
            NULL,                                           // completion context
            NULL);                                          // notify event

    if( NO_ERROR != ErrorCode) { 
        
        Status = GetLastErrorAsResult();
        
        DebugF (_T("H323: Failed to set up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"), 
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   ErrorCode);

    }
    else {
    
        DebugF (_T("H323: Set up trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
               SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
               SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress));

        IsNatRedirectActive = TRUE;
    }

    return Status;
}

void SOCKET_INFO::Clear (BOOL CancelTrivialRedirect)
{
	if (Socket != INVALID_SOCKET) {
		closesocket (Socket);
		Socket = INVALID_SOCKET;
	}

    if (CancelTrivialRedirect && IsNatRedirectActive) {
        
        DebugF (_T("H323: Cancelling trivial redirect (%08X:%04X -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"), 
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress),
                   SOCKADDR_IN_PRINTF(&TrivialRedirectSourceAddress), SOCKADDR_IN_PRINTF(&TrivialRedirectDestAddress));

        NatCancelRedirect ( 
            NatHandle, 
            IPPROTO_TCP, 
            TrivialRedirectDestAddress.sin_addr.s_addr,     // destination address
            TrivialRedirectDestAddress.sin_port,            // destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // source addresss
            TrivialRedirectSourceAddress.sin_port,          // source port
            TrivialRedirectDestAddress.sin_addr.s_addr,     // new destination address
            TrivialRedirectDestAddress.sin_port,            // new destination port
            TrivialRedirectSourceAddress.sin_addr.s_addr,   // new source address
            TrivialRedirectSourceAddress.sin_port           // new source port
            );
            
        IsNatRedirectActive = FALSE;
    }
}

SOCKET_INFO::~SOCKET_INFO (void)
{
    Clear(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\t120lc.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"
#include "main.h"

// destructor
// virtual
T120_LOGICAL_CHANNEL::~T120_LOGICAL_CHANNEL(
    )
{
    // Free the ports if they have been allocated
    FreePorts();
}

// All params in host order
HRESULT
T120_LOGICAL_CHANNEL::SetPorts(
    DWORD T120ConnectToIPAddr,
    WORD  T120ConnectToPort,
    DWORD T120ListenOnIPAddr,
    DWORD T120ConnectFromIPAddr
    )
{
    HRESULT HResult;

    // CODEWORK: Decide on the maximum number of TCP/IP connections to
    // to allow to the same port. CurtSm suggests 8. MaxM thinks 4 for
    // NM3.0 and 5 in general - currently allow 5.
    
    // Allocate m_T120ConnectFromPorts and m_T120ListenOnPort
    // Note that I am using the same routine I use to reserve
    // ports for RTP/RTCP. This call reserves a pair of ports.

    // CODEWORK: The port pool should have functions which
    // reserve more than 2 ports (6 ports).
    HResult = PortPoolAllocRTPPort(&m_T120ListenOnPort);
    if (FAILED(HResult))
    {
        return HResult;
    }

    // This port also has been reserved by the above function call.
    m_T120ConnectFromPorts[0] = m_T120ListenOnPort + 1;

    for (int i = 1; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i += 2)
    {
        HResult = PortPoolAllocRTPPort(&m_T120ConnectFromPorts[i]);
        if (FAILED(HResult))
        {
            return HResult;
        }

        // This port also has been reserved by the above function call.
        // CODEWORK: Note that if MAX_T120_TCP_CONNECTIONS_ALLOWED is
        // even then we will be wasting a port. We need to fix the port
        // reservation function for this.
        if ((i + 1) < MAX_T120_TCP_CONNECTIONS_ALLOWED)
            m_T120ConnectFromPorts[i+1] = m_T120ConnectFromPorts[i] + 1;
    }
    
    m_T120ConnectToIPAddr   = T120ConnectToIPAddr;
    m_T120ConnectToPort     = T120ConnectToPort;

    m_T120ListenOnIPAddr    = T120ListenOnIPAddr;
    m_T120ConnectFromIPAddr = T120ConnectFromIPAddr;

    HResult = CreateNatRedirect();
    
    if (FAILED(HResult))
    {
        return HResult;
    }
    _ASSERTE(S_OK == HResult);
    
    return S_OK;
}

HRESULT
T120_LOGICAL_CHANNEL::FreePorts()
{
    HRESULT Result;

    CancelNatRedirect();
    
    if (m_T120ListenOnPort != 0)
    {
        Result = PortPoolFreeRTPPort(m_T120ListenOnPort);
        if (FAILED(Result))
        {
            DebugF( _T("T120_LOGICAL_CHANNEL::FreePorts: PortPoolFreeRTPPort ")
                    _T("failed error: 0x%x\n"),
                    Result);
        }
        
        m_T120ListenOnPort = 0;
        m_T120ConnectFromPorts[0] = 0;
    }

    for (int i = 1; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i += 2)
    {
        if (m_T120ConnectFromPorts[i] != 0)
        {
            Result = PortPoolFreeRTPPort(m_T120ConnectFromPorts[i]);
            if (FAILED(Result))
            {
                DebugF( _T("T120_LOGICAL_CHANNEL::FreePorts: PortPoolFreeRTPPort ")
                        _T("failed error: 0x%x\n"),
                        Result);
            }
            
            m_T120ConnectFromPorts[i] = 0;
            if ((i + 1) < MAX_T120_TCP_CONNECTIONS_ALLOWED)
                m_T120ConnectFromPorts[i+1] = 0;
        }
    }
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for setting up and tearing down NAT Redirects                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// This is defined in rtplc.cpp
// This should not be required. But currently there is a bug in the API impl.

// Create the NAT redirect 
HRESULT
T120_LOGICAL_CHANNEL::CreateNatRedirect(
    )
{
    // XXX Actually so many checks are not needed
    if (m_T120ConnectToIPAddr == INADDR_NONE ||
        m_T120ConnectToPort   == 0 ||
        m_T120ListenOnPort   == 0 ||
        m_T120ConnectFromPorts[0] == 0)
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CreateNatRedirect() Ports not set")
                _T("m_120ConnectToIPAddr: %d.%d.%d.%d\n"),
                BYTES0123(m_T120ConnectToIPAddr)
                );
        // INVALID state or some such
        return E_UNEXPECTED;
    }
    
    for (int i = 0; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i ++)
    {

        ULONG Status;

        Status = NatCreateRedirectEx (
            NatHandle,
            NatRedirectFlagNoTimeout | NatRedirectFlagLoopback,	// flags
            IPPROTO_TCP,                    // UDP
            htonl(m_T120ListenOnIPAddr),    // source packet dest address (local)
            htons(m_T120ListenOnPort),      // source packet dest port (local)
            htonl(0),                       // wildcard - source packet source address
            htons(0),                       // wildcard - source packet source port
            htonl(m_T120ConnectToIPAddr),   // NewDestinationAddress
            htons(m_T120ConnectToPort),     // NewDestinationPort
            htonl(m_T120ConnectFromIPAddr), // NewSourceAddress
            htons(m_T120ConnectFromPorts[i]),   // NewSourcePort
            NULL,                           // RestrictedAdapterIndex
            NULL,                           // CompletionRoutine
            NULL,                           // CompletionContext
            NULL                            // NotifyEvent
            );
            
        if (Status != STATUS_SUCCESS) {
            DebugF (_T ("T120: failed to set up redirect (*.* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                m_T120ListenOnIPAddr,       // source packet dest address (local)
                m_T120ListenOnPort,         // source packet dest port (local)
                m_T120ConnectFromIPAddr,    // NewSourceAddress
                m_T120ConnectFromPorts[i],  // NewSourcePort
                m_T120ConnectToIPAddr,      // NewDestinationAddress
                m_T120ConnectToPort);       // NewDestinationPort

            return (HRESULT) Status;
        }
        else
        {
            DebugF (_T ("T120: 0x%x set up redirect (*.* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
                m_T120ListenOnIPAddr,       // source packet dest address (local)
                m_T120ListenOnPort,         // source packet dest port (local)
                m_T120ConnectFromIPAddr,    // NewSourceAddress
                m_T120ConnectFromPorts[i],  // NewSourcePort
                m_T120ConnectToIPAddr,      // NewDestinationAddress
                m_T120ConnectToPort);       // NewDestinationPort
        }
    }
    
    return S_OK;
}


void
T120_LOGICAL_CHANNEL::CancelNatRedirect(
    )
{
    // CODEWORK: CODEWORK: 
    // Note that this routine gets called every time the destructor
    // gets called and this means that only half of the redirects could
    // have been established or whatever. So we need to check whether
    // each of the redirects has been established. For this purpose
    // it is probably advisable to have one more field storing whether
    // the redirect has been estd. so that we can appropriately clean
    // it up. This field should also be useful in the WSP filter scenario
    // where we don't actually store the ports.

    // if our current state is LC_STATE_OPEN_ACK_RCVD or 
    // LC_STATE_OPENED_CLOSE_RCVD, we have a NAT mapping
    
    for (int i = 0; i < MAX_T120_TCP_CONNECTIONS_ALLOWED; i ++)
    {
#if 1        
        // XXX just a hack for now
        if (m_T120ConnectFromPorts[i] == 0)
            continue;
#endif 1        
    
        ULONG Win32ErrorCode;

        DebugF (_T("T120: 0x%x cancels redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
            &GetCallBridge (),
            m_T120ListenOnIPAddr, // source packet dest address (local)
            m_T120ListenOnPort,   // source packet dest port (local)
            m_T120ConnectFromIPAddr,     // NewSourceAddress
            m_T120ConnectFromPorts[i],              // NewSourcePort
            m_T120ConnectToIPAddr,     // NewDestinationAddress
            m_T120ConnectToPort);    // NewDestinationPort

        Win32ErrorCode = 
        NatCancelRedirect(
            NatHandle,
            IPPROTO_TCP,                    // UDP
            htonl(m_T120ListenOnIPAddr),    // source packet dest address (local)
            htons(m_T120ListenOnPort),      // source packet dest port (local)
            htonl(0),           // wildcard - source packet source address
            htons(0),           // wildcard - source packet source port
            htonl(m_T120ConnectToIPAddr),   // NewDestinationAddress
            htons(m_T120ConnectToPort),     // NewDestinationPort
            htonl(m_T120ConnectFromIPAddr), // NewSourceAddress
            htons(m_T120ConnectFromPorts[i])    // NewSourcePort
            );
    }

    return;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for processing H.245 PDUs                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// all of these are available in the OPEN LOGICAL CHANNEL message
// it modifies the OLC PDU and passes it on to the other H245
// instance for forwarding ???
HRESULT
T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
    IN H245_INFO                            &H245Info,
    IN MEDIA_TYPE                            MediaType,
    IN WORD                                  LogicalChannelNumber,
    IN BYTE                                  SessionId,
    IN DWORD                                 T120ConnectToIPAddr,
    IN WORD                                  T120ConnectToPort,
    IN OUT  MultimediaSystemControlMessage  *pH245pdu
    )
/*++

Routine Description:

    This routine handles a T120 OLC PDU. The T120_LOGICAL_CHANNEL
    is create by H245_INFO::HandleOpenLogicalChannelPDU().
    If T120ConnectToIPAddr and Port are specified, then
    m_T120ListenOnPort and m_T120ConnectFromPorts are allocated and
    the listen address field in pH245pdu are replaced with an IP address
    and port on the other edge of the proxy.
    
Arguments:
    
    H245Info - 
    
    MediaType - 
    
    LogicalChannelNumber - 
    
    SessionId - 
    
    T120ConnectToIPAddr - 
    
    T120ConnectToPort - 
    
    pH245pdu - If the T120ConnectToIPAddr and Port are specified then
        the listen address field in the H245 pdu is replaced with an
        IP address and port on the other edge of the proxy.

Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{

    // CODEWORK: assert that we are dealing with a T120 PDU
    
    // this should be the first call to this instance after its
    // created - hence, these fields must be as asserted
    _ASSERTE(LC_STATE_NOT_INIT == m_LogicalChannelState);
    _ASSERTE(NULL == m_pH245Info);

    HRESULT HResult = E_FAIL;

    m_pH245Info = &H245Info;

    // If the IP address that we need to connect to is specified in the
    // OLC PDU, then we need to allocate the port for listening on the
    // other interface.
    if (T120ConnectToIPAddr != INADDR_NONE)
    {
        HResult = SetPorts(
                      T120ConnectToIPAddr,
                      T120ConnectToPort,
                      ntohl (m_pH245Info->GetOtherH245Info().GetSocketInfo().LocalAddress.sin_addr.s_addr),
                      // listen on other h245 local address
                      ntohl (m_pH245Info->m_SocketInfo.LocalAddress.sin_addr.s_addr)
                      // connect from our local address
                      );
        
        if (FAILED(HResult))
        {
            DebugF( _T("T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU, ")
                    _T("failed to set its ports, returning 0x%x\n"),
                    HResult);
            return HResult;
        }
        //_ASSERTE(S_FALSE != HResult);

        OpenLogicalChannel &OlcPDU = 
            pH245pdu->u.request.u.openLogicalChannel;
        // modify the OLC PDU by replacing the RTCP address/port
        // with the h245 address and RTCP port
        FillH245TransportAddress(
            m_T120ListenOnIPAddr,
            m_T120ListenOnPort,
            OlcPDU.separateStack.networkAddress.u.localAreaAddress
            );
    }
    

    // Should the part below be pushed into H245_INFO::HandleOpenLogicalChannelPDU ?????
    // let the other H245 instance process the PDU
    HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(
                pH245pdu);

    if (FAILED(HResult))
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU")
            _T("(&H245Info, %u, %u, %d.%d.%d.%d, %u, 0x%x, 0x%x)")
            _T("other H245 instance failed to process OLC PDU, returning 0x%x\n"),
            LogicalChannelNumber, SessionId, BYTES0123(T120ConnectToIPAddr),
            T120ConnectToPort, pH245pdu, HResult);
        return HResult;
    }

    // start timer for a response
    // TO DO *** creating timers after queueing the send is sufficient.
    // change back earlier policy of creating these only after the send
    // callback (to be consistent). creating timers that way would be too
    // complex for logical channels
    HResult = CreateTimer(LC_POST_OPEN_TIMER_VALUE);
    if (FAILED(HResult))
    {
        DebugF (_T("T120: 0x%x failed to create timer for duration %d milliseconds ('Open Logical Channel'). Error - %x.\n"),
             &GetCallBridge (), 
             LC_POST_OPEN_TIMER_VALUE,
             HResult);
        return HResult;
    }
    DebugF (_T("T120: 0x%x created timer for duration %d milliseconds ('Open Logical Channel').\n"),
         &GetCallBridge (), 
         LC_POST_OPEN_TIMER_VALUE);
    //_ASSERTE(S_FALSE != HResult);

    InitLogicalChannel(&H245Info, MediaType,
                       LogicalChannelNumber,
                       SessionId, LC_STATE_OPEN_RCVD);

    // transition state to LC_STATE_OPEN_RCVD
    m_LogicalChannelState   = LC_STATE_OPEN_RCVD;

    return S_OK;
}


// If there is no T.120 Listen address in the PDU
// T120ConnectToIPAddr will contain INADDR_NONE
HRESULT
T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU(
    IN  OpenLogicalChannelAck   &OlcAckPDU,
    OUT DWORD                   &T120ConnectToIPAddr,
    OUT WORD                    &T120ConnectToPort
    )
/*++

Routine Description:

    
Arguments:
    
    OlcAckPDU -
    T120ConnectToIPAddr - 
    T120ConnectToPort -
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    HRESULT HResult = S_OK;

    // These are the return values in case of a failure
    // or if the address is not present in the PDU
    T120ConnectToIPAddr = INADDR_NONE;
    T120ConnectToPort = 0;
    
    // there should be reverse logical channel parameters
    if (!(OpenLogicalChannelAck_reverseLogicalChannelParameters_present &
            OlcAckPDU.bit_mask))
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, NO")
            _T("reverse logical channel params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // there should be a separate stack if we do not have
    // a T.120 end point address to connect to (from the OLC PDU).
    if (!(OpenLogicalChannelAck_separateStack_present &
          OlcAckPDU.bit_mask) &&
        m_T120ConnectToIPAddr == INADDR_NONE)
    {
        DebugF( _T("T120_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("NO separate stack, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    if (OpenLogicalChannelAck_separateStack_present &
        OlcAckPDU.bit_mask)
    {
        HResult = GetT120ConnectToAddress(
                      OlcAckPDU.separateStack,
                      T120ConnectToIPAddr,
                      T120ConnectToPort
                      );
    }
    
    return HResult;
}


HRESULT
T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
    pH245pdu - 
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    //The type of this pdu should be OLC Ack
    _ASSERTE(pH245pdu->u.response.choice == openLogicalChannelAck_chosen);
             
    HRESULT HResult = E_FAIL;
    OpenLogicalChannelAck &OlcAckPDU =
        pH245pdu->u.response.u.openLogicalChannelAck;

    switch(m_LogicalChannelState)
    {
        case LC_STATE_OPEN_RCVD:
            DWORD T120ConnectToIPAddr;
            WORD  T120ConnectToPort;
            

            HResult = CheckOpenLogicalChannelAckPDU(
                        OlcAckPDU,
                        T120ConnectToIPAddr,
                        T120ConnectToPort
                        );
            
            if (FAILED(HResult))
            {
                return HResult;
            }
            _ASSERTE(S_OK == HResult);

            if (T120ConnectToIPAddr != INADDR_NONE)
            {
                HResult = SetPorts(
                         T120ConnectToIPAddr,
                         T120ConnectToPort,
                         ntohl (m_pH245Info->m_SocketInfo.LocalAddress.sin_addr.s_addr),
                         // listen on our local address
                         ntohl (m_pH245Info->GetOtherH245Info().GetSocketInfo().LocalAddress.sin_addr.s_addr)
                         // connect from other h245 local address
                         );
        
                if (FAILED(HResult))
                {
                    return HResult;
                }

                // modify the OLC PDU by replacing the RTCP address/port
                // with the h245 address and RTCP port
                FillH245TransportAddress(
                    m_T120ListenOnIPAddr,
                    m_T120ListenOnPort,
                    OlcAckPDU.separateStack.networkAddress.u.localAreaAddress
                    );
            }

            // reset timer, we must have one (ignore error code if any)
            //_ASSERTE(NULL != m_TimerHandle);
            TimprocCancelTimer();
            DebugF (_T("T120: 0x%x cancelled timer.\n"),
                 &GetCallBridge ());

            // transition to LC_STATE_OPEN_ACK_RCVD
            m_LogicalChannelState = LC_STATE_OPEN_ACK_RCVD;
            break;

        case LC_STATE_CLOSE_RCVD:
            // if we have received a close logical channel PDU, we must throw
            // OLC ACKs away and continue to wait
            DebugF( _T("T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in close state %d, returning E_INVALIDARG\n"),
                    pH245pdu, m_LogicalChannelState);
            return E_INVALIDARG;
            break;
            
        case LC_STATE_NOT_INIT:
        case LC_STATE_OPEN_ACK_RCVD:
        case LC_STATE_OPENED_CLOSE_RCVD:
        default:
            DebugF( _T("T120_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in state %d, returning E_UNEXPECTED\n"),
                    pH245pdu, m_LogicalChannelState);
            _ASSERTE(FALSE);
            return E_UNEXPECTED;
            break;
    } // switch (m_LogicalChannelState)

    return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\sockinfo.h ===
#ifndef __h323ics_sockinfo_h_
#define __h323ics_sockinfo_h_

// This class abstracts a winsock socket
// contains the socket descriptor, local and remote addresses and ports
// corresponding to a winsock socket
struct SOCKET_INFO
{
public:

    SOCKET			Socket;
    
    SOCKADDR_IN		LocalAddress;
    SOCKADDR_IN		RemoteAddress;
    SOCKADDR_IN		TrivialRedirectSourceAddress;
    SOCKADDR_IN		TrivialRedirectDestAddress;
    
    BOOL            IsNatRedirectActive;

    SOCKET_INFO();

    void Init (
        IN	SOCKET			ArgSocket,
        IN	SOCKADDR_IN *	ArgLocalAddress,
        IN	SOCKADDR_IN *	ArgRemoteAddress);

    int Init (
        IN	SOCKET			ArgSocket,
        IN	SOCKADDR_IN *	ArgRemoteAddress);

	BOOLEAN IsSocketValid (void);

    void SetListenInfo (
        IN	SOCKET			ListenSocket,
        IN	SOCKADDR_IN *	ListenAddress);

    int Connect (
        IN	SOCKADDR_IN *	RemoteAddress);
		
    HRESULT CreateTrivialNatRedirect (
        IN SOCKADDR_IN * ArgTrivialRedirectDestAddress,
        IN SOCKADDR_IN * ArgTrivialRedirectSourceAddress,
        IN ULONG RestrictedAdapterIndex);

    void Clear (BOOL CancelTrivialRedirect);

    ~SOCKET_INFO();
};


#endif __h323ics_sockinfo_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\stdafx.h ===
#define	STRICT
#define	UNICODE
#define	_UNICODE

#pragma	warning (disable : 4211)		// ASN.1 stubs have static/extern conflict
#pragma	warning (disable : 4201)		// nameless struct/union
#pragma warning (disable : 4514)		// unreferenced inline function has been removed
#pragma warning (disable : 4100)		// unreferenced formal parameter
#pragma warning (disable : 4127)		// conditional expression is constant
#pragma warning (disable : 4355)		// use of "this" in constructor initializer list



// NT private files
// Need to be before the windows include files
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

// Win32 SDK (public)
#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <winsvc.h>
#include <mswsock.h>

// ANSI
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <limits.h>

// Microsoft private
#include <msasn1.h>
#include <msper.h>
#include <ipnatapi.h>
#include <ipnat.h>

extern "C" {
#include <sainfo.h>
#include <rasuip.h>
#include <raserror.h>
#include <ipexport.h>		// needed for interaction with TCP driver
#include <ipinfo.h>
#include <tcpinfo.h>
#include <ntddtcp.h>
#include <routprot.h>		// for struct IP_ADAPTER_BINDING_INFO
#include <mprerror.h>       // for RRAS error codes
#include <iphlpapi.h>
#include <ntddip.h>
#include <iphlpstk.h>
#include <mprapi.h>
};
#include <natio.h>


// Keep this prototype here until it gets included 
// in 'rasuip.h'
extern "C" {
extern
DWORD APIENTRY
RasGetEntryHrasconnW(
    IN  LPCWSTR             pszPhonebook,
    IN  LPCWSTR             pszEntry,
    OUT LPHRASCONN          lphrasconn);
};


// Interface to ipnathlp.dll
#include "h323icsp.h"

// Project
#include "ldap.h"			// ASN.1 structures for LDAP
#include "h225pp.h"
#include "h245pp.h"
#include "util.h"
#include "h323asn1.h"
#include "q931msg.h"
#include "portmgmt.h"
#include "h323ics.h"
#include "main.h"
#include "timer.h"
#include "gkwsock.h"
#include "cbridge.h"
#include "cblist.h"
#include "intfc.h"
#include "ldappx.h"
#include "timerval.h"
#include "iocompl.h"
#include "q931info.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\rtplc.cpp ===
#include "stdafx.h"
#include "portmgmt.h"
#include "timerval.h"
#include "cbridge.h"
#include "main.h"


// destructor
// virtual
RTP_LOGICAL_CHANNEL::~RTP_LOGICAL_CHANNEL (void)
{
	// close NAT mappings
	CloseNATMappings();

    // release reference to any associated channel or allocated ports
	ReleaseAssociationAndPorts();
}


/*++
  Release ports only if there is no associated channel. If there is an
  associated channel the ports will be freed when it is deleted. Note that
  a logical channel could be closed and reopened again.
--*/

inline void 
RTP_LOGICAL_CHANNEL::ReleaseAssociationAndPorts()
{
    // if there is an associated logical channel
    if (NULL != m_pAssocLogicalChannel)
    {
        //  release reference to it
        m_pAssocLogicalChannel->ResetAssociationRef();
        m_pAssocLogicalChannel = NULL;
    }
    else
    {
        if (m_OwnSourceRecvRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnSourceRecvRTPPort);
        if (m_OwnAssocLCRecvRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnAssocLCRecvRTPPort);
        if (m_OwnDestSendRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnDestSendRTPPort);
        if (m_OwnAssocLCSendRTPPort != 0)
            PortPoolFreeRTPPort(m_OwnAssocLCSendRTPPort);
        m_OwnSourceRecvRTPPort  = m_OwnSourceRecvRTCPPort   = 0;
        m_OwnAssocLCRecvRTPPort = m_OwnDestRecvRTCPPort     = 0;
        m_OwnDestSendRTPPort    = m_OwnDestSendRTCPPort     = 0;
        m_OwnAssocLCSendRTPPort = m_OwnSourceSendRTCPPort   = 0;
    }
}

/*++
 This function is called after the OLC is received.
 --*/

HRESULT
RTP_LOGICAL_CHANNEL::SetPorts (void)
{
	HRESULT HResult = E_FAIL;

	// if there is an associated LC, copy all the ports from that LC.
	// else, allocate them now
    if (NULL != m_pAssocLogicalChannel)
    {
        // tell the associated logical channel that we are associated
        // with it
        m_pAssocLogicalChannel->SetAssociationRef(*this);

        // save the associated channel's own source/dest ports
		// assoc channel's source ports become our dest ports and vice versa
        m_OwnDestRecvRTCPPort	= m_pAssocLogicalChannel->m_OwnSourceRecvRTCPPort;
        m_OwnSourceRecvRTCPPort	= m_pAssocLogicalChannel->m_OwnDestRecvRTCPPort;

        m_OwnDestSendRTCPPort	= m_pAssocLogicalChannel->m_OwnSourceSendRTCPPort;
        m_OwnSourceSendRTCPPort	= m_pAssocLogicalChannel->m_OwnDestSendRTCPPort;

        // Copy the RTP ports
        m_OwnSourceRecvRTPPort  = m_pAssocLogicalChannel->m_OwnAssocLCRecvRTPPort;
        m_OwnAssocLCRecvRTPPort = m_pAssocLogicalChannel->m_OwnSourceRecvRTPPort;

        m_OwnDestSendRTPPort    = m_pAssocLogicalChannel->m_OwnAssocLCSendRTPPort;
        m_OwnAssocLCSendRTPPort = m_pAssocLogicalChannel->m_OwnDestSendRTPPort;
    }
    else
    {
        // allocate own ports - the portmgt apis return an even port only (RTP)
        // and the assumption is that the RTCP port = RTP port + 1
		// however, we use the odd port for receiving RTCP and the even
		// port for sending RTP
        HResult = PortPoolAllocRTPPort (&m_OwnSourceRecvRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnSourceRecvRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnSourceRecvRTCPPort = m_OwnSourceRecvRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnAssocLCRecvRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnAssocLCRecvRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnDestRecvRTCPPort = m_OwnAssocLCRecvRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnDestSendRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts")
				_T("failed to allocate m_OwnDestSendRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnDestSendRTCPPort = m_OwnDestSendRTPPort + 1;

        HResult = PortPoolAllocRTPPort (&m_OwnAssocLCSendRTPPort);
        if (FAILED(HResult))
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::SetPorts, ")
                _T("failed to allocate m_OwnAssocLCSendRTPPort, returning 0x%x\n"),
                HResult);
            goto cleanup;
        }
        m_OwnSourceSendRTCPPort = m_OwnAssocLCSendRTPPort + 1;
    }
    
	DebugF (_T("RTP : 0x%x using ports %04X, %04X, %04X, %04X.\n"),
            &GetCallBridge (),
            m_OwnSourceRecvRTPPort, m_OwnAssocLCRecvRTPPort,
            m_OwnDestSendRTPPort, m_OwnAssocLCSendRTPPort);

	DebugF (_T("RTCP: 0x%x using ports %04X, %04X, %04X, %04X.\n"),
            &GetCallBridge (),
            m_OwnSourceRecvRTCPPort, m_OwnDestRecvRTCPPort,
            m_OwnDestSendRTCPPort, m_OwnSourceSendRTCPPort);

	return S_OK;

 cleanup:
    if (m_OwnSourceRecvRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnSourceRecvRTPPort);
    if (m_OwnAssocLCRecvRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnAssocLCRecvRTPPort);
    if (m_OwnDestSendRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnDestSendRTPPort);
    if (m_OwnAssocLCSendRTPPort != 0)
        PortPoolFreeRTPPort(m_OwnAssocLCSendRTPPort);
    m_OwnSourceRecvRTPPort  = m_OwnSourceRecvRTCPPort   = 0;
    m_OwnAssocLCRecvRTPPort = m_OwnDestRecvRTCPPort     = 0;
    m_OwnDestSendRTPPort    = m_OwnDestSendRTCPPort     = 0;
    m_OwnAssocLCSendRTPPort = m_OwnSourceSendRTCPPort   = 0;
    
    return HResult;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for setting up and tearing down NAT Redirects                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// opens the forward RTP, forward RTCP and reverse RTCP streams
// This function is called after the OLCAck is received.
HRESULT
RTP_LOGICAL_CHANNEL::OpenNATMappings(
	)
{
    // open NAT mapping for source -> dest RTP stream
	// this is the forward RTP stream and we must always open this

	NTSTATUS	Status;
	ULONG RedirectFlags = NatRedirectFlagNoTimeout;

	if (m_OwnDestIPv4Address == m_DestIPv4Address ||
		m_SourceIPv4Address  == m_OwnSourceIPv4Address)
	{
		RedirectFlags |= NatRedirectFlagLoopback;
	}

	Status = NatCreateRedirectEx (
            NatHandle,
			RedirectFlags,	                // flags
			IPPROTO_UDP,				    // UDP
			htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
			htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
			htonl(0),			            // wildcard - source packet source address
			htons(0),			            // wildcard - source packet source port
			htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
			htons(m_DestRTPPort),			// NewDestinationPort
			htonl(m_OwnDestIPv4Address),	// NewSourceAddress
			htons(m_OwnDestSendRTPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                   		// CompletionRoutine
			NULL,							// CompletionContext
            NULL);                          // NotifyEvent

	if (Status != NO_ERROR) {
	
        DebugF (_T("RTP : 0x%x failed to set up redirect for forward RTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
            &GetCallBridge (),
    		m_OwnSourceIPv4Address,		    
    		m_OwnSourceRecvRTPPort,		    
    		m_OwnDestIPv4Address,		    
    		m_OwnDestSendRTPPort,		    
    		m_DestRTPIPv4Address,		    
            m_DestRTPPort,			        
            Status);

		return E_FAIL;
	} 
	else {
	
    	DebugF (_T("RTP : 0x%x set up redirect for forward RTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
            &GetCallBridge (),
    		m_OwnSourceIPv4Address,		
    		m_OwnSourceRecvRTPPort,		
    		m_OwnDestIPv4Address,		
    		m_OwnDestSendRTPPort,		
    		m_DestRTPIPv4Address,		
            m_DestRTPPort);			    
    }

	// check to see if we must open the RTCP streams in both directions
	// source <-> dest
	
	// if there is no associated logical channel or the assoc logical
	// channel is in neither LC_STATE_OPEN_ACK_RCVD nor 
	// LC_STATE_OPENED_CLOSE_RCVD, we must open the RTCP streams
	if ((!m_pAssocLogicalChannel) ||
		 ((LC_STATE_OPEN_ACK_RCVD != m_pAssocLogicalChannel -> m_LogicalChannelState) &&
		 (LC_STATE_OPENED_CLOSE_RCVD != m_pAssocLogicalChannel -> m_LogicalChannelState))) {

		// open NAT mapping for forward RTCP stream
		Status = NatCreateRedirectEx (
			NatHandle,
			RedirectFlags,	                // flags
			IPPROTO_UDP,				    // UDP
			htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
			htons(m_OwnSourceRecvRTCPPort),	// source packet dest port (local)
			htonl(0),				        // wildcard - source packet source address
			htons(0),				        // wildcard - source packet source port
			htonl(m_DestRTCPIPv4Address),	// NewDestinationAddress
			htons(m_DestRTCPPort),			// NewDestinationPort
			htonl(m_OwnDestIPv4Address),	// NewSourceAddress
			htons(m_OwnDestSendRTCPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                           // CompletionRoutine
			NULL,							// CompletionContext
			NULL);                          // NotifyEvent

		if (Status != NO_ERROR) {
			// close the forward RTP stream
			// ignore error code

		    DebugF (_T("RTCP: 0x%x failed to set up redirect for forward RCTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
                &GetCallBridge (),
                m_OwnSourceIPv4Address,		
                m_OwnSourceRecvRTCPPort,	
                m_OwnDestIPv4Address,		
                m_OwnDestSendRTCPPort,		
                m_DestRTCPIPv4Address,		
                m_DestRTCPPort,
                Status);

			NatCancelRedirect (
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort));	// NewSourcePort

			return E_FAIL;
		}
		else {
		
		    DebugF (_T("RTCP: 0x%x set up redirect for forward RCTP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
                m_OwnSourceIPv4Address,		// source packet dest address (local)
                m_OwnSourceRecvRTCPPort,	// source packet dest port (local)
                m_OwnDestIPv4Address,		// NewSourceAddress
                m_OwnDestSendRTCPPort,		// NewSourcePort
                m_DestRTCPIPv4Address,		// NewDestinationAddress
                m_DestRTCPPort);			// NewDestinationPort
        }

		// open NAT mapping for reverse RTCP stream
		Status = NatCreateRedirectEx (
            NatHandle,
			RedirectFlags,						// flags
			IPPROTO_UDP,		// UDP
			htonl(m_OwnDestIPv4Address),	// source packet dest address (local)
			htons(m_OwnDestRecvRTCPPort),	// source packet dest port (local)
			htonl(0),			// wildcard - source packet source address
			htons(0),			// wildcard - source packet source port
			htonl(m_SourceRTCPIPv4Address),	// NewDestinationAddress
			htons(m_SourceRTCPPort),		// NewDestinationPort
			htonl(m_OwnSourceIPv4Address),	// NewSourceAddress
			htons(m_OwnSourceSendRTCPPort),	// NewSourcePort
            NULL,                           // RestrictedAdapterIndex
			NULL,                           // CompletionRoutine
			NULL,							// CompletionContext
            NULL);                          // NotifyEvent

		if (Status != NO_ERROR) {
		
	        DebugF (_T("RTCP: 0x%x failed to set up redirect for reverse RTCP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X). Error - %d.\n"),
                &GetCallBridge (),
                m_OwnDestIPv4Address,			
                m_OwnDestRecvRTCPPort,			
                m_OwnSourceIPv4Address,			
                m_OwnSourceSendRTCPPort,		
                m_SourceRTCPIPv4Address,		
                m_SourceRTCPPort,				
                Status);
                
			// close the forward RTP stream
			// ignore error code

			NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort)		// NewSourcePort
				);

			// close the forward RTCP stream
			// ignore error code
			NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTCPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTCPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTCPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTCPPort)	// NewSourcePort
				);

			return E_FAIL;
		}
		else {
		
	        DebugF (_T("RTCP: 0x%x set up redirect for reverse RTCP stream: (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
                m_OwnDestIPv4Address,			
                m_OwnDestRecvRTCPPort,			
                m_OwnSourceIPv4Address,			
                m_OwnSourceSendRTCPPort,		
                m_SourceRTCPIPv4Address,		
                m_SourceRTCPPort);				
       }

	}

	return S_OK;
}


void
RTP_LOGICAL_CHANNEL::CloseNATMappings(
	)
{
	// if our current state is LC_STATE_OPEN_ACK_RCVD or 
	// LC_STATE_OPENED_CLOSE_RCVD, we have a forward RTP NAT mapping
	// we may also have to close the RTCP mappings
	if ( (LC_STATE_OPEN_ACK_RCVD	 == m_LogicalChannelState) ||
		 (LC_STATE_OPENED_CLOSE_RCVD == m_LogicalChannelState)  )
	{

        DebugF (_T ("RTP : 0x%x cancels forward RTP  redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
            &GetCallBridge (),
			m_OwnSourceIPv4Address,	// source packet dest address (local)
			m_OwnSourceRecvRTPPort,		// source packet dest port (local)
			m_OwnDestIPv4Address,	// NewSourceAddress
			m_OwnDestSendRTPPort,	// NewSourcePort
			m_DestRTPIPv4Address,	// NewDestinationAddress
			m_DestRTPPort			// NewDestinationPort
			);
		// cancel forward RTP NAT mapping
		// ignore error code
		ULONG Win32ErrorCode = NO_ERROR;
		Win32ErrorCode = NatCancelRedirect(
                NatHandle,
				IPPROTO_UDP,					// UDP
				htonl(m_OwnSourceIPv4Address),	// source packet dest address (local)
				htons(m_OwnSourceRecvRTPPort),	// source packet dest port (local)
				htonl(0),						// wildcard - source packet source address
				htons(0),						// wildcard - source packet source port
				htonl(m_DestRTPIPv4Address),	// NewDestinationAddress
				htons(m_DestRTPPort),			// NewDestinationPort
				htonl(m_OwnDestIPv4Address),	// NewSourceAddress
				htons(m_OwnDestSendRTPPort)		// NewSourcePort
            );

		// if we don't have an associated logical channel or its in neither
		// LC_STATE_OPEN_ACK_RCVD nor LC_STATE_OPENED_CLOSE_RCVD, we
		// must close the forward and reverse RTCP NAT mappings
		if ( (NULL == m_pAssocLogicalChannel) ||
			 ( (LC_STATE_OPEN_ACK_RCVD	 != 
					m_pAssocLogicalChannel->m_LogicalChannelState) &&
			   (LC_STATE_OPENED_CLOSE_RCVD != 
					m_pAssocLogicalChannel->m_LogicalChannelState)  ) )
		{
            DebugF (_T ("RTCP: 0x%x cancels forward RTCP redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
				m_OwnSourceIPv4Address,		// source packet dest address (local)
				m_OwnSourceRecvRTCPPort,	// source packet dest port (local)
				m_OwnDestIPv4Address,		// NewSourceAddress
				m_OwnDestSendRTCPPort, 		// NewSourcePort
				m_DestRTCPIPv4Address,		// NewDestinationAddress
				m_DestRTCPPort				// NewDestinationPort
				);
			// cancel forward RTCP NAT mapping
			// ignore error code
 			Win32ErrorCode = NatCancelRedirect(
                    NatHandle,
					IPPROTO_UDP,						// UDP
					htonl(m_OwnSourceIPv4Address),		// source packet dest address (local)
					htons(m_OwnSourceRecvRTCPPort),		// source packet dest port (local)
					htonl(0),							// wildcard - source packet source address
					htons(0),							// wildcard - source packet source port
					htonl(m_DestRTCPIPv4Address),		// NewDestinationAddress
					htons(m_DestRTCPPort),				// NewDestinationPort
					htonl(m_OwnDestIPv4Address),		// NewSourceAddress
					htons(m_OwnDestSendRTCPPort) 		// NewSourcePort
                );

            DebugF (_T ("RTCP: 0x%x cancels reverse RTCP redirect (*:* -> %08X:%04X) => (%08X:%04X -> %08X:%04X).\n"),
                &GetCallBridge (),
				m_OwnDestIPv4Address,		// source packet dest address (local)
				m_OwnDestRecvRTCPPort,		// source packet dest port (local)
				m_OwnSourceIPv4Address,		// NewSourceAddress
				m_OwnSourceSendRTCPPort,	// NewSourcePort
				m_SourceRTCPIPv4Address,	// NewDestinationAddress
				m_SourceRTCPPort			// NewDestinationPort
				);
			// close the reverse RTCP stream
			// ignore error code
			Win32ErrorCode = NatCancelRedirect(
                    NatHandle,
					IPPROTO_UDP,				// UDP
					htonl(m_OwnDestIPv4Address),	
						// source packet dest address (local)
					htons(m_OwnDestRecvRTCPPort),		
						// source packet dest port (local)
					htonl(0),		// wildcard - source packet source address
					htons(0),		// wildcard - source packet source port
					htonl(m_SourceRTCPIPv4Address),	// NewDestinationAddress
					htons(m_SourceRTCPPort),		// NewDestinationPort
					htonl(m_OwnSourceIPv4Address),	// NewSourceAddress
					htons(m_OwnSourceSendRTCPPort)	// NewSourcePort
                );
		}
	}
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for processing H.245 PDUs                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


HRESULT
RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU(
	IN H245_INFO							&H245Info,
    IN MEDIA_TYPE                           MediaType,
	IN DWORD								LocalIPv4Address,
	IN DWORD								RemoteIPv4Address,
	IN DWORD								OtherLocalIPv4Address,
	IN DWORD								OtherRemoteIPv4Address,
	IN WORD									LogicalChannelNumber,
	IN BYTE									SessionId,
	IN RTP_LOGICAL_CHANNEL					*pAssocLogicalChannel,
	IN DWORD								SourceRTCPIPv4Address,
	IN WORD									SourceRTCPPort,
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
	// this should be the first call to this instance after its
	// created - hence, these fields must be as asserted
	_ASSERTE(LC_STATE_NOT_INIT == m_LogicalChannelState);
    _ASSERTE(NULL == m_pH245Info);
    _ASSERTE(NULL == m_pAssocLogicalChannel);

	HRESULT HResult = E_FAIL;

    m_pH245Info             = &H245Info;

    // the destructor will try to release associations, so assign the
    // associated logical channel now
    m_pAssocLogicalChannel = pAssocLogicalChannel;

	// set the local/remote addresses for our and the other h245 instance
	m_OwnSourceIPv4Address	= LocalIPv4Address;
	m_SourceIPv4Address		= RemoteIPv4Address;
	m_OwnDestIPv4Address	= OtherLocalIPv4Address;
	m_DestIPv4Address		= OtherRemoteIPv4Address;

    m_LogicalChannelNumber  = LogicalChannelNumber;
    m_SessionId             = SessionId;
    m_MediaType             = MediaType;  //  XXX

    m_SourceRTCPIPv4Address = SourceRTCPIPv4Address;
    m_SourceRTCPPort        = SourceRTCPPort;

	// set the rtp and rtcp ports on the source and dest side
	// if there is a logical channel, then, just the rtcp ports will be shared
	HResult = SetPorts();
	if (FAILED(HResult))
	{
        DebugF( _T("RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU, ")
            _T("failed to set its ports, returning 0x%x\n"),
            HResult);
        return HResult;
    }
	//_ASSERTE(S_FALSE != HResult);


    OpenLogicalChannel &OlcPDU = 
        pH245pdu->u.request.u.openLogicalChannel;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & MultiplexParams = 
        OlcPDU.forwardLogicalChannelParameters.multiplexParameters;
    H2250LogicalChannelParameters &H2250Params =
        MultiplexParams.u.h2250LogicalChannelParameters;

    // modify the OLC PDU by replacing the RTCP address/port
	// with the h245 address and RTCP port
	FillH245TransportAddress(
		m_OwnDestIPv4Address,
		m_OwnDestRecvRTCPPort,
		H2250Params.mediaControlChannel);

    // Should the part below be pushed into H245_INFO::HandleOpenLogicalChannelPDU ?????
    // let the other H245 instance process the PDU
    HResult = m_pH245Info->GetOtherH245Info().ProcessMessage(
                pH245pdu
                );
    if (FAILED(HResult))
    {
		DebugF(_T("RTP_LOGICAL_CHANNEL::HandleOpenLogicalChannelPDU: other H245 instance failed to process OLC PDU, returning 0x%x\n"), HResult);
        return HResult;
    }

	// start timer for a response
	// TO DO *** creating timers after queueing the send is sufficient.
	// change back earlier policy of creating these only after the send
	// callback (to be consistent). creating timers that way would be too
	// complex for logical channels
	HResult = CreateTimer(LC_POST_OPEN_TIMER_VALUE);
    if (FAILED(HResult))
    {
        DebugF (_T("RTP : 0x%x failed to create timer for duration %d milliseconds ('Open Logical Channel'). Error - %x.\n"),
             &GetCallBridge (), 
             LC_POST_OPEN_TIMER_VALUE,
             HResult);
        return HResult;
    }
    DebugF (_T("RTP : 0x%x created timer for duration %d milliseconds ('Open Logical Channel').\n"),
         &GetCallBridge (), 
         LC_POST_OPEN_TIMER_VALUE);

    // transition state to LC_STATE_OPEN_RCVD
    m_LogicalChannelState   = LC_STATE_OPEN_RCVD;

    return S_OK;
}


HRESULT
RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU(
    IN  MultimediaSystemControlMessage  &H245pdu,
    OUT BYTE                            &SessionId,
    OUT DWORD                           &DestRTPIPv4Address,
    OUT WORD                            &DestRTPPort,
    OUT DWORD                           &DestRTCPIPv4Address,
    OUT WORD                            &DestRTCPPort
    )
/*++

Routine Description:

    
Arguments:
    
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    // get the open logical channel ack PDU
    OpenLogicalChannelAck &OlcAckPDU = H245pdu.u.response.u.openLogicalChannelAck;

    // there shouldn't be reverse logical channel parameters
    if (OpenLogicalChannelAck_reverseLogicalChannelParameters_present &
            OlcAckPDU.bit_mask)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, has ")
            _T("reverse logical channel params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // there shouldn't be a separate stack
    if (OpenLogicalChannelAck_separateStack_present &
            OlcAckPDU.bit_mask)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("has a separate stack, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // we should have forward multiplex ack params - these contain the
    // H245 params
    if ( !(forwardMultiplexAckParameters_present &
            OlcAckPDU.bit_mask) )
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("doesn't have forward multiplex ack params,")
                _T(" returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // we should have the H245 params
    if (h2250LogicalChannelAckParameters_chosen !=
            OlcAckPDU.forwardMultiplexAckParameters.choice)
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("doesn't have H2250 ack params, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    H2250LogicalChannelAckParameters &H2250Params =
        OlcAckPDU.forwardMultiplexAckParameters.\
        u.h2250LogicalChannelAckParameters;

    // it should have media channel info
    if ( !(H2250LogicalChannelAckParameters_mediaChannel_present &
            H2250Params.bit_mask) )
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("doesn't have media channel info, returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // it should have control channel info
    if ( !(H2250LogicalChannelAckParameters_mediaControlChannel_present &
            H2250Params.bit_mask) )
    {
        DebugF(_T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("doesn't have media control channel info,")
                _T(" returning E_INVALIDARG\n"));
        return E_INVALIDARG;
    }

    // save remote client RTP address/port
    HRESULT HResult = E_FAIL;
    HResult = GetH245TransportInfo(
                H2250Params.mediaChannel,
                DestRTPIPv4Address,
                DestRTPPort);

    if (FAILED(HResult))
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("can't get media channel (RTP) address/port, returning 0x%x\n"),
            HResult);
        return HResult;
    }
    _ASSERTE(S_OK == HResult);

    // save remote client RTP address/port
    HResult = GetH245TransportInfo(
                H2250Params.mediaControlChannel,
                DestRTCPIPv4Address,
                DestRTCPPort);

    if (FAILED(HResult))
    {
        DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
            _T("can't get media control channel (RTCP) address/port, ")
            _T("returning 0x%x\n"),
            HResult);
        return HResult;
    }
    _ASSERTE(S_OK == HResult);

    // if there is a session id, save it
    if (sessionID_present & H2250Params.bit_mask)
    {
        // the PDU stores the session ID as an unsigned short
        // although the ITU spec requires it to be a BYTE value [0..255]
        // the cast to BYTE is intentional
        _ASSERTE(255 >= H2250Params.sessionID);
        SessionId = (BYTE)H2250Params.sessionID;

        // the session id must be non-zero
        if (0 == SessionId)
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("has a session id of 0, returning E_INVALIDARG\n"));
            return E_INVALIDARG;
        }
    }
    else
    {
        // if no session id is supplied, the source must have supplied
        // a non-zero session id in OpenLogicalChannel
        if (0 == SessionId)
        {
            DebugF( _T("RTP_LOGICAL_CHANNEL::CheckOpenLogicalChannelAckPDU, ")
                _T("the source supplied a session id of 0 and the dest hasn't")
                _T("supplied one, returning E_INVALIDARG\n"));
            return E_INVALIDARG;
        }
    }

    return HResult;
}


HRESULT
RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU(
    IN      MultimediaSystemControlMessage   *pH245pdu
    )
/*++

Routine Description:

    
Arguments:
    
    pH245pdu - 
    
Return Values:

    S_OK on success.
    E_INVALIDARG if the PDU is invalid.

--*/
{
    HRESULT HResult = E_FAIL;
	switch(m_LogicalChannelState)
	{
	case LC_STATE_OPEN_RCVD:
		{
			HResult = CheckOpenLogicalChannelAckPDU(
						*pH245pdu,
						m_SessionId, 
						m_DestRTPIPv4Address, 
						m_DestRTPPort, 
						m_DestRTCPIPv4Address, 
						m_DestRTCPPort
						);
			if (FAILED(HResult))
			{
				DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                        _T("(&%x), can't process OpenLogicalChannelAck, returning 0x%x\n"),
                        pH245pdu, HResult);
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

			HResult = OpenNATMappings();
			if (FAILED(HResult))
			{
				DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                        _T("(&%x), can't process OpenLogicalChannelAck, returning 0x%x\n"),
                        pH245pdu, HResult);
				return HResult;
			}
			_ASSERTE(S_OK == HResult);

			OpenLogicalChannelAck &OlcAckPDU =
                pH245pdu->u.response.u.openLogicalChannelAck;
			H2250LogicalChannelAckParameters &H2250Params =
				OlcAckPDU.forwardMultiplexAckParameters.u.h2250LogicalChannelAckParameters;

			// replace the RTP address/port
			// with the H.245 address and RTP port
			FillH245TransportAddress(
				m_OwnSourceIPv4Address,
				m_OwnSourceRecvRTPPort,
				H2250Params.mediaChannel
				);

			// replace the RTCP address/port
			// with the h245 address and RTCP port
			FillH245TransportAddress(
				m_OwnSourceIPv4Address,
				m_OwnSourceRecvRTCPPort,
				H2250Params.mediaControlChannel);

			// reset timer, we must have one (ignore error code if any)
			_ASSERTE(NULL != m_TimerHandle);
			TimprocCancelTimer();
            DebugF (_T("RTP : 0x%x cancelled timer.\n"),
                 &GetCallBridge ());

			// trasition to LC_STATE_OPEN_ACK_RCVD
			m_LogicalChannelState = LC_STATE_OPEN_ACK_RCVD;
		}
		break;

	case LC_STATE_CLOSE_RCVD:
		{
			// if we have received a close logical channel PDU, we must throw
			// OLC ACKs away and continue to wait
			DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in close state %d, returning E_INVALIDARG\n"),
                    pH245pdu, m_LogicalChannelState);
			return E_INVALIDARG;
		}
		break;

	case LC_STATE_NOT_INIT:
	case LC_STATE_OPEN_ACK_RCVD:
	case LC_STATE_OPENED_CLOSE_RCVD:
	default:
		{
			DebugF( _T("RTP_LOGICAL_CHANNEL::ProcessOpenLogicalChannelAckPDU")
                    _T("(&%x), in state %d, returning E_UNEXPECTED"),
                    pH245pdu, m_LogicalChannelState);
            _ASSERTE(FALSE);
			return E_UNEXPECTED;
		}
		break;
	};

    return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\timer.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    timer.cpp

Abstract:

    Contains:
        Routines for timer operations

Environment:

    User Mode - Win32

History:
    
    1. 14-Feb-2000 -- File creation (based on             Ilya Kleyman  (ilyak)
                      previous work by AjayCh)

--*/

#include "stdafx.h"

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global Variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// TIMER_PROCESSOR ------------------------------------------------------------------

/*
 * This function is passed as the callback in the 
 * CreateTimerQueueTimer() function
 */
// static
void WINAPI TimeoutCallback (
    IN    PVOID    Context,
    IN    BOOLEAN    TimerFired)
{
 
    TIMER_PROCESSOR *pTimerProcessor = (TIMER_PROCESSOR *) Context;

    pTimerProcessor->TimerCallback();

    // At this point the timer would have been canceled because
    // this is a one shot timer (no period)
}

/*++

Routine Description:

    Create a timer.
    
Arguments:
    
Return Values:
    if Success the caller should increase the ref count.
    
--*/

DWORD TIMER_PROCESSOR::TimprocCreateTimer (
    IN    DWORD    TimeoutValue)
{
    HRESULT Result;

    if (m_TimerHandle) {
        
        DebugF (_T("H323: timer is already pending, cannot create new timer.\n"));
        
        return E_FAIL;
    }

    IncrementLifetimeCounter ();

    if (CreateTimerQueueTimer(&m_TimerHandle,
                               NATH323_TIMER_QUEUE,
                               TimeoutCallback,
                               this,
                               TimeoutValue,
                               0,                    // One shot timer
                               WT_EXECUTEINIOTHREAD)) {

        assert (m_TimerHandle);

        Result = S_OK;
    }
    else {

        Result = GetLastResult();

        DecrementLifetimeCounter ();

    }

    return Result;
}

/*++

Routine Description:

    Cancel the timer if there is one. Otherwise simply return.
    
Arguments:
    
Return Values:
  
--*/

// If Canceling the timer fails this means that the
// timer callback could be pending. In this scenario,
// the timer callback could execute later and so we
// should not release the refcount on the TIMER_CALLBACK
// The refcount will be released in the TimerCallback().

// Release the ref count if callback is NOT pending.
DWORD TIMER_PROCESSOR::TimprocCancelTimer (void) {

   HRESULT HResult = S_OK;

   if (m_TimerHandle != NULL) {

       if (DeleteTimerQueueTimer(NATH323_TIMER_QUEUE, m_TimerHandle, NULL)) {

           DecrementLifetimeCounter ();
       }
       else {

           HResult = GetLastError ();
       }

       m_TimerHandle = NULL;  
   }

   return HResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\timer.h ===
/*++

Copyright (c) 1998 - 2000  Microsoft Corporation

Module Name:

    timer.h

Abstract:

    Contains:
        Declarations of classes, routines and constants needed for
        timer manipulations.

Environment:

    User Mode - Win32

History:
    
    1. 14-Feb-2000 -- File creation                     Ilya Kleyman  (ilyak)

--*/
#ifndef    __h323ics_timer_h
#define    __h323ics_timer_h


#define    NATH323_TIMER_QUEUE        NULL            // use default timer queue

// Classes (Q931 src, dest and H245) inheriting
// from this create timers
// this class provides the callback method for the event manager

class TIMER_PROCESSOR
{
protected:
    TIMER_HANDLE        m_TimerHandle;            // RTL timer queue timer

public:

    TIMER_PROCESSOR            (void)
    :    m_TimerHandle        (NULL)
    {}

    // This method is implemented by Q931_INFO and LOGICAL_CHANNEL
    virtual void TimerCallback    (void) = 0;

    virtual void IncrementLifetimeCounter (void) = 0;
    virtual void DecrementLifetimeCounter (void) = 0;
        
    DWORD TimprocCreateTimer    (
        IN    DWORD    Interval);            // in milliseconds

    DWORD TimprocCancelTimer    (void);
};

#endif // __h323ics_timer_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\util.cpp ===
#include "stdafx.h"

#if	defined(DBG)

void Debug (LPCWSTR Text)
{
	UNICODE_STRING	UnicodeString;
	ANSI_STRING		AnsiString;
	NTSTATUS		Status;

	assert (Text);

    if (DebugLevel > 0) {

        RtlInitUnicodeString (&UnicodeString, Text);

        Status = RtlUnicodeStringToAnsiString (&AnsiString, &UnicodeString, TRUE);
        
        if (NT_SUCCESS (Status)) {

            OutputDebugStringA (AnsiString.Buffer);
            RtlFreeAnsiString (&AnsiString);
        }
    }
}

void DebugVa (LPCTSTR Format, va_list VaList)
{
	TCHAR	Text	[0x200];

	_vsntprintf (Text, 0x200, Format, VaList);
	Debug (Text);
}

void DebugF (LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);
}

void DumpError (DWORD ErrorCode)
{
	TCHAR	Text	[0x200];
	DWORD	TextLength;
	DWORD	MaxLength;
	LPTSTR	Pos;

	_tcscpy (Text, _T("\tError: "));
	Pos = Text + _tcslen (Text);

	MaxLength = 0x200 - (DWORD)(Pos - Text);

	TextLength = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, ErrorCode, LANG_NEUTRAL, Text, 0x200, NULL);
	if (!TextLength)
		_sntprintf (Pos, MaxLength, _T("Uknown error %08XH %u"), ErrorCode, ErrorCode);

	_tcsncat (Text, _T("\n"), MaxLength);
	Text [MaxLength - 1] = 0;

	Debug (Text);
}

void DebugError (DWORD ErrorCode, LPCTSTR Text)
{
	Debug (Text);
	DumpError (ErrorCode);
}

void DebugErrorF (DWORD ErrorCode, LPCTSTR Format, ...)
{
	va_list	VaList;

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

void DebugLastError (LPCTSTR Text)
{
	DebugError (GetLastError(), Text);
}

void DebugLastErrorF (LPCTSTR Format, ...)
{
	va_list	VaList;
	DWORD	ErrorCode;

	ErrorCode = GetLastError();

	va_start (VaList, Format);
	DebugVa (Format, VaList);
	va_end (VaList);

	DumpError (ErrorCode);
}

static __inline CHAR ToHexA (UCHAR x)
{
	x &= 0xF;
	if (x < 10) return x + '0';
	return (x - 10) + 'A';
}

void DumpMemory (const UCHAR * Data, ULONG Length)
{
	const UCHAR *	DataPos;		// position within data
	const UCHAR *	DataEnd;		// end of valid data
	const UCHAR *	RowPos;		// position within a row
	const UCHAR *	RowEnd;		// end of single row
	CHAR			Text	[0x100];
	LPSTR			TextPos;
	ULONG			RowWidth;

	assert (Data);

    if (DebugLevel > 1) {

        DataPos = Data;
        DataEnd = Data + Length;

        while (DataPos < DataEnd) {
            RowWidth = (DWORD)(DataEnd - DataPos);

            if (RowWidth > 16)
                RowWidth = 16;

            RowEnd = DataPos + RowWidth;

            TextPos = Text;
            *TextPos++ = '\t';

            for (RowPos = DataPos; RowPos < RowEnd; RowPos++) {
                *TextPos++ = ToHexA ((*RowPos >> 4) & 0xF);
                *TextPos++ = ToHexA (*RowPos & 0xF);
                *TextPos++ = ' ';
            }

            *TextPos++ = '\r';
            *TextPos++ = '\n';
            *TextPos = 0;

            OutputDebugStringA (Text);

            assert (RowEnd > DataPos);		// make sure we are walking forward

            DataPos = RowEnd;
        }
    }
}

#endif // defined(DBG)

// LIFETIME_CONTROLLER  -------------------------------------------------------------------------

LIFETIME_CONTROLLER::LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter) {

	ReferenceCount = 0L;

	AssociatedSyncCounter = AssocSyncCounter;

	if (AssociatedSyncCounter)
		AssociatedSyncCounter -> Increment ();

#if ENABLE_REFERENCE_HISTORY
	InitializeCriticalSection (&ReferenceHistoryLock);

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();
		
		InsertTailList (&AssociatedSyncCounter -> ActiveLifetimeControllers, &ListEntry);

		AssociatedSyncCounter -> Unlock ();
	
	}
#endif // ENABLE_REFERENCE_HISTORY
}

LIFETIME_CONTROLLER::~LIFETIME_CONTROLLER () {

#if ENABLE_REFERENCE_HISTORY

	if (AssociatedSyncCounter) {
		
		AssociatedSyncCounter -> Lock ();

		RemoveEntryList(&ListEntry);

		AssociatedSyncCounter -> Unlock ();
	}

	DeleteCriticalSection(&ReferenceHistoryLock);
#endif // ENABLE_REFERENCE_HISTORY

	_ASSERTE (ReferenceCount == 0L);
}

void LIFETIME_CONTROLLER::AddRef (void) {

	LONG Count;

	_ASSERTE (ReferenceCount >= 0L);

	Count = InterlockedIncrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif //ENABLE_REFERENCE_HISTORY

}

void LIFETIME_CONTROLLER::Release (void) {

	LONG	Count;

	Count = InterlockedDecrement (&ReferenceCount);

#if ENABLE_REFERENCE_HISTORY
	MAKE_REFERENCE_HISTORY_ENTRY ();
#endif // ENABLE_REFERENCE_HISTORY
	
	_ASSERTE (Count >= 0);

	if (Count == 0) {

		SYNC_COUNTER * LocalAssociatedSyncCounter;

		LocalAssociatedSyncCounter = AssociatedSyncCounter;

		delete this;	

		if (LocalAssociatedSyncCounter)
			LocalAssociatedSyncCounter -> Decrement ();
	}
}


// SYNC_COUNTER -------------------------------------------------------------------------

SYNC_COUNTER::SYNC_COUNTER () {

	CounterValue = 0;
	ZeroEvent =  NULL;
}

SYNC_COUNTER::~SYNC_COUNTER () {

}

HRESULT SYNC_COUNTER::Start (void)
{
	HRESULT Result = S_OK;

	assert (ZeroEvent == NULL);

	CounterValue = 1;

	ZeroEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

	if (!ZeroEvent) {

		Result = GetLastError ();

		DebugLastError (_T("SYNC_COUNTER::SYNC_COUNTER: failed to create zero event\n"));
	}

#if ENABLE_REFERENCE_HISTORY
	Lock ();

	InitializeListHead (&ActiveLifetimeControllers);

	Unlock ();
#endif // ENABLE_REFERENCE_HISTORY

	return Result;
}

void SYNC_COUNTER::Stop () {

	if (ZeroEvent) {
		CloseHandle (ZeroEvent);
		ZeroEvent = NULL;
	}
}

DWORD SYNC_COUNTER::Wait (DWORD Timeout)
{
	if (!ZeroEvent) {
		Debug (_T("SYNC_COUNTER::Wait: cannot wait because zero event could not be created\n"));
		return ERROR_GEN_FAILURE;
	}

	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	}

	Unlock ();

#if	DBG

	if (Timeout == INFINITE) {

		DWORD	Status;

		for (;;) {

			Status = WaitForSingleObject (ZeroEvent, 5000);

			if (Status == WAIT_OBJECT_0)
				return ERROR_SUCCESS;

            assert (Status == WAIT_TIMEOUT);

			DebugF (_T("SYNC_COUNTER::Wait: thread %08XH is taking a long time to wait for sync counter, counter value (%d)\n"),
				GetCurrentThreadId(), CounterValue);
		}
	}
	else
		return WaitForSingleObject (ZeroEvent, Timeout);


#else

	return WaitForSingleObject (ZeroEvent, Timeout);

#endif
}

void SYNC_COUNTER::Increment (void)
{
	Lock();

	CounterValue++;

	Unlock();
}

void SYNC_COUNTER::Decrement (void)
{
	Lock();

	assert (CounterValue > 0);

	if (--CounterValue == 0) {
		if (ZeroEvent)
			SetEvent (ZeroEvent);
	} 

	Unlock();
}



EXTERN_C void MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source)
{
	PLIST_ENTRY		Entry;

	// for now, we do a poor algorithm -- remove and insert every single object

	AssertListIntegrity (Source);
	AssertListIntegrity (Result);

	while (!IsListEmpty (Source)) {
		Entry = RemoveHeadList (Source);
		assert (!IsInList (Result, Entry));
		InsertTailList (Result, Entry);
	}
}

// check to see if entry is in list
EXTERN_C BOOL IsInList (LIST_ENTRY * List, LIST_ENTRY * Entry)
{
	LIST_ENTRY *	Pos;

	AssertListIntegrity (List);

	for (Pos = List -> Flink; Pos != List; Pos = Pos -> Flink)
		if (Pos == Entry)
			return TRUE;

	return FALSE;
}

EXTERN_C void ExtractList (LIST_ENTRY * Destination, LIST_ENTRY * Source)
{
	AssertListIntegrity (Source);

	InsertTailList (Source, Destination);
	RemoveEntryList (Source);
	InitializeListHead (Source);
}

EXTERN_C DWORD CountListLength (LIST_ENTRY * ListHead)
{
	LIST_ENTRY *	ListEntry;
	DWORD			Count;

	assert (ListHead);
	AssertListIntegrity (ListHead);

	Count = 0;

	for (ListEntry = ListHead -> Flink; ListEntry != ListHead; ListEntry++)
		Count++;

	return Count;
}

void AssertListIntegrity (LIST_ENTRY * list)
{
	LIST_ENTRY *	entry;

	assert (list);
	assert (list -> Flink -> Blink == list);
	assert (list -> Blink -> Flink == list);

	for (entry = list -> Flink; entry != list; entry = entry -> Flink) {
		assert (entry);
		assert (entry -> Flink -> Blink == entry);
		assert (entry -> Blink -> Flink == entry);
	}
}

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString)
{
//	assert (SourceString);
//	assert (SourceString -> Buffer);
	assert (DestString);

	if (SourceString) {

		// it's really SourceString -> Length, not * sizeof (CHAR), so don't change it
		DestString -> Buffer = (LPSTR) HeapAlloc (GetProcessHeap(), 0, SourceString -> Length);

		if (DestString -> Buffer) {

			memcpy (DestString -> Buffer, SourceString -> Buffer, SourceString -> Length);

			// yes, maxlen = len, not maxlen = maxlen
			DestString -> MaximumLength = SourceString -> Length;
			DestString -> Length = SourceString -> Length;

			return STATUS_SUCCESS;
		}
		else {
			ZeroMemory (DestString, sizeof (ANSI_STRING));

			return STATUS_NO_MEMORY;
		}
	}
	else {
		DestString -> Buffer = NULL;
		DestString -> MaximumLength = 0;
		DestString -> Length = 0;
		
		return STATUS_SUCCESS;
	}
}

void FreeAnsiString (
	IN	ANSI_STRING *	String)
{
	assert (String);

	if (String -> Buffer) {
		HeapFree (GetProcessHeap(), 0, String -> Buffer);
		String -> Buffer = NULL;
	}
}


#if DBG

void ExposeTimingWindow (void) 
{
#if 0
	// this is here mostly to catch bug #393393, a/v on shutdown (race condition) -- arlied

	Debug (_T("H323: waiting for 10s to expose race condition... (expect assertion failure on NatHandle)\n"));

	DWORD Count;

	for (Count = 0; Count < 10; Count++) {
		assert (NatHandle);
		Sleep (1000);

	}

	Debug (_T("H323: finished waiting for race condition, looks normal...\n"));
#endif
}
#endif

/*++

Routine Description:
    Get the address of the best interface that
    will be used to connect to the address specified.
    
Arguments:
    DestinationAddress (IN) - address to be connected to, host order
    InterfaceAddress  (OUT) - address of the interface that
                              will be used for connection, host order
    
Return Values:
    Win32 error specifying the outcome of the request
    
Notes:

    Tries to use UDP-connect procedure to find the address of the interface
    If the procedure fails, then tries an alternative way of consulting
    the routing table, with GetBestInterface.

--*/
ULONG GetBestInterfaceAddress (
    IN DWORD DestinationAddress, // host order
    OUT DWORD * InterfaceAddress)  // host order
{

    SOCKET UDP_Socket;
    ULONG Error; 
    SOCKADDR_IN         ClientAddress;
    SOCKADDR_IN         LocalToClientAddress;
    INT                 LocalToClientAddrSize = sizeof (SOCKADDR_IN);

    Error = S_OK;

    ClientAddress.sin_addr.s_addr = htonl (DestinationAddress); 
    ClientAddress.sin_port        = htons (0);
    ClientAddress.sin_family      = AF_INET;

    UDP_Socket = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if (UDP_Socket == INVALID_SOCKET){

        Error = WSAGetLastError ();
         
        DebugLastError (_T("GetBestInterfaceAddress: failed to create UDP socket.\n"));

    } else {

        if (SOCKET_ERROR != connect (UDP_Socket, (PSOCKADDR)&ClientAddress, sizeof (SOCKADDR_IN))) {

            LocalToClientAddrSize = sizeof (SOCKADDR_IN);

            if (!getsockname (UDP_Socket, (struct sockaddr *)&LocalToClientAddress, &LocalToClientAddrSize)) {

                *InterfaceAddress = ntohl (LocalToClientAddress.sin_addr.s_addr);

                Error = ERROR_SUCCESS;

            } else {

                Error = WSAGetLastError ();

                DebugLastError (_T("GetBestInterfaceAddress: failed to get name of UDP socket.\n"));
            }

        } else {

            Error = WSAGetLastError ();

            DebugLastError (_T("GetBestInterfaceAddress: failed to connect UDP socket."));
        }

        closesocket (UDP_Socket);
        UDP_Socket = INVALID_SOCKET;
    } 

    return Error; 
}


DWORD
H323MapAdapterToAddress (
    IN DWORD AdapterIndex
    )

/*++

Routine Description:

    This routine is invoked to map an adapter index to an IP address.
    It does so by obtaining the stack's address table, and then linearly
    searching through it trying to find an entry with matching adapter
    index. If found, the entry is then used to obtain the IP address
    corresponding to the adapter index.

Arguments:

    AdapterIndex - Index of a local adapter for which an IP address is requested

Return Value:

    DWORD - IP address (in host order)

    If the routine succeeds, the return value will be a valid IP address
    If the routine fails, the return value will be INADDR_NONE

--*/

{
    DWORD Address = htonl (INADDR_NONE);
    ULONG Index;
    PMIB_IPADDRTABLE Table;

    if (AllocateAndGetIpAddrTableFromStack (
            &Table, FALSE, GetProcessHeap (), 0
            ) == NO_ERROR) {

        for (Index = 0; Index < Table -> dwNumEntries; Index++) {

            if (Table -> table[Index].dwIndex != AdapterIndex) {

                 continue;

            }

            Address = Table -> table [Index].dwAddr;

            break;
        }

        HeapFree (GetProcessHeap (), 0, Table);
    }

    return ntohl (Address);
} // H323MapAddressToAdapter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algconn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ALGconn.h

Abstract:

    This module contains declarations for the ALG transparent proxy's
    connection-management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once

#define ALG_BUFFER_RESERVE      12

//
// Structure:   ALG_CONNECTION
//
// This structure encapsulates information about a control-channel accepted
// on one of the interfaces over which the component is enabled.
// Each entry is stored in the connection list of an interface,
// and is uniquely identified by a 32-bit identifier assigned when the entry
// is created.
// As connection-requests are accepted for a connection-entry,
// endpoints are created in the connection's list.
// Access to the list is synchronized using the interface lock
// for the interface on which the connection was created.
//

typedef struct _ALG_CONNECTION {
    LIST_ENTRY Link;
    ULONG ConnectionId;
    PALG_INTERFACE Interfacep;
    LIST_ENTRY ActiveEndpointList;
} ALG_CONNECTION, *PALG_CONNECTION;

typedef enum {
    AlgClientEndpointType,
    AlgHostEndpointType,
    AlgMaximumEndpointType
} ALG_ENDPOINT_TYPE, *PALG_ENDPOINT_TYPE;

//
// Structure:   ALG_ENDPOINT
//
// This structure encapsulates information about a ALG endpoint,
// which is an active endpoint transferring data between a client and a host.
// Each endpoint is stored in the endpoint list of the connection for which
// it was created, and in the endpoint list of its connection's interface.
//

typedef struct _ALG_ENDPOINT {
    LIST_ENTRY ConnectionLink;
    LIST_ENTRY InterfaceLink;
    ULONG EndpointId;
    ULONG ConnectionId;
    PALG_INTERFACE Interfacep;
    ULONG Flags;
    ALG_ENDPOINT_TYPE Type;
    SOCKET ClientSocket;
    SOCKET HostSocket;
    ULONG BoundaryAddress;
    ULONG ActualClientAddress;
    ULONG ActualHostAddress;
    ULONG DestinationAddress;
    ULONG SourceAddress;
    ULONG NewDestinationAddress;
    ULONG NewSourceAddress;
    USHORT ActualClientPort;
    USHORT ActualHostPort;
    USHORT DestinationPort;
    USHORT SourcePort;
    USHORT NewDestinationPort;
    USHORT NewSourcePort;
    USHORT ReservedPort;
} ALG_ENDPOINT, *PALG_ENDPOINT;

#define ALG_ENDPOINT_FLAG_INITIAL_ENDPOINT  0x00000001
#define ALG_ENDPOINT_FLAG_CLIENT_CLOSED     0x00000002
#define ALG_ENDPOINT_FLAG_HOST_CLOSED       0x00000004
#define ALG_ENDPOINT_FLAG_DELETE_CONNECTION 0x00000008

//
// ROUTINE DECLARATIONS
//

ULONG
AlgActivateActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp
    );

VOID
AlgCloseActiveEndpoint(
    PALG_ENDPOINT Endpointp,
    SOCKET ClosedSocket
    );

ULONG
AlgCreateActiveEndpoint(
    PALG_CONNECTION Connectionp,
    ALG_ENDPOINT_TYPE Type,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    ULONG RemoteAddress,
    USHORT RemotePort,
    ULONG BoundaryAddress,
    OUT PALG_ENDPOINT* EndpointCreated OPTIONAL
    );

ULONG
AlgCreateConnection(
    PALG_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    OUT PALG_CONNECTION* ConnectionCreated OPTIONAL
    );

VOID
AlgDeleteActiveEndpoint(
    PALG_ENDPOINT Endpointp
    );

VOID
AlgDeleteConnection(
    PALG_CONNECTION Connectionp
    );

PALG_ENDPOINT
AlgLookupActiveEndpoint(
    PALG_CONNECTION Connectionp,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

PALG_CONNECTION
AlgLookupConnection(
    PALG_INTERFACE Interfacep,
    ULONG ConnectionId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

PALG_ENDPOINT
AlgLookupInterfaceEndpoint(
    PALG_INTERFACE Interfacep,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
AlgReadActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpoint,
    SOCKET Socket,
    ULONG UserFlags OPTIONAL
    );

ULONG
AlgWriteActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpoint,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG UserFlags OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\util.h ===
#ifndef	__h323ics_util_h
#define	__h323ics_util_h

extern  "C" DWORD   DebugLevel;

EXTERN_C	BOOL	IsInList		(LIST_ENTRY * ListHead, LIST_ENTRY * ListEntry);
EXTERN_C	void	ExtractList		(LIST_ENTRY * DestinationListHead, LIST_ENTRY * SourceListHead);
EXTERN_C	DWORD	CountListLength		(LIST_ENTRY * ListHead);
EXTERN_C	void 	MergeLists (PLIST_ENTRY Result, PLIST_ENTRY Source);
EXTERN_C	void	AssertListIntegrity	(LIST_ENTRY * ListHead);

#define INET_NTOA(a) inet_ntoa(*(struct in_addr*)&(a))

typedef HANDLE TIMER_HANDLE;

__inline
LPWSTR AnsiToUnicode (LPCSTR string, LPWSTR buffer, DWORD buffer_len)
{
    int x;

    x = MultiByteToWideChar (CP_ACP, 0, string, -1, buffer, buffer_len);
    buffer [x] = 0;

    return buffer;
}

__inline
LPSTR UnicodeToAnsi (LPCWSTR string, LPSTR buffer, DWORD buffer_len)
{
    int x;

    x = WideCharToMultiByte (CP_ACP, 0, string, -1, buffer, buffer_len,
                             NULL, FALSE);
    buffer [x] = 0;

    return buffer;
}

class	TIMER_PROCESSOR;
class   OVERLAPPED_PROCESSOR;

class	Q931_INFO;
class	SOURCE_Q931_INFO;
class	DEST_Q931_INFO;

class	LOGICAL_CHANNEL;
class	H245_INFO;
class	SOURCE_H245_INFO;
class	DEST_H245_INFO;

class	H323_STATE;
class	SOURCE_H323_STATE;
class	DEST_H323_STATE;

class	CALL_BRIDGE;

#ifdef __cplusplus
template <class T>
inline BOOL BadReadPtr(T* p, DWORD dwSize = 1)
{
    return IsBadReadPtr(p, dwSize * sizeof(T));
}

template <class T>
inline BOOL BadWritePtr(T* p, DWORD dwSize = 1)
{
    return IsBadWritePtr(p, dwSize * sizeof(T));
}
#endif


#if defined(DBG)

void	Debug	(LPCTSTR);
void	DebugF	(LPCTSTR, ...);
void	DebugError	(DWORD, LPCTSTR);
void	DebugErrorF	(DWORD, LPCTSTR, ...);
void	DebugLastError	(LPCTSTR);
void	DebugLastErrorF	(LPCTSTR, ...);

void	DumpMemory (const UCHAR * Data, ULONG Length);
void	DumpError	(DWORD);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifdef __cplusplus
}
#endif // __cplusplus

#else // !defined(DBG)

static	__inline	void	Debug	(LPCTSTR)					{}
static	__inline	void	DebugF	(LPCTSTR, ...)				{}
static	__inline	void	DebugError	(DWORD, LPCTSTR)		{}
static	__inline	void	DebugErrorF	(DWORD, LPCTSTR, ...)	{}
static	__inline	void	DebugLastError	(LPCTSTR)	{}
static	__inline	void	DebugLastErrorF	(LPCTSTR, ...)	{}

static	__inline	void	DumpMemory (const UCHAR * Data, ULONG Length)		{}
static	__inline	void	DumpError	(DWORD) {}

#endif // defined(DBG)


#ifdef _ASSERTE
#undef _ASSERTE
#endif // _ASSERTE

#ifdef	assert
#undef	assert
#endif

#if	DBG

// The latest and greatest Proxy assert
__inline void PxAssert(LPCTSTR file, DWORD line, LPCTSTR condition)
{
	DebugF (_T("%s(%d) : Assertion failed, condition: %s\n"),
            file, line, condition);
	DebugBreak();
}

#define	_ASSERTE(condition)	if(condition);else\
	{ PxAssert(_T(__FILE__), __LINE__, _T(#condition)); }

#define	assert	_ASSERTE

__inline void PxAssertNeverReached (LPCTSTR File, DWORD Line)
{
	DebugF (_T("%s(%d) : Assertion failure, code path should never be executed\n"),
		File, Line);
	DebugBreak();
}

#define	AssertNeverReached() PxAssertNeverReached (_T(__FILE__), __LINE__);

#else // !DBG

#define	_ASSERTE(condition)			NOP_FUNCTION
#define	assert						NOP_FUNCTION
#define	AssertNeverReached()		NOP_FUNCTION

#endif // DBG




// 0,1,2,3 : count of bytes from MSB to LSB in host order
#define BYTE0(l) ((BYTE)((DWORD)(l) >> 24))
#define BYTE1(l) ((BYTE)((DWORD)(l) >> 16))
#define BYTE2(l) ((BYTE)((DWORD)(l) >> 8))
#define BYTE3(l) ((BYTE)((DWORD)(l)))

// Handy macro to use in printf statements
#define BYTES0123(l) BYTE0(l), BYTE1(l), BYTE2(l), BYTE3(l)

// 0,1,2,3 : count of bytes from MSB to LSB in network order
#define NETORDER_BYTE0(l) ((BYTE)((BYTE *) &l)[0])
#define NETORDER_BYTE1(l) ((BYTE)((BYTE *) &l)[1])
#define NETORDER_BYTE2(l) ((BYTE)((BYTE *) &l)[2])
#define NETORDER_BYTE3(l) ((BYTE)((BYTE *) &l)[3])

#define	SOCKADDR_IN_PRINTF(SocketAddress) \
	ntohl ((SocketAddress) -> sin_addr.s_addr), \
	ntohs ((SocketAddress) -> sin_port)

// Handy macro to use in printf statements
#define NETORDER_BYTES0123(l) NETORDER_BYTE0(l), NETORDER_BYTE1(l), \
                             NETORDER_BYTE2(l), NETORDER_BYTE3(l)

static __inline LONG RegQueryValueString (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	LPTSTR	ReturnString,
	IN	DWORD	StringMax)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (TCHAR) * StringMax;
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnString, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_SZ)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}

static __inline LONG RegQueryValueDWORD (
	IN	HKEY	Key,
	IN	LPCTSTR	ValueName,
	OUT	DWORD *	ReturnValue)
{
	DWORD	ValueLength;
	DWORD	Type;
	LONG	Status;

	ValueLength = sizeof (DWORD);
	Status = RegQueryValueEx (Key, ValueName, NULL, &Type, (LPBYTE) ReturnValue, &ValueLength);

	if (Status != ERROR_SUCCESS)
		return Status;

	if (Type != REG_DWORD)
		return ERROR_INVALID_PARAMETER;

	return ERROR_SUCCESS;
}


class	SIMPLE_CRITICAL_SECTION_BASE
{
protected:

	CRITICAL_SECTION		CriticalSection;

protected:

	void	Lock			(void)	{ EnterCriticalSection (&CriticalSection); }
	void	Unlock			(void)	{ LeaveCriticalSection (&CriticalSection); }
	void	AssertLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) == GetCurrentThreadId()); }
	void	AssertNotLocked	(void)	{ assert (!CriticalSection.OwningThread); }
	void	AssertThreadNotLocked	(void)	{ assert (PtrToUlong(CriticalSection.OwningThread) != GetCurrentThreadId()); }

protected:

	SIMPLE_CRITICAL_SECTION_BASE	(void) {
		InitializeCriticalSection (&CriticalSection);
	}

	~SIMPLE_CRITICAL_SECTION_BASE	(void)	{
		if (CriticalSection.OwningThread) {
			DebugF (_T("SIMPLE_CRITICAL_SECTION_BASE::~SIMPLE_CRITICAL_SECTION_BASE: thread %08XH stills holds this critical section (this %p)\n"),
				PtrToUlong(CriticalSection.OwningThread), this);
		}

		AssertNotLocked();
		DeleteCriticalSection (&CriticalSection);
	}
};

#if ENABLE_REFERENCE_HISTORY
#include "dynarray.h"
#endif // ENABLE_REFERENCE_HISTORY

class SYNC_COUNTER;

class LIFETIME_CONTROLLER 
{
#if ENABLE_REFERENCE_HISTORY
public:
	LIST_ENTRY ListEntry;

	struct REFERENCE_HISTORY {
		LONG CurrentReferenceCount;
		PVOID CallersAddress;
	};

	DYNAMIC_ARRAY <REFERENCE_HISTORY> ReferenceHistory;
	CRITICAL_SECTION ReferenceHistoryLock;

#define MAKE_REFERENCE_HISTORY_ENTRY() {                                           \
		PVOID CallersAddress, CallersCallersAddress;							   \
		RtlGetCallersAddress (&CallersAddress, &CallersCallersAddress);            \
		EnterCriticalSection (&ReferenceHistoryLock);                              \
		REFERENCE_HISTORY * ReferenceHistoryNode = ReferenceHistory.AllocAtEnd (); \
		ReferenceHistoryNode -> CallersAddress = CallersAddress;                   \
		ReferenceHistoryNode -> CurrentReferenceCount = Count;                     \
		LeaveCriticalSection (&ReferenceHistoryLock);                              \
	}

#endif //ENABLE_REFERENCE_HISTORY

private:

	LONG ReferenceCount;
	SYNC_COUNTER * AssociatedSyncCounter;

protected: 

	LIFETIME_CONTROLLER (SYNC_COUNTER * AssocSyncCounter = NULL);
	virtual	~LIFETIME_CONTROLLER ();

public:

	void AddRef (void);

	void Release (void);
};


template <DWORD SampleHistorySize>
class SAMPLE_PREDICTOR {
public:

    SAMPLE_PREDICTOR (void) {
        
        ZeroMemory ((PVOID) &Samples[0],       sizeof (Samples));

        FirstSampleIndex    = 0;
        SamplesArraySize    = 0;
    }

    HRESULT AddSample (LONG Sample) {

        DWORD    ThisSampleIndex;

        if (0UL == SampleHistorySize)
            return E_ABORT;

        if (SamplesArraySize < SampleHistorySize) {

            ThisSampleIndex = SamplesArraySize;

            SamplesArraySize++;

        } else {

            ThisSampleIndex = FirstSampleIndex; // Overwrite the least recent sample

            FirstSampleIndex++;

            FirstSampleIndex %= SampleHistorySize;
        }
        
        Samples [ThisSampleIndex] = Sample; 

        return S_OK;
    }

    LONG PredictNextSample (void) {

        DWORD  Index;
        DWORD  CurrentSampleIndex;

        LONG   Coefficient = 0;
        LONG   Prediction  = 0;

        if (0 == SampleHistorySize)
            return 0;

        for (Index = 0; Index < SamplesArraySize; Index++) {

            if (0 == Index) {

               Coefficient = (LONG)((SamplesArraySize & 1) << 1) - 1; // 1 or -1

            } else {

               Coefficient *= (LONG) Index - (LONG) SamplesArraySize - 1;
               Coefficient /= (LONG) Index;
            }

            CurrentSampleIndex = (FirstSampleIndex + Index) % SamplesArraySize;

            Prediction += Coefficient * Samples [CurrentSampleIndex];

        }

        return Prediction;
    }

#if DBG
    void PrintSamples (void) {
        DWORD Index;

        if (SamplesArraySize) {
            DebugF (_T("Samples in predictor %p are: \n"), this);

            for (Index = 0; Index < SamplesArraySize; Index++) 
                DebugF (_T("\t@%d(%d)-- %d\n"), Index, Index < FirstSampleIndex ? SamplesArraySize - (FirstSampleIndex - Index) : Index - FirstSampleIndex, Samples[Index]);
        } else {
            DebugF (_T("There are no samples in predictor %p.\n"), this);
        }
    }
#endif 

    HRESULT RetrieveOldSample (
            IN DWORD StepsInThePast, // 0 -- most recent sample 
            OUT LONG * OldSample) {

        DWORD SampleIndex;

        if (0 == SampleHistorySize)
            return E_ABORT;

        if (StepsInThePast < SamplesArraySize) {
            // Valid request

            _ASSERTE (SamplesArraySize);

            SampleIndex = (SamplesArraySize + FirstSampleIndex - StepsInThePast - 1) % SamplesArraySize;

            *OldSample = Samples [SampleIndex];

            return S_OK;
        }

        return ERROR_INVALID_DATA;
    }

private:

    LONG    Samples       [SampleHistorySize];           // This is where samples are kept
    LONG    PositiveTerms [SampleHistorySize];  
    LONG    NegativeTerms [SampleHistorySize];  
    DWORD   SamplesArraySize;
    DWORD   FirstSampleIndex;                            // Index of the least recent sample
};

static __inline HRESULT GetLastErrorAsResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

static __inline HRESULT GetLastResult (void) {
	return GetLastError() == ERROR_SUCCESS ? S_OK : HRESULT_FROM_WIN32 (GetLastError());
}

// A sync counter is an integer counter.
// It is kind of the opposite of a semaphore.
// When the counter is zero, the sync counter is signaled.
// When the counter is nonzero, the sync counter is not signaled.

class	SYNC_COUNTER :
public	SIMPLE_CRITICAL_SECTION_BASE
{
	friend class LIFETIME_CONTROLLER;

private:

	LONG		CounterValue;			// the current value of the counter
	HANDLE		ZeroEvent;				// signaled when CounterValue = 0

public:
#if ENABLE_REFERENCE_HISTORY
	LIST_ENTRY ActiveLifetimeControllers;
#endif // ENABLE_REFERENCE_HISTORY


	SYNC_COUNTER ();
	~SYNC_COUNTER ();

	HRESULT	Start (void);
    void Stop (void);

	void	Increment	(void);
	void	Decrement	(void);

	DWORD	Wait		(DWORD Timeout);
};



#define	HRESULT_FROM_WIN32_ERROR_CODE		HRESULT_FROM_WIN32
#define	HRESULT_FROM_WINSOCK_ERROR_CODE		HRESULT_FROM_WINSOCK_ERROR_CODE

// ASN.1 utility functions

// Setup_UUIE&
// SetupMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define SetupMember(pH323UserInfo)                          \
    (pH323UserInfo)->h323_uu_pdu.h323_message_body.u.setup

// Returns a non-zero value only. So don't try comparing it with TRUE/FALSE
// BOOL
// IsDestCallSignalAddressPresent(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define IsDestCallSignalAddressPresent(pH323UserInfo) \
    (SetupMember(pH323UserInfo).bit_mask & Setup_UUIE_destCallSignalAddress_present)

// Get the destCallSignalAddress member
// TransportAddress&
// DCSAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DCSAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destCallSignalAddress

// Get the destCallSignalAddress member
// DESTINATION_ADDRESS *&
// DestAddrMember(
//     IN H323_UserInformation *pH323UserInfo
//     );
#define DestAddrMember(pH323UserInfo) \
    SetupMember(pH323UserInfo).destinationAddress
    
// BOOL
// IsTransportAddressTypeIP(
//     IN TransportAddress Addr
//     );
#define IsTransportAddressTypeIP(Addr) \
    (Addr.choice == ipAddress_chosen)
    
// BOOL
// IPAddrMember(
//     IN TransportAddress Addr
//     );
#define IPAddrMember(Addr) \
    Addr.u.ipAddress

typedef struct Setup_UUIE_destinationAddress DESTINATION_ADDRESS;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines for filling and extracting from structures used to               //
// store Transport addresses in Q.931 and H.245 ASN                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// fills the TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
__inline void
FillTransportAddress(
    IN DWORD                IPv4Address,		// host order
    IN WORD                 Port,				// host order
    OUT TransportAddress    &TransportAddress
    )
{
	// we are filling in an IP address
    TransportAddress.choice = ipAddress_chosen;

    // fill in the port
    TransportAddress.u.ipAddress.port = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != TransportAddress.u.ipAddress.ip.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    TransportAddress.u.ipAddress.ip.length = 4;
	*((DWORD *)TransportAddress.u.ipAddress.ip.value) = 
		htonl(IPv4Address);
}

static __inline void FillTransportAddress (
	IN	const SOCKADDR_IN &	SocketAddress,
	OUT	TransportAddress &	ReturnTransportAddress)
{
	FillTransportAddress (
		ntohl (SocketAddress.sin_addr.s_addr),
		ntohs (SocketAddress.sin_port),
		ReturnTransportAddress);
}

// returns E_INVALIDARG for PDUs which can not be handled.
__inline HRESULT
GetTransportInfo(
    IN const TransportAddress	&TransportAddress,
    OUT DWORD			&IPv4Address,				// host order
    OUT WORD			&Port						// host order
    )
{
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(ipAddress_chosen & TransportAddress.choice))
	{
		DebugF( _T("GetTransportInfo(&H245Address, &0x%x, &%u), ")
            _T("non unicast address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, TransportAddress.choice);
		return E_INVALIDARG;
	}

	// fill in the port
    Port = TransportAddress.u.ipAddress.port;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != TransportAddress.u.ipAddress.ip.length)
	{
		DebugF( _T("GetTransportInfo: bogus address length (%d) in TransportAddress\n"),
			TransportAddress.u.ipAddress.ip.length);
		return E_INVALIDARG;
	}

	IPv4Address = ntohl(*((DWORD *)TransportAddress.u.ipAddress.ip.value));

	return S_OK;
}

static __inline HRESULT GetTransportInfo (
	IN	const TransportAddress &	TransportAddress,
	OUT	SOCKADDR_IN &		ReturnSocketAddress)
{
	HRESULT		Result;

	ReturnSocketAddress.sin_family = AF_INET;

	Result = GetTransportInfo (TransportAddress,
		ReturnSocketAddress.sin_addr.s_addr,
		ReturnSocketAddress.sin_port);

	ReturnSocketAddress.sin_addr.s_addr = htonl (ReturnSocketAddress.sin_addr.s_addr);
	ReturnSocketAddress.sin_port = htons (ReturnSocketAddress.sin_port);

	return Result;
}


// fills the H245TransportAddress port and address bytes with
// those specified. assumes that the passed in values are
// in host order
inline void
FillH245TransportAddress(
    IN DWORD					IPv4Address,
    IN WORD						Port,
    OUT H245TransportAddress	&H245Address
    )
{
	// we are filling in an unicast IP address
	H245Address.choice = unicastAddress_chosen;

	// alias for the unicast address
	UnicastAddress &UnicastIPAddress = H245Address.u.unicastAddress;

	// its an IP address
	UnicastIPAddress.choice = UnicastAddress_iPAddress_chosen;

    // fill in the port
    UnicastIPAddress.u.iPAddress.tsapIdentifier = Port;

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    UnicastIPAddress.u.iPAddress.network.length = 4;
	*((DWORD *)UnicastIPAddress.u.iPAddress.network.value) = 
		htonl(IPv4Address);
}

// Returned IPaddress and port are in host order
inline HRESULT
GetH245TransportInfo(
    IN const H245TransportAddress &H245Address,
    OUT DWORD			    &IPv4Address,
    OUT WORD			    &Port
    )
{
	// we proceed only if the transport address has a unicast address
    if (!(unicastAddress_chosen & H245Address.choice))
	{
		DebugF( _T("GetH245TransportInfo(&H245Address, &0x%x, &%u), ")
            _T("non unicast address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, H245Address.choice);
		return E_INVALIDARG;
	}
    
	// we proceed only if the transport address has the
    // IP address (v4) field filled
    if (!(UnicastAddress_iPAddress_chosen & 
            H245Address.u.unicastAddress.choice))
	{
		DebugF( _T("GetH245TransportInfo(&TransportAddress, &0x%x, &%u), ")
            _T("non ip address type = %d, returning E_INVALIDARG\n"),
			IPv4Address, Port, H245Address.u.unicastAddress.choice);
		return E_INVALIDARG;
	}

    const UnicastAddress & UnicastIPAddress = H245Address.u.unicastAddress;

	// fill in the port
    Port = UnicastIPAddress.u.iPAddress.tsapIdentifier;

    // 4 bytes in the IP address
    // copy the bytes into the transport address array
    if (4 != UnicastIPAddress.u.iPAddress.network.length)
	{
		DebugF( _T("GetH245TransportInfo: bogus ip address length (%d), failing\n"),
			UnicastIPAddress.u.iPAddress.network.length);

		return E_INVALIDARG;
	}

	// value is a ptr to a struct, so it can't be null
	_ASSERTE(NULL != UnicastIPAddress.u.iPAddress.network.value);
	IPv4Address = ntohl(*((DWORD *)UnicastIPAddress.u.iPAddress.network.value));

	return S_OK;
}

static __inline HRESULT GetH245TransportInfo (
	IN	const H245TransportAddress & H245Address,
	OUT	SOCKADDR_IN *		ReturnSocketAddress)
{
	DWORD	IPAddress;
	WORD	Port;
	HRESULT	Result;

	Result = GetH245TransportInfo (H245Address, IPAddress, Port);
	if (Result == S_OK) {
		ReturnSocketAddress -> sin_family = AF_INET;
		ReturnSocketAddress -> sin_addr.s_addr = htonl (IPAddress);
		ReturnSocketAddress -> sin_port = htons (Port);
	}

	return Result;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines dealing with the T.120 Parameters in H.245 PDUs                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


// In case of failure the routine returns 
// INADDR_NONE for the T120ConnectToIPAddr
inline HRESULT
GetT120ConnectToAddress(
    IN  NetworkAccessParameters  separateStack,
    OUT DWORD                   &T120ConnectToIPAddr,
    OUT WORD                    &T120ConnectToPort
    )
{
    // These are the return values in case of a failure.
    T120ConnectToIPAddr = INADDR_NONE;
    T120ConnectToPort   = 0;
    
    // CODEWORK: should we require the distribution member
    // to be present always ?
    
    if ((separateStack.bit_mask & distribution_present) &&
        (separateStack.distribution.choice != unicast_chosen))
    {
        // We support Unicast only
        return E_INVALIDARG;
    }
    
    // Deal with t120SetupProcedure
    
    if (separateStack.networkAddress.choice != localAreaAddress_chosen)
    {
        // Support only local area addresses
        return E_INVALIDARG;
    }
    
    GetH245TransportInfo(
        separateStack.networkAddress.u.localAreaAddress,
        T120ConnectToIPAddr,
        T120ConnectToPort
        );
    
    DebugF (_T ("T120: Endpoint is listening on: %08X:%04X.\n"),
            T120ConnectToIPAddr,
            T120ConnectToPort
            );

    return S_OK;
}



#define TPKT_HEADER_SIZE 4
#define TPKT_VERSION    3


inline DWORD GetPktLenFromTPKTHdr(BYTE *pbTpktHdr)
/*++

Routine Description:

	Compute the length of the packet from the TPKT header.
	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns the length of the PDU which follows the TPKT header.

--*/
{
	_ASSERTE(pbTpktHdr[0] == TPKT_VERSION);
    return ((pbTpktHdr[2] << 8) + pbTpktHdr[3]  - TPKT_HEADER_SIZE);
}

inline void SetupTPKTHeader(
     OUT BYTE *  pbTpktHdr,
     IN  DWORD   dwLength
     )
/*++

Routine Description:

	Setup the TPKT header based on the length.

	The TPKT header is four bytes long. Byte 0 gives
	the TPKT version (defined by TPKT_VERSION). Byte 1
	is reserved and should not be interpreted. Bytes 2 and 3
	together give the size of the packet (Byte 2 is the MSB and
	Byte 3 is the LSB i.e. in network byte order). (This assumes
	that the size of the packet will always fit in 2 bytes).

Arguments:
    
    

Return Values:

    Returns S_OK if the version is right and E_FAIL otherwise.

--*/
{
    _ASSERTE(pbTpktHdr);

    dwLength += TPKT_HEADER_SIZE;

    // TPKT requires that the packet size fit in two bytes.
    _ASSERTE(dwLength < (1L << 16));

    pbTpktHdr[0] = TPKT_VERSION;
    pbTpktHdr[1] = 0;
    pbTpktHdr[2] = HIBYTE(dwLength); //(BYTE)(dwLength >> 8);
    pbTpktHdr[3] = LOBYTE(dwLength); //(BYTE)dwLength;
}

static __inline BOOLEAN RtlEqualStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlEqualString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline INT RtlCompareStringConst (
	IN	const STRING *	StringA,
	IN	const STRING *	StringB,
	IN	BOOLEAN			CaseInSensitive)
{
	return RtlCompareString (
		const_cast<STRING *> (StringA),
		const_cast<STRING *> (StringB),
		CaseInSensitive);
}

static __inline void InitializeAnsiString (
	OUT	ANSI_STRING *		AnsiString,
	IN	ASN1octetstring_t *	AsnString)
{
	assert (AnsiString);
	assert (AsnString);

	AnsiString -> Buffer = (PSTR) AsnString -> value;
	AnsiString -> Length = (USHORT) AsnString -> length / sizeof (CHAR);
}

static __inline void InitializeUnicodeString (
	OUT	UNICODE_STRING *		UnicodeString,
	IN	ASN1char16string_t *	AsnString)
{
	assert (UnicodeString);
	assert (AsnString);

	UnicodeString -> Buffer = (PWSTR)AsnString -> value;
	UnicodeString -> Length = (USHORT) AsnString -> length / sizeof (WCHAR);
}

// use with "%.*s" or "%.*S"
#define	ANSI_STRING_PRINTF(AnsiString) (AnsiString) -> Length, (AnsiString) -> Buffer


// { Length, MaximumLength, Buffer }
#define	ANSI_STRING_INIT(Text) { sizeof (Text) - sizeof (CHAR), 0, (Text) } // account for NUL

void FreeAnsiString (
	IN	ANSI_STRING *	String);

NTSTATUS CopyAnsiString (
	IN	ANSI_STRING *	SourceString,
	OUT	ANSI_STRING *	DestString);

static __inline ULONG ByteSwap (
	IN	ULONG	Value)
{
	union	ULONG_SWAP	{
		BYTE	Bytes	[sizeof (ULONG)];
		ULONG	Integer;
	};
	
	ULONG_SWAP *	SwapValue;
	ULONG_SWAP		SwapResult;

	SwapValue = (ULONG_SWAP *) &Value;
	SwapResult.Bytes [0] = SwapValue -> Bytes [3];
	SwapResult.Bytes [1] = SwapValue -> Bytes [2];
	SwapResult.Bytes [2] = SwapValue -> Bytes [1];
	SwapResult.Bytes [3] = SwapValue -> Bytes [0];

	return SwapResult.Integer;
}

// does NOT convert to host order first
static __inline INT Compare_SOCKADDR_IN (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);

	if (AddressA -> sin_addr.s_addr < AddressB -> sin_addr.s_addr) return -1;
	if (AddressA -> sin_addr.s_addr > AddressB -> sin_addr.s_addr) return 1;

	return 0;
}

static __inline BOOL IsEqualSocketAddress (
	IN	const	SOCKADDR_IN *	AddressA,
	IN	const	SOCKADDR_IN *	AddressB)
{
	assert (AddressA);
	assert (AddressB);
	assert (AddressA -> sin_family == AF_INET);
	assert (AddressB -> sin_family == AF_INET);

	return AddressA -> sin_addr.s_addr == AddressB -> sin_addr.s_addr
		&& AddressA -> sin_port == AddressB -> sin_port;
}

#if DBG

void ExposeTimingWindow (void);

#endif

// Get the address of the best interface that will
// be used to connect to the DestinationAddress
ULONG GetBestInterfaceAddress (
    IN DWORD DestinationAddress,   // host order
    OUT DWORD * InterfaceAddress); // host order

DWORD
H323MapAdapterToAddress (
    IN DWORD AdapterIndex
    );
#endif // __h323ics_util_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algconn.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ALGconn.c

Abstract:

    This module contains code for the ALG transparent proxy's connection
    management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>
#include <mswsock.h>
#include <rasuip.h>

ULONG AlgNextConnectionId = 0;
ULONG AlgNextEndpointId = 0;

typedef struct _ALG_CLOSE_CONNECTION_CONTEXT {
    ULONG InterfaceIndex;
    ULONG ConnectionId;
} ALG_CLOSE_CONNECTION_CONTEXT, *PALG_CLOSE_CONNECTION_CONTEXT;

//
// FORWARD DECLARATIONS
//

ULONG NTAPI
AlgpCloseConnectionWorkerRoutine(
    PVOID Context
    );


ULONG
AlgActivateActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp
    )

/*++

Routine Description:

    This routine is invoked to initiate data transfer on an active endpoint
    once it is connected to both the client and the host.

Arguments:

    Interfacep - the interface on which the endpoint was accepted

    Endpointp - the endpoint to be activated

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on behalf of the read-requests that will
    be issued here. If a failure occurs, it is this routine's responsibility
    to release those references.

--*/

{
    ULONG Error;
    PROFILE("AlgActivateActiveEndpoint");

    //
    // Clear the 'initial-endpoint' flag on the endpoint,
    // now that it is successfully connected.
    //

    Endpointp->Flags &= ~ALG_ENDPOINT_FLAG_INITIAL_ENDPOINT;

    //
    // Initiate read-requests on each of the endpoint's sockets.
    // Note that it is the callee's responsibility to release the references
    // made to the interface on our behalf.
    //

    Error =
        AlgReadActiveEndpoint(
            Interfacep,
            Endpointp,
            Endpointp->ClientSocket,
            ALG_BUFFER_FLAG_FROM_ACTUAL_HOST
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgActivateActiveEndpoint: read error %d",
            Error
            );
        ALG_DEREFERENCE_INTERFACE(Interfacep);
    } else {
        Error =
            AlgReadActiveEndpoint(
                Interfacep,
                Endpointp,
                Endpointp->HostSocket,
                ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT
                );
    }
    return Error;
} // AlgActivateActiveEndpoint


VOID
AlgCloseActiveEndpoint(
    PALG_ENDPOINT Endpointp,
    SOCKET ClosedSocket
    )

/*++

Routine Description:

    This routine is invoked when a graceful close indication is received
    on one of the sockets for an endpoint. If both the client and the host
    have closed their sockets, the endpoint is deleted here.

Arguments:

    Endpointp - the endpoint for the closed socket

    ClosedSocket - the socket whose remote end has been closed

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PROFILE("AlgCloseActiveEndpoint");

    //
    // Propagate the shutdown from one control-channel socket to the other,
    // i.e. from client to server or server to client.
    //

    if (ClosedSocket == Endpointp->ClientSocket) {
        if (Endpointp->Flags & ALG_ENDPOINT_FLAG_CLIENT_CLOSED) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCloseActiveEndpoint: endpoint %d client-end already closed",
                Endpointp->EndpointId
                );
            return;
        }
        shutdown(Endpointp->HostSocket, SD_SEND);
        Endpointp->Flags |= ALG_ENDPOINT_FLAG_CLIENT_CLOSED;
    } else {
        if (Endpointp->Flags & ALG_ENDPOINT_FLAG_HOST_CLOSED) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCloseActiveEndpoint: endpoint %d host-end already closed",
                Endpointp->EndpointId
                );
            return;
        }
        shutdown(Endpointp->ClientSocket, SD_SEND);
        Endpointp->Flags |= ALG_ENDPOINT_FLAG_HOST_CLOSED;
    }

    //
    // If both the client and server have closed their ends of the endpoint
    // we can close the sockets and delete the endpoint.
    //

    if ((Endpointp->Flags & ALG_ENDPOINT_FLAG_CLIENT_CLOSED) &&
        (Endpointp->Flags & ALG_ENDPOINT_FLAG_HOST_CLOSED)) {
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgCloseActiveEndpoint: both sockets closed, deleting endpoint %d",
            Endpointp->EndpointId
            );
        AlgDeleteActiveEndpoint(Endpointp);
    }
} // AlgCloseActiveEndpoint


ULONG
AlgCreateActiveEndpoint(
    PALG_CONNECTION Connectionp,
    ALG_ENDPOINT_TYPE Type,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    ULONG TargetAddress,
    USHORT TargetPort,
    ULONG BoundaryAddress,
    OUT PALG_ENDPOINT* EndpointCreated OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new active endpoint when a TCP
    connection is accepted. It creates an entry for the new endpoint
    and initiates a connection-attempt to the ultimate destination
    as specified by 'Type' and 'TargetPort'.

Arguments:

    Connectionp - the connection on which the TCP connection was accepted

    Type - indicates whether the TCP connection is from a client or a host

    ListeningSocket - the listening socket on which the TCP connection was
        accepted

    AcceptedSocket - the local socket for the accepted TCP connection

    AcceptBuffer - buffer holding connection-acceptance information

    TargetAddress - the IP address to which the secondary proxy connection
        must be made on the alternate socket for the new endpoint

    TargetPort - the port to which the secondary proxy connection must be made
        on the alternate socket for the new endpoint

    BoundaryAddress - the IP address of the boundary interface from which the
        first proxy connection is from
    EndpointCreated - on output, optionally receives the newly created
        endpoint

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface for the connection-attempt which is
    initiated here and the close-notification which is requested on the
    accepted socket. If a failure occurs, it is this routine's responsibility
    to release those references.

--*/

{
    PALG_ENDPOINT Endpointp = NULL;
    ULONG Error;
    PLIST_ENTRY InsertionPoint;
    PALG_INTERFACE Interfacep = Connectionp->Interfacep;
    ULONG Length;
    SOCKADDR_IN SockAddr;
    SOCKET UdpSocket;
    PROFILE("AlgCreateActiveEndpoint");
    do {
        //
        // Update the context associated with the accepted socket,
        // to allow Winsock routines to be used with the resulting file-handle.
        //

        Error =
            setsockopt(
                AcceptedSocket,
                SOL_SOCKET,
                SO_UPDATE_ACCEPT_CONTEXT,
                (PCHAR)&ListeningSocket,
                sizeof(ListeningSocket)
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateActiveEndpoint: error %d updating accept context",
                Error
                );
            break;
        }

        //
        // Allocate and initialize a new endpoint, and insert it in the list
        // of endpoints for its interface, as well as the list of active
        // endpoints for its connection.
        //

        Endpointp = reinterpret_cast<PALG_ENDPOINT>(
                        NH_ALLOCATE(sizeof(*Endpointp))
                        );
        if (!Endpointp) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        ZeroMemory(Endpointp, sizeof(*Endpointp));
        Endpointp->EndpointId = InterlockedIncrement(
                                    reinterpret_cast<LPLONG>(&AlgNextEndpointId)
                                    );
        Endpointp->ConnectionId = Connectionp->ConnectionId;
        Endpointp->Interfacep = Interfacep;
        AlgLookupInterfaceEndpoint(
            Interfacep, Endpointp->EndpointId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Endpointp->InterfaceLink);
        AlgLookupActiveEndpoint(
            Connectionp, Endpointp->EndpointId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Endpointp->ConnectionLink);
        Endpointp->Type = Type;
        Endpointp->ClientSocket = INVALID_SOCKET;
        Endpointp->HostSocket = INVALID_SOCKET;
        Endpointp->BoundaryAddress = BoundaryAddress;

        //
        // We create a temporary UDP socket, connect the socket to the
        // actual client's IP address, extract the IP address to which
        // the socket is implicitly bound by the TCP/IP driver, and
        // discard the socket. This leaves us with the exact IP address
        // that we need to use to contact the client.
        //

        SockAddr.sin_family = AF_INET;
        SockAddr.sin_port = 0;
        SockAddr.sin_addr.s_addr = TargetAddress;
        Length = sizeof(SockAddr);
        if ((UdpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) ==
                INVALID_SOCKET ||
            connect(UdpSocket, (PSOCKADDR)&SockAddr, sizeof(SockAddr)) ==
                SOCKET_ERROR ||
            getsockname(UdpSocket, (PSOCKADDR)&SockAddr, (int*)&Length) ==
                SOCKET_ERROR) {
            Error = WSAGetLastError();
            if (Error == WSAEHOSTUNREACH && Type == AlgHostEndpointType) {
                Error = RasAutoDialSharedConnection();
                if (Error != ERROR_SUCCESS) {
                    NhTrace(
                        TRACE_FLAG_ALG,
                        "AlgCreateActiveEndpoint:"
                        " RasAutoDialSharedConnection failed [%d]",
                        Error
                        );
                    if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    break;
                }
            } else {
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgCreateActiveEndpoint: error %d routing endpoint %d "
                    "using UDP", Error, Endpointp->EndpointId
                    );
                if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }
        }
        closesocket(UdpSocket);

        //
        // Check the type of the endpoint before proceeding further:
        //  'AlgClientEndpointType' - the endpoint was accepted on a client's
        //      behalf from a remote host
        //  'AlgHostEndpointType' - the endpoint was accepted on a host's
        //      behalf from a remote client
        //

        if (Type == AlgClientEndpointType) {

            //
            // This active endpoint was accepted on behalf of a client.
            //

            Endpointp->ClientSocket = AcceptedSocket;
            Endpointp->ActualClientAddress = TargetAddress;
            Endpointp->ActualClientPort = TargetPort;
            NhQueryAcceptEndpoints(
                AcceptBuffer,
                NULL,
                NULL,
                &Endpointp->ActualHostAddress,
                &Endpointp->ActualHostPort
                );

            //
            // We now need to initiate a proxy connection to the actual client.
            // Before doing so, we need to bind to a specific IP address,
            // and issue a redirect so that the actual client will think
            // that our connection-request is coming from the actual host.
            // Create a stream socket bound to the extracted IP address,
            // determine the socket's port number, and create a redirect
            // to transform our connection-request in the eyes of the client.
            //

            Error =
                NhCreateStreamSocket(
                    SockAddr.sin_addr.s_addr, 0, &Endpointp->HostSocket
                    );
            if (Error) {
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }
            EnterCriticalSection(&AlgGlobalInfoLock);
            Error =
                NatCreateRedirectEx(
                    AlgTranslatorHandle,
                    NatRedirectFlagLoopback,
                    NAT_PROTOCOL_TCP,
                    Endpointp->ActualClientAddress,
                    Endpointp->ActualClientPort,
                    SockAddr.sin_addr.s_addr,
                    NhQueryPortSocket(Endpointp->HostSocket),
                    TargetAddress,
                    TargetPort,
                    Endpointp->ActualHostAddress,
                    Endpointp->ActualHostPort,
                    0,
                    NULL,
                    NULL,
                    NULL
                    );
            LeaveCriticalSection(&AlgGlobalInfoLock);
            if (Error) {
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgCreateActiveEndpoint: error %d creating redirect",
                    Error
                    );
                break;
            }

            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateActiveEndpoint: endpoint %d connecting socket %d "
                "to client at %s/%d",
                Endpointp->EndpointId, Endpointp->HostSocket,
                INET_NTOA(TargetAddress), RtlUshortByteSwap(TargetPort)
                );
            Error =
                NhConnectStreamSocket(
                    &AlgComponentReference,
                    Endpointp->HostSocket,
                    TargetAddress,
                    TargetPort,
                    NULL,
                    AlgConnectEndpointCompletionRoutine,
                    AlgCloseEndpointNotificationRoutine,
                    Interfacep,
                    UlongToPtr(Endpointp->EndpointId)
                    );
            if (Error) {
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgCreateActiveEndpoint: error %d connecting to %s",
                    Error,
                    INET_NTOA(TargetAddress)
                    );
                break;
            }
        } else {
            ULONG AddressToUse;

            //
            // This active endpoint was accepted on behalf of a host.
            // We now initiate a proxy connection to the actual host.
            //

            Endpointp->HostSocket = AcceptedSocket;
            Endpointp->ActualHostAddress = TargetAddress;
            Endpointp->ActualHostPort = TargetPort;
            NhQueryAcceptEndpoints(
                AcceptBuffer,
                NULL,
                NULL,
                &Endpointp->ActualClientAddress,
                &Endpointp->ActualClientPort
                );

            //
            // If we grabbed a send address above, use it to bind the
            // socket; otherwise, leave the address unspecified
            //

            AddressToUse = AlgFirewallIfCount
                               ? SockAddr.sin_addr.s_addr
                               : INADDR_NONE;
            //
            // Initiate a connection to the actual host
            //

            Error =
                NhCreateStreamSocket(
                    AddressToUse, 0, &Endpointp->ClientSocket
                    );
            if (Error) {
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }

            //
            // If we have a firwewall interface, possibly install a
            // shadow redirect for this connection. The shadow redirect
            // is necessary to prevent this connection from also being
            // redirected to the proxy (setting in motion an infinite loop...)
            //

            if (AlgFirewallIfCount) {
                ULONG SourceAddress =
                    NhQueryAddressSocket(Endpointp->ClientSocket);
                USHORT SourcePort =
                    NhQueryPortSocket(Endpointp->ClientSocket);

                Error =
                    NatCreateRedirectEx(
                        AlgTranslatorHandle,
                        0,
                        NAT_PROTOCOL_TCP,
                        TargetAddress,
                        TargetPort,
                        SourceAddress,
                        SourcePort,
                        TargetAddress,
                        TargetPort,
                        SourceAddress,
                        SourcePort,
                        0,
                        NULL,
                        NULL,
                        NULL
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_ALG,
                        "AlgCreateActiveEndpoint: Unable to create shadow"
                        " redirect for connection to %s/%d",
                        INET_NTOA(TargetAddress),
                        RtlUshortByteSwap(TargetPort)
                        );

                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    break;
                }
            }

            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateActiveEndpoint: endpoint %d connecting socket %d "
                "to host at %s/%d",
                Endpointp->EndpointId, Endpointp->ClientSocket,
                INET_NTOA(TargetAddress), RtlUshortByteSwap(TargetPort)
                );
            Error =
                NhConnectStreamSocket(
                    &AlgComponentReference,
                    Endpointp->ClientSocket,
                    TargetAddress,
                    TargetPort,
                    NULL,
                    AlgConnectEndpointCompletionRoutine,
                    AlgCloseEndpointNotificationRoutine,
                    Interfacep,
                    UlongToPtr(Endpointp->EndpointId)
                    );
            if (Error) {
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgCreateActiveEndpoint: error %d connecting to host %s",
                    Error,
                    INET_NTOA(TargetAddress)
                    );
                break;
            }
        }

        ALG_DEREFERENCE_INTERFACE(Interfacep);

        if (EndpointCreated) { *EndpointCreated = Endpointp; }
        return NO_ERROR;
    } while(FALSE);
    if (Endpointp) {
        AlgDeleteActiveEndpoint(Endpointp);
    } else {
        NhDeleteStreamSocket(AcceptedSocket);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
    }
    return Error;
} // AlgCreateActiveEndpoint


ULONG
AlgCreateConnection(
    PALG_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    PALG_CONNECTION* ConnectionCreated OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a connection-object corresponding
    to a newly-accepted connection. It creates and inserts the entry,
    queries the kernel-mode translator to determine the client's target server,
    and creates an active endpoint which is connected to that server.

Arguments:

    Interfacep - the interface on which the connection was accepted

    ListeningSocket - the socket on which the connection was accepted

    AcceptedSocket - the accepted socket

    AcceptBuffer - contains address/port information for the local and remote
        endpoints.

    ConnectionCreated - on output, optionally receives a pointer
        to the connection created

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on behalf of this routine. If a failure
    occurs here, this routine is responsible for releasing those references.

--*/

{
    PALG_CONNECTION Connectionp = NULL;
    PALG_ENDPOINT Endpointp = NULL;
    ULONG Error;
    PLIST_ENTRY InsertionPoint;
    ULONG LocalAddress;
    USHORT LocalPort;
    ULONG Length;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION Key;
    ULONG ActualClientAddress;
    USHORT ActualClientPort;
    IP_NAT_PORT_MAPPING PortMapping;
    PROFILE("AlgCreateConnection");

    do {
        //
        // Retrieve the local and remote endpoint information from the
        // connection-acceptance buffer, and use them to query the kernel-mode
        // translation module for the host to which the client was destined
        // before we redirected it to our listening socket.
        //

        NhQueryAcceptEndpoints(
            AcceptBuffer,
            &LocalAddress,
            &LocalPort,
            &ActualClientAddress,
            &ActualClientPort
            );
        Length = sizeof(Key);
        EnterCriticalSection(&AlgGlobalInfoLock);
        Error =
            NatLookupAndQueryInformationSessionMapping(
                AlgTranslatorHandle,
                NAT_PROTOCOL_TCP,
                LocalAddress,
                LocalPort,
                ActualClientAddress,
                ActualClientPort,
                &Key,
                &Length,
                NatKeySessionMappingExInformation
                );
        LeaveCriticalSection(&AlgGlobalInfoLock);
        if (Error) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateConnection: error %d querying session-mapping",
                Error
                );
            break;
        } else {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateConnection: accepted client for %s/%d",
                INET_NTOA(Key.DestinationAddress), ntohs(Key.DestinationPort)
                );
        }

        //
        // Create and initialize a new connection.
        //

        Connectionp = reinterpret_cast<PALG_CONNECTION>(
                        NH_ALLOCATE(sizeof(*Connectionp))
                        );
        if (!Connectionp) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        ZeroMemory(Connectionp, sizeof(Connectionp));
        Connectionp->ConnectionId =
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&AlgNextConnectionId)
                );
        AlgLookupConnection(
            Interfacep, Connectionp->ConnectionId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Connectionp->Link);
        Connectionp->Interfacep = Interfacep;
        InitializeListHead(&Connectionp->ActiveEndpointList);

        //
        // Create a new active endpoint, which will contact the client's
        // actual host and transfer data between the client and the host.
        // Note that the callee will release the two references to the
        // interface if a failure occurs. Once the endpoint is created,
        // we set the 'initial-endpoint' flag on it before releasing
        // the interface lock. This ensures that if the endpoint cannot
        // connect to the actual host, we delete the whole connection.
        // The flag is later cleared in 'AlgActivateActiveEndpoint'
        // when the endpoint is activated.
        //
        if (NAT_IFC_BOUNDARY(Interfacep->Characteristics) &&
            Interfacep->AdapterIndex ==
                NhMapAddressToAdapter(Key.DestinationAddress)) {
            //
            // Inbound
            //
            ASSERT(ALG_INTERFACE_MAPPED(Interfacep));

            Error =
                AlgCreateActiveEndpoint(
                    Connectionp,
                    AlgClientEndpointType,
                    ListeningSocket,
                    AcceptedSocket,
                    AcceptBuffer,
                    Interfacep->PortMapping.PrivateAddress,
                    Interfacep->PortMapping.PrivatePort,
                    Key.DestinationAddress,
                    &Endpointp
                    );
        } else {
            //
            // Outbound
            //
            Error =
                AlgCreateActiveEndpoint(
                    Connectionp,
                    AlgHostEndpointType,
                    ListeningSocket,
                    AcceptedSocket,
                    AcceptBuffer,
                    Key.DestinationAddress,
                    Key.DestinationPort,
                    IP_NAT_ADDRESS_UNSPECIFIED,
                    &Endpointp
                    );
        }
        if (Error) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgCreateConnection: error %d creating active endpoint",
                Error
                );
            break;
        } else {
            Endpointp->Flags |= ALG_ENDPOINT_FLAG_INITIAL_ENDPOINT;
        }

        if (ConnectionCreated) { *ConnectionCreated = Connectionp; }
        return NO_ERROR;

    } while(FALSE);
    if (Connectionp) {
        AlgDeleteConnection(Connectionp);
    } else {
        NhDeleteStreamSocket(AcceptedSocket);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
    }
    return Error;
}


VOID
AlgDeleteActiveEndpoint(
    PALG_ENDPOINT Endpointp
    )

/*++

Routine Description:

    This routine is invoked to destroy an active endpoint.

Arguments:

    Endpoint - the endpoint to be destroyed

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PALG_INTERFACE Interfacep;
    PALG_CONNECTION Connectionp = NULL;
    PROFILE("AlgDeleteActiveEndpoint");
    RemoveEntryList(&Endpointp->ConnectionLink);
    RemoveEntryList(&Endpointp->InterfaceLink);
    if (Endpointp->ClientSocket != INVALID_SOCKET) {
        NhDeleteStreamSocket(Endpointp->ClientSocket);
    }
    if (Endpointp->HostSocket != INVALID_SOCKET) {
        NhDeleteStreamSocket(Endpointp->HostSocket);
    }
    if (Endpointp->ReservedPort != 0) {
        PTIMER_CONTEXT TimerContextp;

        NatCancelRedirect(
            AlgTranslatorHandle,
            NAT_PROTOCOL_TCP,
            Endpointp->DestinationAddress,
            Endpointp->DestinationPort,
            Endpointp->SourceAddress,
            Endpointp->SourcePort,
            Endpointp->NewDestinationAddress,
            Endpointp->NewDestinationPort,
            Endpointp->NewSourceAddress,
            Endpointp->NewSourcePort
            );
            TimerContextp = reinterpret_cast<PTIMER_CONTEXT>(
                                NH_ALLOCATE(sizeof(TIMER_CONTEXT))
                                );
            if (TimerContextp != NULL) {
                TimerContextp->TimerQueueHandle = AlgTimerQueueHandle;
                TimerContextp->ReservedPort = Endpointp->ReservedPort;
                CreateTimerQueueTimer(
                    &(TimerContextp->TimerHandle),
                    AlgTimerQueueHandle,
                    AlgDelayedPortRelease,
                    (PVOID)TimerContextp,
                    ALG_PORT_RELEASE_DELAY,
                    0,
                    WT_EXECUTEDEFAULT
                    );
            } else {
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgDeleteActiveEndpoint:"
                    " memory allocation failed for timer context"
                    );
                NhErrorLog(
                    IP_ALG_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    sizeof(TIMER_CONTEXT)
                    );
            }
        Endpointp->ReservedPort = 0;
    }

    //
    // If this endpoint is the first one for the connection and a failure
    // occurred before it ever even connected to the actual host, or if this
    // endpoint is the last one for the connection and it has been deleted,
    // queue a work-item to delete the connection.
    //

    EnterCriticalSection(&AlgInterfaceLock);
    Interfacep = AlgLookupInterface(Endpointp->Interfacep->Index, NULL);
    if (!Interfacep || !ALG_REFERENCE_INTERFACE(Interfacep)) {
        Interfacep = NULL;
    }
    LeaveCriticalSection(&AlgInterfaceLock);
    if (Interfacep != NULL) {
        ACQUIRE_LOCK(Interfacep);
        Connectionp =
            AlgLookupConnection(Interfacep, Endpointp->ConnectionId, NULL);
        if (Connectionp != NULL &&
            IsListEmpty(&Connectionp->ActiveEndpointList)) {
            Endpointp->Flags |= ALG_ENDPOINT_FLAG_DELETE_CONNECTION;
        }
        RELEASE_LOCK(Interfacep);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
    }

    if ((Endpointp->Flags &
         (ALG_ENDPOINT_FLAG_INITIAL_ENDPOINT |
          ALG_ENDPOINT_FLAG_DELETE_CONNECTION)) &&
        REFERENCE_ALG()) {
        PALG_CLOSE_CONNECTION_CONTEXT Contextp =
            reinterpret_cast<PALG_CLOSE_CONNECTION_CONTEXT>(
                NH_ALLOCATE(sizeof(*Contextp))
                );
        if (!Contextp) {
            DEREFERENCE_ALG();
        } else {
            Contextp->InterfaceIndex = Endpointp->Interfacep->Index;
            Contextp->ConnectionId = Endpointp->ConnectionId;
            if (!QueueUserWorkItem(
                    AlgpCloseConnectionWorkerRoutine, Contextp, 0
                    )) {
                NH_FREE(Contextp);
                DEREFERENCE_ALG();
            } else {
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgDeleteActiveEndpoint: queued connection %d deletion",
                    Endpointp->ConnectionId
                    );
            }
        }
    }
    NH_FREE(Endpointp);
} // AlgDeleteActiveEndpoint


VOID
AlgDeleteConnection(
    PALG_CONNECTION Connectionp
    )

/*++

Routine Description:

    This routine is invoked to destroy a connection-object.
    In the process, it destroys all endpoints for the connection.

Arguments:

    Connectionp - the connection to be deleted

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PALG_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    PROFILE("AlgDeleteConnection");
    RemoveEntryList(&Connectionp->Link);
    while (!IsListEmpty(&Connectionp->ActiveEndpointList)) {
        Link = Connectionp->ActiveEndpointList.Flink;
        Endpointp = CONTAINING_RECORD(Link, ALG_ENDPOINT, ConnectionLink);
        AlgDeleteActiveEndpoint(Endpointp);
    }
    NH_FREE(Connectionp);
} // AlgDeleteConnection


PALG_ENDPOINT
AlgLookupActiveEndpoint(
    PALG_CONNECTION Connectionp,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to an active endpoint given
    its unique 32-bit identifier.

Arguments:

    Connectionp - the connection on which to search for the endpoint

    EndpointId - the 32-bit identifier of the endpoint to be found

    InsertionPoint - on output, optionally receives the location at which
        the endpoint would be inserted, if the endpoint is not in the list.

Return Value:

    PALG_ENDPOINT - the endpoint, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PALG_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    for (Link = Connectionp->ActiveEndpointList.Flink;
         Link != &Connectionp->ActiveEndpointList; Link = Link->Flink) {
        Endpointp = CONTAINING_RECORD(Link, ALG_ENDPOINT, ConnectionLink);
        if (EndpointId > Endpointp->EndpointId) {
            continue;
        } else if (EndpointId < Endpointp->EndpointId) {
            break;
        }
        return Endpointp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // AlgLookupActiveEndpoint


PALG_CONNECTION
AlgLookupConnection(
    PALG_INTERFACE Interfacep,
    ULONG ConnectionId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to a connection given its
    unique 32-bit identifier.

Arguments:

    Interfacep - the interface on which to search for the connection

    ConnectionId - the 32-bit identifier of the connection to be found

    InsertionPoint - on output, optionally receives the location at which
        the connection would be inserted, if the connection is not in the list.

Return Value:

    PALG_CONNECTION - the connection, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PALG_CONNECTION Connectionp;
    PLIST_ENTRY Link;
    for (Link = Interfacep->ConnectionList.Flink;
         Link != &Interfacep->ConnectionList; Link = Link->Flink) {
        Connectionp = CONTAINING_RECORD(Link, ALG_CONNECTION, Link);
        if (ConnectionId > Connectionp->ConnectionId) {
            continue;
        } else if (ConnectionId < Connectionp->ConnectionId) {
            break;
        }
        return Connectionp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // AlgLookupConnection


PALG_ENDPOINT
AlgLookupInterfaceEndpoint(
    PALG_INTERFACE Interfacep,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to any endpoint given
    its unique 32-bit identifier, by searching the endpoints interface list.

Arguments:

    Interfacep - the interfacep on which to search for the endpoint

    EndpointId - the 32-bit identifier of the endpoint to be found

    InsertionPoint - on output, optionally receives the location at which
        the endpoint would be inserted, if the endpoint is not in the list.

Return Value:

    PALG_ENDPOINT - the endpoint, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PALG_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    for (Link = Interfacep->EndpointList.Flink;
         Link != &Interfacep->EndpointList; Link = Link->Flink) {
        Endpointp = CONTAINING_RECORD(Link, ALG_ENDPOINT, InterfaceLink);
        if (EndpointId > Endpointp->EndpointId) {
            continue;
        } else if (EndpointId < Endpointp->EndpointId) {
            break;
        }
        return Endpointp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // AlgLookupInterfaceEndpoint


ULONG
AlgpCloseConnectionWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is scheduled to run when a connection's main endpoint is
    deleted. It deletes the connection, destroying all of its endpoints.

Arguments:

    Context - identifies the connection to be deleted

Return Value:

    ULONG - always NO_ERROR.

Environment:

    Invoked in the context of a system worker thread, with a reference made
    to the interface, as well as to the component. Both references are
    released here.

--*/

{
    PALG_CONNECTION Connectionp;
    PALG_CLOSE_CONNECTION_CONTEXT Contextp =
        (PALG_CLOSE_CONNECTION_CONTEXT)Context;
    PALG_INTERFACE Interfacep;
    PROFILE("AlgpCloseConnectionWorkerRoutine");
    EnterCriticalSection(&AlgInterfaceLock);
    Interfacep = AlgLookupInterface(Contextp->InterfaceIndex, NULL);
    if (!Interfacep || !ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
    } else {
        LeaveCriticalSection(&AlgInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Connectionp =
            AlgLookupConnection(Interfacep, Contextp->ConnectionId, NULL);
        if (Connectionp) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgpCloseConnectionWorkerRoutine: deleting connection %d",
                Connectionp->ConnectionId
                );
            AlgDeleteConnection(Connectionp);
        }
        RELEASE_LOCK(Interfacep);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
    }
    DEREFERENCE_ALG();
    NH_FREE(Context);
    return NO_ERROR;
} // AlgpCloseConnectionWorkerRoutine


ULONG
AlgReadActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp,
    SOCKET Socket,
    ULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to initiate the retrieval of a full message from
    the socket for the given endpoint.

Arguments:

    Interfacep - the interface on which the endpoint was accepted

    Endpointp - the endpoint for which to read a message

    Socket - the socket from which to read the message

    UserFlags - optionally supplies flags to be included in the 'UserFlags'
        field of the message-buffer

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with a reference
    made to the interface on behalf of the read-completion routine. If the read
    cannot be issued here, this routine is responsible for releasing that
    reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    PROFILE("AlgReadActiveEndpoint");

    //
    // Initiate a read on the socket to obtain the next message header.
    // We will do as many reads as it takes to get the full header,
    // which contains the length of the full message.
    // We will then do as many reads as it takes to get the full message.
    //
    // We begin by initializing 'BytesToTransfer' to the size of a message
    // header. This will be decremented with each successfully-read block
    // of data. When it drops to zero, we examine the resulting buffer
    // to determine the full message's length, and begin reading that many
    // bytes into another buffer, after copying the message-header into it.
    //

    Bufferp = NhAcquireVariableLengthBuffer(NH_BUFFER_SIZE);
    if (!Bufferp) {
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        return ERROR_CAN_NOT_COMPLETE;
    }
    Bufferp->UserFlags = UserFlags;
    Bufferp->BytesToTransfer = NH_BUFFER_SIZE - ALG_BUFFER_RESERVE;
    Bufferp->TransferOffset = 0;
    Error =
        NhReadStreamSocket(
            &AlgComponentReference,
            Socket,
            Bufferp,
            Bufferp->BytesToTransfer,
            Bufferp->TransferOffset,
            AlgReadEndpointCompletionRoutine,
            Interfacep,
            UlongToPtr(Endpointp->EndpointId)
            );
    if (Error) { ALG_DEREFERENCE_INTERFACE(Interfacep); }
    return Error;
} // AlgReadActiveEndpoint


ULONG
AlgWriteActiveEndpoint(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to initiate the transmission of a full message on
    the socket for the given endpoint.

Arguments:

    Interfacep - the interface on which the connection was accepted

    Connectionp - the connection on whose endpoint to write a message

    Socket - the endpoint on which to write the message

    Bufferp - supplies the buffer containing the message to be written

    Length - supplies the length of the message to be written

    UserFlags - optionally supplies flags to be included in the 'UserFlags'
        field of the message-buffer

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with a reference
    made to the interface on behalf of the write-completion routine. If the
    write cannot be issued here, this routine is responsible for releasing that
    reference.

--*/

{
    ULONG Error;
    PROFILE("AlgWriteActiveEndpoint");

    //
    // Initiate a write on the socket for the full buffer size
    // We will do as many writes as it takes to send the full message.
    //
    // We begin by initializing 'BytesToTransfer' to the size of a message.
    // This will be decremented with each successfully-read block
    // of data. When it drops to zero, we are done.
    //

    Bufferp->UserFlags = UserFlags;
    Bufferp->BytesToTransfer = Length;
    Bufferp->TransferOffset = 0;
    Error =
        NhWriteStreamSocket(
            &AlgComponentReference,
            Socket,
            Bufferp,
            Bufferp->BytesToTransfer,
            Bufferp->TransferOffset,
            AlgWriteEndpointCompletionRoutine,
            Interfacep,
            UlongToPtr(Endpointp->EndpointId)
            );
    if (Error) { ALG_DEREFERENCE_INTERFACE(Interfacep); }
    return Error;
} // AlgWriteActiveEndpoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algif.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    AlgIF.c

Abstract:

    This module contains code for the ALG transparent proxy's interface
    management.

Author:

    Qiang Wang  (qiangw)        10-April-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>


#include "ALG.h"


//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY AlgInterfaceList;
CRITICAL_SECTION AlgInterfaceLock;
ULONG AlgFirewallIfCount;


ULONG
AlgAcceptConnectionInterface(
    IN PALG_INTERFACE Interfacep,
    IN SOCKET ListeningSocket,
    IN SOCKET AcceptedSocket OPTIONAL,
    IN PNH_BUFFER Bufferp OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep OPTIONAL
    )

/*++

Routine Description:

    This routine is called to accept a connection on an interface. It issues
    an accept-request on the socket and optionally issues a redirect to cause
    ALG control-channel connection-requests to be sent to the listening
    socket.

Arguments:

    Interfacep - the interface on which to accept a connection

    ListeningSocket - the socket on which to listen for a connection

    AcceptedSocket - optionally specifies the socket with which to accept
        a connection.

    Bufferp - optionally supplies a buffer to be used for accept-data

    DynamicRedirectHandlep - on output, optionally receives a handle to a
        dynamic redirect created for the interface. The dynamic redirect
        is only created if the caller specifies this parameter.

Return Value:

    ULONG - Win32/Winsock2 status code.

Notes:

    Invoked with the interface's lock held by the caller and with a reference
    made to the interface on behalf of the accept-completion routine. It is
    this routine's responsibility to release that reference in the event of a
    failure.

--*/

{
    ULONG Address;
    ULONG Error;
    USHORT Port;

    PROFILE("AlgAcceptConnectionInterface");

    Error =
        NhAcceptStreamSocket(
            &AlgComponentReference,
            ListeningSocket,
            AcceptedSocket,
            Bufferp,
            AlgAcceptCompletionRoutine,
            Interfacep,
            (PVOID)ListeningSocket
            );
    if (Error) {
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgAcceptConnectionInterface: error %d accepting connection",
            Error
            );
    } else if (DynamicRedirectHandlep) {

        //
        // From here onward, failures do not require us to drop our reference
        // to the interface, since it is now guaranteed that the accept-
        // completion routine will be invoked.
        //
        // Create the dynamic redirect which will cause all ALG control
        // channel connections to our listening socket.
        //

        Error = NhQueryLocalEndpointSocket(ListeningSocket, &Address, &Port);
        if (Error) {
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgAcceptConnectionInterface: error %d querying endpoint",
                Error
                );
        } else {

            //
            // Install redirect(s).
            //

            if (NAT_IFC_PRIVATE(Interfacep->Characteristics) ||
                ALG_INTERFACE_MAPPED(Interfacep)) {

                ASSERT(!ALG_INTERFACE_MAPPED(Interfacep) ||
                       NAT_IFC_BOUNDARY(Interfacep->Characteristics));

                Error =
                    NatCreateDynamicAdapterRestrictedPortRedirect(
                        NatRedirectFlagReceiveOnly,
                        NAT_PROTOCOL_TCP,
                        ALG_PORT_CONTROL,
                        Address,
                        Port,
                        Interfacep->AdapterIndex,
                        0,
                        &DynamicRedirectHandlep[0]
                        );
                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgAcceptConnectionInterface:"
                    " redirect installed for adapter 0x%08x [%d]",
                    Interfacep->AdapterIndex,
                    Error
                    );
            }

            if (!Error && NAT_IFC_FW(Interfacep->Characteristics)) {
                Error =
                    NatCreateDynamicAdapterRestrictedPortRedirect(
                        NatRedirectFlagSendOnly,
                        NAT_PROTOCOL_TCP,
                        ALG_PORT_CONTROL,
                        Address,
                        Port,
                        Interfacep->AdapterIndex,
                        0,
                        &DynamicRedirectHandlep[1]
                        );

                NhTrace(
                    TRACE_FLAG_ALG,
                    "AlgAcceptConnectionInterface:"
                    " redirect installed for firewalled adapter 0x%08x [%d]",
                    Interfacep->AdapterIndex,
                    Error
                    );
            }
        }
    }

    return Error;
} // AlgAcceptConnectionInterface


ULONG
AlgActivateInterface(
    PALG_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating connection-acceptance on each created socket
    (c) initiating session-redirection for the ALG port, if necessary.

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Notes:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'AlgInterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    BOOLEAN IsNatInterface;

    PROFILE("AlgActivateInterface");

    EnterCriticalSection(&AlgInterfaceLock);
    if (ALG_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        return NO_ERROR;
    }

    Interfacep->Characteristics
        = NatGetInterfaceCharacteristics(Interfacep->Index);

    if (!Interfacep->Characteristics) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    if (NAT_IFC_BOUNDARY(Interfacep->Characteristics)) {
        for (i = 0; i < Interfacep->BindingCount; i++) {
            Error = NatLookupPortMappingAdapter(
                        Interfacep->AdapterIndex,
                        NAT_PROTOCOL_TCP,
                        Interfacep->BindingArray[i].Address,
                        ALG_PORT_CONTROL,
                        &Interfacep->PortMapping
                        );
                        
            if (!Error) {
                Interfacep->Flags |= ALG_INTERFACE_FLAG_MAPPED;
                break;
            }
        }

        if (Error && !NAT_IFC_FW(Interfacep->Characteristics)) {
            LeaveCriticalSection(&AlgInterfaceLock);
            NhTrace(
                TRACE_FLAG_ALG,
                "AlgActivateInterface:"
                " ignoring non-FW and non-mapped NAT boundary interface %d",
                Interfacep->Index
                );
            NhWarningLog(
                IP_ALG_LOG_NAT_INTERFACE_IGNORED,
                0,
                "%d",
                Interfacep->Index
                );
            return NO_ERROR;
        }
    }

    if (NAT_IFC_FW(Interfacep->Characteristics)) {
        InterlockedIncrement(reinterpret_cast<LPLONG>(&AlgFirewallIfCount));
    }

    //
    // Create stream sockets that listen for connection-requests on each
    // logical network, and datagram sockets that process incoming messages.
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {
        Error =
            NhCreateStreamSocket(
                Interfacep->BindingArray[i].Address,
                0,
                &Interfacep->BindingArray[i].ListeningSocket
                );
        if (Error) { break; }
        Error = listen(Interfacep->BindingArray[i].ListeningSocket, SOMAXCONN);
        if (Error == SOCKET_ERROR) { break; }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (--i; (LONG)i >= 0; i--) {
            NhDeleteStreamSocket(
                Interfacep->BindingArray[i].ListeningSocket
                );
            Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_ALG_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&AlgInterfaceLock);
        return Error;
    }

    //
    // Initiate connection-acceptance and message-redirection on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (!ALG_REFERENCE_INTERFACE(Interfacep)) { break; }
        Error =
            AlgAcceptConnectionInterface(
                Interfacep,
                Interfacep->BindingArray[i].ListeningSocket,
                INVALID_SOCKET,
                NULL,
                &Interfacep->BindingArray[i].ListeningRedirectHandle[0]
                );
        if (Error) {
            NhErrorLog(
                IP_ALG_LOG_ACCEPT_FAILED,
                Error,
                "%I",
                Interfacep->BindingArray[i].Address
                );
            Error = NO_ERROR;
        }
    }

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&AlgInterfaceLock);

    return NO_ERROR;

} // AlgActivateInterface


ULONG
AlgBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    ULONG i;
    ULONG Error = NO_ERROR;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgBindInterface");

    EnterCriticalSection(&AlgInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (ALG_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= ALG_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&AlgInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    } else {
        Interfacep->BindingArray =
            reinterpret_cast<PALG_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(ALG_BINDING))
                );
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "AlgBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhErrorLog(
                IP_ALG_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(ALG_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(
            Interfacep->BindingArray,
            BindingInfo->AddressCount * sizeof(ALG_BINDING)
            );
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
    }

    //
    // Figure out our IP Adapter Index, if we have a valid binding
    //

    if (Interfacep->BindingCount) {
        Interfacep->AdapterIndex =
            NhMapAddressToAdapter(BindingInfo->Address[0].Address);
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (ALG_INTERFACE_ACTIVE(Interfacep)) {
        Error = AlgActivateInterface(Interfacep);
    }

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgBindInterface


VOID
AlgCleanupInterface(
    PALG_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Notes:

    Invoked internally from an arbitrary context, with no references
    to the interface.

--*/

{
    PROFILE("AlgCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }

    NH_FREE(Interfacep);

} // AlgCleanupInterface


ULONG
AlgConfigureInterface(
    ULONG Index,
    PIP_ALG_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Notes:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    ULONG Error;
    PALG_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("AlgConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|ALG_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (ALG_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = AlgActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    } else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_ALG_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (ALG_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = AlgActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        } else if (!(OldFlags & IP_ALG_INTERFACE_FLAG_DISABLED) &&
                    (NewFlags & IP_ALG_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (ALG_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                AlgDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgConfigureInterface


ULONG
AlgCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_ALG_INTERFACE_INFO InterfaceInfo,
    OUT PALG_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the ALG transparent proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgCreateInterface");

    EnterCriticalSection(&AlgInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (AlgLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep =
        reinterpret_cast<PALG_INTERFACE>(NH_ALLOCATE(sizeof(ALG_INTERFACE)));

    if (!Interfacep) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "AlgCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_ALG_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(ALG_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|ALG_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InitializeListHead(&Interfacep->ConnectionList);
    InitializeListHead(&Interfacep->EndpointList);
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&AlgInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }




    return NO_ERROR;

} // AlgCreateInterface


VOID
AlgDeactivateInterface(
    PALG_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Notes:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'AlgInterfaceLock' held by caller.

--*/

{
    ULONG i;
    ULONG j;
    PLIST_ENTRY Link;
    PALG_CONNECTION Connectionp;

    PROFILE("AlgDeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    //
    // Stop all network I/O on the interface's logical networks
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (Interfacep->BindingArray[i].ListeningSocket != INVALID_SOCKET) {
            NhDeleteStreamSocket(Interfacep->BindingArray[i].ListeningSocket);
            Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
        }
        for (j = 0; j < 2; j++) {
            if (Interfacep->BindingArray[i].ListeningRedirectHandle[j]) {
                NatCancelDynamicPortRedirect(
                    Interfacep->BindingArray[i].ListeningRedirectHandle[j]
                    );
                Interfacep->BindingArray[i].ListeningRedirectHandle[j] = NULL;
            }
        }
    }

    //
    // Eliminate all connections
    //

    while (!IsListEmpty(&Interfacep->ConnectionList)) {
        Link = RemoveHeadList(&Interfacep->ConnectionList);
        Connectionp = CONTAINING_RECORD(Link, ALG_CONNECTION, Link);
        AlgDeleteConnection(Connectionp);
    }

    ASSERT(IsListEmpty(&Interfacep->EndpointList));

    //
    // If this interface is firewalled, decrement the global count.
    //

    if (NAT_IFC_FW(Interfacep->Characteristics)) {
        InterlockedDecrement(reinterpret_cast<LPLONG>(&AlgFirewallIfCount));
    }

    RELEASE_LOCK(Interfacep);

} // AlgDeactivateInterface


ULONG
AlgDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgDeleteInterface");


    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&AlgInterfaceLock);

 
    Interfacep = AlgLookupInterface(Index, NULL);


    if (Interfacep == NULL) 
	{
        LeaveCriticalSection(&AlgInterfaceLock);

        NhTrace(
            TRACE_FLAG_IF,
            "AlgDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }
 
    //
    // Deactivate the interface
    //

    AlgDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= ALG_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~ALG_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //
    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //
    AlgCleanupInterface(Interfacep);

    LeaveCriticalSection(&AlgInterfaceLock);

    return NO_ERROR;

} // AlgDeleteInterface


ULONG
AlgDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!ALG_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~ALG_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (ALG_INTERFACE_BOUND(Interfacep)) {
        AlgDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // AlgDisableInterface


ULONG
AlgEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    ULONG Error = NO_ERROR;
    PALG_INTERFACE Interfacep;

    PROFILE("AlgEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (ALG_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= ALG_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (ALG_INTERFACE_ACTIVE(Interfacep)) {
        Error = AlgActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // AlgEnableInterface


ULONG
AlgInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgInitializeInterfaceManagement");

    InitializeListHead(&AlgInterfaceList);
    __try {
        InitializeCriticalSection(&AlgInterfaceLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "AlgInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }
    AlgFirewallIfCount = 0;

    return Error;

} // AlgInitializeInterfaceManagement


PALG_INTERFACE
AlgLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PALG_INTERFACE - the interface, if found; otherwise, NULL.

Notes:

    Invoked internally from an arbitrary context, with 'AlgInterfaceLock'
    held by caller.

--*/

{
    PALG_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("AlgLookupInterface");
    for (Link = AlgInterfaceList.Flink; Link != &AlgInterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, ALG_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // AlgLookupInterface


ULONG
AlgQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!ALG_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_ALG_INTERFACE_INFO)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        ALG_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_ALG_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_ALG_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_ALG_INTERFACE_INFO);

    LeaveCriticalSection(&AlgInterfaceLock);

    ALG_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // AlgQueryInterface


VOID
AlgShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Notes:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PALG_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("AlgShutdownInterfaceManagement");
    while (!IsListEmpty(&AlgInterfaceList)) {
        Link = RemoveHeadList(&AlgInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, ALG_INTERFACE, Link);
        if (ALG_INTERFACE_ACTIVE(Interfacep)) {
            AlgDeactivateInterface(Interfacep);
        }
        AlgCleanupInterface(Interfacep);
    }
    DeleteCriticalSection(&AlgInterfaceLock);

} // AlgShutdownInterfaceManagement


VOID
AlgSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the ALG transparent
    proxy is neither installed nor running; it operates as expected,
    since the global information and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Notes:

    Invoked from an arbitrary context.

--*/

{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgSignalNatInterface");

    EnterCriticalSection(&AlgGlobalInfoLock);
    if (!AlgGlobalInfo) {
        LeaveCriticalSection(&AlgGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&AlgGlobalInfoLock);
    EnterCriticalSection(&AlgInterfaceLock);
    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        return;
    }
    AlgDeactivateInterface(Interfacep);
    if (ALG_INTERFACE_ACTIVE(Interfacep)) {
        AlgActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&AlgInterfaceLock);

} // AlgSignalNatInterface


ULONG
AlgUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMALG.C').

--*/

{
    PALG_INTERFACE Interfacep;

    PROFILE("AlgUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&AlgInterfaceLock);

    Interfacep = AlgLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!ALG_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&AlgInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "AlgUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' and 'mapped' flag
    //

    Interfacep->Flags &=
        ~(ALG_INTERFACE_FLAG_BOUND | ALG_INTERFACE_FLAG_MAPPED);

    //
    // Deactivate the interface, if necessary
    //

    if (ALG_INTERFACE_ENABLED(Interfacep)) {
        AlgDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&AlgInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingArray);
    Interfacep->BindingArray = NULL;
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // AlgUnbindInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nath323\timerval.h ===
/*---------------------------------------------------
Copyright (c) 1998, Microsoft Corporation
File: timerval.h

Purpose: 
    Contains H.323 related timer values. Timer values are only
	used to clean up state in case of client error and are not
	aggressive.

History:

    1. created as cb931pdu.h for q931 consts (rajeevb, 19-Jun-1998)
	2. now contains all timer values for q931 and h245 (rajeevb, 19-Jun-1998)

---------------------------------------------------*/
#ifndef __CB_TIMER_H__
#define __CB_TIMER_H__

// timers defined below are in seconds and indicate
// the number of seconds to wait before attempting to
// cleanup
// these are only loosely based on the H.323 specs in that
// they are only used to clean-up state and give a long leash
// to callee's in responding to messages (more than the spec)

#ifndef DBG
// we wait for the callee to respond
// to a SETUP PDU, we wait for a
// CALL PROCEEDING, ALERTING, CONNECT or RELEASE COMPLETE PDU
// the H.225 spec suggests that the caller wait for 4s 
const DWORD Q931_POST_SETUP_TIMER_VALUE = 60000;	// 1min

// we wait for the callee to respond
// to a CALL PROCEEDING PDU, we wait for an 
// ALERTING, CONNECT or RELEASE COMPLETE PDU
// the H.225 spec doesn't define the time to wait for this
const DWORD Q931_POST_CALL_PROC_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an ALERTING PDU, we wait for a 
// CONNECT or RELEASE COMPLETE PDU
// the H.225 spec suggests 180s (3mins) of wait for this
const DWORD Q931_POST_ALERTING_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an OPEN LOGICAL CHANNEL PDU, we wait for a 
// OPEN LOGICAL CHANNEL ACK/REJECT PDU from the callee
// the caller may send a CLOSE LOGICAL CHANNEL PDU in the meantime
// which would cause this to be reset
// I (rajeevb) couldn't find H.245 spec suggestion for this
const DWORD LC_POST_OPEN_TIMER_VALUE = 600000;	// 10mins

// we wait for the callee to respond
// to an CLOSE LOGICAL CHANNEL PDU, we wait for a 
// CLOSE LOGICAL CHANNEL ACK PDU from the callee
// I (rajeevb) couldn't find H.245 spec suggestion for this
const DWORD LC_POST_CLOSE_TIMER_VALUE = 600000;	// 10mins

#else // DBG

// Feel free to play around with the Timer values here

const DWORD Q931_POST_SETUP_TIMER_VALUE = 60000;	// 1min
const DWORD Q931_POST_CALL_PROC_TIMER_VALUE = 60000; //600000;	// 10mins
const DWORD Q931_POST_ALERTING_TIMER_VALUE = 60001; //600001;	// 10mins
const DWORD LC_POST_OPEN_TIMER_VALUE = 600000;	// 10mins
const DWORD LC_POST_CLOSE_TIMER_VALUE = 600001;	// 10mins

#endif // DBG

#endif // __CB_TIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algif.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    AlgIF.h

Abstract:

    This module contains declarations for the ALG transparent proxy's
    interface management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once


//
// Structure:   ALG_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
//

typedef struct _ALG_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET ListeningSocket;
    HANDLE ListeningRedirectHandle[2];
} ALG_BINDING, *PALG_BINDING;


//
// Structure:   ALG_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of ALG transparent proxy
// interfaces, sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('AlgInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _ALG_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    ULONG AdapterIndex; // read-only
    ULONG Characteristics; //read-only after activation
    NET_INTERFACE_TYPE Type; // read-only
    IP_ALG_INTERFACE_INFO Info;
    IP_NAT_PORT_MAPPING PortMapping;
    ULONG Flags;
    ULONG BindingCount;
    PALG_BINDING BindingArray;
    LIST_ENTRY ConnectionList;
    LIST_ENTRY EndpointList;
} ALG_INTERFACE, *PALG_INTERFACE;

//
// Flags
//

#define ALG_INTERFACE_FLAG_DELETED      0x80000000
#define ALG_INTERFACE_DELETED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_DELETED)

#define ALG_INTERFACE_FLAG_BOUND        0x40000000
#define ALG_INTERFACE_BOUND(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_BOUND)

#define ALG_INTERFACE_FLAG_ENABLED      0x20000000
#define ALG_INTERFACE_ENABLED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_ENABLED)

#define ALG_INTERFACE_FLAG_CONFIGURED   0x10000000
#define ALG_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_CONFIGURED)

#define ALG_INTERFACE_FLAG_MAPPED       0x01000000
#define ALG_INTERFACE_MAPPED(i) \
    ((i)->Flags & ALG_INTERFACE_FLAG_MAPPED)

#define ALG_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (ALG_INTERFACE_FLAG_BOUND|ALG_INTERFACE_FLAG_ENABLED)) \
        == (ALG_INTERFACE_FLAG_BOUND|ALG_INTERFACE_FLAG_ENABLED))

#define ALG_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_ALG_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define ALG_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, ALG_INTERFACE_DELETED)

#define ALG_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, AlgCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY AlgInterfaceList;
extern CRITICAL_SECTION AlgInterfaceLock;
extern ULONG AlgFirewallIfCount;


//
// FUNCTION DECLARATIONS
//

ULONG
AlgAcceptConnectionInterface(
    PALG_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep OPTIONAL
    );

ULONG
AlgActivateInterface(
    PALG_INTERFACE Interfacep
    );

ULONG
AlgBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
AlgCleanupInterface(
    PALG_INTERFACE Interfacep
    );

ULONG
AlgConfigureInterface(
    ULONG Index,
    PIP_ALG_INTERFACE_INFO InterfaceInfo
    );

ULONG
AlgCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_ALG_INTERFACE_INFO InterfaceInfo,
    PALG_INTERFACE* InterfaceCreated
    );

VOID
AlgDeactivateInterface(
    PALG_INTERFACE Interfacep
    );

ULONG
AlgDeleteInterface(
    ULONG Index
    );

ULONG
AlgDisableInterface(
    ULONG Index
    );

ULONG
AlgEnableInterface(
    ULONG Index
    );

ULONG
AlgInitializeInterfaceManagement(
    VOID
    );

PALG_INTERFACE
AlgLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
AlgQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
AlgShutdownInterfaceManagement(
    VOID
    );

VOID
AlgSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
AlgUnbindInterface(
    ULONG Index
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algmsg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Algmsg.h

Abstract:

    This module contains declarations related to the ALG transparent
    proxy's message-processing.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once

//
// Reserved port release delay
//
#define ALG_PORT_RELEASE_DELAY                  240000

//
// Flags used in 'UserFlags' field of message-buffers
//

#define ALG_BUFFER_FLAG_CONTINUATION            0x00000001
#define ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT      0x00000004
#define ALG_BUFFER_FLAG_FROM_ACTUAL_HOST        0x00000008

typedef struct _TIMER_CONTEXT {
    HANDLE TimerQueueHandle;
    HANDLE TimerHandle;
    USHORT ReservedPort;
} TIMER_CONTEXT, *PTIMER_CONTEXT;


//
// FUNCTION DECLARATIONS
//

VOID
AlgProcessMessage(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp,
    PNH_BUFFER Bufferp
    );

CHAR *
AlgIsFullMessage(
    CHAR *Bufferp,
    ULONG Length
    );

VOID CALLBACK
AlgDelayedPortRelease(
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algio.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Algio.h

Abstract:

    This module contains declarations for the ALG transparent proxy's
    network I/O completion routines.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once


VOID
AlgAcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
AlgCloseEndpointNotificationRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
AlgConnectEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
AlgReadEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
AlgWriteEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algmsg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    algmsg.c

Abstract:

    This module contains code for the ALG transparent proxy's
    message-processing.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

#define MAKE_ADDRESS(a,b,c,d) \
    ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))

#define MAKE_PORT(a,b)  ((a) | ((b) << 8))

#define TOUPPER(c)      ((c) > 'z' ? (c) : ((c) < 'a' ? (c) : (c) ^ 0x20))

//
// Constant string for the 'PASV' command reply
//

static CONST CHAR PasvReply[] = "227 ";

//
// Constant string for the 'PORT' command (must be upper-case)
//

static CONST CHAR PortCommand[] = "PORT ";


static CONST CHAR Eol[] = "\x0d\x0a\x00\x51\x69\x61\x6e\x67\x20\x57\x61\x6e\x67";

//
// FORWARD DECLARATIONS
//

BOOLEAN
AlgpExtractOctet(
    CHAR **Buffer,
    CHAR *BufferEnd,
    UCHAR *Octet
    );

VOID
AlgpWriteOctet(
    CHAR **Buffer,
    UCHAR Octet
    );


VOID
AlgProcessMessage(
    PALG_INTERFACE Interfacep,
    PALG_ENDPOINT Endpointp,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to process a full message read from an ALG
    client or server on a control channel.

Arguments:

    Interfacep - the interface on which the control-channel was accepted

    Endpointp - the active endpoint corresponding to the control channel

    Bufferp - contains the message read, along with other context information

Return Value:

    none.

Notes:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on our behalf. It is this routine's
    responsibility to release both the references and the buffer.

--*/

{
    BOOLEAN Success;
    BOOLEAN Continuation;
    SOCKET Socket;
    ULONG Error;
    ULONG i;
    LONG NewLength;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG PrivateAddress;
    USHORT PrivatePort;
    UCHAR Numbers[6];
    CHAR *HostPortStartp;
    CHAR *CommandBufferp = reinterpret_cast<CHAR*>(Bufferp->Buffer);
    CHAR *EndOfBufferp =
        reinterpret_cast<CHAR*>(Bufferp->Buffer + Bufferp->TransferOffset);
    CONST CHAR *Commandp =
        Endpointp->Type == AlgClientEndpointType ?
        (PCHAR)PasvReply : (PCHAR)PortCommand;

    PROFILE("AlgProcessMessage");

    if ((Bufferp->UserFlags & ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT) != 0) {
        Socket = Endpointp->ClientSocket;
    } else {
        ASSERT((Bufferp->UserFlags & ALG_BUFFER_FLAG_FROM_ACTUAL_HOST) != 0);
        Socket = Endpointp->HostSocket;
    }

#if DBG
    NhTrace(
        TRACE_FLAG_ALG,
        "AlgProcessMessage: received (0x%08x) (%d) \"%s\"",
        Bufferp->UserFlags, Bufferp->TransferOffset, CommandBufferp
        );
#endif
    if ((Bufferp->UserFlags & ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT) != 0 &&
        (Bufferp->UserFlags & ALG_BUFFER_FLAG_CONTINUATION) == 0) {
        while (*Commandp != '\0' && *Commandp == TOUPPER(*CommandBufferp)) {
            Commandp++;
            CommandBufferp++;
        }

        if (*Commandp == '\0') {
            //
            // We found a match.
            //
            if (Endpointp->Type == AlgClientEndpointType) {
                //
                // Skip non-numerical characters.
                //
                while (CommandBufferp < EndOfBufferp &&
                    (*CommandBufferp < '0' || *CommandBufferp > '9')) {
                    CommandBufferp++;
                }
            } else {
                //
                // Skip white space.
                //
                while (*CommandBufferp == ' ') {
                    CommandBufferp++;
                }
            }

            HostPortStartp = CommandBufferp;

            //
            // Extract host and port numbers.
            //
            Success =
                AlgpExtractOctet(
                    &CommandBufferp,
                    EndOfBufferp,
                    &Numbers[0]
                    );

            i = 1;
            while (i < 6 && Success && *CommandBufferp == ',') {
                CommandBufferp++;
                Success =
                    AlgpExtractOctet(
                        &CommandBufferp,
                        EndOfBufferp,
                        &Numbers[i]
                        );
                i++;
            }

            if (i == 6 && Success) {
                //
                // We extract all of them successfully.
                //
                PrivateAddress =
                    MAKE_ADDRESS(
                        Numbers[0],
                        Numbers[1],
                        Numbers[2],
                        Numbers[3]
                        );
                PrivatePort = MAKE_PORT(Numbers[4], Numbers[5]);

                PublicAddress = Endpointp->BoundaryAddress;
                if (PublicAddress == IP_NAT_ADDRESS_UNSPECIFIED) {
                    PublicAddress =
                        NhQueryAddressSocket(Endpointp->ClientSocket);
                }

                //
                // Cancel the previous one first.
                //
                if (Endpointp->ReservedPort != 0) {
                    PTIMER_CONTEXT TimerContextp;

                    NatCancelRedirect(
                        AlgTranslatorHandle,
                        NAT_PROTOCOL_TCP,
                        Endpointp->DestinationAddress,
                        Endpointp->DestinationPort,
                        Endpointp->SourceAddress,
                        Endpointp->SourcePort,
                        Endpointp->NewDestinationAddress,
                        Endpointp->NewDestinationPort,
                        Endpointp->NewSourceAddress,
                        Endpointp->NewSourcePort
                        );
                    TimerContextp = reinterpret_cast<PTIMER_CONTEXT>(
                                        NH_ALLOCATE(sizeof(TIMER_CONTEXT))
                                        );
                    if (TimerContextp != NULL) {
                        TimerContextp->TimerQueueHandle = AlgTimerQueueHandle;
                        TimerContextp->ReservedPort = Endpointp->ReservedPort;
                        CreateTimerQueueTimer(
                            &(TimerContextp->TimerHandle),
                            AlgTimerQueueHandle,
                            AlgDelayedPortRelease,
                            (PVOID)TimerContextp,
                            ALG_PORT_RELEASE_DELAY,
                            0,
                            WT_EXECUTEDEFAULT
                            );
                    } else {
                        NhTrace(
                            TRACE_FLAG_ALG,
                            "AlgProcessMessage:"
                            " memory allocation failed for timer context"
                            );
                        NhErrorLog(
                            IP_ALG_LOG_ALLOCATION_FAILED,
                            0,
                            "%d",
                            sizeof(TIMER_CONTEXT)
                            );
                    }
                    Endpointp->ReservedPort = 0;
                }

                //
                // Reserve a port for the new data session.
                //
                Error =
                    NatAcquirePortReservation(
                        AlgPortReservationHandle,
                        1,
                        &PublicPort
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_ALG,
                        "AlgProcessMessage: error %d acquiring port",
                        Error
                        );
                    AlgDeleteActiveEndpoint(Endpointp);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    return;
                }
                Endpointp->ReservedPort = PublicPort;

                //
                // Create a redirect for the new data session.
                //
                if (Endpointp->Type == AlgClientEndpointType) {
                    Endpointp->DestinationAddress = PublicAddress;
                    Endpointp->SourceAddress =  0;
                    Endpointp->NewDestinationAddress =  PrivateAddress;
                    Endpointp->NewSourceAddress = 0;
                    Endpointp->DestinationPort = PublicPort;
                    Endpointp->SourcePort = 0;
                    Endpointp->NewDestinationPort = PrivatePort;
                    Endpointp->NewSourcePort = 0;
                    Error =
                        NatCreatePartialRedirect(
                            AlgTranslatorHandle,
                            NatRedirectFlagLoopback,
                            NAT_PROTOCOL_TCP,
                            PublicAddress,
                            PublicPort,
                            PrivateAddress,
                            PrivatePort,
                            NULL,
                            NULL,
                            NULL
                            );
                } else {
                    Endpointp->DestinationAddress = PublicAddress;
                    Endpointp->SourceAddress = Endpointp->ActualHostAddress;
                    Endpointp->NewDestinationAddress =  PrivateAddress;
                    Endpointp->NewSourceAddress = Endpointp->ActualHostAddress;
                    Endpointp->DestinationPort = PublicPort;
                    Endpointp->SourcePort = ALG_PORT_DATA;
                    Endpointp->NewDestinationPort = PrivatePort;
                    Endpointp->NewSourcePort = ALG_PORT_DATA;
                    Error =
                        NatCreateRedirect(
                            AlgTranslatorHandle,
                            NatRedirectFlagLoopback,
                            NAT_PROTOCOL_TCP,
                            PublicAddress,
                            PublicPort,
                            Endpointp->ActualHostAddress,
                            ALG_PORT_DATA,
                            PrivateAddress,
                            PrivatePort,
                            Endpointp->ActualHostAddress,
                            ALG_PORT_DATA,
                            NULL,
                            NULL,
                            NULL
                            );
                }
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_ALG,
                        "AlgProcessMessage: error %d creating redirect",
                        Error
                        );
                    AlgDeleteActiveEndpoint(Endpointp);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    return;
                }

                //
                // Modify the ALG command.
                //
                Numbers[0] = (UCHAR)(PublicAddress & 0xff);
                Numbers[1] = (UCHAR)((PublicAddress >> 8) & 0xff);
                Numbers[2] = (UCHAR)((PublicAddress >> 16) & 0xff);
                Numbers[3] = (UCHAR)((PublicAddress >> 24) & 0xff);
                Numbers[4] = (UCHAR)(PublicPort & 0xff);
                Numbers[5] = (UCHAR)((PublicPort >> 8) & 0xff);
                NewLength = 17;
                for (i = 0; i < 6; i++) {
                    if (Numbers[i] > 99) {
                        NewLength++;
                    } else if (Numbers[i] <= 9) {
                        NewLength--;
                    }
                }

                Bufferp->TransferOffset +=
                    NewLength - (ULONG)(CommandBufferp - HostPortStartp);
                ASSERT(Bufferp->TransferOffset <= NH_BUFFER_SIZE);

                MoveMemory(
                    HostPortStartp + NewLength,
                    CommandBufferp,
                    EndOfBufferp - CommandBufferp
                    );

                AlgpWriteOctet(&HostPortStartp, Numbers[0]);
                i = 1;
                do {
                    *HostPortStartp = ',';
                    HostPortStartp++;
                    AlgpWriteOctet(&HostPortStartp, Numbers[i]);
                    i++;
                } while (i < 6);
            }
        }
    }

    //
    // Forward the message.
    //
    Continuation =
        AlgIsFullMessage(
            reinterpret_cast<CHAR*>(
                &(Bufferp->Buffer[Bufferp->TransferOffset - 2])
            ),
            2
            ) == NULL;
    if (Continuation) {
        Bufferp->UserFlags |= ALG_BUFFER_FLAG_CONTINUATION;
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgProcessMessage: message to be continued (%d)",
            Bufferp->TransferOffset
            );
    } else {
        Bufferp->UserFlags &= ~(ULONG)ALG_BUFFER_FLAG_CONTINUATION;
    }
#if DBG
    NhTrace(
        TRACE_FLAG_ALG,
        "AlgProcessMessage: written (%d) \"%s\"",
        Bufferp->TransferOffset,
        Bufferp->Buffer
        );
#endif
    Error =
        AlgWriteActiveEndpoint(
            Interfacep,
            Endpointp,
            Socket,
            Bufferp,
            Bufferp->TransferOffset,
            Bufferp->UserFlags
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_ALG,
            "AlgProcessMessage: deleting endpoint %d, "
            "AlgWriteActiveEndpoint=%d",
            Endpointp->EndpointId, Error
            );
        AlgDeleteActiveEndpoint(Endpointp);
    }
}


CHAR *
AlgIsFullMessage(
    CHAR *Bufferp,
    ULONG Length
    )

/*++

Routine Description:

    This routine is called to determine whether the passed-in buffer includes
    a full ALG command.

Arguments:

    Bufferp - contains the message read, along with other context information

Return Value:

    CHAR * - points to the start of the next ALG command, or NULL if no
        complete ALG command is detected.

--*/

{
    ULONG Count = Length;
    CONST CHAR *CommandBufferp = Bufferp;
    CONST CHAR *CommandDelimiter = Eol;

    PROFILE("AlgIsFullMessage");

    ASSERT(
        Eol[0] != '\0' &&
        (Eol[1] == '\0' || Eol[2] == '\0') &&
        Eol[0] != Eol[1]
        );

    while (Count > 0 && *CommandDelimiter != '\0') {
        if (*CommandBufferp == *CommandDelimiter) {
            CommandDelimiter++;
            CommandBufferp++;
            Count--;
        } else {
            if (CommandDelimiter == Eol) {
                CommandBufferp++;
                Count--;
            } else {
                CommandDelimiter = Eol;
            }
        }
    }

    return *CommandDelimiter == '\0' ? (CHAR *)CommandBufferp : NULL;
}


VOID CALLBACK
AlgDelayedPortRelease(
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    This routine is called to release a reserved port.

Arguments:

    Parameter - callback context
    TimerOrWaitFired - wait timed out

Return Value:

    None.

--*/

{
    PTIMER_CONTEXT TimerContextp = (PTIMER_CONTEXT)Parameter;
    PROFILE("AlgDelayedPortRelease");

    NatReleasePortReservation(
        AlgPortReservationHandle,
        TimerContextp->ReservedPort,
        1
        );
    DeleteTimerQueueTimer(
        TimerContextp->TimerQueueHandle,
        TimerContextp->TimerHandle,
        NULL
        );
    NH_FREE(TimerContextp);
}


BOOLEAN
AlgpExtractOctet(
    CHAR **Buffer,
    CHAR *BufferEnd,
    UCHAR *Octet
    )

/*++

Routine Description:

    This routine is called to extrcat an octet from a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    BufferEnd - points to the end of the string
    Octet - points to a caller-suplied storage to store converted octet

Return Value:

    BOOLEAN - TRUE if successfuly converted, FALSE otherwise.

--*/

{
    BOOLEAN Success;
    ULONG i = 0;
    ULONG Value = 0;

    while (i < 3 && **Buffer >= '0' && **Buffer <= '9') {
        Value *= 10;
        Value += **Buffer - '0';
        (*Buffer)++;
        i++;
    }

    Success = i > 0 && Value < 0x100;

    if (Success) {
        *Octet = (UCHAR)Value;
    }

    return Success;
}


VOID
AlgpWriteOctet(
    CHAR **Buffer,
    UCHAR Octet
    )

/*++

Routine Description:

    This routine is called to convert an octet to a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    Octet - octet to convert

Return Value:

    None.

--*/

{
    UCHAR Value = Octet;

    if (Octet > 99) {
        **Buffer = '0' + Value / 100;
        Value %= 100;
        (*Buffer)++;
    }

    if (Octet > 9) {
        **Buffer = '0' + Value / 10;
        Value %= 10;
        (*Buffer)++;
    }

    ASSERT(Value <= 9);

    **Buffer = '0' + Value;
    (*Buffer)++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\natprivateapi_imp.h ===
#pragma once

#include <ipnatapi.h>
#include <rasuip.h>

/////////////////////////////////////////////////////////////////////////////
// CNat
class ATL_NO_VTABLE CNat : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public INat
{


public:
    CNat()
    {
        m_hTranslatorHandle = NULL;
    }


    virtual ~CNat();


DECLARE_NO_REGISTRY()
DECLARE_NOT_AGGREGATABLE(CNat)


BEGIN_COM_MAP(CNat)
    COM_INTERFACE_ENTRY(INat)
END_COM_MAP()




//
// INat
//
public:
   

    STDMETHODIMP CreateDynamicRedirect(
        IN  ULONG       Flags, 
        IN  ULONG       AdapterIndex,
        IN  UCHAR       Protocol, 
        IN  ULONG       DestinationAddress, 
        IN  USHORT      DestinationPort, 
        IN  ULONG       SourceAddress, 
        IN  USHORT      SourcePort, 
        IN  ULONG       NewDestinationAddress, 
        IN  USHORT      NewDestinationPort, 
        IN  ULONG       NewSourceAddress,
        IN  USHORT      NewSourcePort,
        OUT HANDLE_PTR* DynamicRedirectHandle
        );

    STDMETHOD(CancelDynamicRedirect)(
        HANDLE_PTR      DynamicRedirectHandle
        );


    STDMETHODIMP CreateRedirect(
        IN  ULONG       nFlags, 
        IN  UCHAR       Protocol, 
        IN  ULONG       nDestinationAddress, 
        IN  USHORT      nDestinationPort, 
        IN  ULONG       nSourceAddress,
        IN  USHORT      nSourcePort,
        IN  ULONG       nNewDestinationAddress,
        IN  USHORT      nNewDestinationPort,
        IN  ULONG       nNewSourceAddress,
        IN  USHORT      nNewSourcePort,
        IN  ULONG       nRestrictAdapterIndex, 
        IN  DWORD_PTR   dwAlgProcessId,
        IN  HANDLE_PTR  hEventForCreate, 
        IN  HANDLE_PTR  hEventForDelete
        );

    STDMETHODIMP CancelRedirect(
        IN  UCHAR       Protocol, 
        IN  ULONG       nDestinationAddress, 
        IN  USHORT      nDestinationPort, 
        IN  ULONG       nSourceAddress,  
        IN  USHORT      nSourcePort,  
        IN  ULONG       nNewDestinationAddress,   
        IN  USHORT      nNewDestinationPort,   
        IN  ULONG       nNewSourceAddress,   
        IN  USHORT      nNewSourcePort
        );

    STDMETHODIMP 
    GetBestSourceAddressForDestinationAddress(
        IN  ULONG       ulDestinationAddress, 
        IN  BOOL        fDemandDial, 
        OUT ULONG*      pulBestSrcAddress
        );

    STDMETHODIMP CNat::LookupAdapterPortMapping(
        IN  ULONG       ulAdapterIndex,
        IN  UCHAR       Protocol,
        IN  ULONG       ulDestinationAddress,
        IN  USHORT      usDestinationPort,
        OUT ULONG*      pulRemapAddress,
        OUT USHORT*     pusRemapPort
        );

    STDMETHODIMP GetOriginalDestinationInformation(
        IN  UCHAR       Protocol,
        IN  ULONG       nDestinationAddress,
        IN  USHORT      nDestinationPort,
        IN  ULONG       nSourceAddress,
        IN  USHORT      nSourcePort,
        OUT ULONG*      pnOriginalDestinationAddress,
        OUT USHORT*     pnOriginalDestinationPort,
        OUT ULONG*      pulAdapterIndex
        );

    STDMETHODIMP ReleasePort(
        IN  USHORT      ReservedPortBase,  
        IN  USHORT      PortCount
        );

    STDMETHODIMP ReservePort(
        IN  USHORT      PortCount,   
        OUT PUSHORT     ReservedPortBase
        );

private:
    
    //
    // ALG expose publicly eAGL_TCP=1 and eALG_UP=2 and intenaly UDP is 0x11 and TCP is 0x06
    //
    inline UCHAR
    ProtocolConvertToNT(
        UCHAR  Protocol
        )
    {
        if ( Protocol== eALG_TCP )
            return NAT_PROTOCOL_TCP;

        if ( Protocol== eALG_UDP )
            return NAT_PROTOCOL_UDP;

        return Protocol;
    }

//
// Properties
//
private:

    HANDLE  m_hTranslatorHandle;


//
// Helper private Methods
//
    inline HANDLE GetTranslatorHandle()
    {
        if ( !m_hTranslatorHandle )
        {
            LRESULT lRet = NatInitializeTranslator(&m_hTranslatorHandle);
            if ( ERROR_SUCCESS != lRet ) 
                return NULL;
        }

        return m_hTranslatorHandle;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\alglog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    alglog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#pragma once

#define IP_ALG_LOG_BASE                       35000

#define IP_ALG_LOG_NAT_INTERFACE_IGNORED      (IP_ALG_LOG_BASE+1)
/*
 * The ALG transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_ALG_LOG_ACTIVATE_FAILED            (IP_ALG_LOG_BASE+2)
/*
 * The ALG transparent proxy was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_ALG_LOG_RECEIVE_FAILED             (IP_ALG_LOG_BASE+3)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_ALLOCATION_FAILED          (IP_ALG_LOG_BASE+4)
/*
 * The ALG transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_ALG_LOG_ACCEPT_FAILED              (IP_ALG_LOG_BASE+5)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to accept connections on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_SEND_FAILED                (IP_ALG_LOG_BASE+7)
/*
 * The ALG transparent proxy encountered a network error while
 * attempting to send messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_ALG_LOG_END                        (IP_ALG_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\natprivateapi_imp.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    rmALG.cpp

Abstract:

    This module contains routines for the ALG Manager module's 
    private interface to be used only by the ALG.exe manager.

Author:

    JPDup		10-Nov-2000

Revision History:

--*/


#include "precomp.h"

#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>

#include "Alg.h"
#include "NatPrivateAPI_Imp.h"

#include <MyTrace.h>

#include <Rtutils.h>



extern HANDLE                   AlgPortReservationHandle;   // see rmALG.CPP




/////////////////////////////////////////////////////////////////////////////
// CNat






//
// Standard destructor
//
CNat::~CNat(void)
{
    MYTRACE_ENTER("CNat::~CNat(void)");

    if ( m_hTranslatorHandle )
        NatShutdownTranslator(m_hTranslatorHandle);

}







STDMETHODIMP 
CNat::CreateRedirect(
    IN  ULONG       Flags, 
    IN  UCHAR       Protocol, 

    IN  ULONG       DestinationAddress, 
    IN  USHORT      DestinationPort, 

    IN  ULONG       SourceAddress, 
    IN  USHORT      SourcePort, 

    IN  ULONG       NewDestinationAddress, 
    IN  USHORT      NewDestinationPort, 

    IN  ULONG       NewSourceAddress, 
    IN  USHORT      NewSourcePort, 

    IN  ULONG       RestrictAdapterIndex, 

    IN  DWORD_PTR   dwAlgProcessId,
    IN  HANDLE_PTR  hCreateEvent, 
    IN  HANDLE_PTR  hDeleteEvent
    )
{
/*++

Routine Description:

    Creates a Redirect PORT

Arguments:

    Flags                   - Specifies options for the redirect
    Protocol                - IP protocol of the session to be redirected

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    RestrictAdapterIndex    - optionally specifies the adapter index that this redirect should be restricted to 

    hCreateEvent            - optionally specifies an event to be signalled when a session matches the redirect.

    hDeleteEvent            - optionally specifies an event to be signalled when a session is delete.


Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE

--*/

    MYTRACE_ENTER("CNat::CreateRedirect");

    MYTRACE("ProtocolPublic %d, ProtocolInternal %d", Protocol, ProtocolConvertToNT(Protocol));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(DestinationAddress),      ntohs(DestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(SourceAddress),           ntohs(SourcePort));
    MYTRACE("NewDestination %s:%d", MYTRACE_IP(NewDestinationAddress),   ntohs(NewDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(NewSourceAddress),        ntohs(NewSourcePort));

    HANDLE  hThisEventForCreate=NULL;
    HANDLE  hThisEventForDelete=NULL;


    //
    // Duplicate the requested Event handles
    //
    if ( dwAlgProcessId )
    {

        HANDLE hAlgProcess = OpenProcess(
            PROCESS_DUP_HANDLE,     // access flag
            false,                  // handle inheritance option
            (DWORD)dwAlgProcessId   // process identifier
            );

        if ( !hAlgProcess )
        {
            MYTRACE_ERROR("Could not open the Process ID of ALG.exe", 0);
            return HRESULT_FROM_WIN32(GetLastError());
        }



        if ( hCreateEvent )
        {
        
            //
            // a create event was requested 
            //
            if ( !DuplicateHandle(
                    hAlgProcess,
                    (HANDLE)hCreateEvent,
                    GetCurrentProcess(),
                    &hThisEventForCreate,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )
                )
            {
                MYTRACE_ERROR("DuplicateHandle on the CREATE handle", 0);
                CloseHandle(hAlgProcess);
                return HRESULT_FROM_WIN32(GetLastError());
            }

            MYTRACE("New DuplicateHandle 'CREATE'=%d base on=%d", hThisEventForCreate, hCreateEvent);
        }
        else
        {
            MYTRACE("No event for Creation requested");
        }



        if ( hDeleteEvent )
        {
            //
            // a delete event was requested
            //
            if ( !DuplicateHandle(
                    hAlgProcess,
                    (HANDLE)hDeleteEvent,
                    GetCurrentProcess(),
                    &hThisEventForDelete,
                    0,
                    FALSE,
                    DUPLICATE_SAME_ACCESS
                    )
                )
            {
                MYTRACE_ERROR("DuplicateHandle on the DELETE handle", 0);

                if ( hThisEventForCreate )
	            CloseHandle(hThisEventForCreate);

                CloseHandle(hAlgProcess);

                return HRESULT_FROM_WIN32(GetLastError());
            }

            MYTRACE("New DuplicateHandle 'DELETE'=%d base on=%d", hThisEventForDelete, hDeleteEvent);

        }
        else
        {
            MYTRACE("No event for Delete requested");
        }

        CloseHandle(hAlgProcess);
    }
    else
    {
        MYTRACE("NO EVENT Requested");
    }


    ULONG Error = NatCreateRedirectEx(
        GetTranslatorHandle(),
        Flags,
        ProtocolConvertToNT(Protocol),

        DestinationAddress,
        DestinationPort,

        SourceAddress,      
        SourcePort,

        NewDestinationAddress,
        NewDestinationPort,

        NewSourceAddress,
        NewSourcePort,

        RestrictAdapterIndex,
        IPNATAPI_SET_EVENT_ON_COMPLETION, // Special constant to use Event vs. a callback to a CompletionRoutine
        (PVOID)hThisEventForDelete,       //HANDLE for DELETE sessions
        (HANDLE)hThisEventForCreate       //HANDLE                    NotifyEvent         OPTIONAL
        ); 

    if ( hThisEventForCreate )
        CloseHandle(hThisEventForCreate);

    if ( hThisEventForDelete )
        CloseHandle(hThisEventForDelete);

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("From NatCreateRedirectEx", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}


//
//
//

STDMETHODIMP 
CNat::CancelRedirect(
    IN  UCHAR    Protocol, 

    IN  ULONG    DestinationAddress, 
    IN  USHORT   DestinationPort, 

    IN  ULONG    SourceAddress, 
    IN  USHORT   SourcePort, 

    IN  ULONG    NewDestinationAddress, 
    IN  USHORT   NewDestinationPort, 

    IN  ULONG    NewSourceAddress, 
    IN  USHORT   NewSourcePort
    )
/*++

Routine Description:

    Cancel a Redirect

Arguments:

    Protocol                - IP protocol of the session to be redirected eALG_TCP || eALG_UDP

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "


Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE

--*/
{
    MYTRACE_ENTER("CNat::CancelRedirect");

    MYTRACE("Protocol Public %d, Internal %d", Protocol, ProtocolConvertToNT(Protocol));
    MYTRACE("Destination    %s:%d", MYTRACE_IP(DestinationAddress),     ntohs(DestinationPort));
    MYTRACE("Source         %s:%d", MYTRACE_IP(SourceAddress),          ntohs(SourcePort));
    MYTRACE("NewDestination %s:%d", MYTRACE_IP(NewDestinationAddress),  ntohs(NewDestinationPort));
    MYTRACE("NewSource      %s:%d", MYTRACE_IP(NewSourceAddress),       ntohs(NewSourcePort));

    ULONG Error = NatCancelRedirect(
        GetTranslatorHandle(),
        ProtocolConvertToNT(Protocol),
        DestinationAddress,
        DestinationPort,
        SourceAddress,
        SourcePort,
        NewDestinationAddress,
        NewDestinationPort,
        NewSourceAddress,
        NewSourcePort
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("From NatCancelRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}





STDMETHODIMP 
CNat::CreateDynamicRedirect(
    IN  ULONG       Flags, 
    IN  ULONG       nAdapterIndex,
    IN  UCHAR       Protocol, 

    IN  ULONG       DestinationAddress, 
    IN  USHORT      DestinationPort, 

    IN  ULONG       SourceAddress, 
    IN  USHORT      SourcePort, 

    IN  ULONG       NewDestinationAddress, 
    IN  USHORT      NewDestinationPort, 

    IN  ULONG       NewSourceAddress,
    IN  USHORT      NewSourcePort,

    OUT HANDLE_PTR* pDynamicRedirectHandle
    )
/*++

Routine Description:

    Cancel a dynamic Redirect, by seting up a dynamic redirection any time a adapter is created the redirection will be
    applied to that new adapter.

Arguments:

    Flags                   - Specifies options for the redirect
    nAdapterIndex           - Index of the IP adapter (Same as the index found using the cmd line "ROUTE PRINT")
    Protocol                - IP protocol of the session to be redirected

    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    pDynamicRedirectHandle  - This routine will populate this field with the handle (Cookie) for the purpose of canceling
                              this DynamicRedirect

Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

Environment:

    The routine runs in the context of the ALG Manager and cant only be invoke by the ALG.EXE
    and is use via the public api CreatePrimaryControlChannel (See ALG.EXE)

--*/
{
    MYTRACE_ENTER("CNat::CreateDynamicRedirect");

    ASSERT(pDynamicRedirectHandle!=NULL);

#if defined(DBG) || defined(_DEBUG)

    MYTRACE("Flags          %d", Flags);


    MYTRACE("Protocol Public %d Internal %d", Protocol, ProtocolConvertToNT(Protocol));

    if ( Flags & NatRedirectFlagNoTimeout )
        MYTRACE("    NatRedirectFlagNoTimeout");

    if ( Flags & NatRedirectFlagUnidirectional )
        MYTRACE("    NatRedirectFlagUnidirectional");

    if ( Flags & NatRedirectFlagRestrictSource )
        MYTRACE("    NatRedirectFlagRestrictSource");

    if ( Flags & NatRedirectFlagPortRedirect )
        MYTRACE("    NatRedirectFlagPortRedirect");

    if ( Flags & NatRedirectFlagReceiveOnly )
        MYTRACE("    NatRedirectFlagReceiveOnly");

    if ( Flags & NatRedirectFlagLoopback )
        MYTRACE("    NatRedirectFlagLoopback");

    if ( Flags & NatRedirectFlagSendOnly )
        MYTRACE("    NatRedirectFlagSendOnly");

    if ( Flags & NatRedirectFlagRestrictAdapter )
        MYTRACE("    NatRedirectFlagRestrictAdapter");

    if ( Flags & NatRedirectFlagSourceRedirect )
        MYTRACE("    NatRedirectFlagSourceRedirect");


    MYTRACE("AdapterIndex   %d", nAdapterIndex);
    
    in_addr tmpAddr;
    tmpAddr.s_addr = DestinationAddress;
    MYTRACE("Destination    %s:%d", inet_ntoa(tmpAddr),    ntohs(DestinationPort));
    tmpAddr.s_addr = SourceAddress;
    MYTRACE("Source         %s:%d", inet_ntoa(tmpAddr),    ntohs(SourcePort));
    tmpAddr.s_addr = NewDestinationAddress;
    MYTRACE("NewDestination %s:%d", inet_ntoa(tmpAddr),    ntohs(NewDestinationPort));
    tmpAddr.s_addr = NewSourceAddress;
    MYTRACE("NewSource      %s:%d", inet_ntoa(tmpAddr),    ntohs(NewSourcePort));
#endif

    
    MYTRACE("About to call NatCreateDynamicFullRedirect");

    ULONG nRestrictSourceAddress = 0;

    if ( NatRedirectFlagRestrictSource & Flags )
    {
        MYTRACE("NatRedirectFlagRestrictSource flags is set");
        nRestrictSourceAddress = SourceAddress;
        SourceAddress = 0;
    }

    ULONG Error = NatCreateDynamicFullRedirect(
        Flags|NatRedirectFlagLoopback,
        ProtocolConvertToNT(Protocol),

        DestinationAddress,
        DestinationPort,

        SourceAddress,
        SourcePort,

        NewDestinationAddress,
        NewDestinationPort,

        NewSourceAddress,
        NewSourcePort,

        nRestrictSourceAddress,         //ULONG RestrictSourceAddress OPTIONAL,
        nAdapterIndex,                  //ULONG RestrictAdapterIndex OPTIONAL,
        0,                              //MinimumBacklog OPTIONAL,
        (PHANDLE)pDynamicRedirectHandle
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Failed NatCreateDynamicFullRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("Call to NatCreateDynamicFullRedirect worked");

    return S_OK;;
}




STDMETHODIMP 
CNat::CancelDynamicRedirect(
    IN  HANDLE_PTR DynamicRedirectHandle
    )
/*++

Routine Description:

    This routine is called to cancel the given dynamic redirect.
    by calling the NatApi version of this function

Arguments:

    DynamicRedirectHandle   - the handle to the dynamic redirect to be cancelled

Return Value:

    HRESULT                 - S_OK for success or and HRESULT error

--*/

{
    MYTRACE_ENTER("CNat::CancelDynamicRedirect");

    ULONG Error = NatCancelDynamicRedirect((PHANDLE)DynamicRedirectHandle);

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Failed NatCancelDynamicRedirect", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    return S_OK;
}




STDMETHODIMP 
CNat::GetBestSourceAddressForDestinationAddress(
    IN  ULONG       ulDestinationAddress, 
    IN  BOOL        fDemandDial, 
    OUT ULONG*      pulBestSrcAddress
    )
/*++

Routine Description:

    We create a temporary UDP socket, connect the socket to the
    actual client's IP address, extract the IP address to which
    the socket is implicitly bound by the TCP/IP driver, and
    discard the socket. This leaves us with the exact IP address
    that we need to use to contact the client.

Arguments:

    ulDestinationAddress, 
    fDemandDial, 
    pulBestSrcAddress


Return Value:

    HRESULT             - S_OK for success

Environment:

    ALG module will call this method to:

--*/

{
    MYTRACE_ENTER("CNat::GetBestSourceAddressForDestinationAddress");

    if ( !pulBestSrcAddress )
    {
        MYTRACE_ERROR("pulBestSrcAddress not supplied",0);
        return E_INVALIDARG;
    }


    SOCKADDR_IN SockAddr;

    SockAddr.sin_family         = AF_INET;
    SockAddr.sin_port           = 0;
    SockAddr.sin_addr.s_addr    = ulDestinationAddress;

    
    ULONG Length = sizeof(SockAddr);


    SOCKET UdpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

    if  (   INVALID_SOCKET == UdpSocket
        ||  SOCKET_ERROR   == connect(UdpSocket, (PSOCKADDR)&SockAddr, sizeof(SockAddr))
        ||  SOCKET_ERROR   == getsockname(UdpSocket, (PSOCKADDR)&SockAddr, (int*)&Length)
        )   
    {
        ULONG nError = WSAGetLastError();

        if ( nError == WSAEHOSTUNREACH )
        {
            if ( fDemandDial )
                nError = RasAutoDialSharedConnection(); 

            if ( ERROR_SUCCESS != nError ) 
            {
                MYTRACE_ERROR(" RasAutoDialSharedConnection failed [%d]", nError);

                if ( UdpSocket != INVALID_SOCKET ) 
                { 
                    closesocket(UdpSocket); 
                }

                return HRESULT_FROM_WIN32(nError);
            }
        } 
        else 
        {
            MYTRACE_ERROR("error %d routing endpoint %d using UDP", nError);

            if (UdpSocket != INVALID_SOCKET) 
            { 
                closesocket(UdpSocket); 
            }

            return HRESULT_FROM_WIN32(nError);
        }
    }

    *pulBestSrcAddress = SockAddr.sin_addr.s_addr;

    closesocket(UdpSocket);

    return S_OK;
}



STDMETHODIMP CNat::LookupAdapterPortMapping(
    IN  ULONG   ulAdapterIndex,
    IN  UCHAR   Protocol,
    IN  ULONG   ulDestinationAddress,
    IN  USHORT  usDestinationPort,
    OUT ULONG*  pulRemapAddress,
    OUT USHORT* pusRemapPort
    )
/*++

Routine Description:

    Call NAT port maping to ge the real destination for the port
    This ofcourse is the use has set some maping in the SharedConnection or Firewalled adapter on the Service Tab.

Arguments:

    ulAdapterIndex          - Index of the IP adapter of the session.

    Protocol                - eALG_PROTOCOL_UDP, eALG_PROTOCOL_TCP
    DestinationAddress      - the edge public adapter address
    DestinationPort         - the edge public adapter port

    RemapAddres             - The address where that the user itended this port to go to (Private computer on the private lan)
    SourcePort              - Should be the same as the DestinationPort for future it may be different.


Return Value:

    HRESULT - S_OK if it worked or E_FAIL if no maping was found

--*/
{
    MYTRACE_ENTER("LookupAdapterPortMapping");
    MYTRACE("AdapterIndex %d Protocol %d DestAddress %s:%d", ulAdapterIndex, ProtocolConvertToNT(Protocol), MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));

    IP_NAT_PORT_MAPPING PortMapping;

    ULONG Error = NatLookupPortMappingAdapter(
                    ulAdapterIndex,
                    ProtocolConvertToNT(Protocol),
                    ulDestinationAddress,
                    usDestinationPort,
                    &PortMapping
                    );
                        
    if ( Error ) 
    {
        MYTRACE_ERROR("from NatLookupPortMappingAdapter", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    *pulRemapAddress   = PortMapping.PrivateAddress;
    *pusRemapPort      = PortMapping.PrivatePort;

    return S_OK;
}




STDMETHODIMP CNat::GetOriginalDestinationInformation(
    IN  UCHAR   Protocol,

    IN  ULONG   ulDestinationAddress,
    IN  USHORT  usDestinationPort,

    IN  ULONG   ulSourceAddress,
    IN  USHORT  usSourcePort,

    OUT ULONG*  pulOriginalDestinationAddress,
    OUT USHORT* pusOriginalDestinationPort,

    OUT ULONG*  pulAdapterIndex
    )
/*++

Routine Description:

    Determine the original destination endpoint of a session that is redirected to.

Arguments:


    DestinationAddress      - destination endpoint of the session to be redirected
    DestinationPort         - "

    SourceAddress           - source endpoint of the session to be redirected
    SourcePort              - "

    NewDestinationAddress   - replacement destination endpoint for the session
    NewDestinationPort      - "

    NewSourceAddress        - replacement source endpoint for the session
    NewSourcePort           - "

    pulOriginalDestinationAddress   - Returns the original address of the destination (Where the caller realy wanted to go)
    pusOriginalDestinationPort      - Returns the original port of the destination

    pulAdapterIndex                 - Index of the IP adapter of the session.

Return Value:

    HRESULT - S_OK if it worked or E_FAIL

--*/
{
    MYTRACE_ENTER("CNat::GetOriginalDestinationInformation");
    MYTRACE("Destination  %s:%d", MYTRACE_IP(ulDestinationAddress), ntohs(usDestinationPort));
    MYTRACE("Address      %s:%d", MYTRACE_IP(ulSourceAddress),      ntohs(usSourcePort));

    ASSERT(pulOriginalDestinationAddress!=NULL);
    ASSERT(pusOriginalDestinationPort!=NULL);
    ASSERT(pulAdapterIndex!=NULL);


    IP_NAT_SESSION_MAPPING_KEY_EX  Information;
    ULONG   ulSizeOfInformation = sizeof(IP_NAT_SESSION_MAPPING_KEY_EX);

    ULONG Error = NatLookupAndQueryInformationSessionMapping(
        GetTranslatorHandle(),
        ProtocolConvertToNT(Protocol),

        ulDestinationAddress,
        usDestinationPort,

        ulSourceAddress,
        usSourcePort,

        &Information,
        &ulSizeOfInformation,
        NatKeySessionMappingExInformation
        );


    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("Call to NatLookupAndQueryInformationMapping", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("Original Index %d Address:Port %s:%d", Information.AdapterIndex, MYTRACE_IP(Information.DestinationAddress), ntohs(Information.DestinationPort));

    *pulOriginalDestinationAddress  = Information.DestinationAddress;
    *pusOriginalDestinationPort     = Information.DestinationPort;
    *pulAdapterIndex                = Information.AdapterIndex;

    return S_OK;

}





STDMETHODIMP CNat::ReservePort(
    IN  USHORT      PortCount, 
    OUT PUSHORT     pReservedPortBase
    )
/*++

Routine Description:

    Call the into the NAP api to reserve the required port on behave of the ALG module.

Arguments:

    PortCount           -   Number of port to reserve
    pReservedPortBase   -   Starting number of the range of port reserved. example  ReserePort(3, &) would save 5000,5001,5002 and return 5000 as base

Return Value:

    HRESULT - S_OK if it worked or E_FAIL


Environment:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

--*/
{
    MYTRACE_ENTER("CNat::ReservePort");

    ASSERT(pReservedPortBase!=NULL);

    if ( !AlgPortReservationHandle )
        return E_FAIL;                  // AlgPortReservationHandle should already have been done


    ULONG Error = NatAcquirePortReservation(
        AlgPortReservationHandle,
        PortCount,
        pReservedPortBase
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("from NatAcquirePortReservation", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("PortBase %d count %d", *pReservedPortBase, PortCount);

    return S_OK;
}





STDMETHODIMP CNat::ReleasePort(
    IN  USHORT  ReservedPortBase, 
    IN  USHORT  PortCount
    )
/*++

Routine Description:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

    This routine will call the Nat api to release the previously reserved ports

Arguments:

    PortCount           -   Number of port to reserve
    pReservedPortBase   -   Starting number of the range of port reserved. example  ReserePort(3, &) would save 5000,5001,5002 and return 5000 as base

Return Value:

    HRESULT - S_OK if it worked or E_FAIL

Environment:

    Private interface between rmALG and ALG.EXE

    ALG expose a more simple interface to reserve at Port
    in turn it call this private interface that end up calling the more complex NatApi

--*/
{

    MYTRACE_ENTER("CNat::ReleasePort");    

    if ( !AlgPortReservationHandle )
        return E_FAIL;                  // AlgPortReservationHandle should already have been done

    ULONG Error = NatReleasePortReservation(
        AlgPortReservationHandle,
        ReservedPortBase,
        PortCount
        );

    if ( ERROR_SUCCESS != Error )
    {
        MYTRACE_ERROR("from NatReleasePortReservation", Error);
        return HRESULT_FROM_WIN32(Error);
    }

    MYTRACE("PortBase=%d, Count=%d", ntohs(ReservedPortBase), PortCount);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\algio.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ALGio.c

Abstract:

    This module contains code for the ALG transparent proxy's network
    I/O completion routines.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "Algmsg.h"

VOID
AlgAcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of an accept operation
    on a ALG transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds the local and remote IP address and port
        for the connection.

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued
    an I/O completion packet from the common I/O completion port
    with which our stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhAcceptStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    SOCKET AcceptedSocket;
    PALG_CONNECTION Connectionp;
    ULONG Error;
    PALG_INTERFACE Interfacep;
    SOCKET ListeningSocket;
    PROFILE("AlgAcceptCompletionRoutine");
    do {
        AcceptedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PALG_INTERFACE)Bufferp->Context;
        ListeningSocket = (SOCKET)Bufferp->Context2;

        //
        // Acquire three additional references to the interface
        // for the followup requests that we will issue below,
        // and lock the interface.
        //

        EnterCriticalSection(&AlgInterfaceLock);
        if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&AlgInterfaceLock);
            NhReleaseBuffer(Bufferp);
            NhDeleteStreamSocket(AcceptedSocket);
            break;
        }
        ALG_REFERENCE_INTERFACE(Interfacep);
        ALG_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&AlgInterfaceLock);
        ACQUIRE_LOCK(Interfacep);

        //
        // Process the accept-completion.
        // First look for an error code. If an error occurred
        // and the interface is no longer active, end the completion-handling.
        // Otherwise, attempt to reissue the accept-request.
        //

        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "AlgAcceptCompletionRoutine: error %d for interface %d",
                ErrorCode, Interfacep->Index
                );

            //
            // See if the interface is still active and, if so, reissue
            // the accept-request. Since we will not be creating an active
            // endpoint, we won't need the second reference to the interface.
            //

            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);

            if (!ALG_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhDeleteStreamSocket(AcceptedSocket);
            } else {

                //
                // Reissue the accept-request. Note that the callee is now
                // responsible for the reference we made to the interface.
                //

                Error =
                    AlgAcceptConnectionInterface(
                        Interfacep,
                        ListeningSocket,
                        AcceptedSocket,
                        Bufferp,
                        NULL
                        );
                RELEASE_LOCK(Interfacep);
                if (Error) {
                    NhReleaseBuffer(Bufferp);
                    NhDeleteStreamSocket(AcceptedSocket);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "AlgAcceptCompletionRoutine: error %d reissuing accept",
                        Error
                        );
                }
            }

            break;
        }

        //
        // Now see if the interface is operational.
        // If it isn't, we need to destroy the accepted socket
        // and return control.
        //

        if (!ALG_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhDeleteStreamSocket(AcceptedSocket);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgAcceptCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&AlgStatistics.ConnectionsDropped)
                );
            break;
        }

        //
        // We now create a 'ALG_CONNECTION' for the new connection,
        // in the process launching operations for the connection.
        // The connection management module will handle the accepted socket
        // from here onward, and is responsible for the references to the
        // interface that were made above.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "AlgAcceptCompletionRoutine: socket %d accepting connection",
            ListeningSocket
            );
        Error =
            AlgCreateConnection(
                Interfacep,
                ListeningSocket,
                AcceptedSocket,
                Bufferp->Buffer,
                &Connectionp
                );
        if (Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&AlgStatistics.ConnectionsDropped)
                );
        } else {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&AlgStatistics.ConnectionsAccepted)
                );
        }

        //
        // Finally, issue an accept operation for the next connection-request
        // on the listening socket. Note that the callee is responsible
        // for releasing the reference to the interface in case of a failure.
        //

        Error =
            AlgAcceptConnectionInterface(
                Interfacep,
                ListeningSocket,
                INVALID_SOCKET,
                Bufferp,
                NULL
                );
        RELEASE_LOCK(Interfacep);
        if (Error) { NhReleaseBuffer(Bufferp); }

    } while(FALSE);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_ALG();
} // AlgAcceptCompletionRoutine


VOID
AlgCloseEndpointNotificationRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon notification of a close operation
    on a ALG transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds context information for the closed socket.
        Note that we are not allowed to release this buffer here.

Return Value:

    none.

Environment:

    Runs in the context of a wait-thread.
    A reference to the component will have been made on our behalf
    by 'NhAcceptStreamSocket' or 'NhConnectStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.
    Both of these references are released here.

--*/

{
    SOCKET ClosedSocket;
    ULONG EndpointId;
    PALG_INTERFACE Interfacep;
    PROFILE("AlgCloseEndpointNotificationRoutine");
    do {
        ClosedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PALG_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);
        NhTrace(
            TRACE_FLAG_IO,
            "AlgCloseEndpointNotificationRoutine: endpoint %d socket %d "
            "closed, error %d",
            EndpointId, ClosedSocket, ErrorCode
            );

#if 0
        PALG_ENDPOINT Endpointp;

        //
        // Lock the interface, and retrieve the endpoint whose socket has
        // been closed.
        //

        ACQUIRE_LOCK(Interfacep);
        Endpointp = AlgLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);
        if (Endpointp) {
            AlgCloseActiveEndpoint(Endpointp, ClosedSocket);
        }
        RELEASE_LOCK(Interfacep);
#endif
    } while(FALSE);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_ALG();
} // AlgCloseEndpointNotificationRoutine


VOID
AlgConnectEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a connect operation
    on a ALG transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds the context information for the endpoint.
        Note that we are not allowed to release this buffer here.

Return Value:

    none.

Environment:

    Runs in the context of a wait-thread.
    A reference to the component will have been made on our behalf
    by 'NhConnectStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.
    Neither of these references may be released here; they are both
    released in the close-notification routine, which we are guaranteed
    will be invoked. (Eventually.)

--*/

{
    SOCKET ConnectedSocket;
    ULONG EndpointId;
    PALG_ENDPOINT Endpointp;
    ULONG Error;
    PALG_INTERFACE Interfacep;
    PROFILE("AlgConnectEndpointCompletionRoutine");
    do {
        ConnectedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PALG_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire two additional references to the interface
        // for the endpoint-activation that we will initiate below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&AlgInterfaceLock);
        if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&AlgInterfaceLock);
            break;
        }
        ALG_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&AlgInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = AlgLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // First look for an error code.
        // If an error occurred and the interface is still active,
        // destroy the endpoint.
        // If the interface is inactive, we're done, since the endpoint
        // will have already been destroyed.
        // If the interface is active but the endpoint has already
        // been destroyed, end this connection-attempt.
        //

        if (ErrorCode) {
            if (Endpointp) {
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgConnectEndpointCompletionRoutine: deleting endpoint %d "
                    "on error %d", EndpointId, ErrorCode
                    );
                AlgDeleteActiveEndpoint(Endpointp);
            }
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            break;
        } else if (!ALG_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgConnectEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgConnectEndpointCompletionRoutine: endpoint %d removed",
                EndpointId
                );
            break;
        }

        //
        // We now activate the endpoint, beginning data transfer.
        // Note that it is the caller's responsibility to release
        // the two new references to the interface if an error occurs.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "AlgConnectEndpointCompletionRoutine: endpoint %d socket %d "
            "connected", EndpointId, ConnectedSocket
            );
        Error = AlgActivateActiveEndpoint(Interfacep, Endpointp);
        RELEASE_LOCK(Interfacep);

    } while(FALSE);

} // AlgConnectEndpointCompletionRoutine


VOID
AlgReadEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a ALG transparent proxy stream socket.

    The contexts for all reads are the interface and endpoint-identifier
    corresponding to the socket, stored in 'Context' and 'Context2',
    respectively.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the socket

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued an
    I/O completion packet from the common I/O completion port with which
    our stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    ULONG EndpointId;
    PALG_ENDPOINT Endpointp;
    ULONG Error;
    PALG_INTERFACE Interfacep;
    PROFILE("AlgReadEndpointCompletionRoutine");
    do {
        Interfacep = (PALG_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire two additional references to the interface
        // for the followup requests that we will issue below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&AlgInterfaceLock);
        if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&AlgInterfaceLock);
            NhReleaseBuffer(Bufferp);
            break;
        }
        ALG_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&AlgInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = AlgLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // Process the read-completion. First we look for an error-code,
        // and if we find one, we decide whether to re-issue the read-request.
        // If the interface is still active, the error-code is non-fatal, and
        // the endpoint still exists, we reissue the read.
        //

        if (ErrorCode) {

            //
            // We won't be needing the second reference to the interface,
            // since we won't be calling 'AlgProcessMessage.
            //

            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgReadEndpointCompletionRoutine: error %d for endpoint %d",
                ErrorCode, EndpointId
                );
            if (!ALG_INTERFACE_ACTIVE(Interfacep) || !Endpointp) {
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else if (NhIsFatalSocketError(ErrorCode)) {
                AlgDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgReadEndpointCompletionRoutine: deleting endpoint %d "
                    "on fatal read-error %d", EndpointId, ErrorCode
                    );
            } else {

                //
                // We need to repost the buffer for another read operation,
                // so we now reissue a read for the same number of bytes as
                // before.
                //

                Error =
                    NhReadStreamSocket(
                        &AlgComponentReference,
                        Bufferp->Socket,
                        Bufferp,
                        Bufferp->BytesToTransfer,
                        Bufferp->TransferOffset,
                        AlgReadEndpointCompletionRoutine,
                        Bufferp->Context,
                        Bufferp->Context2
                        );
                if (Error) {
                    AlgDeleteActiveEndpoint(Endpointp);
                    RELEASE_LOCK(Interfacep);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "AlgReadEndpointCompletionRoutine: deleting endpoint "
                        "%d, NhReadStreamSocket=%d", EndpointId, Error
                        );
                    if (Error != ERROR_NETNAME_DELETED) {
                        NhWarningLog(
                            IP_ALG_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                    }
                    NhReleaseBuffer(Bufferp);
                    break;
                }

                RELEASE_LOCK(Interfacep);
            }

            break;
        } else if (!BytesTransferred) {

            //
            // Zero bytes were read from the endpoint's socket.
            // This indicates that the sender has closed the socket.
            // We now propagate the closure to the alternate socket
            // for the endpoint. When the 'other' sender is done,
            // this endpoint will be removed altogether.
            //

            NhTrace(
                TRACE_FLAG_IO,
                "AlgReadEndpointCompletionRoutine: endpoint %d socket %d "
                "closed", EndpointId, Bufferp->Socket
                );
            if (Endpointp) {
                AlgCloseActiveEndpoint(Endpointp, Bufferp->Socket);
            }
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            break;
        }

        //
        // The original request completed successfully.
        // Now see if the interface and endpoint are operational and,
        // if not, return control.
        //

        if (!ALG_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgReadEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgReadEndpointCompletionRoutine: endpoint %d not found",
                EndpointId
                );
            break;
        }

        //
        // Record the number of bytes read, and issue a read-request
        // for the remainder if necessary. Otherwise, process the completed
        // message.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "AlgReadEndpointCompletionRoutine: endpoint %d socket %d read %d "
            "bytes", EndpointId, Bufferp->Socket, BytesTransferred
            );
        ASSERT(BytesTransferred <= Bufferp->BytesToTransfer);
        Bufferp->BytesToTransfer -= BytesTransferred;
        Bufferp->TransferOffset += BytesTransferred;

        if (Bufferp->BytesToTransfer > 0 &&
            AlgIsFullMessage(
                reinterpret_cast<CHAR*>(Bufferp->Buffer),
                Bufferp->TransferOffset
                ) == NULL) {

            //
            // Read the remainder of the message, after releasing
            // the second reference to the interface, which is needed
            // only when we call 'AlgProcessMessage'.
            //

            ALG_DEREFERENCE_INTERFACE(Interfacep);

            Error =
                NhReadStreamSocket(
                    &AlgComponentReference,
                    Bufferp->Socket,
                    Bufferp,
                    Bufferp->BytesToTransfer,
                    Bufferp->TransferOffset,
                    AlgReadEndpointCompletionRoutine,
                    Bufferp->Context,
                    Bufferp->Context2
                    );
            if (Error) {
                AlgDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgReadEndpointCompletionRoutine: deleting endpoint "
                    "%d, NhReadStreamSocket=%d", EndpointId, Error
                    );
                if (Error != ERROR_NETNAME_DELETED) {
                    NhWarningLog(
                        IP_ALG_LOG_RECEIVE_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                }
                NhReleaseBuffer(Bufferp);
                break;
            }
        } else {

            //
            // We've finished reading something. Process it.
            //

            AlgProcessMessage(Interfacep, Endpointp, Bufferp);
        }

        RELEASE_LOCK(Interfacep);

    } while(FALSE);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_ALG();

} // AlgReadEndpointCompletionRoutine


VOID
AlgWriteEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a stream socket for a ALG control-channel connection.

    The contexts for all writes are the interface and endpoint-identifier
    corresponding to the socket, stored in 'Context' and 'Context2',
    respectively.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the stream socket

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued an
    I/O completion packet from the common I/O completion port with which our
    stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhWriteStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    ULONG Error;
    ULONG EndpointId;
    PALG_ENDPOINT Endpointp;
    PALG_INTERFACE Interfacep;
    PROFILE("AlgWriteEndpointCompletionRoutine");
    do {
        Interfacep = (PALG_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire an additional reference to the interface
        // for the followup requests that we will issue below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&AlgInterfaceLock);
        if (!ALG_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&AlgInterfaceLock);
            NhReleaseBuffer(Bufferp);
            break;
        }
        LeaveCriticalSection(&AlgInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = AlgLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // Process the write-completion. First we look for an error-code,
        // and if we find one, we decide whether to re-issue the write-request.
        // If the interface is still active, the error-code is non-fatal, and
        // the endpoint still exists, we reissue the write.
        //

        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "AlgWriteEndpointCompletionRoutine: error %d for endpoint %d",
                ErrorCode, EndpointId
                );
            if (!ALG_INTERFACE_ACTIVE(Interfacep) || !Endpointp) {
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else if (NhIsFatalSocketError(ErrorCode)) {
                AlgDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgWriteEndpointCompletionRoutine: deleting endpoint %d "
                    "on fatal write-error %d", EndpointId, ErrorCode
                    );
            } else {

                //
                // We need to repost the buffer for another write operation,
                // so we now reissue a write for the same number of bytes
                // as before.
                //

                Error =
                    NhWriteStreamSocket(
                        &AlgComponentReference,
                        Bufferp->Socket,
                        Bufferp,
                        Bufferp->BytesToTransfer,
                        Bufferp->TransferOffset,
                        AlgWriteEndpointCompletionRoutine,
                        Bufferp->Context,
                        Bufferp->Context2
                        );
                if (Error) {
                    AlgDeleteActiveEndpoint(Endpointp);
                    RELEASE_LOCK(Interfacep);
                    ALG_DEREFERENCE_INTERFACE(Interfacep);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "AlgWriteEndpointCompletionRoutine: deleting endpoint "
                        "%d, NhWriteStreamSocket=%d", EndpointId, Error
                        );
                    NhWarningLog(
                        IP_ALG_LOG_SEND_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                    NhReleaseBuffer(Bufferp);
                    break;
                }

                RELEASE_LOCK(Interfacep);
            }

            break;
        }

        //
        // The original request completed successfully.
        // Now see if the interface and endpoint are operational and,
        // if not, return control.
        //

        if (!ALG_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgWriteEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            ALG_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "AlgWriteEndpointCompletionRoutine: endpoint %d not found",
                EndpointId
                );
            break;
        }

        //
        // Record the number of bytes written, and issue a write-request
        // for the remainder if necessary. Otherwise, we are done,
        // and we return to reading from the 'other' socket for the
        // control-channel.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "AlgWriteEndpointCompletionRoutine: endpoint %d socket %d wrote %d "
            "bytes", EndpointId, Bufferp->Socket, BytesTransferred
            );

        ASSERT(BytesTransferred <= Bufferp->BytesToTransfer);
        Bufferp->BytesToTransfer -= BytesTransferred;
        Bufferp->TransferOffset += BytesTransferred;
        if (Bufferp->BytesToTransfer) {

            //
            // Write the remainder of the message
            //

            Error =
                NhWriteStreamSocket(
                    &AlgComponentReference,
                    Bufferp->Socket,
                    Bufferp,
                    Bufferp->BytesToTransfer,
                    Bufferp->TransferOffset,
                    AlgWriteEndpointCompletionRoutine,
                    Bufferp->Context,
                    Bufferp->Context2
                    );
            if (Error) {
                AlgDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                ALG_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgWriteEndpointCompletionRoutine: deleting endpoint %d, "
                    "NhWriteStreamSocket=%d", EndpointId, Error
                    );
                NhWarningLog(
                    IP_ALG_LOG_SEND_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Bufferp->Socket)
                    );
                NhReleaseBuffer(Bufferp);
                break;
            }
        } else {
            SOCKET Socket;
            ULONG UserFlags;

            //
            // We now go back to reading from the other socket of the
            // endpoint, by issuing the next read on the endpoint's other
            // socket. Note that it is the responsibility of the callee
            // to release the reference to the interface if a failure occurs.
            //

            UserFlags = Bufferp->UserFlags;
            if (UserFlags & ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT) {
                Socket = Endpointp->HostSocket;
                UserFlags &= ~(ULONG)ALG_BUFFER_FLAG_CONTINUATION;
                UserFlags |= ALG_BUFFER_FLAG_FROM_ACTUAL_CLIENT;
            } else {
                Socket = Endpointp->ClientSocket;
                UserFlags &= ~(ULONG)ALG_BUFFER_FLAG_CONTINUATION;
                UserFlags |= ALG_BUFFER_FLAG_FROM_ACTUAL_HOST;
            }
            NhReleaseBuffer(Bufferp);
            Error =
                AlgReadActiveEndpoint(
                    Interfacep,
                    Endpointp,
                    Socket,
                    UserFlags
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_IO,
                    "AlgWriteEndpointCompletionRoutine: deleting endpoint %d, "
                    "AlgReadActiveEndpoint=%d", EndpointId, Error
                    );
                AlgDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                NhWarningLog(
                    IP_ALG_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Socket)
                    );
                break;
            }
        }

        RELEASE_LOCK(Interfacep);

    } while(FALSE);

    ALG_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_ALG();

} // AlgWriteEndpointCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpauto.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpauto.h

Abstract:

    This module contains declarations for generation of a client address
    from a given scope of addresses.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPAUTO_H_
#define _NATHLP_DHCPAUTO_H_

#define MAX_HARDWARE_ADDRESS_LENGTH 32

ULONG
DhcpAcquireUniqueAddress(
    PCHAR Name,
    ULONG NameLength,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    );

ULONG
DhcpGenerateAddress(
    PULONG Seed,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength,
    ULONG ScopeNetwork,
    ULONG ScopeMask
    );

BOOLEAN
DhcpIsReservedAddress(
    ULONG Address,
    PCHAR Name OPTIONAL,
    ULONG NameLength OPTIONAL
    );

BOOLEAN
DhcpIsUniqueAddress(
    ULONG Address,
    PBOOLEAN IsLocal,
    PUCHAR ConflictAddress OPTIONAL,
    PULONG ConflictAddressLength OPTIONAL
    );

ULONG
DhcpQueryReservedAddress(
    PCHAR Name,
    ULONG NameLength
    );

ULONG
DhcpConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pHostName,
    ULONG  HostNameLength,
    PWCHAR *ppszUnicode
    );

extern
BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    );

extern
BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    );

BOOL
DhcpGetLocalMacAddr(
    ULONG Address,
    PUCHAR MacAddr,
    PULONG MacAddrLength
    );

#endif // _NATHLP_DHCPAUTO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmALG.h"

#include "algif.h"
#include "algconn.h"
#include "algio.h"
#include "alglog.h"
#include "algmsg.h"

#include "Alg.h"
#include "Alg_Private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpif.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpif.c

Abstract:

    This module contains code for the DHCP allocator's interface management.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            15-Dec-2000
    Added DhcpGetPrivateInterfaceAddress()
    
--*/

#include "precomp.h"
#pragma hdrstop
#include <ipinfo.h>

extern "C" {
#include <iphlpstk.h>
}

//
// LOCAL TYPE DECLARATIONS
//

typedef struct _DHCP_DEFER_READ_CONTEXT {
    ULONG Index;
    SOCKET Socket;
    ULONG DeferralCount;
} DHCP_DEFER_READ_CONTEXT, *PDHCP_DEFER_READ_CONTEXT;

#define DHCP_DEFER_READ_TIMEOUT     (5 * 1000)

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY DhcpInterfaceList;
CRITICAL_SECTION DhcpInterfaceLock;

//
// Forward declarations
//

VOID NTAPI
DhcpDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DhcpDeferReadWorkerRoutine(
    PVOID Context
    );


ULONG
DhcpActivateInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating datagram-reads on each created socket

Arguments:

    Context - the index of the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'DhcpInterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    BOOLEAN IsNatInterface;
    ULONG ScopeNetwork;
    ULONG ScopeMask;

    PROFILE("DhcpActivateInterface");

    //
    // Read the scope-network from which addresses are to be assigned
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);
    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask = DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    //
    // (re)take the interface lock for the duration of the routine
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (DHCP_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        return NO_ERROR;
    }

    //
    // See whether this is (a) a NAT interface and (b) a boundary interface.
    // We never operate on boundary interfaces, and we only operate
    // on NAT interfaces.
    //

    if (NhIsBoundaryInterface(Interfacep->Index, &IsNatInterface)) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpActivateInterface: ignoring boundary interface %d",
            Interfacep->Index
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_NAT_INTERFACE_IGNORED,
            0,
            "%d",
            Interfacep->Index
            );
        LeaveCriticalSection(&DhcpInterfaceLock);
        return NO_ERROR;
    }

    if (!IsNatInterface) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        LeaveCriticalSection(&DhcpInterfaceLock);
        return NO_ERROR;
    }

    //
    // Create datagram sockets for receiving data on each logical network;
    // N.B. We exclude networks other than the scope network.
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if ((Interfacep->BindingArray[i].Address & ScopeMask) !=
            (ScopeNetwork & ScopeMask)
            ) {
            NhErrorLog(
                IP_AUTO_DHCP_LOG_NON_SCOPE_ADDRESS,
                0,
                "%I%I%I",
                Interfacep->BindingArray[i].Address,
                ScopeNetwork,
                ScopeMask
                );
            continue;
        }
        Error =
            NhCreateDatagramSocket(
                Interfacep->BindingArray[i].Address,
                DHCP_PORT_SERVER,
                &Interfacep->BindingArray[i].Socket
                );
        if (Error) { break; }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (; (LONG)i >= 0; i--) {
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket
                );
            Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DhcpInterfaceLock);
        return Error;
    }

    //
    // Initiate read-operations on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if ((Interfacep->BindingArray[i].Address & ScopeMask) !=
            (ScopeNetwork & ScopeMask)
            ) { continue; }

        //
        // Make a reference to the interface;
        // this reference is released in the completion routine
        //

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        //
        // Initiate the read-operation
        //

        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Interfacep->BindingArray[i].Socket,
                NULL,
                DhcpReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Mask)
                );

        //
        // Drop the reference if a failure occurred
        //

        if (Error) {

            NhErrorLog(
                IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                Interfacep->BindingArray[i].Address
                );

            DHCP_DEREFERENCE_INTERFACE(Interfacep);

            //
            // Reissue the read-operation later
            //

            DhcpDeferReadInterface(
                Interfacep,
                Interfacep->BindingArray[i].Socket
                );

            Error = NO_ERROR;
        }

        //
        // Now make another reference for the client-request
        // with which we detect servers on the network.
        //

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        Error =
            DhcpWriteClientRequestMessage(
                Interfacep,
                &Interfacep->BindingArray[i]
                );

        //
        // Drop the reference if a failure occurred
        //

        if (Error) { DHCP_DEREFERENCE_INTERFACE(Interfacep); Error = NO_ERROR; }
    }

    //
    // cache that this particular interface is a non boundary NAT interface
    //
    Interfacep->Flags |= DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY;

    RELEASE_LOCK(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    return NO_ERROR;

} // DhcpActivateInterface


ULONG
DhcpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpBindInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (DHCP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    }
    else {
        Interfacep->BindingArray =
            reinterpret_cast<PDHCP_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(DHCP_BINDING))
                );
                
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "DhcpBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(DHCP_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        Interfacep->BindingArray[i].ClientSocket = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending = FALSE;
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        Error = DhcpActivateInterface(Interfacep);
    }

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpBindInterface


VOID
DhcpCleanupInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context.

--*/

{
    PROFILE("DhcpCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }
    
    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // DhcpCleanupInterface


ULONG
DhcpConfigureInterface(
    ULONG Index,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error;
    PDHCP_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("DhcpConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|DHCP_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(IP_AUTO_DHCP_INTERFACE_INFO));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DhcpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }
    else {

        CopyMemory(
            &Interfacep->Info,
            InterfaceInfo,
            sizeof(IP_AUTO_DHCP_INTERFACE_INFO)
            );

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DhcpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
        else
        if (!(OldFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED) &&
            (NewFlags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                DhcpDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpConfigureInterface


ULONG
DhcpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo,
    OUT PDHCP_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the DHCP allocator.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpCreateInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (DhcpLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PDHCP_INTERFACE>(
                    NH_ALLOCATE(sizeof(DHCP_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "DhcpCreateInterface: error allocating interface"
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DHCP_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|DHCP_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&DhcpInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // DhcpCreateInterface


VOID
DhcpDeactivateInterface(
    PDHCP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'DhcpInterfaceLock' held by caller.

--*/

{
    ULONG i;

    PROFILE("DhcpDeactivateInterface");

    //
    // Stop all network I/O on the interface's logical networks
    //

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (Interfacep->BindingArray[i].Socket != INVALID_SOCKET) {
            NhDeleteDatagramSocket(Interfacep->BindingArray[i].Socket);
            Interfacep->BindingArray[i].Socket = INVALID_SOCKET;
        }
        if (Interfacep->BindingArray[i].ClientSocket != INVALID_SOCKET) {
            NhDeleteDatagramSocket(Interfacep->BindingArray[i].ClientSocket);
            Interfacep->BindingArray[i].ClientSocket = INVALID_SOCKET;
        }
    }

    //
    // clear interface status as a non boundary NAT interface
    //
    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY;

    RELEASE_LOCK(Interfacep);

} // DhcpDeactivateInterface


VOID NTAPI
DhcpDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to re-issue a deferred read when the countdown
    for the deferral completes.

Arguments:

    Context - holds information identifying the interface and socket

    TimedOut - indicates whether the countdown completed

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the component on our behalf.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG Error;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    NTSTATUS status;

    PROFILE("DhcpDeferReadCallbackRoutine");

    Contextp = (PDHCP_DEFER_READ_CONTEXT)Context;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    Interfacep = DhcpLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DHCP_INTERFACE_ACTIVE(Interfacep) ||
        !DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DHCP();
        return;
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the socket on which to reissue the read
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Contextp->Socket) {continue;}
    
        //
        // This is the binding on which to reissue the read.
        // If no pending timer is recorded, assume a rebind occurred, and quit.
        //

        if (!Interfacep->BindingArray[i].TimerPending) { break; }

        Interfacep->BindingArray[i].TimerPending = FALSE;

        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Interfacep->BindingArray[i].Socket,
                NULL,
                DhcpReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Mask)
                );

        RELEASE_LOCK(Interfacep);

        if (!Error) {
            NH_FREE(Contextp);
            DEREFERENCE_DHCP();
            return;
        }

        //
        // An error occurred; we'll have to retry later.
        // we queue a work item which sets the timer.
        //

        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpDeferReadCallbackRoutine: error %d reading interface %d",
            Error,
            Interfacep->Index
            );

        //
        // Reference the component on behalf of the work-item
        //

        if (REFERENCE_DHCP()) {
    
            //
            // Queue a work-item, reusing the deferral context
            //
    
            status =
                RtlQueueWorkItem(
                    DhcpDeferReadWorkerRoutine,
                    Contextp, 
                    WT_EXECUTEINIOTHREAD
                    );
    
            if (NT_SUCCESS(status)) {
                Contextp = NULL;
            }
            else {
                NH_FREE(Contextp);
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpDeferReadCallbackRoutine: error %d deferring %d",
                    Error,
                    Interfacep->Index
                    );
                DEREFERENCE_DHCP();
            }
        }

        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    //
    // The interface was not found; never mind.
    //

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    NH_FREE(Contextp);
    DEREFERENCE_DHCP();

} // DhcpDeferReadCallbackRoutine


VOID
DhcpDeferReadInterface(
    PDHCP_INTERFACE Interfacep,
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to defer a read-request on an interface,
    typically if an attempt to post a read failed.

Arguments:

    Interfacep - the interface on which to defer the request

    Socket - the socket on which to defer the request

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced and locked by the caller.
    The caller may release the reference upon return.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    NTSTATUS status;

    PROFILE("DhcpDeferReadInterface");

    //
    // Find the binding for the given socket.
    //

    status = STATUS_SUCCESS;

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Socket) { continue; }
    
        //
        // This is the binding. If there is already a timer for it,
        // then just return silently.
        //

        if (Interfacep->BindingArray[i].TimerPending) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }
    
        //
        // Allocate a context block for the deferral.
        //

        Contextp =
            (PDHCP_DEFER_READ_CONTEXT)
                NH_ALLOCATE(sizeof(DHCP_DEFER_READ_CONTEXT));

        if (!Contextp) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadInterface: cannot allocate deferral context"
                );
            status = STATUS_NO_MEMORY;
            break;
        }

        Contextp->Index = Interfacep->Index;
        Contextp->Socket = Socket;
        Contextp->DeferralCount = 1;
    
        //
        // Install a timer to re-issue the read request
        //

        status =
            NhSetTimer(
                &DhcpComponentReference,
                NULL,
                DhcpDeferReadCallbackRoutine,
                Contextp,
                DHCP_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Interfacep->BindingArray[i].TimerPending = TRUE;
        }
        else {
            NH_FREE(Contextp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadInterface: status %08x setting deferral timer",
                status
                );
        }

        break;
    }

    if (i >= Interfacep->BindingCount) { status = STATUS_UNSUCCESSFUL; }

} // DhcpDeferReadInterface


VOID APIENTRY
DhcpDeferReadWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to set a timer for reissuing a deferred read.

Arguments:

    Context - contains the context for the timer.

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the module made on our behalf.

--*/

{
    PDHCP_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    NTSTATUS status;

    PROFILE("DhcpDeferReadWorkerRoutine");

    Contextp = (PDHCP_DEFER_READ_CONTEXT)Context;
    ++Contextp->DeferralCount;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    Interfacep = DhcpLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DHCP_INTERFACE_ACTIVE(Interfacep) ||
        !DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DHCP();
        return;
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the binding on which to set the timer
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket != Contextp->Socket) {continue;}
    
        //
        // This is the binding on which to reissue the read.
        // If a timer is already pending, assume a rebind occurred, and quit.
        //

        if (Interfacep->BindingArray[i].TimerPending) { break; }

        //
        // Install a timer to re-issue the read request,
        // reusing the deferral context.
        //

        status =
            NhSetTimer(
                &DhcpComponentReference,
                NULL,
                DhcpDeferReadCallbackRoutine,
                Contextp,
                DHCP_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Contextp = NULL;
            Interfacep->BindingArray[i].TimerPending = TRUE;
        }
        else {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpDeferReadWorkerRoutine: status %08x setting timer",
                status
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    if (Contextp) { NH_FREE(Contextp); }
    DEREFERENCE_DHCP();

} // DhcpDeferReadWorkerRoutine


ULONG
DhcpDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpDeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure it isn't already deleted
    //

    if (DHCP_INTERFACE_DELETED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d already deleted",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    DhcpDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    DhcpCleanupInterface(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    return NO_ERROR;

} // DhcpDeleteInterface


ULONG
DhcpDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!DHCP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (DHCP_INTERFACE_BOUND(Interfacep)) {
        DhcpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DhcpDisableInterface


ULONG
DhcpEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (DHCP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= DHCP_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        Error = DhcpActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DhcpEnableInterface


ULONG
DhcpInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DhcpInitializeInterfaceManagement");

    InitializeListHead(&DhcpInterfaceList);
    __try {
        InitializeCriticalSection(&DhcpInterfaceLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // DhcpInitializeInterfaceManagement


BOOLEAN
DhcpIsLocalHardwareAddress(
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given hardware address
    is for a local interface.

Arguments:

    HardwareAddress - the hardware address to find

    HardwareAddressLength - the length of the hardware address in bytes

Return Value:

    BOOLEAN - TRUE if the address is found, FALSE otherwise

--*/

{
    ULONG Error;
    ULONG i;
    PMIB_IFTABLE Table;

    //
    // if the hardware address length is zero, assume external address
    //
    if (!HardwareAddressLength)
    {
        return FALSE;
    }

    Error =
        AllocateAndGetIfTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0, FALSE
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpIsLocalHardwareAddress: GetIfTableFromStack=%d", Error
            );
        return FALSE;
    }
    for (i = 0; i < Table->dwNumEntries; i++) {
        if (Table->table[i].dwPhysAddrLen == HardwareAddressLength &&
            memcmp(
                Table->table[i].bPhysAddr,
                HardwareAddress,
                HardwareAddressLength
                ) == 0) {
            HeapFree(GetProcessHeap(), 0, Table);
            return TRUE;
        }
    }
    HeapFree(GetProcessHeap(), 0, Table);
    return FALSE;

} // DhcpIsLocalHardwareAddress


PDHCP_INTERFACE
DhcpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PDHCP_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'DhcpInterfaceLock'
    held by caller.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpLookupInterface");

    for (Link = DhcpInterfaceList.Flink;
         Link != &DhcpInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (Index > Interfacep->Index) { continue; }
        else
        if (Index < Interfacep->Index) { break; }

        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // DhcpLookupInterface


ULONG
DhcpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!DHCP_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    if (*InterfaceInfoSize < sizeof(IP_AUTO_DHCP_INTERFACE_INFO)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_AUTO_DHCP_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_AUTO_DHCP_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_AUTO_DHCP_INTERFACE_INFO);

    LeaveCriticalSection(&DhcpInterfaceLock);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DhcpQueryInterface


VOID
DhcpReactivateEveryInterface(
    VOID
    )

/*++

Routine Description:

    This routine is called to reactivate all activate interfaces
    when a change occurs to the global DHCP configuration.
    Thus if, for instance, the scope network has been changed and is now 
    either valid or invalid, during deactivation all sockets are closed,
    and during reactivation they are or are not reopened as appropriate.
    depending on the validity or invalidity of the new configuration.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from a router-manager thread with no locks held.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpReactivateEveryInterface");

    EnterCriticalSection(&DhcpInterfaceLock);

    for (Link = DhcpInterfaceList.Flink; Link != &DhcpInterfaceList;
         Link = Link->Flink) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (!DHCP_REFERENCE_INTERFACE(Interfacep)) { continue; }

        if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
            DhcpDeactivateInterface(Interfacep);
            DhcpActivateInterface(Interfacep);
        }

        DHCP_DEREFERENCE_INTERFACE(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

} // DhcpReactivateEveryInterface


VOID
DhcpShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked internally in an arbitrary thread context,
    after all references to all interfaces have been released.

--*/

{
    PDHCP_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DhcpShutdownInterfaceManagement");

    while (!IsListEmpty(&DhcpInterfaceList)) {
        Link = RemoveHeadList(&DhcpInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);
        if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
            DhcpDeactivateInterface(Interfacep);
        }
        DhcpCleanupInterface(Interfacep);
    }

    DeleteCriticalSection(&DhcpInterfaceLock);

} // DhcpShutdownInterfaceManagement


VOID
DhcpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the DHCP allocator
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpSignalNatInterface");

    EnterCriticalSection(&DhcpGlobalInfoLock);
    if (!DhcpGlobalInfo) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&DhcpGlobalInfoLock);
    EnterCriticalSection(&DhcpInterfaceLock);
    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        return;
    }
    DhcpDeactivateInterface(Interfacep);
    if (DHCP_INTERFACE_ACTIVE(Interfacep)) {
        DhcpActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&DhcpInterfaceLock);

} // DhcpSignalNatInterface


ULONG
DhcpUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDHCP.C').

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    if (!(Interfacep = DhcpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!DHCP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~DHCP_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (DHCP_INTERFACE_ENABLED(Interfacep)) {
        DhcpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingArray);
    Interfacep->BindingArray = NULL;
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // DhcpUnbindInterface


ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to return the IP address on which DHCP
    has been enabled (and which matches the scope net and mask).

Arguments:

    none.

Return Value:

    Bound IP address if an address is found (else 0).

Environment:

    Invoked from an arbitrary context.
    
--*/
{
    PROFILE("DhcpGetPrivateInterfaceAddress");

    ULONG   ipAddr = 0;
    ULONG   ulRet  = NO_ERROR;

    //
    // Find out the interface on which we are enabled and
    // return the primary IP address to which we are bound.
    // (Try to match the scope to the IP address.)
    //

    PDHCP_INTERFACE Interfacep = NULL;
    PLIST_ENTRY     Link;
    ULONG           i;
   
    //
    // Get Scope information from DHCP Global Info
    //    
    ULONG ScopeNetwork          = 0;
    ULONG ScopeMask             = 0;

    EnterCriticalSection(&DhcpGlobalInfoLock);

    //
    // Check to see if we have been initialized
    //
    if (!DhcpGlobalInfo)
    {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return ipAddr;
    }

    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask    = DhcpGlobalInfo->ScopeMask;

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    EnterCriticalSection(&DhcpInterfaceLock);

    if (ScopeNetwork && ScopeMask)
    {
        ULONG NetAddress = ScopeNetwork & ScopeMask;
        
        //
        // Search & Retrieve the interface to be configured
        //
        for (Link = DhcpInterfaceList.Flink;
             Link != &DhcpInterfaceList;
             Link = Link->Flink
             )
        {
            Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

            ACQUIRE_LOCK(Interfacep);

            for (i = 0; i < Interfacep->BindingCount; i++)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DhcpGetPrivateInterfaceAddress: IP address %s (Index %d)",
                    INET_NTOA(Interfacep->BindingArray[i].Address),
                    Interfacep->Index
                    );
                    
                if (NetAddress == (Interfacep->BindingArray[i].Address &
                                   Interfacep->BindingArray[i].Mask))
                {
                    ipAddr = Interfacep->BindingArray[i].Address;
                    break;
                }
            }
            
            RELEASE_LOCK(Interfacep);

            if (ipAddr)
            {
                LeaveCriticalSection(&DhcpInterfaceLock);

                NhTrace(
                    TRACE_FLAG_DNS,
                    "DhcpGetPrivateInterfaceAddress: Dhcp private interface IP address %s (Index %d)",
                    INET_NTOA(ipAddr),
                    Interfacep->Index
                    );
                
                return ipAddr;
            }
        }
    }
    
    if (!(Interfacep = DhcpLookupInterface(0, NULL)))
    {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DhcpGetPrivateInterfaceAddress: interface index 0 (default) not found"
            );
        return 0;
    }

    ACQUIRE_LOCK(Interfacep);

    if (Interfacep->BindingCount)
    {
        //
        // simply take the first address available
        //
        ipAddr = Interfacep->BindingArray[0].Address;
    }
    
    RELEASE_LOCK(Interfacep);

    LeaveCriticalSection(&DhcpInterfaceLock);

    NhTrace(
        TRACE_FLAG_DNS,
        "DhcpGetPrivateInterfaceAddress: Dhcp private interface IP address %s (Index 0)",
        INET_NTOA(ipAddr)
        );

    return ipAddr;
} // DhcpGetPrivateInterfaceAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpauto.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpauto.c

Abstract:

    This module contains code for automatic selection of a client address
    from a given scope of addresses.
    It makes use of a hashing function which accounts for the client's
    hardware address.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            5-Jul-2001
    +Changed DhcpIsReservedAddress & DhcpQueryReservedAddress to
    handle variable length name strings.
    +Added DhcpConvertHostNametoUnicode (mimics DhcpServer effect)
    Raghu Gatta (rgatta)            17-Jul-2001
    +Added DhcpGetLocalMacAddr
--*/

#include "precomp.h"
#pragma hdrstop

ULONG
DhcpAcquireUniqueAddress(
    PCHAR Name,
    ULONG NameLength,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    )

/*++

Routine Description:

    This routine is invoked to acquire a unique address for a client
    using the given hardware address to decrease the likelihood of collision.

Arguments:

    Name - the name of the host for whom the address is being requested.
        If this matches the name of a server in the shared-access server-list,
        the address reserved for the server is returned.

    NameLength - length of 'Name', excluding any terminating 'nul'.

    HardwareAddress - the hardware address to be used

    HardwareAddressLength - the length of the hardware address

Return Value:

    ULONG - the generated IP address

Environment:

    Invoked from an arbitrary context.

--*/

{
    ULONG AssignedAddress;
    ULONG i = 0;
    PLIST_ENTRY Link;
    ULONG ScopeMask;
    ULONG ScopeNetwork;
    ULONG Seed = GetTickCount();
    BOOLEAN bUnused;

    PROFILE("DhcpAcquireUniqueAddress");

    EnterCriticalSection(&DhcpGlobalInfoLock);
    if (Name &&
        (AssignedAddress = DhcpQueryReservedAddress(Name, NameLength))) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpAcquireUniqueAddress: returning mapping to %s",
            INET_NTOA(AssignedAddress)
            );
        return AssignedAddress;
    }
    ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
    ScopeMask = DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    do {

        if (++i > 4) { AssignedAddress = 0; break; }

        //
        // Generate an address
        //

        do {
            AssignedAddress = 
                DhcpGenerateAddress(
                    &Seed,
                    HardwareAddress,
                    HardwareAddressLength,
                    ScopeNetwork,
                    ScopeMask
                    );
        } while(
            (AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask
            );
    
    } while(!DhcpIsUniqueAddress(AssignedAddress, &bUnused, NULL, NULL));

    return AssignedAddress;

} // DhcpAcquireUniqueAddress


ULONG
DhcpGenerateAddress(
    PULONG Seed,
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength,
    ULONG ScopeNetwork,
    ULONG ScopeMask
    )

/*++

Routine Description:

    This routine is invoked to compute a randomized hash value 
    for a client IP address using a hardware-address.

Arguments:

    Seed - contains (and receives) the seed to 'RtlRandom'

    HardwareAddress - the hardware address to be used

    HardwareAddressLength - the length of the hardware address

    ScopeNetwork - the network into which the generated address
        will be constrained

    ScopeMask - the mask for the scope network

Return Value:

    ULONG - the generated IP address

Environment:

    Invoked from an arbitrary context.

Revision History:

    Based on 'GrandHashing' from net\sockets\tcpcmd\dhcpm\client\dhcp
    by RameshV.

--*/

{
    ULONG Hash;
    ULONG Shift;

#if 1
    Hash = RtlRandom(Seed) & 0xffff0000;
    Hash |= RtlRandom(Seed) >> 16;
#else
    Seed = GetTickCount();

    Seed = Seed * 1103515245 + 12345;
    Hash = (Seed) >> 16;
    Hash <<= 16;
    Seed = Seed * 1103515245 + 12345;
    Hash += Seed >> 16;
#endif

    Shift = Hash % sizeof(ULONG);

    while(HardwareAddressLength--) {
        Hash += (*HardwareAddress++) << (8 * Shift);
        Shift = (Shift + 1) % sizeof(ULONG);
    }

    return (Hash & ~ScopeMask) | ScopeNetwork;

} // DnsGenerateAddress


BOOLEAN
DhcpIsReservedAddress(
    ULONG Address,
    PCHAR Name OPTIONAL,
    ULONG NameLength OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given IP address
    is reserved for another client.

Arguments:

    Address - the IP address to be determined

    Name - optionally specifies the client on whose behalf the call is made

    NameLength - specifies the length of 'Name' excluding the terminating nul

Return Value:

    BOOLEAN - TRUE if the address is reserved for another client,
        FALSE otherwise.

Environment:

    Invoked with 'DhcpGlobalInfoLock' held by the caller.

--*/

{
    ULONG Error = NO_ERROR;
    PLIST_ENTRY Link;
    PNAT_DHCP_RESERVATION Reservation;
    PWCHAR pszUnicodeHostName = NULL;
    
    EnterCriticalSection(&NhLock);
    if (IsListEmpty(&NhDhcpReservationList)) {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    }
    if (Name) {
        Error = DhcpConvertHostNametoUnicode(
                    CP_OEMCP,       // atleast Windows clients send it this way
                    Name,
                    NameLength,
                    &pszUnicodeHostName
                    );
        if (NO_ERROR != Error) {
            LeaveCriticalSection(&NhLock);
            if (pszUnicodeHostName) {
                NH_FREE(pszUnicodeHostName);
            }
            //
            // we can return true or false on failure
            // better we return false - otherwise the client will be in a continuous
            // loop trying to get another address when we NACK its request
            //
            return FALSE;
        }
    }
    for (Link = NhDhcpReservationList.Flink;
         Link != &NhDhcpReservationList; Link = Link->Flink) {
        Reservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);
        if (Address == Reservation->Address) {
            if (lstrcmpiW(pszUnicodeHostName, Reservation->Name)) {
                LeaveCriticalSection(&NhLock);
                if (pszUnicodeHostName) {
                    NH_FREE(pszUnicodeHostName);
                }
                return TRUE;
            } else {
                LeaveCriticalSection(&NhLock);
                if (pszUnicodeHostName) {
                    NH_FREE(pszUnicodeHostName);
                }
                return FALSE;
            }
        } else if (lstrcmpiW(pszUnicodeHostName, Reservation->Name) == 0 &&
                   Address != Reservation->Address) {
            LeaveCriticalSection(&NhLock);
            if (pszUnicodeHostName) {
                NH_FREE(pszUnicodeHostName);
            }
            return TRUE;
        }
    }
    LeaveCriticalSection(&NhLock);

    if (pszUnicodeHostName) {
        NH_FREE(pszUnicodeHostName);
    }
    return FALSE;
} // DhcpIsReservedAddress


BOOLEAN
DhcpIsUniqueAddress(
    ULONG Address,
    PBOOLEAN IsLocal,
    PUCHAR ConflictAddress OPTIONAL,
    PULONG ConflictAddressLength OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given address
    is unique on the directly connected subnetworks.

    The determination accounts for any configured static addresses
    included in the global information.

Arguments:

    Address - the address whose uniqueness is to be determined

    IsLocal - pointer to BOOLEAN which receives info about whether
        the requested address is one of the local interfaces' address

    ConflictAddress - optionally receives a copy of the conflicting
        hardware address if a conflict is found

    ConflictAddressLength - if 'ConflictAddress' is set, receives
        the length of the conflicting address.

Return Value:

    BOOLEAN - TRUE if unique, FALSE otherwise.

--*/

{
    BOOLEAN ConflictFound = FALSE;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    ULONG i;
    PDHCP_INTERFACE Interfacep;
    BOOLEAN IsNatInterface;
    PLIST_ENTRY Link;
    ULONG SourceAddress;

    PROFILE("DhcpIsUniqueAddress");

    *IsLocal = FALSE;

    //
    // See if this is a static address
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);

    if (DhcpGlobalInfo && DhcpGlobalInfo->ExclusionCount) {
        for (i = 0; i < DhcpGlobalInfo->ExclusionCount; i++) {
            if (Address == DhcpGlobalInfo->ExclusionArray[i]) {
                LeaveCriticalSection(&DhcpGlobalInfoLock);
                if (ConflictAddressLength) { *ConflictAddressLength = 0; }
                return FALSE;
            }
        }
    }

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    //
    // Try to detect collisions
    //

    EnterCriticalSection(&DhcpInterfaceLock);

    for (Link = DhcpInterfaceList.Flink;
         Link != &DhcpInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DHCP_INTERFACE, Link);

        if (DHCP_INTERFACE_DELETED(Interfacep)) { continue; }

        ACQUIRE_LOCK(Interfacep);

        //
        // We send out an ARP request unless
        //  (a) the interface is a boundary interface
        //  (b) the interface is not NAT-enabled
        //  (c) the allocator is not active on the interface
        //  (d) the interface is not a LAN adapter
        //  (e) the interface has no bindings.
        //

        if (!DHCP_INTERFACE_NAT_NONBOUNDARY(Interfacep) ||
            !DHCP_INTERFACE_ACTIVE(Interfacep) ||
            (Interfacep->Type != PERMANENT) ||
            !Interfacep->BindingCount) {
            RELEASE_LOCK(Interfacep);
            continue;
        }

        for (i = 0; i < Interfacep->BindingCount; i++) {

            SourceAddress = Interfacep->BindingArray[i].Address;
            ExistingAddressLength = sizeof(ExistingAddress);

            if (SourceAddress == Address)
            {
                //
                // check to see that requested address is not same as
                // one of the local addresses on the NAT box
                //
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpIsUniqueAddress: %s is in use locally",
                    INET_NTOA(Address)
                    );

                if (ConflictAddress) {
                    if (DhcpGetLocalMacAddr(
                            Address,
                            ExistingAddress,
                            &ExistingAddressLength
                            ))
                    {
                        if (ExistingAddressLength > MAX_HARDWARE_ADDRESS_LENGTH) {
                            ExistingAddressLength = MAX_HARDWARE_ADDRESS_LENGTH;
                        }
                        CopyMemory(
                            ConflictAddress,
                            ExistingAddress,
                            ExistingAddressLength
                            );
                        *ConflictAddressLength = ExistingAddressLength;                
                    }
                    else
                    {
                        *ConflictAddressLength = 0;
                    }
                }
                *IsLocal = TRUE;
                ConflictFound = TRUE;
                break;
            }

            RELEASE_LOCK(Interfacep);

            Error =
                SendARP(
                    Address,
                    SourceAddress,
                    (PULONG)ExistingAddress,
                    &ExistingAddressLength
                    );

            ACQUIRE_LOCK(Interfacep);

            if (Error) {
                NhWarningLog(
                    IP_AUTO_DHCP_LOG_SENDARP_FAILED,
                    Error,
                    "%I%I",
                    Address,
                    SourceAddress
                    );
            } else if (ExistingAddressLength &&
                       ExistingAddressLength <= sizeof(ExistingAddress)) {
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpIsUniqueAddress: %s is in use",
                    INET_NTOA(Address)
                    );
#if DBG
                NhDump(
                    TRACE_FLAG_DHCP,
                    ExistingAddress,
                    ExistingAddressLength,
                    1
                    );
#endif
                if (ConflictAddress) {
                    if (ExistingAddressLength > MAX_HARDWARE_ADDRESS_LENGTH) {
                        ExistingAddressLength = MAX_HARDWARE_ADDRESS_LENGTH;
                    }
                    CopyMemory(
                        ConflictAddress,
                        ExistingAddress,
                        ExistingAddressLength
                        );
                    *ConflictAddressLength = ExistingAddressLength;
                }
                ConflictFound = TRUE;
                break;
            }
        }

        RELEASE_LOCK(Interfacep);

        if (ConflictFound) { break; }
    }

    LeaveCriticalSection(&DhcpInterfaceLock);

    return ConflictFound ? FALSE : TRUE;

} // DhcpIsUniqueAddress


ULONG
DhcpQueryReservedAddress(
    PCHAR Name,
    ULONG NameLength
    )

/*++

Routine Description:

    This routine is called to determine whether the given machine name
    corresponds to an entry in the list of reserved addresses.

Arguments:

    Name - specifies the machine name, which might not be nul-terminated.

    NameLength - specifies the length of the given machine name,
        not including any terminating nul character.

Return Value:

    ULONG - the IP address of the machine, if any.

Environment:

    Invoked with 'DhcpGlobalInfoLock' held by the caller.

--*/

{
    ULONG Error = NO_ERROR;
    PLIST_ENTRY Link;
    ULONG ReservedAddress;
    PNAT_DHCP_RESERVATION Reservation;
    PWCHAR pszUnicodeHostName = NULL;

    EnterCriticalSection(&NhLock);
    if (IsListEmpty(&NhDhcpReservationList))
    {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    }
    if (Name) {
        Error = DhcpConvertHostNametoUnicode(
                    CP_OEMCP,       // atleast Windows clients send it this way
                    Name,
                    NameLength,
                    &pszUnicodeHostName
                    );
        if (NO_ERROR != Error) {
            LeaveCriticalSection(&NhLock);
            if (pszUnicodeHostName) {
                NH_FREE(pszUnicodeHostName);
            }
            return FALSE;
        }
    }
    for (Link = NhDhcpReservationList.Flink;
         Link != &NhDhcpReservationList; Link = Link->Flink)
    {
        Reservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);
        if (lstrcmpiW(pszUnicodeHostName, Reservation->Name)) { continue; }
        ReservedAddress = Reservation->Address;
        LeaveCriticalSection(&NhLock);
        if (pszUnicodeHostName) {
            NH_FREE(pszUnicodeHostName);
        }
        return ReservedAddress;
    }
    LeaveCriticalSection(&NhLock);

    if (pszUnicodeHostName) {
        NH_FREE(pszUnicodeHostName);
    }
    return 0;
} // DhcpQueryReservedAddress


//
// Utility routines
//

ULONG
DhcpConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pHostName,
    ULONG  HostNameLength,
    PWCHAR *ppszUnicode
    )
{
    //
    // make sure to free the returned Unicode hostname
    //
    
    DWORD  dwSize = 0;
    ULONG  Error = NO_ERROR;
    PCHAR  pszHostName = NULL;
    LPBYTE pszUtf8HostName = NULL;  // copy of pszHostName in Utf8 format
    PWCHAR pszUnicodeHostName = NULL;

    if (ppszUnicode)
    {
        *ppszUnicode = NULL;
    }
    else
    {
        return ERROR_INVALID_PARAMETER;
    }

    do
    {
        //
        // create a null terminated copy
        //
        dwSize = HostNameLength + 4;
        pszHostName = reinterpret_cast<PCHAR>(NH_ALLOCATE(dwSize));
        if (!pszHostName)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DhcpConvertHostNametoUnicode: allocation failed for "
                "hostname copy buffer"
                );
            break;
        }
        ZeroMemory(pszHostName, dwSize);
        memcpy(pszHostName, pHostName, HostNameLength);
        pszHostName[HostNameLength] = '\0';

        //
        // convert the given hostname to a Unicode string
        //
        
        if (CP_UTF8 == CodePage)
        {
            pszUtf8HostName = (LPBYTE)pszHostName;
        }
        else
        {
            //
            // now convert this into UTF8 format
            //
            if (!ConvertToUtf8(
                     CodePage,
                     (LPSTR)pszHostName,
                     (PCHAR *)&pszUtf8HostName,
                     &dwSize))
            {
                Error = GetLastError();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DhcpConvertHostNametoUnicode: conversion from "
                    "CodePage %d to UTF8 for hostname failed "
                    "with error %ld (0x%08x)",
                    CodePage,
                    Error,
                    Error
                    );
                break;
            }
        }

        //
        // now convert UTF8 string into Unicode format
        //
        if (!ConvertUTF8ToUnicode(
                     pszUtf8HostName,
                     (LPWSTR *)&pszUnicodeHostName,
                     &dwSize))
        {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_DNS,
                "DhcpConvertHostNametoUnicode: conversion from "
                "UTF8 to Unicode for hostname failed "
                "with error %ld (0x%08x)",
                Error,
                Error
                );
            if (pszUnicodeHostName)
            {
                NH_FREE(pszUnicodeHostName);
            }
            break;
        }

        *ppszUnicode = pszUnicodeHostName;

        NhTrace(
            TRACE_FLAG_DNS,
            "DhcpConvertHostNametoUnicode: succeeded! %S",
            pszUnicodeHostName
            );
            
    } while (FALSE);

    if (pszHostName)
    {
        NH_FREE(pszHostName);
    }
    
    if ((CP_UTF8 != CodePage) && pszUtf8HostName)
    {
        NH_FREE(pszUtf8HostName);
    }

    return Error;

} // DhcpConvertHostNametoUnicode

BOOL
DhcpGetLocalMacAddr(
    ULONG Address,
    PUCHAR MacAddr,
    PULONG MacAddrLength
    )

/*++

Routine Description:

    This routine is invoked to determine the local physical MAC address
    for the given local IP address.

Arguments:

    Address - the local IP address

    MacAddr - buffer for holding the MAC addr (upto MAX_HARDWARE_ADDRESS_LENGTH)

    MacAddrLength - specifies the length of 'MacAddr'

Return Value:

    BOOLEAN - TRUE if we are able to get the MAC address,
        FALSE otherwise.

Environment:

    Invoked from DhcpIsUniqueAddress().

--*/

{
    BOOL            bRet = FALSE;
    DWORD           Error = NO_ERROR;
    PMIB_IPNETTABLE IpNetTable = NULL;
    PMIB_IPNETROW   IpNetRow = NULL;
    DWORD           dwPhysAddrLen = 0, i;
    ULONG           dwSize = 0;
    
    do
    {
        //
        // retrieve size of address mapping table
        //
        Error = GetIpNetTable(
                    IpNetTable,
                    &dwSize,
                    FALSE
                    );

        if (!Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: should NOT have returned %d",
                Error
                );
            break;
        }
        else
        if (ERROR_INSUFFICIENT_BUFFER != Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: GetIpNetTable=%d",
                Error
                );
            break;
        }

        //
        // allocate a buffer
        //
        IpNetTable = (PMIB_IPNETTABLE)NH_ALLOCATE(dwSize);

        if (!IpNetTable)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: error allocating %d bytes",
                dwSize
                );
            break;
        }

        //
        // retrieve the address mapping table
        //
        Error = GetIpNetTable(
                    IpNetTable,
                    &dwSize,
                    FALSE
                    );

        if (NO_ERROR != Error)
        {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpGetLocalMacAddr: GetIpNetTable=%d size=%d",
                Error,
                dwSize
                );
            break;
        }

        for (i = 0; i < IpNetTable->dwNumEntries; i++)
        {
            IpNetRow = &IpNetTable->table[i];

            if (IpNetRow->dwAddr == Address)
            {
                dwPhysAddrLen = IpNetRow->dwPhysAddrLen;
                if (dwPhysAddrLen > MAX_HARDWARE_ADDRESS_LENGTH)
                {
                    dwPhysAddrLen = MAX_HARDWARE_ADDRESS_LENGTH;
                }
                CopyMemory(
                    MacAddr,
                    IpNetRow->bPhysAddr,
                    dwPhysAddrLen
                    );
                *MacAddrLength = dwPhysAddrLen;
                bRet = TRUE;
                break;
            }
        }

    } while (FALSE);

    if (IpNetTable)
    {
        NH_FREE(IpNetTable);
    }

    return bRet;
} // DhcpGetLocalMacAddr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\alg\rmalg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmALG.cpp

Abstract:

    This module contains routines for the ALG Manager module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    JPDup		10-Nov-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

#include <initguid.h>
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>



#include "Alg_private.h"
#include "NatPrivateAPI_Imp.h"

#include <MyTrace.h>


MYTRACE_ENABLE



//
// Globals
//



COMPONENT_REFERENCE	    AlgComponentReference;
PIP_ALG_GLOBAL_INFO	    AlgGlobalInfo = NULL;
CRITICAL_SECTION	    AlgGlobalInfoLock;

HANDLE                  AlgNotificationEvent;
HANDLE                  AlgTimerQueueHandle = NULL;
HANDLE                  AlgPortReservationHandle = NULL;
HANDLE                  AlgTranslatorHandle = NULL;
ULONG                   AlgProtocolStopped = 0;
IP_ALG_STATISTICS 	    AlgStatistics;
SUPPORT_FUNCTIONS 	    AlgSupportFunctions;

//
// GIT cookie for the IHNetCfgMgr instance
//
DWORD                   AlgGITcookie = 0;
IGlobalInterfaceTable*  AlgGITp = NULL;






const MPR_ROUTING_CHARACTERISTICS AlgRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_ALG,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    AlgRmStartProtocol,
    AlgRmStartComplete,
    AlgRmStopProtocol,
    AlgRmGetGlobalInfo,
    AlgRmSetGlobalInfo,
    NULL,
    NULL,
    AlgRmAddInterface,
    AlgRmDeleteInterface,
    AlgRmInterfaceStatus,

    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL, //AlgRmMibGet,
    NULL, //AlgRmMibSet,
    NULL, //AlgRmMibGetFirst,
    NULL, //AlgRmMibGetNext,
    NULL,
    NULL
};


#define COMINIT_BEGIN \
    bool bComInitialized = true; \
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE ); \
    if ( FAILED(hr) ) \
    { \
        bComInitialized = FALSE; \
        if (RPC_E_CHANGED_MODE == hr) \
            hr = S_OK; \
    } \

#define COMINIT_END if (TRUE == bComInitialized) { CoUninitialize(); }


#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))




//
//
//
HRESULT
GetAlgControllerInterface(
    IAlgController** ppAlgController
    )

/*++

Routine Description:

    This routine obtains a pointer to the home networking configuration
    manager.

Arguments:

    ppAlgController - receives the IAlgController pointer. The caller must release this pointer.

Return Value:

    standard HRESULT

Environment:

COM must be initialized on the calling thread

--*/

{

    HRESULT hr = S_OK;
    
    if ( NULL == AlgGITp )
    {
        IAlgController* pIAlgController;
        
        //
        // Create the global interface table
        //
        
        hr = CoCreateInstance(
            CLSID_StdGlobalInterfaceTable,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IGlobalInterfaceTable, &AlgGITp)
            );

        if ( SUCCEEDED(hr) )
        {
            //
            // Create the ALG Interface (ALG.exe will start as a service by COM)
            //

            hr = CoCreateInstance(
                    CLSID_AlgController,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    IID_PPV_ARG(IAlgController, &pIAlgController)
                    );

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "GetAlgControllerInterface: Unable to create pIAlgController (0x%08x)",
                    hr
                    );
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "GetAlgControllerInterface: Unable to create GIT (0x%08x)",
                hr
                );
        }

        if (SUCCEEDED(hr))
        {
            //
            // Store the CfgMgr pointer in the GIT
            //

            hr = AlgGITp->RegisterInterfaceInGlobal(
                pIAlgController,
                IID_IAlgController,
                &AlgGITcookie
                );
                
            pIAlgController->Release();

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "GetAlgControllerInterface: Unable to register pIAlgController (0x%08x)",
                    hr
                    );
            }
        }
    }
            
    if ( SUCCEEDED(hr) )
    {
        hr = AlgGITp->GetInterfaceFromGlobal(
                AlgGITcookie,
                IID_PPV_ARG(IAlgController, ppAlgController)
                );
    }

    return hr;
    
} // GetAlgControllerInterface



//
//
//
void
FreeAlgControllerInterface()
{
    //
    // Free up HNetCfgMgr pointers
    //

    if ( !AlgGITp )
        return; // nothing to free

    //
    // Make sure COM is initialized
    //
    HRESULT hr;

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {
        //
        // Release the ALG.exe private interface from the GIT
        //

        AlgGITp->RevokeInterfaceFromGlobal(AlgGITcookie);
        AlgGITcookie = 0;

        //
        // Release the GIT
        //

        AlgGITp->Release();
        AlgGITp = NULL;
    }

    COMINIT_END;

}


VOID
AlgCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the ALG transparent proxy module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DeleteCriticalSection(&AlgGlobalInfoLock);
    DeleteComponentReference(&AlgComponentReference);

} // AlgCleanupModule


VOID
AlgCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the ALG transparent proxy
    protocol-component after a 'StopProtocol'. It runs when the last reference
    to the component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("AlgCleanupProtocol");
    if (AlgGlobalInfo) { NH_FREE(AlgGlobalInfo); AlgGlobalInfo = NULL; }
    if (AlgTimerQueueHandle) {
        DeleteTimerQueueEx(AlgTimerQueueHandle, INVALID_HANDLE_VALUE);
        AlgTimerQueueHandle = NULL;
    }
    if (AlgPortReservationHandle) {
        NatShutdownPortReservation(AlgPortReservationHandle);
        AlgPortReservationHandle = NULL;
    }
    if (AlgTranslatorHandle) {
        NatShutdownTranslator(AlgTranslatorHandle); AlgTranslatorHandle = NULL;
    }
    InterlockedExchange(reinterpret_cast<LPLONG>(&AlgProtocolStopped), 1);
    SetEvent(AlgNotificationEvent);
    ResetComponentReference(&AlgComponentReference);

    //
    // Free the GIT and AlgController interface
    //
    FreeAlgControllerInterface();

} // AlgCleanupProtocol


BOOLEAN
AlgInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the FnP module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{

    if (InitializeComponentReference(
            &AlgComponentReference, AlgCleanupProtocol
            )) 
	{
	    return FALSE;
    }
    __try 
    {
        InitializeCriticalSection(&AlgGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        DeleteComponentReference(&AlgComponentReference);
        return FALSE;
    }

    return TRUE;

} // AlgInitializeModule




//
// Get ALG COM Interface to Start the ALG and give call back Interface
//
HRESULT 
Initialise_ALG()
{
    HRESULT hr;

    COMINIT_BEGIN;
    
    if ( FAILED(hr) )
        return hr;

    //
    // Get COM to load the ALG.exe 
    // The ALG will be launch using a LOCAL_SERVICE priviledge
    // See the RunAs entry under the AppID of the ALG.exe
    //
    
    IAlgController* pIAlgController=NULL;
    
    hr = GetAlgControllerInterface(&pIAlgController);
    if ( SUCCEEDED(hr) )
    {
        //
        // We create our Private COM interface to the NAT api
        //
        CComObject<CNat>*	pComponentNat;
        hr = CComObject<CNat>::CreateInstance(&pComponentNat);
        
        if ( SUCCEEDED(hr) )
        {
            pComponentNat->AddRef();
            
            //
            // Make sure we pass a INat interface 
            //
            INat* pINat=NULL;
            hr = pComponentNat->QueryInterface(IID_INat, (void**)&pINat);
            
            if ( SUCCEEDED(hr) )
            {
                
                //
                // Let the ALG manager start the loading of all the ALG modules
                //
                hr = pIAlgController->Start(pINat);
                
                if ( FAILED(hr) )
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "Initialise_ALG: Error (0x%08x)  on pIAlgController->Start(pINat)",
                        hr
                        );
                }

                //
                // ALG manager will have AddRef this INat so we can release
                //
                pINat->Release();

            }

            pComponentNat->Release();
        }
    }    
    else
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "Initialise_ALG: Error (0x%08x)  Getting the IAlgController interface",
            hr
            );
        
        return hr;
    }


    if ( pIAlgController )
        pIAlgController->Release();

    COMINIT_END;
    
    return S_OK;

}




ULONG
APIENTRY
AlgRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    MYTRACE_START(L"rmALG");
    MYTRACE_ENTER("AlgRmStartProtocol");
    PROFILE("AlgRmStartProtocol");

    ULONG Error = NO_ERROR;
    ULONG Size;

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&AlgGlobalInfoLock);

        Size = sizeof(*AlgGlobalInfo);

        AlgGlobalInfo =
            reinterpret_cast<PIP_ALG_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!AlgGlobalInfo) {
            LeaveCriticalSection(&AlgGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_ALG_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(AlgGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        AlgNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&AlgSupportFunctions, sizeof(AlgSupportFunctions));
        } else {
            CopyMemory(
                &AlgSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        //
        // Obtain a handle to the kernel-mode translation module.
        //

        Error = NatInitializeTranslator(&AlgTranslatorHandle);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing translator",
                Error
                );
            break;
        }

        //
        // Obtain a port-reservation handle
        //

        Error = NatInitializePortReservation(
            ALG_PORT_RESERVATION_BLOCK_SIZE, 
            &AlgPortReservationHandle
            );


        if (Error) 
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing port-reservation",
                Error
                );
            break;
        }

        AlgTimerQueueHandle = CreateTimerQueue();
        if (AlgTimerQueueHandle == NULL) {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_INIT,
                "AlgRmStartProtocol: error %d initializing timer queue",
                Error
                );
            break;
        }



        //
        // Start the ALG.exe
        //
        Initialise_ALG();
        


        LeaveCriticalSection(&AlgGlobalInfoLock);
        InterlockedExchange(reinterpret_cast<LPLONG>(&AlgProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmStartProtocol


ULONG
APIENTRY
AlgRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{

    return NO_ERROR;

} // AlgRmStartComplete


ULONG
APIENTRY
AlgRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    MYTRACE_ENTER("AlgRmStopProtocol");
    PROFILE("AlgRmStopProtocol");
    
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
  

	//
	// Stop all ALG
	//
    HRESULT hr;
    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {

        IAlgController* pIAlgController=NULL;
        hr = GetAlgControllerInterface(&pIAlgController);

        if ( SUCCEEDED(hr) )
        {
            hr = pIAlgController->Stop();
            
            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmStopProtocol: Error (0x%08x) returned from pIalgController->Stop()",
                    hr
                    );
            }

            ULONG nRef = pIAlgController->Release();

            //
            // We are done with the ALG 
            // Free the GIT and AlgController interface
            //
            FreeAlgControllerInterface();
        }
    }

    COMINIT_END;



    //
    // Drop the initial reference to cause a cleanup
    //
    ReleaseInitialComponentReference(&AlgComponentReference);


    MYTRACE_STOP;

    return DEREFERENCE_ALG() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // AlgRmStopProtocol




ULONG
APIENTRY
AlgRmAddInterface(
    PWCHAR              Name,
    ULONG               Index,
    NET_INTERFACE_TYPE  Type,
    ULONG               MediaType,
    USHORT              AccessType,
    USHORT              ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("AlgRmAddInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);


    ULONG Error = NO_ERROR;

    //
    // Also notify the ALG.exe manager
    //
    HRESULT hr;

    COMINIT_BEGIN;
    
    if ( SUCCEEDED(hr) )
    {
        IAlgController* pIAlgController=NULL;
        HRESULT hr = GetAlgControllerInterface(&pIAlgController);

        if ( SUCCEEDED(hr) )
        {
        
            ULONG   nInterfaceCharacteristics = NatGetInterfaceCharacteristics(Index);

            short   nTypeOfAdapter = 0;
        
            if ( NAT_IFC_BOUNDARY(nInterfaceCharacteristics) )
                nTypeOfAdapter |= eALG_BOUNDARY;
        
            if ( NAT_IFC_FW(nInterfaceCharacteristics) )
                nTypeOfAdapter |= eALG_FIREWALLED;
        
            if ( NAT_IFC_PRIVATE(nInterfaceCharacteristics) ) 
                nTypeOfAdapter |= eALG_PRIVATE;

        
            hr = pIAlgController->Adapter_Add(
                Index,            
                (short)nTypeOfAdapter
                );

            if ( FAILED(hr) )
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmAddInterface: Error (0x%08x) returned from pIalgController->Adapter_Add()",
                    hr
                    );
            }
 
            pIAlgController->Release();
        }
	}

    COMINIT_END;

    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmAddInterface


ULONG
APIENTRY
AlgRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = S_OK;
    PROFILE("AlgRmDeleteInterface");


    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Also notify the ALG.exe manager
    //
    HRESULT hr;

    COMINIT_BEGIN;

    if ( SUCCEEDED(hr) )
    {
        IAlgController* pIAlgController=NULL;
        HRESULT hr = GetAlgControllerInterface(&pIAlgController);

        if ( SUCCEEDED(hr) )
        {
            hr = pIAlgController->Adapter_Remove(Index);
            
               if ( FAILED(hr) )
               {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "AlgRmAddInterface: Error (0x%08x) returned from pIalgController->Adapter_Remove()",
                    hr
                    );
               }

            pIAlgController->Release();
        }
    }

    COMINIT_END;
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmDeleteInterface





ULONG
APIENTRY
AlgRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = AlgRmBindInterface(Index, StatusInfo);
            } else {
                Error = AlgRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = AlgRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = AlgRmDisableInterface(Index);
            break;
        }
    }

    return Error;

} // AlgRmInterfaceStatus


ULONG
AlgRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmBindInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    HRESULT hr;

    //
    // Also notify the ALG.exe manager
    //
    ULONG nAddressCount = ((PIP_ADAPTER_BINDING_INFO)BindingInfo)->AddressCount;

    //
    // Build a simple array of address(DWORD) to send over RPC
    //
    DWORD* apdwAddress = new DWORD[((PIP_ADAPTER_BINDING_INFO)BindingInfo)->AddressCount];
    if(NULL != apdwAddress)
    {
        
        
        for ( ULONG nAddress=0; nAddress < nAddressCount; nAddress++ )
        {
            apdwAddress[nAddress] = ((PIP_ADAPTER_BINDING_INFO)BindingInfo)->Address[nAddress].Address;
        }
        
        
        COMINIT_BEGIN;
        
        if ( SUCCEEDED(hr) )
        {
            IAlgController* pIAlgController=NULL;
            HRESULT hr = GetAlgControllerInterface(&pIAlgController);
            
            if ( SUCCEEDED(hr) )
            {
                ULONG nRealAdapterIndex = NhMapAddressToAdapter(apdwAddress[0]);
                
                hr = pIAlgController->Adapter_Bind(
                    Index,            
                    nRealAdapterIndex,
                    nAddressCount,
                    apdwAddress
                    );
                
                if ( FAILED(hr) )
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "AlgRmBinInterface: Error (0x%08x) returned from pIalgController->Adapter_Bind()",
                        hr
                        );
                }
                
                pIAlgController->Release();
            }
        }
        
        COMINIT_END;

        delete [] apdwAddress;
    }
    
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmBindInterface


ULONG
AlgRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmUnbindInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
/*
    Error =
        AlgUnbindInterface(
            Index
            );
*/
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmUnbindInterface


ULONG
AlgRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmEnableInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
/*
    Error =
        AlgEnableInterface(
            Index
            );
*/
    DEREFERENCE_ALG_AND_RETURN(Error);

} // AlgRmEnableInterface


ULONG
AlgRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("AlgRmDisableInterface");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);
    DEREFERENCE_ALG_AND_RETURN(Error);
} // AlgRmDisableInterface


ULONG
APIENTRY
AlgRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("AlgRmGetGlobalInfo");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&AlgGlobalInfoLock);
    Size = sizeof(*AlgGlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&AlgGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_ALG_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, AlgGlobalInfo, Size);
    LeaveCriticalSection(&AlgGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}

    DEREFERENCE_ALG_AND_RETURN(NO_ERROR);
} // AlgRmGetGlobalInfo


ULONG
APIENTRY
AlgRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_ALG_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("AlgRmSetGlobalInfo");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_ALG_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*AlgGlobalInfo);
    NewInfo = reinterpret_cast<PIP_ALG_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "AlgRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_ALG_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_ALG_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&AlgGlobalInfoLock);
    OldFlags = AlgGlobalInfo->Flags;
    NH_FREE(AlgGlobalInfo);
    AlgGlobalInfo = NewInfo;
    NewFlags = AlgGlobalInfo->Flags;
    LeaveCriticalSection(&AlgGlobalInfoLock);

    DEREFERENCE_ALG_AND_RETURN(NO_ERROR);
} // AlgRmSetGlobalInfo

ULONG
AlgRmPortMappingChanged(
    ULONG Index,
    UCHAR Protocol,
    USHORT Port
    )

/*++

Routine Description:

    This routine is invoked when a port mapping has changed for
    an interface.

Arguments:

    Index - the index of the interface on which the port mapping 
        changed.

    Protcol - the IP protocol for the port mapping

    Port - the port for the port mapping
    
Return Value:

    ULONG - Win32 status code

Environment:

    This method must be called by a COM-initialized thread.

--*/

{
    ULONG Error = NO_ERROR;
    HRESULT hr;
    IAlgController* pIAlgController;
    
    PROFILE("AlgRmPortMappingChanged");

    REFERENCE_ALG_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    hr = GetAlgControllerInterface(&pIAlgController);
    if (SUCCEEDED(hr))
    {
        hr = pIAlgController->Adapter_PortMappingChanged(
                Index,
                Protocol,
                Port
                );
        
        pIAlgController->Release();
    }

    if (FAILED(hr))
    {
        Error = ERROR_CAN_NOT_COMPLETE;
    }

    DEREFERENCE_ALG_AND_RETURN(Error);
} // AlgRmPortMappingChanged
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpif.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpif.h

Abstract:

    This module contains declarations for the DHCP allocator's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:
    
--*/

#ifndef _NATHLP_DHCPIF_H_
#define _NATHLP_DHCPIF_H_

//
// Structure:   DHCP_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
// The 'TimerPending' field is set when a receive-attempt fails on an interface
// and a timer is queued to reattempt the receive later.
//

typedef struct _DHCP_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET Socket;
    SOCKET ClientSocket;
    BOOLEAN TimerPending;
} DHCP_BINDING, *PDHCP_BINDING;


//
// Structure:   DHCP_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of DHCP interfaces,
// sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('DhcpInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _DHCP_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index;
    NET_INTERFACE_TYPE Type;
    IP_AUTO_DHCP_INTERFACE_INFO Info;
    ULONG Flags;
    ULONG BindingCount;
    PDHCP_BINDING BindingArray;
} DHCP_INTERFACE, *PDHCP_INTERFACE;

//
// Flags
//

#define DHCP_INTERFACE_FLAG_DELETED         0x80000000
#define DHCP_INTERFACE_DELETED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_DELETED)

#define DHCP_INTERFACE_FLAG_BOUND           0x40000000
#define DHCP_INTERFACE_BOUND(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_BOUND)

#define DHCP_INTERFACE_FLAG_ENABLED         0x20000000
#define DHCP_INTERFACE_ENABLED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_ENABLED)

#define DHCP_INTERFACE_FLAG_CONFIGURED      0x10000000
#define DHCP_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_CONFIGURED)

#define DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY 0x08000000
#define DHCP_INTERFACE_NAT_NONBOUNDARY(i) \
    ((i)->Flags & DHCP_INTERFACE_FLAG_NAT_NONBOUNDARY)

#define DHCP_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (DHCP_INTERFACE_FLAG_BOUND|DHCP_INTERFACE_FLAG_ENABLED)) \
        == (DHCP_INTERFACE_FLAG_BOUND|DHCP_INTERFACE_FLAG_ENABLED))

#define DHCP_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_AUTO_DHCP_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define DHCP_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, DHCP_INTERFACE_DELETED)

#define DHCP_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, DhcpCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY DhcpInterfaceList;
extern CRITICAL_SECTION DhcpInterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
DhcpActivateInterface(
    PDHCP_INTERFACE Interfacep
    );

ULONG
DhcpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
DhcpCleanupInterface(
    PDHCP_INTERFACE Interfacep
    );

ULONG
DhcpConfigureInterface(
    ULONG Index,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo
    );

ULONG
DhcpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_AUTO_DHCP_INTERFACE_INFO InterfaceInfo,
    PDHCP_INTERFACE* InterfaceCreated
    );

VOID
DhcpDeactivateInterface(
    PDHCP_INTERFACE Interfacep
    );

VOID
DhcpDeferReadInterface(
    PDHCP_INTERFACE Interfacep,
    SOCKET Socket
    );

ULONG
DhcpDeleteInterface(
    ULONG Index
    );

ULONG
DhcpDisableInterface(
    ULONG Index
    );

ULONG
DhcpEnableInterface(
    ULONG Index
    );

ULONG
DhcpInitializeInterfaceManagement(
    VOID
    );

BOOLEAN
DhcpIsLocalHardwareAddress(
    PUCHAR HardwareAddress,
    ULONG HardwareAddressLength
    );

PDHCP_INTERFACE
DhcpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
DhcpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
DhcpReactivateEveryInterface(
    VOID
    );

VOID
DhcpShutdownInterfaceManagement(
    VOID
    );

VOID
DhcpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
DhcpUnbindInterface(
    ULONG Index
    );

ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    );


#endif // _NATHLP_DHCPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpio.c

Abstract:

    This module contains code for the DHCP allocator's network I/O.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
DhcpReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a datagram socket bound to the DHCP server UDP port.

    The message read is validated and processed, and if necessary,
    a reply is generated and sent to the client.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDHCP_HEADER Headerp;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpReadCompletionRoutine");

    do {

        //
        // There are two cases where we don't process the message;
        // (a) the I/O operation failed
        // (b) the interface is no longer active
        // In cases (a) we repost the buffer; in case (b) we do not.
        //

        Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

        //
        // First look for an error code
        //
    
        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "DhcpReadCompletionRoutine: error %d for read-context %x",
                ErrorCode,
                Bufferp->Context
                );
            //
            // See if the interface is still active
            //
            ACQUIRE_LOCK(Interfacep);
            if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                NhReleaseBuffer(Bufferp);
            }
            else {
                RELEASE_LOCK(Interfacep);
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    //
                    // Repost the buffer for another read operation
                    //
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                LeaveCriticalSection(&DhcpInterfaceLock);
            }
            break;
        }

        //
        // Now see if the interface is operational
        //

        ACQUIRE_LOCK(Interfacep);
        if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "DhcpReadCompletionRoutine: interface %x inactive",
                Interfacep
                );
            break;
        }
        RELEASE_LOCK(Interfacep);

        //
        // Now look at the message
        //

        Headerp = (PDHCP_HEADER)Bufferp->Buffer;

        switch (Headerp->Operation) {

            case BOOTP_OPERATION_REQUEST: {
                DhcpProcessMessage(
                    Interfacep,
                    Bufferp
                    );
                break;
            }

            case BOOTP_OPERATION_REPLY: {
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                    );
                    
                NhTrace(
                    TRACE_FLAG_IO,
                    "DhcpReadCompletionRoutine: ignoring BOOTPREPLY"
                    );
                //
                // Repost the buffer for another read operation.
                //
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                break;
            }

            default: {
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                    )
                    ;
                NhTrace(
                    TRACE_FLAG_IO,
                    "DhcpReadCompletionRoutine: ignoring invalid BOOTP operation %d",
                    Headerp->Operation
                    );
                NhInformationLog(
                    IP_AUTO_DHCP_LOG_INVALID_BOOTP_OPERATION,
                    0,
                    "%d",
                    Headerp->Operation
                    );
                //
                // Repost the buffer for another read operation.
                //
                EnterCriticalSection(&DhcpInterfaceLock);
                if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                }
                else {
                    LeaveCriticalSection(&DhcpInterfaceLock);
                    Error =
                        NhReadDatagramSocket(
                            &DhcpComponentReference,
                            Bufferp->Socket,
                            Bufferp,
                            DhcpReadCompletionRoutine,
                            Bufferp->Context,
                            Bufferp->Context2
                            );
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DHCP_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
                break;
            }
        }

    } while(FALSE);

    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_DHCP();

} // DhcpReadCompletionRoutine


VOID
DhcpReadServerReplyCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a receive-operation
    on a socket bound to the DHCP client port, when the component
    is attempting to detect the presence of a DHCP server.

Arguments:

    ErrorCode - system-supplied status code

    BytesTransferred - system-supplied byte count

    Bufferp - send buffer

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread upon removal
    of an I/O completion packet.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Address;
    ULONG Error;
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpReadServerReplyCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

    if (ErrorCode) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: error %d receiving %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    ACQUIRE_LOCK(Interfacep);
    if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
        RELEASE_LOCK(Interfacep);
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }
    RELEASE_LOCK(Interfacep);

    //
    // Inspect the message read
    //

    Address = NhQueryAddressSocket(Bufferp->Socket);

    if (NhIsLocalAddress(Bufferp->ReadAddress.sin_addr.s_addr)) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: ignoring, from self (%s)",
            INET_NTOA(Address)
            );
    } else {
        CHAR LocalAddress[16];

        lstrcpyA(LocalAddress, INET_NTOA(Address));
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: %s found, disabling %d (%s)",
            INET_NTOA(Bufferp->ReadAddress.sin_addr),
            Interfacep->Index,
            LocalAddress
            );

        //
        // We received this from another server.
        // We'll need to disable this interface.
        //

        DhcpDisableInterface(Interfacep->Index);
        NhErrorLog(
            IP_AUTO_DHCP_LOG_DUPLICATE_SERVER,
            0,
            "%I%I",
            Bufferp->ReadAddress.sin_addr.s_addr,
            Address
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    //
    // We received it from ourselves.
    // Look for another server.
    //

    Error =
        NhReadDatagramSocket(
            &DhcpComponentReference,
            Bufferp->Socket,
            Bufferp,
            DhcpReadServerReplyCompletionRoutine,
            Bufferp->Context,
            Bufferp->Context2
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpReadServerReplyCompletionRoutine: error %d reposting %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhReleaseBuffer(Bufferp);
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Address
            );
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    DEREFERENCE_DHCP();

} // DhcpReadServerReplyCompletionRoutine


VOID
DhcpWriteClientRequestCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a send-operation
    on a socket bound to the DHCP client port, when the component
    is attempting to detect the presence of a DHCP server.

Arguments:

    ErrorCode - system-supplied status code

    BytesTransferred - system-supplied byte count

    Bufferp - send buffer

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread upon removal
    of an I/O completion packet.
    A reference to the interface will have been made on our behalf
    by 'DhcpWriteClientRequestMessage'.
    A reference to the component will have been made on our behalf
    by 'NhWriteDatagramSocket'.

--*/

{
    PDHCP_INTERFACE Interfacep;
    ULONG Error;

    PROFILE("DhcpWriteClientRequestCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;

    if (ErrorCode) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpWriteClientRequestCompletionRoutine: error %d broadcast %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            ErrorCode,
            "%I",
            NhQueryAddressSocket(Bufferp->Socket)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    ACQUIRE_LOCK(Interfacep);
    if (!DHCP_INTERFACE_ACTIVE(Interfacep)) {
        RELEASE_LOCK(Interfacep);
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }
    RELEASE_LOCK(Interfacep);

    //
    // Reuse the send buffer to listen for a response from the server
    //

    Error =
        NhReadDatagramSocket(
            &DhcpComponentReference,
            Bufferp->Socket,
            Bufferp,
            DhcpReadServerReplyCompletionRoutine,
            Bufferp->Context,
            Bufferp->Context2
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IO,
            "DhcpWriteClientRequestCompletionRoutine: error %d receiving %s",
            ErrorCode,
            INET_NTOA(Bufferp->Context2)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            NhQueryAddressSocket(Bufferp->Socket)
            );
        NhReleaseBuffer(Bufferp);
        DHCP_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DHCP();
        return;
    }

    DEREFERENCE_DHCP();

} // DhcpWriteClientRequestCompletionRoutine



VOID
DhcpWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a datagram socket bound to the DHCP server UDP port.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the interface will have been made on our behalf
    by the code which invoked 'NhWriteDatagramSocket'.
    A reference to the component will have been made on our behalf
    within 'NhWriteDatagramSocket'.

--*/

{
    PDHCP_INTERFACE Interfacep;

    PROFILE("DhcpWriteCompletionRoutine");

    Interfacep = (PDHCP_INTERFACE)Bufferp->Context;
    DHCP_DEREFERENCE_INTERFACE(Interfacep);
    NhReleaseBuffer(Bufferp);
    DEREFERENCE_DHCP();

} // DhcpWriteCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpio.h

Abstract:

    This module contains declarations for the DHCP allocator's network I/O
    completion routines.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPIO_H_
#define _NATHLP_DHCPIO_H_


//
// CONSTANT DECLARATIONS
//

#define DHCP_ADDRESS_BROADCAST  0xffffffff


//
// FUNCTION DECLARATIONS
//

VOID
DhcpReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpReadServerReplyCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpWriteClientRequestCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DhcpWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DHCPIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcplog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcplog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   14-Mar-1998

Revision History:

--*/

#define IP_AUTO_DHCP_LOG_BASE                       30000

#define IP_AUTO_DHCP_LOG_SENDARP_FAILED             (IP_AUTO_DHCP_LOG_BASE+1)
/*
 * The DHCP allocator was unable to check whether the IP address %1
 * is in use on the network for local IP address %2.
 * This error may indicate lack of support for address-resolution on the
 * network, or an error condition on the local machine.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_ACTIVATE_FAILED            (IP_AUTO_DHCP_LOG_BASE+2)
/*
 * The DHCP allocator was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_ALLOCATION_FAILED          (IP_AUTO_DHCP_LOG_BASE+3)
/*
 * The DHCP allocator was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_AUTO_DHCP_LOG_INVALID_BOOTP_OPERATION    (IP_AUTO_DHCP_LOG_BASE+4)
/*
 * The DHCP allocator received a message containing an unrecognized code (%1).
 * The message was neither a BOOTP request nor a BOOTP reply, and was ignored.
 */

#define IP_AUTO_DHCP_LOG_DUPLICATE_SERVER           (IP_AUTO_DHCP_LOG_BASE+5)
/*
 * The DHCP allocator has detected a DHCP server with IP address %1
 * on the same network as the interface with IP address %2.
 * The allocator has disabled itself on the interface in order to avoid
 * confusing DHCP clients.
 */

#define IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE      (IP_AUTO_DHCP_LOG_BASE+6)
/*
 * The DHCP allocator encountered a network error while attempting to detect
 * existing DHCP servers on the network of the interface with IP address %1.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_MESSAGE_TOO_SMALL          (IP_AUTO_DHCP_LOG_BASE+7)
/*
 * The DHCP allocator received a message smaller than the minimum message size.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_INVALID_FORMAT             (IP_AUTO_DHCP_LOG_BASE+8)
/*
 * The DHCP allocator received a message whose format was invalid.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_REPLY_FAILED               (IP_AUTO_DHCP_LOG_BASE+9)
/*
 * The DHCP allocator encountered a network error while attempting to reply
 * on IP address %1 to a request from a client.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_INVALID_DHCP_MESSAGE_TYPE  (IP_AUTO_DHCP_LOG_BASE+10)
/*
 * The DHCP allocator received a DHCP message containing an unrecognized
 * message type (%1) in the DHCP message type option field.
 * The message has been discarded.
 */

#define IP_AUTO_DHCP_LOG_RECEIVE_FAILED             (IP_AUTO_DHCP_LOG_BASE+11)
/*
 * The DHCP allocator encountered a network error while attempting to
 * receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_AUTO_DHCP_LOG_NAT_INTERFACE_IGNORED      (IP_AUTO_DHCP_LOG_BASE+12)
/*
 * The DHCP allocator detected network address translation (NAT) enabled
 * on the interface with index '%1'.
 * The allocator has disabled itself on the interface in order to avoid
 * confusing DHCP clients.
 */

#define IP_AUTO_DHCP_LOG_NON_SCOPE_ADDRESS          (IP_AUTO_DHCP_LOG_BASE+13)
/*
 * The DHCP allocator has disabled itself on IP address %1,
 * since the IP address is outside the %2/%3 scope
 * from which addresses are being allocated to DHCP clients.
 * To enable the DHCP allocator on this IP address,
 * please change the scope to include the IP address,
 * or change the IP address to fall within the scope.
 */

#define IP_AUTO_DHCP_LOG_END                        (IP_AUTO_DHCP_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpmsg.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpmsg.h

Abstract:

    This module contains declarations related to the DHCP allocator's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DHCPMSG_H_
#define _NATHLP_DHCPMSG_H_

//
// CONSTANT DECLARATIONS
//

#define DHCP_MAXIMUM_RENEWAL_TIME   (5 * 60)

#define DHCP_NBT_NODE_TYPE_B        1
#define DHCP_NBT_NODE_TYPE_P        2
#define DHCP_NBT_NODE_TYPE_M        4
#define DHCP_NBT_NODE_TYPE_H        8

//
// DHCP message format
//

#include <pshpack1.h>

//
// Disable "zero-sized array in struct/union" warning
//

#pragma warning(push)
#pragma warning(disable : 4200)

typedef struct _DHCP_OPTION {
    UCHAR Tag;
    UCHAR Length;
    UCHAR Option[];
} DHCP_OPTION, *PDHCP_OPTION;

typedef struct _DHCP_FOOTER {
    UCHAR Cookie[4];
} DHCP_FOOTER, *PDHCP_FOOTER;

typedef struct _DHCP_HEADER {
    UCHAR Operation;
    UCHAR HardwareAddressType;
    UCHAR HardwareAddressLength;
    UCHAR HopCount;
    ULONG TransactionId;
    USHORT SecondsSinceBoot;
    USHORT Flags;
    ULONG ClientAddress;
    ULONG AssignedAddress;
    ULONG BootstrapServerAddress;
    ULONG RelayAgentAddress;
    UCHAR HardwareAddress[16];
    UCHAR ServerHostName[64];
    UCHAR BootFile[128];
    DHCP_FOOTER Footer[];
} DHCP_HEADER, *PDHCP_HEADER;

#pragma warning(pop)

#include <poppack.h>


//
// MACRO DECLARATIONS
//

//
// BOOTP operation codes
//

#define BOOTP_OPERATION_REQUEST 1
#define BOOTP_OPERATION_REPLY   2

//
// BOOTP flags
//

#define BOOTP_FLAG_BROADCAST    0x0080

//
// BOOTP maximum option-area size
//

#define BOOTP_VENDOR_LENGTH     64

//
// Internal transaction ID for DHCP server detection
//

#define DHCP_DETECTION_TRANSACTION_ID   'MSFT'

//
// DHCP magic cookie
//

#define DHCP_MAGIC_COOKIE       ((99 << 24) | (83 << 16) | (130 << 8) | (99))
#define DHCP_MAGIC_COOKIE_SIZE  4

//
// DHCP option tag values
//

#define DHCP_TAG_PAD                    0
#define DHCP_TAG_SUBNET_MASK            1
#define DHCP_TAG_ROUTER                 3
#define DHCP_TAG_DNS_SERVER             6
#define DHCP_TAG_HOST_NAME              12
#define DHCP_TAG_DOMAIN_NAME            15
#define DHCP_TAG_STATIC_ROUTE           33
#define DHCP_TAG_WINS_SERVER            44
#define DHCP_TAG_NBT_NODE_TYPE          46
#define DHCP_TAG_NBT_SCOPE              47
#define DHCP_TAG_REQUESTED_ADDRESS      50
#define DHCP_TAG_LEASE_TIME             51
#define DHCP_TAG_OPTION_OVERLOAD        52
#define DHCP_TAG_MESSAGE_TYPE           53
#define DHCP_TAG_SERVER_IDENTIFIER      54
#define DHCP_TAG_PARAMETER_REQUEST_LIST 55
#define DHCP_TAG_ERROR_MESSAGE          56
#define DHCP_TAG_MAXIMUM_MESSAGE_SIZE   57
#define DHCP_TAG_RENEWAL_TIME           58
#define DHCP_TAG_REBINDING_TIME         59
#define DHCP_TAG_VENDOR_CLASS           60
#define DHCP_TAG_CLIENT_IDENTIFIER      61
#define DHCP_TAG_DYNAMIC_DNS            81
#define DHCP_TAG_END                    255

//
// Enumeration: DHCP_OPTION_INDEX
//
// The following enumerates the options of interest to the DHCP allocator.
// The enumeration aids in the processing of the options.
// (See 'DhcpExtractOptionsFromMessage').
//

typedef enum {
    DhcpOptionClientIdentifier,
    DhcpOptionMessageType,
    DhcpOptionRequestedAddress,
    DhcpOptionParameterRequestList,
    DhcpOptionErrorMessage,
    DhcpOptionDynamicDns,
    DhcpOptionHostName,
    DhcpOptionCount
} DHCP_OPTION_INDEX;

//
// DHCP message type values
//

#define DHCP_MESSAGE_BOOTP              0
#define DHCP_MESSAGE_DISCOVER           1
#define DHCP_MESSAGE_OFFER              2
#define DHCP_MESSAGE_REQUEST            3
#define DHCP_MESSAGE_DECLINE            4
#define DHCP_MESSAGE_ACK                5
#define DHCP_MESSAGE_NAK                6
#define DHCP_MESSAGE_RELEASE            7
#define DHCP_MESSAGE_INFORM             8


//
// IP/1394 support (RFC 2855)
//
#define IP1394_HTYPE                    0x18


//
// FUNCTION DECLARATIONS
//

ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessBootpMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessDiscoverMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessInformMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DhcpProcessMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

VOID
DhcpProcessRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

ULONG
DhcpWriteClientRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PDHCP_BINDING Binding
    );

#endif // _NATHLP_DHCPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmdhcp.h"
#include "rmdns.h"

#include "dhcpauto.h"
#include "dhcpif.h"
#include "dhcpio.h"
#include "dhcplog.h"
#include "dhcpmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\dhcpmsg.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dhcpmsg.c

Abstract:

    This module contains declarations related to the DHCP allocator's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            15-Dec-2000
    + Changed manner in which the option DHCP_TAG_DOMAIN_NAME is
    added in DhcpBuildReplyMessage().
    + Inform DNS component via DnsUpdate() in DhcpProcessRequestMessage().

    Raghu Gatta (rgatta)            20-Apr-2001
    + IP/1394 support changes

--*/

#include "precomp.h"
#pragma hdrstop

//
// EXTERNAL DECLARATIONS
//
extern PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo;
extern PWCHAR DnsICSDomainSuffix;
extern CRITICAL_SECTION DnsGlobalInfoLock;

//
// FORWARD DECLARATIONS
//

VOID
DhcpAppendOptionToMessage(
    DHCP_OPTION UNALIGNED** Optionp,
    UCHAR Tag,
    UCHAR Length,
    UCHAR Option[]
    );

VOID
DhcpBuildReplyMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED** Option,
    UCHAR MessageType,
    BOOLEAN DynamicDns,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    );

VOID
DnsUpdate(
    CHAR *pszName,
    ULONG len,
    ULONG ulAddress
    );


VOID
DhcpAppendOptionToMessage(
    DHCP_OPTION UNALIGNED** Optionp,
    UCHAR Tag,
    UCHAR Length,
    UCHAR Option[]
    )
/*++

Routine Description:

    This routine is invoked to append an option to a DHCP message.

Arguments:

    Optionp - on input, the point at which to append the option;
        on output, the point at which to append the next option.

    Tag - the option tag

    Length - the option length

    Option - the option's data

Return Value:

    none.

--*/

{
    PROFILE("DhcpAppendOptionToMessage");

    (*Optionp)->Tag = Tag;

    if (!Length) {
        *Optionp = (DHCP_OPTION UNALIGNED *)((PUCHAR)*Optionp + 1);
    } else {
        (*Optionp)->Length = Length;
        CopyMemory((*Optionp)->Option, Option, Length);
        *Optionp = (DHCP_OPTION UNALIGNED *)((PUCHAR)*Optionp + Length + 2);
    }

} // DhcpAppendOptionToMessage


VOID
DhcpBuildReplyMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED** Option,
    UCHAR MessageType,
    BOOLEAN DynamicDns,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to construct the options portion
    of a reply message.

Arguments:

    Interfacep - the interface on which the reply will be sent

    Bufferp - the buffer containing the reply

    Option - the start of the options portion on input;
        on output, the end of the message

    MessageType - the type of message to be sent

    DynamicDns - indicates whether to include the 'dynamic-dns' option.

    OptionArray - options extracted from message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG Address;
    ULONG SubnetMask;
    ULONG i;

    //
    // Obtain the address and mask for the endpoint
    //

    Address = NhQueryAddressSocket(Bufferp->Socket);
    SubnetMask = PtrToUlong(Bufferp->Context2);

    if (MessageType == DHCP_MESSAGE_BOOTP) {
        ((PDHCP_HEADER)Bufferp->Buffer)->BootstrapServerAddress = Address;
    } else {

        //
        // Always begin with the 'message-type' option.
        //

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_MESSAGE_TYPE,
            1,
            &MessageType
            );

        //
        // Provide our address as the server-identifier
        //

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_SERVER_IDENTIFIER,
            4,
            (PUCHAR)&Address
            );
    }

    if (MessageType != DHCP_MESSAGE_NAK) {

        PCHAR DomainName;
        ULONG dnSize;
        ULONG LeaseTime;
        UCHAR NbtNodeType = DHCP_NBT_NODE_TYPE_M;
        ULONG RebindingTime;
        ULONG RenewalTime;

        EnterCriticalSection(&DhcpGlobalInfoLock);
        LeaseTime = DhcpGlobalInfo->LeaseTime * 60;
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        RebindingTime = (LeaseTime * 3) / 4;
        RenewalTime = LeaseTime / 2;
        if (RenewalTime > DHCP_MAXIMUM_RENEWAL_TIME) {
            RenewalTime = DHCP_MAXIMUM_RENEWAL_TIME;
        }

        LeaseTime = htonl(LeaseTime);
        RebindingTime = htonl(RebindingTime);
        RenewalTime = htonl(RenewalTime);

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_SUBNET_MASK,
            4,
            (PUCHAR)&SubnetMask
            );

        DhcpAppendOptionToMessage(
            Option,
            DHCP_TAG_ROUTER,
            4,
            (PUCHAR)&Address
            );

        ////
        //// RFC 2132 9.14 : server treats client identifier as an opaque object
        //// append the client identifier if present in received message
        ////
        //if (OptionArray[DhcpOptionClientIdentifier])
        //{
        //    DhcpAppendOptionToMessage(
        //        Option,
        //        DHCP_TAG_CLIENT_IDENTIFIER,
        //        OptionArray[DhcpOptionClientIdentifier]->Length,
        //        (PUCHAR)OptionArray[DhcpOptionClientIdentifier]->Option
        //        );
        //}

        if (MessageType != DHCP_MESSAGE_BOOTP) {

            //specify the DNS server in the message if DNS proxy is enabled 
            //or DNS server is running on local host
            if (NhIsDnsProxyEnabled() || !NoLocalDns) {
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DNS_SERVER,
                    4,
                    (PUCHAR)&Address
                    );
            }
    
            if (NhIsWinsProxyEnabled()) {
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_WINS_SERVER,
                    4,
                    (PUCHAR)&Address
                    );
            }
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_RENEWAL_TIME,
                4,
                (PUCHAR)&RenewalTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_REBINDING_TIME,
                4,
                (PUCHAR)&RebindingTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_LEASE_TIME,
                4,
                (PUCHAR)&LeaseTime
                );
    
            DhcpAppendOptionToMessage(
                Option,
                DHCP_TAG_NBT_NODE_TYPE,
                1,
                &NbtNodeType
                );
    
            if (DynamicDns) {
                UCHAR DynamicDns[3] = { 0x03, 0, 0 };
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DYNAMIC_DNS,
                    sizeof(DynamicDns),
                    DynamicDns
                    );
            }

            //if (NhpStopDnsEvent && DnsICSDomainSuffix)
            if (DnsGlobalInfo && DnsICSDomainSuffix)
            {
                EnterCriticalSection(&DnsGlobalInfoLock);
            
                dnSize = wcstombs(NULL, DnsICSDomainSuffix, 0);
                DomainName = reinterpret_cast<PCHAR>(NH_ALLOCATE(dnSize + 1));
                if (DomainName)
                {
                    wcstombs(DomainName, DnsICSDomainSuffix, (dnSize + 1));
                }

                LeaveCriticalSection(&DnsGlobalInfoLock);
            }
            else
            //
            // at this point we have no DNS enabled
            // so we default to old behaviour
            //
            {
                DomainName = NhQuerySharedConnectionDomainName();
            }

            if (DomainName)
            {
                //
                // We include the terminating nul in the domain name
                // even though the RFC says we should not, because
                // the DHCP server does so.
                //
                DhcpAppendOptionToMessage(
                    Option,
                    DHCP_TAG_DOMAIN_NAME,
                    (UCHAR)(lstrlenA(DomainName) + 1),
                    (PUCHAR)DomainName
                    );
                NH_FREE(DomainName);
            }

        }
    }

    DhcpAppendOptionToMessage(
        Option,
        DHCP_TAG_END,
        0,
        NULL
        );

} // DhcpBuildReplyMessage


ULONG
DhcpExtractOptionsFromMessage(
    PDHCP_HEADER Headerp,
    ULONG MessageSize,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is invoked to parse the options contained in a DHCP message.
    Pointers to each option are stored in the given option array.

Arguments:

    Headerp - the header of the DHCP message to be parsed

    MessageSize - the size of the message to be parsed

    OptionArray - receives the parsed options

Return Value:

    ULONG - Win32 status code.

--*/

{
    DHCP_OPTION UNALIGNED* Index;
    DHCP_OPTION UNALIGNED* End;

    PROFILE("DhcpExtractOptionsFromMessage");

    //
    // Initialize the option array to be empty
    //

    ZeroMemory(OptionArray, DhcpOptionCount * sizeof(PDHCP_OPTION));

    //
    // Check that the message is large enough to hold options
    //

    if (MessageSize < sizeof(DHCP_HEADER)) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpExtractOptionsFromMessage: message size %d too small",
            MessageSize
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_MESSAGE_TOO_SMALL,
            0,
            ""
            );
        return ERROR_INVALID_DATA;
    }

    //
    // Ensure that the magic cookie is present; if not, there are no options.
    //

    if (MessageSize < (sizeof(DHCP_HEADER) + sizeof(DHCP_FOOTER)) ||
        *(ULONG UNALIGNED*)Headerp->Footer[0].Cookie != DHCP_MAGIC_COOKIE) {
        return NO_ERROR;
    }

    //
    // Parse the message's options, if any
    //

    End = (PDHCP_OPTION)((PUCHAR)Headerp + MessageSize);

    Index = (PDHCP_OPTION)&Headerp->Footer[1];
    
    while (Index < End && Index->Tag != DHCP_TAG_END) {

        if ((DHCP_TAG_PAD != Index->Tag) &&
            (End < (PDHCP_OPTION)(Index->Option + Index->Length))) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpExtractOptionsFromMessage: option truncated at %d bytes",
                MessageSize
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_INVALID_FORMAT,
                0,
                ""
                );
            return ERROR_INVALID_DATA;
        }

        switch (Index->Tag) {
            case DHCP_TAG_PAD:
                NhTrace(TRACE_FLAG_DHCP, "Pad");
                break;
            case DHCP_TAG_CLIENT_IDENTIFIER:
                NhTrace(TRACE_FLAG_DHCP, "ClientIdentifier");
                OptionArray[DhcpOptionClientIdentifier] = Index; break;
            case DHCP_TAG_MESSAGE_TYPE:
                NhTrace(TRACE_FLAG_DHCP, "MessageType");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionMessageType] = Index; break;
            case DHCP_TAG_REQUESTED_ADDRESS:
                NhTrace(TRACE_FLAG_DHCP, "RequestedAddress");
                if (Index->Length < 4) { break; }
                OptionArray[DhcpOptionRequestedAddress] = Index; break;
            case DHCP_TAG_PARAMETER_REQUEST_LIST:
                NhTrace(TRACE_FLAG_DHCP, "ParameterRequestList");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionParameterRequestList] = Index; break;
            case DHCP_TAG_ERROR_MESSAGE:
                NhTrace(TRACE_FLAG_DHCP, "ErrorMessage");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionErrorMessage] = Index; break;
            case DHCP_TAG_DYNAMIC_DNS:
                NhTrace(TRACE_FLAG_DHCP, "DynamicDns");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionDynamicDns] = Index; break;
            case DHCP_TAG_HOST_NAME:
                NhTrace(TRACE_FLAG_DHCP, "HostName");
                if (Index->Length < 1) { break; }
                OptionArray[DhcpOptionHostName] = Index; break;
        }

        if (DHCP_TAG_PAD != Index->Tag) {
            Index = (PDHCP_OPTION)(Index->Option + Index->Length);
        }
        else {
            Index = (PDHCP_OPTION)((PUCHAR)Index + 1);
        }
    }

    if (Index->Tag != DHCP_TAG_END) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpExtractOptionsFromMessage: message truncated to %d bytes",
            MessageSize
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_INVALID_FORMAT,
            0,
            ""
            );
        return ERROR_INVALID_DATA;
    }

    return NO_ERROR;

} // DhcpExtractOptionsFromMessage


VOID
DhcpProcessBootpMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received BOOTP message.

Arguments:

    Interfacep - the interface on which the message was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessBootpMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    if (!Headerp->ClientAddress) {
        AssignedAddress = 0;
    } else {
    
        //
        // Validate the address requested by the client
        //

        AssignedAddress = Headerp->ClientAddress;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-zeros
            // or all-ones address on the subnet.
            // Select a different address for the client.
            //
    
            AssignedAddress = 0;
        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //

            AssignedAddress = 0;

        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            AssignedAddress = 0;
        }
    }

    if (!AssignedAddress &&
        !(AssignedAddress =
            DhcpAcquireUniqueAddress(
                NULL,
                0,
                Headerp->HardwareAddress,
                Headerp->HardwareAddressLength
                ))) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessBootpMessage: address-allocation failed"
            );
        return;
    }

    //  
    // Acquire a buffer for the reply we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessBootpMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original buffer;
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original header
    //

    *Offerp = *Headerp;

    //
    // Set up the offer-header fields
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_BOOTP,
        FALSE,
        OptionArray
        );

    //
    // Send the offer to the BOOTP client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }

        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.BootpOffersSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessBootpMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessBootpMessage


VOID
DhcpProcessDiscoverMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received DHCPDISCOVER message.

Arguments:

    Interfacep - the interface on which the discover was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessDiscoverMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //
    // See if the client is renewing or requesting
    //

    if (!OptionArray[DhcpOptionRequestedAddress]) {

        AssignedAddress = 0;
    } else {

        //
        // Validate the address requested by the client
        //

        AssignedAddress =
            *(ULONG UNALIGNED*)OptionArray[DhcpOptionRequestedAddress]->Option;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-zeroes
            // or all-ones address on the subnet.
            // Select a different address for the client.
            //
    
            AssignedAddress = 0;
        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //

            AssignedAddress = 0;
        } else if (OptionArray[DhcpOptionHostName]) {
            if (DhcpIsReservedAddress(
                    AssignedAddress,
                    reinterpret_cast<PCHAR>(
                        OptionArray[DhcpOptionHostName]->Option
                        ),
                    OptionArray[DhcpOptionHostName]->Length
                    )) {

                //
                // The address is reserved for someone else,
                // or the client has a different address reserved.
                //

                AssignedAddress = 0;
            }
        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            AssignedAddress = 0;
        }
    }

    //
    // Generate an address for the client if necessary
    //

    if (!AssignedAddress) {
        if (!OptionArray[DhcpOptionHostName]) {
            AssignedAddress =
                DhcpAcquireUniqueAddress(
                    NULL,
                    0,
                    Headerp->HardwareAddress,
                    Headerp->HardwareAddressLength
                    );
        } else {
            AssignedAddress =
                DhcpAcquireUniqueAddress(
                    reinterpret_cast<PCHAR>(
                        OptionArray[DhcpOptionHostName]->Option
                        ),
                    OptionArray[DhcpOptionHostName]->Length,
                    Headerp->HardwareAddress,
                    Headerp->HardwareAddressLength
                    );
        }
        if (!AssignedAddress) {
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessDiscoverMessage: address-allocation failed"
                );
            return;
        }
    }

    //  
    // Acquire a buffer for the offer we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessDiscoverMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original message
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original discover header
    //

    *Offerp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Offerp->HardwareAddressType) &&
        (0 == Offerp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Offerp->HardwareAddress, sizeof(Offerp->HardwareAddress));
    }

    //
    // Set up the offer-header fieldds
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_OFFER,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // Send the offer to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.OffersSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessDiscoverMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessDiscoverMessage



VOID
DhcpProcessInformMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a received DHCPINFORM message.

Arguments:

    Interfacep - the interface on which the inform was received

    Bufferp - the buffer containing the message

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced by the caller.

--*/

{
    PDHCP_HEADER Ackp;
    ULONG Error;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;

    PROFILE("DhcpProcessInformMessage");

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //  
    // Acquire a buffer for the ack we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessInformMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields from the original message
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Ackp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original header
    //

    *Ackp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Ackp->HardwareAddressType) &&
        (0 == Ackp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Ackp->HardwareAddress, sizeof(Ackp->HardwareAddress));
    }
    
    //
    // Set up the ack-header fieldds
    //

    Ackp->Operation = BOOTP_OPERATION_REPLY;
    Ackp->AssignedAddress = 0;
    Ackp->ServerHostName[0] = 0;
    Ackp->BootFile[0] = 0;
    Ackp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Ackp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Ackp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        DHCP_MESSAGE_ACK,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // Send the offer to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.AcksSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessInformMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessInformMessage


VOID
DhcpProcessMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DHCP client message.

Arguments:

    Interfacep - the interface on which the request was received

    Bufferp - the buffer containing the message received

Return Value:

    none.

Environment:

    Invoked internally with 'Interfacep' referenced by the caller.

--*/

{
    ULONG Error;
    PDHCP_HEADER Headerp;
    UCHAR MessageType;
    PDHCP_OPTION OptionArray[DhcpOptionCount];

    PROFILE("DhcpProcessMessage");

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

#if DBG
    NhDump(
        TRACE_FLAG_DHCP,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );
#endif

    //
    // Extract pointers to each option in the message
    //

    Error =
        DhcpExtractOptionsFromMessage(
            Headerp,
            Bufferp->BytesTransferred,
            OptionArray
            );

    if (Error) {
        InterlockedIncrement(
            reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
            );
    }
    else
    //
    // Look for the message-type;
    // This distinguishes BOOTP from DHCP clients.
    //
    if (!OptionArray[DhcpOptionMessageType]) {
        DhcpProcessBootpMessage(
            Interfacep,
            Bufferp,
            OptionArray
            );
    } else if (Headerp->HardwareAddressLength <=
                sizeof(Headerp->HardwareAddress) &&
               DhcpIsLocalHardwareAddress(
                Headerp->HardwareAddress, Headerp->HardwareAddressLength)) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessMessage: ignoring message, from self"
            );
    } else switch(MessageType = OptionArray[DhcpOptionMessageType]->Option[0]) {
        case DHCP_MESSAGE_DISCOVER: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.DiscoversReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received DISCOVER message"
                );
            DhcpProcessDiscoverMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_REQUEST: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.RequestsReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received REQUEST message"
                );
            DhcpProcessRequestMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_INFORM: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.InformsReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received INFORM message"
                );
            DhcpProcessInformMessage(
                Interfacep,
                Bufferp,
                OptionArray
                );
            break;
        }
        case DHCP_MESSAGE_DECLINE: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.DeclinesReceived)
                );
            // log message
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received DECLINE message"
                );
            break;
        }
        case DHCP_MESSAGE_RELEASE: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.ReleasesReceived)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: received RELEASE message"
                );
            break;
        }
        default: {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DhcpStatistics.MessagesIgnored)
                );
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: message type %d invalid",
                MessageType
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_INVALID_DHCP_MESSAGE_TYPE,
                0,
                "%d",
                MessageType
                );
            break;
        }
    }

    //
    // Post the buffer for another read
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Bufferp);
    } else {
        LeaveCriticalSection(&DhcpInterfaceLock);
        Error =
            NhReadDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                Bufferp,
                DhcpReadCompletionRoutine,
                Bufferp->Context,
                Bufferp->Context2
                );
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DhcpDeferReadInterface(Interfacep, Bufferp->Socket);
            RELEASE_LOCK(Interfacep);
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessMessage: error %d reposting read",
                Error
                );
            NhWarningLog(
                IP_AUTO_DHCP_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
            NhReleaseBuffer(Bufferp);
        }
    }

} // DhcpProcessMessage


VOID
DhcpProcessRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PNH_BUFFER Bufferp,
    DHCP_OPTION UNALIGNED* OptionArray[]
    )

/*++

Routine Description:

    This routine is called to process a request message.

Arguments:

    Interfacep - the interface on which the request was received

    Bufferp - the buffer containing the message received

    OptionArray - options extracted from the message

Return Value:

    none.

Environment:

    Invoked internally with 'Interfacep' referenced by the caller.

--*/

{
    ULONG AssignedAddress = 0;
    ULONG Error;
    UCHAR ExistingAddress[MAX_HARDWARE_ADDRESS_LENGTH];
    ULONG ExistingAddressLength;
    PDHCP_HEADER Headerp;
    ULONG MessageLength;
    PDHCP_HEADER Offerp;
    DHCP_OPTION UNALIGNED* Option;
    ULONG ReplyAddress;
    USHORT ReplyPort;
    PNH_BUFFER Replyp;
    UCHAR ReplyType = DHCP_MESSAGE_ACK;
    ULONG ScopeNetwork;
    ULONG ScopeMask;
    BOOLEAN bIsLocal = FALSE;

    PROFILE("DhcpProcessRequestMessage");

    ZeroMemory(ExistingAddress, sizeof(ExistingAddress));

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    //
    // Validate the address requested by the client
    //

    if (!Headerp->ClientAddress && !OptionArray[DhcpOptionRequestedAddress]) {

        //
        // The client left out the address being requested
        //

        ReplyType = DHCP_MESSAGE_NAK;
    } else {

        //
        // Try to see if the address is in use.
        //

        AssignedAddress =
            Headerp->ClientAddress
                ? Headerp->ClientAddress
                : *(ULONG UNALIGNED*)
                        OptionArray[DhcpOptionRequestedAddress]->Option;
    
        EnterCriticalSection(&DhcpGlobalInfoLock);
        ScopeNetwork = DhcpGlobalInfo->ScopeNetwork;
        ScopeMask = DhcpGlobalInfo->ScopeMask;
        LeaveCriticalSection(&DhcpGlobalInfoLock);

        if ((AssignedAddress & ~ScopeMask) == 0 ||
            (AssignedAddress & ~ScopeMask) == ~ScopeMask ||
            (AssignedAddress & ScopeMask) != (ScopeNetwork & ScopeMask)) {

            //
            // The client is on the wrong subnet, or has an all-ones
            // or all-zeroes address.
            //

            ReplyType = DHCP_MESSAGE_NAK;

        } else if (!DhcpIsUniqueAddress(
                        AssignedAddress,
                        &bIsLocal,
                        ExistingAddress,
                        &ExistingAddressLength
                        ) &&
                    (bIsLocal ||
                    ((Headerp->HardwareAddressType != 7 && // due to WinXP Bridge bug + WinME Client bug
                      Headerp->HardwareAddressLength) &&   // if address length is zero we wont compare
                     (ExistingAddressLength < Headerp->HardwareAddressLength ||
                      memcmp(
                         ExistingAddress,
                         Headerp->HardwareAddress,
                         Headerp->HardwareAddressLength
                         ))))) {

            //
            // Someone has the requested address, and it's not the requestor.
            //
            
            ReplyType = DHCP_MESSAGE_NAK;

        } else if (OptionArray[DhcpOptionHostName]) {
            if (DhcpIsReservedAddress(
                AssignedAddress,
                reinterpret_cast<PCHAR>(
                    OptionArray[DhcpOptionHostName]->Option
                    ),
                OptionArray[DhcpOptionHostName]->Length
                )) {

                //
                // The address is reserved for someone else,
                // or the client has a different address reserved.
                //

                ReplyType = DHCP_MESSAGE_NAK;
            } 
        } else if (DhcpIsReservedAddress(AssignedAddress, NULL, 0)) {

            //
            // The address is reserved for someone else.
            //

            ReplyType = DHCP_MESSAGE_NAK;
        }
    }

    //  
    // Acquire a buffer for the reply we will send back
    //

    Replyp = NhAcquireBuffer();

    if (!Replyp) {
        NhTrace(
            TRACE_FLAG_DHCP,
            "DhcpProcessRequestMessage: buffer-allocation failed"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return;
    }

    //
    // Pick up fields to be used in the reply-buffer
    // the routines setting up the reply will attempt to read these,
    // so they are set to the values from the original buffer.
    //

    Replyp->Socket = Bufferp->Socket;
    Replyp->ReadAddress = Bufferp->ReadAddress;
    Replyp->WriteAddress = Bufferp->WriteAddress;
    Replyp->Context = Bufferp->Context;
    Replyp->Context2 = Bufferp->Context2;

    Offerp = (PDHCP_HEADER)Replyp->Buffer;

    //
    // Copy the original discover header
    //

    *Offerp = *Headerp;

    //
    // IP/1394 support (RFC 2855)
    //
    if ((IP1394_HTYPE == Offerp->HardwareAddressType) &&
        (0 == Offerp->HardwareAddressLength))
    {
        //
        // MUST set client hardware address to zero
        //
        ZeroMemory(Offerp->HardwareAddress, sizeof(Offerp->HardwareAddress));
    }

    //
    // Set up the offer-header fieldds
    //

    Offerp->Operation = BOOTP_OPERATION_REPLY;
    Offerp->AssignedAddress = AssignedAddress;
    Offerp->ServerHostName[0] = 0;
    Offerp->BootFile[0] = 0;
    Offerp->SecondsSinceBoot = 0;
    *(ULONG UNALIGNED *)Offerp->Footer[0].Cookie = DHCP_MAGIC_COOKIE;

    //
    // Fill in options
    //

    Option = (PDHCP_OPTION)&Offerp->Footer[1];

    DhcpBuildReplyMessage(
        Interfacep,
        Replyp,
        &Option,
        ReplyType,
        (BOOLEAN)(OptionArray[DhcpOptionDynamicDns] ? TRUE : FALSE),
        OptionArray
        );

    //
    // NEW LOGIC HERE => tied to DNS
    //
    if (DHCP_MESSAGE_ACK == ReplyType)
    {
        //
        // We perform the equivalent of Dynamic DNS here
        // by informing the DNS component that this client exists
        //
        if (OptionArray[DhcpOptionHostName])
        {
            //
            // check if DNS component is active
            //
            if (REFERENCE_DNS())
            {
                DnsUpdate(
                    reinterpret_cast<PCHAR>(OptionArray[DhcpOptionHostName]->Option),
                    (ULONG) OptionArray[DhcpOptionHostName]->Length,
                    AssignedAddress
                    );

                DEREFERENCE_DNS();
            }
        }
    }

    //
    // Send the reply to the client
    //

    EnterCriticalSection(&DhcpInterfaceLock);
    if (!DHCP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DhcpInterfaceLock);
        NhReleaseBuffer(Replyp);
    } else {

        LeaveCriticalSection(&DhcpInterfaceLock);

        if (Headerp->RelayAgentAddress) {
            ReplyAddress = Headerp->RelayAgentAddress;
            ReplyPort = DHCP_PORT_SERVER;
        } else {
            ReplyAddress = INADDR_BROADCAST;
            ReplyPort = DHCP_PORT_CLIENT;
        }
    
        MessageLength = (ULONG)((PUCHAR)Option - Replyp->Buffer);
        if (MessageLength < sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH) {
            MessageLength = sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH;
        }
    
        Error =
            NhWriteDatagramSocket(
                &DhcpComponentReference,
                Bufferp->Socket,
                ReplyAddress,
                ReplyPort,
                Replyp,
                MessageLength,
                DhcpWriteCompletionRoutine,
                Interfacep,
                Bufferp->Context2
                );

        if (!Error) {
            InterlockedIncrement(
                (ReplyType == DHCP_MESSAGE_ACK)
                    ? reinterpret_cast<LPLONG>(&DhcpStatistics.AcksSent)
                    : reinterpret_cast<LPLONG>(&DhcpStatistics.NaksSent)
                );
        } else {
            DHCP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Replyp);
            NhTrace(
                TRACE_FLAG_DHCP,
                "DhcpProcessRequestMessage: error %d sending reply",   
                Error
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_REPLY_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

} // DhcpProcessRequestMessage


ULONG
DhcpWriteClientRequestMessage(
    PDHCP_INTERFACE Interfacep,
    PDHCP_BINDING Binding
    )

/*++

Routine Description:

    This routine is invoked to check for the existence of a DHCP server
    on the given interface and address. It generates a BOOTP request
    on a socket bound to the DHCP client port.

Arguments:

    Interfacep - the interface on which the client request is to be sent

    Binding - the binding on which the request is to be sent

Return Value:

    ULONG - status code.

Environment:

    Invoked with 'Interfacep' locked and with a reference made to 'Interfacep'
    for the send which occurs here.
    If the routine fails, it is the caller's responsibility to release
    the reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    PDHCP_HEADER Headerp;
    SOCKET Socket;

    PROFILE("DhcpWriteClientRequestMessage");

    //
    // Create a socket using the given address
    //

    Error =
        NhCreateDatagramSocket(
            Binding->Address,
            DHCP_PORT_CLIENT,
            &Binding->ClientSocket
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error %d creating socket for %s",
            Error,
            INET_NTOA(Binding->Address)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Binding->Address
            );
        return Error;
    }

    //
    // Allocate a buffer for the BOOTP request
    //

    Bufferp = NhAcquireBuffer();
    if (!Bufferp) {
        NhDeleteDatagramSocket(Binding->ClientSocket);
        Binding->ClientSocket = INVALID_SOCKET;
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error allocating buffer for %s",
            INET_NTOA(Binding->Address)
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NH_BUFFER)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the BOOTP request
    //

    Headerp = (PDHCP_HEADER)Bufferp->Buffer;

    ZeroMemory(Headerp, sizeof(*Headerp));

    Headerp->Operation = BOOTP_OPERATION_REQUEST;
    Headerp->HardwareAddressType = 1;
    Headerp->HardwareAddressLength = 6;
    Headerp->TransactionId = DHCP_DETECTION_TRANSACTION_ID;
    Headerp->SecondsSinceBoot = 10;
    Headerp->Flags |= BOOTP_FLAG_BROADCAST;
    Headerp->ClientAddress = Binding->Address;
    Headerp->HardwareAddress[1] = 0xab;
    *(PULONG)(Headerp->Footer[0].Cookie) = DHCP_MAGIC_COOKIE;
    *(PUCHAR)(Headerp->Footer + 1) = DHCP_TAG_END;

    //
    // Send the BOOTP request on the socket
    //

    Error =
        NhWriteDatagramSocket(
            &DhcpComponentReference,
            Binding->ClientSocket,
            INADDR_BROADCAST,
            DHCP_PORT_SERVER,
            Bufferp,
            sizeof(DHCP_HEADER) + BOOTP_VENDOR_LENGTH,
            DhcpWriteClientRequestCompletionRoutine,
            (PVOID)Interfacep,
            UlongToPtr(Binding->Address)
            );

    if (Error) {
        NhReleaseBuffer(Bufferp);
        NhDeleteDatagramSocket(Binding->ClientSocket);
        Binding->ClientSocket = INVALID_SOCKET;
        NhTrace(
            TRACE_FLAG_IF,
            "DhcpWriteClientRequestMessage: error %d writing request for %s",
            Error,
            INET_NTOA(Binding->Address)
            );
        NhWarningLog(
            IP_AUTO_DHCP_LOG_DETECTION_UNAVAILABLE,
            Error,
            "%I",
            Binding->Address
            );
        return Error;
    }

    return NO_ERROR;

} // DhcpWriteClientRequestMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\debug.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module contains declarations for debugging-support.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE NhEventLogHandle = NULL;
ULONG NhpTraceId = INVALID_TRACEID;

//
// FORWARD DECLARATIONS
//

BOOLEAN
NhpIsAllowedLog(
    ULONG MessageId,
    ULONG Level
    );

//
// TRACING ROUTINES (alphabetically)
//

VOID
NhDump(
    ULONG Flags,
    PUCHAR Buffer,
    ULONG BufferLength,
    ULONG Width
    )
{
    TraceDumpEx(
        NhpTraceId,
        Flags,
        Buffer,
        BufferLength,
        Width,
        FALSE,
        NULL
        );
}

VOID
NhInitializeTraceManagement(
    VOID
    )
{
    NhpTraceId = TraceRegisterA("IPNATHLP");
}

VOID
NhShutdownTraceManagement(
    VOID
    )
{
    TraceDeregister(NhpTraceId);
    NhpTraceId = INVALID_TRACEID;
}

VOID
NhTrace(
    ULONG Flags,
    PCHAR Format,
    ...
    )
{
    va_list VaList;

    va_start(VaList, Format);
    TraceVprintfExA(NhpTraceId, Flags, Format, VaList);
    va_end(VaList);
}


//
// EVENTLOGGING ROUTINES (alphabetically)
//

VOID
NhErrorLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_ERROR)) { return; }
    va_start(arglist, Format);
    RouterLogEventValistExA(
        NhEventLogHandle,
        EVENTLOG_ERROR_TYPE,
        ErrorCode,
        MessageId,
        Format,
        arglist
        );
    va_end(arglist);
}

VOID
NhInformationLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_INFO)) { return; }
    va_start(arglist, Format);
    RouterLogEventValistExA(
        NhEventLogHandle,
        EVENTLOG_INFORMATION_TYPE,
        ErrorCode,
        MessageId,
        Format,
        arglist
        );
    va_end(arglist);
}

VOID
NhInitializeEventLogManagement(
    VOID
    )
{
    NhEventLogHandle = RouterLogRegisterA(TARGETNAME);
}

BOOLEAN
NhpIsAllowedLog(
    ULONG MessageId,
    ULONG Level
    )
{
    if (MessageId > IP_AUTO_DHCP_LOG_BASE && MessageId < IP_AUTO_DHCP_LOG_END) {
        EnterCriticalSection(&DhcpGlobalInfoLock);
        if (!DhcpGlobalInfo) {
            LeaveCriticalSection(&DhcpGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (DhcpGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&DhcpGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        return TRUE;
    } else if (MessageId > IP_DNS_PROXY_LOG_BASE &&
                MessageId < IP_DNS_PROXY_LOG_END) {
        EnterCriticalSection(&DnsGlobalInfoLock);
        if (!DnsGlobalInfo) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (DnsGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&DnsGlobalInfoLock);
        return TRUE;
    } 

#ifndef NO_FTP_PROXY
    else if (MessageId > IP_FTP_LOG_BASE && MessageId < IP_FTP_LOG_END) {
        EnterCriticalSection(&FtpGlobalInfoLock);
        if (!FtpGlobalInfo) {
            LeaveCriticalSection(&FtpGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (FtpGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&FtpGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&FtpGlobalInfoLock);
        return TRUE;
    }
#endif
    else if (MessageId > IP_H323_LOG_BASE && MessageId < IP_H323_LOG_END) {
        EnterCriticalSection(&H323GlobalInfoLock);
        if (!H323GlobalInfo) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (H323GlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&H323GlobalInfoLock);
        return TRUE;
    } else if (MessageId > IP_NAT_LOG_BASE && MessageId < IP_NAT_LOG_END) {
        EnterCriticalSection(&NatGlobalInfoLock);
        if (!NatGlobalInfo) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            return (Level == IPNATHLP_LOGGING_ERROR) ? TRUE : FALSE;
        } else if (NatGlobalInfo->LoggingLevel < Level) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            return FALSE;
        }
        LeaveCriticalSection(&NatGlobalInfoLock);
        return TRUE;
    }
    return TRUE;
}

VOID
NhWarningLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    if (!NhpIsAllowedLog(MessageId, IPNATHLP_LOGGING_WARN)) { return; }
    va_start(arglist, Format);
    RouterLogEventValistExA(
        NhEventLogHandle,
        EVENTLOG_WARNING_TYPE,
        ErrorCode,
        MessageId,
        Format,
        arglist
        );
    va_end(arglist);
}

VOID
NhShutdownEventLogManagement(
    VOID
    )
{
    RouterLogDeregister(NhEventLogHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dhcp\rmdhcp.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdhcp.c

Abstract:

    This module contains routines for the DHCP allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

COMPONENT_REFERENCE DhcpComponentReference;

PCHAR DhcpDomainName = NULL;

PIP_AUTO_DHCP_GLOBAL_INFO DhcpGlobalInfo;

CRITICAL_SECTION DhcpGlobalInfoLock;

HANDLE DhcpNotificationEvent;

ULONG DhcpProtocolStopped = 0;

const MPR_ROUTING_CHARACTERISTICS DhcpRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_DHCP_ALLOCATOR,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    DhcpRmStartProtocol,
    DhcpRmStartComplete,
    DhcpRmStopProtocol,
    DhcpRmGetGlobalInfo,
    DhcpRmSetGlobalInfo,
    NULL,
    NULL,
    DhcpRmAddInterface,
    DhcpRmDeleteInterface,
    DhcpRmInterfaceStatus,
    DhcpRmGetInterfaceInfo,
    DhcpRmSetInterfaceInfo,
    DhcpRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    DhcpRmMibCreate,
    DhcpRmMibDelete,
    DhcpRmMibGet,
    DhcpRmMibSet,
    DhcpRmMibGetFirst,
    DhcpRmMibGetNext,
    NULL,
    NULL
};

IP_AUTO_DHCP_STATISTICS DhcpStatistics;
SUPPORT_FUNCTIONS DhcpSupportFunctions;

extern "C"
LPSTR WINAPI
DnsGetPrimaryDomainName_A(
    VOID
    );


VOID
DhcpCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DHCP module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DeleteCriticalSection(&DhcpGlobalInfoLock);
    DhcpShutdownInterfaceManagement();
    DeleteComponentReference(&DhcpComponentReference);

} // DhcpCleanupModule


VOID
DhcpCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DHCP protocol-component
    after a 'StopProtocol'. It runs when the last reference to the  
    DHCP component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("DhcpCleanupProtocol");

#if 1
    if (DhcpDomainName) {
        LocalFree(DhcpDomainName);
        DhcpDomainName = NULL;
    }
#else
    if (DhcpDomainName) {
        NH_FREE(DhcpDomainName);
        DhcpDomainName = NULL;
    }
#endif
    if (DhcpGlobalInfo) { NH_FREE(DhcpGlobalInfo); DhcpGlobalInfo = NULL; }
    InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 1);
    SetEvent(DhcpNotificationEvent);
    ResetComponentReference(&DhcpComponentReference);

} // DhcpCleanupProtocol


BOOLEAN
DhcpInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the DHCP module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &DhcpComponentReference, DhcpCleanupProtocol
            )) {
        return FALSE;
    } else if (DhcpInitializeInterfaceManagement()) {
        DeleteComponentReference(&DhcpComponentReference);
        return FALSE;
    } else {
        __try {
            InitializeCriticalSection(&DhcpGlobalInfoLock);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            DeleteComponentReference(&DhcpComponentReference);
            return FALSE;
        }
    }

    return TRUE;

} // DhcpInitializeModule


ULONG
APIENTRY
DhcpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("DhcpRmStartProtocol");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Create a copy of the global configuration
        //

        Size =
            sizeof(*DhcpGlobalInfo) +
            ((PIP_AUTO_DHCP_GLOBAL_INFO)GlobalInfo)->ExclusionCount *
            sizeof(ULONG);
    
        DhcpGlobalInfo =
            reinterpret_cast<PIP_AUTO_DHCP_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!DhcpGlobalInfo) {
            NhTrace(
                TRACE_FLAG_INIT,
                "DhcpRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(DhcpGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        DhcpNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&DhcpSupportFunctions, sizeof(DhcpSupportFunctions));
        }
        else {
            CopyMemory(
                &DhcpSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmStartProtocol


ULONG
APIENTRY
DhcpRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // DhcpRmStartComplete


ULONG
APIENTRY
DhcpRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("DhcpStopProtocol");

    //
    // Reference the module to make sure it's running
    //

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&DhcpComponentReference);

    return DEREFERENCE_DHCP() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // DhcpRmStopProtocol


ULONG
APIENTRY
DhcpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmAddInterface");

    if (Type != PERMANENT) { return NO_ERROR; }

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpCreateInterface(
            Index,
            Type,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmAddInterface


ULONG
APIENTRY
DhcpRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmDeleteInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpDeleteInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmDeleteInterface


ULONG
APIENTRY
DhcpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("DhcpRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&DhcpProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // DhcpRmGetEventMessage


ULONG
APIENTRY
DhcpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmGetInterfaceInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpQueryInterface(
            Index,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );

    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmGetInterfaceInfo


ULONG
APIENTRY
DhcpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmSetInterfaceInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        DhcpConfigureInterface(
            Index,
            (PIP_AUTO_DHCP_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmSetInterfaceInfo


ULONG
APIENTRY
DhcpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = DhcpRmBindInterface(Index, StatusInfo);
            } else {
                Error = DhcpRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = DhcpRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = DhcpRmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // DhcpRmInterfaceStatus


ULONG
DhcpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PCHAR DomainName;
    ULONG Error;
    NTSTATUS status;

    PROFILE("DhcpRmBindInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpBindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    //
    // Re-read the domain name in case it changed
    //

    EnterCriticalSection(&DhcpGlobalInfoLock);

#if 1
    DomainName = DnsGetPrimaryDomainName_A();
    if (DomainName) {
        if (DhcpDomainName && lstrcmpiA(DomainName, DhcpDomainName) == 0) {
            LocalFree(DomainName);
        } else {
            if (DhcpDomainName) { LocalFree(DhcpDomainName); }
            DhcpDomainName = DomainName;
        }
    }
#else
    status = NhQueryDomainName(&DomainName);

    if (NT_SUCCESS(status)) {
        if (DhcpDomainName && lstrcmpiA(DomainName, DhcpDomainName) == 0) {
            NH_FREE(DomainName);
        } else {
            NH_FREE(DhcpDomainName);
            if (DhcpDomainName) { NH_FREE(DhcpDomainName); }
            DhcpDomainName = DomainName;
        }
    }
#endif

    LeaveCriticalSection(&DhcpGlobalInfoLock);

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmBindInterface


ULONG
DhcpRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmUnbindInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpUnbindInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmUnbindInterface


ULONG
DhcpRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmEnableInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpEnableInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmEnableInterface


ULONG
DhcpRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DhcpRmDisableInterface");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DhcpDisableInterface(
            Index
            );

    DEREFERENCE_DHCP_AND_RETURN(Error);

} // DhcpRmDisableInterface


ULONG
APIENTRY
DhcpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("DhcpRmGetGlobalInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&DhcpGlobalInfoLock);
    Size =
        sizeof(*DhcpGlobalInfo) +
        DhcpGlobalInfo->ExclusionCount * sizeof(ULONG);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&DhcpGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_DHCP_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, DhcpGlobalInfo, Size);
    LeaveCriticalSection(&DhcpGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DHCP_AND_RETURN(NO_ERROR);
    
} // DhcpRmGetGlobalInfo


ULONG
APIENTRY
DhcpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PIP_AUTO_DHCP_GLOBAL_INFO NewInfo;
    ULONG NewScope;
    ULONG OldScope;
    ULONG Size;
    PROFILE("DhcpRmSetGlobalInfo");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DHCP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size =
        sizeof(*DhcpGlobalInfo) +
        ((PIP_AUTO_DHCP_GLOBAL_INFO)GlobalInfo)->ExclusionCount * sizeof(ULONG);
    NewInfo = reinterpret_cast<PIP_AUTO_DHCP_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "DhcpRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_AUTO_DHCP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_DHCP_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&DhcpGlobalInfoLock);
    OldScope = DhcpGlobalInfo->ScopeNetwork & DhcpGlobalInfo->ScopeMask;
    NH_FREE(DhcpGlobalInfo);
    DhcpGlobalInfo = NewInfo;
    NewScope = DhcpGlobalInfo->ScopeNetwork & DhcpGlobalInfo->ScopeMask;
    LeaveCriticalSection(&DhcpGlobalInfoLock);

    if (OldScope != NewScope) {
        DhcpReactivateEveryInterface();
    }

    DEREFERENCE_DHCP_AND_RETURN(NO_ERROR);
    
} // DhcpRmSetGlobalInfo


ULONG
APIENTRY
DhcpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
DhcpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The DHCP allocator only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_AUTO_DHCP_MIB_QUERY Oidp;

    PROFILE("DhcpRmMibGet");

    REFERENCE_DHCP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        Oidp = (PIP_AUTO_DHCP_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_AUTO_DHCP_STATISTICS_OID: {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(DhcpStatistics)) {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DhcpStatistics);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
                else {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DhcpStatistics);
                    Oidp = (PIP_AUTO_DHCP_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_AUTO_DHCP_STATISTICS_OID;
                    CopyMemory(
                        Oidp->Data,
                        &DhcpStatistics,
                        sizeof(DhcpStatistics)
                        );
                    Error = NO_ERROR;
                }
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_DHCP,
                    "DhcpRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_DHCP_AND_RETURN(Error);
}


ULONG
APIENTRY
DhcpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DhcpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\buffer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.c

Abstract:

    This module contains code for buffer-management.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

LIST_ENTRY NhpBufferQueue;
LONG NhpBufferQueueLength;
CRITICAL_SECTION NhpBufferQueueLock;

PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer.
    If no buffer is available on the buffer queue, a new one is obtained.

Arguments:

    none.

Return Value:

    PNH_BUFFER - the buffer allocated

--*/

{
    PNH_BUFFER Buffer;
    PLIST_ENTRY Link;
    EnterCriticalSection(&NhpBufferQueueLock);
    if (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedDecrement(&NhpBufferQueueLength);
        Buffer = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        Buffer->Type = NhFixedLengthBufferType;
        return Buffer;
    }
    LeaveCriticalSection(&NhpBufferQueueLock);
    Buffer = NH_ALLOCATE_BUFFER();
    if (Buffer) {
        Buffer->Type = NhFixedLengthBufferType;
    }
    return Buffer;
} // NhAcquireFixedLengthBuffer


PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    )

/*++

Routine Description:

    This routine is invoked to acquire an I/O buffer of non-standard size.
    If the length requested is less than or equal to 'NH_BUFFER_SIZE',
    a buffer from the shared buffer-queue is returned.
    Otherwise, a buffer is especially allocated for the caller.

Arguments:

    Length - the length of the buffer required.

Return Value:

    PNH_BUFFER - the buffer allocated.

--*/

{
    PNH_BUFFER Buffer;
    if (Length <= NH_BUFFER_SIZE) {
        return NhAcquireFixedLengthBuffer();
    }
    Buffer = reinterpret_cast<PNH_BUFFER>(
                NH_ALLOCATE(FIELD_OFFSET(NH_BUFFER, Buffer[Length]))
                );
                
    if (Buffer) { Buffer->Type = NhVariableLengthBufferType; }
    return Buffer;
} // NhAcquireVariableLengthBuffer


PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine creates a duplicate of the given buffer,
    including both its data and its control information.

    N.B. Variable-length buffers cannot be duplicated by this routine.

Arguments:

    Bufferp - the buffer to be duplicated

Return Value:

    PNH_BUFFER - a pointer to the duplicate

--*/

{
    PNH_BUFFER Duplicatep;
    ASSERT(Bufferp->Type == NhFixedLengthBufferType);
    if (!(Duplicatep = NhAcquireBuffer())) { return NULL; }
    *Duplicatep = *Bufferp;
    return Duplicatep;
} // NhDuplicateBuffer


ULONG
NhInitializeBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine readies the buffer-management for operation.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    InitializeListHead(&NhpBufferQueue);
    NhpBufferQueueLength = 0;
    __try {
        InitializeCriticalSection(&NhpBufferQueueLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_BUFFER,
            "NhInitializeBufferManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // NhInitializeBufferManagement


VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to release a buffer to the buffer queue.
    It attempts to place the buffer on the queue for re-use, unless
    the queue is full in which case the buffer is immediately freed.

Arguments:

    Bufferp - the buffer to be released

Return Value:

    none.

--*/

{
    if (NhpBufferQueueLength > NH_MAX_BUFFER_QUEUE_LENGTH ||
        Bufferp->Type != NhFixedLengthBufferType) {
        NH_FREE_BUFFER(Bufferp);
    } else {
        EnterCriticalSection(&NhpBufferQueueLock);
        InsertHeadList(&NhpBufferQueue, &Bufferp->Link);
        LeaveCriticalSection(&NhpBufferQueueLock);
        InterlockedIncrement(&NhpBufferQueueLength);
    }
} // NhReleaseBuffer



VOID
NhShutdownBufferManagement(
    VOID
    )

/*++

Routine Description:

    This routine cleans up resources used by the buffer-management module.
    It assumes the list will not be accessed while the clean up is in progress.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNH_BUFFER Bufferp;

    while (!IsListEmpty(&NhpBufferQueue)) {
        Link = RemoveHeadList(&NhpBufferQueue);
        Bufferp = CONTAINING_RECORD(Link, NH_BUFFER, Link);
        NH_FREE_BUFFER(Bufferp);
    }

    DeleteCriticalSection(&NhpBufferQueueLock);
    NhpBufferQueueLength = 0;

} // NhShutdownBufferManagement
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "rmapi.h"
#include "rmdhcp.h"
#include "rmdns.h"
#include "rmh323.h"
#include "rmnat.h"
#include "rmftp.h"
#include "rmALG.h"

#include "dhcpif.h"
#include "dhcplog.h"

#include "dnsif.h"
#include "dnslog.h"


#include "ftpif.h"
#include "ftplog.h"

#include "Algif.h"
#include "Alglog.h"

#include "h323if.h"
#include "h323log.h"

#include "natlog.h"
#include "svcmain.h"
#include "timer.h"
#include "csaupdate.h"

#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\makefile.inc ===
$(O)\nathlpmc.mc: $(IPNAT_PROJECT_PATH)\dhcp\dhcplog.h $(IPNAT_PROJECT_PATH)\dns\dnslog.h $(IPNAT_PROJECT_PATH)\inc\natlog.h $(IPNAT_PROJECT_PATH)\inc\pastlog.h $(IPNAT_PROJECT_PATH)\h323\h323log.h
    mapmsg NET IP_AUTO_DHCP_LOG_BASE $(IPNAT_PROJECT_PATH)\dhcp\dhcplog.h > $(O)\nathlpmc.mc
    mapmsg NET IP_DNS_PROXY_LOG_BASE $(IPNAT_PROJECT_PATH)\dns\dnslog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_NAT_LOG_BASE $(IPNAT_PROJECT_PATH)\inc\natlog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_PAST_LOG_BASE $(IPNAT_PROJECT_PATH)\inc\pastlog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_FTP_LOG_BASE $(IPNAT_PROJECT_PATH)\ftp\ftplog.h >> $(O)\nathlpmc.mc
    mapmsg NET IP_H323_LOG_BASE $(IPNAT_PROJECT_PATH)\h323\h323log.h >> $(O)\nathlpmc.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\resource.h ===
#pragma once

// beacon reserves XML 1-100
// this is in the net\homenet\beacon\idl directory

#include "beaconrc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\timer.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    timer.c

Abstract:

    This module contains routines for manipulating the timer-queue
    which is shared by all the components in this module.

Author:

    Abolade Gbadegesin (aboladeg)   1-April-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HANDLE NhpTimerQueueHandle = NULL;
CRITICAL_SECTION NhpTimerQueueLock;

typedef struct _NH_TIMER_CONTEXT {
    WAITORTIMERCALLBACKFUNC TimerRoutine;
    PVOID Context;
    HANDLE Handle;
} NH_TIMER_CONTEXT, *PNH_TIMER_CONTEXT;


ULONG
NhInitializeTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the timer-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    __try {
        InitializeCriticalSection(&NhpTimerQueueLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_TIMER,
            "NhInitializeTimerManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }
    return Error;

} // NhInitializeTimerManagement


VOID NTAPI
NhpTimerCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )
{
    ((PNH_TIMER_CONTEXT)Context)->TimerRoutine(
        ((PNH_TIMER_CONTEXT)Context)->Context, TimedOut
        );
    EnterCriticalSection(&NhpTimerQueueLock);
    if (NhpTimerQueueHandle) {
        LeaveCriticalSection(&NhpTimerQueueLock);
        RtlDeleteTimer(
            NhpTimerQueueHandle, ((PNH_TIMER_CONTEXT)Context)->Handle, NULL
            );
    } else {
        LeaveCriticalSection(&NhpTimerQueueLock);
    }
    NH_FREE(Context);
} // NhpTimerCallbackRoutine


NTSTATUS
NhSetTimer(
    PCOMPONENT_REFERENCE Component OPTIONAL,
    OUT HANDLE* Handlep OPTIONAL,
    WAITORTIMERCALLBACKFUNC TimerRoutine,
    PVOID Context,
    ULONG DueTime
    )

/*++

Routine Description:

    This routine is called to install a timer.

Arguments:

    Component - optionally supplies a component to be referenced

    Handlep - optionally receives the handle of the timer created

    TimerRoutine - invoked upon completion of the countdown

    Context - supplied to 'TimerRoutine' upon completion of the countdown

    DueTime - countdown time in milliseconds

Return Value:

    NTSTATUS - status code.

--*/

{
    HANDLE Handle;
    NTSTATUS status;
    PNH_TIMER_CONTEXT TimerContext;

    EnterCriticalSection(&NhpTimerQueueLock);
    if (!NhpTimerQueueHandle) {
        status = RtlCreateTimerQueue(&NhpTimerQueueHandle);
        if (!NT_SUCCESS(status)) {
            NhpTimerQueueHandle = NULL;
            LeaveCriticalSection(&NhpTimerQueueLock);
            NhTrace(
                TRACE_FLAG_TIMER,
                "NhSetTimer: RtlCreateTimerQueue=%x", status
                );
            return status;
        }
    }
    LeaveCriticalSection(&NhpTimerQueueLock);

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, STATUS_UNSUCCESSFUL);
    }
    TimerContext =
        reinterpret_cast<PNH_TIMER_CONTEXT>(NH_ALLOCATE(sizeof(*TimerContext)));
    if (!TimerContext) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        return STATUS_NO_MEMORY;
    }

    TimerContext->TimerRoutine = TimerRoutine;
    TimerContext->Context = Context;

    status =
        RtlCreateTimer(
            NhpTimerQueueHandle,
            &TimerContext->Handle,
            NhpTimerCallbackRoutine,
            TimerContext,
            DueTime,
            0,
            0
            );

    if (!NT_SUCCESS(status)) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    } else if (Handlep) {
        *Handlep = TimerContext->Handle;
    }
    return status;

} // NhSetTimer


VOID
NhShutdownTimerManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to clean up the timer-management module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhpTimerQueueLock);
    if (NhpTimerQueueHandle) { RtlDeleteTimerQueue(NhpTimerQueueHandle); }
    NhpTimerQueueHandle = NULL;
    LeaveCriticalSection(&NhpTimerQueueLock);
    DeleteCriticalSection(&NhpTimerQueueLock);

} // NhShutdownTimerManagement


NTSTATUS
NhUpdateTimer(
    HANDLE Handle,
    ULONG DueTime
    )

/*++

Routine Description:

    This routine modifies the countdown for a timer.

Arguments:

    Handle - the handle of the timer to be modified

    DueTime - the new countdown in milliseconds

Return Value:

    NTSTATUS - status code.

--*/

{
    EnterCriticalSection(&NhpTimerQueueLock);
    if (!NhpTimerQueueHandle) {
        LeaveCriticalSection(&NhpTimerQueueLock);
        return STATUS_INVALID_PARAMETER;
    }
    LeaveCriticalSection(&NhpTimerQueueLock);

    return
        RtlUpdateTimer(
            NhpTimerQueueHandle,
            Handle,
            DueTime,
            0
            );

} // NhUpdateTimer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\socket.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.c

Abstract:

    This module contains code for socket-management.
    The routines provided generally follow the same asynchronous model
    using a completion routine that is invoked in the context of
    a callback thread.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

    Jonathan Burstein (jonburs)     12-April-2001

    Added support for raw datagram sockets.

--*/

#include "precomp.h"
#pragma hdrstop
#include <ws2tcpip.h>
#include <mstcpip.h>
#include <mswsock.h>

#if DBG
ULONG NhpReadCount = 0;
#endif
ULONG UnusedBytesTransferred;

typedef struct _NH_CLOSE_BUFFER {
    HANDLE Event OPTIONAL;
    HANDLE WaitHandle OPTIONAL;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine;
} NH_CLOSE_BUFFER, *PNH_CLOSE_BUFFER;

typedef struct _NH_CONNECT_BUFFER {
    HANDLE Event;
    HANDLE WaitHandle;
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL;
    BOOLEAN CloseNotificationReceived;
} NH_CONNECT_BUFFER, *PNH_CONNECT_BUFFER;

//
// FORWARD DECLARATIONS
//

VOID NTAPI
NhpCloseNotificationCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID NTAPI
NhpConnectOrCloseCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

VOID WINAPI
NhpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    );

VOID APIENTRY
NhpIoWorkerRoutine(
    PVOID Context
    );


ULONG
NhAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to accept an incoming connection-request
    on a listening stream socket using 'AcceptEx'. The I/O system invokes
    the provided 'CompletionRoutine' upon completion of the read.

    It is the completion-routine's responsibility to use 'setsockopt' to
    set the SO_UPDATE_ACCEPT_CONTEXT option on the accepted socket before
    the accepted socket can be used with Winsock2 routines.

    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    ListeningSocket - the endpoint that is listening for connection-requests

    AcceptedSocket - the endpoint to be assigned a connection-request,
        or INVALID_SOCKET to create a new endpoint

    Bufferp - the buffer to be used for asynchronous completion
        or NULL to acquire a new buffer

    AcceptCompletionRoutine - the routine to be invoked upon completion

    Context - the context to be associated with the accept-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the accept-completion routine
    will be invoked.
    Conversely, a failure code is a guarantee that the routine will not
    be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    SOCKET LocalSocket = INVALID_SOCKET;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(TRACE_FLAG_SOCKET, "error allocating buffer for accept");
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if (AcceptedSocket == INVALID_SOCKET) {
        Error = NhCreateStreamSocket(INADDR_NONE, 0, &LocalSocket);
        if (Error) {
            NhTrace(
                TRACE_FLAG_SOCKET, "error %d creating socket for accept", Error
                );
            if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        AcceptedSocket = LocalSocket;
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = AcceptedSocket;
    Bufferp->CompletionRoutine = AcceptCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;

    if (AcceptEx(
            ListeningSocket,
            AcceptedSocket,
            Bufferp->Buffer,
            0,
            sizeof(SOCKADDR_IN) + 16,
            sizeof(SOCKADDR_IN) + 16,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            )) {
        Error = NO_ERROR;
    } else {
        if ((Error = WSAGetLastError()) == ERROR_IO_PENDING) {
            Error = NO_ERROR;
        } else if (Error) {
            if (LocalSocket != INVALID_SOCKET) {
                NhDeleteStreamSocket(LocalSocket);
            }
            if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            NhTrace(
                TRACE_FLAG_SOCKET, "error %d returned by 'AcceptEx'", Error
                );
        }
    }

    return Error;

} // NhAcceptStreamSocket


ULONG
NhConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to establish a connection using a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

    Since Windows Sockets does not deliver connect-notifications to
    I/O completion ports, we need to make some special arrangements in order
    to notify the caller's completion routine the way we do for send-requests
    and receive-requests. Specifically, we create an event-handle and
    request connect-notification on it by calling 'WSAEventSelect'.
    We then register a wait on the event-handle, specifying a private
    completion routine. (See 'NhpConnectOrCloseCallbackRoutine'.)
    When this completion routine runs, it extracts the status code of the
    connection-attempt using 'WSAEnumNetworkEvents'. It then passes the status
    along with the usual parameters to the caller's completion routine.

    The caller may optionally receive notification when the remote endpoint
    closes the socket after a successful connection. We use the same
    'WSAEventSelect' mechanism to detect that condition and invoke the
    caller's notification routine.

    N.B. The buffer supplied to this routine may not be released by either
    the connect-completion routine or the close-notification routine.
    (See 'NhpConnectOrCloseCallbackRoutine' for more information.)

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket with which to establish a connection

    Address - the IP address of the remote endpoint

    Port - the port number of the remote endpoint

    Bufferp - optionally supplies the buffer to be used to hold context
        during the connection-attempt

    ConnectCompletionRoutine - a routine to be invoked upon completion 
        of the connect-attempt

    CloseNotificationRoutine - optionally specifies a routine to be invoked
        upon notification of the resulting socket's closure by the remote
        endpoint

    Context - passed to the 'ConnectCompletionRoutine' and
        'CloseNotificationRoutine'

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code

    A success code is a guarantee that both the connect-completion routine
    and the close-notification routine, if any, will be invoked.
    Conversely, a failure code is a guarantee that the neither routine will
    be invoked.

--*/

{
    PNH_CONNECT_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhConnectStreamSocket: error allocating buffer for connect"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = ConnectingSocket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = ConnectCompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->ConnectAddress.sin_family = AF_INET;
    Bufferp->ConnectAddress.sin_addr.s_addr = Address;
    Bufferp->ConnectAddress.sin_port = Port;

    Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationReceived = FALSE;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            NhpConnectOrCloseCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        ULONG EventsSelected = FD_CONNECT;
        if (CloseNotificationRoutine) { EventsSelected |= FD_CLOSE; }
        Error =
            WSAEventSelect(
                ConnectingSocket, Contextp->Event, EventsSelected
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
        } else {
            Error =
                WSAConnect(
                    ConnectingSocket,
                    (PSOCKADDR)&Bufferp->ConnectAddress,
                    sizeof(Bufferp->ConnectAddress),
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );
        }
    }

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSAEWOULDBLOCK) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhConnectStreamSocket


ULONG
NhCreateDatagramSocket(
    ULONG Address,
    USHORT Port,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is called to initialize a datagram socket.

Arguments:

    Address - the IP address to which the socket should be bound (network-order)

    Port - the UDP port to which the socket should be bound (network-order)

    Socketp - receives the created socket

Return Value:

    ULONG - Win32/Winsock2 error code

--*/

{
    ULONG Error;
    ULONG Option;
    ULONG OutputBufferLength;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new socket
        //
    
        Socket =
            WSASocket(
                AF_INET, SOCK_DGRAM, IPPROTO_UDP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateDatagramSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)Socket, NhpIoCompletionRoutine, 0);

        //
        // Attempt to enable endpoint-reuse on the socket
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                SOL_SOCKET,
                SO_REUSEADDR,
                (PCHAR)&Option,
                sizeof(Option)
                );

        //
        // Attempt to enable broadcasting on the socket
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                SOL_SOCKET,
                SO_BROADCAST,
                (PCHAR)&Option,
                sizeof(Option)
                );

        //
        // Limit broadcasts to the outgoing network
        // (the default is to send broadcasts on all interfaces).
        //

        Option = 1;
        WSAIoctl(
            Socket,
            SIO_LIMIT_BROADCASTS,
            &Option,
            sizeof(Option),
            NULL,
            0,
            &OutputBufferLength,
            NULL,
            NULL
            );

        //
        // Bind the socket
        //

        SocketAddress.sin_family = AF_INET;
        SocketAddress.sin_port = Port;
        SocketAddress.sin_addr.s_addr = Address;

        Error = bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));

        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateDatagramSocket: error %d binding socket", Error
                );
            break;
        }

        //
        // Save the socket and return
        //

        *Socketp = Socket;

        return NO_ERROR;

    } while (FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
    
} // NhCreateDatagramSocket


ULONG
NhCreateRawDatagramSocket(
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is called to initialize a raw, header-include
    datagram socket.

Arguments:

    Socketp - receives the created socket

Return Value:

    ULONG - Win32/Winsock2 error code

--*/

{
    ULONG Error;
    ULONG Option;
    ULONG OutputBufferLength;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new socket
        //
    
        Socket =
            WSASocket(
                AF_INET, SOCK_RAW, IPPROTO_UDP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateRawDatagramSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)Socket, NhpIoCompletionRoutine, 0);

        //
        // Turn on header-include mode
        //

        Option = 1;
        Error =
            setsockopt(
                Socket,
                IPPROTO_IP,
                IP_HDRINCL,
                (PCHAR)&Option,
                sizeof(Option)
                );
        if (SOCKET_ERROR == Error) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateRawDatagramSocket: error %d setting IP_HDRINCL", Error
                );
            break;
        }

        //
        // Limit broadcasts to the outgoing network
        // (the default is to send broadcasts on all interfaces).
        //

        Option = 1;
        WSAIoctl(
            Socket,
            SIO_LIMIT_BROADCASTS,
            &Option,
            sizeof(Option),
            NULL,
            0,
            &OutputBufferLength,
            NULL,
            NULL
            );

        //
        // Save the socket and return
        //

        *Socketp = Socket;

        return NO_ERROR;

    } while (FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;

} // NhCreateRawDatagramSocket



ULONG
NhCreateStreamSocket(
    ULONG Address OPTIONAL,
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    )

/*++

Routine Description:

    This routine is invoked to create and initialize a stream socket.
    The socket will also be bound to a local IP address and port,
    unless none is specified.

Arguments:

    Address - the local IP address to which the new socket should be bound,
        or INADDR_ANY to allow the system to leave the IP address unspecified,
        or INADDR_NONE if the socket should not be bound at all.

    Port - the port number to which the new socket should be bound,
        or 0 if to allow the system to select a port number.

    Socketp - receives initialized socket

Return Value:

    ULONG - Win32/Winsock2 status code.

--*/

{
    ULONG Error;
    ULONG Option;
    SOCKET Socket;
    SOCKADDR_IN SocketAddress;

    do {

        //
        // Create a new stream socket.
        //

        Socket =
            WSASocket(
                AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED
                );
        if (Socket == INVALID_SOCKET) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhCreateStreamSocket: error %d creating socket", Error
                );
            break;
        }

        //
        // Associate the socket with our I/O completion port
        //

        BindIoCompletionCallback((HANDLE)Socket, NhpIoCompletionRoutine, 0);

        //
        // Disable send and receive buffering in AFD,
        // since we will be operating asynchronously with a receive-buffer
        // (almost) always outstanding, and since in any case we want
        // TCP/IP's flow-control to limit the sender's sending rate properly.
        //

        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );
        Option = 0;
        setsockopt(
            Socket,
            SOL_SOCKET,
            SO_SNDBUF,
            (PCHAR)&Option,
            sizeof(Option)
            );

        //
        // If the caller has requested that the socket be bound by specifying
        // a local IP address, bind the socket now.
        //

        if (Address != INADDR_NONE) {
            SocketAddress.sin_family = AF_INET;
            SocketAddress.sin_port = Port;
            SocketAddress.sin_addr.s_addr = Address;
            Error =
                bind(Socket, (PSOCKADDR)&SocketAddress, sizeof(SocketAddress));
            if (Error == SOCKET_ERROR) {
                Error = WSAGetLastError();
                NhTrace(
                    TRACE_FLAG_SOCKET,
                    "NhCreateStreamSocket: error %d binding socket", Error
                    );
                break;
            }
        }

        //
        // Store the new socket in the caller's output-parameter, and return.
        //

        *Socketp = Socket;
        return NO_ERROR;

    } while(FALSE);

    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
    return Error;
} // NhCreateStreamSocket


VOID
NhDeleteSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine releases network resources for a socket.

Arguments:

    Socket - the socket to be deleted

Return Value:

    none.

--*/

{
    if (Socket != INVALID_SOCKET) { closesocket(Socket); }
} // NhDeleteSocket


ULONG
NhNotifyOnCloseStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to request notification of a socket's closure.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the notification routine runs.

Arguments:

    Component - the component to be referenced for the notification routine

    Socket - the endpoint for which close-notification is requested

    Bufferp - the buffer to be used to hold context-informatio for the request,
        or NULL to acquire a new buffer.

    CloseNotificationRoutine - the routine to be invoked upon closure of the
        socket

    Context - the context to be associated with the notification-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the notification routine will be invoked.
    Conversely, a failure code is a guarantee that the notification routine
    will not be invoked.

--*/

{
    PNH_CLOSE_BUFFER Contextp;
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = NULL;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;

    Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    Contextp->CloseNotificationRoutine = CloseNotificationRoutine;
    Contextp->WaitHandle = NULL;
    Contextp->Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!Contextp->Event ||
        !RegisterWaitForSingleObject(
            &Contextp->WaitHandle,
            Contextp->Event,
            NhpCloseNotificationCallbackRoutine,
            Bufferp,
            INFINITE,
            WT_EXECUTEINIOTHREAD
            )) {
        Error = GetLastError();
    } else {
        Error = WSAEventSelect(Socket, Contextp->Event, FD_CLOSE);
        if (Error == SOCKET_ERROR) { Error = WSAGetLastError(); }
    }

    if (Error) {
        if (Contextp->WaitHandle) { UnregisterWait(Contextp->WaitHandle); }
        if (Contextp->Event) { CloseHandle(Contextp->Event); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhNotifyOnCloseStreamSocket


VOID NTAPI
NhpCloseNotificationCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked upon closure of an accepted connection by the
    remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when connection-acceptance is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CLOSE_BUFFER Contextp = (PNH_CLOSE_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CLOSE', we unregister the wait since there's
    // nothing left to wait for.
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;
    Error =
        WSAEnumNetworkEvents(
            Bufferp->Socket, Contextp->Event, &NetworkEvents
            );
    if (Error || !(NetworkEvents.lNetworkEvents & FD_CLOSE)) {

        //
        // We couldn't determine which events occurred on the socket,
        // so call the notification routine with an error, and fall through
        // to the cleanup code below.
        //

        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(
                ERROR_OPERATION_ABORTED, 0, Bufferp
                );
        }

    } else {

        //
        // A close occurred on the socket, so retrieve the error code,
        // invoke the close-notification routine if any, and fall through
        // to the cleanup code below.
        //

        Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];
        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
        }
    }

    UnregisterWait(Contextp->WaitHandle);
    CloseHandle(Contextp->Event);
    NhReleaseBuffer(Bufferp);

} // NhpCloseNotificationCallbackRoutine


VOID NTAPI
NhpConnectOrCloseCallbackRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked by upon completion of a connect-operation
    or upon closure of the connection by the remote endpoint.
    It runs in the context of a thread executing a callback-routine associated
    with a wait-handle. The wait-handle is registered for the event-handle
    that is passed to 'WSAEventSelect' when a connection-attempt is initiated.

Arguments:

    Context - context-field associated with the completed wait

    WaitCompleted - indicates whether the wait completed or was timed-out

Return Value:

    none.

Environment:

    Runs in the context of a system wait thread.

--*/

{
    PNH_BUFFER Bufferp = (PNH_BUFFER)Context;
    PNH_CONNECT_BUFFER Contextp = (PNH_CONNECT_BUFFER)Bufferp->Buffer;
    ULONG Error;
    WSANETWORKEVENTS NetworkEvents;

    //
    // Retrieve the network events for which we're being invoked
    // When invoked for 'FD_CONNECT', we unregister the wait if an error
    // occurred. When invoked for 'FD_CLOSE', we unregister the wait
    // since there's nothing left to wait for.
    //
    // In essence, our goal is to guarantee that whatever the success
    // or failure or sequence of events on the socket, the connect-completion
    // and close-notification routines will both be called for the socket,
    // in that order.
    //
    // N.B. Neither routine is allowed to release the connect-buffer,
    // since we may need to preserve it on behalf of the close-notification
    // routine, if any.
    //
    // N.B. We may be invoked with both the 'FD_CONNECT' and 'FD_CLOSE' bits
    // set, for instance when the socket is closed. In that case we call
    // both routines here.
    //

    Bufferp->BytesTransferred = 0;
    NetworkEvents.lNetworkEvents = 0;
    Error =
        WSAEnumNetworkEvents(
            Bufferp->Socket, Contextp->Event, &NetworkEvents
            );
    if (Error) {

        //
        // We couldn't determine which events occurred on the socket,
        // so call the routines with errors, and fall through
        // to the cleanup code below.
        //

        if (Bufferp->CompletionRoutine) {
            Bufferp->CompletionRoutine(ERROR_OPERATION_ABORTED, 0, Bufferp);
            Bufferp->CompletionRoutine = NULL;
        }
        if (Contextp->CloseNotificationRoutine) {
            Contextp->CloseNotificationRoutine(
                ERROR_OPERATION_ABORTED, 0, Bufferp
                );
        }
        Contextp->CloseNotificationReceived = TRUE;

    } else {
        if (NetworkEvents.lNetworkEvents & FD_CONNECT) {
    
            //
            // The connect completed, so retrieve the error code and invoke
            // the connect-completion routine. If the connect failed,
            // we may never receive close-notification (unless the bit
            // is already set) so we need to simulate close-notification
            // here so that the cleanup code below executes.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CONNECT_BIT];
            if (Bufferp->CompletionRoutine) {
                Bufferp->CompletionRoutine(Error, 0, Bufferp);
                Bufferp->CompletionRoutine = NULL;
            }
            if (Error && !(NetworkEvents.lNetworkEvents & FD_CLOSE)) {
                if (Contextp->CloseNotificationRoutine) {
                    Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
                }
                Contextp->CloseNotificationReceived = TRUE;
            }
        }
        if (NetworkEvents.lNetworkEvents & FD_CLOSE) {
    
            //
            // A close occurred on the socket, so retrieve the error code,
            // invoke the close-notification routine if any, and fall through
            // to the cleanup code below.
            //
    
            Error = NetworkEvents.iErrorCode[FD_CLOSE_BIT];
            if (Contextp->CloseNotificationRoutine) {
                Contextp->CloseNotificationRoutine(Error, 0, Bufferp);
            }
            Contextp->CloseNotificationReceived = TRUE;
        }
    }

    //
    // If both the connect-completion and close-notification routines have run,
    // we are done with this wait-handle and buffer.
    //

    if (!Bufferp->CompletionRoutine && Contextp->CloseNotificationReceived) {
        UnregisterWait(Contextp->WaitHandle);
        CloseHandle(Contextp->Event);
        NhReleaseBuffer(Bufferp);
    }
} // NhpConnectOrCloseCallbackRoutine


VOID
NhpIoCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    LPOVERLAPPED Overlapped
    )

/*++

Routine Description:

    This routine is invoked by the I/O system upon completion of an operation.

Arguments:

    ErrorCode - system-supplied error code

    BytesTransferred - system-supplied byte-count

    Overlapped - caller-supplied context area

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker thread.

--*/

{
    PNH_BUFFER Bufferp = CONTAINING_RECORD(Overlapped, NH_BUFFER, Overlapped);
    NTSTATUS status;
    Bufferp->ErrorCode = ErrorCode;
    Bufferp->BytesTransferred = BytesTransferred;
    Bufferp->CompletionRoutine(
        Bufferp->ErrorCode,
        Bufferp->BytesTransferred,
        Bufferp
        );
} // NhpIoCompletionRoutine


VOID APIENTRY
NhpIoWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to continue processing of completed I/O
    in the context of an alertably waiting thread which does not exit idly.

Arguments:

    Context - holds the buffer associated with the completed I/O operation.

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL alertable worker thread.

--*/

{
    ((PNH_BUFFER)Context)->CompletionRoutine(
        ((PNH_BUFFER)Context)->ErrorCode,
        ((PNH_BUFFER)Context)->BytesTransferred,
        ((PNH_BUFFER)Context)
        );

} // NhpIoWorkerRoutine


VOID
NhQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    )
{
    PSOCKADDR_IN LocalSockAddr = NULL;
    ULONG LocalLength = sizeof(LocalSockAddr);
    PSOCKADDR_IN RemoteSockAddr = NULL;
    ULONG RemoteLength = sizeof(RemoteSockAddr);
    GetAcceptExSockaddrs(
        AcceptBuffer,
        0,
        sizeof(SOCKADDR_IN) + 16,
        sizeof(SOCKADDR_IN) + 16,
        (PSOCKADDR*)&LocalSockAddr,
        reinterpret_cast<LPINT>(&LocalLength),
        (PSOCKADDR*)&RemoteSockAddr,
        (LPINT)&RemoteLength
        );

    if (LocalAddress && LocalSockAddr) {
        *LocalAddress = LocalSockAddr->sin_addr.s_addr; 
    }
    if (LocalPort && LocalSockAddr) { 
        *LocalPort = LocalSockAddr->sin_port; 
    }
    if (RemoteAddress && RemoteSockAddr) { 
        *RemoteAddress = RemoteSockAddr->sin_addr.s_addr; 
    }
    if (RemotePort && RemoteSockAddr) { 
        *RemotePort = RemoteSockAddr->sin_port; 
    }
} // NhQueryAcceptEndpoints


ULONG
NhQueryAddressSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to retrieve the IP address associated with
    a socket.

Arguments:

    Socket - the socket to be queried

Return Value:

    ULONG - the IP address retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_addr.s_addr;
} // NhQueryAddressSocket


ULONG
NhQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getsockname(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // NhQueryEndpointSocket


USHORT
NhQueryPortSocket(
    SOCKET Socket
    )

/*++

Routine Description:

    This routine retrieves the port number to which a socket is bound.

Arguments:

    Socket - the socket to be queried

Return Value:

    USHORT - the port number retrieved

--*/

{
    SOCKADDR_IN Address;
    LONG AddressLength;
    AddressLength = sizeof(Address);
    getsockname(Socket, (PSOCKADDR)&Address, (int*)&AddressLength);
    return Address.sin_port;
} // NhQueryPortSocket


ULONG
NhQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    )
{
    SOCKADDR_IN SockAddr;
    LONG Length;
    Length = sizeof(SockAddr);
    if (getpeername(Socket, (PSOCKADDR)&SockAddr, (int*)&Length) == SOCKET_ERROR) {
        return WSAGetLastError();
    }
    if (Address) { *Address = SockAddr.sin_addr.s_addr; }
    if (Port) { *Port = SockAddr.sin_port; }
    return NO_ERROR;
} // NhQueryRemoteEndpointSocket


ULONG
NhReadDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a datagram socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer. If no buffer is supplied,
        the resulting message is assumed to fit inside a fixed-length buffer

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Bufferp = LocalBufferp = NhAcquireBuffer();
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadDatagramSocket: error allocating buffer for receive"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->AddressLength = sizeof(Bufferp->ReadAddress);
    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = NH_BUFFER_SIZE;

    Error =
        WSARecvFrom(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            (PSOCKADDR)&Bufferp->ReadAddress,
            (LPINT)&Bufferp->AddressLength,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadDatagramSocket: error %d returned by 'WSARecvFrom'", Error
            );
    }

    return Error;

} // NhReadDatagramSocket


ULONG
NhReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to read a message from a stream socket.
    The I/O system invokes the provided 'CompletionRoutine' upon completion
    of the read.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the endpoint on which to read a message

    Bufferp - the buffer into which the message should be read,
        or NULL to acquire a new buffer

    Length - the maximum number of bytes to be read

    Offset - the offset into the buffer at which the read should begin,
        valid only if 'Bufferp' is provided.

    CompletionRoutine - the routine to be invoked upon completion of the read

    Context - the context to be associated with the read-request;
        this can be obtained from 'Bufferp->Context' upon completion.

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code.
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    PNH_BUFFER LocalBufferp = NULL;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    if (!Bufferp) {
        Offset = 0;
        Bufferp = LocalBufferp = NhAcquireVariableLengthBuffer(Length);
        if (!Bufferp) {
            NhTrace(
                TRACE_FLAG_SOCKET,
                "NhReadStreamSocket: error allocating buffer for receive"
                );
            if (Component) { DEREFERENCE_COMPONENT(Component); }
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->ReceiveFlags = 0;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (ReadFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadStreamSocket: error %d returned by 'ReadFile'", Error
            );
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSARecv(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            &Bufferp->ReceiveFlags,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        if (Component) { DEREFERENCE_COMPONENT(Component); }
        if (LocalBufferp) { NhReleaseBuffer(LocalBufferp); }
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhReadStreamSocket: error %d returned by 'WSARecv'", Error
            );
    }
#endif

    return Error;

} // NhReadStreamSocket


ULONG
NhWriteDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp,
    ULONG Length,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a datagram socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Address - the address of the message's destination

    Port - the port of the message's destination

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    LONG AddressLength;
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
    Bufferp->WriteAddress.sin_family = AF_INET;
    Bufferp->WriteAddress.sin_addr.s_addr = Address;
    Bufferp->WriteAddress.sin_port = Port;
    AddressLength = sizeof(Bufferp->WriteAddress);
    WsaBuf.buf = reinterpret_cast<char*>(Bufferp->Buffer);
    WsaBuf.len = Length;

    Error =
        WSASendTo(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            (PSOCKADDR)&Bufferp->WriteAddress,
            AddressLength,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteDatagramSocket: error %d returned by 'WSASendTo'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }

    return Error;

} // NhWriteDatagramSocket


ULONG
NhWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is invoked to send a message on a stream socket.
    A reference is made to the given component, if any, if the request is 
    submitted successfully. This guarantees the component will not be unloaded
    before the completion routine runs.

Arguments:

    Component - the component to be referenced for the completion routine

    Socket - the socket on which to send the message

    Bufferp - the buffer containing the message to be sent

    Length - the number of bytes to transfer

    Offset - the offset into the buffer at which the data to be sent begins

    CompletionRoutine - the routine to be invoked upon completion of the send

    Context - passed to the 'CompletionRoutine' upon completion of the send

    Context2 - secondary context

Return Value:

    ULONG - Win32/Winsock2 status code
    A success code is a guarantee that the completion routine will be invoked.
    Conversely, a failure code is a guarantee that the completion routine will
    not be invoked.

--*/

{
    ULONG Error;
    WSABUF WsaBuf;

    if (Component) {
        REFERENCE_COMPONENT_OR_RETURN(Component, ERROR_CAN_NOT_COMPLETE);
    }

    ZeroMemory(&Bufferp->Overlapped, sizeof(Bufferp->Overlapped));

    Bufferp->Socket = Socket;
    Bufferp->CompletionRoutine = CompletionRoutine;
    Bufferp->Context = Context;
    Bufferp->Context2 = Context2;
#if 1
    if (WriteFile(
            (HANDLE)Bufferp->Socket,
            Bufferp->Buffer + Offset,
            Length,
            &UnusedBytesTransferred,
            &Bufferp->Overlapped
            ) ||
        (Error = GetLastError()) == ERROR_IO_PENDING) {
        Error = NO_ERROR;
    } else {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WriteFile'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#else
    WsaBuf.buf = Bufferp->Buffer + Offset;
    WsaBuf.len = Length;

    Error =
        WSASend(
            Socket,
            &WsaBuf,
            1,
            &UnusedBytesTransferred,
            0,
            &Bufferp->Overlapped,
            NULL
            );

    if (Error == SOCKET_ERROR &&
        (Error = WSAGetLastError()) == WSA_IO_PENDING) {
        Error = NO_ERROR;
    } else if (Error) {
        NhTrace(
            TRACE_FLAG_SOCKET,
            "NhWriteStreamSocket: error %d returned by 'WSASend'", Error
            );
        if (Component) { DEREFERENCE_COMPONENT(Component); }
    }
#endif

    return Error;

} // NhWriteStreamSocket
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsfile.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dnsfile.c

Abstract:

    This module contains code for the Simple DNS Server (formerly the DNS Proxy)
    to operate on the Hosts.ics file. Abridged from the DS tree.

Author:

    Raghu Gatta (rgatta)   15-Nov-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// EXTERNAL DECLARATIONS
//

extern "C"
FILE *
SockOpenNetworkDataBase(
    IN  char *Database,
    OUT char *Pathname,
    IN  int   PathnameLen,
    IN  char *OpenFlags
    );


//
// Locking Order:
//      (1) DnsFileInfo.Lock
//      (2) DnsTableLock
// OR
//      (1) DnsGlobalInfoLock
//      (2) DnsTableLock



//
// Globals
//

IP_DNS_PROXY_FILE_INFO DnsFileInfo;


ULONG
DnsInitializeFileManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the file management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsInitializeFileManagement");

    ZeroMemory(&DnsFileInfo, sizeof(IP_DNS_PROXY_FILE_INFO));

    __try {
        InitializeCriticalSection(&DnsFileInfo.Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DnsInitializeFileManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // DnsInitializeFileManagement



VOID
DnsShutdownFileManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the file management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/

{
    PROFILE("DnsShutdownFileManagement");

    DnsEndHostsIcsFile();

    DeleteCriticalSection(&DnsFileInfo.Lock);

} // DnsShutdownFileManagement



BOOL
DnsEndHostsIcsFile(
    VOID
    )
/*++

Routine Description:

    Close hosts file.

Arguments:

    None.

Globals:

    DnsFileInfo.HostFile -- host file ptr, tested and cleared

Return Value:

    None.

--*/
{
    if (DnsFileInfo.HostFile)
    {
        fclose(DnsFileInfo.HostFile);
        DnsFileInfo.HostFile = NULL;
    }

    return TRUE;
} // DnsEndHostsIcsFile



BOOL
DnsSetHostsIcsFile(
    BOOL fOverwrite
    )
/*++

Routine Description:

    Open hosts.ics file. If we write, we overwrite, else we read

Arguments:

    None.

Globals:

    DnsFileInfo.HostFile -- host file ptr, tested and set

Return Value:

    None.

--*/
{
    LPVOID lpMsgBuf;
    UINT   len;
    WCHAR  hostDirectory[MAX_PATH*2];
    PCHAR  mode = fOverwrite ? "w+t" : "rt";
    

    DnsEndHostsIcsFile();

    //
    // reset the host file name to hosts.ics
    //
    ZeroMemory(DnsFileInfo.HostFileName, HOSTDB_SIZE);

    DnsFileInfo.HostFile = SockOpenNetworkDataBase(
                               HOSTSICSFILE,
                               DnsFileInfo.HostFileName,
                               HOSTDB_SIZE,
                               mode
                               );
                     
    if(DnsFileInfo.HostFile == NULL)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSetHostsIcsFile: Unable to open %s file",
            HOSTSICSFILE
            );
            
        return FALSE;
    }
    else
    {
        /*
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSetHostsIcsFile: Successfully opened %s file",
            DnsFileInfo.HostFileName
            );
        */
    }

    return TRUE;
} // DnsSetHostsIcsFile



BOOL
GetHostFromHostsIcsFile(
    BOOL fStartup
    )
/*++

Routine Description:

    Reads an entry from hosts.ics file.

Arguments:

    fStartup set to TRUE if called on startup of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is set
    DnsFileInfo.Ip4Address    -- IP4 address is set


Return Value:

    TRUE if we were able to successfully able to read a line.
    FALSE if on EOF or no hosts file found.

--*/
{
    char *p, *ep;
    register char *cp, **q;

    //
    // we assume the hosts.ics file has already been opened
    //

    if (DnsFileInfo.HostFile == NULL)
    {
        return FALSE;
    }

    DnsFileInfo.HostLineBuf[BUFSIZ] = NULL;
    DnsFileInfo.pHostName  = NULL;
    DnsFileInfo.Ip4Address = 0;
    ZeroMemory(&DnsFileInfo.HostTime, sizeof(SYSTEMTIME));

    //
    // loop until successfully read IP address
    // IP address starts on column 1 
    //

    while( 1 )
    {
        // quit on EOF

        if ((p = fgets(DnsFileInfo.HostLineBuf, BUFSIZ, DnsFileInfo.HostFile)) == NULL)
        {
            if (!feof(DnsFileInfo.HostFile))
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "GetHostFromHostsIcsFile: Error reading line"
                    );
            }
            return FALSE;
        }

        // comment line -- skip

        if (*p == '#')
        {
            p++;

            //
            // if in startup mode, we skip first comment sign;
            // if there are more comment signs -- skip
            //
            if ((fStartup && *p == '#') || !fStartup)
            {
                continue;
            }
        }

        // null address terminate at EOL

        cp = strpbrk(p, "\n");
        if (cp != NULL)
        {
            *cp = '\0';
        }

        // whole line is whitespace -- skip

        cp = strpbrk(p, " \t");
        if ( cp == NULL )
        {
            continue;
        }

        // NULL terminate address string

        *cp++ = '\0';

        //
        // read address
        //  - try IP4
        //  - ignore IP6 for now
        //  - otherwise skip
        //
    
        DnsFileInfo.Ip4Address = inet_addr(p);

        if (DnsFileInfo.Ip4Address != INADDR_NONE ||
            _strnicmp("255.255.255.255", p, 15) == 0)
        {
            break;
        }

        // invalid address, ignore line

        //
        // debug tracing
        //
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host file address %s",
            p
            );
            
        continue;
    }

    // find the end of the string which was read
    
    ep = cp;
    while( *ep ) ep++;

    //
    // find name
    //  - skip leading whitespace
    //  - set global name ptr
    //
    
    while( *cp == ' ' || *cp == '\t' ) cp++;
    DnsFileInfo.pHostName = cp;

    // stop at trailing whitespace, NULL terminate

    cp = strpbrk(cp, " \t");
    if ( cp != NULL )
    {
        *cp++ = '\0';
    }
    else
    {
        // we have a name - but no timestamp
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp",
            DnsFileInfo.pHostName
            );
        goto Failed;
    }

    // we dont have any support for aliases

    //
    // find the timestamp
    //  - skip leading whitespace
    //  - read the time values
    //
    while( *cp == ' ' || *cp == '\t' ) cp++;

    if ((cp >= ep) || (*cp != '#'))
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp",
            DnsFileInfo.pHostName
            );
        goto Failed;
    }
    
    cp++;

    while( *cp == ' ' || *cp == '\t' ) cp++;    // now at first system time value
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 1",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wYear         = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;
    
    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 2",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMonth        = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 3",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wDayOfWeek    = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 4",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wDay          = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 5",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wHour         = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 6",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMinute       = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 7",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wSecond       = (WORD) atoi(cp);
    cp = strpbrk(cp, " \t");
    if (cp == NULL) goto Failed;

    while( *cp == ' ' || *cp == '\t' ) cp++;
    if ((cp >= ep) || (*cp == NULL))
    {
        NhTrace(
        TRACE_FLAG_DNS,
        "GetHostFromHostsIcsFile: Error parsing host (%s) file timestamp @ 8",
        DnsFileInfo.pHostName
        );
        goto Failed;
    }
    DnsFileInfo.HostTime.wMilliseconds = (WORD) atoi(cp);

    //
    // successful entry read
    //
    /*
    NhTrace(
        TRACE_FLAG_DNS,
        "%s (%s) has timestamp: %04u-%02u-%02u %02u:%02u:%02u",
        DnsFileInfo.pHostName,
        inet_ntoa(*(PIN_ADDR)&DnsFileInfo.Ip4Address),
        DnsFileInfo.HostTime.wYear,
        DnsFileInfo.HostTime.wMonth,
        DnsFileInfo.HostTime.wDay,
        DnsFileInfo.HostTime.wHour,
        DnsFileInfo.HostTime.wMinute,
        DnsFileInfo.HostTime.wSecond
        );
    */
    return TRUE;

Failed:

    // reset entries
    
    DnsFileInfo.HostLineBuf[0] = NULL;
    DnsFileInfo.pHostName  = NULL;
    DnsFileInfo.Ip4Address = 0;
    ZeroMemory(&DnsFileInfo.HostTime, sizeof(SYSTEMTIME));

    return TRUE;
    
} // GetHostFromHostsIcsFile



VOID
LoadHostsIcsFile(
    BOOL fStartup
    )
/*++

Routine Description:

    Read hosts file into our local cache.

Arguments:

    fStartup set to TRUE if called on startup of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set then cleared
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is read
    DnsFileInfo.Ip4Address    -- IP4 address is read

Return Value:

    None.

--*/
{
    register PCHAR * cp;
    FILETIME ftExpires;
    PWCHAR pszName;
    LPVOID lpMsgBuf;

    NhTrace(
        TRACE_FLAG_DNS,
        "LoadHostsIcsFile: Entering..."
        );

    ACQUIRE_LOCK(&DnsFileInfo);

    //
    //  read entries from host file until exhausted
    //

    DnsSetHostsIcsFile(FALSE);  // read only

    while (GetHostFromHostsIcsFile(fStartup))
    {
        if (DnsFileInfo.pHostName)
        {
            if (!SystemTimeToFileTime(&DnsFileInfo.HostTime, &ftExpires))
            {
                DWORD dwLastError = GetLastError();
                
                NhTrace(
                    TRACE_FLAG_DNS,
                    "LoadHostsIcsFile: SystemTimeToFileTime() failed"
                    );

                lpMsgBuf = NULL;
                
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    dwLastError,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                    );
                    
                NhTrace(
                    TRACE_FLAG_DNS,
                    "LoadHostsIcsFile: with message (0x%08x) %S",
                    dwLastError,
                    lpMsgBuf
                    );
                
                if (lpMsgBuf) LocalFree(lpMsgBuf);

                // skip entry
                continue;
            }

            pszName = (PWCHAR) NH_ALLOCATE((strlen(DnsFileInfo.pHostName) + 1) * sizeof(WCHAR));

            mbstowcs(pszName, DnsFileInfo.pHostName, (strlen(DnsFileInfo.pHostName) + 1));

            NhTrace(
                TRACE_FLAG_DNS,
                "%S (%s) has timestamp: %04u-%02u-%02u %02u:%02u:%02u",
                pszName,
                inet_ntoa(*(PIN_ADDR)&DnsFileInfo.Ip4Address),
                DnsFileInfo.HostTime.wYear,
                DnsFileInfo.HostTime.wMonth,
                DnsFileInfo.HostTime.wDay,
                DnsFileInfo.HostTime.wHour,
                DnsFileInfo.HostTime.wMinute,
                DnsFileInfo.HostTime.wSecond
                );

            DnsAddAddressForName(
                pszName,
                DnsFileInfo.Ip4Address,
                ftExpires
                );

            NH_FREE(pszName);
        }

    }

    DnsEndHostsIcsFile();

    RELEASE_LOCK(&DnsFileInfo);

    //
    // now that we have everything in our table format,
    // write back a clean version to disk
    //
    SaveHostsIcsFile(FALSE);

    NhTrace(
        TRACE_FLAG_DNS,
        "LoadHostsIcsFile: ...Leaving."
        );

} // LoadHostsIcsFile



VOID
SaveHostsIcsFile(
    BOOL fShutdown
    )
/*++

Routine Description:

    Write hosts file from our local cache.

Arguments:

    fShutdown set to TRUE if called on shutdown of protocol

Globals:

    DnsFileInfo.HostFile      -- host file ptr, tested and set then cleared
    DnsFileInfo.HostTime      -- host timestamp
    DnsFileInfo.pHostName     -- name ptr is read
    DnsFileInfo.Ip4Address    -- IP4 address is read

Return Value:

    None.

--*/
{
    //DWORD       dwSize = 0;
    //PWCHAR      pszSuffix = NULL;
    UINT        i;
    SYSTEMTIME  stTime;
    LPVOID      lpMsgBuf;
    
    NhTrace(
        TRACE_FLAG_DNS,
        "SaveHostsIcsFile: Entering..."
        );

    //
    // adding ourself as a special case
    //
    DnsAddSelf();

    //
    // get a copy of current ICS Domain suffix (used later on)
    // we dont play with it directly from the global copy
    // due to locking problems
    //
    /*
    EnterCriticalSection(&DnsGlobalInfoLock);

    if (DnsICSDomainSuffix)
    {
        dwSize = wcslen(DnsICSDomainSuffix) + 1;

        pszSuffix = reinterpret_cast<PWCHAR>(
                        NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                        );
        if (!pszSuffix)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "SaveHostsIcsFile: allocation failed for "
                "DnsICSDomainSuffix copy"
                );
        }
        else
        {
            wcscpy(pszSuffix, DnsICSDomainSuffix);
        }
    }
    
    LeaveCriticalSection(&DnsGlobalInfoLock);
    */

    ACQUIRE_LOCK(&DnsFileInfo);

    //
    // write entries into host file
    //

    DnsSetHostsIcsFile(TRUE);  // overwrite existing file if any

    if (DnsFileInfo.HostFile != NULL)
    {
        //
        // write default header string
        //
        if (fShutdown)
        {
            // add extra # at front
            fputc('#', DnsFileInfo.HostFile);
            
        }
        fputs(HOSTSICSFILE_HEADER, DnsFileInfo.HostFile);

        PDNS_ENTRY pDnsEntry;

        EnterCriticalSection(&DnsTableLock);

        pDnsEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, TRUE);

        while (pDnsEntry != NULL)
        {

            for (i = 0; i < pDnsEntry->cAddresses; i++)
            {
                //
                // dont add entries with invalid suffixes
                // (this could happen for example because the suffix
                //  was changed in the registry)
                //
                //if (!IsSuffixValid(pDnsEntry->pszName, pszSuffix))
                //{
                //    continue;
                //}
                
                //
                // dont add expired entries to the hosts.ics file
                //
                if (IsFileTimeExpired(&pDnsEntry->aAddressInfo[i].ftExpires))
                {
                    continue;
                }

                if (!FileTimeToSystemTime(
                         &pDnsEntry->aAddressInfo[i].ftExpires,
                         &stTime))
                {
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "SaveHostsIcsFile: FileTimeToSystemTime() failed"
                        );

                    lpMsgBuf = NULL;
                    
                    FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        GetLastError(),
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                        );
                        
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "SaveHostsIcsFile: with message %S",
                        lpMsgBuf
                        );
                    
                    if (lpMsgBuf) LocalFree(lpMsgBuf);

                    // skip entry
                    continue;
                }

                if (fShutdown)
                {
                    // add extra # at front
                    fputc('#', DnsFileInfo.HostFile);
                    
                }
                
                fprintf(
                    DnsFileInfo.HostFile,
                    "%s %S # %u %u %u %u %u %u %u %u\n",
                    inet_ntoa(*(PIN_ADDR)&pDnsEntry->aAddressInfo[i].ulAddress),
                    pDnsEntry->pszName,
                    stTime.wYear,
                    stTime.wMonth,
                    stTime.wDayOfWeek,
                    stTime.wDay,
                    stTime.wHour,
                    stTime.wMinute,
                    stTime.wSecond,
                    stTime.wMilliseconds
                    );

                NhTrace(
                    TRACE_FLAG_DNS,
                    "adding entry: %s %S # %u %u %u %u %u %u %u %u\n",
                    inet_ntoa(*(PIN_ADDR)&pDnsEntry->aAddressInfo[i].ulAddress),
                    pDnsEntry->pszName,
                    stTime.wYear,
                    stTime.wMonth,
                    stTime.wDayOfWeek,
                    stTime.wDay,
                    stTime.wHour,
                    stTime.wMinute,
                    stTime.wSecond,
                    stTime.wMilliseconds
                    );
            }

            pDnsEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, FALSE);

        }

        LeaveCriticalSection(&DnsTableLock);
    }

    DnsEndHostsIcsFile();

    RELEASE_LOCK(&DnsFileInfo);

    /*
    if (pszSuffix)
    {
        NH_FREE(pszSuffix);
        pszSuffix = NULL;
    }
    */

    NhTrace(
        TRACE_FLAG_DNS,
        "SaveHostsIcsFile: ...Leaving."
        );

} // SaveHostsIcsFile



BOOL
IsFileTimeExpired(
    FILETIME *ftTime
    )
{
    ULARGE_INTEGER  uliTime, uliNow;
    FILETIME        ftNow;

    GetSystemTimeAsFileTime(&ftNow);
    memcpy(&uliNow, &ftNow, sizeof(ULARGE_INTEGER));
    memcpy(&uliTime, ftTime, sizeof(ULARGE_INTEGER));

    return (uliTime.QuadPart < uliNow.QuadPart);
} // IsFileTimeExpired
    


BOOL
IsSuffixValid(
    WCHAR *pszName,
    WCHAR *pszSuffix
    )

/*++

Routine Description:

    This routine is invoked to compare suffix on the end of the name
    with what the DNS component thinks of as the current suffix.

Arguments:

    none.

Return Value:

    TRUE or FALSE.

Environment:

    Invoked in an arbitrary context.

--*/

{
    BOOL ret;
    PWCHAR start = pszName;
    size_t lenName   = 0,
           lenSuffix = 0;

    if (!start)
    {
        return FALSE;
    }

    lenName   = wcslen(pszName);
    lenSuffix = wcslen(pszSuffix);

    if (!lenName || !lenSuffix)
    {
        return FALSE;
    }

    if (lenName < lenSuffix)
    {
        return FALSE;
    }

    lenName -= lenSuffix;

    while (lenName--) start++;

    ret = wcscmp(start, pszSuffix);

    return (!ret);
} // IsSuffixValid
    


//
//  End dnsfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\range.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    range.c

Abstract:

    This module implements an efficient mapping from an arbitrary range of
    IP addresses to a minimal set of IP address-mask pairs covering the range.

    The key to the approach is to regard the set of all possible IP addresses
    as a full 32-bit deep binary tree. Then a single IP address is a path
    through that tree, and a range of addresses is the area between two paths
    through the tree. We then describe such a path-delineated area by pruning
    full subtrees of the area recursively from left to right.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
DecomposeRange(
    ULONG StartAddress,
    ULONG EndAddress,
    ULONG Mask,
    PDECOMPOSE_RANGE_CALLBACK Callback,
    PVOID CallbackContext
    )

/*++

Routine Description:

    This routine decomposes the range StartAddress-EndAddress into
    a minimal set of address-mask pairs, passing the generated
    pairs to the given callback routine.

Arguments:

    StartAddress - the start of the range

    EndAddress - the end of the range

    Mask - the most general mask covering the range

    Callback - routine invoked for each generated address-mask pair

    CallbackContext - context passed to 'Callback'.

Return Value:

    none.

--*/

{
    ULONG temp;

    //
    // Step 1:
    // Check for the first base case: the root of a full tree.
    //

    if ((StartAddress & ~Mask) == 0 && (EndAddress & ~Mask) == ~Mask) {

        if (Callback) { Callback(StartAddress, Mask, CallbackContext); }

        return;
    }

    //
    // Step 2.
    // Extend the mask by one bit to cover the first different position
    // between the start and end address, essentially moving down in the tree
    // to the node where the paths branch.
    //
    //      . <- Most general mask
    //      |
    //      * <- branching point
    //     / \
    //

    Mask = ntohl(Mask);
    Mask >>= 1; Mask |= (1<<31);
    Mask = htonl(Mask);

    //
    // Step 3.
    // Split the range, with the new right edge being a fully-rightward path
    // (no left turns) starting below and to the left of the branching point.
    //
    //      . <- branching point
    //     / \
    //    *
    //     \ <- new right edge
    //

    temp = StartAddress | ~Mask;

    //
    // Step 4.
    // Check for the second base case:
    // the left edge is a fully-leftward path (all-zeroes).
    //

    if ((StartAddress & ~Mask) == 0) {

        if (Callback) { Callback(StartAddress, Mask, CallbackContext); }
    }
    else {

        //
        // Not a base case, so take the left branch.
        //
    
        DecomposeRange(
            StartAddress,
            temp,
            Mask,
            Callback,
            CallbackContext
            );
    }

    //
    // we may be done, if the right edge is also fully rightward
    //

    if ((StartAddress | ~Mask) == EndAddress) { return; }

    //
    // Step 5.
    // Decompose the remaining portion of the range,
    // with the new left edge being the fully-leftward path which starts
    // below and to the right of the original branching point.
    //
    //      . <- branching point
    //     / \
    //        *
    //       / <- new left edge
    //

    temp = EndAddress & Mask;

    //
    // Step 6.
    // Check for the third base case:
    // the right edge is fully-rightward (all-ones).
    //

    if (EndAddress == (temp | ~Mask)) {

        if (Callback) { Callback(EndAddress, Mask, CallbackContext); }
    }
    else {

        //
        // Not a base case; take the right branch.
        //

        DecomposeRange(
            temp,
            EndAddress,
            MostGeneralMask(temp, EndAddress),
            Callback,
            CallbackContext
            );
    }
}


ULONG
MostGeneralMask(
    ULONG StartAddress,
    ULONG EndAddress
    )

/*++

Routine Description:

    This routine generates the most general mask covering the range
    'StartAddress' - 'EndAddress'.

Arguments:

    StartAddress - beginning of range, in network order

    EndAddress - end of range, in network order

Return Value:

    ULONG - the most general mask

--*/

{
    ULONG CommonBits, Mask;
    StartAddress = ntohl(StartAddress);
    EndAddress = ntohl(EndAddress);

    //
    // find the bits common to the start address and end address
    //

    CommonBits = ~(StartAddress ^ EndAddress);

    //
    // CommonBits now has a 1 in each position where StartAddress and
    // EndAddress are the same.
    // We want to reduce this to only include the longest contiguous
    // most significant bits
    // e.g. 11101110 becomes 11100000 and 11111101 becomes 11111100
    //

    for (Mask = 0xffffffff; Mask && ((CommonBits & Mask) != Mask); Mask<<=1) { }
    
    return htonl(Mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsfile.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dnsfile.h

Abstract:

    This module contains declarations for the DNS proxy's file
    management.

Author:

    Raghu Gatta (rgatta)   21-Nov-2000

Revision History:
    
--*/

#ifndef _NATHLP_DNSFILE_H_
#define _NATHLP_DNSFILE_H_


//
//  Sockets hosts.ics file stuff
//  NOTE: The hosts.ics file will reside in the same directory as the hosts file
//

#define HOSTS_FILE_DIRECTORY    L"\\drivers\\etc"
#define HOSTDB_SIZE             (MAX_PATH + 12)   // 12 == strlen("\\hosts.ics") + 1
#define HOSTSICSFILE            "hosts.ics"

#define HOSTSICSFILE_HEADER     \
"# Copyright (c) 1993-2001 Microsoft Corp.\n"                                   \
"#\n"                                                                           \
"# This file has been automatically generated for use by Microsoft Internet\n"  \
"# Connection Sharing. It contains the mappings of IP addresses to host names\n"\
"# for the home network. Please do not make changes to the HOSTS.ICS file.\n"   \
"# Any changes may result in a loss of connectivity between machines on the\n"  \
"# local network.\n"                                                            \
"#\n"                                                                           \
"\n"



typedef struct _IP_DNS_PROXY_FILE_INFO
{
    CRITICAL_SECTION  Lock;
    FILE             *HostFile;
    CHAR              HostFileName[HOSTDB_SIZE];
    CHAR              HostLineBuf[BUFSIZ + 1];

    // temp values in the context of current file processing
    SYSTEMTIME        HostTime;
    PCHAR             pHostName;
    ULONG             Ip4Address;

} IP_DNS_PROXY_FILE_INFO, *PIP_DNS_PROXY_FILE_INFO;


//
// FUNCTION DECLARATIONS
//

ULONG
DnsInitializeFileManagement(
    VOID
    );

VOID
DnsShutdownFileManagement(
    VOID
    );

BOOL
DnsEndHostsIcsFile(
    VOID
    );

BOOL
DnsSetHostsIcsFile(
    BOOL fOverwrite
    );

BOOL
GetHostFromHostsIcsFile(
    BOOL fStartup
    );

VOID
LoadHostsIcsFile(
    BOOL fStartup
    );

VOID
SaveHostsIcsFile(
    BOOL fShutdown
    );

BOOL
IsFileTimeExpired(
    FILETIME *ftTime
    );

BOOL
IsSuffixValid(
    WCHAR *pszName,
    WCHAR *pszSuffix
    );


#endif // _NATHLP_DNSFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dll\rmapi.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmapi.c

Abstract:

    This module contains code for the part of the router-manager interface
    which is common to all the protocols in this component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <ipinfo.h>
#include "beacon.h"

#include <atlbase.h>
CComModule _Module;
#include <atlcom.h>
#include "nathlp_i.c"

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_SAUpdate, CSharedAccessUpdate)
END_OBJECT_MAP()


extern "C" {
#include <iphlpstk.h>
}

HANDLE NhpComponentEvent = NULL;
NH_COMPONENT_MODE NhComponentMode = NhUninitializedMode;
const WCHAR NhpDhcpDomainString[] = L"DhcpDomain";
const WCHAR NhpDomainString[] = L"Domain";
const WCHAR NhpEnableProxy[] = L"EnableProxy";
LONG NhpIsWinsProxyEnabled = -1;
CRITICAL_SECTION NhLock;
HMODULE NhpRtrmgrDll = NULL;
LIST_ENTRY NhApplicationSettingsList;
LIST_ENTRY NhDhcpReservationList;
DWORD NhDhcpScopeAddress = 0;
DWORD NhDhcpScopeMask = 0;
const WCHAR NhTcpipParametersString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters";

//
// EXTERNAL DECLARATIONS
//

BOOL
APIENTRY
DllMain(
    HINSTANCE Instance,
    ULONG Reason,
    PVOID Unused
    )

/*++

Routine Description:

    Standard DLL entry/exit routine.
    Initializes/shuts-down the modules implemented in the DLL.
    The initialization performed is sufficient that all the modules'
    interface lists can be searched, whether or not the protocols are
    installed or operational.

Arguments:

    Instance - the instance of this DLL in this process

    Reason - the reason for invocation

    Unused - unused.

Return Value:

    BOOL - indicates success or failure.

--*/

{
    switch (Reason) {
        case DLL_PROCESS_ATTACH: {
            WSADATA wd;
            DisableThreadLibraryCalls(Instance);
            __try {
                InitializeCriticalSection(&NhLock);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }


            WSAStartup(MAKEWORD(2,2), &wd);
            NhInitializeTraceManagement();
            NhInitializeEventLogManagement();
            InitializeListHead(&NhApplicationSettingsList);
            InitializeListHead(&NhDhcpReservationList);
            if (NhInitializeBufferManagement()) { return FALSE; }
            if (NhInitializeTimerManagement()) { return FALSE; }
            if (!NatInitializeModule()) { return FALSE; }
            if (!DhcpInitializeModule()) { return FALSE; }
            if (!DnsInitializeModule()) { return FALSE; }
#ifndef NO_FTP_PROXY
	    if (!FtpInitializeModule()) { return FALSE; }
#endif
            if (!AlgInitializeModule()) { return FALSE; }
            if (!H323InitializeModule()) { return FALSE; }
            if(FAILED(InitializeBeaconSvr())) { return FALSE; }

            _Module.Init(ObjectMap, Instance, &LIBID_IPNATHelperLib);
            _Module.RegisterTypeLib();
            break;
        }
        case DLL_PROCESS_DETACH: {
            NhResetComponentMode();
            TerminateBeaconSvr();
            H323CleanupModule();
#ifndef NO_FTP_PROXY
            FtpCleanupModule();
#endif
            AlgCleanupModule();
            DnsCleanupModule();
            DhcpCleanupModule();
            NatCleanupModule();
            NhShutdownTimerManagement();
            NhShutdownBufferManagement();
            NhShutdownEventLogManagement();
            NhShutdownTraceManagement();
            WSACleanup();
            if (NhpRtrmgrDll) {
                FreeLibrary(NhpRtrmgrDll); NhpRtrmgrDll = NULL;
            }
            DeleteCriticalSection(&NhLock);

            _Module.Term();

            break;
        }
    }

    return TRUE;

} // DllMain


VOID
NhBuildDhcpReservations(
    VOID
    )

/*++

Routine Description:

    Builds the list of DHCP reservations

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held on a COM-initialized thread.

--*/

{
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr = NULL;
    IEnumHNetPortMappingBindings *pEnumBindings;
    IHNetIcsSettings *pIcsSettings;
    PNAT_DHCP_RESERVATION pReservation;
    ULONG ulCount;

    hr = NhGetHNetCfgMgr(&pCfgMgr);
    
    if (SUCCEEDED(hr))
    {
        //
        // Get the ICS settings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings)
                );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get DHCP scope information
        //

        hr = pIcsSettings->GetDhcpScopeSettings(
                &NhDhcpScopeAddress,
                &NhDhcpScopeMask
                );
        
        //
        // Get enumeration of DHCP reservered addresses
        //

        if (SUCCEEDED(hr))
        {
            hr = pIcsSettings->EnumDhcpReservedAddresses(&pEnumBindings);
        }
        
        pIcsSettings->Release();
    }

    if (SUCCEEDED(hr))
    {   
        //
        // Process the items in the enum
        //

        do
        {
            IHNetPortMappingBinding *pBinding;
            
            hr = pEnumBindings->Next(1, &pBinding, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Allocate a new reservation entry
                //

                pReservation = reinterpret_cast<PNAT_DHCP_RESERVATION>(
                                    NH_ALLOCATE(sizeof(*pReservation))
                                    );

                if (NULL != pReservation)
                {
                    ZeroMemory(pReservation, sizeof(*pReservation));

                    //
                    // Get computer name
                    //

                    hr = pBinding->GetTargetComputerName(
                            &pReservation->Name
                            );

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get reserved address
                        //

                        hr = pBinding->GetTargetComputerAddress(
                                &pReservation->Address
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add entry to list
                        //

                        InsertTailList(
                            &NhDhcpReservationList,
                            &pReservation->Link)
                            ;
                    }
                    else
                    {
                        //
                        // Free entry
                        //

                        NH_FREE(pReservation);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pBinding->Release();
            }
        } while (SUCCEEDED(hr) && 1 == ulCount);

        pEnumBindings->Release();
    }

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }
} // NhBuildDhcpReservations


ULONG
NhDialSharedConnection(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to connect a home-router interface.
    The connection is established by invoking the RAS autodial process
    with the appropriate phonebook and entry-name in the security context
    of the logged-on user.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    return RasAutoDialSharedConnection();
} // NhDialSharedConnection


VOID
NhFreeApplicationSettings(
    VOID
    )

/*++

Routine Description:

    Frees the list of application settings

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held.

--*/

{
    PLIST_ENTRY Link;
    PNAT_APP_ENTRY pAppEntry;

    PROFILE("NhFreeApplicationSettings");
    
    while (!IsListEmpty(&NhApplicationSettingsList))
    {
        Link = RemoveHeadList(&NhApplicationSettingsList);
        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);

        CoTaskMemFree(pAppEntry->ResponseArray);
        NH_FREE(pAppEntry);
    }
} // NhFreeApplicationSettings


VOID
NhFreeDhcpReservations(
    VOID
    )

/*++

Routine Description:

    Frees the list of DHCP reservations

Arguments:

    none.

Return Value:

    None.

Environment:

    Invoked with NhLock held.

--*/

{
    PLIST_ENTRY Link;
    PNAT_DHCP_RESERVATION pReservation;

    PROFILE("NhFreeDhcpReservations");
    
    while (!IsListEmpty(&NhDhcpReservationList))
    {
        Link = RemoveHeadList(&NhDhcpReservationList);
        pReservation = CONTAINING_RECORD(Link, NAT_DHCP_RESERVATION, Link);

        CoTaskMemFree(pReservation->Name);
        NH_FREE(pReservation);
    }
} // NhFreeDhcpReservations


BOOLEAN
NhIsDnsProxyEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to discover whether the DNS proxy is enabled.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if DNS proxy is enabled, FALSE otherwise

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhIsDnsProxyEnabled");

    return DnsIsDnsEnabled();

} // NhIsDnsProxyEnabled


BOOLEAN
NhIsLocalAddress(
    ULONG Address
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given IP address
    is for a local interface.

Arguments:

    Address - the IP address to find

Return Value:

    BOOLEAN - TRUE if the address is found, FALSE otherwise

--*/

{
    ULONG Error;
    ULONG i;
    PMIB_IPADDRTABLE Table;

    Error =
        AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_IF,
            "NhIsLocalAddress: GetIpAddrTableFromStack=%d", Error
            );
        return FALSE;
    }
    for (i = 0; i < Table->dwNumEntries; i++) {
        if (Table->table[i].dwAddr == Address) {
            HeapFree(GetProcessHeap(), 0, Table);
            return TRUE;
        }
    }
    HeapFree(GetProcessHeap(), 0, Table);
    return FALSE;

} // NhIsLocalAddress


BOOLEAN
NhIsWinsProxyEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to discover whether the WINS proxy is enabled.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if WINS proxy is enabled, FALSE otherwise

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhIsWinsProxyEnabled");

    return DnsIsWinsEnabled();

} // NhIsWinsProxyEnabled


PIP_ADAPTER_BINDING_INFO
NhQueryBindingInformation(
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is called to obtain the binding information
    for the adapter with the given index.
    It does this by obtaining a table of IP addresses from the stack,
    and determining which addresses correspond to the given index.

Arguments:

    AdapterIndex - the adapter for which binding information is required

Return Value:

    PIP_ADAPTER_BINDING_INFO - the allocated binding information

--*/

{
    PIP_ADAPTER_BINDING_INFO BindingInfo = NULL;
    ULONG Count = 0;
    ULONG i;
    PMIB_IPADDRTABLE Table;
    if (AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            ) == NO_ERROR) {
        //
        // Count the adapter's addresses
        //
        for (i = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwIndex == AdapterIndex) { ++Count; }
        }
        //
        // Allocate space for the binding info
        //
        BindingInfo = reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
                        NH_ALLOCATE(SIZEOF_IP_BINDING(Count))
                        );
        if (BindingInfo) {
            //
            // Fill in the binding info
            //
            BindingInfo->AddressCount = Count;
            BindingInfo->RemoteAddress = 0;
            Count = 0;
            for (i = 0; i < Table->dwNumEntries; i++) {
                if (Table->table[i].dwIndex != AdapterIndex) { continue; }
                BindingInfo->Address[Count].Address = Table->table[i].dwAddr;
                BindingInfo->Address[Count].Mask = Table->table[i].dwMask;
                ++Count;
            }
        }
        HeapFree(GetProcessHeap(), 0, Table);
    }
    return BindingInfo;
} // NhQueryBindingInformation


NTSTATUS
NhQueryDomainName(
    PCHAR* DomainName
    )

/*++

Routine Description:

    This routine is invoked to obtain the local domain name.

Arguments:

    DomainName - receives the allocated string containing the domain name

Return Value:

    NTSTATUS - NT status code.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    IO_STATUS_BLOCK IoStatus;
    HANDLE Key;
    ULONG Length;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("NhQueryDomainName");

    *DomainName = NULL;

    RtlInitUnicodeString(&UnicodeString, NhTcpipParametersString);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the 'Tcpip' registry key
    //

    status =
        NtOpenKey(
            &Key,
            KEY_ALL_ACCESS,
            &ObjectAttributes
            );

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error %x opening registry key",
            status
            );
        return status;
    }

    //
    // Read the 'Domain' value
    //

    status =
        NhQueryValueKey(
            Key,
            NhpDomainString,
            &Information
            );

    if (!NT_SUCCESS(status)) {
        status =
            NhQueryValueKey(
                Key,
                NhpDhcpDomainString,
                &Information
                );
    }

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error %x querying domain name",
            status
            );
        NtClose(Key);
        return status;
    }

    //
    // Copy the domain name
    //

    Length = lstrlenW((PWCHAR)Information->Data) + 1;

    *DomainName = reinterpret_cast<PCHAR>(NH_ALLOCATE(Length));

    if (!*DomainName) {
        NH_FREE(Information);
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryDomainName: error allocating domain name"
            );
        return STATUS_NO_MEMORY;
    }

    RtlUnicodeToMultiByteN(
        *DomainName,
        Length,
        NULL,
        (PWCHAR)Information->Data,
        Length * sizeof(WCHAR)
        );

    NH_FREE(Information);

    return STATUS_SUCCESS;

} // NhQueryDomainName


NTSTATUS
NhQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    )

/*++

Routine Description:

    This routine is called to obtain the value of a registry key.

Arguments:

    Key - the key to be queried

    ValueName - the value to be queried

    Information - receives a pointer to the information read

Return Value:

    NTSTATUS - NT status code.

--*/

{
    UCHAR Buffer[sizeof(KEY_VALUE_PARTIAL_INFORMATION)];
    ULONG InformationLength;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("NhQueryValueKey");

    RtlInitUnicodeString(&UnicodeString, ValueName);

    *Information = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
    InformationLength = sizeof(KEY_VALUE_PARTIAL_INFORMATION);

    //
    // Read the value's size
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status) &&
        status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL
        ) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: status %08x obtaining value size",
            status
            );
        *Information = NULL;
        return status;
    }

    //
    // Allocate space for the value's size
    //

    *Information =
        (PKEY_VALUE_PARTIAL_INFORMATION)NH_ALLOCATE(InformationLength + 2);

    if (!*Information) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: error allocating %d bytes",
            InformationLength + 2
            );
        return STATUS_NO_MEMORY;
    }

    //
    // Read the value's data
    //

    status =
        NtQueryValueKey(
            Key,
            &UnicodeString,
            KeyValuePartialInformation,
            *Information,
            InformationLength,
            &InformationLength
            );

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_REG,
            "NhQueryValueKey: status %08x obtaining value data",
            status
            );
        NH_FREE(*Information);
        *Information = NULL;
    }

    return status;

} // NhQueryValueKey


ULONG
NhMapAddressToAdapter(
    ULONG Address
    )

/*++

Routine Description:

    This routine is invoked to map an IP address to an adapter index.
    It does so by obtaining the stack's address-table, which contains
    valid adapter-indices rather than IP router-manager indices.
    This table is then used to obtain the IP address's adapter-index.

Arguments:

    Address - the local address for which an adapter-index is required

Return Value:

    ULONG - adapter index.

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG i;
    PMIB_IPADDRTABLE Table;
    PROFILE("NhMapAddressToAdapter");
    if (AllocateAndGetIpAddrTableFromStack(
            &Table, FALSE, GetProcessHeap(), 0
            ) == NO_ERROR) {
        for (i = 0; i < Table->dwNumEntries; i++) {
            if (Table->table[i].dwAddr != Address) { continue; }
            AdapterIndex = Table->table[i].dwIndex;
            break;
        }
        HeapFree(GetProcessHeap(), 0, Table);
    }
    return AdapterIndex;
} // NhMapAddressToAdapter


ULONG
NhMapInterfaceToAdapter(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to map an interface to an adapter index.
    It does so by invoking the appropriate IP router-manager entry-point.

Arguments:

    Index - the index of the interface to be mapped

Return Value:

    ULONG - adapter index.

--*/

{
    MAPINTERFACETOADAPTER FarProc;
    PROFILE("NhMapInterfaceToAdapter");
    EnterCriticalSection(&NhLock);
    if (!NhpRtrmgrDll) { NhpRtrmgrDll = LoadLibraryA("IPRTRMGR.DLL"); }
    LeaveCriticalSection(&NhLock);
    if (!NhpRtrmgrDll) { return (ULONG)-1; }
    FarProc = (MAPINTERFACETOADAPTER)GetProcAddress(NhpRtrmgrDll, "MapInterfaceToAdapter");
    return (ULONG)(FarProc ? (*FarProc)(Index) : -1);
} // NhMapInterfaceToAdapter


VOID
NhResetComponentMode(
    VOID
    )

/*++

Routine Description:

    This routine relinquishes control of the kernel-mode translation module,
    and returns this module to an uninitialized state.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhLock);
    if (NhpComponentEvent) {
        CloseHandle(NhpComponentEvent); NhpComponentEvent = NULL;
    }
    NhComponentMode = NhUninitializedMode;
    LeaveCriticalSection(&NhLock);
} // NhResetComponentMode


BOOLEAN
NhSetComponentMode(
    NH_COMPONENT_MODE ComponentMode
    )

/*++

Routine Description:

    This routine is invoked to atomically set the module into a particular mode
    in order to prevent conflict between shared-access and connection-sharing,
    both of which are implemented in this module, and both of which run
    in the 'netsvcs' instance of SVCHOST.EXE.

    In setting either mode, the routine first determines whether it is already
    executing in the alternate mode, in which case it fails.
    Otherwise, it attempts to create a named event, to claim exclusive control
    of the kernel-mode translation module. If the named event already exists,
    then the routine again fails.
    Otherwise, the kernel-mode translation module is claimed for this module
    and the module is set into the required mode.

Arguments:

    ComponentMode - the mode into which the module is to be set.

Return Value:

    BOOLEAN - TRUE if successful, FALSE if the module could not be set
        or if the kernel-mode translation module has already been claimed.
--*/

{
    EnterCriticalSection(&NhLock);
    if (NhpComponentEvent) {
        if (NhComponentMode != ComponentMode) {
            LeaveCriticalSection(&NhLock);
            NhErrorLog(
                (ComponentMode == NhRoutingProtocolMode)
                    ? IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT
                    : IP_NAT_LOG_SHARED_ACCESS_CONFLICT,
                0,
                ""
                );
            return FALSE;
        }
    } else {
        NhpComponentEvent =
            CreateEventA(NULL, FALSE, FALSE, IP_NAT_SERVICE_NAME);
        if (!NhpComponentEvent) {
            LeaveCriticalSection(&NhLock);
            return FALSE;
        } else if (GetLastError() == ERROR_ALREADY_EXISTS) {
            CloseHandle(NhpComponentEvent); NhpComponentEvent = NULL;
            LeaveCriticalSection(&NhLock);
            NhErrorLog(
                (ComponentMode == NhRoutingProtocolMode)
                    ? IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT
                    : IP_NAT_LOG_SHARED_ACCESS_CONFLICT,
                0,
                ""
                );
            return FALSE;
        }
    }
    NhComponentMode = ComponentMode;
    LeaveCriticalSection(&NhLock);
    return TRUE;
} // NhSetComponentMode


VOID
NhSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    It invokes the reconfiguration for the DHCP allocator and DNS proxy,
    neither of which are expected to operate on a NAT boundary interface.
    This notification gives either (or both) an opportunity to deactivate
    itself on NAT interfaces or reactivate itself on non-NAT interfaces.

Arguments:

    Index - the interface whose configuration has changed

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("NhSignalNatInterface");

    //
    // Attempt to obtain the corresponding DHCP and DNS interfaces.
    // It is important that this works regardless of whether DHCP allocation,
    // DNS proxying or DirectPlay transparent proxying is enabled;
    // the interface lists are initialized minimally in 'DllMain' above.
    //

    DhcpSignalNatInterface(Index, Boundary);
    DnsSignalNatInterface(Index, Boundary);
#ifndef NO_FTP_PROXY
    FtpSignalNatInterface(Index, Boundary);
#endif
//    AlgSignalNatInterface(Index, Boundary);
    H323SignalNatInterface(Index, Boundary);

} // NhSignalNatInterface


VOID
NhUpdateApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to (re)load the advanced application settings.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr;
    PNAT_APP_ENTRY pAppEntry;
    IHNetCfgMgr *pCfgMgr = NULL;
    IHNetProtocolSettings *pProtocolSettings;
    IEnumHNetApplicationProtocols *pEnumApps;
    BOOLEAN ComInitialized = FALSE;
    ULONG ulCount;
    PROFILE("NhUpdateApplicationSettings");

    EnterCriticalSection(&NhLock);

    //
    // Free old settings list
    //

    NhFreeApplicationSettings();

    //
    // Free DHCP reservation list
    //

    NhFreeDhcpReservations();

    //
    // Make sure COM is initialized on this thread
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (SUCCEEDED(hr))
    {
        ComInitialized = TRUE;
    }
    else if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
    }
    

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetCfgMgr pointer out of the GIT 
        //

        hr = NhGetHNetCfgMgr(&pCfgMgr);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get the IHNetProtocolSettings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetProtocolSettings, &pProtocolSettings)
                );
    }

    if (SUCCEEDED(hr))
    {
        //
        // Get the enumeration of enabled application protocols
        //

        hr = pProtocolSettings->EnumApplicationProtocols(TRUE, &pEnumApps);
        pProtocolSettings->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Process the items in the enum
        //

        do
        {
            IHNetApplicationProtocol *pAppProtocol;
            
            hr = pEnumApps->Next(1, &pAppProtocol, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // Allocate a new app entry
                //

                pAppEntry = reinterpret_cast<PNAT_APP_ENTRY>(
                                NH_ALLOCATE(sizeof(*pAppEntry))
                                );

                if (NULL != pAppEntry)
                {
                    ZeroMemory(pAppEntry, sizeof(*pAppEntry));

                    //
                    // Get protocol
                    //

                    hr = pAppProtocol->GetOutgoingIPProtocol(
                            &pAppEntry->Protocol
                            );

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get port
                        //

                        hr = pAppProtocol->GetOutgoingPort(
                                &pAppEntry->Port
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Get responses
                        //

                        hr = pAppProtocol->GetResponseRanges(
                                &pAppEntry->ResponseCount,
                                &pAppEntry->ResponseArray
                                );
                    }

                    if (SUCCEEDED(hr))
                    {
                        //
                        // Add entry to list
                        //

                        InsertTailList(&NhApplicationSettingsList, &pAppEntry->Link);
                    }
                    else
                    {
                        //
                        // Free entry
                        //

                        NH_FREE(pAppEntry);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                pAppProtocol->Release();
            }
        } while (SUCCEEDED(hr) && 1 == ulCount);

        pEnumApps->Release();
    }

    //
    // Build the DHCP reservation list
    //

    NhBuildDhcpReservations();
    
    LeaveCriticalSection(&NhLock);

    //
    // Free config manager
    //

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }

    //
    // Uninitialize COM
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

} // NhUpdateApplicationSettings


ULONG
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingCharacteristics,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceCharacteristics
    )

/*++

Routine Description:

    This routine is invoked once for each protocol implemented in this module.
    On each invocation, the supplied 'RoutingCharacteristics' indicates
    the protocol to be registered in its 'dwProtocolId' field.

Arguments:

    RoutingCharacteristics - on input, the protocol to be registered
        and the router-manager's supported functionality.

    ServiceCharacteristics - unused.

Return Value:

    ULONG - status code.

--*/

{
    if (RoutingCharacteristics->dwVersion < MS_ROUTER_VERSION) {
        return ERROR_NOT_SUPPORTED;
    }

    if ((RoutingCharacteristics->fSupportedFunctionality &
            (RF_ROUTING|RF_ADD_ALL_INTERFACES)) != 
            (RF_ROUTING|RF_ADD_ALL_INTERFACES)) {
        return ERROR_NOT_SUPPORTED;
    }

    switch (RoutingCharacteristics->dwProtocolId) {

        case MS_IP_NAT: {
            //
            // Attempt to set the component into 'Connection Sharing' mode.
            // This module implements both shared-access and connection-sharing
            // which are mutually exclusive, so we need to ensure that
            // shared-access is not operational before proceeding.
            //
            if (!NhSetComponentMode(NhRoutingProtocolMode)) {
                return ERROR_CAN_NOT_COMPLETE;
            }
            CopyMemory(
                RoutingCharacteristics,
                &NatRoutingCharacteristics,
                sizeof(NatRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality = RF_ROUTING;
            break;
        }

        case MS_IP_DNS_PROXY: {
            CopyMemory(
                RoutingCharacteristics,
                &DnsRoutingCharacteristics,
                sizeof(DnsRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

        case MS_IP_DHCP_ALLOCATOR: {
            CopyMemory( 
                RoutingCharacteristics,
                &DhcpRoutingCharacteristics,
                sizeof(DhcpRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

#ifndef NO_FTP_PROXY
        case MS_IP_FTP: {
            CopyMemory( 
                RoutingCharacteristics,
                &FtpRoutingCharacteristics,
                sizeof(FtpRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }
#endif
        case MS_IP_ALG: {
            CopyMemory( 
                RoutingCharacteristics,
                &AlgRoutingCharacteristics,
                sizeof(AlgRoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }
        
        case MS_IP_H323: {
            CopyMemory( 
                RoutingCharacteristics,
                &H323RoutingCharacteristics,
                sizeof(H323RoutingCharacteristics)
                );
            RoutingCharacteristics->fSupportedFunctionality =
                    (RF_ROUTING|RF_ADD_ALL_INTERFACES);
            break;
        }

        default: {
            return ERROR_NOT_SUPPORTED;
        }
    }

    ServiceCharacteristics->mscMpr40ServiceChars.fSupportedFunctionality = 0;

    return NO_ERROR;

} // RegisterProtocol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsif.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsif.c

Abstract:

    This module contains code for the DNS proxy's interface management.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop

//
// LOCAL TYPE DECLARATIONS
//

typedef struct _DNS_DEFER_READ_CONTEXT {
    ULONG Index;
    SOCKET Socket;
    ULONG DeferralCount;
} DNS_DEFER_READ_CONTEXT, *PDNS_DEFER_READ_CONTEXT;

#define DNS_DEFER_READ_INITIAL_TIMEOUT (1 * 1000)
#define DNS_DEFER_READ_TIMEOUT (5 * 1000)
#define DNS_CONNECT_TIMEOUT (60 * 1000)

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY DnsInterfaceList;
CRITICAL_SECTION DnsInterfaceLock;
ULONG DnspLastConnectAttemptTickCount;

//
// Forward declarations
//

VOID NTAPI
DnspDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DnspDeferReadWorkerRoutine(
    PVOID Context
    );

ULONG NTAPI
DnspSaveFileWorkerRoutine(
    PVOID Context
    );


ULONG
DnsActivateInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating datagram-reads on each created socket

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'DnsInterfaceLock' held by caller.

--*/

{
    BOOLEAN EnableDns;
    BOOLEAN EnableWins = FALSE;
    ULONG Error;
    ULONG i;
    BOOLEAN IsNatInterface;

    PROFILE("DnsActivateInterface");

    EnterCriticalSection(&DnsGlobalInfoLock);
    EnableDns =
        (DnsGlobalInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS) ? TRUE : FALSE;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // (re)take the interface lock for the duration of the routine
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!(EnableDns || EnableWins) ||
        DNS_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        return NO_ERROR;
    }

    if (NhIsBoundaryInterface(Interfacep->Index, &IsNatInterface)) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: ignoring NAT interface %d",
            Interfacep->Index
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_NAT_INTERFACE_IGNORED,
            0,
            "%d",
            Interfacep->Index
            );
        LeaveCriticalSection(&DnsInterfaceLock);
        return NO_ERROR;
    }

    if (!IsNatInterface) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        LeaveCriticalSection(&DnsInterfaceLock);
        return NO_ERROR;
    }

    //
    // Create datagram sockets for receiving data on each logical network
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (EnableDns) {
            Error =
                NhCreateDatagramSocket(
                    Interfacep->BindingArray[i].Address,
                    DNS_PORT_SERVER,
                    &Interfacep->BindingArray[i].Socket[DnsProxyDns]
                    );
            if (Error) { break; }
        }

        if (EnableWins) {
            Error =
                NhCreateDatagramSocket(
                    Interfacep->BindingArray[i].Address,
                    WINS_PORT_SERVER,
                    &Interfacep->BindingArray[i].Socket[DnsProxyWins]
                    );
            if (Error) { break; }
        }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (; (LONG)i >= 0; i--) {
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket[DnsProxyDns]
                );
            Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
            NhDeleteDatagramSocket(
                Interfacep->BindingArray[i].Socket[DnsProxyWins]
                );
            Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_DNS_PROXY_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&DnsInterfaceLock);
        return Error;
    }

    if (EnableWins && DNS_REFERENCE_INTERFACE(Interfacep)) {
        Error =
            NhReadDatagramSocket(
                &DnsComponentReference,
                DnsGlobalSocket,
                NULL,
                DnsReadCompletionRoutine,
                Interfacep,
                NULL
                );
        if (Error) { DNS_DEREFERENCE_INTERFACE(Interfacep); }
    }

    //
    // Initiate read-operations on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (EnableDns) {

            //
            // Make a reference to the interface;
            // this reference is released in the completion routine
            //
    
            if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }
    
            //
            // Initiate the read-operation
            //
    
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Interfacep->BindingArray[i].Socket[DnsProxyDns],
                    NULL,
                    DnsReadCompletionRoutine,
                    Interfacep,
                    UlongToPtr(Interfacep->BindingArray[i].Address)
                    );
    
            //
            // Drop the reference if a failure occurred
            //
    
            if (Error) {
    
                NhErrorLog(
                    IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    Interfacep->BindingArray[i].Address
                    );
    
                DNS_DEREFERENCE_INTERFACE(Interfacep);
    
                //
                // Reissue the read-operation later
                //
    
                DnsDeferReadInterface(
                    Interfacep,
                    Interfacep->BindingArray[i].Socket[DnsProxyDns]
                    );
    
                Error = NO_ERROR;
            }
        }

        if (EnableWins) {

            //
            // Reference the interface for the WINS socket receive
            //
    
            if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }
    
            //
            // Initiate the read-operation
            //
    
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Interfacep->BindingArray[i].Socket[DnsProxyWins],
                    NULL,
                    DnsReadCompletionRoutine,
                    Interfacep,
                    UlongToPtr(Interfacep->BindingArray[i].Address)
                    );
    
            //
            // Drop the reference if a failure occurred
            //
    
            if (Error) {
    
                NhErrorLog(
                    IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    Interfacep->BindingArray[i].Address
                    );
    
                DNS_DEREFERENCE_INTERFACE(Interfacep);
    
                //
                // Reissue the read-operation later
                //
    
                DnsDeferReadInterface(
                    Interfacep,
                    Interfacep->BindingArray[i].Socket[DnsProxyWins]
                    );
    
                Error = NO_ERROR;
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // queue a write to disk (ip address may have changed)
    // (necessary to do this to prevent possible deadlock)
    //
    if (REFERENCE_DNS())
    {
        if (!QueueUserWorkItem(DnspSaveFileWorkerRoutine, NULL, WT_EXECUTEDEFAULT))
        {
            Error = GetLastError();
            NhTrace(
            TRACE_FLAG_DNS,
            "DnsActivateInterface: QueueUserWorkItem failed with error %d (0x%08x)",
            Error,
            Error
            );
            DEREFERENCE_DNS();
        }
        else
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsActivateInterface: queued a write of %s file",
                HOSTSICSFILE
                );
        }
    }

    return NO_ERROR;

} // DnsActivateInterface


ULONG
DnsBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsBindInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (DNS_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    }
    else {
        Interfacep->BindingArray =
            reinterpret_cast<PDNS_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(DNS_BINDING))
                );
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "DnsBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(DNS_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending[DnsProxyDns] = FALSE;
        Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
        Interfacep->BindingArray[i].TimerPending[DnsProxyWins] = FALSE;
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        Error = DnsActivateInterface(Interfacep);
    }

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsBindInterface


VOID
DnsCleanupInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context.

--*/

{
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }

    while (!IsListEmpty(&Interfacep->QueryList)) {
        Link = Interfacep->QueryList.Flink;
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        DnsDeleteQuery(Interfacep, Queryp);
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // DnsCleanupInterface


VOID
DnsConnectDefaultInterface(
    PVOID Unused
    )

/*++

Routine Description:

    This routine is invoked to attempt to initiate a demand-dial connection
    on the interface marked as 'default' for DNS requests.
    If no such interface is found, no operation is performed.

Arguments:

    none used.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine is invoked from the context of an RTUTILS work item.

--*/

{
    ULONG Error;
    ULONG Index;
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    ULONG TickCount;
    ROUTER_INTERFACE_TYPE Type;

    PROFILE("DnsConnectDefaultInterface");

    //
    // To avoid repeated autodial dialogs, we record the last time
    // we attempted to connect the default interface.
    // If we did so recently, return silently.
    // N.B. If the tick-count wrapped, we reset the last-attempt counter.
    //

    EnterCriticalSection(&DnsGlobalInfoLock);
    TickCount = NtGetTickCount();
    if (TickCount > DnspLastConnectAttemptTickCount &&
        TickCount <= (DnspLastConnectAttemptTickCount + DNS_CONNECT_TIMEOUT)
        ) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }
    DnspLastConnectAttemptTickCount = TickCount;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // Look through the interface list for one which is marked as default
    //

    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (!DNS_INTERFACE_ADMIN_DEFAULT(Interfacep)) { continue; }

        //
        // We've found the default interface.
        //

        Index = Interfacep->Index;

        LeaveCriticalSection(&DnsInterfaceLock);

        //
        // Attempt to connect it.
        //

        EnterCriticalSection(&DnsGlobalInfoLock);
        Error =
            DnsSupportFunctions.DemandDialRequest(
                MS_IP_DNS_PROXY,
                Index
                );
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // No interface is marked as the default.
    //

    LeaveCriticalSection(&DnsInterfaceLock);
    NhDialSharedConnection();
    NhWarningLog(
        IP_DNS_PROXY_LOG_NO_DEFAULT_INTERFACE,
        0,
        ""
        );
    DEREFERENCE_DNS();

} // DnsConnectDefaultInterface


ULONG
DnsConfigureInterface(
    ULONG Index,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("DnsConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|DNS_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DnsActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }
    else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = DnsActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
        else
        if (!(OldFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED) &&
            (NewFlags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                DnsDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsConfigureInterface


ULONG
DnsCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo,
    OUT PDNS_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the DNS proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsCreateInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (DnsLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PDNS_INTERFACE>(
                    NH_ALLOCATE(sizeof(DNS_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "DnsCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DNS_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|DNS_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InitializeListHead(&Interfacep->QueryList);
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&DnsInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // DnsCreateInterface


VOID
DnsDeactivateInterface(
    PDNS_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'DnsInterfaceLock' held by caller.

--*/

{
    ULONG i;
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsDeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    //
    // Stop all network I/O on the interface's logical networks
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        NhDeleteDatagramSocket(
            Interfacep->BindingArray[i].Socket[DnsProxyDns]
            );
        Interfacep->BindingArray[i].Socket[DnsProxyDns] = INVALID_SOCKET;
        NhDeleteDatagramSocket(
            Interfacep->BindingArray[i].Socket[DnsProxyWins]
            );
        Interfacep->BindingArray[i].Socket[DnsProxyWins] = INVALID_SOCKET;
    }

    //
    // Eliminate all pending queries
    //

    while (!IsListEmpty(&Interfacep->QueryList)) {
        Link = RemoveHeadList(&Interfacep->QueryList);
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        NH_FREE(Queryp);
    }

    RELEASE_LOCK(Interfacep);

} // DnsDeactivateInterface


VOID NTAPI
DnspDeferReadCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to re-issue a deferred read when the countdown
    for the deferral completes.

Arguments:

    Context - holds information identifying the interface and socket

    TimedOut - indicates whether the countdown completed

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the component on our behalf.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG Error;
    ULONG i;
    PDNS_INTERFACE Interfacep;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnspDeferReadCallbackRoutine");

    Contextp = (PDNS_DEFER_READ_CONTEXT)Context;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DNS_INTERFACE_ACTIVE(Interfacep) ||
        !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the socket on which to reissue the read
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns]
                != Contextp->Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins]
                != Contextp->Socket) {
            continue;
        }

        //
        // This is the binding on which to reissue the read.
        // If no pending timer is recorded, assume a rebind occurred, and quit.
        //

        if (!Interfacep->BindingArray[i].TimerPending[Type]) { break; }

        Interfacep->BindingArray[i].TimerPending[Type] = FALSE;

        Error =
            NhReadDatagramSocket(
                &DnsComponentReference,
                Contextp->Socket,
                NULL,
                DnsReadCompletionRoutine,
                Interfacep,
                UlongToPtr(Interfacep->BindingArray[i].Mask)
                );

        RELEASE_LOCK(Interfacep);

        if (!Error) {
            NH_FREE(Contextp);
            DEREFERENCE_DNS();
            return;
        }

        //
        // An error occurred; we'll have to retry later.
        // we queue a work item which sets the timer.
        //

        NhTrace(
            TRACE_FLAG_DNS,
            "DnspDeferReadCallbackRoutine: error %d reading interface %d",
            Error,
            Interfacep->Index
            );

        //
        // Reference the component on behalf of the work-item
        //

        if (REFERENCE_DNS()) {
    
            //
            // Queue a work-item, reusing the deferral context
            //
    
            status =
                RtlQueueWorkItem(
                    DnspDeferReadWorkerRoutine,
                    Contextp, 
                    WT_EXECUTEINIOTHREAD
                    );
    
            if (NT_SUCCESS(status)) {
                Contextp = NULL;
            }
            else {
                NH_FREE(Contextp);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnspDeferReadCallbackRoutine: error %d deferring %d",
                    Error,
                    Interfacep->Index
                    );
                DEREFERENCE_DNS();
            }
        }

        DNS_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DNS();
        return;
    }

    //
    // The interface was not found; never mind.
    //

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    NH_FREE(Contextp);
    DEREFERENCE_DNS();

} // DnspDeferReadCallbackRoutine


VOID
DnsDeferReadInterface(
    PDNS_INTERFACE Interfacep,
    SOCKET Socket
    )

/*++

Routine Description:

    This routine is invoked to defer a read-request on an interface,
    typically if an attempt to post a read failed.

Arguments:

    Interfacep - the interface on which to defer the request

    Socket - the socket on which to defer the request

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' referenced and locked by the caller.
    The caller may release the reference upon return.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnsDeferReadInterface");

    //
    // Find the binding for the given socket.
    //

    status = STATUS_SUCCESS;

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns] != Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins] != Socket) {
            continue;
        }

        //
        // This is the binding. If there is already a timer for it,
        // then just return silently.
        //

        if (Interfacep->BindingArray[i].TimerPending[Type]) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // Allocate a context block for the deferral.
        //

        Contextp =
            (PDNS_DEFER_READ_CONTEXT)
                NH_ALLOCATE(sizeof(DNS_DEFER_READ_CONTEXT));

        if (!Contextp) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsDeferReadInterface: cannot allocate deferral context"
                );
            status = STATUS_NO_MEMORY;
            break;
        }

        Contextp->Index = Interfacep->Index;
        Contextp->Socket = Socket;
        Contextp->DeferralCount = 1;
    
        //
        // Install a timer to re-issue the read request
        //

        status =
            NhSetTimer(
                &DnsComponentReference,
                NULL,
                DnspDeferReadCallbackRoutine,
                Contextp,
                DNS_DEFER_READ_INITIAL_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Interfacep->BindingArray[i].TimerPending[Type] = TRUE;
        }
        else {
            NH_FREE(Contextp);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsDeferReadInterface: status %08x setting deferral timer",
                status
                );
        }

        break;
    }

    if (i >= Interfacep->BindingCount) { status = STATUS_UNSUCCESSFUL; }

} // DnsDeferReadInterface


VOID APIENTRY
DnspDeferReadWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to set a timer for reissuing a deferred read.

Arguments:

    Context - contains the context for the timer.

Return Value:

    none.

Environment:

    Invoked with an outstanding reference to the module made on our behalf.

--*/

{
    PDNS_DEFER_READ_CONTEXT Contextp;
    ULONG i;
    PDNS_INTERFACE Interfacep;
    NTSTATUS status;
    DNS_PROXY_TYPE Type;

    PROFILE("DnspDeferReadWorkerRoutine");

    Contextp = (PDNS_DEFER_READ_CONTEXT)Context;
    ++Contextp->DeferralCount;

    //
    // Find the interface on which the read was deferred
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(Contextp->Index, NULL);
    if (!Interfacep ||
        !DNS_INTERFACE_ACTIVE(Interfacep) ||
        !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NH_FREE(Contextp);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Search for the binding on which to set the timer
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {

        if (Interfacep->BindingArray[i].Socket[Type = DnsProxyDns]
                != Contextp->Socket &&
            Interfacep->BindingArray[i].Socket[Type = DnsProxyWins]
                != Contextp->Socket) {
            continue;
        }
    
        //
        // This is the binding on which to reissue the read.
        // If a timer is already pending, assume a rebind occurred, and quit.
        //

        if (Interfacep->BindingArray[i].TimerPending[Type]) { break; }

        //
        // Install a timer to re-issue the read request,
        // reusing the deferral context.
        //

        status =
            NhSetTimer(
                &DnsComponentReference,
                NULL,
                DnspDeferReadCallbackRoutine,
                Contextp,
                DNS_DEFER_READ_TIMEOUT
                );

        if (NT_SUCCESS(status)) {
            Contextp = NULL;
            Interfacep->BindingArray[i].TimerPending[Type] = TRUE;
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnspDeferReadWorkerRoutine: status %08x setting timer",
                status
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    if (Contextp) { NH_FREE(Contextp); }
    DEREFERENCE_DNS();

} // DnspDeferReadWorkerRoutine


ULONG
DnsDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsDeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    DnsDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    DnsCleanupInterface(Interfacep);

    LeaveCriticalSection(&DnsInterfaceLock);

    return NO_ERROR;

} // DnsDeleteInterface


ULONG
DnsDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!DNS_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (DNS_INTERFACE_BOUND(Interfacep)) {
        DnsDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsDisableInterface


ULONG
DnsEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (DNS_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= DNS_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        Error = DnsActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // DnsEnableInterface


ULONG
DnsInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("DnsInitializeInterfaceManagement");

    InitializeListHead(&DnsInterfaceList);
    __try {
        InitializeCriticalSection(&DnsInterfaceLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "DnsInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    DnspLastConnectAttemptTickCount = NtGetTickCount();

    return Error;

} // DnsInitializeInterfaceManagement


PDNS_INTERFACE
DnsLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PDNS_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'DnsInterfaceLock'
    held by caller.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsLookupInterface");

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (Index > Interfacep->Index) { continue; }
        else
        if (Index < Interfacep->Index) { break; }

        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // DnsLookupInterface


ULONG
DnsQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!DNS_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_DNS_PROXY_INTERFACE_INFO)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_DNS_PROXY_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_DNS_PROXY_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_DNS_PROXY_INTERFACE_INFO);

    LeaveCriticalSection(&DnsInterfaceLock);

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsQueryInterface


VOID
DnsReactivateEveryInterface(
    VOID
    )

/*++

Routine Description:

    This routine is called to reactivate all activate interfaces
    when a change occurs to the global DNS or WINS proxy setting.
    Thus if, for instance, WINS proxy is disabled, during deactivation
    all such sockets are closed, and during reactivation they are
    not reopened.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from a router-manager thread with no locks held.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsReactivateEveryInterface");

    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         ) {

        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        if (!DNS_REFERENCE_INTERFACE(Interfacep)) { continue; }

        if (DNS_INTERFACE_ACTIVE(Interfacep)) {
            DnsDeactivateInterface(Interfacep);
            DnsActivateInterface(Interfacep);
        }

        DNS_DEREFERENCE_INTERFACE(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

} // DnsReactivateEveryInterface


ULONG NTAPI
DnspSaveFileWorkerRoutine(
    PVOID Context
    )
{
    //
    // Context unused
    //
    
    PROFILE("DnspSaveFileWorkerRoutine");

    SaveHostsIcsFile(FALSE);

    DEREFERENCE_DNS();
    return NO_ERROR;
} // DnspSaveFileWorkerRoutine


VOID
DnsShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PDNS_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("DnsShutdownInterfaceManagement");

    while (!IsListEmpty(&DnsInterfaceList)) {
        Link = RemoveHeadList(&DnsInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);
        if (DNS_INTERFACE_ACTIVE(Interfacep)) {
            DnsDeactivateInterface(Interfacep);
        }
        DnsCleanupInterface(Interfacep);
    }

    DeleteCriticalSection(&DnsInterfaceLock);

} // DnsShutdownInterfaceManagement


VOID
DnsSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the DNS proxy
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsSignalNatInterface");

    EnterCriticalSection(&DnsGlobalInfoLock);
    if (!DnsGlobalInfo) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);
    EnterCriticalSection(&DnsInterfaceLock);
    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        return;
    }
    DnsDeactivateInterface(Interfacep);
    if (DNS_INTERFACE_ACTIVE(Interfacep)) {
        DnsActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&DnsInterfaceLock);

} // DnsSignalNatInterface


ULONG
DnsUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMDNS.C').

--*/

{
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&DnsInterfaceLock);

    if (!(Interfacep = DnsLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!DNS_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "DnsUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~DNS_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (DNS_INTERFACE_ENABLED(Interfacep)) {
        DnsDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingArray);
    Interfacep->BindingArray = NULL;
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    DNS_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // DnsUnbindInterface


ULONG
DnsGetPrivateInterfaceAddress(
    VOID
    )
/*++

Routine Description:

    This routine is invoked to return the IP address on which DNS
    has been enabled.

Arguments:

    none.

Return Value:

    Bound IP address if an address is found (else 0).

Environment:

    Invoked from an arbitrary context.
    
--*/
{
    PROFILE("DnsGetPrivateInterfaceAddress");

    ULONG   ipAddr = 0;
    ULONG   ulRet  = NO_ERROR;

    //
    // Find out the first available interface on which we are enabled and
    // return the primary IP address to which we are bound.
    //

    PDNS_INTERFACE Interfacep = NULL;
    PLIST_ENTRY    Link;
    ULONG          i;
   
    EnterCriticalSection(&DnsInterfaceLock);

    for (Link = DnsInterfaceList.Flink;
         Link != &DnsInterfaceList;
         Link = Link->Flink
         )
    {
        Interfacep = CONTAINING_RECORD(Link, DNS_INTERFACE, Link);

        ACQUIRE_LOCK(Interfacep);

        for (i = 0; i < Interfacep->BindingCount; i++)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsGetPrivateInterfaceAddress: IP address %s (Index %d)",
                INET_NTOA(Interfacep->BindingArray[i].Address),
                Interfacep->Index
                );
                
            if (Interfacep->BindingArray[i].Address &
                Interfacep->BindingArray[i].Mask)
            {
                ipAddr = Interfacep->BindingArray[i].Address;
                break;
            }
        }
        
        RELEASE_LOCK(Interfacep);

        if (ipAddr)
        {
            LeaveCriticalSection(&DnsInterfaceLock);

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsGetPrivateInterfaceAddress: Dns private interface IP address %s (Index %d)",
                INET_NTOA(ipAddr),
                Interfacep->Index
                );
            
            return ipAddr;
        }
    }

    LeaveCriticalSection(&DnsInterfaceLock);

    return ipAddr;
} // DnsGetPrivateInterfaceAddress
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsif.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsif.h

Abstract:

    This module contains declarations for the DNS proxy's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:
    
--*/

#ifndef _NATHLP_DNSIF_H_
#define _NATHLP_DNSIF_H_

//
// Enumeration: DNS_PROXY_TYPE
//

typedef enum {
    DnsProxyDns = 0,
    DnsProxyWins,
    DnsProxyCount
} DNS_PROXY_TYPE;

#define DNS_PROXY_TYPE_TO_PORT(t) \
    (USHORT)(((t) == DnsProxyDns) ? DNS_PORT_SERVER : WINS_PORT_SERVER)

#define DNS_PROXY_PORT_TO_TYPE(p) \
    (DNS_PROXY_TYPE)(((p) == DNS_PORT_SERVER) ? DnsProxyDns : DnsProxyWins)


//
// Structure:   DNS_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
// The 'TimerPending' field is set when a receive-attempt fails on an interface
// and a timer is queued to reattempt the receive later.
//

typedef struct _DNS_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET Socket[DnsProxyCount];
    BOOLEAN TimerPending[DnsProxyCount];
} DNS_BINDING, *PDNS_BINDING;


//
// Structure:   DNS_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of DNS interfaces,
// sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('DnsInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _DNS_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    NET_INTERFACE_TYPE Type; // read-only
    IP_DNS_PROXY_INTERFACE_INFO Info;
    ULONG Flags;
    ULONG BindingCount;
    PDNS_BINDING BindingArray;
    LIST_ENTRY QueryList;
} DNS_INTERFACE, *PDNS_INTERFACE;

//
// Flags
//

#define DNS_INTERFACE_FLAG_DELETED      0x80000000
#define DNS_INTERFACE_DELETED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_DELETED)

#define DNS_INTERFACE_FLAG_BOUND        0x40000000
#define DNS_INTERFACE_BOUND(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_BOUND)

#define DNS_INTERFACE_FLAG_ENABLED      0x20000000
#define DNS_INTERFACE_ENABLED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_ENABLED)

#define DNS_INTERFACE_FLAG_CONFIGURED   0x10000000
#define DNS_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & DNS_INTERFACE_FLAG_CONFIGURED)

#define DNS_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (DNS_INTERFACE_FLAG_BOUND|DNS_INTERFACE_FLAG_ENABLED)) \
        == (DNS_INTERFACE_FLAG_BOUND|DNS_INTERFACE_FLAG_ENABLED))

#define DNS_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_DNS_PROXY_INTERFACE_FLAG_DISABLED)

#define DNS_INTERFACE_ADMIN_DEFAULT(i) \
    ((i)->Flags & IP_DNS_PROXY_INTERFACE_FLAG_DEFAULT)

//
// Synchronization
//

#define DNS_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, DNS_INTERFACE_DELETED)

#define DNS_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, DnsCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY DnsInterfaceList;
extern CRITICAL_SECTION DnsInterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
DnsActivateInterface(
    PDNS_INTERFACE Interfacep
    );

ULONG
DnsBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
DnsCleanupInterface(
    PDNS_INTERFACE Interfacep
    );

VOID APIENTRY
DnsConnectDefaultInterface(
    PVOID Unused
    );

ULONG
DnsConfigureInterface(
    ULONG Index,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo
    );

ULONG
DnsCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_DNS_PROXY_INTERFACE_INFO InterfaceInfo,
    PDNS_INTERFACE* InterfaceCreated
    );

VOID
DnsDeactivateInterface(
    PDNS_INTERFACE Interfacep
    );

VOID
DnsDeferReadInterface(
    PDNS_INTERFACE Interfacep,
    SOCKET Socket
    );

ULONG
DnsDeleteInterface(
    ULONG Index
    );

ULONG
DnsDisableInterface(
    ULONG Index
    );

ULONG
DnsEnableInterface(
    ULONG Index
    );

ULONG
DnsInitializeInterfaceManagement(
    VOID
    );

PDNS_INTERFACE
DnsLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
DnsQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
DnsReactivateEveryInterface(
    VOID
    );

VOID
DnsShutdownInterfaceManagement(
    VOID
    );

VOID
DnsSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
DnsUnbindInterface(
    ULONG Index
    );

ULONG
DnsGetPrivateInterfaceAddress(
    VOID
    );

#endif // _NATHLP_DNSIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsio.h

Abstract:

    This module contains declarations for the DNS allocator's network I/O
    completion routines.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DNSIO_H_
#define _NATHLP_DNSIO_H_

VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
DnsWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DNSIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnslog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnslog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   25-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            02-Jan-2001
    Added IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED
        & IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX

--*/

#define IP_DNS_PROXY_LOG_BASE                       31000

#define IP_DNS_PROXY_LOG_NAT_INTERFACE_IGNORED      (IP_DNS_PROXY_LOG_BASE+1)
/*
 * The DNS proxy agent detected network address translation (NAT) enabled
 * on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_DNS_PROXY_LOG_ACTIVATE_FAILED            (IP_DNS_PROXY_LOG_BASE+2)
/*
 * The DNS proxy agent was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_RECEIVE_FAILED             (IP_DNS_PROXY_LOG_BASE+3)
/*
 * The DNS proxy agent encountered a network error while attempting to
 * receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_ALLOCATION_FAILED          (IP_DNS_PROXY_LOG_BASE+4)
/*
 * The DNS proxy agent was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_DNS_PROXY_LOG_RESPONSE_FAILED            (IP_DNS_PROXY_LOG_BASE+5)
/*
 * The DNS proxy agent encountered a network error while attempting
 * to forward a response to a client from a name-resolution server
 * on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_QUERY_FAILED               (IP_DNS_PROXY_LOG_BASE+6)
/*
 * The DNS proxy agent encountered a network error while attempting
 * to forward a query from the client %1 to the server %2
 * on the interface with IP address %3.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED       (IP_DNS_PROXY_LOG_BASE+7)
/*
 * The DNS proxy agent was unable to register for notification of changes
 * to the local list of DNS and WINS servers.
 * This may indicate that system resources are low.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_SERVER_LIST             (IP_DNS_PROXY_LOG_BASE+8)
/*
 * The DNS proxy agent was unable to read the local list of name-resolution
 * servers from the registry.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_SERVERS_LEFT            (IP_DNS_PROXY_LOG_BASE+9)
/*
 * The DNS proxy agent was unable to resolve a query from %1
 * after consulting all entries in the local list of name-resolution servers.
 */

#define IP_DNS_PROXY_LOG_DEMAND_DIAL_FAILED         (IP_DNS_PROXY_LOG_BASE+10)
/*
 * The DNS proxy agent was unable to initiate a demand-dial connection
 * on the default interface while trying to resolve a query from %1.
 */

#define IP_DNS_PROXY_LOG_NO_DEFAULT_INTERFACE       (IP_DNS_PROXY_LOG_BASE+11)
/*
 * The DNS proxy agent was unable to resolve a query
 * because no list of name-resolution servers is configured locally
 * and no interface is configured as the default for name-resolution.
 * Please configure one or more name-resolution server addresses,
 * or configure an interface to be automatically dialed when a request
 * is received by the DNS proxy agent.
 */

#define IP_DNS_PROXY_LOG_ERROR_SERVER_LIST          (IP_DNS_PROXY_LOG_BASE+12)
/*
 * The DNS proxy agent encountered an error while obtaining the local list
 * of name-resolution servers.
 * Some DNS or WINS servers may be inaccessible to clients on the local network.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED  (IP_DNS_PROXY_LOG_BASE+13)
/*
 * The DNS proxy agent was unable to register for notification of changes
 * to the ICS Domain suffix string.
 * This may indicate that system resources are low.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX             (IP_DNS_PROXY_LOG_BASE+14)
/*
 * The DNS proxy agent was unable to read the ICS Domain suffix string
 * from the registry.
 * The data is the error code.
 */

#define IP_DNS_PROXY_LOG_END                        (IP_DNS_PROXY_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsio.c

Abstract:

    This module contains code for the DNS allocator's network I/O completion
    routines.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "dnsmsg.h"


VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a datagram socket bound to the DNS server UDP port.

    The message read is validated and processed; the processing may involve
    creating a query-record and forwarding the query to a server, or
    matching a response to an existing query-record and forwarding the
    response to the appropriate client.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_INTERFACE Interfacep;

    PROFILE("DnsReadCompletionRoutine");

    do {

        //
        // There are two cases where we don't process the message;
        // (a) the I/O operation failed
        // (b) the interface is no longer active
        // In case (a), we repost the buffer; in case (b), we do not.
        //

        Interfacep = (PDNS_INTERFACE)Bufferp->Context;

        //
        // First look for an error code
        //
    
        if (ErrorCode) {

            NhTrace(
                TRACE_FLAG_IO,
                "DnsReadCompletionRoutine: error %d for read-context %x",
                ErrorCode,
                Bufferp->Context
                );

            //
            // See if the interface is still active
            //

            ACQUIRE_LOCK(Interfacep);
            if (!DNS_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else {
                RELEASE_LOCK(Interfacep);
                EnterCriticalSection(&DnsInterfaceLock);
                if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    NhReleaseBuffer(Bufferp);
                } else {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    //
                    // Repost the buffer for another read operation
                    //
                    do {
                        Error =
                            NhReadDatagramSocket(
                                &DnsComponentReference,
                                Bufferp->Socket,
                                Bufferp,
                                DnsReadCompletionRoutine,
                                Bufferp->Context,
                                Bufferp->Context2
                                );
                        //
                        // A connection-reset error indicates that our last
                        // *send* could not be delivered at its destination.
                        // We could hardly care less; so issue the read again,
                        // immediately.
                        //
                    } while (Error == WSAECONNRESET);
                    if (Error) {
                        ACQUIRE_LOCK(Interfacep);
                        DnsDeferReadInterface(Interfacep, Bufferp->Socket);
                        RELEASE_LOCK(Interfacep);
                        DNS_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                        NhReleaseBuffer(Bufferp);
                    }
                }
            }

            break;
        }

        //
        // Now see if the interface is operational
        //

        ACQUIRE_LOCK(Interfacep);
        if (!DNS_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "DnsReadCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        }
        RELEASE_LOCK(Interfacep);

        //
        // Now look at the message
        //

        Headerp = (PDNS_HEADER)Bufferp->Buffer;

        if (Headerp->IsResponse == DNS_MESSAGE_QUERY) {
            DnsProcessQueryMessage(
                Interfacep,
                Bufferp
                );
        } else {
            DnsProcessResponseMessage(
                Interfacep,
                Bufferp
                );
        }

    } while(FALSE);

    DNS_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_DNS();

} // DnsReadCompletionRoutine


VOID
DnsWriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a datagram socket bound to the DNS server UDP port.

    The write-context for all writes is a 'DNS_QUERY'. Our handling
    is dependent on whether the message written was a query or a response.

    Upon completion of a query, we may need to do a resend if there was
    an error. Upon completion of a response, we delete the query-record.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the datagram socket

Return Value:

    none.

Environment:

    Runs in the context of an RTUTILS.DLL worker-thread which has just
    dequeued an I/O completion packet from the common I/O completion port
    with which our datagram sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadDatagramSocket'.

--*/

{
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_INTERFACE Interfacep;
    USHORT QueryId;
    PDNS_QUERY Queryp;
    PULONG Server;

    PROFILE("DnsWriteCompletionRoutine");

    Interfacep = (PDNS_INTERFACE)Bufferp->Context;
    QueryId = (USHORT)Bufferp->Context2;
    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    ACQUIRE_LOCK(Interfacep);

    //
    // Obtain the query associated with the send.
    //

    Queryp = DnsMapResponseToQuery(Interfacep, QueryId);

    if (Headerp->IsResponse == DNS_MESSAGE_RESPONSE) {

        if (ErrorCode) {

            //
            // An error occurred sending the message to the client
            //

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: error %d response %d interface %d",
                ErrorCode,
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                ErrorCode,
                "%I",
                NhQueryAddressSocket(Bufferp->Socket)
                );

        } else if (Queryp && Headerp->ResponseCode == DNS_RCODE_NOERROR) {

            //
            // We're done with this query since it succeeded; remove it.
            //

            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: removing query %d interface %d",
                Queryp->QueryId,
                Interfacep->Index
                );

            DnsDeleteQuery(Interfacep, Queryp);
        }
    } else {

        if (!ErrorCode) {
    
            //
            // No errors, so just return.
            //
    
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: sent query %d interface %d",
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
        } else {
    
            //
            // The query just went out and it failed.
            //
    
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsWriteCompletionRoutine: error %d for query %d interface %d",
                ErrorCode,
                Queryp ? Queryp->QueryId : -1,
                Interfacep->Index
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_QUERY_FAILED,
                ErrorCode,
                "%I%I%I",
                Queryp ? Queryp->SourceAddress : -1,
                Bufferp->WriteAddress.sin_addr.s_addr,
                NhQueryAddressSocket(Bufferp->Socket)
                );
        }
    }

    RELEASE_LOCK(Interfacep);
    DNS_DEREFERENCE_INTERFACE(Interfacep);
    NhReleaseBuffer(Bufferp);
    DEREFERENCE_DNS();

} // DnsWriteCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsmsg.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsmsg.h

Abstract:

    This module contains declarations related to the DNS proxy's
    message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            17-Nov-2000
    Cleanup

--*/

#ifndef _NATHLP_DNSMSG_H_
#define _NATHLP_DNSMSG_H_

//
// DNS message format, opcodes and response codes in sdk\inc\windns.h
//

//
// DNS message types
//

#define DNS_MESSAGE_QUERY           0
#define DNS_MESSAGE_RESPONSE        1


VOID
DnsProcessQueryMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

VOID
DnsProcessResponseMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_DNSMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnslookup.cpp ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    dnslookup.c

Abstract:

    This module contains code for the DNS component's name-lookup mechanism.

Author:

    Tom Brown (tbrown)      10/21/99

Revision History:

    Raghu Gatta (rgatta)    21-Oct-2000
    Rewrite + Cleanup + New Functions

--*/

#include "precomp.h"
#pragma hdrstop

#define DNS_HOMENET_DOT         L"."

ULONG               g_PrivateIPAddr = 0;
CRITICAL_SECTION    DnsTableLock;   // protects both tables
RTL_GENERIC_TABLE   g_DnsTable,
                    g_ReverseDnsTable;


//
// FORWARD DECLARATIONS
//

ULONG
DhcpGetPrivateInterfaceAddress(
    VOID
    );


RTL_GENERIC_COMPARE_RESULTS 
TableNameCompareRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine Description:

    This is a callback routine to compare two DNS_ENTRY structures.
    It is used by the RTL table implementation.

Arguments:

    Table - pointer to the RTL table. Not used.

    FirstStruct - the first DNS_ENTRY structure

    SecondStruct - the second DNS_ENTRY structure

Return Value:

    One of GenericLessThan, GenericGreaterThan, or GenericEqual,
    depending on the relative values of the parameters.

Environment:

    Called back by the Rtl table lookup routines.

--*/

{
    INT     iCompareResults;
    BOOL    fNamesAreEqual;
    WCHAR   *pszFirstName, *pszSecondName;

    PROFILE("TableNameCompareRoutine");

    pszFirstName = ((PDNS_ENTRY)FirstStruct)->pszName;
    pszSecondName = ((PDNS_ENTRY)SecondStruct)->pszName;

    fNamesAreEqual = DnsNameCompare_W(pszFirstName, pszSecondName);

    if (fNamesAreEqual)
    {
        iCompareResults = 0;
    }
    else
    {
        iCompareResults = _wcsicmp(pszFirstName, pszSecondName);
    }

    if (iCompareResults < 0)
    {
        return GenericLessThan;
    }
    else if (iCompareResults > 0)
    {
        return GenericGreaterThan;
    }
    else
    {
        return GenericEqual;
    }
}

RTL_GENERIC_COMPARE_RESULTS 
TableAddressCompareRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
/*++

Routine Description:

    This is a callback routine to compare two REVERSE_DNS_ENTRY structures.
    It is used by the RTL table implementation.

Arguments:

    Table - pointer to the RTL table. Not used.

    FirstStruct - the first REVERSE_DNS_ENTRY structure

    SecondStruct - the second REVERSE_DNS_ENTRY structure

Return Value:

    One of GenericLessThan, GenericGreaterThan, or GenericEqual,
    depending on the relative values of the parameters.

Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    DNS_ADDRESS Address1, Address2;

    PROFILE("TableAddressCompareRoutine");

    Address1 = ((PREVERSE_DNS_ENTRY)FirstStruct)->ulAddress;
    Address2 = ((PREVERSE_DNS_ENTRY)SecondStruct)->ulAddress;

    if (Address1 > Address2)
    {
        return GenericGreaterThan;
    }
    else if (Address1 < Address2)
    {
        return GenericLessThan;
    }
    else
    {
        return GenericEqual;
    }
}


PVOID
TableAllocateRoutine(
    PRTL_GENERIC_TABLE Table,
    CLONG ByteSize
    )
/*++

Routine Description:

    This is a callback routine to allocate memory for an Rtl table.

Arguments:

    Table - pointer to the RTL table. Not used.

    ByteSize - the number of bytes to allocate

    SecondStruct - the second DNS_ENTRY structure

Return Value:

    A pointer to the allocated memory.

Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    return NH_ALLOCATE(ByteSize);
}

VOID
TableFreeRoutine(
    PRTL_GENERIC_TABLE Table,
    PVOID pBuffer
    )
/*++

Routine Description:

    This is a callback routine to free memory allocated by TableAllocateRoutine.

Arguments:

    Table - pointer to the RTL table. Not used.

    pBuffer - pointer to the buffer to free

Return Value:

    None
    
Environment:

    Called back by the Rtl table lookup routines.

--*/
{
    NH_FREE(pBuffer);
}



ULONG
DnsInitializeTableManagement(
    VOID
    )
/*++

Routine Description:

    This is a public function that must be called before any of the other Dns
    table functions. It initializes the various tables used by the server.

Arguments:

    None

Return Value:

    None
    
Environment:

    Arbitrary.

--*/
{
    ULONG Error = NO_ERROR;

    PROFILE("DnsInitializeTableManagement");

    __try {
        InitializeCriticalSection(&DnsTableLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsInitializeTableManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    RtlInitializeGenericTable(
        &g_DnsTable,
        TableNameCompareRoutine,
        TableAllocateRoutine,
        TableFreeRoutine,
        NULL
        );

    RtlInitializeGenericTable(
        &g_ReverseDnsTable,
        TableAddressCompareRoutine,
        TableAllocateRoutine,
        TableFreeRoutine,
        NULL
        );

    return Error;
} // DnsInitializeTableManagement



VOID
DnsShutdownTableManagement(
    VOID
    )
/*++

Routine Description:

    This routine is called to shutdown the table management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/
{
    PROFILE("DnsShutdownTableManagement");

    DnsEmptyTables();

    DeleteCriticalSection(&DnsTableLock);

} // DnsShutdownTableManagement



VOID
DnsEmptyTables(
    VOID
    )
/*++

Routine Description:

    This routine is called to empty the DNS tables.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context.

--*/
{
    ULONG               i, count;
    PDNS_ENTRY          pDnsEntry;
    REVERSE_DNS_ENTRY   reverseEntry;
    PREVERSE_DNS_ENTRY  pRDnsEntry;
    WCHAR              *pszNameCopy;
    
    PROFILE("DnsEmptyTables");

    //
    // for each entry in the forward table, delete all the entries in the
    // reverse table
    //

    //
    // emptying table in LIFO order
    //

    EnterCriticalSection(&DnsTableLock);

    count = RtlNumberGenericTableElements(&g_DnsTable);

    while (count)
    {
        pDnsEntry = (PDNS_ENTRY) RtlGetElementGenericTable(
                                     &g_DnsTable,
                                     --count
                                     );

        reverseEntry.pszName = NULL;

        for (i = 0; i < pDnsEntry->cAddresses; i++)
        {
            reverseEntry.ulAddress = pDnsEntry->aAddressInfo[i].ulAddress;
            RtlDeleteElementGenericTable(
                &g_ReverseDnsTable,
                &reverseEntry
                );
        }

        pszNameCopy = pDnsEntry->pszName;

        NH_FREE(pDnsEntry->aAddressInfo);
        pDnsEntry->aAddressInfo = NULL;
    
        RtlDeleteElementGenericTable(
            &g_DnsTable,
            pDnsEntry
            );

        NH_FREE(pszNameCopy);
    }
    
    //
    // the forward table should be empty by now
    //

    ASSERT(RtlIsGenericTableEmpty(&g_DnsTable));

    //
    // ensure that the reverse table is also empty
    //

    count = RtlNumberGenericTableElements(&g_ReverseDnsTable);

    while (count)
    {
        pRDnsEntry = (PREVERSE_DNS_ENTRY) RtlGetElementGenericTable(
                                              &g_ReverseDnsTable,
                                              --count
                                              );

        RtlDeleteElementGenericTable(
            &g_ReverseDnsTable,
            pRDnsEntry
            );
    }

    LeaveCriticalSection(&DnsTableLock);

} // DnsEmptyTables



BOOL
DnsRegisterName(
    WCHAR *pszName,
    UINT cAddresses,
    ADDRESS_INFO aAddressInfo[]
    )
/*++

Routine Description:

    Public function to register a DNS name in the server's table.

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    cAddresses - Number of addresses associated with this name

    aAddressInfo - Array of address information (addresses in network order)

Return Value:

    TRUE if the registration was for a new name (the name did not already exist
    in the table); FALSE if the name already existed and was replaced.
    FALSE also if there was an error condition.
    
Environment:

    Arbitrary

--*/
{
    DNS_ENTRY           dnsEntry;
    DWORD               cAddressesAllocated = 0;
    REVERSE_DNS_ENTRY   reverseDnsEntry;
    BOOLEAN             fNewElement = TRUE,
                        fNameIsNew = FALSE;
    UINT                i;
    
    PROFILE("DnsRegisterName");

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsRegisterName: Registering name %S, with %d addresses",
        pszName,
        cAddresses
        );

    for (i = 0; i < cAddresses; i++)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsRegisterName: Address %d = %lx",
            i,
            aAddressInfo[i].ulAddress
            );
    }
    
    dnsEntry.pszName = (PWCHAR) NH_ALLOCATE((wcslen(pszName) + 1) * sizeof(WCHAR));

    if (!dnsEntry.pszName)
    {
        return fNameIsNew; // currently set to FALSE
    }
    
    wcscpy(dnsEntry.pszName, pszName);

    if (cAddresses == 1)
    {
        // In general, all names will have one address; so if we're just registering
        // one name, then only allocate enough space for one name.
        cAddressesAllocated = 1;
    }
    else
    {
        // If we have more than one address, then allocate in increments of 5.
        cAddressesAllocated = ((cAddresses + 4) / 5) * 5;
    }

    dnsEntry.aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(cAddressesAllocated * sizeof(ADDRESS_INFO));

    if (!dnsEntry.aAddressInfo)
    {
        NH_FREE(dnsEntry.pszName);
        return fNameIsNew; // currently set to FALSE
    }

    memcpy(dnsEntry.aAddressInfo, aAddressInfo, cAddresses * sizeof(ADDRESS_INFO));

    dnsEntry.cAddresses = cAddresses;
    dnsEntry.cAddressesAllocated = cAddressesAllocated;

    EnterCriticalSection(&DnsTableLock);

    RtlInsertElementGenericTable(
        &g_DnsTable,
        &dnsEntry,
        sizeof(dnsEntry),
        &fNameIsNew
        );

    reverseDnsEntry.pszName = dnsEntry.pszName;
    for (i = 0; i < cAddresses; i++)
    {
        PREVERSE_DNS_ENTRY  pEntry;

        reverseDnsEntry.ulAddress = dnsEntry.aAddressInfo[i].ulAddress;
        pEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                          &g_ReverseDnsTable,
                                          &reverseDnsEntry,
                                          sizeof(reverseDnsEntry),
                                          &fNewElement
                                          );
        // If this IP address is already in the reverse table, then replace it.
        if (!fNewElement)
        {
            pEntry->pszName = dnsEntry.pszName;
        }
    }

    LeaveCriticalSection(&DnsTableLock);

    if (!fNewElement)
    {
        DnsCleanupTables();
    }

    return fNameIsNew;
} // DnsRegisterName



VOID
DnsAddAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress,
    FILETIME    ftExpires
    )
/*++

Routine Description:

    Public function to add an IP address for a name that potentially
    already exists.

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    ulAddress - New IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY  pEntry;

    PROFILE("DnsAddAddressForName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry == NULL)
    {
        ADDRESS_INFO    info;

        info.ulAddress = ulAddress;
        info.ftExpires = ftExpires;
        //info.ulExpires = ulExpires;
        DnsRegisterName(pszName, 1, &info);
    }
    else
    {
        UINT     i;
        REVERSE_DNS_ENTRY   reverseDnsEntry;
        PREVERSE_DNS_ENTRY  pReverseEntry;
        BOOLEAN             fNewElement;
        
        // first, let's make sure that this IP address isn't already associated with
        // this name.

        for (i = 0; i < pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                //
                // simply update the expiry time
                //
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsAddAddressForName: Refresh expiry time for %S",
                    pszName
                    );
                pEntry->aAddressInfo[i].ftExpires = ftExpires;
                return; 
            }
        }

        //
        // we limit the number of addresses per machine name to one only
        //
        
        //
        // guard against zero allocation
        //
        if (!pEntry->cAddressesAllocated)
        {
            pEntry->aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(1 * sizeof(ADDRESS_INFO));

            if (pEntry->aAddressInfo)
            {
                pEntry->cAddressesAllocated = 1;
            }
            else
            {
                // no memory - return quitely
                return;
            }
        }

        //
        // at least 1 block has been allocated
        //
        pEntry->cAddresses = 1;
        pEntry->aAddressInfo[0].ulAddress = ulAddress;
        pEntry->aAddressInfo[0].ftExpires = ftExpires;

        
        reverseDnsEntry.ulAddress = ulAddress;
        reverseDnsEntry.pszName = pEntry->pszName;

        EnterCriticalSection(&DnsTableLock);
        
        pReverseEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &reverseDnsEntry,
                                                 sizeof(reverseDnsEntry),
                                                 &fNewElement
                                                 );
        // If this IP address is already in the reverse table, then replace it.
        if (!fNewElement)
        {
            pReverseEntry->pszName = pEntry->pszName;
        }

        LeaveCriticalSection(&DnsTableLock);

        if (!fNewElement)
        {
            DnsCleanupTables();
        }
    }
} // DnsAddAddressForName



VOID
DnsDeleteAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to un-associate an IP address from a given name,
    and potentially delete the record from the table if there are no more
    IP addresses associated with the name.

Arguments:

    pszName - Name, in Unicode, dotted-name format.

    ulAddress - IP address to un-associate with the given name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY  pEntry;
    REVERSE_DNS_ENTRY   reverseEntry;

    PROFILE("DnsDeleteAddressForName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry != NULL)
    {
        INT i, iLocation = -1;

        // Find the index of the requested address
        for (i = 0; i < (INT)pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                iLocation = i;
                break;
            }
        }

        if (iLocation > -1)
        {
            if (pEntry->cAddresses > 1)
            {
                // Move the rest of the array backwards
                memcpy(&pEntry->aAddressInfo[iLocation], 
                        &pEntry->aAddressInfo[iLocation + 1],
                        (pEntry->cAddresses - 1 - iLocation) * sizeof(ADDRESS_INFO));
                pEntry->cAddresses--;
            }
            else
            {
                // Delete the whole entry - it no longer has any IP addresses associated
                // with it.
                DnsDeleteName(pszName);
            }
        }
    }

    reverseEntry.pszName = NULL;
    reverseEntry.ulAddress = ulAddress;

    EnterCriticalSection(&DnsTableLock);

    RtlDeleteElementGenericTable(
        &g_ReverseDnsTable,
        &reverseEntry
        );

    LeaveCriticalSection(&DnsTableLock);
} // DnsDeleteAddressForName



PDNS_ENTRY
DnsPurgeExpiredNames(
    PDNS_ENTRY pEntry
    )
/*++

Routine Description:

    TODO.

Arguments:

    TODO
    
Return Value:

    TODO
    

Environment:

    TODO.

--*/
{
    UINT i, j;
    FILETIME ftTime;
    REVERSE_DNS_ENTRY  reverseEntry;

    PROFILE("DnsPurgeExpiredNames");

    GetSystemTimeAsFileTime(&ftTime);
    reverseEntry.pszName = NULL;

    for (j = 1; j < pEntry->cAddresses + 1; j++)
    {
        // j is 1-based so that we can safely subtract 1 from it below (it's unsigned).
        // we really want the 0-based number, so we translate that to i immediately.
        
        i = j - 1;
        if (IsFileTimeExpired(&pEntry->aAddressInfo[i].ftExpires))
        {
            NhTrace(TRACE_FLAG_DNS, "DnsPurgeExpiredNames: Deleting address %lx for name %ls",
                        pEntry->aAddressInfo[i].ulAddress,
                        pEntry->pszName);
            reverseEntry.ulAddress = pEntry->aAddressInfo[i].ulAddress;
            RtlDeleteElementGenericTable(
                &g_ReverseDnsTable,
                &reverseEntry
                );
            
            memcpy(&pEntry->aAddressInfo[i], &pEntry->aAddressInfo[i+1],
                    (pEntry->cAddresses - i - 1) * sizeof(ADDRESS_INFO));
            pEntry->cAddresses--;
            j--;
        }
    }

    if (pEntry->cAddresses == 0)
    {
        WCHAR   *pszName;

        pszName = pEntry->pszName;
        NH_FREE(pEntry->aAddressInfo);
        pEntry->aAddressInfo = NULL;
        
        RtlDeleteElementGenericTable(
            &g_DnsTable,
            pEntry
            );

        NH_FREE(pszName);

        pEntry = NULL;
    }

    return pEntry;
} // DnsPurgeExpiredNames



PDNS_ENTRY
DnsLookupAddress(
    WCHAR *pszName
    )
/*++

Routine Description:

    Public function to look up the address of a given name.

Arguments:

    pszName - Name to look up, in Unicode, dotted name format.

Return Value:

    A pointer to the DNS_ENTRY value that is in the table. Note that 
    this is not a copy, so a) it should not be freed by the caller, and
    b) any modifications made to the data will be reflected in the table.

    If the name is not found, the function will return NULL.

    Addresses are stored in network order.

Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY      pEntry;
    DNS_ENTRY       dnsSearch;

    PROFILE("DnsLookupAddress");

    dnsSearch.pszName = pszName;
    dnsSearch.cAddresses = 0;

    EnterCriticalSection(&DnsTableLock);

    pEntry = (PDNS_ENTRY) RtlLookupElementGenericTable(
                              &g_DnsTable,
                              &dnsSearch
                              );

    if (pEntry)
    {
        pEntry = DnsPurgeExpiredNames(pEntry);
    }

    LeaveCriticalSection(&DnsTableLock);

    return pEntry;
} // DnsLookupAddress



PREVERSE_DNS_ENTRY
DnsLookupName(
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to look up the name of a given address.

Arguments:

    ulAddress - network order address.

Return Value:

    A pointer to the REVERSE_DNS_ENTRY value that is in the table. Note that 
    this is not a copy, so a) it should not be freed by the caller, and
    b) any modifications made to the data will be reflected in the table.

    If the address is not found, the function will return NULL.

Environment:

    Arbitrary.

--*/
{
    PREVERSE_DNS_ENTRY  pEntry;
    REVERSE_DNS_ENTRY   dnsSearch;

    PROFILE("DnsLookupName");

    dnsSearch.ulAddress = ulAddress;
    dnsSearch.pszName = NULL;

    EnterCriticalSection(&DnsTableLock);

    pEntry = (PREVERSE_DNS_ENTRY) RtlLookupElementGenericTable(
                                      &g_ReverseDnsTable,
                                      &dnsSearch
                                      );

    LeaveCriticalSection(&DnsTableLock);

    return pEntry;
} // DnsLookupName



VOID
DnsDeleteName(
    WCHAR *pszName
    )
/*++

Routine Description:

    Public function to delete a given name from the DNS table.

Arguments:

    pszName - Name to delete.

Return Value:

    None.

Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY          pEntry;
    REVERSE_DNS_ENTRY   reverseEntry;
    UINT                i;
    WCHAR               *pszNameCopy;

    PROFILE("DnsDeleteName");

    pEntry = DnsLookupAddress(pszName);

    reverseEntry.pszName = NULL;

    EnterCriticalSection(&DnsTableLock);

    for (i = 0; i < pEntry->cAddresses; i++)
    {
        reverseEntry.ulAddress = pEntry->aAddressInfo[i].ulAddress;
        RtlDeleteElementGenericTable(
            &g_ReverseDnsTable,
            &reverseEntry
            );
    }

    pszNameCopy = pEntry->pszName;
    NH_FREE(pEntry->aAddressInfo);
    pEntry->aAddressInfo = NULL;
    
    RtlDeleteElementGenericTable(
        &g_DnsTable,
        pEntry
        );

    LeaveCriticalSection(&DnsTableLock);

    NH_FREE(pszNameCopy);
} // DnsDeleteName



VOID
DnsUpdateName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    )
/*++

Routine Description:

    Public function to add an IP address for a name that potentially
    already exists. If both name and address exist, we update the time
    in the table for a fresh lease

Arguments:

    pszName - Name to register, in Unicode, dotted-name format.

    ulAddress - (possibly new) IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PDNS_ENTRY      pEntry;
    FILETIME        ftExpires;
    LARGE_INTEGER   liExpires, liTime, liNow;
    BOOL            fWriteToStore = FALSE;
    BOOLEAN         fNewElement = TRUE; // refers to reverse table entry

    GetSystemTimeAsFileTime(&ftExpires);    // current UTC time
    memcpy(&liNow, &ftExpires, sizeof(LARGE_INTEGER));
    //
    // current cache table expiry time is fixed - put in registry afterwards
    //
    liTime = RtlEnlargedIntegerMultiply(CACHE_ENTRY_EXPIRY, SYSTIME_UNITS_IN_1_SEC);
    liExpires = RtlLargeIntegerAdd(liTime, liNow);;
    memcpy(&ftExpires, &liExpires, sizeof(LARGE_INTEGER));

    PROFILE("DnsUpdateName");

    pEntry = DnsLookupAddress(pszName);
    if (pEntry == NULL)
    {
        ADDRESS_INFO    info;

        info.ulAddress = ulAddress;
        info.ftExpires = ftExpires;
        DnsRegisterName(pszName, 1, &info);

        fWriteToStore = TRUE;
    }
    else
    {
        UINT     i;
        REVERSE_DNS_ENTRY   reverseDnsEntry;
        PREVERSE_DNS_ENTRY  pReverseEntry;
        
        // first, let's make sure that this IP address isn't already associated with
        // this name.

        for (i = 0; i < pEntry->cAddresses; i++)
        {
            if (pEntry->aAddressInfo[i].ulAddress == ulAddress)
            {
                //
                // simply update the expiry time
                //
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdateName: Refresh expiry time for %S",
                    pszName
                    );
                pEntry->aAddressInfo[i].ftExpires = ftExpires;
                return;
            }
        }

        //
        // we limit the number of addresses per machine name to one only
        //

        //
        // guard against zero allocation
        //
        if (!pEntry->cAddressesAllocated)
        {
            pEntry->aAddressInfo = (PADDRESS_INFO) NH_ALLOCATE(1 * sizeof(ADDRESS_INFO));

            if (pEntry->aAddressInfo)
            {
                pEntry->cAddressesAllocated = 1;
            }
            else
            {
                // no memory - return quitely
                return;
            }
        }

        //
        // at least 1 block has been allocated
        //
        pEntry->cAddresses = 1;
        pEntry->aAddressInfo[0].ulAddress = ulAddress;
        pEntry->aAddressInfo[0].ftExpires = ftExpires;
        
        reverseDnsEntry.ulAddress = ulAddress;
        reverseDnsEntry.pszName = pEntry->pszName;

        EnterCriticalSection(&DnsTableLock);
        
        pReverseEntry = (PREVERSE_DNS_ENTRY) RtlInsertElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &reverseDnsEntry,
                                                 sizeof(reverseDnsEntry),
                                                 &fNewElement
                                                 );
        // If this IP address is already in the reverse table, then replace it.
        if (!fNewElement)
        {
            pReverseEntry->pszName = pEntry->pszName;
        }

        LeaveCriticalSection(&DnsTableLock);

        if (!fNewElement)
        {
            DnsCleanupTables();
        }

        fWriteToStore = TRUE;
    }

    if (fWriteToStore)
    {
        SaveHostsIcsFile(FALSE);
    }
} // DnsUpdateName



VOID
DnsUpdate(
    CHAR *pName,
    ULONG len,
    ULONG ulAddress
    )
/*++

Routine Description:

    Called from the DHCP component to simulate Dynamic DNS.

Arguments:

    pName - hostname to register, in wire format.

    len - length of hostname

    ulAddress - (possibly new) IP address to associate with this name,
                in network order

Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PROFILE("DnsUpdate");

    //
    // convert string to a Unicode string and update table
    //

    DWORD  dwSize = 0;
    DWORD  Error = NO_ERROR;
    LPVOID lpMsgBuf = NULL;
    LPBYTE pszName = NULL;
    PWCHAR pszUnicodeFQDN = NULL;

    if (NULL == pName || 0 == len || '\0' == *pName)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsUpdate: No Name present - discard DNS Update"
            );
        return;
    }

    do
    {
        EnterCriticalSection(&DnsGlobalInfoLock);

        if (!DnsICSDomainSuffix)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: DnsICSDomainSuffix string not present - update failed!"
                );
            break;
        }

        //
        // create a null terminated copy
        //
        dwSize = len + 4;
        pszName = reinterpret_cast<LPBYTE>(NH_ALLOCATE(dwSize));
        if (!pszName)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: allocation failed for hostname copy buffer"
                );
            break;
        }
        ZeroMemory(pszName, dwSize);
        memcpy(pszName, pName, len);
        pszName[len] = '\0';

        //
        // NOTE: the RFCs are unclear about how to handle hostname option.
        // try out different codepage conversions to unicode in order of:
        // OEM, ANSI, MAC and finally give UTF8 a try
        // our default conversion is to use mbstowcs()
        //

        //
        // try OEM to Unicode conversion
        //
        Error = DnsConvertHostNametoUnicode(
                    CP_OEMCP,
                    (PCHAR)pszName,
                    DnsICSDomainSuffix,
                    &pszUnicodeFQDN
                    );
        if (Error)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsUpdate: DnsConvertHostName(OEM)toUnicode failed with "
                "Error %ld (0x%08x)",
                Error,
                Error
                );

            if (pszUnicodeFQDN)
            {
                NH_FREE(pszUnicodeFQDN);
                pszUnicodeFQDN = NULL;
            }
        }

        //
        // try ANSI to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_ACP,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(ANSI)toUnicode failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }

        //
        // try MAC to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_MACCP,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(MAC)toUnicode() failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }
        
        //
        // try UTF8 to Unicode conversion
        //
        if (!pszUnicodeFQDN)
        {
            Error = DnsConvertHostNametoUnicode(
                        CP_UTF8,
                        (PCHAR)pszName,
                        DnsICSDomainSuffix,
                        &pszUnicodeFQDN
                        );
            if (Error)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: DnsConvertHostName(UTF8)toUnicode() failed with "
                    "Error %ld (0x%08x)",
                    Error,
                    Error
                    );

                if (pszUnicodeFQDN)
                {
                    NH_FREE(pszUnicodeFQDN);
                    pszUnicodeFQDN = NULL;
                }
            }
        }
        
        //
        // default conversion
        //
        if (!pszUnicodeFQDN)
        {
            dwSize = len                        +
                     wcslen(DNS_HOMENET_DOT)    +
                     wcslen(DnsICSDomainSuffix) +
                     1;
            pszUnicodeFQDN = reinterpret_cast<PWCHAR>(NH_ALLOCATE(sizeof(WCHAR) * dwSize));
            if (!pszUnicodeFQDN)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsUpdate: allocation failed for client name"
                    );
                break;
            }
            ZeroMemory(pszUnicodeFQDN, (sizeof(WCHAR) * dwSize));

            mbstowcs(pszUnicodeFQDN, (char *)pszName, len);
            wcscat(pszUnicodeFQDN, DNS_HOMENET_DOT);    // add the dot
            wcscat(pszUnicodeFQDN, DnsICSDomainSuffix); // add the suffix
        }

        LeaveCriticalSection(&DnsGlobalInfoLock);

        DnsUpdateName(
            pszUnicodeFQDN,
            ulAddress
            );

        NH_FREE(pszName);
        NH_FREE(pszUnicodeFQDN);
        return;

    } while (FALSE);

    LeaveCriticalSection(&DnsGlobalInfoLock);

    if (pszName)
    {
        NH_FREE(pszName);
    }

    if (pszUnicodeFQDN)
    {
        NH_FREE(pszUnicodeFQDN);
    }
    
    return;
} // DnsUpdate



VOID
DnsAddSelf(
    VOID
    )
/*++

Routine Description:

    Called each time we do a load of the hosts.ics file

Arguments:

    none.
    
Return Value:

    None.
    
Environment:

    Arbitrary

--*/
{
    PROFILE("DnsAddSelf");

    DWORD           len = 512, dwSize = 0;
    WCHAR           pszCompNameBuf[512];
    PWCHAR          pszBuf = NULL;
    LPVOID          lpMsgBuf;
    ULONG           ulAddress = 0;
    FILETIME        ftExpires;
    LARGE_INTEGER   liExpires, liTime, liNow;
    
    ZeroMemory(pszCompNameBuf, (sizeof(WCHAR) * len));

    if (!GetComputerNameExW(
            ComputerNameDnsHostname,//ComputerNameNetBIOS,
            pszCompNameBuf,
            &len
            )
       )
    {
        lpMsgBuf = NULL;
        
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM |
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            GetLastError(),
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR) &lpMsgBuf,
            0,
            NULL
            );
            
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsAddSelf: GetComputerNameExW failed with message: %S",
            lpMsgBuf
            );
        
        if (lpMsgBuf) LocalFree(lpMsgBuf);
    }
    else
    {
        //
        // we query the DHCP component if it is active for an IP address
        // because it has scope information also. if this fails, we revert
        // to the DNS component's list of interface addresses
        //
        
        //
        // check if DHCP component is active
        //
        if (REFERENCE_DHCP())
        {
            ulAddress = DhcpGetPrivateInterfaceAddress();

            DEREFERENCE_DHCP();
        }

        if (!ulAddress)
        {
            ulAddress = DnsGetPrivateInterfaceAddress();
        }

        if (!ulAddress)
        {
            //
            // could not retreive correct IP address - use cached address
            //
            ulAddress = g_PrivateIPAddr;
        }
        else
        {
            //
            // got some valid address
            //
            g_PrivateIPAddr = ulAddress;
        }
    
        if (ulAddress)
        {
            if (DnsICSDomainSuffix)
            {
                EnterCriticalSection(&DnsGlobalInfoLock);

                dwSize = len                        +
                         wcslen(DNS_HOMENET_DOT)    +
                         wcslen(DnsICSDomainSuffix) +
                         1;

                pszBuf = reinterpret_cast<PWCHAR>(
                             NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                             );

                if (!pszBuf)
                {
                    LeaveCriticalSection(&DnsGlobalInfoLock);
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsAddSelf: allocation failed for client name"
                        );

                    return;
                }

                ZeroMemory(pszBuf, (sizeof(WCHAR) * dwSize));

                wcscpy(pszBuf, pszCompNameBuf);     // copy the name
                wcscat(pszBuf, DNS_HOMENET_DOT);    // add the dot
                wcscat(pszBuf, DnsICSDomainSuffix); // add the suffix

                LeaveCriticalSection(&DnsGlobalInfoLock);

                GetSystemTimeAsFileTime(&ftExpires);    // current UTC time
                memcpy(&liNow, &ftExpires, sizeof(LARGE_INTEGER));
                liTime = RtlEnlargedIntegerMultiply((5 * 365 * 24 * 60 * 60), SYSTIME_UNITS_IN_1_SEC);
                liExpires = RtlLargeIntegerAdd(liTime, liNow);;
                memcpy(&ftExpires, &liExpires, sizeof(LARGE_INTEGER));

                DnsAddAddressForName(
                    pszBuf,
                    ulAddress,
                    ftExpires
                    );

                NH_FREE(pszBuf);
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsAddSelf: DnsICSDomainSuffix string not present - update failed!"
                    );
            }
        }
    }

    return;
} // DnsAddSelf



VOID
DnsCleanupTables(
    VOID
    )
/*++

Routine Description:

    Called each time we detect that there could be atleast one entry with
    an IP address not belonging to it anymore.

Arguments:

    none.
    
Return Value:

    None.
    
Environment:

    Arbitrary.

--*/
{
    PDNS_ENTRY          pFwdEntry;
    PREVERSE_DNS_ENTRY  pRevEntry;
    DNS_ENTRY           dnsFwdSearch;
    REVERSE_DNS_ENTRY   dnsRevSearch;
    BOOL                fDelEntry;
    UINT                i;
    PWCHAR              *GCArray = NULL;
    DWORD               GCCount  = 0,
                        GCSize   = 0;

    

    //
    // Enumerate through the forward DNS table - if the IP address(es)
    // for each forward entry have an entry in the reverse DNS table
    // and this reverse entry's name pointer does not point to us, then
    // delete this IP address from this forward entry
    //
    EnterCriticalSection(&DnsTableLock);

    pFwdEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, TRUE);

    while (pFwdEntry != NULL)
    {

        for (i = 0; i < pFwdEntry->cAddresses; i++)
        {
            pRevEntry = NULL;

            dnsRevSearch.ulAddress = pFwdEntry->aAddressInfo[i].ulAddress;
            dnsRevSearch.pszName = NULL;

            pRevEntry = (PREVERSE_DNS_ENTRY) RtlLookupElementGenericTable(
                                                 &g_ReverseDnsTable,
                                                 &dnsRevSearch
                                                 );
            if ((!pRevEntry) ||
                ((pRevEntry) && 
                 (pRevEntry->pszName != pFwdEntry->pszName)))
            {
                //
                // Remove this IP address from the forward entry address list
                //
                if (pFwdEntry->cAddresses > 1)
                {
                    memcpy(&pFwdEntry->aAddressInfo[i], 
                           &pFwdEntry->aAddressInfo[i + 1],
                          (pFwdEntry->cAddresses - 1 - i) * sizeof(ADDRESS_INFO));
                    pFwdEntry->cAddresses--;
                }
                else
                {
                    //
                    // Single "invalid" IP address - zero the count
                    //
                    pFwdEntry->cAddresses = 0;
                    NH_FREE(pFwdEntry->aAddressInfo);
                    pFwdEntry->aAddressInfo = NULL;
                    break;
                }
            }
        }

        if (0 == pFwdEntry->cAddresses)
        {
            //
            // Remember this entry name
            //
            if (GCSize <= GCCount)
            {
                PWCHAR *tmpGCArray = NULL;
                DWORD   tmpGCSize = 0;

                // Allocate in increments of five
                tmpGCSize = ((GCCount + 5) / 5) * 5;
                tmpGCArray = (PWCHAR *) NH_ALLOCATE(tmpGCSize * sizeof(PWCHAR));

                if (tmpGCArray)
                {
                    if (GCArray)
                    {
                        memcpy(tmpGCArray, GCArray, (GCCount * sizeof(PWCHAR)));

                        NH_FREE(GCArray);
                    }

                    GCSize = tmpGCSize;
                    GCArray = tmpGCArray;

                    //
                    // add it to our array
                    //
                    GCArray[GCCount++] = pFwdEntry->pszName;
                }
            }
            else
            {
                //
                // add it to our array
                //
                GCArray[GCCount++] = pFwdEntry->pszName;
            }
        }

        pFwdEntry = (PDNS_ENTRY) RtlEnumerateGenericTable(&g_DnsTable, FALSE);

    }

    //
    // Garbage collect after complete enumeration
    //
    for (i = 0; i < GCCount; i++)
    {
        dnsFwdSearch.pszName = GCArray[i];
        dnsFwdSearch.cAddresses = 0;

        pFwdEntry = (PDNS_ENTRY) RtlLookupElementGenericTable(
                                  &g_DnsTable,
                                  &dnsFwdSearch
                                  );

        if (pFwdEntry)
        {
            //
            // (1) we have a copy of pointer to name as in GCArray[i]
            // (2) aAddressInfo has already been taken care of above
            // (3) only need to get rid of FwdEntry struct from table
            //
            RtlDeleteElementGenericTable(
                &g_DnsTable,
                pFwdEntry
                );

            //
            // done after the fwd entry was deleted from fwd DNS table
            //
            NH_FREE(GCArray[i]);
        }
        GCArray[i] = NULL;
    }

    LeaveCriticalSection(&DnsTableLock);

    if (GCArray)
    {
        NH_FREE(GCArray);
    }

    return;
} // DnsCleanupTables


//
// Utility conversion routines
//

DWORD
DnsConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pszHostName,
    PWCHAR DnsICSDomainSuffix,
    PWCHAR *ppszUnicodeFQDN
    )
{

    PROFILE("DnsConvertHostNametoUnicode");

    //
    // make sure to free the returned UnicodeFQDN
    // caller holds DnsGlobalInfoLock
    //
    
    DWORD  dwSize = 0;
    DWORD  Error = NO_ERROR;
    LPBYTE pszUtf8HostName = NULL;  // copy of pszHostName in Utf8 format
    PWCHAR pszUnicodeHostName = NULL;
    PWCHAR pszUnicodeFQDN = NULL;
    
    //
    // convert the given hostname to a Unicode string
    //

    if (CP_UTF8 == CodePage)
    {
        pszUtf8HostName = (LPBYTE)pszHostName;
    }
    else
    {
        //
        // now convert this into UTF8 format
        //
        if (!ConvertToUtf8(
                 CodePage,
                 (LPSTR)pszHostName,
                 (PCHAR *)&pszUtf8HostName,
                 &dwSize))
        {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsConvertHostNametoUnicode: conversion from "
                "CodePage %d to UTF8 for hostname failed "
                "with error %ld (0x%08x)",
                CodePage,
                Error,
                Error
                );
            if (pszUtf8HostName)
            {
                NH_FREE(pszUtf8HostName);
            }
            return Error;
        }
    }

    //
    // now convert this into Unicode format
    //
    if (!ConvertUTF8ToUnicode(
                 pszUtf8HostName,
                 (LPWSTR *)&pszUnicodeHostName,
                 &dwSize))
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsConvertHostNametoUnicode: conversion from "
            "UTF8 to Unicode for hostname failed "
            "with error %ld (0x%08x)",
            Error,
            Error
            );
        if (CP_UTF8 != CodePage)
        {
            NH_FREE(pszUtf8HostName);
        }
        if (pszUnicodeHostName)
        {
            NH_FREE(pszUnicodeHostName);
        }
        return Error;
    }

    dwSize += sizeof(WCHAR)*(wcslen(DNS_HOMENET_DOT)+wcslen(DnsICSDomainSuffix)+1);
    pszUnicodeFQDN = reinterpret_cast<PWCHAR>(NH_ALLOCATE(dwSize));
    if (!pszUnicodeFQDN)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsConvertHostNametoUnicode: allocation failed "
            "for Unicode FQDN"
            );
        if (CP_UTF8 != CodePage)
        {
            NH_FREE(pszUtf8HostName);
        }
        NH_FREE(pszUnicodeHostName);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(pszUnicodeFQDN, dwSize);

    wcscpy(pszUnicodeFQDN, pszUnicodeHostName); // copy the name
    wcscat(pszUnicodeFQDN, DNS_HOMENET_DOT);    // add the dot
    wcscat(pszUnicodeFQDN, DnsICSDomainSuffix); // add the suffix

    *ppszUnicodeFQDN = pszUnicodeFQDN;
    if (CP_UTF8 != CodePage)
    {
        NH_FREE(pszUtf8HostName);
    }
    NH_FREE(pszUnicodeHostName);

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsConvertHostNametoUnicode: succeeded! %S",
        pszUnicodeFQDN
        );

    return Error;

} // DnsConvertHostNametoUnicode


BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    )
/*++

Routine Description:

    This functions converts an specified CodePage string to Utf8 format.

Arguments:

    pszName - Buffer to the hostname string which is null terminated.

    ppszUtf8Name - receives Pointer to the buffer receiving Utf8 string.

    BufSize - receives Length of the above buffer in bytes.
    
Return Value:

    TRUE on successful conversion.

--*/
{
    DWORD Error = NO_ERROR;
    DWORD dwSize = 0;
    PCHAR pszUtf8Name = NULL;
    LPWSTR pBuf = NULL;

    DWORD Count;

    Count = MultiByteToWideChar(
                CodePage,
                MB_ERR_INVALID_CHARS,
                pszName,
                -1,
                pBuf,
                0
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        return FALSE;
    }
    dwSize = Count * sizeof(WCHAR);
    pBuf = reinterpret_cast<LPWSTR>(NH_ALLOCATE(dwSize));
    if (!pBuf)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: allocation failed for temporary wide char buffer"
            );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pBuf, dwSize);

    Count = MultiByteToWideChar(
                CodePage,
                MB_ERR_INVALID_CHARS,
                pszName,
                -1,
                pBuf,
                Count
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        NH_FREE(pBuf);
        return FALSE;
    }

    Count = WideCharToMultiByte(
                CP_UTF8,
                0,
                pBuf,
                -1,
                pszUtf8Name,
                0,
                NULL,
                NULL
                );
    dwSize = Count;
    pszUtf8Name = reinterpret_cast<PCHAR>(NH_ALLOCATE(dwSize));
    if (!pszUtf8Name)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertToUtf8: allocation failed for Utf8 char buffer"
            );
            NH_FREE(pBuf);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pszUtf8Name, dwSize);

    Count = WideCharToMultiByte(
                CP_UTF8,
                0,
                pBuf,
                -1,
                pszUtf8Name,
                Count,
                NULL,
                NULL
                );

    //
    // N.B. Looks like there is no such thing as a default
    // character for UTF8 - so we have to assume this
    // succeeded..
    // if any default characters were used, then it can't be
    // converted actually.. so don't allow this
    //

    NH_FREE(pBuf);

    *ppszUtf8Name = pszUtf8Name;
    *pUtf8NameSize = dwSize;

    return (Count != 0);

} // ConvertToUtf8



BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    )
/*++

Routine Description:

    This functions converts Utf8 format to Unicodestring.

Arguments:

    UTF8String - Buffer to UTFString which is null terminated.

    ppszUnicodeName - receives Pointer to the buffer receiving Unicode string.

    pUnicodeLength - receives Length of the above buffer in bytes.

Return Value:

    TRUE on successful conversion.

--*/
{

    DWORD Count, dwSize = 0, Error = NO_ERROR;
    LPWSTR pBuf = NULL;

    Count = MultiByteToWideChar(
                CP_UTF8,
                0,
                (LPCSTR)UTF8String,
                -1,
                pBuf,
                0
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        return FALSE;
    }
    dwSize = Count * sizeof(WCHAR);
    pBuf = reinterpret_cast<LPWSTR>(NH_ALLOCATE(dwSize));
    if (!pBuf)
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: allocation failed for unicode string buffer"
            );
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    ZeroMemory(pBuf, dwSize);

    Count = MultiByteToWideChar(
                CP_UTF8,
                0,
                (LPCSTR)UTF8String,
                -1,
                pBuf,
                Count
                );
    if(0 == Count)
    {
        Error = GetLastError();
        NhTrace(
            TRACE_FLAG_DNS,
            "ConvertUTF8ToUnicode: MultiByteToWideChar returned %ld (0x%08x)",
            Error,
            Error
            );
        NH_FREE(pBuf);
        return FALSE;
    }

    *ppszUnicodeName = pBuf;
    *pUnicodeNameSize = dwSize;

    return (Count != 0);
    
} // ConvertUTF8ToUnicode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnslookup.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnslookup.h

Abstract:

    This module contains declarations related to the DNS server's
    lookup table.

Author:

    Tom Brown (tbrown)      25-Oct-1999

Revision History:

    Raghu Gatta (rgatta)    21-Oct-2000
    Time macros + New Functions

--*/

#ifndef _NATHLP_DNSLOOKUP_H_
#define _NATHLP_DNSLOOKUP_H_

#define LOCAL_DOMAIN L"local"
#define LOCAL_DOMAIN_ANSI "local"

//
// move to somewhere else if necessary
//

//
// Time conversion constants and macros
//

#define SYSTIME_UNITS_IN_1_MSEC  (1000 * 10)
#define SYSTIME_UNITS_IN_1_SEC   (1000 * SYSTIME_UNITS_IN_1_MSEC)


//
// macro to get system time in 100-nanosecond units
//

#define DnsQuerySystemTime(p)   NtQuerySystemTime((p))


//
// macros to convert time between 100-nanosecond, 1millsec, and 1 sec units
//

#define DnsSystemTimeToMillisecs(p) {                                       \
    DWORD _r;                                                               \
    *(p) = RtlExtendedLargeIntegerDivide(*(p), SYSTIME_UNITS_IN_1_MSEC, &_r);\
}

#define DnsMillisecsToSystemTime(p)                                         \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_IN_1_MSEC)

#define DnsSecsToSystemTime(p)                                              \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_IN_1_SEC)

#define CACHE_ENTRY_EXPIRY  (7 * 24 * 60 * 60)  // (matches DHCP lease time)



typedef ULONG DNS_ADDRESS;

typedef struct
{
    DNS_ADDRESS ulAddress;
    FILETIME    ftExpires;
    //ULONG       ulExpires;
} ADDRESS_INFO, *PADDRESS_INFO;

typedef struct
{
    WCHAR           *pszName;
    UINT            cAddresses;
    DWORD           cAddressesAllocated;
    PADDRESS_INFO   aAddressInfo;
} DNS_ENTRY, *PDNS_ENTRY;

typedef struct
{
    DNS_ADDRESS     ulAddress;           
    WCHAR           *pszName; // do not free this! It is the same pointer as used in the
                              // forward lookup table.
} REVERSE_DNS_ENTRY, *PREVERSE_DNS_ENTRY;


extern CRITICAL_SECTION    DnsTableLock;   // protects both tables
extern RTL_GENERIC_TABLE   g_DnsTable,
                           g_ReverseDnsTable;


ULONG
DnsInitializeTableManagement(
    VOID
    );


VOID
DnsShutdownTableManagement(
    VOID
    );


VOID
DnsEmptyTables(
    VOID
    );


BOOL
DnsRegisterName(
    WCHAR *pszName,
    UINT cAddresses,
    ADDRESS_INFO aAddressInfo[]
    );


VOID
DnsAddAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress,
    FILETIME    ftExpires
    //ULONG ulExpires
    );


VOID
DnsDeleteAddressForName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    );


PDNS_ENTRY
DnsLookupAddress(
    WCHAR *pszName
    );


PREVERSE_DNS_ENTRY
DnsLookupName(
    DNS_ADDRESS ulAddress
    );


VOID
DnsDeleteName(
    WCHAR *pszName
    );


VOID
DnsUpdateName(
    WCHAR *pszName,
    DNS_ADDRESS ulAddress
    );


VOID
DnsUpdate(
    CHAR *pszName,
    ULONG len,
    ULONG ulAddress
    );


VOID
DnsAddSelf(
    VOID
    );


VOID
DnsCleanupTables(
    VOID
    );

DWORD
DnsConvertHostNametoUnicode(
    UINT   CodePage,
    CHAR   *pszHostName,
    PWCHAR DnsICSDomainSuffix,
    PWCHAR *ppszUnicodeFQDN
    );

BOOL
ConvertToUtf8(
    IN UINT   CodePage,
    IN LPSTR  pszName,
    OUT PCHAR *ppszUtf8Name,
    OUT ULONG *pUtf8NameSize
    );

BOOL
ConvertUTF8ToUnicode(
    IN LPBYTE  UTF8String,
    OUT LPWSTR *ppszUnicodeName,
    OUT DWORD  *pUnicodeNameSize
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsmsg.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsmsg.c

Abstract:

    This module contains code for the DNS proxy's message-processing.

Author:

    Abolade Gbadegesin (aboladeg)   9-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Rewrite + Cleanup + New Functions

--*/

#include "precomp.h"
#pragma hdrstop


//
// EXTERNAL DECLARATIONS
//
extern "C" DWORD G_UseEdns;


VOID
DnsProcessQueryMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DNS query message.

Arguments:

    Interfacep - the interface on which the query was received

    Bufferp - the buffer containing the query

Return Value:

    none.

Environment:

    Invoked internally in the context of a worker-thread completion routine,
    with an outstanding reference to 'Interfacep' from the time the
    read-operation was begun.

--*/

{
    PVOID Context;
    PVOID Context2;
    ULONG Error;
    PDNS_QUERY Queryp;
    PDNS_HEADER Headerp;
    BOOLEAN Referenced = TRUE;
    SOCKET Socket;
    LPVOID lpMsgBuf;

    PROFILE("DnsProcessQueryMessage");

#if DBG

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsProcessQueryMessage: dumping %d bytes",
        Bufferp->BytesTransferred
        );

    NhDump(
        TRACE_FLAG_DNS,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );

#endif

    InterlockedIncrement(
        reinterpret_cast<LPLONG>(&DnsStatistics.QueriesReceived)
        );

    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    Socket = Bufferp->Socket;
    Context = Bufferp->Context;
    Context2 = Bufferp->Context2;

    //
    // if the Broadcast bit (9) was set, we leave it as is
    // instead of zeroing it
    //
    //if (Headerp->Broadcast) {
    //    Headerp->Broadcast = 0;
    //}

    if (Headerp->Opcode == DNS_OPCODE_QUERY ||
        Headerp->Opcode == DNS_OPCODE_IQUERY ||
        Headerp->Opcode == DNS_OPCODE_SERVER_STATUS) {

        //
        // Query the local DNS Resolver cache before proxying
        //

        //
        // Unpack
        //
        DNS_STATUS          dnsStatus;
        DNS_PARSED_MESSAGE  dnsParsedMsg;
        PDNS_MESSAGE_BUFFER pDnsBuffer = NULL;
        PDNS_MSG_BUF        pDnsMsgBuf = NULL;
        PDNS_RECORD         pQueryResultsSet = NULL;
        WORD                wMessageLength;
        DWORD               dwFlags, dwQueryOptions;
        DNS_CHARSET         CharSet;
        BOOL                fQ4DefaultSuffix = FALSE;

        ZeroMemory(&dnsParsedMsg, sizeof(DNS_PARSED_MESSAGE));
        
        pDnsBuffer     = (PDNS_MESSAGE_BUFFER) Headerp;        
        wMessageLength = (WORD) Bufferp->BytesTransferred;
        dwFlags        = DNS_PARSE_FLAG_ONLY_QUESTION;
        CharSet        = DnsCharSetUtf8;

        //
        // Dns* functions require byte flipping
        //
        DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);
        
        dnsStatus = Dns_ParseMessage(
                        &dnsParsedMsg,
                        pDnsBuffer,
                        wMessageLength,
                        dwFlags,
                        CharSet
                        );

        if (NO_ERROR == dnsStatus)
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: Dns_ParseMessage succeeded!!"
                );

            //
            // Make a note of whether this question was for our private
            // default domain (ie mshome.net)
            //
            {
                //
                // the question name is in UTF_8 form
                //
            
                PWCHAR pszQName = NULL;
                DWORD  dwUtf8Size  = 0,
                       dwSize;

                dwUtf8Size = strlen((char *)dnsParsedMsg.pQuestionName);

                dwSize = DnsGetBufferLengthForStringCopy(
                             (char *)dnsParsedMsg.pQuestionName,
                             dwUtf8Size,
                             DnsCharSetUtf8,
                             DnsCharSetUnicode
                             );
                if (!dwSize)
                {
                    //
                    // invalid input string
                    //
                    DWORD dwRet = GetLastError();

                    lpMsgBuf = NULL;
                    
                    FormatMessage(
                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                        FORMAT_MESSAGE_FROM_SYSTEM |
                        FORMAT_MESSAGE_IGNORE_INSERTS,
                        NULL,
                        dwRet,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (LPTSTR) &lpMsgBuf,
                        0,
                        NULL
                        );
                        
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsProcessQueryMessage: DnsGetBufferLengthForStringCopy"
                        " returned (0x%08x) %S",
                        dwRet,
                        lpMsgBuf
                        );
                    
                    if (lpMsgBuf) LocalFree(lpMsgBuf);
                }
                else
                {
                    pszQName = reinterpret_cast<PWCHAR>(NH_ALLOCATE(dwSize));
                    
                    if (!pszQName)
                    {
                        NhTrace(
                            TRACE_FLAG_DNS,
                            "DnsProcessQueryMessage: allocation "
                            "failed for pszQName"
                            );
                    }
                    else
                    {
                        ZeroMemory(pszQName, dwSize);
                        
                        DnsUtf8ToUnicode(
                            (char *)dnsParsedMsg.pQuestionName,
                            dwUtf8Size,
                            pszQName,
                            dwSize
                            );
                    
                        fQ4DefaultSuffix = IsSuffixValid(
                                                      pszQName,
                                                      DNS_HOMENET_SUFFIX
                                                      );
                        NhTrace(
                            TRACE_FLAG_DNS,
                            "DnsProcessQueryMessage: %S (%s)",
                            pszQName,
                            (fQ4DefaultSuffix?"TRUE":"FALSE")
                            );

                        NH_FREE(pszQName);
                    }
                }
            }
            
            //
            // Query
            //
            dwQueryOptions = (
                              DNS_QUERY_STANDARD              |
                              DNS_QUERY_CACHE_ONLY            |
                              DNS_QUERY_TREAT_AS_FQDN         |
                              //DNS_QUERY_ALLOW_EMPTY_AUTH_RESP |
                              0
                             );

            dnsStatus = DnsQuery_UTF8(
                            (LPSTR) dnsParsedMsg.pQuestionName,
                            dnsParsedMsg.QuestionType,
                            dwQueryOptions,
                            NULL,
                            &pQueryResultsSet,
                            NULL
                            );
        }

        if (dnsStatus)
        {
            lpMsgBuf = NULL;

            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_FROM_SYSTEM |
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                dnsStatus,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                (LPTSTR) &lpMsgBuf,
                0,
                NULL
                );
                
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: (0x%08x) %S",
                dnsStatus,
                lpMsgBuf
                );
            
            if (lpMsgBuf) LocalFree(lpMsgBuf);
        }
        
        if ((NO_ERROR == dnsStatus) &&
            (pQueryResultsSet)          // ??? what do i check to see if 
                                        // there was actually something useful
                                        // returned from the cache
           )
        {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: results found in the local DNS Resolver Cache"
                );

            //
            // Pack & Send back answer; return
            //

            // set response bit
            dnsParsedMsg.Header.IsResponse = 1;

            // set the section field of every DNS_RECORD given to us
            // *** NEED TO CHANGE THIS LATER ***
            PDNS_RECORD pRR = pQueryResultsSet;
            DWORD       cnt = 0;
            while (pRR)
            {
                pRR->Flags.S.Section = 1;
                cnt++;
                pRR = pRR->pNext;
            }
            
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: %d records",
                cnt
                );
            
            // set global EDNS OPT field to 0 every time
            // *** NEED TO CHANGE THIS LATER ***
            //G_UseEdns = 0;

            pDnsMsgBuf = Dns_BuildPacket(
                             &dnsParsedMsg.Header,   // ??? parsed message header should be OK
                             TRUE,                   // ??? no header count copy - counts done automatically?
                             dnsParsedMsg.pQuestionName,
                             dnsParsedMsg.QuestionType,
                             pQueryResultsSet,
                             dwQueryOptions,
                             TRUE                    // set to update because of G_UseEdns workaround
                             );

            if (NULL == pDnsMsgBuf)
            {
                lpMsgBuf = NULL;
                
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    FORMAT_MESSAGE_FROM_SYSTEM |
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    GetLastError(),
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                    (LPTSTR) &lpMsgBuf,
                    0,
                    NULL
                    );
                    
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: Dns_BuildPacket failed (%S)",
                    lpMsgBuf
                    );
                
                if (lpMsgBuf) LocalFree(lpMsgBuf);
            }
            else
            {
                DWORD dwDnsPktSize = (DWORD)(sizeof(DNS_HEADER) +
                                             ((PCHAR)pDnsMsgBuf->pCurrent - 
                                              (PCHAR)pDnsMsgBuf->MessageBody));
            
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: Dns_BuildPacket returned pkt of size %d (%d) bytes",
                    dwDnsPktSize,
                    DNS_MESSAGE_OFFSET(pDnsMsgBuf, pDnsMsgBuf->pCurrent)
                    );
            
                //
                // send back the answer retrieved from the cache
                //
                PNH_BUFFER NewBufferp = NhAcquireVariableLengthBuffer(
                                            dwDnsPktSize
                                            );

                if (!NewBufferp)
                {
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsProcessQueryMessage: could not acquire buffer"
                        );
                }
                else
                {
                    //
                    // Dns* functions return in host order ???
                    //
                    DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsMsgBuf->MessageHead);
                    
                    //
                    // Reference the interface now since we are replying
                    // to the query
                    //
                    
                    EnterCriticalSection(&DnsInterfaceLock);
                    if (!DNS_REFERENCE_INTERFACE(Interfacep))
                    {
                        LeaveCriticalSection(&DnsInterfaceLock);
                        Referenced = FALSE;
                    }
                    else
                    {
                        LeaveCriticalSection(&DnsInterfaceLock);
                    
                        ACQUIRE_LOCK(Interfacep);

                        memcpy(
                            NewBufferp->Buffer,
                            &pDnsMsgBuf->MessageHead,
                            dwDnsPktSize
                            );
                        
                        Error =
                            NhWriteDatagramSocket(
                                &DnsComponentReference,
                                Bufferp->Socket,
                                Bufferp->ReadAddress.sin_addr.s_addr,
                                Bufferp->ReadAddress.sin_port,
                                NewBufferp,
                                dwDnsPktSize,
                                DnsWriteCompletionRoutine,
                                Interfacep,
                                NULL
                                );

                        RELEASE_LOCK(Interfacep);
                        
                        if (!Error)
                        {
                            InterlockedIncrement(
                                reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                                );
                        }
                        else
                        {
                            NhReleaseBuffer(NewBufferp);
                            DNS_DEREFERENCE_INTERFACE(Interfacep);
                            NhWarningLog(
                                IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                                Error,
                                "%I",
                                NhQueryAddressSocket(Socket)
                                );
                        }
                    }
                }
                
                LocalFree(pDnsMsgBuf);
                
            }
            
            //
            // CLEANUP
            //
            
            DnsRecordListFree(
                pQueryResultsSet,
                DnsFreeRecordListDeep
                );

            // buffer is reposted below

        }
        else
        if (//(DNS_ERROR_RECORD_DOES_NOT_EXIST == dnsStatus) &&
            (fQ4DefaultSuffix))
        {
            //
            // this was a question for our default suffix
            // we send a name error reply back to the client
            // - note however that we dont publish an SOA
            //   record for our default suffix domain
            //

            //
            // Undoing Flip above
            //
            DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);
            
            DWORD dwDnsPktSize = Bufferp->BytesTransferred;
        
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsProcessQueryMessage: returning error message"
                );
        
            //
            // send back the negative answer
            //
            PNH_BUFFER NewBufferp = NhAcquireVariableLengthBuffer(
                                        dwDnsPktSize
                                        );

            if (!NewBufferp)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: could not acquire buffer"
                    );
            }
            else
            {
                //
                // Reference the interface now since we are replying
                // to the query
                //
                
                EnterCriticalSection(&DnsInterfaceLock);
                if (!DNS_REFERENCE_INTERFACE(Interfacep))
                {
                    LeaveCriticalSection(&DnsInterfaceLock);
                    Referenced = FALSE;
                }
                else
                {
                    LeaveCriticalSection(&DnsInterfaceLock);
                
                    ACQUIRE_LOCK(Interfacep);

                    memcpy(
                        NewBufferp->Buffer,
                        Bufferp->Buffer,
                        dwDnsPktSize
                        );

                    PDNS_HEADER NewHeaderp = (PDNS_HEADER)NewBufferp->Buffer;

                    //
                    // set response bit
                    //
                    NewHeaderp->IsResponse = 1;

                    //
                    // set "Name does not exist" error in the RCode field
                    //
                    NewHeaderp->ResponseCode = DNS_RCODE_NXDOMAIN;

                    
                    Error =
                        NhWriteDatagramSocket(
                            &DnsComponentReference,
                            Bufferp->Socket,
                            Bufferp->ReadAddress.sin_addr.s_addr,
                            Bufferp->ReadAddress.sin_port,
                            NewBufferp,
                            dwDnsPktSize,
                            DnsWriteCompletionRoutine,
                            Interfacep,
                            NULL
                            );

                    RELEASE_LOCK(Interfacep);
                    
                    if (!Error)
                    {
                        InterlockedIncrement(
                            reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                            );
                    }
                    else
                    {
                        NhReleaseBuffer(NewBufferp);
                        DNS_DEREFERENCE_INTERFACE(Interfacep);
                        NhWarningLog(
                            IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Socket)
                            );
                    }
                }
            }

            // buffer is reposted below
            
        }
        else
        {
            //
            // Undoing Flip above
            //
            DNS_BYTE_FLIP_HEADER_COUNTS(&pDnsBuffer->MessageHead);

            //
            // Reference the interface now in case we need to forward the query
            //
        
            EnterCriticalSection(&DnsInterfaceLock);
            if (DNS_REFERENCE_INTERFACE(Interfacep))
            {
                LeaveCriticalSection(&DnsInterfaceLock);
            }
            else
            {
                LeaveCriticalSection(&DnsInterfaceLock);
                Referenced = FALSE;
            }
        
            ACQUIRE_LOCK(Interfacep);
        
            //
            // See if this query is already pending;
            // if not, create a record for it on the receiving interface.
            //
        
            if (DnsIsPendingQuery(Interfacep, Bufferp))
            {
                RELEASE_LOCK(Interfacep);

                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: query already pending"
                    );

                if (Referenced)
                { 
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                } 
            }
            else
            if (!Referenced ||
                !(Queryp = DnsRecordQuery(Interfacep, Bufferp)))
            {
                RELEASE_LOCK(Interfacep);

                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsProcessQueryMessage: query could not be created"
                    );

                if (Referenced)
                {
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                }
            }
            else
            {
        
                //
                // Write the new ID in the query
                //
        
                Headerp->Xid = Queryp->QueryId;
        
                //
                // Send the query to our servers
                //
        
                Error =
                    DnsSendQuery(
                        Interfacep,
                        Queryp,
                        FALSE
                        );
        
                //
                // This buffer is now associated with an outstanding query,
                // so don't repost it below.
                //
        
                if (!Error)
                {
                    Bufferp = NULL;
                    RELEASE_LOCK(Interfacep);
                }
                else
                {
                    //
                    // Delete the query, but not the buffer, which we repost below
                    //
                    Queryp->Bufferp = NULL;
                    DnsDeleteQuery(Interfacep, Queryp);
                    RELEASE_LOCK(Interfacep);
                    DNS_DEREFERENCE_INTERFACE(Interfacep);
                }
            }
        }

        //
        // cleanup question name
        //
        LocalFree(dnsParsedMsg.pQuestionName);      // ??? is LocalFree OK?
    }

    //
    // Post another read
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);
        do {
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Socket,
                    Bufferp,
                    DnsReadCompletionRoutine,
                    Context,
                    Context2
                    );
            //
            // A connection-reset error indicates that our last *send*
            // could not be delivered at its destination.
            // We could hardly care less; so issue the read again,
            // immediately.
            //
        } while (Error == WSAECONNRESET);
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DnsDeferReadInterface(Interfacep, Socket);
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            NhErrorLog(
                IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Socket)
                );
            if (Bufferp) { NhReleaseBuffer(Bufferp); }
        }
    }

} // DnsProcessQueryMessage


VOID
DnsProcessResponseMessage(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked to process a DNS response message.

Arguments:

    Interfacep - the interface on which the query was received

    Bufferp - the buffer containing the query

Return Value:

    none.

Environment:

    Invoked internally in the context of a worker-thread completion routine,
    with an outstanding reference to 'Interfacep' from the time the
    read-operation was begun.

--*/

{
    PVOID Context;
    PVOID Context2;
    ULONG Error;
    PDNS_HEADER Headerp;
    PDNS_QUERY Queryp;
    SOCKET Socket;

    PROFILE("DnsProcessResponseMessage");

#if DBG
    NhDump(
        TRACE_FLAG_DNS,
        Bufferp->Buffer,
        Bufferp->BytesTransferred,
        1
        );
#endif

    InterlockedIncrement(
        reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesReceived)
        );

    Headerp = (PDNS_HEADER)Bufferp->Buffer;

    Socket = Bufferp->Socket;
    Context = Bufferp->Context;
    Context2 = Bufferp->Context2;

    //
    // Reference the interface and attempt to forward the response
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);

        ACQUIRE_LOCK(Interfacep);
    
        //
        // See if the response is for a pending query
        //
    
        if (!(Queryp = DnsMapResponseToQuery(Interfacep, Headerp->Xid))) {
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DnsStatistics.MessagesIgnored)
                );
        } else {
    
            //
            // We have the corresponding query.
            // Send the response back to the client.
            //
    
            Headerp->Xid = Queryp->SourceId;
    
            Error =
                NhWriteDatagramSocket(
                    &DnsComponentReference,
                    Bufferp->Socket,
                    Queryp->SourceAddress,
                    Queryp->SourcePort,
                    Bufferp,
                    Bufferp->BytesTransferred,
                    DnsWriteCompletionRoutine,
                    Interfacep,
                    (PVOID)Queryp->QueryId
                    );
    
            RELEASE_LOCK(Interfacep);
    
            //
            // This buffer is in use for a send-operation,
            // so don't repost it below.
            //
    
            if (!Error) {
                Bufferp = NULL;
                InterlockedIncrement(
                    reinterpret_cast<LPLONG>(&DnsStatistics.ResponsesSent)
                    );
            } else {
                DNS_DEREFERENCE_INTERFACE(Interfacep);
                NhWarningLog(
                    IP_DNS_PROXY_LOG_RESPONSE_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Socket)
                    );
            }
        }
    }

    //
    // Post another read buffer
    //

    EnterCriticalSection(&DnsInterfaceLock);
    if (!DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        if (Bufferp) { NhReleaseBuffer(Bufferp); }
    } else {
        LeaveCriticalSection(&DnsInterfaceLock);
        do {
            Error =
                NhReadDatagramSocket(
                    &DnsComponentReference,
                    Socket,
                    Bufferp,
                    DnsReadCompletionRoutine,
                    Context,
                    Context2
                    );
            //
            // A connection-reset error indicates that our last *send*
            // could not be delivered at its destination.
            // We could hardly care less; so issue the read again,
            // immediately.
            //
        } while (Error == WSAECONNRESET);
        if (Error) {
            ACQUIRE_LOCK(Interfacep);
            DnsDeferReadInterface(Interfacep, Socket);
            RELEASE_LOCK(Interfacep);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
            if (Bufferp) { NhReleaseBuffer(Bufferp); }
            NhErrorLog(
                IP_DNS_PROXY_LOG_RECEIVE_FAILED,
                Error,
                "%I",
                NhQueryAddressSocket(Socket)
                );
        }
    }

} // DnsProcessResponseMessage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsquery.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsquery.c

Abstract:

    This module contains code for the DNS proxy's query-management.

Author:

    Abolade Gbadegesin (aboladeg)   11-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Added ICSDomain registry key change notify code.
    
--*/

#include "precomp.h"
#pragma hdrstop
#include "dnsmsg.h"

//
// Structure:   DNS_QUERY_TIMEOUT_CONTEXT
//
// This structure is used to pass context information
// to the timeout callback-routine for DNS queries.
//

typedef struct _DNS_QUERY_TIMEOUT_CONTEXT {
    ULONG Index;
    USHORT QueryId;
} DNS_QUERY_TIMEOUT_CONTEXT, *PDNS_QUERY_TIMEOUT_CONTEXT;


//
// GLOBAL DATA DEFINITIONS
//

const WCHAR DnsDhcpNameServerString[] = L"DhcpNameServer";
const WCHAR DnsNameServerString[] = L"NameServer";
HANDLE DnsNotifyChangeKeyEvent = NULL;
IO_STATUS_BLOCK DnsNotifyChangeKeyIoStatus;
HANDLE DnsNotifyChangeKeyWaitHandle = NULL;
HANDLE DnsNotifyChangeAddressEvent = NULL;
OVERLAPPED DnsNotifyChangeAddressOverlapped;
HANDLE DnsNotifyChangeAddressWaitHandle = NULL;
PULONG DnsServerList[DnsProxyCount] = { NULL, NULL };
HANDLE DnsTcpipInterfacesKey = NULL;
const WCHAR DnsTcpipInterfacesString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters\\Interfaces";

HANDLE DnsNotifyChangeKeyICSDomainEvent = NULL;
IO_STATUS_BLOCK DnsNotifyChangeKeyICSDomainIoStatus;
HANDLE DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
HANDLE DnsTcpipParametersKey = NULL;
const WCHAR DnsTcpipParametersString[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services"
    L"\\Tcpip\\Parameters";
const WCHAR DnsICSDomainValueName[] =
    L"ICSDomain";
PWCHAR DnsICSDomainSuffix = NULL;



//
// FORWARD DECLARATIONS
//

VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnspQueryTimeoutCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID APIENTRY
DnspQueryTimeoutWorkerRoutine(
    PVOID Context
    );

VOID
DnsReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );


VOID
DnsDeleteQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp
    )

/*++

Routine Description:

    This routine is called to delete a pending query.

Arguments:

    Interfacep - the query's interface

    Queryp - the query to be deleted

Return Value:

    none.

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    PROFILE("DnsDeleteQuery");

    if (Queryp->Bufferp) { NhReleaseBuffer(Queryp->Bufferp); }
    if (Queryp->TimerHandle) {
        //
        // This query is associated with a timer;
        // Rather than cancel the timeout-routine, we let it run,
        // so that it can release any references it has on the component.
        // When it does run, though, the routine won't find this query.
        //
        Queryp->TimerHandle = NULL;
    }
    RemoveEntryList(&Queryp->Link);
    NH_FREE(Queryp);

} // DnsDeleteQuery


BOOLEAN
DnsIsPendingQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    )

/*++

Routine Description:

    This routine is invoked to determine whether a query is already pending
    for the client-request in the given buffer.

    The list of queries is sorted on 'QueryId', but we will be searching
    on 'SourceId' and 'SourceAddress' and 'SourcePort'; hence, we must do
    an exhaustive search of the pending-query list.

Arguments:

    Interfacep - the interface on which to look

    QueryBuffer - the query to be searched for

Return Value:

    BOOLEAN - TRUE if the query is already pending, FALSE otherwise.

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    BOOLEAN Exists;
    PDNS_HEADER Headerp;
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsIsPendingQuery");

    Exists = FALSE;
    Headerp = (PDNS_HEADER)QueryBuffer->Buffer;

    for (Link = Interfacep->QueryList.Flink;
         Link != &Interfacep->QueryList;
         Link = Link->Flink
         ) {

        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);

        if (Queryp->SourceId != Headerp->Xid ||
            Queryp->SourceAddress != QueryBuffer->ReadAddress.sin_addr.s_addr ||
            Queryp->SourcePort != QueryBuffer->ReadAddress.sin_port
            ) {
            continue;
        }

        Exists = TRUE;
        break;
    }

    return Exists;

} // DnsIsPendingQuery


PDNS_QUERY
DnsMapResponseToQuery(
    PDNS_INTERFACE Interfacep,
    USHORT ResponseId
    )

/*++

Routine Description:

    This routine is invoked to map an incoming response from a DNS server
    to a pending query for a DNS client.

Arguments:

    Interfacep - the interface holding the pending query, if any

    ResponseId - the ID in the response received from the server

Return Value:

    PDNS_QUERY - the pending query, if any

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    PLIST_ENTRY Link;
    PDNS_QUERY Queryp;

    PROFILE("DnsMapResponseToQuery");

    for (Link = Interfacep->QueryList.Flink;
         Link != &Interfacep->QueryList;
         Link = Link->Flink
         ) {
        Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
        if (ResponseId > Queryp->QueryId) {
            continue;
        } else if (ResponseId < Queryp->QueryId) {
            break;
        }
        return Queryp;
    }

    return NULL;

} // DnsMapResponseToQuery



VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of when changes occur
    in the (system) table that maps IP addresses to interfaces.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    ULONG Error;
    HANDLE UnusedTcpipHandle;

    PROFILE("DnsNotifyChangeAddressCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeAddressEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Rebuild the list of DNS servers
    //

    DnsQueryServerList();

    //
    // Repost the address change-notification
    //

    ZeroMemory(&DnsNotifyChangeAddressOverlapped, sizeof(OVERLAPPED));

    DnsNotifyChangeAddressOverlapped.hEvent = DnsNotifyChangeAddressEvent;

    Error =
        NotifyAddrChange(
            &UnusedTcpipHandle,
            &DnsNotifyChangeAddressOverlapped
            );

    if (Error != ERROR_IO_PENDING) {
        if (DnsNotifyChangeAddressWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
            DnsNotifyChangeAddressWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeAddressEvent);
        DnsNotifyChangeAddressEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeAddressCallbackRoutine: error %08x "
            "for change address",
            Error
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
            Error,
            ""
            );
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeAddressCallbackRoutine



VOID NTAPI
DnsNotifyChangeKeyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of a change to the
    TCP/IP parameters subkey containing the DNS adapter information.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    NTSTATUS status;

    PROFILE("DnsNotifyChangeKeyCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeKeyEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Rebuild the list of DNS servers
    //

    DnsQueryServerList();

    //
    // Repost the change-notification
    //

    status =
        NtNotifyChangeKey(
            DnsTcpipInterfacesKey,
            DnsNotifyChangeKeyEvent,
            NULL,
            NULL,
            &DnsNotifyChangeKeyIoStatus,
            REG_NOTIFY_CHANGE_LAST_SET,
            TRUE,
            NULL,
            0,
            TRUE
            );

    if (!NT_SUCCESS(status)) {
        if (DnsNotifyChangeKeyWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
            DnsNotifyChangeKeyWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeKeyEvent);
        DnsNotifyChangeKeyEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeKeyCallbackRoutine: status %08x "
            "enabling change notify",
            status
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
            RtlNtStatusToDosError(status),
            ""
            );
        DEREFERENCE_DNS();
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeKeyCallbackRoutine



VOID NTAPI
DnsNotifyChangeKeyICSDomainCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked to notify us of a change to the TCP/IP
    parameters subkey containing the ICS Domain suffix string information.

Arguments:

    Context - unused

    TimedOut - indicates a time-out occurred

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released 
    when the wait is cancelled, unless an error occurs here,
    in which case it is released immediately.

--*/

{
    NTSTATUS status;

    PROFILE("DnsNotifyChangeKeyICSDomainCallbackRoutine");

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (!DnsNotifyChangeKeyICSDomainEvent) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS();
        return;
    }

    //
    // Check to see if the domain string changed;
    // if it doesnt exist - create one.
    //

    DnsQueryICSDomainSuffix();

    //
    // Repost the change-notification
    //

    status =
        NtNotifyChangeKey(
            DnsTcpipParametersKey,
            DnsNotifyChangeKeyICSDomainEvent,
            NULL,
            NULL,
            &DnsNotifyChangeKeyICSDomainIoStatus,
            REG_NOTIFY_CHANGE_LAST_SET,
            FALSE,                          // not interested in the subtree
            NULL,
            0,
            TRUE
            );

    if (!NT_SUCCESS(status)) {
        if (DnsNotifyChangeKeyICSDomainWaitHandle) {
            RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
            DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
        }
        NtClose(DnsNotifyChangeKeyICSDomainEvent);
        DnsNotifyChangeKeyICSDomainEvent = NULL;
        LeaveCriticalSection(&DnsGlobalInfoLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsNotifyChangeKeyICSDomainCallbackRoutine: status %08x "
            "enabling change notify",
            status
            );
        NhWarningLog(
            IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
            RtlNtStatusToDosError(status),
            ""
            );
        DEREFERENCE_DNS();
        return;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

} // DnsNotifyChangeKeyICSDomainCallbackRoutine


VOID NTAPI
DnspQueryTimeoutCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is called when the timeout for a query expires.
    We may need to resubmit the query and install a new timer,
    but we cannot do this in the context of an Rtl timer-routine.
    Therefore, queue an RTUTILS.DLL work-item to handle the timeout.

Arguments:

    Context - holds the timer context

    TimedOut - unused.

Return Value:

    none.

Environment:

    Invoked in the context of an Rtl timer-thread with a reference made
    to the component on our behalf at the time 'RtlCreateTimer' was invoked.

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    PDNS_QUERY Queryp;
    NTSTATUS status;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;

    PROFILE("DnspQueryTimeoutCallbackRoutine");

    TimeoutContext = (PDNS_QUERY_TIMEOUT_CONTEXT)Context;

    //
    // Look up the interface for the timeout
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(TimeoutContext->Index, NULL);
    if (!Interfacep || !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: interface %d not found",
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Look up the query which timed out
    //

    ACQUIRE_LOCK(Interfacep);
    Queryp = DnsMapResponseToQuery(Interfacep, TimeoutContext->QueryId);
    if (!Queryp) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: query %d interface %d not found",
            TimeoutContext->QueryId,
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }

    Queryp->TimerHandle = NULL;

    //
    // Try to queue a work-item for the timeout;
    // if this succeeds, keep the reference on the component.
    // Otherwise, we have to drop the reference here.
    //

    status =
        RtlQueueWorkItem(
            DnspQueryTimeoutWorkerRoutine,
            Context, 
            WT_EXECUTEINIOTHREAD
            );

    if (NT_SUCCESS(status)) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
    } else {
        NH_FREE(TimeoutContext);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutCallbackRoutine: RtlQueueWorkItem=%d, aborting",
            status
            );
        DnsDeleteQuery(Interfacep, Queryp);
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        DEREFERENCE_DNS();
    }

} // DnspQueryTimeoutCallbackRoutine


VOID APIENTRY
DnspQueryTimeoutWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is called when the timeout for a query expires.
    It is queued by the query's timer-handler.

Arguments:

    Context - holds the timer context

Return Value:

    none.

Environment:

    Invoked in the context of an RTUTILS worker-thread with a reference made
    to the component on our behalf at the time 'RtlCreateTimer' was invoked.

--*/

{
    ULONG Error;
    PDNS_INTERFACE Interfacep;
    PDNS_QUERY Queryp;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;

    PROFILE("DnspQueryTimeoutWorkerRoutine");

    TimeoutContext = (PDNS_QUERY_TIMEOUT_CONTEXT)Context;

    //
    // Look up the interface for the timeout
    //

    EnterCriticalSection(&DnsInterfaceLock);
    Interfacep = DnsLookupInterface(TimeoutContext->Index, NULL);
    if (!Interfacep || !DNS_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&DnsInterfaceLock);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutWorkerRoutine: interface %d not found",
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }
    LeaveCriticalSection(&DnsInterfaceLock);

    //
    // Look up the query which timed out
    //

    ACQUIRE_LOCK(Interfacep);
    Queryp = DnsMapResponseToQuery(Interfacep, TimeoutContext->QueryId);
    if (!Queryp) {
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_DNS,
            "DnspQueryTimeoutWorkerRoutine: query %d interface %d not found",
            TimeoutContext->QueryId,
            TimeoutContext->Index
            );
        NH_FREE(TimeoutContext);
        DEREFERENCE_DNS();
        return;
    }

    NH_FREE(TimeoutContext);

    //
    // Have 'DnsSendQuery' repost the timed-out query.
    // Note that we retain our reference to the interface
    // on behalf of the send to be initiated in 'DnsSendQuery'.
    //

    Error =
        DnsSendQuery(
            Interfacep,
            Queryp,
            TRUE
            );

    if (!Error) {
        RELEASE_LOCK(Interfacep);
    } else {
        DnsDeleteQuery(Interfacep, Queryp);
        RELEASE_LOCK(Interfacep);
        DNS_DEREFERENCE_INTERFACE(Interfacep);
    }

    DEREFERENCE_DNS();

} // DnspQueryTimeoutWorkerRoutine


ULONG
DnsQueryServerList(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to read the list of DNS servers from the registry.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    PUCHAR Buffer;
    ULONG Error;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    PDNS_INTERFACE Interfacep;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("DnsQueryServerList");

    if (!DnsTcpipInterfacesKey) {

        RtlInitUnicodeString(&UnicodeString, DnsTcpipInterfacesString);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    
        //
        // Open the 'Tcpip\Parameters\Interfaces' registry key
        //
    
        status =
            NtOpenKey(
                &DnsTcpipInterfacesKey,
                KEY_ALL_ACCESS,
                &ObjectAttributes
                );
    
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error %x opening registry key",
                status
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                Error,
                ""
                );
            return Error;
        }
    }

    //
    // See if we need to install change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the change-notification routine
    // which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeKeyEvent && REFERENCE_DNS()) {

        //
        // Attempt to set up change notification on the key
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeKeyEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: status %08x creating notify-change event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        } else {
    
            //
            // Register a wait on the notify-change event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeKeyWaitHandle,
                    DnsNotifyChangeKeyEvent,
                    DnsNotifyChangeKeyCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status)) {
                NtClose(DnsNotifyChangeKeyEvent);
                DnsNotifyChangeKeyEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: status %08x registering wait",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            } else {
        
                //
                // Register for change-notification on the key
                //
        
                status =
                    NtNotifyChangeKey(
                        DnsTcpipInterfacesKey,
                        DnsNotifyChangeKeyEvent,
                        NULL,
                        NULL,
                        &DnsNotifyChangeKeyIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        TRUE,
                        NULL,
                        0,
                        TRUE
                        );
        
                if (!NT_SUCCESS(status)) {
                    RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
                    DnsNotifyChangeKeyWaitHandle = NULL;
                    NtClose(DnsNotifyChangeKeyEvent);
                    DnsNotifyChangeKeyEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryServerList: status %08x (%08x) "
                        "enabling change notify",
                        status
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                        RtlNtStatusToDosError(status),
                        ""
                        );
                }
            }
        }
    }

    //
    // See if we need to install address-change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the address-change-notification
    // routine which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeAddressEvent && REFERENCE_DNS()) {

        //
        // Attempt to set up address change notification
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeAddressEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: status %08x creating "
                "notify-change address event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        } else {
    
            //
            // Register a wait on the notify-change address event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeAddressWaitHandle,
                    DnsNotifyChangeAddressEvent,
                    DnsNotifyChangeAddressCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status)) {
                NtClose(DnsNotifyChangeAddressEvent);
                DnsNotifyChangeAddressEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: status %08x registering wait"
                    "for change address",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            } else {

                HANDLE UnusedTcpipHandle;

                //
                // Register for change-notification
                //

                ZeroMemory(
                    &DnsNotifyChangeAddressOverlapped,
                    sizeof(OVERLAPPED)
                    );

                DnsNotifyChangeAddressOverlapped.hEvent =
                                                DnsNotifyChangeAddressEvent;

                Error =
                    NotifyAddrChange(
                        &UnusedTcpipHandle,
                        &DnsNotifyChangeAddressOverlapped
                        );

                if (Error != ERROR_IO_PENDING) {
                    RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
                    DnsNotifyChangeAddressWaitHandle = NULL;
                    NtClose(DnsNotifyChangeAddressEvent);
                    DnsNotifyChangeAddressEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryServerList: error %08x"
                        "for change address",
                        Error
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_NOTIFY_FAILED,
                        Error,
                        ""
                        );
                }
            }
        }
    }


    {
    PIP_ADAPTER_INFO AdapterInfo;
    PIP_ADAPTER_INFO AdaptersInfo = NULL;
    ULONG Address;
    PIP_ADDR_STRING AddrString;
    ULONG dnsLength = 0;
    PULONG dnsServerList = NULL;
    PFIXED_INFO FixedInfo = NULL;
    LONG i;
    ULONG Length;
    PIP_PER_ADAPTER_INFO PerAdapterInfo;
    ULONG tempLength;
    PULONG tempServerList;
    ULONG winsLength;
    PULONG winsServerList = NULL;

    //
    // Read the DNS and WINS server lists.
    // 'GetAdaptersInfo' provides the WINS servers for each adapter,
    // while 'GetPerAdapterInfo' provides the DNS servers for each adapter.
    // While 'GetAdaptersInfo' returns an array of all adapters,
    // 'GetPerAdapterInfo' must be invoked for each individual adapter.
    // Hence we begin with 'GetAdaptersInfo', and enumerate each adapter
    // building the WINS and DNS server lists in parallel.
    //

    do {

        //
        // Retrieve the size of the adapter list
        //

        Length = 0;
        Error = GetAdaptersInfo(NULL, &Length);
    
        if (!Error) {
            break;
        } else if (Error != ERROR_BUFFER_OVERFLOW) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: GetAdaptersInfo=%d",
                Error
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ERROR_SERVER_LIST,
                Error,
                ""
                );
            break;
        }

        //
        // Allocate a buffer to hold the list
        //

        AdaptersInfo = (PIP_ADAPTER_INFO)NH_ALLOCATE(Length);

        if (!AdaptersInfo) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error allocating %d bytes",
                Length
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Length
                );
            break;
        }

        //
        // Retrieve the list
        //

        Error = GetAdaptersInfo(AdaptersInfo, &Length);

        if (Error) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: GetAdaptersInfo=%d",
                Error
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                Error,
                ""
                );
            break;
        }

        //
        // Count the WINS servers
        //

        for (AdapterInfo = AdaptersInfo, winsLength = 1;
             AdapterInfo;
             AdapterInfo = AdapterInfo->Next
             ) {
            if (inet_addr(AdapterInfo->PrimaryWinsServer.IpAddress.String)) {
                ++winsLength;
            }
            if (inet_addr(AdapterInfo->SecondaryWinsServer.IpAddress.String)) {
                ++winsLength;
            }
        }

        //
        // Allocate space for the WINS servers
        //

        winsServerList = (PULONG)NH_ALLOCATE(winsLength * sizeof(ULONG));

        if (!winsServerList) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryServerList: error allocating %d-byte WINS server list",
                winsLength * sizeof(ULONG)
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                winsLength * sizeof(ULONG)
                );
            break;
        }

        //
        // Now fill in the WINS server names from each adapter.
        // In the process, we pick up the DNS server lists for each adapter.
        //

        for (AdapterInfo = AdaptersInfo, Length = 0;
             AdapterInfo;
             AdapterInfo = AdapterInfo->Next
             ) {

            Address =
                inet_addr(AdapterInfo->PrimaryWinsServer.IpAddress.String);
            if (Address) {
                for (i = 0; i < (LONG)Length; i++) {
                    if (Address == winsServerList[i]) { break; }
                }
                if (i >= (LONG)Length) { winsServerList[Length++] = Address; }
            }
            Address =
                inet_addr(AdapterInfo->SecondaryWinsServer.IpAddress.String);
            if (Address) {
                for (i = 0; i < (LONG)Length; i++) {
                    if (Address == winsServerList[i]) { break; }
                }
                if (i >= (LONG)Length) { winsServerList[Length++] = Address; }
            }

            //
            // Now obtain the DNS servers for the adapter.
            //

            Error = GetPerAdapterInfo(AdapterInfo->Index, NULL, &tempLength);
            if (Error != ERROR_BUFFER_OVERFLOW) { continue; }

            //
            // Allocate memory for the per-adapter info
            //

            PerAdapterInfo =
                reinterpret_cast<PIP_PER_ADAPTER_INFO>(
                    NH_ALLOCATE(tempLength)
                    );
            if (!PerAdapterInfo) {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: error allocating %d bytes",
                    tempLength
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    tempLength
                    );
                continue;
            }

            //
            // Retrieve the per-adapter info
            //

            Error =
                GetPerAdapterInfo(
                    AdapterInfo->Index,
                    PerAdapterInfo,
                    &tempLength
                    );
            if (Error) {
                NH_FREE(PerAdapterInfo);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: GetPerAdapterInfo=%d",
                    Error
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_NO_SERVER_LIST,
                    Error,
                    ""
                    );
                continue;
            }

            //
            // Count the DNS servers for the adapter
            //

            for (AddrString = &PerAdapterInfo->DnsServerList, tempLength = 0;
                 AddrString;
                 AddrString = AddrString->Next
                 ) {
                if (inet_addr(AddrString->IpAddress.String)) { ++tempLength; }
            }

            if (!tempLength) { NH_FREE(PerAdapterInfo); continue; }

            //
            // Allocate space for the adapter's DNS servers
            //

            tempServerList =
                reinterpret_cast<PULONG>(
                    NH_ALLOCATE((dnsLength + tempLength + 1) * sizeof(ULONG))
                    );
            if (!tempServerList) {
                NH_FREE(PerAdapterInfo);
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryServerList: error allocating %d bytes",
                    (dnsLength + tempLength + 1) * sizeof(ULONG)
                    );
                NhErrorLog(
                    IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    (dnsLength + tempLength + 1) * sizeof(ULONG)
                    );
                continue;
            }

            //
            // Copy the existing servers
            //

            if (dnsServerList) {
                CopyMemory(
                    tempServerList,
                    dnsServerList,
                    dnsLength * sizeof(ULONG)
                    );
            }

            //
            // Read the new servers into the new server list
            //

            for (AddrString = &PerAdapterInfo->DnsServerList;
                 AddrString;
                 AddrString = AddrString->Next
                 ) {

                Address = inet_addr(AddrString->IpAddress.String);
                if (!Address) { continue; }

                for (i = 0; i < (LONG)dnsLength; i++) {
                    if (Address == tempServerList[i]) { break; }
                }

                if (i < (LONG)dnsLength) { continue; }

                //
                // The current DNS server goes in the front of the list,
                // while any other server is appended.
                //

                if (PerAdapterInfo->CurrentDnsServer != AddrString) {
                    tempServerList[dnsLength] = Address;
                } else {
                    MoveMemory(
                        tempServerList + sizeof(ULONG),
                        tempServerList,
                        dnsLength * sizeof(ULONG)
                        );
                    tempServerList[0] = Address;
                }

                ++dnsLength;
            }

            tempServerList[dnsLength] = 0;
            NH_FREE(PerAdapterInfo);

            //
            // Replace the existing server list
            //

            

            if (dnsServerList) { NH_FREE(dnsServerList); }
            dnsServerList = tempServerList;
        }

        winsServerList[Length] = 0;

    } while(FALSE);

    if (AdaptersInfo) { NH_FREE(AdaptersInfo); }

    //
    // Store the new server lists
    //

    NhTrace(
        TRACE_FLAG_DNS,
        "DnsQueryServerList: new server list lengths are : DNS (%d) WINS (%d)",
        dnsLength,
        Length
        );

    if (DnsServerList[DnsProxyDns]) { NH_FREE(DnsServerList[DnsProxyDns]); }
    DnsServerList[DnsProxyDns] = dnsServerList;
    if (DnsServerList[DnsProxyWins]) { NH_FREE(DnsServerList[DnsProxyWins]); }
    DnsServerList[DnsProxyWins] = winsServerList;
    }

    return NO_ERROR;

} // DnsQueryServerList

VOID
DnsQueryRegistryICSDomainSuffix(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to read the ICS Domain suffix from the registry.

Arguments:

    none.

Return Value:

    VOID.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    DWORD    dwSize = 0;
    LPVOID   lpMsgBuf;
    BOOL     fSuffixChanged = FALSE;
    BOOL     fUseDefaultSuffix = FALSE;

    //
    // retrieve current suffix string (if any)
    //
    status =
        NhQueryValueKey(
            DnsTcpipParametersKey,
            DnsICSDomainValueName,
            &Information
            );


    if (!NT_SUCCESS(status))
    {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsQueryRegistryICSDomainSuffix: error (0x%08x) querying "
            "ICS Domain suffix name",
            status
            );

        //
        // if we did not find it in the registry and we had previously
        // got some suffix - we revert to default string (happens below)
        //
        if ((STATUS_OBJECT_NAME_NOT_FOUND == status) && DnsICSDomainSuffix)
        {
            NH_FREE(DnsICSDomainSuffix);
            DnsICSDomainSuffix = NULL;
        }
            
        //
        // if we have no idea of the string, set our copy to default string
        //
        if (NULL == DnsICSDomainSuffix)
        {
            dwSize = wcslen(DNS_HOMENET_SUFFIX) + 1;

            DnsICSDomainSuffix = reinterpret_cast<PWCHAR>(
                                     NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                                     );
            if (!DnsICSDomainSuffix)
            {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryRegistryICSDomainSuffix: allocation "
                    "failed for DnsICSDomainSuffix"
                    );

                return;
            }

            wcscpy(DnsICSDomainSuffix, DNS_HOMENET_SUFFIX);
            fSuffixChanged = TRUE;
        }
    }
    else
    {
        //
        // overwrite our current version of suffix string
        //

        dwSize = lstrlenW((PWCHAR)Information->Data);

        if (dwSize)
        {
            //
            // we have a nonzero string
            //
            dwSize++;   // add 1 for terminating null
            
        }
        else
        {
            //
            // the data is a null string - use default suffix
            //
            dwSize = wcslen(DNS_HOMENET_SUFFIX) + 1;
            fUseDefaultSuffix = TRUE;
        }

        if (DnsICSDomainSuffix)
        {
            NH_FREE(DnsICSDomainSuffix);
            DnsICSDomainSuffix = NULL;
        }

        DnsICSDomainSuffix = reinterpret_cast<PWCHAR>(
                                 NH_ALLOCATE(sizeof(WCHAR) * dwSize)
                                 );
        if (!DnsICSDomainSuffix)
        {
            NH_FREE(Information);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryRegistryICSDomainSuffix: allocation "
                "failed for DnsICSDomainSuffix"
                );

            return;
        }

        if (!fUseDefaultSuffix)
        {
            wcscpy(DnsICSDomainSuffix, (PWCHAR) Information->Data);
        }
        else
        {
            wcscpy(DnsICSDomainSuffix, DNS_HOMENET_SUFFIX);
        }
        fSuffixChanged = TRUE;

        NH_FREE(Information);
    }

    if (fSuffixChanged)
    {
        //
        // enumerate existing entries and replace old ones
        // + we must do this because otherwise forward and reverse lookups
        //   are dependent on the way in which the entries are ordered in
        //   the hosts.ics file
        //
        //DnsReplaceOnSuffixChange();
    }

} // DnsQueryRegistryICSDomainSuffix


ULONG
DnsQueryICSDomainSuffix(
    VOID
    )

/*++

Routine Description:

    This routine invokes DnsQueryRegistryICSDomainSuffix and installs
    change notification for this reg key if necessary.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked in an arbitrary context with 'DnsGlobalInfoLock' acquired
    by the caller.

--*/

{
    PUCHAR Buffer;
    ULONG Error;
    PKEY_VALUE_PARTIAL_INFORMATION Information;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    UNICODE_STRING UnicodeString;

    PROFILE("DnsQueryICSDomainSuffix");

    if (!DnsTcpipParametersKey)
    {

        RtlInitUnicodeString(&UnicodeString, DnsTcpipParametersString);
        InitializeObjectAttributes(
            &ObjectAttributes,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );
    
        //
        // Open the 'Tcpip\Parameters' registry key
        //
    
        status =
            NtOpenKey(
                &DnsTcpipParametersKey,
                KEY_ALL_ACCESS,
                &ObjectAttributes
                );
    
        if (!NT_SUCCESS(status))
        {
            Error = RtlNtStatusToDosError(status);
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryICSDomainSuffix: error %x opening registry key",
                status
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_NO_ICSD_SUFFIX,
                Error,
                ""
                );
            return Error;
        }
    }

    //
    // See if we need to install change-notification,
    // and reference ourselves if so.
    // The reference is made on behalf of the change-notification routine
    // which will be invoked by a wait-thread when a change occurs.
    //

    if (!DnsNotifyChangeKeyICSDomainEvent && REFERENCE_DNS())
    {

        //
        // Attempt to set up change notification on the key
        //

        status =
            NtCreateEvent(
                &DnsNotifyChangeKeyICSDomainEvent,
                EVENT_ALL_ACCESS,
                NULL,
                SynchronizationEvent,
                FALSE
                );

        if (!NT_SUCCESS(status)) {
            DEREFERENCE_DNS();
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsQueryICSDomainSuffix: status %08x creating notify-change event",
                status
                );
            NhWarningLog(
                IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                RtlNtStatusToDosError(status),
                ""
                );
        }
        else
        {
            //
            // Register a wait on the notify-change event
            //

            status =
                RtlRegisterWait(
                    &DnsNotifyChangeKeyICSDomainWaitHandle,
                    DnsNotifyChangeKeyICSDomainEvent,
                    DnsNotifyChangeKeyICSDomainCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
        
            if (!NT_SUCCESS(status))
            {
                NtClose(DnsNotifyChangeKeyICSDomainEvent);
                DnsNotifyChangeKeyICSDomainEvent = NULL;
                DEREFERENCE_DNS();
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsQueryICSDomainSuffix: status %08x registering wait",
                    status
                    );
                NhWarningLog(
                    IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                    RtlNtStatusToDosError(status),
                    ""
                    );
            }
            else
            {
                //
                // Register for change-notification on the key
                //
        
                status =
                    NtNotifyChangeKey(
                        DnsTcpipParametersKey,
                        DnsNotifyChangeKeyICSDomainEvent,
                        NULL,
                        NULL,
                        &DnsNotifyChangeKeyICSDomainIoStatus,
                        REG_NOTIFY_CHANGE_LAST_SET,
                        FALSE,              // not interested in the subtree
                        NULL,
                        0,
                        TRUE
                        );
        
                if (!NT_SUCCESS(status))
                {
                    RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
                    DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
                    NtClose(DnsNotifyChangeKeyICSDomainEvent);
                    DnsNotifyChangeKeyICSDomainEvent = NULL;
                    DEREFERENCE_DNS();
                    NhTrace(
                        TRACE_FLAG_DNS,
                        "DnsQueryICSDomainSuffix: status %08x (%08x) "
                        "enabling change notify",
                        status
                        );
                    NhWarningLog(
                        IP_DNS_PROXY_LOG_CHANGE_ICSD_NOTIFY_FAILED,
                        RtlNtStatusToDosError(status),
                        ""
                        );
                }
            }
        }
    }

    DnsQueryRegistryICSDomainSuffix();

    return NO_ERROR;

} // DnsQueryICSDomainSuffix


PDNS_QUERY
DnsRecordQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    )

/*++

Routine Description:

    This routine is invoked to create a pending-query entry for a client's
    DNS query.

Arguments:

    Interfacep - the interface on which to create the record

    QueryBuffer - the DNS request for which to create a record

Return Value:

    PDNS_QUERY - the pending query if created

Environment:

    Invoked with 'Interfacep' locked by the caller.

--*/

{
    BOOLEAN ConflictFound;
    PDNS_HEADER Headerp;
    PLIST_ENTRY Link;
    USHORT QueryId;
    PDNS_QUERY Queryp;
    ULONG RetryCount = MAXCHAR;
    ULONG Seed = GetTickCount();

    PROFILE("DnsRecordQuery");

    //
    // Attempt to generate a random ID for the query.
    // Assuming we succeed, we leave the loop with 'Link'
    // set to the correct insertion-point for the new query.
    //
    do {

        QueryId = (USHORT)((RtlRandom(&Seed) & 0xffff0000) >> 16);
        ConflictFound = FALSE;
        for (Link = Interfacep->QueryList.Flink; Link != &Interfacep->QueryList;
             Link = Link->Flink) {
            Queryp = CONTAINING_RECORD(Link, DNS_QUERY, Link);
            if (QueryId > Queryp->QueryId) {
                continue;
            } else if (QueryId < Queryp->QueryId) {
                break;
            }
            ConflictFound = TRUE;
            break;
        }
    } while(ConflictFound && --RetryCount);

    if (ConflictFound) { return NULL; }

    //
    // Allocate and initialize the new query
    //

    Queryp = reinterpret_cast<PDNS_QUERY>(NH_ALLOCATE(sizeof(DNS_QUERY)));

    if (!Queryp) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsRecordQuery: allocation failed for DNS query"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(DNS_QUERY)
            );
        return NULL;
    }

    Headerp = (PDNS_HEADER)QueryBuffer->Buffer;
    Queryp->QueryId = QueryId;
    Queryp->SourceId = Headerp->Xid;
    Queryp->SourceAddress = QueryBuffer->ReadAddress.sin_addr.s_addr;
    Queryp->SourcePort = QueryBuffer->ReadAddress.sin_port;
    Queryp->Type =
        DNS_PROXY_PORT_TO_TYPE(NhQueryPortSocket(QueryBuffer->Socket));
    Queryp->QueryLength = QueryBuffer->BytesTransferred;
    Queryp->Bufferp = QueryBuffer;
    Queryp->Interfacep = Interfacep;
    Queryp->TimerHandle = NULL;
    Queryp->RetryCount = 0;

    //
    // Insert the new query in the location determined above.
    //

    InsertTailList(Link, &Queryp->Link);
    return Queryp;

} // DnsRecordQuery



ULONG
DnsSendQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp,
    BOOLEAN Resend
    )

/*++

Routine Description:

    This routine is invoked to forward a query to our DNS servers.

Arguments:

    Interfacep - the interface on which to send the query

    Queryp - the DNS request to be sent

    Resend - if TRUE, the buffer is being resent; otherwise, the buffer
        is being sent for the first time.

Return Value:

    ULONG - Win32 status code.
    On success, 'Queryp' may have been deleted.

Environment:

    Invoked with 'Interfacep' locked by the caller, and with a reference made
    to it for the send which occurs here.
    If the routine fails, it is the caller's responsibility to release that
    reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    ULONG i, j;
    PULONG ServerList;
    SOCKET Socket;
    NTSTATUS status;
    PDNS_QUERY_TIMEOUT_CONTEXT TimeoutContext;
    ULONG TimeoutSeconds;

    PROFILE("DnsSendQuery");

    //
    // For WINS queries, we use a global socket to work around the fact that
    // even though we're bound to the WINS port, responses will only be
    // delivered to the first socket bound to the socket, which is
    // the kernel-mode NetBT driver.
    //

    EnterCriticalSection(&DnsGlobalInfoLock);
    if (Queryp->Type == DnsProxyDns) {
        Socket = Queryp->Bufferp->Socket;
        ServerList = DnsServerList[DnsProxyDns];
    } else {
        Socket = DnsGlobalSocket;
        ServerList = DnsServerList[DnsProxyWins];
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // See if there are any servers to be tried.
    //

    if (!ServerList ||
        !ServerList[0] ||
        Queryp->RetryCount++ > DNS_QUERY_RETRY) {
        if (!ServerList) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: no server list"
                );
        }
        else if (!ServerList[0]) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: no server entries in list"
                );        
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: retry count for query %d "
                "greater than DNS_QUERY_RETRY(%d)",
                Queryp->QueryId,
                DNS_QUERY_RETRY
                );        
        }
        if (REFERENCE_DNS()) {
            //
            // Initiate an attempt to connect the default interface, if any.
            //
            status =
                RtlQueueWorkItem(
                    DnsConnectDefaultInterface,
                    NULL, 
                    WT_EXECUTEINIOTHREAD
                    );
            if (!NT_SUCCESS(status)) { DEREFERENCE_DNS(); }
        }
        NhInformationLog(
            IP_DNS_PROXY_LOG_NO_SERVERS_LEFT,
            0,
            "%I",
            Queryp->SourceAddress
            );
        return ERROR_NO_MORE_ITEMS;
    }

    //
    // Send the query to each server on the list
    //

    for (i = 0; ServerList[i]; i++) {

        for (j = 0; j < Interfacep->BindingCount; j++) {
            if (Interfacep->BindingArray[j].Address == ServerList[i]) {
                break;
            }
        }
        if (j < Interfacep->BindingCount) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: server %s is self, ignoring",
                INET_NTOA(ServerList[i])
                );
            continue;
        }

        if (!DNS_REFERENCE_INTERFACE(Interfacep) ||
            !(Bufferp = NhDuplicateBuffer(Queryp->Bufferp))) {
            continue;
        }

        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSendQuery: sending query %d interface %d to %s",
            (PVOID)((PDNS_HEADER)Bufferp->Buffer)->Xid,
            Interfacep->Index,
            INET_NTOA(ServerList[i])
            );
    
        //
        // Send the message
        //
    
        Error =
            NhWriteDatagramSocket(
                &DnsComponentReference,
                Socket,
                ServerList[i],
                DNS_PROXY_TYPE_TO_PORT(Queryp->Type),
                Bufferp,
                Queryp->QueryLength,
                DnsWriteCompletionRoutine,
                Interfacep,
                (PVOID)Queryp->QueryId
                );
    
        if (!Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&DnsStatistics.QueriesSent)
                );
        } else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: error %d sending query %d interface %d",
                Error,
                Queryp->QueryId,
                Interfacep->Index
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_QUERY_FAILED,
                Error,
                "%I%I%I",
                Queryp->SourceAddress,
                ServerList[i],
                NhQueryAddressSocket(Bufferp->Socket)
                );
            Error = NO_ERROR;
            NhReleaseBuffer(Bufferp);
            DNS_DEREFERENCE_INTERFACE(Interfacep);
        }
    }

    //
    // Set up the query's timeout.
    // Note that we are now certain that the write-completion routine
    // will be executed. However, if the timeout cannot be set,
    // we want to be assured that the query will still be deleted.
    // Therefore, on failure we delete the query immediately,
    // and the write-completion routine will simply not find it.
    //

    status = STATUS_UNSUCCESSFUL;

    EnterCriticalSection(&DnsGlobalInfoLock);
    TimeoutSeconds = DnsGlobalInfo->TimeoutSeconds;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    if (Queryp->TimerHandle) {

        //
        // Update the timer-queue entry for the query
        //

        status =
            NhUpdateTimer(
                Queryp->TimerHandle,
                TimeoutSeconds * 1000
                );
    } else {

        //
        // Allocate a timer-queue entry context block
        //

        TimeoutContext = reinterpret_cast<PDNS_QUERY_TIMEOUT_CONTEXT>(
                            NH_ALLOCATE(sizeof(*TimeoutContext))
                            );

        if (!TimeoutContext) {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsSendQuery: error allocating query %d timeout context",
                Queryp->QueryId
                );
            status = STATUS_UNSUCCESSFUL;
        } else {

            TimeoutContext->Index = Interfacep->Index;
            TimeoutContext->QueryId = Queryp->QueryId;

            //
            // Insert a timer-queue entry to check the status of the query
            //
    
            status =
                NhSetTimer(
                    &DnsComponentReference,
                    &Queryp->TimerHandle,
                    DnspQueryTimeoutCallbackRoutine,
                    TimeoutContext,
                    TimeoutSeconds * 1000
                    );

            if (!NT_SUCCESS(status)) {
                NH_FREE(TimeoutContext);
                Queryp->TimerHandle = NULL;
            }
        }
    }

    //
    // If the above failed, delete the query now.
    //

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_DNS,
            "DnsSendQuery: status %08x setting timer for query %d",
            status,
            Queryp->QueryId
            );
        DnsDeleteQuery(Interfacep, Queryp);
    }

    DNS_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // DnsSendQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <winsock2.h>
#include <windns.h>
#include <dnsapi.h>
#include <dnslib.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmdns.h"
#include "rmdhcp.h"

#include "dnsfile.h"
#include "dnsif.h"
#include "dnsio.h"
#include "dnslog.h"
#include "dnslookup.h"
#include "dnsmsg.h"
#include "dnsquery.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\dnsquery.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    dnsquery.h

Abstract:

    This module contains declarations for the DNS proxy's query-management.

Author:

    Abolade Gbadegesin (aboladeg)   11-Mar-1998

Revision History:

    Raghu Gatta (rgatta)            1-Dec-2000
    Added ICSDomain registry key change notify functions.

--*/

#ifndef _NATHLP_DNSQUERY_H_
#define _NATHLP_DNSQUERY_H_

//
// CONSTANT DECLARATIONS
//

#define DNS_QUERY_TIMEOUT   (4 * 1000)
#define DNS_QUERY_RETRY     3


//
// STRUCTURE DECLARATIONS
//

//
// Structure:   DNS_QUERY
//
// This structure holds information about a single pending DNS query.
// Each such entry is on an interface's list of pending queries,
// sorted on the 'QueryId' field.
// Access to the list is synchronized using the interface's lock.
//

typedef struct _DNS_QUERY {
    LIST_ENTRY Link;
    USHORT QueryId;
    USHORT SourceId;
    ULONG SourceAddress;
    USHORT SourcePort;
    DNS_PROXY_TYPE Type;
    ULONG QueryLength;
    PNH_BUFFER Bufferp;
    PDNS_INTERFACE Interfacep;
    HANDLE TimerHandle;
    ULONG RetryCount;
} DNS_QUERY, *PDNS_QUERY;

//
// GLOBAL VARIABLE DECLARATIONS
//

extern HANDLE DnsNotifyChangeKeyEvent;
extern HANDLE DnsNotifyChangeKeyWaitHandle;
extern PULONG DnsServerList[DnsProxyCount];
extern HANDLE DnsTcpipInterfacesKey;

extern HANDLE DnsNotifyChangeAddressEvent;
extern HANDLE DnsNotifyChangeAddressWaitHandle;

extern HANDLE DnsNotifyChangeKeyICSDomainEvent;
extern HANDLE DnsNotifyChangeKeyICSDomainWaitHandle;
extern HANDLE DnsTcpipParametersKey;
extern PWCHAR DnsICSDomainSuffix;



//
// ROUTINE DECLARATIONS
//

VOID
DnsDeleteQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp
    );

BOOLEAN
DnsIsPendingQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    );

PDNS_QUERY
DnsMapResponseToQuery(
    PDNS_INTERFACE Interfacep,
    USHORT ResponseId
    );

VOID NTAPI
DnsNotifyChangeAddressCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnsNotifyChangeKeyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
DnsNotifyChangeKeyICSDomainCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

ULONG
DnsQueryServerList(
    VOID
    );

ULONG
DnsQueryICSDomainSuffix(
    VOID
    );

PDNS_QUERY
DnsRecordQuery(
    PDNS_INTERFACE Interfacep,
    PNH_BUFFER QueryBuffer
    );

ULONG
DnsSendQuery(
    PDNS_INTERFACE Interfacep,
    PDNS_QUERY Queryp,
    BOOLEAN Resend
    );

#endif // _NATHLP_DNSQUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpconn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpconn.h

Abstract:

    This module contains declarations for the FTP transparent proxy's
    connection-management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_FTPCONN_H_
#define _NATHLP_FTPCONN_H_

#define FTP_BUFFER_RESERVE      12

//
// Structure:   FTP_CONNECTION
//
// This structure encapsulates information about a control-channel accepted
// on one of the interfaces over which the component is enabled.
// Each entry is stored in the connection list of an interface,
// and is uniquely identified by a 32-bit identifier assigned when the entry
// is created.
// As connection-requests are accepted for a connection-entry,
// endpoints are created in the connection's list.
// Access to the list is synchronized using the interface lock
// for the interface on which the connection was created.
//

typedef struct _FTP_CONNECTION {
    LIST_ENTRY Link;
    ULONG ConnectionId;
    PFTP_INTERFACE Interfacep;
    LIST_ENTRY ActiveEndpointList;
} FTP_CONNECTION, *PFTP_CONNECTION;

typedef enum {
    FtpClientEndpointType,
    FtpHostEndpointType,
    FtpMaximumEndpointType
} FTP_ENDPOINT_TYPE, *PFTP_ENDPOINT_TYPE;

//
// Structure:   FTP_ENDPOINT
//
// This structure encapsulates information about a FTP endpoint,
// which is an active endpoint transferring data between a client and a host.
// Each endpoint is stored in the endpoint list of the connection for which
// it was created, and in the endpoint list of its connection's interface.
//

typedef struct _FTP_ENDPOINT {
    LIST_ENTRY ConnectionLink;
    LIST_ENTRY InterfaceLink;
    ULONG EndpointId;
    ULONG ConnectionId;
    PFTP_INTERFACE Interfacep;
    ULONG Flags;
    FTP_ENDPOINT_TYPE Type;
    SOCKET ClientSocket;
    SOCKET HostSocket;
    ULONG BoundaryAddress;
    ULONG ActualClientAddress;
    ULONG ActualHostAddress;
    ULONG DestinationAddress;
    ULONG SourceAddress;
    ULONG NewDestinationAddress;
    ULONG NewSourceAddress;
    USHORT ActualClientPort;
    USHORT ActualHostPort;
    USHORT DestinationPort;
    USHORT SourcePort;
    USHORT NewDestinationPort;
    USHORT NewSourcePort;
    USHORT ReservedPort;
} FTP_ENDPOINT, *PFTP_ENDPOINT;

#define FTP_ENDPOINT_FLAG_INITIAL_ENDPOINT  0x00000001
#define FTP_ENDPOINT_FLAG_CLIENT_CLOSED     0x00000002
#define FTP_ENDPOINT_FLAG_HOST_CLOSED       0x00000004
#define FTP_ENDPOINT_FLAG_DELETE_CONNECTION 0x00000008

//
// ROUTINE DECLARATIONS
//

ULONG
FtpActivateActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp
    );

VOID
FtpCloseActiveEndpoint(
    PFTP_ENDPOINT Endpointp,
    SOCKET ClosedSocket
    );

ULONG
FtpCreateActiveEndpoint(
    PFTP_CONNECTION Connectionp,
    FTP_ENDPOINT_TYPE Type,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    ULONG RemoteAddress,
    USHORT RemotePort,
    ULONG BoundaryAddress,
    OUT PFTP_ENDPOINT* EndpointCreated OPTIONAL
    );

ULONG
FtpCreateConnection(
    PFTP_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    OUT PFTP_CONNECTION* ConnectionCreated OPTIONAL
    );

VOID
FtpDeleteActiveEndpoint(
    PFTP_ENDPOINT Endpointp
    );

VOID
FtpDeleteConnection(
    PFTP_CONNECTION Connectionp
    );

PFTP_ENDPOINT
FtpLookupActiveEndpoint(
    PFTP_CONNECTION Connectionp,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

PFTP_CONNECTION
FtpLookupConnection(
    PFTP_INTERFACE Interfacep,
    ULONG ConnectionId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

PFTP_ENDPOINT
FtpLookupInterfaceEndpoint(
    PFTP_INTERFACE Interfacep,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
FtpReadActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpoint,
    SOCKET Socket,
    ULONG UserFlags OPTIONAL
    );

ULONG
FtpWriteActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpoint,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG UserFlags OPTIONAL
    );

#endif // _NATHLP_FTPCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\dns\rmdns.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdns.c

Abstract:

    This module contains routines for the DNS allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

COMPONENT_REFERENCE DnsComponentReference;
PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo = NULL;
CRITICAL_SECTION DnsGlobalInfoLock;
SOCKET DnsGlobalSocket = INVALID_SOCKET;
HANDLE DnsNotificationEvent;
ULONG DnsProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS DnsRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_DNS_PROXY,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    DnsRmStartProtocol,
    DnsRmStartComplete,
    DnsRmStopProtocol,
    DnsRmGetGlobalInfo,
    DnsRmSetGlobalInfo,
    NULL,
    NULL,
    DnsRmAddInterface,
    DnsRmDeleteInterface,
    DnsRmInterfaceStatus,
    
    DnsRmGetInterfaceInfo,
    DnsRmSetInterfaceInfo,
    DnsRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    DnsRmMibCreate,
    DnsRmMibDelete,
    DnsRmMibGet,
    DnsRmMibSet,
    DnsRmMibGetFirst,
    DnsRmMibGetNext,
    NULL,
    NULL
};


IP_DNS_PROXY_STATISTICS DnsStatistics;
SUPPORT_FUNCTIONS DnsSupportFunctions;


VOID
DnsCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DNS module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DnsShutdownInterfaceManagement();
    DnsShutdownTableManagement();
    DnsShutdownFileManagement();
    DeleteCriticalSection(&DnsGlobalInfoLock);
    DeleteComponentReference(&DnsComponentReference);

} // DnsCleanupModule


VOID
DnsCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the DNS protocol-component
    after a 'StopProtocol'. It runs when the last reference to the  
    DHCP component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    DNS_PROXY_TYPE Type;

    PROFILE("DnsCleanupProtocol");

    if (DnsServerList[DnsProxyDns]) {
        NH_FREE(DnsServerList[DnsProxyDns]);
        DnsServerList[DnsProxyDns] = NULL;
    }
    if (DnsServerList[DnsProxyWins]) {
        NH_FREE(DnsServerList[DnsProxyWins]);
        DnsServerList[DnsProxyWins] = NULL;
    }
    if (DnsICSDomainSuffix)
    {
        NH_FREE(DnsICSDomainSuffix);
        DnsICSDomainSuffix = NULL;
    }
    if (DnsGlobalInfo) { NH_FREE(DnsGlobalInfo); DnsGlobalInfo = NULL; }
    InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 1);
    SetEvent(DnsNotificationEvent);
    ResetComponentReference(&DnsComponentReference);

} // DnsCleanupProtocol


BOOLEAN
DnsInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the DNS module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &DnsComponentReference, DnsCleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&DnsGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    if (DnsInitializeFileManagement())  {
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    if (DnsInitializeTableManagement())  {
        DnsShutdownFileManagement();
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }
    
    if (DnsInitializeInterfaceManagement())  {
        DnsShutdownTableManagement();
        DnsShutdownFileManagement();
        DeleteCriticalSection(&DnsGlobalInfoLock);
        DeleteComponentReference(&DnsComponentReference);
        return FALSE;
    }

    return TRUE;

} // DnsInitializeModule


BOOLEAN
DnsIsDnsEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to determine whether the DNS proxy is enabled.
    It checks the global info which, if found, indicates that the protocol
    is enabled.
    Note that the global info critical section is always initialized in the
    'DllMain' routine, which is why this routine works if the DNS proxy
    is not even installed.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if DNS proxy is enabled, FALSE otherwise.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("DnsIsDnsEnabled");

    if (!REFERENCE_DNS()) { return FALSE; }
    EnterCriticalSection(&DnsGlobalInfoLock);
    if (!DnsGlobalInfo ||
        !(DnsGlobalInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS)) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        DEREFERENCE_DNS_AND_RETURN(FALSE);
    }
    LeaveCriticalSection(&DnsGlobalInfoLock);
    DEREFERENCE_DNS_AND_RETURN(TRUE);

} // DnsIsDnsEnabled


BOOLEAN
DnsIsWinsEnabled(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to determine whether the WINS proxy is enabled.
    It checks the global info which, if found, indicates that the protocol
    is enabled.
    Note that the global info critical section is always initialized in the
    'DllMain' routine, which is why this routine works if the DNS proxy
    is not even installed.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if WINS proxy is enabled, FALSE otherwise.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PROFILE("DnsIsWinsEnabled");

    return FALSE;

} // DnsIsWinsEnabled


ULONG
APIENTRY
DnsRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount    
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    SOCKET GlobalSocket;
    ULONG Size;
    NTSTATUS status;

    PROFILE("DnsRmStartProtocol");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&DnsGlobalInfoLock);

        Size = sizeof(*DnsGlobalInfo);
    
        DnsGlobalInfo =
            reinterpret_cast<PIP_DNS_PROXY_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!DnsGlobalInfo) {
            LeaveCriticalSection(&DnsGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "DnsRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(DnsGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        DnsNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&DnsSupportFunctions, sizeof(DnsSupportFunctions));
        }
        else {
            CopyMemory(
                &DnsSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        //
        // Query for ICS domain suffix string
        //
        DnsQueryICSDomainSuffix();

        //
        // Build the server list
        //

        DnsQueryServerList();

        //
        // Create the global query-socket
        //

        Error = NhCreateDatagramSocket(0, 0, &GlobalSocket);
        if (Error == NO_ERROR) {
            InterlockedExchangePointer(
                (PVOID*)&DnsGlobalSocket,
                (PVOID)GlobalSocket
                );
        }
        else {
            NhTrace(
                TRACE_FLAG_DNS,
                "DnsRmStartProtocol: error %d creating global socket", Error
                );
            Error = NO_ERROR;
        }

        LeaveCriticalSection(&DnsGlobalInfoLock);

        //
        // load entries from the hosts.ics file (if present)
        //
        LoadHostsIcsFile(TRUE);

        InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmStartProtocol


ULONG
APIENTRY
DnsRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // DnsRmStartComplete


ULONG
APIENTRY
DnsRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    SOCKET GlobalSocket;

    PROFILE("DnsRmStopProtocol");

    //
    // Reference the module to make sure it's running
    //

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Save any entries present in our tables
    //
    SaveHostsIcsFile(TRUE);

    //
    // Empty the dns tables to save memory space
    //
    DnsEmptyTables();

    EnterCriticalSection(&DnsGlobalInfoLock);

    if (DnsNotifyChangeKeyWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeKeyWaitHandle);
        DnsNotifyChangeKeyWaitHandle = NULL;
    }
    if (DnsNotifyChangeKeyEvent) {
        NtClose(DnsNotifyChangeKeyEvent);
        DnsNotifyChangeKeyEvent = NULL;
        DnsNotifyChangeKeyCallbackRoutine(NULL, FALSE);
    }
    if (DnsTcpipInterfacesKey) {
        NtClose(DnsTcpipInterfacesKey);
        DnsTcpipInterfacesKey = NULL;
    }

    if (DnsNotifyChangeAddressWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeAddressWaitHandle);
        DnsNotifyChangeAddressWaitHandle = NULL;
    }
    if (DnsNotifyChangeAddressEvent) {
        NtClose(DnsNotifyChangeAddressEvent);
        DnsNotifyChangeAddressEvent = NULL;
        DnsNotifyChangeAddressCallbackRoutine(NULL, FALSE);
    }

    //
    // ICSDomain
    //
    if (DnsNotifyChangeKeyICSDomainWaitHandle) {
        RtlDeregisterWait(DnsNotifyChangeKeyICSDomainWaitHandle);
        DnsNotifyChangeKeyICSDomainWaitHandle = NULL;
    }
    if (DnsNotifyChangeKeyICSDomainEvent) {
        NtClose(DnsNotifyChangeKeyICSDomainEvent);
        DnsNotifyChangeKeyICSDomainEvent = NULL;
        DnsNotifyChangeKeyICSDomainCallbackRoutine(NULL, FALSE);
    }
    if (DnsTcpipParametersKey) {
        NtClose(DnsTcpipParametersKey);
        DnsTcpipParametersKey = NULL;
    }

    LeaveCriticalSection(&DnsGlobalInfoLock);

    GlobalSocket =
        (SOCKET)InterlockedExchangePointer(
                    (PVOID*)&DnsGlobalSocket, 
                    (PVOID)INVALID_SOCKET
                    );
    NhDeleteDatagramSocket(GlobalSocket);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&DnsComponentReference);

    return DEREFERENCE_DNS() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // DnsRmStopProtocol


ULONG
APIENTRY
DnsRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmAddInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsCreateInterface(
            Index,
            Type,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmAddInterface


ULONG
APIENTRY
DnsRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmDeleteInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsDeleteInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmDeleteInterface


ULONG
APIENTRY
DnsRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("DnsRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&DnsProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // DnsRmGetEventMessage


ULONG
APIENTRY
DnsRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DnsRmGetInterfaceInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsQueryInterface(
            Index,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmGetInterfaceInfo


ULONG
APIENTRY
DnsRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("DnsRmSetInterfaceInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        DnsConfigureInterface(
            Index,
            (PIP_DNS_PROXY_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmSetInterfaceInfo


ULONG
APIENTRY
DnsRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = DnsRmBindInterface(Index, StatusInfo);
            } else {
                Error = DnsRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = DnsRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = DnsRmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // DnsRmInterfaceStatus


ULONG
DnsRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmBindInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsBindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmBindInterface


ULONG
DnsRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmUnbindInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsUnbindInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmUnbindInterface


ULONG
DnsRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmEnableInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsEnableInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmEnableInterface


ULONG
DnsRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("DnsRmDisableInterface");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        DnsDisableInterface(
            Index
            );

    DEREFERENCE_DNS_AND_RETURN(Error);

} // DnsRmDisableInterface


ULONG
APIENTRY
DnsRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("DnsRmGetGlobalInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&DnsGlobalInfoLock);
    Size = sizeof(*DnsGlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&DnsGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_DNS_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, DnsGlobalInfo, Size);
    LeaveCriticalSection(&DnsGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_DNS_AND_RETURN(NO_ERROR);
    
} // DnsRmGetGlobalInfo


ULONG
APIENTRY
DnsRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_DNS_PROXY_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("DnsRmSetGlobalInfo");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_DNS_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*DnsGlobalInfo);
    NewInfo = reinterpret_cast<PIP_DNS_PROXY_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "DnsRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_DNS_PROXY_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_DNS_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&DnsGlobalInfoLock);
    OldFlags = DnsGlobalInfo->Flags;
    NH_FREE(DnsGlobalInfo);
    DnsGlobalInfo = NewInfo;
    NewFlags = DnsGlobalInfo->Flags;
    LeaveCriticalSection(&DnsGlobalInfoLock);

    //
    // See if the enabled state of either DNS or WINS proxy changed.
    // If so, we need to deactivate and reactivate all interfaces
    //

    if ((NewFlags & IP_DNS_PROXY_FLAG_ENABLE_DNS)
            != (OldFlags & IP_DNS_PROXY_FLAG_ENABLE_DNS)) {
        DnsReactivateEveryInterface();
    }

    DEREFERENCE_DNS_AND_RETURN(NO_ERROR);
    
} // DnsRmSetGlobalInfo


ULONG
APIENTRY
DnsRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
DnsRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The DNS proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_DNS_PROXY_MIB_QUERY Oidp;

    PROFILE("DnsRmMibGet");

    REFERENCE_DNS_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    }
    else {
        Oidp = (PIP_DNS_PROXY_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_DNS_PROXY_STATISTICS_OID: {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(DnsStatistics)) {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DnsStatistics);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                }
                else {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(DnsStatistics);
                    Oidp = (PIP_DNS_PROXY_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_DNS_PROXY_STATISTICS_OID;
                    CopyMemory(
                        Oidp->Data,
                        &DnsStatistics,
                        sizeof(DnsStatistics)
                        );
                    Error = NO_ERROR;
                }
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_DNS,
                    "DnsRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_DNS_AND_RETURN(Error);
}


ULONG
APIENTRY
DnsRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
DnsRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpif.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpif.h

Abstract:

    This module contains declarations for the FTP transparent proxy's
    interface management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_FTPIF_H_
#define _NATHLP_FTPIF_H_

//
// Structure:   FTP_BINDING
//
// This structure holds information used for I/O on a logical network.
// Each interface's 'BindingArray' contains an entry for each binding-entry
// supplied during 'BindInterface'.
//

typedef struct _FTP_BINDING {
    ULONG Address;
    ULONG Mask;
    SOCKET ListeningSocket;
    HANDLE ListeningRedirectHandle[2];
} FTP_BINDING, *PFTP_BINDING;


//
// Structure:   FTP_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of FTP transparent proxy
// interfaces, sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('FtpInterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _FTP_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    ULONG AdapterIndex; // read-only
    ULONG Characteristics; //read-only after activation
    NET_INTERFACE_TYPE Type; // read-only
    IP_FTP_INTERFACE_INFO Info;
    IP_NAT_PORT_MAPPING PortMapping;
    ULONG Flags;
    ULONG BindingCount;
    PFTP_BINDING BindingArray;
    LIST_ENTRY ConnectionList;
    LIST_ENTRY EndpointList;
} FTP_INTERFACE, *PFTP_INTERFACE;

//
// Flags
//

#define FTP_INTERFACE_FLAG_DELETED      0x80000000
#define FTP_INTERFACE_DELETED(i) \
    ((i)->Flags & FTP_INTERFACE_FLAG_DELETED)

#define FTP_INTERFACE_FLAG_BOUND        0x40000000
#define FTP_INTERFACE_BOUND(i) \
    ((i)->Flags & FTP_INTERFACE_FLAG_BOUND)

#define FTP_INTERFACE_FLAG_ENABLED      0x20000000
#define FTP_INTERFACE_ENABLED(i) \
    ((i)->Flags & FTP_INTERFACE_FLAG_ENABLED)

#define FTP_INTERFACE_FLAG_CONFIGURED   0x10000000
#define FTP_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & FTP_INTERFACE_FLAG_CONFIGURED)

#define FTP_INTERFACE_FLAG_MAPPED       0x01000000
#define FTP_INTERFACE_MAPPED(i) \
    ((i)->Flags & FTP_INTERFACE_FLAG_MAPPED)

#define FTP_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (FTP_INTERFACE_FLAG_BOUND|FTP_INTERFACE_FLAG_ENABLED)) \
        == (FTP_INTERFACE_FLAG_BOUND|FTP_INTERFACE_FLAG_ENABLED))

#define FTP_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_FTP_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define FTP_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, FTP_INTERFACE_DELETED)

#define FTP_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, FtpCleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY FtpInterfaceList;
extern CRITICAL_SECTION FtpInterfaceLock;
extern ULONG FtpFirewallIfCount;


//
// FUNCTION DECLARATIONS
//

ULONG
FtpAcceptConnectionInterface(
    PFTP_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep OPTIONAL
    );

ULONG
FtpActivateInterface(
    PFTP_INTERFACE Interfacep
    );

ULONG
FtpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
FtpCleanupInterface(
    PFTP_INTERFACE Interfacep
    );

ULONG
FtpConfigureInterface(
    ULONG Index,
    PIP_FTP_INTERFACE_INFO InterfaceInfo
    );

ULONG
FtpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_FTP_INTERFACE_INFO InterfaceInfo,
    PFTP_INTERFACE* InterfaceCreated
    );

VOID
FtpDeactivateInterface(
    PFTP_INTERFACE Interfacep
    );

ULONG
FtpDeleteInterface(
    ULONG Index
    );

ULONG
FtpDisableInterface(
    ULONG Index
    );

ULONG
FtpEnableInterface(
    ULONG Index
    );

ULONG
FtpInitializeInterfaceManagement(
    VOID
    );

PFTP_INTERFACE
FtpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
FtpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
FtpShutdownInterfaceManagement(
    VOID
    );

VOID
FtpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
FtpUnbindInterface(
    ULONG Index
    );

#endif // _NATHLP_FTPIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpif.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    ftpif.c

Abstract:

    This module contains code for the FTP transparent proxy's interface
    management.

Author:

    Qiang Wang  (qiangw)        10-April-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY FtpInterfaceList;
CRITICAL_SECTION FtpInterfaceLock;
ULONG FtpFirewallIfCount;


ULONG
FtpAcceptConnectionInterface(
    IN PFTP_INTERFACE Interfacep,
    IN SOCKET ListeningSocket,
    IN SOCKET AcceptedSocket OPTIONAL,
    IN PNH_BUFFER Bufferp OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep OPTIONAL
    )

/*++

Routine Description:

    This routine is called to accept a connection on an interface. It issues
    an accept-request on the socket and optionally issues a redirect to cause
    FTP control-channel connection-requests to be sent to the listening
    socket.

Arguments:

    Interfacep - the interface on which to accept a connection

    ListeningSocket - the socket on which to listen for a connection

    AcceptedSocket - optionally specifies the socket with which to accept
        a connection.

    Bufferp - optionally supplies a buffer to be used for accept-data

    DynamicRedirectHandlep - on output, optionally receives a handle to a
        dynamic redirect created for the interface. The dynamic redirect
        is only created if the caller specifies this parameter.

Return Value:

    ULONG - Win32/Winsock2 status code.

Notes:

    Invoked with the interface's lock held by the caller and with a reference
    made to the interface on behalf of the accept-completion routine. It is
    this routine's responsibility to release that reference in the event of a
    failure.

--*/

{
    ULONG Address;
    ULONG Error;
    USHORT Port;

    PROFILE("FtpAcceptConnectionInterface");

    Error =
        NhAcceptStreamSocket(
            &FtpComponentReference,
            ListeningSocket,
            AcceptedSocket,
            Bufferp,
            FtpAcceptCompletionRoutine,
            Interfacep,
            (PVOID)ListeningSocket
            );
    if (Error) {
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpAcceptConnectionInterface: error %d accepting connection",
            Error
            );
    } else if (DynamicRedirectHandlep) {

        //
        // From here onward, failures do not require us to drop our reference
        // to the interface, since it is now guaranteed that the accept-
        // completion routine will be invoked.
        //
        // Create the dynamic redirect which will cause all FTP control
        // channel connections to our listening socket.
        //

        Error = NhQueryLocalEndpointSocket(ListeningSocket, &Address, &Port);
        if (Error) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpAcceptConnectionInterface: error %d querying endpoint",
                Error
                );
        } else {

            //
            // Install redirect(s).
            //

            if (NAT_IFC_PRIVATE(Interfacep->Characteristics) ||
                FTP_INTERFACE_MAPPED(Interfacep)) {

                ASSERT(!FTP_INTERFACE_MAPPED(Interfacep) ||
                       NAT_IFC_BOUNDARY(Interfacep->Characteristics));

                Error =
                    NatCreateDynamicAdapterRestrictedPortRedirect(
                        NatRedirectFlagReceiveOnly,
                        NAT_PROTOCOL_TCP,
                        FTP_PORT_CONTROL,
                        Address,
                        Port,
                        Interfacep->AdapterIndex,
                        0,
                        &DynamicRedirectHandlep[0]
                        );
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpAcceptConnectionInterface:"
                    " redirect installed for adapter 0x%08x [%d]",
                    Interfacep->AdapterIndex,
                    Error
                    );
            }

            if (!Error && NAT_IFC_FW(Interfacep->Characteristics)) {
                Error =
                    NatCreateDynamicAdapterRestrictedPortRedirect(
                        NatRedirectFlagSendOnly,
                        NAT_PROTOCOL_TCP,
                        FTP_PORT_CONTROL,
                        Address,
                        Port,
                        Interfacep->AdapterIndex,
                        0,
                        &DynamicRedirectHandlep[1]
                        );

                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpAcceptConnectionInterface:"
                    " redirect installed for firewalled adapter 0x%08x [%d]",
                    Interfacep->AdapterIndex,
                    Error
                    );
            }
        }
    }

    return Error;
} // FtpAcceptConnectionInterface


ULONG
FtpActivateInterface(
    PFTP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.
    Activation involves
    (a) creating sockets for each binding of the interface
    (b) initiating connection-acceptance on each created socket
    (c) initiating session-redirection for the FTP port, if necessary.

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Notes:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'FtpInterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    BOOLEAN IsNatInterface;

    PROFILE("FtpActivateInterface");

    EnterCriticalSection(&FtpInterfaceLock);
    if (FTP_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        return NO_ERROR;
    }

    Interfacep->Characteristics
        = NatGetInterfaceCharacteristics(Interfacep->Index);

    if (!Interfacep->Characteristics) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    if (NAT_IFC_BOUNDARY(Interfacep->Characteristics)) {
        for (i = 0; i < Interfacep->BindingCount; i++) {
            Error = NatLookupPortMappingAdapter(
                        Interfacep->AdapterIndex,
                        NAT_PROTOCOL_TCP,
                        Interfacep->BindingArray[i].Address,
                        FTP_PORT_CONTROL,
                        &Interfacep->PortMapping
                        );
                        
            if (!Error) {
                Interfacep->Flags |= FTP_INTERFACE_FLAG_MAPPED;
                break;
            }
        }

        if (Error && !NAT_IFC_FW(Interfacep->Characteristics)) {
            LeaveCriticalSection(&FtpInterfaceLock);
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpActivateInterface:"
                " ignoring non-FW and non-mapped NAT boundary interface %d",
                Interfacep->Index
                );
            NhWarningLog(
                IP_FTP_LOG_NAT_INTERFACE_IGNORED,
                0,
                "%d",
                Interfacep->Index
                );
            return NO_ERROR;
        }
    }

    if (NAT_IFC_FW(Interfacep->Characteristics)) {
        InterlockedIncrement(reinterpret_cast<LPLONG>(&FtpFirewallIfCount));
    }

    //
    // Create stream sockets that listen for connection-requests on each
    // logical network, and datagram sockets that process incoming messages.
    //

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    for (i = 0; i < Interfacep->BindingCount; i++) {
        Error =
            NhCreateStreamSocket(
                Interfacep->BindingArray[i].Address,
                0,
                &Interfacep->BindingArray[i].ListeningSocket
                );
        if (Error) { break; }
        Error = listen(Interfacep->BindingArray[i].ListeningSocket, SOMAXCONN);
        if (Error == SOCKET_ERROR) { break; }
    }

    //
    // If an error occurred, roll back all work done so far and fail.
    //

    if (Error) {
        ULONG FailedAddress = i;
        for (--i; (LONG)i >= 0; i--) {
            NhDeleteStreamSocket(
                Interfacep->BindingArray[i].ListeningSocket
                );
            Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
        }
        NhErrorLog(
            IP_FTP_LOG_ACTIVATE_FAILED,
            Error,
            "%I",
            Interfacep->BindingArray[FailedAddress].Address
            );
        RELEASE_LOCK(Interfacep);
        LeaveCriticalSection(&FtpInterfaceLock);
        return Error;
    }

    //
    // Initiate connection-acceptance and message-redirection on each socket
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (!FTP_REFERENCE_INTERFACE(Interfacep)) { break; }
        Error =
            FtpAcceptConnectionInterface(
                Interfacep,
                Interfacep->BindingArray[i].ListeningSocket,
                INVALID_SOCKET,
                NULL,
                &Interfacep->BindingArray[i].ListeningRedirectHandle[0]
                );
        if (Error) {
            NhErrorLog(
                IP_FTP_LOG_ACCEPT_FAILED,
                Error,
                "%I",
                Interfacep->BindingArray[i].Address
                );
            Error = NO_ERROR;
        }
    }

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&FtpInterfaceLock);

    return NO_ERROR;

} // FtpActivateInterface


ULONG
FtpBindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    ULONG i;
    ULONG Error = NO_ERROR;
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpBindInterface");

    EnterCriticalSection(&FtpInterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (FTP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpBindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= FTP_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&FtpInterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding
    //

    if (!BindingInfo->AddressCount) {
        Interfacep->BindingCount = 0;
        Interfacep->BindingArray = NULL;
    } else {
        Interfacep->BindingArray =
            reinterpret_cast<PFTP_BINDING>(
                NH_ALLOCATE(BindingInfo->AddressCount * sizeof(FTP_BINDING))
                );
        if (!Interfacep->BindingArray) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IF,
                "FtpBindInterface: allocation failed for interface %d binding",
                Index
                );
            NhErrorLog(
                IP_FTP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                BindingInfo->AddressCount * sizeof(FTP_BINDING)
                );
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        ZeroMemory(
            Interfacep->BindingArray,
            BindingInfo->AddressCount * sizeof(FTP_BINDING)
            );
        Interfacep->BindingCount = BindingInfo->AddressCount;
    }

    //
    // Copy the binding
    //

    for (i = 0; i < BindingInfo->AddressCount; i++) {
        Interfacep->BindingArray[i].Address = BindingInfo->Address[i].Address;
        Interfacep->BindingArray[i].Mask = BindingInfo->Address[i].Mask;
        Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
    }

    //
    // Figure out our IP Adapter Index, if we have a valid binding
    //

    if (Interfacep->BindingCount) {
        Interfacep->AdapterIndex =
            NhMapAddressToAdapter(BindingInfo->Address[0].Address);
    }

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (FTP_INTERFACE_ACTIVE(Interfacep)) {
        Error = FtpActivateInterface(Interfacep);
    }

    FTP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // FtpBindInterface


VOID
FtpCleanupInterface(
    PFTP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Notes:

    Invoked internally from an arbitrary context, with no references
    to the interface.

--*/

{
    PROFILE("FtpCleanupInterface");

    if (Interfacep->BindingArray) {
        NH_FREE(Interfacep->BindingArray);
        Interfacep->BindingArray = NULL;
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // FtpCleanupInterface


ULONG
FtpConfigureInterface(
    ULONG Index,
    PIP_FTP_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Notes:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    ULONG Error;
    PFTP_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("FtpConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&FtpInterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|FTP_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_FTP_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (FTP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = FtpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    } else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_FTP_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_FTP_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (FTP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = FtpActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        } else if (!(OldFlags & IP_FTP_INTERFACE_FLAG_DISABLED) &&
                    (NewFlags & IP_FTP_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (FTP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                FtpDeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    FTP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // FtpConfigureInterface


ULONG
FtpCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_FTP_INTERFACE_INFO InterfaceInfo,
    OUT PFTP_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the FTP transparent proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpCreateInterface");

    EnterCriticalSection(&FtpInterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (FtpLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpCreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep =
        reinterpret_cast<PFTP_INTERFACE>(NH_ALLOCATE(sizeof(FTP_INTERFACE)));

    if (!Interfacep) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "FtpCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_FTP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(FTP_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|FTP_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InitializeListHead(&Interfacep->ConnectionList);
    InitializeListHead(&Interfacep->EndpointList);
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&FtpInterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // FtpCreateInterface


VOID
FtpDeactivateInterface(
    PFTP_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Notes:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'FtpInterfaceLock' held by caller.

--*/

{
    ULONG i;
    ULONG j;
    PLIST_ENTRY Link;
    PFTP_CONNECTION Connectionp;

    PROFILE("FtpDeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    //
    // Stop all network I/O on the interface's logical networks
    //

    for (i = 0; i < Interfacep->BindingCount; i++) {
        if (Interfacep->BindingArray[i].ListeningSocket != INVALID_SOCKET) {
            NhDeleteStreamSocket(Interfacep->BindingArray[i].ListeningSocket);
            Interfacep->BindingArray[i].ListeningSocket = INVALID_SOCKET;
        }
        for (j = 0; j < 2; j++) {
            if (Interfacep->BindingArray[i].ListeningRedirectHandle[j]) {
                NatCancelDynamicPortRedirect(
                    Interfacep->BindingArray[i].ListeningRedirectHandle[j]
                    );
                Interfacep->BindingArray[i].ListeningRedirectHandle[j] = NULL;
            }
        }
    }

    //
    // Eliminate all connections
    //

    while (!IsListEmpty(&Interfacep->ConnectionList)) {
        Link = RemoveHeadList(&Interfacep->ConnectionList);
        Connectionp = CONTAINING_RECORD(Link, FTP_CONNECTION, Link);
        FtpDeleteConnection(Connectionp);
    }

    ASSERT(IsListEmpty(&Interfacep->EndpointList));

    //
    // If this interface is firewalled, decrement the global count.
    //

    if (NAT_IFC_FW(Interfacep->Characteristics)) {
        InterlockedDecrement(reinterpret_cast<LPLONG>(&FtpFirewallIfCount));
    }

    RELEASE_LOCK(Interfacep);

} // FtpDeactivateInterface


ULONG
FtpDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpDeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    FtpDeactivateInterface(Interfacep);

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= FTP_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~FTP_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpDeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    FtpCleanupInterface(Interfacep);

    LeaveCriticalSection(&FtpInterfaceLock);

    return NO_ERROR;

} // FtpDeleteInterface


ULONG
FtpDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpDisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpDisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!FTP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpDisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpDisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~FTP_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (FTP_INTERFACE_BOUND(Interfacep)) {
        FtpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&FtpInterfaceLock);

    FTP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // FtpDisableInterface


ULONG
FtpEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpEnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpEnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (FTP_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpEnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpEnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= FTP_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (FTP_INTERFACE_ACTIVE(Interfacep)) {
        Error = FtpActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&FtpInterfaceLock);

    FTP_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // FtpEnableInterface


ULONG
FtpInitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("FtpInitializeInterfaceManagement");

    InitializeListHead(&FtpInterfaceList);
    __try {
        InitializeCriticalSection(&FtpInterfaceLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "FtpInitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }
    FtpFirewallIfCount = 0;

    return Error;

} // FtpInitializeInterfaceManagement


PFTP_INTERFACE
FtpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PFTP_INTERFACE - the interface, if found; otherwise, NULL.

Notes:

    Invoked internally from an arbitrary context, with 'FtpInterfaceLock'
    held by caller.

--*/

{
    PFTP_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("FtpLookupInterface");
    for (Link = FtpInterfaceList.Flink; Link != &FtpInterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, FTP_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // FtpLookupInterface


ULONG
FtpQueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpQueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpQueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!FTP_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpQueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_FTP_INTERFACE_INFO)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_FTP_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_FTP_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_FTP_INTERFACE_INFO);

    LeaveCriticalSection(&FtpInterfaceLock);

    FTP_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // FtpQueryInterface


VOID
FtpShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Notes:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PFTP_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("FtpShutdownInterfaceManagement");
    while (!IsListEmpty(&FtpInterfaceList)) {
        Link = RemoveHeadList(&FtpInterfaceList);
        Interfacep = CONTAINING_RECORD(Link, FTP_INTERFACE, Link);
        if (FTP_INTERFACE_ACTIVE(Interfacep)) {
            FtpDeactivateInterface(Interfacep);
        }
        FtpCleanupInterface(Interfacep);
    }
    DeleteCriticalSection(&FtpInterfaceLock);

} // FtpShutdownInterfaceManagement


VOID
FtpSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the FTP transparent
    proxy is neither installed nor running; it operates as expected,
    since the global information and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Notes:

    Invoked from an arbitrary context.

--*/

{
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpSignalNatInterface");

    EnterCriticalSection(&FtpGlobalInfoLock);
    if (!FtpGlobalInfo) {
        LeaveCriticalSection(&FtpGlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&FtpGlobalInfoLock);
    EnterCriticalSection(&FtpInterfaceLock);
    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        return;
    }
    FtpDeactivateInterface(Interfacep);
    if (FTP_INTERFACE_ACTIVE(Interfacep)) {
        FtpActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&FtpInterfaceLock);

} // FtpSignalNatInterface


ULONG
FtpUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Notes:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMFTP.C').

--*/

{
    PFTP_INTERFACE Interfacep;

    PROFILE("FtpUnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&FtpInterfaceLock);

    Interfacep = FtpLookupInterface(Index, NULL);
    if (Interfacep == NULL) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!FTP_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "FtpUnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' and 'mapped' flag
    //

    Interfacep->Flags &=
        ~(FTP_INTERFACE_FLAG_BOUND | FTP_INTERFACE_FLAG_MAPPED);

    //
    // Deactivate the interface, if necessary
    //

    if (FTP_INTERFACE_ENABLED(Interfacep)) {
        FtpDeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&FtpInterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingArray);
    Interfacep->BindingArray = NULL;
    Interfacep->BindingCount = 0;
    RELEASE_LOCK(Interfacep);

    FTP_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // FtpUnbindInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpio.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpio.c

Abstract:

    This module contains code for the FTP transparent proxy's network
    I/O completion routines.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include "ftpmsg.h"

VOID
FtpAcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of an accept operation
    on a FTP transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds the local and remote IP address and port
        for the connection.

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued
    an I/O completion packet from the common I/O completion port
    with which our stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhAcceptStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    SOCKET AcceptedSocket;
    PFTP_CONNECTION Connectionp;
    ULONG Error;
    PFTP_INTERFACE Interfacep;
    SOCKET ListeningSocket;
    PROFILE("FtpAcceptCompletionRoutine");
    do {
        AcceptedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PFTP_INTERFACE)Bufferp->Context;
        ListeningSocket = (SOCKET)Bufferp->Context2;

        //
        // Acquire three additional references to the interface
        // for the followup requests that we will issue below,
        // and lock the interface.
        //

        EnterCriticalSection(&FtpInterfaceLock);
        if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&FtpInterfaceLock);
            NhReleaseBuffer(Bufferp);
            NhDeleteStreamSocket(AcceptedSocket);
            break;
        }
        FTP_REFERENCE_INTERFACE(Interfacep);
        FTP_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&FtpInterfaceLock);
        ACQUIRE_LOCK(Interfacep);

        //
        // Process the accept-completion.
        // First look for an error code. If an error occurred
        // and the interface is no longer active, end the completion-handling.
        // Otherwise, attempt to reissue the accept-request.
        //

        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "FtpAcceptCompletionRoutine: error %d for interface %d",
                ErrorCode, Interfacep->Index
                );

            //
            // See if the interface is still active and, if so, reissue
            // the accept-request. Since we will not be creating an active
            // endpoint, we won't need the second reference to the interface.
            //

            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);

            if (!FTP_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhDeleteStreamSocket(AcceptedSocket);
            } else {

                //
                // Reissue the accept-request. Note that the callee is now
                // responsible for the reference we made to the interface.
                //

                Error =
                    FtpAcceptConnectionInterface(
                        Interfacep,
                        ListeningSocket,
                        AcceptedSocket,
                        Bufferp,
                        NULL
                        );
                RELEASE_LOCK(Interfacep);
                if (Error) {
                    NhReleaseBuffer(Bufferp);
                    NhDeleteStreamSocket(AcceptedSocket);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "FtpAcceptCompletionRoutine: error %d reissuing accept",
                        Error
                        );
                }
            }

            break;
        }

        //
        // Now see if the interface is operational.
        // If it isn't, we need to destroy the accepted socket
        // and return control.
        //

        if (!FTP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhDeleteStreamSocket(AcceptedSocket);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpAcceptCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&FtpStatistics.ConnectionsDropped)
                );
            break;
        }

        //
        // We now create a 'FTP_CONNECTION' for the new connection,
        // in the process launching operations for the connection.
        // The connection management module will handle the accepted socket
        // from here onward, and is responsible for the references to the
        // interface that were made above.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "FtpAcceptCompletionRoutine: socket %d accepting connection",
            ListeningSocket
            );
        Error =
            FtpCreateConnection(
                Interfacep,
                ListeningSocket,
                AcceptedSocket,
                Bufferp->Buffer,
                &Connectionp
                );
        if (Error) {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&FtpStatistics.ConnectionsDropped)
                );
        } else {
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&FtpStatistics.ConnectionsAccepted)
                );
        }

        //
        // Finally, issue an accept operation for the next connection-request
        // on the listening socket. Note that the callee is responsible
        // for releasing the reference to the interface in case of a failure.
        //

        Error =
            FtpAcceptConnectionInterface(
                Interfacep,
                ListeningSocket,
                INVALID_SOCKET,
                Bufferp,
                NULL
                );
        RELEASE_LOCK(Interfacep);
        if (Error) { NhReleaseBuffer(Bufferp); }

    } while(FALSE);

    FTP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_FTP();
} // FtpAcceptCompletionRoutine


VOID
FtpCloseEndpointNotificationRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon notification of a close operation
    on a FTP transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds context information for the closed socket.
        Note that we are not allowed to release this buffer here.

Return Value:

    none.

Environment:

    Runs in the context of a wait-thread.
    A reference to the component will have been made on our behalf
    by 'NhAcceptStreamSocket' or 'NhConnectStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.
    Both of these references are released here.

--*/

{
    SOCKET ClosedSocket;
    ULONG EndpointId;
    PFTP_INTERFACE Interfacep;
    PROFILE("FtpCloseEndpointNotificationRoutine");
    do {
        ClosedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PFTP_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);
        NhTrace(
            TRACE_FLAG_IO,
            "FtpCloseEndpointNotificationRoutine: endpoint %d socket %d "
            "closed, error %d",
            EndpointId, ClosedSocket, ErrorCode
            );

#if 0
        PFTP_ENDPOINT Endpointp;

        //
        // Lock the interface, and retrieve the endpoint whose socket has
        // been closed.
        //

        ACQUIRE_LOCK(Interfacep);
        Endpointp = FtpLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);
        if (Endpointp) {
            FtpCloseActiveEndpoint(Endpointp, ClosedSocket);
        }
        RELEASE_LOCK(Interfacep);
#endif
    } while(FALSE);

    FTP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_FTP();
} // FtpCloseEndpointNotificationRoutine


VOID
FtpConnectEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a connect operation
    on a FTP transparent proxy stream socket.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds the context information for the endpoint.
        Note that we are not allowed to release this buffer here.

Return Value:

    none.

Environment:

    Runs in the context of a wait-thread.
    A reference to the component will have been made on our behalf
    by 'NhConnectStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.
    Neither of these references may be released here; they are both
    released in the close-notification routine, which we are guaranteed
    will be invoked. (Eventually.)

--*/

{
    SOCKET ConnectedSocket;
    ULONG EndpointId;
    PFTP_ENDPOINT Endpointp;
    ULONG Error;
    PFTP_INTERFACE Interfacep;
    PROFILE("FtpConnectEndpointCompletionRoutine");
    do {
        ConnectedSocket = (SOCKET)Bufferp->Socket;
        Interfacep = (PFTP_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire two additional references to the interface
        // for the endpoint-activation that we will initiate below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&FtpInterfaceLock);
        if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&FtpInterfaceLock);
            break;
        }
        FTP_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&FtpInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = FtpLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // First look for an error code.
        // If an error occurred and the interface is still active,
        // destroy the endpoint.
        // If the interface is inactive, we're done, since the endpoint
        // will have already been destroyed.
        // If the interface is active but the endpoint has already
        // been destroyed, end this connection-attempt.
        //

        if (ErrorCode) {
            if (Endpointp) {
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpConnectEndpointCompletionRoutine: deleting endpoint %d "
                    "on error %d", EndpointId, ErrorCode
                    );
                FtpDeleteActiveEndpoint(Endpointp);
            }
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            break;
        } else if (!FTP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpConnectEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpConnectEndpointCompletionRoutine: endpoint %d removed",
                EndpointId
                );
            break;
        }

        //
        // We now activate the endpoint, beginning data transfer.
        // Note that it is the caller's responsibility to release
        // the two new references to the interface if an error occurs.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "FtpConnectEndpointCompletionRoutine: endpoint %d socket %d "
            "connected", EndpointId, ConnectedSocket
            );
        Error = FtpActivateActiveEndpoint(Interfacep, Endpointp);
        RELEASE_LOCK(Interfacep);

    } while(FALSE);

} // FtpConnectEndpointCompletionRoutine


VOID
FtpReadEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a read operation
    on a FTP transparent proxy stream socket.

    The contexts for all reads are the interface and endpoint-identifier
    corresponding to the socket, stored in 'Context' and 'Context2',
    respectively.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the socket

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued an
    I/O completion packet from the common I/O completion port with which
    our stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhReadStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    ULONG EndpointId;
    PFTP_ENDPOINT Endpointp;
    ULONG Error;
    PFTP_INTERFACE Interfacep;
    PROFILE("FtpReadEndpointCompletionRoutine");
    do {
        Interfacep = (PFTP_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire two additional references to the interface
        // for the followup requests that we will issue below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&FtpInterfaceLock);
        if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&FtpInterfaceLock);
            NhReleaseBuffer(Bufferp);
            break;
        }
        FTP_REFERENCE_INTERFACE(Interfacep);
        LeaveCriticalSection(&FtpInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = FtpLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // Process the read-completion. First we look for an error-code,
        // and if we find one, we decide whether to re-issue the read-request.
        // If the interface is still active, the error-code is non-fatal, and
        // the endpoint still exists, we reissue the read.
        //

        if (ErrorCode) {

            //
            // We won't be needing the second reference to the interface,
            // since we won't be calling 'FtpProcessMessage.
            //

            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpReadEndpointCompletionRoutine: error %d for endpoint %d",
                ErrorCode, EndpointId
                );
            if (!FTP_INTERFACE_ACTIVE(Interfacep) || !Endpointp) {
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else if (NhIsFatalSocketError(ErrorCode)) {
                FtpDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpReadEndpointCompletionRoutine: deleting endpoint %d "
                    "on fatal read-error %d", EndpointId, ErrorCode
                    );
            } else {

                //
                // We need to repost the buffer for another read operation,
                // so we now reissue a read for the same number of bytes as
                // before.
                //

                Error =
                    NhReadStreamSocket(
                        &FtpComponentReference,
                        Bufferp->Socket,
                        Bufferp,
                        Bufferp->BytesToTransfer,
                        Bufferp->TransferOffset,
                        FtpReadEndpointCompletionRoutine,
                        Bufferp->Context,
                        Bufferp->Context2
                        );
                if (Error) {
                    FtpDeleteActiveEndpoint(Endpointp);
                    RELEASE_LOCK(Interfacep);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "FtpReadEndpointCompletionRoutine: deleting endpoint "
                        "%d, NhReadStreamSocket=%d", EndpointId, Error
                        );
                    if (Error != ERROR_NETNAME_DELETED) {
                        NhWarningLog(
                            IP_FTP_LOG_RECEIVE_FAILED,
                            Error,
                            "%I",
                            NhQueryAddressSocket(Bufferp->Socket)
                            );
                    }
                    NhReleaseBuffer(Bufferp);
                    break;
                }

                RELEASE_LOCK(Interfacep);
            }

            break;
        } else if (!BytesTransferred) {

            //
            // Zero bytes were read from the endpoint's socket.
            // This indicates that the sender has closed the socket.
            // We now propagate the closure to the alternate socket
            // for the endpoint. When the 'other' sender is done,
            // this endpoint will be removed altogether.
            //

            NhTrace(
                TRACE_FLAG_IO,
                "FtpReadEndpointCompletionRoutine: endpoint %d socket %d "
                "closed", EndpointId, Bufferp->Socket
                );
            if (Endpointp) {
                FtpCloseActiveEndpoint(Endpointp, Bufferp->Socket);
            }
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            break;
        }

        //
        // The original request completed successfully.
        // Now see if the interface and endpoint are operational and,
        // if not, return control.
        //

        if (!FTP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpReadEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpReadEndpointCompletionRoutine: endpoint %d not found",
                EndpointId
                );
            break;
        }

        //
        // Record the number of bytes read, and issue a read-request
        // for the remainder if necessary. Otherwise, process the completed
        // message.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "FtpReadEndpointCompletionRoutine: endpoint %d socket %d read %d "
            "bytes", EndpointId, Bufferp->Socket, BytesTransferred
            );
        ASSERT(BytesTransferred <= Bufferp->BytesToTransfer);
        Bufferp->BytesToTransfer -= BytesTransferred;
        Bufferp->TransferOffset += BytesTransferred;

        if (Bufferp->BytesToTransfer > 0 &&
            FtpIsFullMessage(
                reinterpret_cast<CHAR*>(Bufferp->Buffer),
                Bufferp->TransferOffset
                ) == NULL) {

            //
            // Read the remainder of the message, after releasing
            // the second reference to the interface, which is needed
            // only when we call 'FtpProcessMessage'.
            //

            FTP_DEREFERENCE_INTERFACE(Interfacep);

            Error =
                NhReadStreamSocket(
                    &FtpComponentReference,
                    Bufferp->Socket,
                    Bufferp,
                    Bufferp->BytesToTransfer,
                    Bufferp->TransferOffset,
                    FtpReadEndpointCompletionRoutine,
                    Bufferp->Context,
                    Bufferp->Context2
                    );
            if (Error) {
                FtpDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpReadEndpointCompletionRoutine: deleting endpoint "
                    "%d, NhReadStreamSocket=%d", EndpointId, Error
                    );
                if (Error != ERROR_NETNAME_DELETED) {
                    NhWarningLog(
                        IP_FTP_LOG_RECEIVE_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                }
                NhReleaseBuffer(Bufferp);
                break;
            }
        } else {

            //
            // We've finished reading something. Process it.
            //

            FtpProcessMessage(Interfacep, Endpointp, Bufferp);
        }

        RELEASE_LOCK(Interfacep);

    } while(FALSE);

    FTP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_FTP();

} // FtpReadEndpointCompletionRoutine


VOID
FtpWriteEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is invoked upon completion of a write-operation
    on a stream socket for a FTP control-channel connection.

    The contexts for all writes are the interface and endpoint-identifier
    corresponding to the socket, stored in 'Context' and 'Context2',
    respectively.

Arguments:

    ErrorCode - Win32 status code for the I/O operation

    BytesTransferred - number of bytes in 'Bufferp'

    Bufferp - holds data read from the stream socket

Return Value:

    none.

Environment:

    Runs in the context of a worker-thread which has just dequeued an
    I/O completion packet from the common I/O completion port with which our
    stream sockets are associated.
    A reference to the component will have been made on our behalf
    by 'NhWriteStreamSocket'.
    A reference to the interface will have been made on our behalf
    by whoever issued the I/O request.

--*/

{
    ULONG Error;
    ULONG EndpointId;
    PFTP_ENDPOINT Endpointp;
    PFTP_INTERFACE Interfacep;
    PROFILE("FtpWriteEndpointCompletionRoutine");
    do {
        Interfacep = (PFTP_INTERFACE)Bufferp->Context;
        EndpointId = PtrToUlong(Bufferp->Context2);

        //
        // Acquire an additional reference to the interface
        // for the followup requests that we will issue below,
        // lock the interface, and retrieve the endpoint.
        //

        EnterCriticalSection(&FtpInterfaceLock);
        if (!FTP_REFERENCE_INTERFACE(Interfacep)) {
            LeaveCriticalSection(&FtpInterfaceLock);
            NhReleaseBuffer(Bufferp);
            break;
        }
        LeaveCriticalSection(&FtpInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Endpointp = FtpLookupInterfaceEndpoint(Interfacep, EndpointId, NULL);

        //
        // Process the write-completion. First we look for an error-code,
        // and if we find one, we decide whether to re-issue the write-request.
        // If the interface is still active, the error-code is non-fatal, and
        // the endpoint still exists, we reissue the write.
        //

        if (ErrorCode) {
            NhTrace(
                TRACE_FLAG_IO,
                "FtpWriteEndpointCompletionRoutine: error %d for endpoint %d",
                ErrorCode, EndpointId
                );
            if (!FTP_INTERFACE_ACTIVE(Interfacep) || !Endpointp) {
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
            } else if (NhIsFatalSocketError(ErrorCode)) {
                FtpDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhReleaseBuffer(Bufferp);
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpWriteEndpointCompletionRoutine: deleting endpoint %d "
                    "on fatal write-error %d", EndpointId, ErrorCode
                    );
            } else {

                //
                // We need to repost the buffer for another write operation,
                // so we now reissue a write for the same number of bytes
                // as before.
                //

                Error =
                    NhWriteStreamSocket(
                        &FtpComponentReference,
                        Bufferp->Socket,
                        Bufferp,
                        Bufferp->BytesToTransfer,
                        Bufferp->TransferOffset,
                        FtpWriteEndpointCompletionRoutine,
                        Bufferp->Context,
                        Bufferp->Context2
                        );
                if (Error) {
                    FtpDeleteActiveEndpoint(Endpointp);
                    RELEASE_LOCK(Interfacep);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    NhTrace(
                        TRACE_FLAG_IO,
                        "FtpWriteEndpointCompletionRoutine: deleting endpoint "
                        "%d, NhWriteStreamSocket=%d", EndpointId, Error
                        );
                    NhWarningLog(
                        IP_FTP_LOG_SEND_FAILED,
                        Error,
                        "%I",
                        NhQueryAddressSocket(Bufferp->Socket)
                        );
                    NhReleaseBuffer(Bufferp);
                    break;
                }

                RELEASE_LOCK(Interfacep);
            }

            break;
        }

        //
        // The original request completed successfully.
        // Now see if the interface and endpoint are operational and,
        // if not, return control.
        //

        if (!FTP_INTERFACE_ACTIVE(Interfacep)) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpWriteEndpointCompletionRoutine: interface %d inactive",
                Interfacep->Index
                );
            break;
        } else if (!Endpointp) {
            RELEASE_LOCK(Interfacep);
            FTP_DEREFERENCE_INTERFACE(Interfacep);
            NhReleaseBuffer(Bufferp);
            NhTrace(
                TRACE_FLAG_IO,
                "FtpWriteEndpointCompletionRoutine: endpoint %d not found",
                EndpointId
                );
            break;
        }

        //
        // Record the number of bytes written, and issue a write-request
        // for the remainder if necessary. Otherwise, we are done,
        // and we return to reading from the 'other' socket for the
        // control-channel.
        //

        NhTrace(
            TRACE_FLAG_IO,
            "FtpWriteEndpointCompletionRoutine: endpoint %d socket %d wrote %d "
            "bytes", EndpointId, Bufferp->Socket, BytesTransferred
            );

        ASSERT(BytesTransferred <= Bufferp->BytesToTransfer);
        Bufferp->BytesToTransfer -= BytesTransferred;
        Bufferp->TransferOffset += BytesTransferred;
        if (Bufferp->BytesToTransfer) {

            //
            // Write the remainder of the message
            //

            Error =
                NhWriteStreamSocket(
                    &FtpComponentReference,
                    Bufferp->Socket,
                    Bufferp,
                    Bufferp->BytesToTransfer,
                    Bufferp->TransferOffset,
                    FtpWriteEndpointCompletionRoutine,
                    Bufferp->Context,
                    Bufferp->Context2
                    );
            if (Error) {
                FtpDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpWriteEndpointCompletionRoutine: deleting endpoint %d, "
                    "NhWriteStreamSocket=%d", EndpointId, Error
                    );
                NhWarningLog(
                    IP_FTP_LOG_SEND_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Bufferp->Socket)
                    );
                NhReleaseBuffer(Bufferp);
                break;
            }
        } else {
            SOCKET Socket;
            ULONG UserFlags;

            //
            // We now go back to reading from the other socket of the
            // endpoint, by issuing the next read on the endpoint's other
            // socket. Note that it is the responsibility of the callee
            // to release the reference to the interface if a failure occurs.
            //

            UserFlags = Bufferp->UserFlags;
            if (UserFlags & FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT) {
                Socket = Endpointp->HostSocket;
                UserFlags &= ~(ULONG)FTP_BUFFER_FLAG_CONTINUATION;
                UserFlags |= FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT;
            } else {
                Socket = Endpointp->ClientSocket;
                UserFlags &= ~(ULONG)FTP_BUFFER_FLAG_CONTINUATION;
                UserFlags |= FTP_BUFFER_FLAG_FROM_ACTUAL_HOST;
            }
            NhReleaseBuffer(Bufferp);
            Error =
                FtpReadActiveEndpoint(
                    Interfacep,
                    Endpointp,
                    Socket,
                    UserFlags
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_IO,
                    "FtpWriteEndpointCompletionRoutine: deleting endpoint %d, "
                    "FtpReadActiveEndpoint=%d", EndpointId, Error
                    );
                FtpDeleteActiveEndpoint(Endpointp);
                RELEASE_LOCK(Interfacep);
                NhWarningLog(
                    IP_FTP_LOG_RECEIVE_FAILED,
                    Error,
                    "%I",
                    NhQueryAddressSocket(Socket)
                    );
                break;
            }
        }

        RELEASE_LOCK(Interfacep);

    } while(FALSE);

    FTP_DEREFERENCE_INTERFACE(Interfacep);
    DEREFERENCE_FTP();

} // FtpWriteEndpointCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpio.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpio.h

Abstract:

    This module contains declarations for the FTP transparent proxy's
    network I/O completion routines.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_FTPIO_H_
#define _NATHLP_FTPIO_H_

VOID
FtpAcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
FtpCloseEndpointNotificationRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
FtpConnectEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
FtpReadEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

VOID
FtpWriteEndpointCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    );

#endif // _NATHLP_FTPIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpconn.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpconn.c

Abstract:

    This module contains code for the FTP transparent proxy's connection
    management.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>
#include <mswsock.h>
#include <rasuip.h>

ULONG FtpNextConnectionId = 0;
ULONG FtpNextEndpointId = 0;

typedef struct _FTP_CLOSE_CONNECTION_CONTEXT {
    ULONG InterfaceIndex;
    ULONG ConnectionId;
} FTP_CLOSE_CONNECTION_CONTEXT, *PFTP_CLOSE_CONNECTION_CONTEXT;

//
// FORWARD DECLARATIONS
//

ULONG NTAPI
FtppCloseConnectionWorkerRoutine(
    PVOID Context
    );


ULONG
FtpActivateActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp
    )

/*++

Routine Description:

    This routine is invoked to initiate data transfer on an active endpoint
    once it is connected to both the client and the host.

Arguments:

    Interfacep - the interface on which the endpoint was accepted

    Endpointp - the endpoint to be activated

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on behalf of the read-requests that will
    be issued here. If a failure occurs, it is this routine's responsibility
    to release those references.

--*/

{
    ULONG Error;
    PROFILE("FtpActivateActiveEndpoint");

    //
    // Clear the 'initial-endpoint' flag on the endpoint,
    // now that it is successfully connected.
    //

    Endpointp->Flags &= ~FTP_ENDPOINT_FLAG_INITIAL_ENDPOINT;

    //
    // Initiate read-requests on each of the endpoint's sockets.
    // Note that it is the callee's responsibility to release the references
    // made to the interface on our behalf.
    //

    Error =
        FtpReadActiveEndpoint(
            Interfacep,
            Endpointp,
            Endpointp->ClientSocket,
            FTP_BUFFER_FLAG_FROM_ACTUAL_HOST
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpActivateActiveEndpoint: read error %d",
            Error
            );
        FTP_DEREFERENCE_INTERFACE(Interfacep);
    } else {
        Error =
            FtpReadActiveEndpoint(
                Interfacep,
                Endpointp,
                Endpointp->HostSocket,
                FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT
                );
    }
    return Error;
} // FtpActivateActiveEndpoint


VOID
FtpCloseActiveEndpoint(
    PFTP_ENDPOINT Endpointp,
    SOCKET ClosedSocket
    )

/*++

Routine Description:

    This routine is invoked when a graceful close indication is received
    on one of the sockets for an endpoint. If both the client and the host
    have closed their sockets, the endpoint is deleted here.

Arguments:

    Endpointp - the endpoint for the closed socket

    ClosedSocket - the socket whose remote end has been closed

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PROFILE("FtpCloseActiveEndpoint");

    //
    // Propagate the shutdown from one control-channel socket to the other,
    // i.e. from client to server or server to client.
    //

    if (ClosedSocket == Endpointp->ClientSocket) {
        if (Endpointp->Flags & FTP_ENDPOINT_FLAG_CLIENT_CLOSED) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCloseActiveEndpoint: endpoint %d client-end already closed",
                Endpointp->EndpointId
                );
            return;
        }
        shutdown(Endpointp->HostSocket, SD_SEND);
        Endpointp->Flags |= FTP_ENDPOINT_FLAG_CLIENT_CLOSED;
    } else {
        if (Endpointp->Flags & FTP_ENDPOINT_FLAG_HOST_CLOSED) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCloseActiveEndpoint: endpoint %d host-end already closed",
                Endpointp->EndpointId
                );
            return;
        }
        shutdown(Endpointp->ClientSocket, SD_SEND);
        Endpointp->Flags |= FTP_ENDPOINT_FLAG_HOST_CLOSED;
    }

    //
    // If both the client and server have closed their ends of the endpoint
    // we can close the sockets and delete the endpoint.
    //

    if ((Endpointp->Flags & FTP_ENDPOINT_FLAG_CLIENT_CLOSED) &&
        (Endpointp->Flags & FTP_ENDPOINT_FLAG_HOST_CLOSED)) {
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpCloseActiveEndpoint: both sockets closed, deleting endpoint %d",
            Endpointp->EndpointId
            );
        FtpDeleteActiveEndpoint(Endpointp);
    }
} // FtpCloseActiveEndpoint


ULONG
FtpCreateActiveEndpoint(
    PFTP_CONNECTION Connectionp,
    FTP_ENDPOINT_TYPE Type,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    ULONG TargetAddress,
    USHORT TargetPort,
    ULONG BoundaryAddress,
    OUT PFTP_ENDPOINT* EndpointCreated OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a new active endpoint when a TCP
    connection is accepted. It creates an entry for the new endpoint
    and initiates a connection-attempt to the ultimate destination
    as specified by 'Type' and 'TargetPort'.

Arguments:

    Connectionp - the connection on which the TCP connection was accepted

    Type - indicates whether the TCP connection is from a client or a host

    ListeningSocket - the listening socket on which the TCP connection was
        accepted

    AcceptedSocket - the local socket for the accepted TCP connection

    AcceptBuffer - buffer holding connection-acceptance information

    TargetAddress - the IP address to which the secondary proxy connection
        must be made on the alternate socket for the new endpoint

    TargetPort - the port to which the secondary proxy connection must be made
        on the alternate socket for the new endpoint

    BoundaryAddress - the IP address of the boundary interface from which the
        first proxy connection is from
    EndpointCreated - on output, optionally receives the newly created
        endpoint

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface for the connection-attempt which is
    initiated here and the close-notification which is requested on the
    accepted socket. If a failure occurs, it is this routine's responsibility
    to release those references.

--*/

{
    PFTP_ENDPOINT Endpointp = NULL;
    ULONG Error;
    PLIST_ENTRY InsertionPoint;
    PFTP_INTERFACE Interfacep = Connectionp->Interfacep;
    ULONG Length;
    SOCKADDR_IN SockAddr;
    SOCKET UdpSocket;
    PROFILE("FtpCreateActiveEndpoint");
    do {
        //
        // Update the context associated with the accepted socket,
        // to allow Winsock routines to be used with the resulting file-handle.
        //

        Error =
            setsockopt(
                AcceptedSocket,
                SOL_SOCKET,
                SO_UPDATE_ACCEPT_CONTEXT,
                (PCHAR)&ListeningSocket,
                sizeof(ListeningSocket)
                );
        if (Error == SOCKET_ERROR) {
            Error = WSAGetLastError();
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateActiveEndpoint: error %d updating accept context",
                Error
                );
            break;
        }

        //
        // Allocate and initialize a new endpoint, and insert it in the list
        // of endpoints for its interface, as well as the list of active
        // endpoints for its connection.
        //

        Endpointp = reinterpret_cast<PFTP_ENDPOINT>(
                        NH_ALLOCATE(sizeof(*Endpointp))
                        );
        if (!Endpointp) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        ZeroMemory(Endpointp, sizeof(*Endpointp));
        Endpointp->EndpointId = InterlockedIncrement(
                                    reinterpret_cast<LPLONG>(&FtpNextEndpointId)
                                    );
        Endpointp->ConnectionId = Connectionp->ConnectionId;
        Endpointp->Interfacep = Interfacep;
        FtpLookupInterfaceEndpoint(
            Interfacep, Endpointp->EndpointId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Endpointp->InterfaceLink);
        FtpLookupActiveEndpoint(
            Connectionp, Endpointp->EndpointId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Endpointp->ConnectionLink);
        Endpointp->Type = Type;
        Endpointp->ClientSocket = INVALID_SOCKET;
        Endpointp->HostSocket = INVALID_SOCKET;
        Endpointp->BoundaryAddress = BoundaryAddress;

        //
        // We create a temporary UDP socket, connect the socket to the
        // actual client's IP address, extract the IP address to which
        // the socket is implicitly bound by the TCP/IP driver, and
        // discard the socket. This leaves us with the exact IP address
        // that we need to use to contact the client.
        //

        SockAddr.sin_family = AF_INET;
        SockAddr.sin_port = 0;
        SockAddr.sin_addr.s_addr = TargetAddress;
        Length = sizeof(SockAddr);
        if ((UdpSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) ==
                INVALID_SOCKET ||
            connect(UdpSocket, (PSOCKADDR)&SockAddr, sizeof(SockAddr)) ==
                SOCKET_ERROR ||
            getsockname(UdpSocket, (PSOCKADDR)&SockAddr, (int*)&Length) ==
                SOCKET_ERROR) {
            Error = WSAGetLastError();
            if (Error == WSAEHOSTUNREACH && Type == FtpHostEndpointType) {
                Error = RasAutoDialSharedConnection();
                if (Error != ERROR_SUCCESS) {
                    NhTrace(
                        TRACE_FLAG_FTP,
                        "FtpCreateActiveEndpoint:"
                        " RasAutoDialSharedConnection failed [%d]",
                        Error
                        );
                    if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    break;
                }
            } else {
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpCreateActiveEndpoint: error %d routing endpoint %d "
                    "using UDP", Error, Endpointp->EndpointId
                    );
                if (UdpSocket != INVALID_SOCKET) { closesocket(UdpSocket); }
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }
        }
        closesocket(UdpSocket);

        //
        // Check the type of the endpoint before proceeding further:
        //  'FtpClientEndpointType' - the endpoint was accepted on a client's
        //      behalf from a remote host
        //  'FtpHostEndpointType' - the endpoint was accepted on a host's
        //      behalf from a remote client
        //

        if (Type == FtpClientEndpointType) {

            //
            // This active endpoint was accepted on behalf of a client.
            //

            Endpointp->ClientSocket = AcceptedSocket;
            Endpointp->ActualClientAddress = TargetAddress;
            Endpointp->ActualClientPort = TargetPort;
            NhQueryAcceptEndpoints(
                AcceptBuffer,
                NULL,
                NULL,
                &Endpointp->ActualHostAddress,
                &Endpointp->ActualHostPort
                );

            //
            // We now need to initiate a proxy connection to the actual client.
            // Before doing so, we need to bind to a specific IP address,
            // and issue a redirect so that the actual client will think
            // that our connection-request is coming from the actual host.
            // Create a stream socket bound to the extracted IP address,
            // determine the socket's port number, and create a redirect
            // to transform our connection-request in the eyes of the client.
            //

            Error =
                NhCreateStreamSocket(
                    SockAddr.sin_addr.s_addr, 0, &Endpointp->HostSocket
                    );
            if (Error) {
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }
            EnterCriticalSection(&FtpGlobalInfoLock);
            Error =
                NatCreateRedirectEx(
                    FtpTranslatorHandle,
                    NatRedirectFlagLoopback,
                    NAT_PROTOCOL_TCP,
                    Endpointp->ActualClientAddress,
                    Endpointp->ActualClientPort,
                    SockAddr.sin_addr.s_addr,
                    NhQueryPortSocket(Endpointp->HostSocket),
                    TargetAddress,
                    TargetPort,
                    Endpointp->ActualHostAddress,
                    Endpointp->ActualHostPort,
                    0,
                    NULL,
                    NULL,
                    NULL
                    );
            LeaveCriticalSection(&FtpGlobalInfoLock);
            if (Error) {
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpCreateActiveEndpoint: error %d creating redirect",
                    Error
                    );
                break;
            }

            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateActiveEndpoint: endpoint %d connecting socket %d "
                "to client at %s/%d",
                Endpointp->EndpointId, Endpointp->HostSocket,
                INET_NTOA(TargetAddress), RtlUshortByteSwap(TargetPort)
                );
            Error =
                NhConnectStreamSocket(
                    &FtpComponentReference,
                    Endpointp->HostSocket,
                    TargetAddress,
                    TargetPort,
                    NULL,
                    FtpConnectEndpointCompletionRoutine,
                    FtpCloseEndpointNotificationRoutine,
                    Interfacep,
                    UlongToPtr(Endpointp->EndpointId)
                    );
            if (Error) {
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpCreateActiveEndpoint: error %d connecting to %s",
                    Error,
                    INET_NTOA(TargetAddress)
                    );
                break;
            }
        } else {
            ULONG AddressToUse;

            //
            // This active endpoint was accepted on behalf of a host.
            // We now initiate a proxy connection to the actual host.
            //

            Endpointp->HostSocket = AcceptedSocket;
            Endpointp->ActualHostAddress = TargetAddress;
            Endpointp->ActualHostPort = TargetPort;
            NhQueryAcceptEndpoints(
                AcceptBuffer,
                NULL,
                NULL,
                &Endpointp->ActualClientAddress,
                &Endpointp->ActualClientPort
                );

            //
            // If we grabbed a send address above, use it to bind the
            // socket; otherwise, leave the address unspecified
            //

            AddressToUse = FtpFirewallIfCount
                               ? SockAddr.sin_addr.s_addr
                               : INADDR_NONE;
            //
            // Initiate a connection to the actual host
            //

            Error =
                NhCreateStreamSocket(
                    AddressToUse, 0, &Endpointp->ClientSocket
                    );
            if (Error) {
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                break;
            }

            //
            // If we have a firwewall interface, possibly install a
            // shadow redirect for this connection. The shadow redirect
            // is necessary to prevent this connection from also being
            // redirected to the proxy (setting in motion an infinite loop...)
            //

            if (FtpFirewallIfCount) {
                ULONG SourceAddress =
                    NhQueryAddressSocket(Endpointp->ClientSocket);
                USHORT SourcePort =
                    NhQueryPortSocket(Endpointp->ClientSocket);

                Error =
                    NatCreateRedirectEx(
                        FtpTranslatorHandle,
                        0,
                        NAT_PROTOCOL_TCP,
                        TargetAddress,
                        TargetPort,
                        SourceAddress,
                        SourcePort,
                        TargetAddress,
                        TargetPort,
                        SourceAddress,
                        SourcePort,
                        0,
                        NULL,
                        NULL,
                        NULL
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_FTP,
                        "FtpCreateActiveEndpoint: Unable to create shadow"
                        " redirect for connection to %s/%d",
                        INET_NTOA(TargetAddress),
                        RtlUshortByteSwap(TargetPort)
                        );

                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    break;
                }
            }

            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateActiveEndpoint: endpoint %d connecting socket %d "
                "to host at %s/%d",
                Endpointp->EndpointId, Endpointp->ClientSocket,
                INET_NTOA(TargetAddress), RtlUshortByteSwap(TargetPort)
                );
            Error =
                NhConnectStreamSocket(
                    &FtpComponentReference,
                    Endpointp->ClientSocket,
                    TargetAddress,
                    TargetPort,
                    NULL,
                    FtpConnectEndpointCompletionRoutine,
                    FtpCloseEndpointNotificationRoutine,
                    Interfacep,
                    UlongToPtr(Endpointp->EndpointId)
                    );
            if (Error) {
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                FTP_DEREFERENCE_INTERFACE(Interfacep);
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpCreateActiveEndpoint: error %d connecting to host %s",
                    Error,
                    INET_NTOA(TargetAddress)
                    );
                break;
            }
        }

        FTP_DEREFERENCE_INTERFACE(Interfacep);

        if (EndpointCreated) { *EndpointCreated = Endpointp; }
        return NO_ERROR;
    } while(FALSE);
    if (Endpointp) {
        FtpDeleteActiveEndpoint(Endpointp);
    } else {
        NhDeleteStreamSocket(AcceptedSocket);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
    }
    return Error;
} // FtpCreateActiveEndpoint


ULONG
FtpCreateConnection(
    PFTP_INTERFACE Interfacep,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket,
    PUCHAR AcceptBuffer,
    PFTP_CONNECTION* ConnectionCreated OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to create a connection-object corresponding
    to a newly-accepted connection. It creates and inserts the entry,
    queries the kernel-mode translator to determine the client's target server,
    and creates an active endpoint which is connected to that server.

Arguments:

    Interfacep - the interface on which the connection was accepted

    ListeningSocket - the socket on which the connection was accepted

    AcceptedSocket - the accepted socket

    AcceptBuffer - contains address/port information for the local and remote
        endpoints.

    ConnectionCreated - on output, optionally receives a pointer
        to the connection created

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on behalf of this routine. If a failure
    occurs here, this routine is responsible for releasing those references.

--*/

{
    PFTP_CONNECTION Connectionp = NULL;
    PFTP_ENDPOINT Endpointp = NULL;
    ULONG Error;
    PLIST_ENTRY InsertionPoint;
    ULONG LocalAddress;
    USHORT LocalPort;
    ULONG Length;
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION Key;
    ULONG ActualClientAddress;
    USHORT ActualClientPort;
    IP_NAT_PORT_MAPPING PortMapping;
    PROFILE("FtpCreateConnection");

    do {
        //
        // Retrieve the local and remote endpoint information from the
        // connection-acceptance buffer, and use them to query the kernel-mode
        // translation module for the host to which the client was destined
        // before we redirected it to our listening socket.
        //

        NhQueryAcceptEndpoints(
            AcceptBuffer,
            &LocalAddress,
            &LocalPort,
            &ActualClientAddress,
            &ActualClientPort
            );
        Length = sizeof(Key);
        EnterCriticalSection(&FtpGlobalInfoLock);
        Error =
            NatLookupAndQueryInformationSessionMapping(
                FtpTranslatorHandle,
                NAT_PROTOCOL_TCP,
                LocalAddress,
                LocalPort,
                ActualClientAddress,
                ActualClientPort,
                &Key,
                &Length,
                NatKeySessionMappingExInformation
                );
        LeaveCriticalSection(&FtpGlobalInfoLock);
        if (Error) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateConnection: error %d querying session-mapping",
                Error
                );
            break;
        } else {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateConnection: accepted client for %s/%d",
                INET_NTOA(Key.DestinationAddress), ntohs(Key.DestinationPort)
                );
        }

        //
        // Create and initialize a new connection.
        //

        Connectionp = reinterpret_cast<PFTP_CONNECTION>(
                        NH_ALLOCATE(sizeof(*Connectionp))
                        );
        if (!Connectionp) { Error = ERROR_NOT_ENOUGH_MEMORY; break; }
        ZeroMemory(Connectionp, sizeof(Connectionp));
        Connectionp->ConnectionId =
            InterlockedIncrement(
                reinterpret_cast<LPLONG>(&FtpNextConnectionId)
                );
        FtpLookupConnection(
            Interfacep, Connectionp->ConnectionId, &InsertionPoint
            );
        InsertTailList(InsertionPoint, &Connectionp->Link);
        Connectionp->Interfacep = Interfacep;
        InitializeListHead(&Connectionp->ActiveEndpointList);

        //
        // Create a new active endpoint, which will contact the client's
        // actual host and transfer data between the client and the host.
        // Note that the callee will release the two references to the
        // interface if a failure occurs. Once the endpoint is created,
        // we set the 'initial-endpoint' flag on it before releasing
        // the interface lock. This ensures that if the endpoint cannot
        // connect to the actual host, we delete the whole connection.
        // The flag is later cleared in 'FtpActivateActiveEndpoint'
        // when the endpoint is activated.
        //
        if (NAT_IFC_BOUNDARY(Interfacep->Characteristics) &&
            Interfacep->AdapterIndex ==
                NhMapAddressToAdapter(Key.DestinationAddress)) {
            //
            // Inbound
            //
            ASSERT(FTP_INTERFACE_MAPPED(Interfacep));

            Error =
                FtpCreateActiveEndpoint(
                    Connectionp,
                    FtpClientEndpointType,
                    ListeningSocket,
                    AcceptedSocket,
                    AcceptBuffer,
                    Interfacep->PortMapping.PrivateAddress,
                    Interfacep->PortMapping.PrivatePort,
                    Key.DestinationAddress,
                    &Endpointp
                    );
        } else {
            //
            // Outbound
            //
            Error =
                FtpCreateActiveEndpoint(
                    Connectionp,
                    FtpHostEndpointType,
                    ListeningSocket,
                    AcceptedSocket,
                    AcceptBuffer,
                    Key.DestinationAddress,
                    Key.DestinationPort,
                    IP_NAT_ADDRESS_UNSPECIFIED,
                    &Endpointp
                    );
        }
        if (Error) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtpCreateConnection: error %d creating active endpoint",
                Error
                );
            break;
        } else {
            Endpointp->Flags |= FTP_ENDPOINT_FLAG_INITIAL_ENDPOINT;
        }

        if (ConnectionCreated) { *ConnectionCreated = Connectionp; }
        return NO_ERROR;

    } while(FALSE);
    if (Connectionp) {
        FtpDeleteConnection(Connectionp);
    } else {
        NhDeleteStreamSocket(AcceptedSocket);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
    }
    return Error;
}


VOID
FtpDeleteActiveEndpoint(
    PFTP_ENDPOINT Endpointp
    )

/*++

Routine Description:

    This routine is invoked to destroy an active endpoint.

Arguments:

    Endpoint - the endpoint to be destroyed

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PFTP_INTERFACE Interfacep;
    PFTP_CONNECTION Connectionp = NULL;
    PROFILE("FtpDeleteActiveEndpoint");
    RemoveEntryList(&Endpointp->ConnectionLink);
    RemoveEntryList(&Endpointp->InterfaceLink);
    if (Endpointp->ClientSocket != INVALID_SOCKET) {
        NhDeleteStreamSocket(Endpointp->ClientSocket);
    }
    if (Endpointp->HostSocket != INVALID_SOCKET) {
        NhDeleteStreamSocket(Endpointp->HostSocket);
    }
    if (Endpointp->ReservedPort != 0) {
        PTIMER_CONTEXT TimerContextp;

        NatCancelRedirect(
            FtpTranslatorHandle,
            NAT_PROTOCOL_TCP,
            Endpointp->DestinationAddress,
            Endpointp->DestinationPort,
            Endpointp->SourceAddress,
            Endpointp->SourcePort,
            Endpointp->NewDestinationAddress,
            Endpointp->NewDestinationPort,
            Endpointp->NewSourceAddress,
            Endpointp->NewSourcePort
            );
            TimerContextp = reinterpret_cast<PTIMER_CONTEXT>(
                                NH_ALLOCATE(sizeof(TIMER_CONTEXT))
                                );
            if (TimerContextp != NULL) {
                TimerContextp->TimerQueueHandle = FtpTimerQueueHandle;
                TimerContextp->ReservedPort = Endpointp->ReservedPort;
                CreateTimerQueueTimer(
                    &(TimerContextp->TimerHandle),
                    FtpTimerQueueHandle,
                    FtpDelayedPortRelease,
                    (PVOID)TimerContextp,
                    FTP_PORT_RELEASE_DELAY,
                    0,
                    WT_EXECUTEDEFAULT
                    );
            } else {
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpDeleteActiveEndpoint:"
                    " memory allocation failed for timer context"
                    );
                NhErrorLog(
                    IP_FTP_LOG_ALLOCATION_FAILED,
                    0,
                    "%d",
                    sizeof(TIMER_CONTEXT)
                    );
            }
        Endpointp->ReservedPort = 0;
    }

    //
    // If this endpoint is the first one for the connection and a failure
    // occurred before it ever even connected to the actual host, or if this
    // endpoint is the last one for the connection and it has been deleted,
    // queue a work-item to delete the connection.
    //

    EnterCriticalSection(&FtpInterfaceLock);
    Interfacep = FtpLookupInterface(Endpointp->Interfacep->Index, NULL);
    if (!Interfacep || !FTP_REFERENCE_INTERFACE(Interfacep)) {
        Interfacep = NULL;
    }
    LeaveCriticalSection(&FtpInterfaceLock);
    if (Interfacep != NULL) {
        ACQUIRE_LOCK(Interfacep);
        Connectionp =
            FtpLookupConnection(Interfacep, Endpointp->ConnectionId, NULL);
        if (Connectionp != NULL &&
            IsListEmpty(&Connectionp->ActiveEndpointList)) {
            Endpointp->Flags |= FTP_ENDPOINT_FLAG_DELETE_CONNECTION;
        }
        RELEASE_LOCK(Interfacep);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
    }

    if ((Endpointp->Flags &
         (FTP_ENDPOINT_FLAG_INITIAL_ENDPOINT |
          FTP_ENDPOINT_FLAG_DELETE_CONNECTION)) &&
        REFERENCE_FTP()) {
        PFTP_CLOSE_CONNECTION_CONTEXT Contextp =
            reinterpret_cast<PFTP_CLOSE_CONNECTION_CONTEXT>(
                NH_ALLOCATE(sizeof(*Contextp))
                );
        if (!Contextp) {
            DEREFERENCE_FTP();
        } else {
            Contextp->InterfaceIndex = Endpointp->Interfacep->Index;
            Contextp->ConnectionId = Endpointp->ConnectionId;
            if (!QueueUserWorkItem(
                    FtppCloseConnectionWorkerRoutine, Contextp, 0
                    )) {
                NH_FREE(Contextp);
                DEREFERENCE_FTP();
            } else {
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpDeleteActiveEndpoint: queued connection %d deletion",
                    Endpointp->ConnectionId
                    );
            }
        }
    }
    NH_FREE(Endpointp);
} // FtpDeleteActiveEndpoint


VOID
FtpDeleteConnection(
    PFTP_CONNECTION Connectionp
    )

/*++

Routine Description:

    This routine is invoked to destroy a connection-object.
    In the process, it destroys all endpoints for the connection.

Arguments:

    Connectionp - the connection to be deleted

Return Value:

    none.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PFTP_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    PROFILE("FtpDeleteConnection");
    RemoveEntryList(&Connectionp->Link);
    while (!IsListEmpty(&Connectionp->ActiveEndpointList)) {
        Link = Connectionp->ActiveEndpointList.Flink;
        Endpointp = CONTAINING_RECORD(Link, FTP_ENDPOINT, ConnectionLink);
        FtpDeleteActiveEndpoint(Endpointp);
    }
    NH_FREE(Connectionp);
} // FtpDeleteConnection


PFTP_ENDPOINT
FtpLookupActiveEndpoint(
    PFTP_CONNECTION Connectionp,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to an active endpoint given
    its unique 32-bit identifier.

Arguments:

    Connectionp - the connection on which to search for the endpoint

    EndpointId - the 32-bit identifier of the endpoint to be found

    InsertionPoint - on output, optionally receives the location at which
        the endpoint would be inserted, if the endpoint is not in the list.

Return Value:

    PFTP_ENDPOINT - the endpoint, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PFTP_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    for (Link = Connectionp->ActiveEndpointList.Flink;
         Link != &Connectionp->ActiveEndpointList; Link = Link->Flink) {
        Endpointp = CONTAINING_RECORD(Link, FTP_ENDPOINT, ConnectionLink);
        if (EndpointId > Endpointp->EndpointId) {
            continue;
        } else if (EndpointId < Endpointp->EndpointId) {
            break;
        }
        return Endpointp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // FtpLookupActiveEndpoint


PFTP_CONNECTION
FtpLookupConnection(
    PFTP_INTERFACE Interfacep,
    ULONG ConnectionId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to a connection given its
    unique 32-bit identifier.

Arguments:

    Interfacep - the interface on which to search for the connection

    ConnectionId - the 32-bit identifier of the connection to be found

    InsertionPoint - on output, optionally receives the location at which
        the connection would be inserted, if the connection is not in the list.

Return Value:

    PFTP_CONNECTION - the connection, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PFTP_CONNECTION Connectionp;
    PLIST_ENTRY Link;
    for (Link = Interfacep->ConnectionList.Flink;
         Link != &Interfacep->ConnectionList; Link = Link->Flink) {
        Connectionp = CONTAINING_RECORD(Link, FTP_CONNECTION, Link);
        if (ConnectionId > Connectionp->ConnectionId) {
            continue;
        } else if (ConnectionId < Connectionp->ConnectionId) {
            break;
        }
        return Connectionp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // FtpLookupConnection


PFTP_ENDPOINT
FtpLookupInterfaceEndpoint(
    PFTP_INTERFACE Interfacep,
    ULONG EndpointId,
    PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to retrieve a pointer to any endpoint given
    its unique 32-bit identifier, by searching the endpoints interface list.

Arguments:

    Interfacep - the interfacep on which to search for the endpoint

    EndpointId - the 32-bit identifier of the endpoint to be found

    InsertionPoint - on output, optionally receives the location at which
        the endpoint would be inserted, if the endpoint is not in the list.

Return Value:

    PFTP_ENDPOINT - the endpoint, if found.

Environment:

    Invoked with the interface's lock held by the caller.

--*/

{
    PFTP_ENDPOINT Endpointp;
    PLIST_ENTRY Link;
    for (Link = Interfacep->EndpointList.Flink;
         Link != &Interfacep->EndpointList; Link = Link->Flink) {
        Endpointp = CONTAINING_RECORD(Link, FTP_ENDPOINT, InterfaceLink);
        if (EndpointId > Endpointp->EndpointId) {
            continue;
        } else if (EndpointId < Endpointp->EndpointId) {
            break;
        }
        return Endpointp;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;
} // FtpLookupInterfaceEndpoint


ULONG
FtppCloseConnectionWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine is scheduled to run when a connection's main endpoint is
    deleted. It deletes the connection, destroying all of its endpoints.

Arguments:

    Context - identifies the connection to be deleted

Return Value:

    ULONG - always NO_ERROR.

Environment:

    Invoked in the context of a system worker thread, with a reference made
    to the interface, as well as to the component. Both references are
    released here.

--*/

{
    PFTP_CONNECTION Connectionp;
    PFTP_CLOSE_CONNECTION_CONTEXT Contextp =
        (PFTP_CLOSE_CONNECTION_CONTEXT)Context;
    PFTP_INTERFACE Interfacep;
    PROFILE("FtppCloseConnectionWorkerRoutine");
    EnterCriticalSection(&FtpInterfaceLock);
    Interfacep = FtpLookupInterface(Contextp->InterfaceIndex, NULL);
    if (!Interfacep || !FTP_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&FtpInterfaceLock);
    } else {
        LeaveCriticalSection(&FtpInterfaceLock);
        ACQUIRE_LOCK(Interfacep);
        Connectionp =
            FtpLookupConnection(Interfacep, Contextp->ConnectionId, NULL);
        if (Connectionp) {
            NhTrace(
                TRACE_FLAG_FTP,
                "FtppCloseConnectionWorkerRoutine: deleting connection %d",
                Connectionp->ConnectionId
                );
            FtpDeleteConnection(Connectionp);
        }
        RELEASE_LOCK(Interfacep);
        FTP_DEREFERENCE_INTERFACE(Interfacep);
    }
    DEREFERENCE_FTP();
    NH_FREE(Context);
    return NO_ERROR;
} // FtppCloseConnectionWorkerRoutine


ULONG
FtpReadActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp,
    SOCKET Socket,
    ULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to initiate the retrieval of a full message from
    the socket for the given endpoint.

Arguments:

    Interfacep - the interface on which the endpoint was accepted

    Endpointp - the endpoint for which to read a message

    Socket - the socket from which to read the message

    UserFlags - optionally supplies flags to be included in the 'UserFlags'
        field of the message-buffer

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with a reference
    made to the interface on behalf of the read-completion routine. If the read
    cannot be issued here, this routine is responsible for releasing that
    reference.

--*/

{
    PNH_BUFFER Bufferp;
    ULONG Error;
    PROFILE("FtpReadActiveEndpoint");

    //
    // Initiate a read on the socket to obtain the next message header.
    // We will do as many reads as it takes to get the full header,
    // which contains the length of the full message.
    // We will then do as many reads as it takes to get the full message.
    //
    // We begin by initializing 'BytesToTransfer' to the size of a message
    // header. This will be decremented with each successfully-read block
    // of data. When it drops to zero, we examine the resulting buffer
    // to determine the full message's length, and begin reading that many
    // bytes into another buffer, after copying the message-header into it.
    //

    Bufferp = NhAcquireVariableLengthBuffer(NH_BUFFER_SIZE);
    if (!Bufferp) {
        FTP_DEREFERENCE_INTERFACE(Interfacep);
        return ERROR_CAN_NOT_COMPLETE;
    }
    Bufferp->UserFlags = UserFlags;
    Bufferp->BytesToTransfer = NH_BUFFER_SIZE - FTP_BUFFER_RESERVE;
    Bufferp->TransferOffset = 0;
    Error =
        NhReadStreamSocket(
            &FtpComponentReference,
            Socket,
            Bufferp,
            Bufferp->BytesToTransfer,
            Bufferp->TransferOffset,
            FtpReadEndpointCompletionRoutine,
            Interfacep,
            UlongToPtr(Endpointp->EndpointId)
            );
    if (Error) { FTP_DEREFERENCE_INTERFACE(Interfacep); }
    return Error;
} // FtpReadActiveEndpoint


ULONG
FtpWriteActiveEndpoint(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG UserFlags OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to initiate the transmission of a full message on
    the socket for the given endpoint.

Arguments:

    Interfacep - the interface on which the connection was accepted

    Connectionp - the connection on whose endpoint to write a message

    Socket - the endpoint on which to write the message

    Bufferp - supplies the buffer containing the message to be written

    Length - supplies the length of the message to be written

    UserFlags - optionally supplies flags to be included in the 'UserFlags'
        field of the message-buffer

Return Value:

    ULONG - Win32/Winsock2 status code.

Environment:

    Invoked with the interface's lock held by the caller, and with a reference
    made to the interface on behalf of the write-completion routine. If the
    write cannot be issued here, this routine is responsible for releasing that
    reference.

--*/

{
    ULONG Error;
    PROFILE("FtpWriteActiveEndpoint");

    //
    // Initiate a write on the socket for the full buffer size
    // We will do as many writes as it takes to send the full message.
    //
    // We begin by initializing 'BytesToTransfer' to the size of a message.
    // This will be decremented with each successfully-read block
    // of data. When it drops to zero, we are done.
    //

    Bufferp->UserFlags = UserFlags;
    Bufferp->BytesToTransfer = Length;
    Bufferp->TransferOffset = 0;
    Error =
        NhWriteStreamSocket(
            &FtpComponentReference,
            Socket,
            Bufferp,
            Bufferp->BytesToTransfer,
            Bufferp->TransferOffset,
            FtpWriteEndpointCompletionRoutine,
            Interfacep,
            UlongToPtr(Endpointp->EndpointId)
            );
    if (Error) { FTP_DEREFERENCE_INTERFACE(Interfacep); }
    return Error;
} // FtpWriteActiveEndpoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmftp.h"

#include "ftpif.h"
#include "ftpconn.h"
#include "ftpio.h"
#include "ftplog.h"
#include "ftpmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpmsg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpmsg.h

Abstract:

    This module contains declarations related to the FTP transparent
    proxy's message-processing.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_FTPMSG_H_
#define _NATHLP_FTPMSG_H_

//
// Reserved port release delay
//
#define FTP_PORT_RELEASE_DELAY                  240000

//
// Flags used in 'UserFlags' field of message-buffers
//

#define FTP_BUFFER_FLAG_CONTINUATION            0x00000001
#define FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT      0x00000004
#define FTP_BUFFER_FLAG_FROM_ACTUAL_HOST        0x00000008

typedef struct _TIMER_CONTEXT {
    HANDLE TimerQueueHandle;
    HANDLE TimerHandle;
    USHORT ReservedPort;
} TIMER_CONTEXT, *PTIMER_CONTEXT;


//
// FUNCTION DECLARATIONS
//

VOID
FtpProcessMessage(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp,
    PNH_BUFFER Bufferp
    );

CHAR *
FtpIsFullMessage(
    CHAR *Bufferp,
    ULONG Length
    );

VOID CALLBACK
FtpDelayedPortRelease(
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    );

#endif // _NATHLP_FTPMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftpmsg.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftpmsg.c

Abstract:

    This module contains code for the FTP transparent proxy's
    message-processing.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

#define MAKE_ADDRESS(a,b,c,d) \
    ((a) | ((b) << 8) | ((c) << 16) | ((d) << 24))

#define MAKE_PORT(a,b)  ((a) | ((b) << 8))

#define TOUPPER(c)      ((c) > 'z' ? (c) : ((c) < 'a' ? (c) : (c) ^ 0x20))

//
// Constant string for the 'PASV' command reply
//

static CONST CHAR PasvReply[] = "227 ";

//
// Constant string for the 'PORT' command (must be upper-case)
//

static CONST CHAR PortCommand[] = "PORT ";


static CONST CHAR Eol[] = "\x0d\x0a\x00\x51\x69\x61\x6e\x67\x20\x57\x61\x6e\x67";

//
// FORWARD DECLARATIONS
//

BOOLEAN
FtppExtractOctet(
    CHAR **Buffer,
    CHAR *BufferEnd,
    UCHAR *Octet
    );

VOID
FtppWriteOctet(
    CHAR **Buffer,
    UCHAR Octet
    );


VOID
FtpProcessMessage(
    PFTP_INTERFACE Interfacep,
    PFTP_ENDPOINT Endpointp,
    PNH_BUFFER Bufferp
    )

/*++

Routine Description:

    This routine is called to process a full message read from an FTP
    client or server on a control channel.

Arguments:

    Interfacep - the interface on which the control-channel was accepted

    Endpointp - the active endpoint corresponding to the control channel

    Bufferp - contains the message read, along with other context information

Return Value:

    none.

Notes:

    Invoked with the interface's lock held by the caller, and with two
    references made to the interface on our behalf. It is this routine's
    responsibility to release both the references and the buffer.

--*/

{
    BOOLEAN Success;
    BOOLEAN Continuation;
    SOCKET Socket;
    ULONG Error;
    ULONG i;
    LONG NewLength;
    ULONG PublicAddress;
    USHORT PublicPort;
    ULONG PrivateAddress;
    USHORT PrivatePort;
    UCHAR Numbers[6];
    CHAR *HostPortStartp;
    CHAR *CommandBufferp = reinterpret_cast<CHAR*>(Bufferp->Buffer);
    CHAR *EndOfBufferp =
        reinterpret_cast<CHAR*>(Bufferp->Buffer + Bufferp->TransferOffset);
    CONST CHAR *Commandp =
        Endpointp->Type == FtpClientEndpointType ?
        (PCHAR)PasvReply : (PCHAR)PortCommand;

    PROFILE("FtpProcessMessage");

    if ((Bufferp->UserFlags & FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT) != 0) {
        Socket = Endpointp->ClientSocket;
    } else {
        ASSERT((Bufferp->UserFlags & FTP_BUFFER_FLAG_FROM_ACTUAL_HOST) != 0);
        Socket = Endpointp->HostSocket;
    }

#if DBG
    NhTrace(
        TRACE_FLAG_FTP,
        "FtpProcessMessage: received (0x%08x) (%d) \"%s\"",
        Bufferp->UserFlags, Bufferp->TransferOffset, CommandBufferp
        );
#endif
    if ((Bufferp->UserFlags & FTP_BUFFER_FLAG_FROM_ACTUAL_CLIENT) != 0 &&
        (Bufferp->UserFlags & FTP_BUFFER_FLAG_CONTINUATION) == 0) {
        while (*Commandp != '\0' && *Commandp == TOUPPER(*CommandBufferp)) {
            Commandp++;
            CommandBufferp++;
        }

        if (*Commandp == '\0') {
            //
            // We found a match.
            //
            if (Endpointp->Type == FtpClientEndpointType) {
                //
                // Skip non-numerical characters.
                //
                while (CommandBufferp < EndOfBufferp &&
                    (*CommandBufferp < '0' || *CommandBufferp > '9')) {
                    CommandBufferp++;
                }
            } else {
                //
                // Skip white space.
                //
                while (*CommandBufferp == ' ') {
                    CommandBufferp++;
                }
            }

            HostPortStartp = CommandBufferp;

            //
            // Extract host and port numbers.
            //
            Success =
                FtppExtractOctet(
                    &CommandBufferp,
                    EndOfBufferp,
                    &Numbers[0]
                    );

            i = 1;
            while (i < 6 && Success && *CommandBufferp == ',') {
                CommandBufferp++;
                Success =
                    FtppExtractOctet(
                        &CommandBufferp,
                        EndOfBufferp,
                        &Numbers[i]
                        );
                i++;
            }

            if (i == 6 && Success) {
                //
                // We extract all of them successfully.
                //
                PrivateAddress =
                    MAKE_ADDRESS(
                        Numbers[0],
                        Numbers[1],
                        Numbers[2],
                        Numbers[3]
                        );
                PrivatePort = MAKE_PORT(Numbers[4], Numbers[5]);

                PublicAddress = Endpointp->BoundaryAddress;
                if (PublicAddress == IP_NAT_ADDRESS_UNSPECIFIED) {
                    PublicAddress =
                        NhQueryAddressSocket(Endpointp->ClientSocket);
                }

                //
                // Cancel the previous one first.
                //
                if (Endpointp->ReservedPort != 0) {
                    PTIMER_CONTEXT TimerContextp;

                    NatCancelRedirect(
                        FtpTranslatorHandle,
                        NAT_PROTOCOL_TCP,
                        Endpointp->DestinationAddress,
                        Endpointp->DestinationPort,
                        Endpointp->SourceAddress,
                        Endpointp->SourcePort,
                        Endpointp->NewDestinationAddress,
                        Endpointp->NewDestinationPort,
                        Endpointp->NewSourceAddress,
                        Endpointp->NewSourcePort
                        );
                    TimerContextp = reinterpret_cast<PTIMER_CONTEXT>(
                                        NH_ALLOCATE(sizeof(TIMER_CONTEXT))
                                        );
                    if (TimerContextp != NULL) {
                        TimerContextp->TimerQueueHandle = FtpTimerQueueHandle;
                        TimerContextp->ReservedPort = Endpointp->ReservedPort;
                        CreateTimerQueueTimer(
                            &(TimerContextp->TimerHandle),
                            FtpTimerQueueHandle,
                            FtpDelayedPortRelease,
                            (PVOID)TimerContextp,
                            FTP_PORT_RELEASE_DELAY,
                            0,
                            WT_EXECUTEDEFAULT
                            );
                    } else {
                        NhTrace(
                            TRACE_FLAG_FTP,
                            "FtpProcessMessage:"
                            " memory allocation failed for timer context"
                            );
                        NhErrorLog(
                            IP_FTP_LOG_ALLOCATION_FAILED,
                            0,
                            "%d",
                            sizeof(TIMER_CONTEXT)
                            );
                    }
                    Endpointp->ReservedPort = 0;
                }

                //
                // Reserve a port for the new data session.
                //
                Error =
                    NatAcquirePortReservation(
                        FtpPortReservationHandle,
                        1,
                        &PublicPort
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_FTP,
                        "FtpProcessMessage: error %d acquiring port",
                        Error
                        );
                    FtpDeleteActiveEndpoint(Endpointp);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    return;
                }
                Endpointp->ReservedPort = PublicPort;

                //
                // Create a redirect for the new data session.
                //
                if (Endpointp->Type == FtpClientEndpointType) {
                    Endpointp->DestinationAddress = PublicAddress;
                    Endpointp->SourceAddress =  0;
                    Endpointp->NewDestinationAddress =  PrivateAddress;
                    Endpointp->NewSourceAddress = 0;
                    Endpointp->DestinationPort = PublicPort;
                    Endpointp->SourcePort = 0;
                    Endpointp->NewDestinationPort = PrivatePort;
                    Endpointp->NewSourcePort = 0;
                    Error =
                        NatCreatePartialRedirect(
                            FtpTranslatorHandle,
                            NatRedirectFlagLoopback,
                            NAT_PROTOCOL_TCP,
                            PublicAddress,
                            PublicPort,
                            PrivateAddress,
                            PrivatePort,
                            NULL,
                            NULL,
                            NULL
                            );
                } else {
                    Endpointp->DestinationAddress = PublicAddress;
                    Endpointp->SourceAddress = Endpointp->ActualHostAddress;
                    Endpointp->NewDestinationAddress =  PrivateAddress;
                    Endpointp->NewSourceAddress = Endpointp->ActualHostAddress;
                    Endpointp->DestinationPort = PublicPort;
                    Endpointp->SourcePort = FTP_PORT_DATA;
                    Endpointp->NewDestinationPort = PrivatePort;
                    Endpointp->NewSourcePort = FTP_PORT_DATA;
                    Error =
                        NatCreateRedirect(
                            FtpTranslatorHandle,
                            NatRedirectFlagLoopback,
                            NAT_PROTOCOL_TCP,
                            PublicAddress,
                            PublicPort,
                            Endpointp->ActualHostAddress,
                            FTP_PORT_DATA,
                            PrivateAddress,
                            PrivatePort,
                            Endpointp->ActualHostAddress,
                            FTP_PORT_DATA,
                            NULL,
                            NULL,
                            NULL
                            );
                }
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_FTP,
                        "FtpProcessMessage: error %d creating redirect",
                        Error
                        );
                    FtpDeleteActiveEndpoint(Endpointp);
                    FTP_DEREFERENCE_INTERFACE(Interfacep);
                    return;
                }

                //
                // Modify the FTP command.
                //
                Numbers[0] = (UCHAR)(PublicAddress & 0xff);
                Numbers[1] = (UCHAR)((PublicAddress >> 8) & 0xff);
                Numbers[2] = (UCHAR)((PublicAddress >> 16) & 0xff);
                Numbers[3] = (UCHAR)((PublicAddress >> 24) & 0xff);
                Numbers[4] = (UCHAR)(PublicPort & 0xff);
                Numbers[5] = (UCHAR)((PublicPort >> 8) & 0xff);
                NewLength = 17;
                for (i = 0; i < 6; i++) {
                    if (Numbers[i] > 99) {
                        NewLength++;
                    } else if (Numbers[i] <= 9) {
                        NewLength--;
                    }
                }

                Bufferp->TransferOffset +=
                    NewLength - (ULONG)(CommandBufferp - HostPortStartp);
                ASSERT(Bufferp->TransferOffset <= NH_BUFFER_SIZE);

                MoveMemory(
                    HostPortStartp + NewLength,
                    CommandBufferp,
                    EndOfBufferp - CommandBufferp
                    );

                FtppWriteOctet(&HostPortStartp, Numbers[0]);
                i = 1;
                do {
                    *HostPortStartp = ',';
                    HostPortStartp++;
                    FtppWriteOctet(&HostPortStartp, Numbers[i]);
                    i++;
                } while (i < 6);
            }
        }
    }

    //
    // Forward the message.
    //
    Continuation =
        FtpIsFullMessage(
            reinterpret_cast<CHAR*>(
                &(Bufferp->Buffer[Bufferp->TransferOffset - 2])
            ),
            2
            ) == NULL;
    if (Continuation) {
        Bufferp->UserFlags |= FTP_BUFFER_FLAG_CONTINUATION;
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpProcessMessage: message to be continued (%d)",
            Bufferp->TransferOffset
            );
    } else {
        Bufferp->UserFlags &= ~(ULONG)FTP_BUFFER_FLAG_CONTINUATION;
    }
#if DBG
    NhTrace(
        TRACE_FLAG_FTP,
        "FtpProcessMessage: written (%d) \"%s\"",
        Bufferp->TransferOffset,
        Bufferp->Buffer
        );
#endif
    Error =
        FtpWriteActiveEndpoint(
            Interfacep,
            Endpointp,
            Socket,
            Bufferp,
            Bufferp->TransferOffset,
            Bufferp->UserFlags
            );
    if (Error) {
        NhTrace(
            TRACE_FLAG_FTP,
            "FtpProcessMessage: deleting endpoint %d, "
            "FtpWriteActiveEndpoint=%d",
            Endpointp->EndpointId, Error
            );
        FtpDeleteActiveEndpoint(Endpointp);
    }
}


CHAR *
FtpIsFullMessage(
    CHAR *Bufferp,
    ULONG Length
    )

/*++

Routine Description:

    This routine is called to determine whether the passed-in buffer includes
    a full FTP command.

Arguments:

    Bufferp - contains the message read, along with other context information

Return Value:

    CHAR * - points to the start of the next FTP command, or NULL if no
        complete FTP command is detected.

--*/

{
    ULONG Count = Length;
    CONST CHAR *CommandBufferp = Bufferp;
    CONST CHAR *CommandDelimiter = Eol;

    PROFILE("FtpIsFullMessage");

    ASSERT(
        Eol[0] != '\0' &&
        (Eol[1] == '\0' || Eol[2] == '\0') &&
        Eol[0] != Eol[1]
        );

    while (Count > 0 && *CommandDelimiter != '\0') {
        if (*CommandBufferp == *CommandDelimiter) {
            CommandDelimiter++;
            CommandBufferp++;
            Count--;
        } else {
            if (CommandDelimiter == Eol) {
                CommandBufferp++;
                Count--;
            } else {
                CommandDelimiter = Eol;
            }
        }
    }

    return *CommandDelimiter == '\0' ? (CHAR *)CommandBufferp : NULL;
}


VOID CALLBACK
FtpDelayedPortRelease(
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    This routine is called to release a reserved port.

Arguments:

    Parameter - callback context
    TimerOrWaitFired - wait timed out

Return Value:

    None.

--*/

{
    PTIMER_CONTEXT TimerContextp = (PTIMER_CONTEXT)Parameter;
    PROFILE("FtpDelayedPortRelease");

    NatReleasePortReservation(
        FtpPortReservationHandle,
        TimerContextp->ReservedPort,
        1
        );
    DeleteTimerQueueTimer(
        TimerContextp->TimerQueueHandle,
        TimerContextp->TimerHandle,
        NULL
        );
    NH_FREE(TimerContextp);
}


BOOLEAN
FtppExtractOctet(
    CHAR **Buffer,
    CHAR *BufferEnd,
    UCHAR *Octet
    )

/*++

Routine Description:

    This routine is called to extrcat an octet from a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    BufferEnd - points to the end of the string
    Octet - points to a caller-suplied storage to store converted octet

Return Value:

    BOOLEAN - TRUE if successfuly converted, FALSE otherwise.

--*/

{
    BOOLEAN Success;
    ULONG i = 0;
    ULONG Value = 0;

    while (i < 3 && **Buffer >= '0' && **Buffer <= '9') {
        Value *= 10;
        Value += **Buffer - '0';
        (*Buffer)++;
        i++;
    }

    Success = i > 0 && Value < 0x100;

    if (Success) {
        *Octet = (UCHAR)Value;
    }

    return Success;
}


VOID
FtppWriteOctet(
    CHAR **Buffer,
    UCHAR Octet
    )

/*++

Routine Description:

    This routine is called to convert an octet to a string.

Arguments:

    Buffer - points to a pointer to a string where conversion starts; on
        return it points to the pointer to the string where conversion ends
    Octet - octet to convert

Return Value:

    None.

--*/

{
    UCHAR Value = Octet;

    if (Octet > 99) {
        **Buffer = '0' + Value / 100;
        Value %= 100;
        (*Buffer)++;
    }

    if (Octet > 9) {
        **Buffer = '0' + Value / 10;
        Value %= 10;
        (*Buffer)++;
    }

    ASSERT(Value <= 9);

    **Buffer = '0' + Value;
    (*Buffer)++;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\ftplog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ftplog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_FTPLOG_H_
#define _NATHLP_FTPLOG_H_

#define IP_FTP_LOG_BASE                       35000

#define IP_FTP_LOG_NAT_INTERFACE_IGNORED      (IP_FTP_LOG_BASE+1)
/*
 * The FTP transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_FTP_LOG_ACTIVATE_FAILED            (IP_FTP_LOG_BASE+2)
/*
 * The FTP transparent proxy was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_FTP_LOG_RECEIVE_FAILED             (IP_FTP_LOG_BASE+3)
/*
 * The FTP transparent proxy encountered a network error while
 * attempting to receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_FTP_LOG_ALLOCATION_FAILED          (IP_FTP_LOG_BASE+4)
/*
 * The FTP transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_FTP_LOG_ACCEPT_FAILED              (IP_FTP_LOG_BASE+5)
/*
 * The FTP transparent proxy encountered a network error while
 * attempting to accept connections on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_FTP_LOG_SEND_FAILED                (IP_FTP_LOG_BASE+7)
/*
 * The FTP transparent proxy encountered a network error while
 * attempting to send messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_FTP_LOG_END                        (IP_FTP_LOG_BASE+999)
/*
 * end.
 */

#endif // _NATHLP_FTPLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\h323\h323log.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323log.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   24-May-1999

Revision History:

--*/

#define IP_H323_LOG_BASE                       34000

#define IP_H323_LOG_NAT_INTERFACE_IGNORED      (IP_H323_LOG_BASE+1)
/*
 * The H.323 transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_H323_LOG_ALLOCATION_FAILED          (IP_H323_LOG_BASE+2)
/*
 * The H.323 transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_H323_LOG_END                        (IP_H323_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\h323\h323if.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323if.c

Abstract:

    This module contains code for the H.323 transparent proxy's interface
    management.

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop
#include <h323icsp.h>

//
// GLOBAL DATA DEFINITIONS
//

LIST_ENTRY H323InterfaceList;
CRITICAL_SECTION H323InterfaceLock;

//
// FORWARD DECLARATIONS
//

ULONG
H323ActivateInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to activate an interface, when the interface
    becomes both enabled and bound.

Arguments:

    Interfacep - the interface to be activated

Return Value:

    ULONG - Win32 status code indicating success or failure.

Environment:

    Always invoked locally, with  'Interfacep' referenced by caller and/or
    'H323InterfaceLock' held by caller.

--*/

{
    ULONG Error;
    ULONG i;
    ULONG InterfaceCharacteristics;
    H323_INTERFACE_TYPE H323InterfaceType;

    PROFILE("H323ActivateInterface");

    EnterCriticalSection(&H323InterfaceLock);
    if (H323_INTERFACE_ADMIN_DISABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        return NO_ERROR;
    }

    InterfaceCharacteristics =
        NatGetInterfaceCharacteristics(
                Interfacep->Index
                );

    if (!InterfaceCharacteristics) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_H323,
            "H323ActivateInterface: ignoring non-NAT interface %d",
            Interfacep->Index
            );
        return NO_ERROR;
    }

    Error = NO_ERROR;

    if (NAT_IFC_FW(InterfaceCharacteristics)) {
        H323InterfaceType = H323_INTERFACE_PUBLIC_FIREWALLED;
    } else if (NAT_IFC_BOUNDARY(InterfaceCharacteristics)) {
        H323InterfaceType = H323_INTERFACE_PUBLIC;
    } else {
        ASSERT(NAT_IFC_PRIVATE(InterfaceCharacteristics));
        H323InterfaceType = H323_INTERFACE_PRIVATE;
    }

    ACQUIRE_LOCK(Interfacep);

    H323ProxyActivateInterface(
        Interfacep->Index,
        H323InterfaceType,
        Interfacep->BindingInfo
        );

    RELEASE_LOCK(Interfacep);
    LeaveCriticalSection(&H323InterfaceLock);

    return NO_ERROR;

} // H323ActivateInterface


ULONG
H323BindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to supply the binding for an interface.
    It records the binding information received, and if necessary,
    it activates the interface.

Arguments:

    Index - the index of the interface to be bound

    BindingInfo - the binding-information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    ULONG i;
    PH323_INTERFACE Interfacep;

    PROFILE("H323BindInterface");

    EnterCriticalSection(&H323InterfaceLock);

    //
    // Retrieve the interface to be bound
    //

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (H323_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Update the interface's flags
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_BOUND;

    LeaveCriticalSection(&H323InterfaceLock);

    ACQUIRE_LOCK(Interfacep);

    //
    // Allocate space for the binding, and copy it
    //

    Interfacep->BindingInfo =
        reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
            NH_ALLOCATE(SIZEOF_IP_BINDING(BindingInfo->AddressCount))
            );
    if (!Interfacep->BindingInfo) {
        RELEASE_LOCK(Interfacep);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "H323BindInterface: allocation failed for interface %d binding",
            Index
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            SIZEOF_IP_BINDING(BindingInfo->AddressCount)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    CopyMemory(
        Interfacep->BindingInfo,
        BindingInfo,
        SIZEOF_IP_BINDING(BindingInfo->AddressCount)
        );

    RELEASE_LOCK(Interfacep);

    //
    // Activate the interface if necessary
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        Error = H323ActivateInterface(Interfacep);
    }

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323BindInterface


VOID
H323CleanupInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked when the very last reference to an interface
    is released, and the interface must be destroyed.

Arguments:

    Interfacep - the interface to be destroyed

Return Value:

    none.

Environment:

    Invoked internally from an arbitrary context, with no references
    to the interface.

--*/

{
    PLIST_ENTRY Link;

    PROFILE("H323CleanupInterface");

    if (Interfacep->BindingInfo) {
        NH_FREE(Interfacep->BindingInfo);
        Interfacep->BindingInfo = NULL;
    }

    DeleteCriticalSection(&Interfacep->Lock);

    NH_FREE(Interfacep);

} // H323CleanupInterface


ULONG
H323ConfigureInterface(
    ULONG Index,
    PIP_H323_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is called to set the configuration for an interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    Invoked internally in the context of a IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error;
    PH323_INTERFACE Interfacep;
    ULONG NewFlags;
    ULONG OldFlags;

    PROFILE("H323ConfigureInterface");

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323ConfigureInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323ConfigureInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    LeaveCriticalSection(&H323InterfaceLock);

    Error = NO_ERROR;

    ACQUIRE_LOCK(Interfacep);

    //
    // Compare the interface's current and new configuration
    //

    OldFlags = Interfacep->Info.Flags;
    NewFlags =
        (InterfaceInfo
            ? (InterfaceInfo->Flags|H323_INTERFACE_FLAG_CONFIGURED) : 0);

    Interfacep->Flags &= ~OldFlags;
    Interfacep->Flags |= NewFlags;

    if (!InterfaceInfo) {

        ZeroMemory(&Interfacep->Info, sizeof(*InterfaceInfo));

        //
        // The interface no longer has any information;
        // default to being enabled.
        //

        if (OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) {

            //
            // Activate the interface if necessary
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = H323ActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    } else {

        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));

        //
        // Activate or deactivate the interface if its status changed
        //

        if ((OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) &&
            !(NewFlags & IP_H323_INTERFACE_FLAG_DISABLED)) {

            //
            // Activate the interface
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                Error = H323ActivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        } else if (!(OldFlags & IP_H323_INTERFACE_FLAG_DISABLED) &&
                    (NewFlags & IP_H323_INTERFACE_FLAG_DISABLED)) {

            //
            // Deactivate the interface if necessary
            //

            if (H323_INTERFACE_ACTIVE(Interfacep)) {
                RELEASE_LOCK(Interfacep);
                H323DeactivateInterface(Interfacep);
                ACQUIRE_LOCK(Interfacep);
            }
        }
    }

    RELEASE_LOCK(Interfacep);
    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323ConfigureInterface


ULONG
H323CreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_H323_INTERFACE_INFO InterfaceInfo,
    OUT PH323_INTERFACE* InterfaceCreated
    )

/*++

Routine Description:

    This routine is invoked by the router-manager to add a new interface
    to the H.323 transparent proxy.

Arguments:

    Index - the index of the new interface

    Type - the media type of the new interface

    InterfaceInfo - the interface's configuration

    Interfacep - receives the interface created

Return Value:

    ULONG - Win32 error code

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PLIST_ENTRY InsertionPoint;
    PH323_INTERFACE Interfacep;

    PROFILE("H323CreateInterface");

    EnterCriticalSection(&H323InterfaceLock);

    //
    // See if the interface already exists;
    // If not, this obtains the insertion point
    //

    if (H323LookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323CreateInterface: duplicate index found for %d",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep = reinterpret_cast<PH323_INTERFACE>(
                    NH_ALLOCATE(sizeof(H323_INTERFACE))
                    );

    if (!Interfacep) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF, "H323CreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(H323_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    __try {
        InitializeCriticalSection(&Interfacep->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        LeaveCriticalSection(&H323InterfaceLock);
        NH_FREE(Interfacep);
        return GetExceptionCode();
    }

    Interfacep->Index = Index;
    Interfacep->Type = Type;
    if (InterfaceInfo) {
        Interfacep->Flags = InterfaceInfo->Flags|H323_INTERFACE_FLAG_CONFIGURED;
        CopyMemory(&Interfacep->Info, InterfaceInfo, sizeof(*InterfaceInfo));
    }
    Interfacep->ReferenceCount = 1;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&H323InterfaceLock);

    if (InterfaceCreated) { *InterfaceCreated = Interfacep; }

    return NO_ERROR;

} // H323CreateInterface


VOID
H323DeactivateInterface(
    PH323_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is called to deactivate an interface.
    It closes all sockets on the interface's bindings (if any).

Arguments:

    Interfacep - the interface to be deactivated

Return Value:

    none.

Environment:

    Always invoked locally, with 'Interfacep' referenced by caller and/or
    'H323InterfaceLock' held by caller.

--*/

{
    ULONG i;
    PLIST_ENTRY Link;

    PROFILE("H323DeactivateInterface");

    ACQUIRE_LOCK(Interfacep);

    // TODO: Call h323ics!DeactivateInterface
    H323ProxyDeactivateInterface(Interfacep->Index);

    RELEASE_LOCK(Interfacep);

} // H323DeactivateInterface


ULONG
H323DeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to delete an interface.
    It drops the reference count on the interface so that the last
    dereferencer will delete the interface, and sets the 'deleted' flag
    so that further references to the interface will fail.

Arguments:

    Index - the index of the interface to be deleted

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323DeleteInterface");

    //
    // Retrieve the interface to be deleted
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Deactivate the interface
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    //
    // Mark the interface as deleted and take it off the interface list
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_DELETED;
    Interfacep->Flags &= ~H323_INTERFACE_FLAG_ENABLED;
    RemoveEntryList(&Interfacep->Link);

    //
    // Drop the reference count; if it is non-zero,
    // the deletion will complete later.
    //

    if (--Interfacep->ReferenceCount) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DeleteInterface: interface %d deletion pending",
            Index
            );
        return NO_ERROR;
    }

    //
    // The reference count is zero, so perform final cleanup
    //

    H323CleanupInterface(Interfacep);

    LeaveCriticalSection(&H323InterfaceLock);

    return NO_ERROR;

} // H323DeleteInterface


ULONG
H323DisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to disable I/O on an interface.
    If the interface is active, it is deactivated.

Arguments:

    Index - the index of the interface to be disabled.

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323DisableInterface");

    //
    // Retrieve the interface to be disabled
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already disabled
    //

    if (!H323_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d already disabled",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323DisableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'enabled' flag
    //

    Interfacep->Flags &= ~H323_INTERFACE_FLAG_ENABLED;

    //
    // Deactivate the interface, if necessary
    //

    if (H323_INTERFACE_BOUND(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // H323DisableInterface


ULONG
H323EnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is called to enable I/O on an interface.
    If the interface is already bound, this enabling activates it.

Arguments:

    Index - the index of the interfaec to be enabled

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    PH323_INTERFACE Interfacep;

    PROFILE("H323EnableInterface");

    //
    // Retrieve the interface to be enabled
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already enabled
    //

    if (H323_INTERFACE_ENABLED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d already enabled",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323EnableInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Set the 'enabled' flag
    //

    Interfacep->Flags |= H323_INTERFACE_FLAG_ENABLED;

    //
    // Activate the interface, if necessary
    //

    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        Error = H323ActivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return Error;

} // H323EnableInterface


ULONG
H323InitializeInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to initialize the interface-management module.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    ULONG Error = NO_ERROR;
    PROFILE("H323InitializeInterfaceManagement");

    InitializeListHead(&H323InterfaceList);
    __try {
        InitializeCriticalSection(&H323InterfaceLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        NhTrace(
            TRACE_FLAG_IF,
            "H323InitializeInterfaceManagement: exception %d creating lock",
            Error = GetExceptionCode()
            );
    }

    return Error;

} // H323InitializeInterfaceManagement


PH323_INTERFACE
H323LookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PH323_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'H323InterfaceLock'
    held by caller.

--*/

{
    PH323_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("H323LookupInterface");
    for (Link = H323InterfaceList.Flink; Link != &H323InterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, H323_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }
    if (InsertionPoint) { *InsertionPoint = Link; }
    return NULL;

} // H323LookupInterface


ULONG
H323QueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for an interface.

Arguments:

    Index - the interface to be queried

    InterfaceInfo - receives the retrieved information

    InterfaceInfoSize - receives the (required) size of the information

Return Value:

    ULONG - Win32 status code.

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323QueryInterface");

    //
    // Check the caller's buffer size
    //

    if (!InterfaceInfoSize) { return ERROR_INVALID_PARAMETER; }

    //
    // Retrieve the interface to be configured
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // See if there is any explicit config on this interface
    //

    if (!H323_INTERFACE_CONFIGURED(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        NhTrace(
            TRACE_FLAG_IF,
            "H323QueryInterface: interface %d has no configuration",
            Index
            );
        *InterfaceInfoSize = 0;
        return NO_ERROR;
    }

    //
    // See if there is enough buffer space
    //

    if (*InterfaceInfoSize < sizeof(IP_H323_INTERFACE_INFO)) {
        LeaveCriticalSection(&H323InterfaceLock);
        H323_DEREFERENCE_INTERFACE(Interfacep);
        *InterfaceInfoSize = sizeof(IP_H323_INTERFACE_INFO);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Copy the requested data
    //

    CopyMemory(
        InterfaceInfo,
        &Interfacep->Info,
        sizeof(IP_H323_INTERFACE_INFO)
        );
    *InterfaceInfoSize = sizeof(IP_H323_INTERFACE_INFO);

    LeaveCriticalSection(&H323InterfaceLock);

    H323_DEREFERENCE_INTERFACE(Interfacep);

    return NO_ERROR;

} // H323QueryInterface


VOID
H323ShutdownInterfaceManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to shutdown the interface-management module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked in an arbitrary thread context, after all references
    to all interfaces have been released.

--*/

{
    PH323_INTERFACE Interfacep;
    PLIST_ENTRY Link;
    PROFILE("H323ShutdownInterfaceManagement");
    while (!IsListEmpty(&H323InterfaceList)) {
        Link = RemoveHeadList(&H323InterfaceList);
        Interfacep = CONTAINING_RECORD(Link, H323_INTERFACE, Link);
        if (H323_INTERFACE_ACTIVE(Interfacep)) {
            H323DeactivateInterface(Interfacep);
        }
        H323CleanupInterface(Interfacep);
    }
    DeleteCriticalSection(&H323InterfaceLock);

} // H323ShutdownInterfaceManagement


VOID
H323SignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    )

/*++

Routine Description:

    This routine is invoked upon reconfiguration of a NAT interface.
    Note that this routine may be invoked even when the H.323
    transparent proxy is neither installed nor running; it operates as expected,
    since the global information and lock are always initialized.

    Upon invocation, the routine activates or deactivates the interface
    depending on whether the NAT is not or is running on the interface,
    respectively.

Arguments:

    Index - the reconfigured interface

    Boundary - indicates whether the interface is now a boundary interface

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323SignalNatInterface");

    EnterCriticalSection(&H323GlobalInfoLock);
    if (!H323GlobalInfo) {
        LeaveCriticalSection(&H323GlobalInfoLock);
        return;
    }
    LeaveCriticalSection(&H323GlobalInfoLock);
    EnterCriticalSection(&H323InterfaceLock);
    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        return;
    }
    if (H323_INTERFACE_ACTIVE(Interfacep)) {
        H323DeactivateInterface(Interfacep);
        H323ActivateInterface(Interfacep);
    }
    LeaveCriticalSection(&H323InterfaceLock);

} // H323SignalNatInterface


ULONG
H323UnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to revoke the binding on an interface.
    This involves deactivating the interface if it is active.

Arguments:

    Index - the index of the interface to be unbound

Return Value:

    none.

Environment:

    Invoked internally in the context of an IP router-manager thread.
    (See 'RMH323.C').

--*/

{
    PH323_INTERFACE Interfacep;

    PROFILE("H323UnbindInterface");

    //
    // Retrieve the interface to be unbound
    //

    EnterCriticalSection(&H323InterfaceLock);

    if (!(Interfacep = H323LookupInterface(Index, NULL))) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!H323_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    //
    // Reference the interface
    //

    if (!H323_REFERENCE_INTERFACE(Interfacep)) {
        LeaveCriticalSection(&H323InterfaceLock);
        NhTrace(
            TRACE_FLAG_IF,
            "H323UnbindInterface: interface %d cannot be referenced",
            Index
            );
        return ERROR_INTERFACE_DISABLED;
    }

    //
    // Clear the 'bound' flag
    //

    Interfacep->Flags &= ~H323_INTERFACE_FLAG_BOUND;

    //
    // Deactivate the interface, if necessary
    //

    if (H323_INTERFACE_ENABLED(Interfacep)) {
        H323DeactivateInterface(Interfacep);
    }

    LeaveCriticalSection(&H323InterfaceLock);

    //
    // Destroy the interface's binding
    //

    ACQUIRE_LOCK(Interfacep);
    NH_FREE(Interfacep->BindingInfo);
    Interfacep->BindingInfo = NULL;
    RELEASE_LOCK(Interfacep);

    H323_DEREFERENCE_INTERFACE(Interfacep);
    return NO_ERROR;

} // H323UnbindInterface
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\h323\h323if.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    h323if.h

Abstract:

    This module contains declarations for the H.323 transparent proxy's
    interface management.

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:
    
--*/

#ifndef _NATHLP_H323IF_H_
#define _NATHLP_H323IF_H_

//
// Structure:   H323_INTERFACE
//
// This structure holds operational information for an interface.
//
// Each interface is inserted into the list of H.323 transparent proxy
// interfaces, sorted by 'Index'.
//
// Synchronization on an interface makes use of an interface-list lock
// ('H323InterfaceLock'), a per-interface reference count, and a per-interface
// critical-section:
//
// Acquiring a reference to an interface guarantees the interface's existence;
// acquiring the interface's lock guarantees the interface's consistency.
//
// To acquire a reference, first acquire the interface-list lock;
// to traverse the interface-list, first acquire the interface-list lock.
//
// An interface's lock can only be acquired if
//      (a) a reference to the interface has been acquired, or
//      (b) the interface-list lock is currently held.
// Note that holding the list lock alone does not guarantee consistency.
//
// Fields marked read-only can be read so long as the interface is referenced.
//

typedef struct _H323_INTERFACE {
    LIST_ENTRY Link;
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Index; // read-only
    NET_INTERFACE_TYPE Type; // read-only
    IP_H323_INTERFACE_INFO Info;
    ULONG Flags;
    PIP_ADAPTER_BINDING_INFO BindingInfo;
} H323_INTERFACE, *PH323_INTERFACE;

//
// Flags
//

#define H323_INTERFACE_FLAG_DELETED      0x80000000
#define H323_INTERFACE_DELETED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_DELETED)

#define H323_INTERFACE_FLAG_BOUND        0x40000000
#define H323_INTERFACE_BOUND(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_BOUND)

#define H323_INTERFACE_FLAG_ENABLED      0x20000000
#define H323_INTERFACE_ENABLED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_ENABLED)

#define H323_INTERFACE_FLAG_CONFIGURED   0x10000000
#define H323_INTERFACE_CONFIGURED(i) \
    ((i)->Flags & H323_INTERFACE_FLAG_CONFIGURED)

#define H323_INTERFACE_ACTIVE(i) \
    (((i)->Flags & (H323_INTERFACE_FLAG_BOUND|H323_INTERFACE_FLAG_ENABLED)) \
        == (H323_INTERFACE_FLAG_BOUND|H323_INTERFACE_FLAG_ENABLED))

#define H323_INTERFACE_ADMIN_DISABLED(i) \
    ((i)->Flags & IP_H323_INTERFACE_FLAG_DISABLED)

//
// Synchronization
//

#define H323_REFERENCE_INTERFACE(i) \
    REFERENCE_OBJECT(i, H323_INTERFACE_DELETED)

#define H323_DEREFERENCE_INTERFACE(i) \
    DEREFERENCE_OBJECT(i, H323CleanupInterface)


//
// GLOBAL DATA DECLARATIONS
//

extern LIST_ENTRY H323InterfaceList;
extern CRITICAL_SECTION H323InterfaceLock;


//
// FUNCTION DECLARATIONS
//

ULONG
H323ActivateInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323BindInterface(
    ULONG Index,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
H323CleanupInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323ConfigureInterface(
    ULONG Index,
    PIP_H323_INTERFACE_INFO InterfaceInfo
    );

ULONG
H323CreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_H323_INTERFACE_INFO InterfaceInfo,
    PH323_INTERFACE* InterfaceCreated
    );

VOID
H323DeactivateInterface(
    PH323_INTERFACE Interfacep
    );

ULONG
H323DeleteInterface(
    ULONG Index
    );

ULONG
H323DisableInterface(
    ULONG Index
    );

ULONG
H323EnableInterface(
    ULONG Index
    );

ULONG
H323InitializeInterfaceManagement(
    VOID
    );

PH323_INTERFACE
H323LookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
H323QueryInterface(
    ULONG Index,
    PVOID InterfaceInfo,
    PULONG InterfaceInfoSize
    );

VOID
H323ShutdownInterfaceManagement(
    VOID
    );

VOID
H323SignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
H323UnbindInterface(
    ULONG Index
    );

#endif // _NATHLP_H323IF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\ftp\rmftp.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmftp.c

Abstract:

    This module contains routines for the FTP transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

COMPONENT_REFERENCE FtpComponentReference;
PIP_FTP_GLOBAL_INFO FtpGlobalInfo = NULL;
CRITICAL_SECTION FtpGlobalInfoLock;
HANDLE FtpNotificationEvent;
HANDLE FtpTimerQueueHandle = NULL;
HANDLE FtpPortReservationHandle = NULL;
ULONG FtpProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS FtpRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_FTP,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    FtpRmStartProtocol,
    FtpRmStartComplete,
    FtpRmStopProtocol,
    FtpRmGetGlobalInfo,
    FtpRmSetGlobalInfo,
    NULL,
    NULL,
    FtpRmAddInterface,
    FtpRmDeleteInterface,
    FtpRmInterfaceStatus,

    FtpRmGetInterfaceInfo,
    FtpRmSetInterfaceInfo,
    FtpRmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    FtpRmMibCreate,
    FtpRmMibDelete,
    FtpRmMibGet,
    FtpRmMibSet,
    FtpRmMibGetFirst,
    FtpRmMibGetNext,
    NULL,
    NULL
};


IP_FTP_STATISTICS FtpStatistics;
SUPPORT_FUNCTIONS FtpSupportFunctions;
HANDLE FtpTranslatorHandle = NULL;


VOID
FtpCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the FTP transparent proxy module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    FtpShutdownInterfaceManagement();
    DeleteCriticalSection(&FtpGlobalInfoLock);
    DeleteComponentReference(&FtpComponentReference);

} // FtpCleanupModule


VOID
FtpCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the FTP transparent proxy
    protocol-component after a 'StopProtocol'. It runs when the last reference
    to the component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("FtpCleanupProtocol");
    if (FtpGlobalInfo) { NH_FREE(FtpGlobalInfo); FtpGlobalInfo = NULL; }
    if (FtpTimerQueueHandle) {
        DeleteTimerQueueEx(FtpTimerQueueHandle, INVALID_HANDLE_VALUE);
        FtpTimerQueueHandle = NULL;
    }
    if (FtpPortReservationHandle) {
        NatShutdownPortReservation(FtpPortReservationHandle);
        FtpPortReservationHandle = NULL;
    }
    if (FtpTranslatorHandle) {
        NatShutdownTranslator(FtpTranslatorHandle); FtpTranslatorHandle = NULL;
    }
    InterlockedExchange(reinterpret_cast<LPLONG>(&FtpProtocolStopped), 1);
    SetEvent(FtpNotificationEvent);
    ResetComponentReference(&FtpComponentReference);

} // FtpCleanupProtocol


BOOLEAN
FtpInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the FnP module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &FtpComponentReference, FtpCleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&FtpGlobalInfoLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&FtpComponentReference);
        return FALSE;
    }

    if (FtpInitializeInterfaceManagement())  {
        DeleteCriticalSection(&FtpGlobalInfoLock);
        DeleteComponentReference(&FtpComponentReference);
        return FALSE;
    }

    return TRUE;

} // FtpInitializeModule


ULONG
APIENTRY
FtpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("FtpRmStartProtocol");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_FTP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&FtpGlobalInfoLock);

        Size = sizeof(*FtpGlobalInfo);

        FtpGlobalInfo =
            reinterpret_cast<PIP_FTP_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!FtpGlobalInfo) {
            LeaveCriticalSection(&FtpGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "FtpRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_FTP_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(FtpGlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        FtpNotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&FtpSupportFunctions, sizeof(FtpSupportFunctions));
        } else {
            CopyMemory(
                &FtpSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        //
        // Obtain a handle to the kernel-mode translation module.
        //

        Error = NatInitializeTranslator(&FtpTranslatorHandle);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "FtpRmStartProtocol: error %d initializing translator",
                Error
                );
            break;
        }

        //
        // Obtain a port-reservation handle
        //

        Error =
            NatInitializePortReservation(
                FTP_PORT_RESERVATION_BLOCK_SIZE, &FtpPortReservationHandle
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "FtpRmStartProtocol: error %d initializing port-reservation",
                Error
                );
            break;
        }

        FtpTimerQueueHandle = CreateTimerQueue();
        if (FtpTimerQueueHandle == NULL) {
            Error = GetLastError();
            NhTrace(
                TRACE_FLAG_INIT,
                "FtpRmStartProtocol: error %d initializing timer queue",
                Error
                );
            break;
        }

        LeaveCriticalSection(&FtpGlobalInfoLock);
        InterlockedExchange(reinterpret_cast<LPLONG>(&FtpProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmStartProtocol


ULONG
APIENTRY
FtpRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // FtpRmStartComplete


ULONG
APIENTRY
FtpRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&FtpComponentReference);

    return DEREFERENCE_FTP() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // FtpRmStopProtocol


ULONG
APIENTRY
FtpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmAddInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpCreateInterface(
            Index,
            Type,
            (PIP_FTP_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmAddInterface


ULONG
APIENTRY
FtpRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmDeleteInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpDeleteInterface(
            Index
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmDeleteInterface


ULONG
APIENTRY
FtpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("FtpRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&FtpProtocolStopped), 0))
    {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // FtpRmGetEventMessage


ULONG
APIENTRY
FtpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("FtpRmGetInterfaceInfo");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpQueryInterface(
            Index,
            (PIP_FTP_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmGetInterfaceInfo


ULONG
APIENTRY
FtpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("FtpRmSetInterfaceInfo");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpConfigureInterface(
            Index,
            (PIP_FTP_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmSetInterfaceInfo


ULONG
APIENTRY
FtpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = FtpRmBindInterface(Index, StatusInfo);
            } else {
                Error = FtpRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = FtpRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = FtpRmDisableInterface(Index);
            break;
        }
    }

    return Error;

} // FtpRmInterfaceStatus


ULONG
FtpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmBindInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpBindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmBindInterface


ULONG
FtpRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmUnbindInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpUnbindInterface(
            Index
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmUnbindInterface


ULONG
FtpRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmEnableInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpEnableInterface(
            Index
            );

    DEREFERENCE_FTP_AND_RETURN(Error);

} // FtpRmEnableInterface


ULONG
FtpRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("FtpRmDisableInterface");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        FtpDisableInterface(
            Index
            );

    DEREFERENCE_FTP_AND_RETURN(Error);
} // FtpRmDisableInterface


ULONG
APIENTRY
FtpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("FtpRmGetGlobalInfo");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_FTP_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&FtpGlobalInfoLock);
    Size = sizeof(*FtpGlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&FtpGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_FTP_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, FtpGlobalInfo, Size);
    LeaveCriticalSection(&FtpGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}

    DEREFERENCE_FTP_AND_RETURN(NO_ERROR);
} // FtpRmGetGlobalInfo


ULONG
APIENTRY
FtpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_FTP_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("FtpRmSetGlobalInfo");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_FTP_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*FtpGlobalInfo);
    NewInfo = reinterpret_cast<PIP_FTP_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "FtpRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_FTP_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_FTP_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&FtpGlobalInfoLock);
    OldFlags = FtpGlobalInfo->Flags;
    NH_FREE(FtpGlobalInfo);
    FtpGlobalInfo = NewInfo;
    NewFlags = FtpGlobalInfo->Flags;
    LeaveCriticalSection(&FtpGlobalInfoLock);

    DEREFERENCE_FTP_AND_RETURN(NO_ERROR);
} // FtpRmSetGlobalInfo


ULONG
APIENTRY
FtpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
FtpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
FtpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The transparent proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_FTP_MIB_QUERY Oidp;

    PROFILE("FtpRmMibGet");

    REFERENCE_FTP_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Oidp = (PIP_FTP_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_FTP_STATISTICS_OID: {
                if (*OutputDataSize < sizeof(*Oidp) + sizeof(FtpStatistics)) {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(FtpStatistics);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    *OutputDataSize = sizeof(*Oidp) + sizeof(FtpStatistics);
                    Oidp = (PIP_FTP_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_FTP_STATISTICS_OID;
                    CopyMemory(
                        Oidp->Data,
                        &FtpStatistics,
                        sizeof(FtpStatistics)
                        );
                    Error = NO_ERROR;
                }
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_FTP,
                    "FtpRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_FTP_AND_RETURN(Error);
}


ULONG
APIENTRY
FtpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
FtpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
FtpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\h323\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "timer.h"
#include "natio.h"
#include "natconn.h"
#include "rmapi.h"

#include "rmh323.h"

#include "h323if.h"
#include "h323log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\debug.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    debug.h

Abstract:

    This module contains declarations for debugging and eventlogging support.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_DEBUG_H_
#define _NATHLP_DEBUG_H_

#define TRACE_FLAG_PROFILE      ((ULONG)0x00010000 | TRACE_USE_MASK)
#define TRACE_FLAG_SOCKET       ((ULONG)0x00020000 | TRACE_USE_MASK)
#define TRACE_FLAG_IF           ((ULONG)0x00040000 | TRACE_USE_MASK)
#define TRACE_FLAG_IO           ((ULONG)0x00080000 | TRACE_USE_MASK)
#define TRACE_FLAG_DHCP         ((ULONG)0x00100000 | TRACE_USE_MASK)
#define TRACE_FLAG_BUFFER       ((ULONG)0x00200000 | TRACE_USE_MASK)
#define TRACE_FLAG_INIT         ((ULONG)0x00400000 | TRACE_USE_MASK)
#define TRACE_FLAG_DNS          ((ULONG)0x00800000 | TRACE_USE_MASK)
#define TRACE_FLAG_NAT          ((ULONG)0x01000000 | TRACE_USE_MASK)
#define TRACE_FLAG_REG          ((ULONG)0x02000000 | TRACE_USE_MASK)
#define TRACE_FLAG_TIMER        ((ULONG)0x04000000 | TRACE_USE_MASK)
// MASK VALUE 0x08000000 is available, 
#define TRACE_FLAG_H323         ((ULONG)0x10000000 | TRACE_USE_MASK)
#define TRACE_FLAG_FTP          ((ULONG)0x20000000 | TRACE_USE_MASK)
#define TRACE_FLAG_FWLOG        ((ULONG)0x40000000 | TRACE_USE_MASK)
#define TRACE_FLAG_ALG			((ULONG)0x80000000 | TRACE_USE_MASK)

#if 1
#define PROFILE(f)              NhTrace(TRACE_FLAG_PROFILE, f)
#else
#if DBG
#define PROFILE(f)              NhTrace(TRACE_FLAG_PROFILE, f)
#else
#define PROFILE(f)
#endif
#endif

extern HANDLE NhEventLogHandle;

//
// TRACING ROUTINE DECLARATIONS
//

VOID
NhDump(
    ULONG Flags,
    PUCHAR Buffer,
    ULONG BufferLength,
    ULONG Width
    );

VOID
NhInitializeTraceManagement(
    VOID
    );

VOID
NhShutdownTraceManagement(
    VOID
    );

VOID
NhTrace(
    ULONG Flags,
    PCHAR Format,
    ...
    );

//
// EVENT-LOGGING ROUTINE DECLARATIONS
//

VOID
NhInitializeEventLogManagement(
    VOID
    );

VOID
NhErrorLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhInformationLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhWarningLog(
    ULONG MessageId,
    ULONG ErrorCode,
    PCHAR Format,
    ...
    );

VOID
NhShutdownEventLogManagement(
    VOID
    );

#endif // _NATHLP_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\natapip.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    natapip.h

Abstract:

    This module contains private declarations for the NAT's I/O interface
    to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   16-Jun-1999

Revision History:

--*/

#ifndef _NATAPI_NATAPIP_H_
#define _NATAPI_NATAPIP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))

#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

#ifndef REFERENCE_OBJECT
#define REFERENCE_OBJECT(x,deleted) \
    (deleted(x) ? FALSE : (InterlockedIncrement(&(x)->ReferenceCount), TRUE))
#endif

#ifndef DEREFERENCE_OBJECT
#define DEREFERENCE_OBJECT(x,cleanup) \
    (InterlockedDecrement(&(x)->ReferenceCount) ? TRUE : (cleanup(x), FALSE))
#endif

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );

#ifdef __cplusplus
}
#endif

#endif // _NATAPI_NATAPIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\compref.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    compref.h

Abstract:

    This module contains declarations for maintaining reference-count
    on a component. It provides an asynchronous thread-safe means of
    handling cleanup in a module.

    The mechanism defined uses a locked reference count and cleanup-routine
    to manage the lifetime of the component. When the reference-count
    is dropped to zero, the associated cleanup-routine is invoked.

Author:

    Abolade Gbadegesin (aboladeg)   6-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_COMPREF_H_
#define _NATHLP_COMPREF_H_

typedef
VOID
(*PCOMPONENT_CLEANUP_ROUTINE)(
    VOID
    );

//
// Structure:   COMPONENT_REFERENCE
//
// This structure must reside in memory for the lifetime of the component
// to which it refers. It is used to synchronize the component's execution.
//

typedef struct _COMPONENT_REFERENCE {
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    BOOLEAN Deleted;
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine;
#if COMPREF_TRACKING
    struct _COMPREF_RECORD* RecordArray;
    ULONG RecordIndex;
#endif
} COMPONENT_REFERENCE, *PCOMPONENT_REFERENCE;

#if COMPREF_TRACKING
#define COMPREF_RECORD_COUNT    (1024)
typedef struct _COMPREF_RECORD {
    PCHAR File;
    USHORT Line;
    UCHAR ReferenceCount;
    enum {
        ComprefAcquireRecord,
        ComprefReleaseRecord
    } Type;
} COMPREF_RECORD, *PCOMPREF_RECORD;
#endif


//
// FUNCTION DECLARATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    );

#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    );
#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    );

//
// MACRO DECLARATIONS
//

#define RETURN_VOID

#if COMPREF_TRACKING

#define REFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)

#define DEREFERENCE_COMPONENT(c) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!RecordComponentReference(c, __FILE__, __LINE__, ComprefAcquireRecord)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    RecordComponentReference(c, __FILE__, __LINE__, ComprefReleaseRecord); \
    return retcode

#else

#define REFERENCE_COMPONENT(c) \
    AcquireComponentReference(c)

#define DEREFERENCE_COMPONENT(c) \
    ReleaseComponentReference(c)

#define REFERENCE_COMPONENT_OR_RETURN(c,retcode) \
    if (!AcquireComponentReference(c)) { return retcode; }

#define DEREFERENCE_COMPONENT_AND_RETURN(c,retcode) \
    ReleaseComponentReference(c); return retcode

#endif


//
// INLINE ROUTINE IMPLEMENTATIONS
//

__inline
BOOLEAN
AcquireComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to increment the reference-count to a component.
    The attempt may fail if the initial reference has been released
    and the component is therefore being deleted.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was referenced, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    ++ComponentReference->ReferenceCount;
    LeaveCriticalSection(&ComponentReference->Lock);
    return TRUE;

} // AcquireComponentReference


VOID
__inline
DeleteComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to destroy a component reference.
    It may only be called after the last reference to the component is released,
    i.e. after 'ReleaseComponentReference' has returned 'TRUE'.
    It may also be called from within the component's 'CleanupRoutine'.

Arguments:

    ComponentReference - the component to be destroyed

Return Value:

    none.

--*/

{
    DeleteCriticalSection(&ComponentReference->Lock);
#if COMPREF_TRACKING
    HeapFree(GetProcessHeap(), 0, ComponentReference->RecordArray);
#endif

} // DeleteComponentReference


ULONG
__inline
InitializeComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCOMPONENT_CLEANUP_ROUTINE CleanupRoutine
    )

/*++

Routine Description:

    This routine is called to initialize a component reference.

Arguments:

    ComponentReference - the component to be initialized

    CleanupRoutine - the routine to be called when the component
        is to be cleaned up (within the final 'ReleaseComponentReference').

Return Value:

    none.

--*/

{
    __try {
        InitializeCriticalSection(&ComponentReference->Lock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }
    ComponentReference->Deleted = FALSE;
    ComponentReference->ReferenceCount = 1;
    ComponentReference->CleanupRoutine = CleanupRoutine;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ComponentReference->RecordArray =
        HeapAlloc(
            GetProcessHeap(), 0, sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
            );
#endif
    return NO_ERROR;

} // InitializeComponentReference



#if COMPREF_TRACKING
__inline
BOOLEAN
RecordComponentReference(
    PCOMPONENT_REFERENCE ComponentReference,
    PCHAR File,
    ULONG Line,
    UCHAR Type
    )
{
    BOOLEAN Success;
    ULONG i = InterlockedIncrement(&ComponentReference->RecordIndex);
    i %= COMPREF_RECORD_COUNT;
    ComponentReference->RecordArray[i].File = File;
    ComponentReference->RecordArray[i].Line = (USHORT)Line;
    ComponentReference->RecordArray[i].Type = Type;
    if (Type == ComprefAcquireRecord) {
        Success = AcquireComponentReference(ComponentReference);
    } else {
        Success = ReleaseComponentReference(ComponentReference);
    }
    ComponentReference->RecordArray[i].ReferenceCount =
        (UCHAR)ComponentReference->ReferenceCount;
    return Success;
}

#endif

__inline
BOOLEAN
ReleaseComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop a reference to a component.
    If the reference drops to zero, cleanup is performed.
    Otherwise, cleanup occurs later when the last reference is released.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseComponentReference


__inline
BOOLEAN
ReleaseInitialComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to drop the initial reference to a component,
    and mark the component as deleted.
    If the reference drops to zero, cleanup is performed right away.

Arguments:

    ComponentReference - the component to be referenced

Return Value:

    BOOLEAN - TRUE if the component was cleaned up, FALSE otherwise.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    if (ComponentReference->Deleted) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return TRUE;
    }
    ComponentReference->Deleted = TRUE;
    if (--ComponentReference->ReferenceCount) {
        LeaveCriticalSection(&ComponentReference->Lock);
        return FALSE;
    }
    LeaveCriticalSection(&ComponentReference->Lock);
    ComponentReference->CleanupRoutine();
    return TRUE;
} // ReleaseInitialComponentReference


__inline
VOID
ResetComponentReference(
    PCOMPONENT_REFERENCE ComponentReference
    )

/*++

Routine Description:

    This routine is called to reset a component reference
    to an initial state.

Arguments:

    ComponentReference - the component to be reset

Return Value:

    none.

--*/

{
    EnterCriticalSection(&ComponentReference->Lock);
    ComponentReference->ReferenceCount = 1;
    ComponentReference->Deleted = FALSE;
#if COMPREF_TRACKING
    ComponentReference->RecordIndex = 0;
    ZeroMemory(
        ComponentReference->RecordArray,
        sizeof(COMPREF_RECORD) * COMPREF_RECORD_COUNT
        );
#endif
    LeaveCriticalSection(&ComponentReference->Lock);
} // ReleaseComponentReference



#endif // _NATHLP_COMPREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\natconn.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natconn.h

Abstract:

    This module contains declarations for the NAT's RAS connection management.
    Outgoing RAS client connections may be shared by associating them with
    a router-interface of type ROUTER_IF_TYPE_HOME_ROUTER.
    When such a connection is established by the user, we detect the connection
    and create a corresponding NAT interface with the kernel-mode translator.

Author:

    Abolade Gbadegesin (aboladeg)   2-May-1998

Revision History:

--*/

#ifndef _NATHLP_NATCONN_H_
#define _NATHLP_NATCONN_H_

extern HANDLE NatConnectionNotifyEvent;
extern HANDLE NatConfigurationChangedEvent;

//
// Structure : NAT_UDP_BROADCAST_MAPPING
//

typedef struct _NAT_UDP_BROADCAST_MAPPING
{
    LIST_ENTRY Link;
    USHORT usPublicPort;
    PVOID pvCookie;    
} NAT_UDP_BROADCAST_MAPPING, *PNAT_UDP_BROADCAST_MAPPING;

//
// Structure: NAT_PORT_MAPPING_ENTRY
//

typedef struct _NAT_PORT_MAPPING_ENTRY
{
    LIST_ENTRY Link;
    
    UCHAR ucProtocol;
    USHORT usPublicPort;
    ULONG ulPrivateAddress;
    USHORT usPrivatePort;

    BOOLEAN fNameActive;
    
    BOOLEAN fUdpBroadcastMapping;
    PVOID pvBroadcastCookie;

    GUID *pProtocolGuid;
    IHNetPortMappingProtocol *pProtocol;
    IHNetPortMappingBinding *pBinding;
    
} NAT_PORT_MAPPING_ENTRY, *PNAT_PORT_MAPPING_ENTRY;

//
// Structure: NAT_CONNECTION_ENTRY
//

typedef struct _NAT_CONNECTION_INFO
{
    LIST_ENTRY Link;

    //
    // Information needed to configure kernel driver
    //
    
    PIP_NAT_INTERFACE_INFO pInterfaceInfo;
    PIP_ADAPTER_BINDING_INFO pBindingInfo;
    NAT_INTERFACE Interface;
    ULONG AdapterIndex;

    //
    // HNetCfg interfaces for the connection
    //
    
    IHNetConnection *pHNetConnection;
    IHNetFirewalledConnection *pHNetFwConnection;
    IHNetIcsPublicConnection *pHNetIcsPublicConnection;

    //
    // Cached information describing the connection. Storing
    // this allows us to reduce roundtrips to the store.
    //
    
    HNET_CONN_PROPERTIES HNetProperties;
    GUID Guid;
    LPWSTR wszPhonebookPath;

    //
    // Stored port mapping information
    //

    LIST_ENTRY PortMappingList; // The length of this list is the sum of the counts
    ULONG PortMappingCount;
    ULONG UdpBroadcastPortMappingCount;
} NAT_CONNECTION_ENTRY, *PNAT_CONNECTION_ENTRY;

PNAT_CONNECTION_ENTRY
NatFindConnectionEntry(
    GUID *pGuid
    );

PNAT_PORT_MAPPING_ENTRY
NatFindPortMappingEntry(
    PNAT_CONNECTION_ENTRY pConnection,
    GUID *pGuid
    );

VOID
NatFreePortMappingEntry(
    PNAT_PORT_MAPPING_ENTRY pEntry
    );


#ifdef DIALIN_SHARING
VOID
NatProcessClientConnection(
    VOID
    );
#endif

PCHAR
NatQuerySharedConnectionDomainName(
    VOID
    );

ULONG
NatStartConnectionManagement(
    VOID
    );

VOID
NatStopConnectionManagement(
    VOID
    );

BOOLEAN
NatUnbindAllConnections(
    VOID
    );

#endif // _NATHLP_NATCONN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\buffer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    This module contains declarations for buffer-management.

    All network I/O in this component occurs via completion packets.
    The buffer routines below are used to acquire and release the buffers
    used for sending and receiving data.

    In addition to holding the data transferred, the buffers contain fields
    to facilitate their use with completion ports. See below for details
    on the use of the fields.

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_BUFFER_H_
#define _NATHLP_BUFFER_H_

#define NH_BUFFER_SIZE              576
#define NH_MAX_BUFFER_QUEUE_LENGTH  32

struct _NH_BUFFER;

//
// Typedef:     PNH_COMPLETION_ROUTINE
//

typedef
VOID
(*PNH_COMPLETION_ROUTINE)(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    struct _NH_BUFFER* Bufferp
    );


//
// Structure:   NH_BUFFER
//
// This structure holds a buffer used for network I/O on a socket.
//

typedef enum _NH_BUFFER_TYPE {
    NhFixedLengthBufferType,
    NhVariableLengthBufferType
} NH_BUFFER_TYPE;

typedef struct _NH_BUFFER {
    union {
        LIST_ENTRY Link;
        NH_BUFFER_TYPE Type;
    };
    //
    // The socket associated with the buffer's most recent I/O request
    //
    SOCKET Socket;
    //
    // Completion routine and contexts for the buffer's most recent I/O request
    //
    PNH_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Context2;
    //
    // Passed as the system context area for any I/O using the buffer
    //
    OVERLAPPED Overlapped;
    //
    // Upon completion of a receive, the receive-flags and source-address
    // length for the message read
    //
    ULONG ReceiveFlags;
    ULONG AddressLength;
    union {
        //
        // Holds the source address when a datagram-read completes
        //
        SOCKADDR_IN ReadAddress;
        //
        // Holds the destination address while a datagram-send is in progress
        //
        SOCKADDR_IN WriteAddress;
        //
        // Holds the remote address while a connect is in progress
        //
        SOCKADDR_IN ConnectAddress;
        //
        // Holds the state of a multi-request read or write
        //
        struct {
            ULONG UserFlags;
            ULONG BytesToTransfer;
            ULONG TransferOffset;
        };
    };
    //
    // Upon completion of an I/O request, the error-code, byte-count,
    // and data-bytes for the request
    //
    ULONG ErrorCode;
    ULONG BytesTransferred;
    UCHAR Buffer[NH_BUFFER_SIZE];
} NH_BUFFER, *PNH_BUFFER;

#define NH_ALLOCATE_BUFFER() \
    reinterpret_cast<PNH_BUFFER>(NH_ALLOCATE(sizeof(NH_BUFFER)))
    
#define NH_FREE_BUFFER(b)       NH_FREE(b)


//
// BUFFER-MANAGEMENT ROUTINES (alphabetically)
//

#define NhAcquireBuffer() NhAcquireFixedLengthBuffer()
PNH_BUFFER
NhAcquireFixedLengthBuffer(
    VOID
    );

PNH_BUFFER
NhAcquireVariableLengthBuffer(
    ULONG Length
    );

PNH_BUFFER
NhDuplicateBuffer(
    PNH_BUFFER Bufferp
    );

ULONG
NhInitializeBufferManagement(
    VOID
    );

VOID
NhReleaseBuffer(
    PNH_BUFFER Bufferp
    );

VOID
NhShutdownBufferManagement(
    VOID
    );

#endif // _NATHLP_BUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\nathlpp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    nathlpp.h

Abstract:

    This module contains declarations common to the user-mode components
    of home-networking.

Author:

    Abolade Gbadegesin (aboladeg)   5-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATHLPP_H_
#define _NATHLP_NATHLPP_H_


//
// Object synchronization macros
//

#define ACQUIRE_LOCK(x)         EnterCriticalSection(&(x)->Lock)
#define RELEASE_LOCK(x)         LeaveCriticalSection(&(x)->Lock)

#define REFERENCE_OBJECT(x,deleted) \
    (deleted(x) \
        ? FALSE \
        : (InterlockedIncrement( \
            reinterpret_cast<LPLONG>(&(x)->ReferenceCount) \
            ), TRUE))

#define DEREFERENCE_OBJECT(x,cleanup) \
    (InterlockedDecrement(reinterpret_cast<LPLONG>(&(x)->ReferenceCount)) \
        ? TRUE \
        : (cleanup(x), FALSE))

//
// Memory management macros
//

#define NH_ALLOCATE(s)          HeapAlloc(GetProcessHeap(), 0, (s))
#define NH_FREE(p)              HeapFree(GetProcessHeap(), 0, (p))

//
// Protocol-related constants
//

#define DHCP_PORT_SERVER        0x4300
#define DHCP_PORT_CLIENT        0x4400

#define DNS_PORT_SERVER         0x3500
#define WINS_PORT_SERVER        0x8900

#define FTP_PORT_DATA           0x1400
#define FTP_PORT_CONTROL        0x1500

#define ALG_PORT_DATA           0x1600
#define ALG_PORT_CONTROL        0x1700

//
// DNS suffix string
//

#define DNS_HOMENET_SUFFIX      L"mshome.net"               // default string

#endif // _NATHLP_NATHLPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\h323\rmh323.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmh323.c

Abstract:

    This module contains routines for the H.323 transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <h323icsp.h>

COMPONENT_REFERENCE H323ComponentReference;
PIP_H323_GLOBAL_INFO H323GlobalInfo = NULL;
CRITICAL_SECTION H323GlobalInfoLock;
HANDLE H323NotificationEvent;
ULONG H323ProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS H323RoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_H323,
    RF_ROUTING|RF_ADD_ALL_INTERFACES,
    H323RmStartProtocol,
    H323RmStartComplete,
    H323RmStopProtocol,
    H323RmGetGlobalInfo,
    H323RmSetGlobalInfo,
    NULL,
    NULL,
    H323RmAddInterface,
    H323RmDeleteInterface,
    H323RmInterfaceStatus,
    
    H323RmGetInterfaceInfo,
    H323RmSetInterfaceInfo,
    H323RmGetEventMessage,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    H323RmMibCreate,
    H323RmMibDelete,
    H323RmMibGet,
    H323RmMibSet,
    H323RmMibGetFirst,
    H323RmMibGetNext,
    NULL,
    NULL
};

SUPPORT_FUNCTIONS H323SupportFunctions;


VOID
H323CleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the H.323 transparent proxy module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    // TODO: Call h323ics!CleanupModule
    H323ProxyCleanupModule();

    H323ShutdownInterfaceManagement();
    DeleteCriticalSection(&H323GlobalInfoLock);
    DeleteComponentReference(&H323ComponentReference);

} // H323CleanupModule


VOID
H323CleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the H.323 transparent proxy
    protocol-component after a 'StopProtocol'. It runs when the last reference
    to the component is released. (See 'COMPREF.H').

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("H323CleanupProtocol");
    if (H323GlobalInfo) { NH_FREE(H323GlobalInfo); H323GlobalInfo = NULL; }

    // TODO: Call h323ics!StopService
    H323ProxyStopService();

    InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 1);
    SetEvent(H323NotificationEvent);
    ResetComponentReference(&H323ComponentReference);

} // H323CleanupProtocol


BOOLEAN
H323InitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the H323 module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    if (InitializeComponentReference(
            &H323ComponentReference, H323CleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&H323GlobalInfoLock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&H323ComponentReference);
        return FALSE;
    }

    if (H323InitializeInterfaceManagement())  {
        DeleteCriticalSection(&H323GlobalInfoLock);
        DeleteComponentReference(&H323ComponentReference);
        return FALSE;
    }

    // TODO: Call h323ics!InitializeModule
    H323ProxyInitializeModule();

    return TRUE;

} // H323InitializeModule


ULONG
APIENTRY
H323RmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount    
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("H323RmStartProtocol");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&H323GlobalInfoLock);

        Size = sizeof(*H323GlobalInfo);
    
        H323GlobalInfo
            = reinterpret_cast<PIP_H323_GLOBAL_INFO>(NH_ALLOCATE(Size));

        if (!H323GlobalInfo) {
            LeaveCriticalSection(&H323GlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "H323RmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_H323_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(H323GlobalInfo, GlobalInfo, Size);

        //
        // Save the notification event
        //

        H323NotificationEvent = NotificationEvent;

        //
        // Save the support functions
        //

        if (!SupportFunctions) {
            ZeroMemory(&H323SupportFunctions, sizeof(H323SupportFunctions));
        } else {
            CopyMemory(
                &H323SupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }

        // TODO: Call h323ics!StartModule
        H323ProxyStartService();

        LeaveCriticalSection(&H323GlobalInfoLock);
        InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmStartProtocol


ULONG
APIENTRY
H323RmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // H323RmStartComplete


ULONG
APIENTRY
H323RmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&H323ComponentReference);

    return DEREFERENCE_H323() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // H323RmStopProtocol


ULONG
APIENTRY
H323RmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmAddInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323CreateInterface(
            Index,
            Type,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo,
            NULL
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmAddInterface


ULONG
APIENTRY
H323RmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmDeleteInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323DeleteInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmDeleteInterface


ULONG
APIENTRY
H323RmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("H323RmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&H323ProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // H323RmGetEventMessage


ULONG
APIENTRY
H323RmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("H323RmGetInterfaceInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323QueryInterface(
            Index,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmGetInterfaceInfo


ULONG
APIENTRY
H323RmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("H323RmSetInterfaceInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        H323ConfigureInterface(
            Index,
            (PIP_H323_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmSetInterfaceInfo


ULONG
APIENTRY
H323RmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = H323RmBindInterface(Index, StatusInfo);
            } else {
                Error = H323RmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = H323RmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = H323RmDisableInterface(Index);
            break;
        }
    }

    return Error;
    
} // H323RmInterfaceStatus


ULONG
H323RmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmBindInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323BindInterface(
            Index,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmBindInterface


ULONG
H323RmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmUnbindInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323UnbindInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmUnbindInterface


ULONG
H323RmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.

Arguments:

    Index - the interface to be enabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmEnableInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323EnableInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmEnableInterface


ULONG
H323RmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.

Arguments:

    Index - the interface to be disabled.

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("H323RmDisableInterface");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        H323DisableInterface(
            Index
            );

    DEREFERENCE_H323_AND_RETURN(Error);

} // H323RmDisableInterface


ULONG
APIENTRY
H323RmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("H323RmGetGlobalInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER);
    }

    EnterCriticalSection(&H323GlobalInfoLock);
    Size = sizeof(*H323GlobalInfo);
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&H323GlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_H323_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, H323GlobalInfo, Size);
    LeaveCriticalSection(&H323GlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_H323_AND_RETURN(NO_ERROR);
    
} // H323RmGetGlobalInfo


ULONG
APIENTRY
H323RmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG OldFlags;
    ULONG NewFlags;
    PIP_H323_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("H323RmSetGlobalInfo");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_H323_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size = sizeof(*H323GlobalInfo);
    NewInfo = reinterpret_cast<PIP_H323_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "H323RmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_H323_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_H323_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    EnterCriticalSection(&H323GlobalInfoLock);
    OldFlags = H323GlobalInfo->Flags;
    NH_FREE(H323GlobalInfo);
    H323GlobalInfo = NewInfo;
    NewFlags = H323GlobalInfo->Flags;
    LeaveCriticalSection(&H323GlobalInfoLock);

    DEREFERENCE_H323_AND_RETURN(NO_ERROR);
    
} // H323RmSetGlobalInfo


ULONG
APIENTRY
H323RmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
H323RmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The transparent proxy only exposes one item to the MIB; its statistics.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_H323_MIB_QUERY Oidp;

    PROFILE("H323RmMibGet");

    REFERENCE_H323_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Oidp = (PIP_H323_MIB_QUERY)InputData;
//      switch(Oidp->Oid) {
//          default: {
                NhTrace(
                    TRACE_FLAG_H323,
                    "H323RmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
//              break;
//          }
//      }
    }

    DEREFERENCE_H323_AND_RETURN(Error);
}


ULONG
APIENTRY
H323RmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
H323RmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\natio.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natio.h

Abstract:

    This module contains declarations for the NAT's I/O interface
    to the kernel-mode driver. It also contains the user-mode stubs
    which proxy router-manager requests to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATIO_H_
#define _NATHLP_NATIO_H_

//
// Structure:   NAT_INTERFACE
//
// This structure describes an interface which has been created with the NAT.
// Each interface is inserted into the list of interfaces, sorted by 'Index'.
// Access to the list of interfaces is controlled by 'NatInterfaceLock'.
//

typedef struct _NAT_INTERFACE {
    LIST_ENTRY Link;
    ULONG Index;
    ULONG AdapterIndex;
    ROUTER_INTERFACE_TYPE Type;
    ULONG Flags;
    PIP_NAT_INTERFACE_INFO Info;
} NAT_INTERFACE, *PNAT_INTERFACE;





#define NAT_INTERFACE_FLAG_ADDED_FTP		0x80000000
#define NAT_INTERFACE_ADDED_FTP(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_FTP)

#define NAT_INTERFACE_FLAG_BOUND			0x40000000
#define NAT_INTERFACE_BOUND(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_BOUND)

// MASK 0x20000000 is available

#define NAT_INTERFACE_FLAG_ADDED_H323		0x10000000
#define NAT_INTERFACE_ADDED_H323(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_H323)

#define NAT_INTERFACE_FLAG_ADDED_ALG		0x08000000
#define NAT_INTERFACE_ADDED_ALG(i) \
    ((i)->Flags & NAT_INTERFACE_FLAG_ADDED_ALG)

//
// GLOBAL VARIABLE DECLARATIONS
//

extern HANDLE NatFileHandle;
extern LIST_ENTRY NatInterfaceList;
extern CRITICAL_SECTION NatInterfaceLock;

//
// FUNCTION DECLARATIONS
//

ULONG
NatBindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo,
    ULONG AdapterIndex
    );

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatConfigureDriver(
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatConfigureInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    );

ULONG
NatCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    );

ULONG
NatCreateTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    );

ULONG
NatDeleteInterface(
    ULONG Index
    );

ULONG
NatDeleteTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    );

#define NAT_IF_CHAR_BOUNDARY    0x00000001
#define NAT_IF_CHAR_PRIVATE     0x00000002
#define NAT_IF_CHAR_FW          0x00000004

#define NAT_IFC_BOUNDARY(_Flags) \
    ((_Flags) & NAT_IF_CHAR_BOUNDARY)

#define NAT_IFC_PRIVATE(_Flags) \
    ((_Flags) & NAT_IF_CHAR_PRIVATE)

#define NAT_IFC_FW(_Flags) \
    ((_Flags) & NAT_IF_CHAR_FW)

ULONG
NatGetInterfaceCharacteristics(
    ULONG Index
    );

VOID
NatInstallApplicationSettings(
    VOID
    );

BOOLEAN
NatIsBoundaryInterface(
    ULONG Index,
    PBOOLEAN IsNatInterface OPTIONAL
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

ULONG
NatQueryInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo,
    PULONG InterfaceInfoSize
    );

ULONG
NatQueryInterfaceMappingTable(
    ULONG Index,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    );

ULONG
NatQueryMappingTable(
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    );

ULONG
NatQueryStatisticsInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics,
    PULONG InterfaceStatisticsSize
    );

VOID
NatRemoveApplicationSettings(
    VOID
    );

ULONG
NatUnbindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );

ULONG
NatLookupPortMappingAdapter(
    ULONG AdapterIndex,
    UCHAR Protocol,
    ULONG PublicAddress,
    USHORT PublicPort,
    PIP_NAT_PORT_MAPPING PortMappingp
    );

#endif // _NATHLP_NATIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\natlog.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natlog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Abolade Gbadegesin (aboladeg)   25-Mar-1998

Revision History:

--*/

#define IP_NAT_LOG_BASE                             32000

#define IP_NAT_LOG_UPDATE_ARP_FAILED                (IP_NAT_LOG_BASE+1)
/*
 * The Network Address Translator (NAT) was unable to update the
 * local address-resolution table to respond to requests for
 * IP address %1 and mask %2.
 * Address-resolution may fail to operate for addresses in the given range.
 * This error may indicate a problem with TCP/IP networking,
 * or it may indicate lack of support for address-resolution
 * in the underlying network interface.
 * The data is the error code.
 */

#define IP_NAT_LOG_ALLOCATION_FAILED                (IP_NAT_LOG_BASE+2)
/*
 * The Network Address Translator (NAT) was unable to allocate %1 bytes.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_NAT_LOG_IOCTL_FAILED                     (IP_NAT_LOG_BASE+3)
/*
 * The Network Address Translator (NAT) was unable to request an operation
 * of the kernel-mode translation module.
 * This may indicate misconfiguration, insufficient resources, or
 * an internal error.
 * The data is the error code.
 */

#define IP_NAT_LOG_LOAD_DRIVER_FAILED               (IP_NAT_LOG_BASE+4)
/*
 * The Network Address Translator (NAT) was unable to load
 * the kernel-mode translation module.
 * The data is the error code.
 */

#define IP_NAT_LOG_UNLOAD_DRIVER_FAILED             (IP_NAT_LOG_BASE+5)
/*
 * The Network Address Translator (NAT) was unable to unload
 * the kernel-mode translation module.
 * The data is the error code.
 */

#define IP_NAT_LOG_SHARED_ACCESS_CONFLICT           (IP_NAT_LOG_BASE+6)
/*
 * The Internet Connection Sharing service could not start because
 * another process has taken control of the kernel-mode translation module.
 * This may occur when the Connection Sharing component has been installed
 * in the Routing and Remote Access Manager.
 * If this is the case, please remove the Connection Sharing component 
 * and restart the Internet Connection Sharing service.
 */

#define IP_NAT_LOG_ROUTING_PROTOCOL_CONFLICT        (IP_NAT_LOG_BASE+7)
/*
 * The Connection Sharing component could not start because another process
 * has taken control of the kernel-mode translation module.
 * This may occur when Internet Connection Sharing has been enabled
 * for a connection.
 * If this is the case, please disable Internet Connection Sharing
 * for the connection in the Network Connections folder and then
 * restart Routing and Remote Access.
 */

#define IP_NAT_LOG_END                              (IP_NAT_LOG_BASE+999)
/*
 * end.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmalg.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmALG.h

Abstract:

    This module declares routines for the ALG transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    JPDup		10-Nov-2000

Revision History:

--*/

#ifndef _NATHLP_RMALG_H_
#define _NATHLP_RMALG_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE                  AlgComponentReference;
extern PIP_ALG_GLOBAL_INFO                  AlgGlobalInfo;
extern CRITICAL_SECTION                     AlgGlobalInfoLock;
extern HANDLE                               AlgNotificationEvent;
extern HANDLE                               AlgTimerQueueHandle;
extern HANDLE                               AlgPortReservationHandle;
extern ULONG                                AlgProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS    AlgRoutingCharacteristics;
extern IP_ALG_STATISTICS                    AlgStatistics;
extern SUPPORT_FUNCTIONS                    AlgSupportFunctions;
extern HANDLE                               AlgTranslatorHandle;

//
// MACRO DECLARATIONS
//

#define REFERENCE_ALG() \
    REFERENCE_COMPONENT(&AlgComponentReference)

#define REFERENCE_ALG_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&AlgComponentReference,retcode)

#define DEREFERENCE_ALG() \
    DEREFERENCE_COMPONENT(&AlgComponentReference)

#define DEREFERENCE_ALG_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&AlgComponentReference, retcode)

#define ALG_PORT_RESERVATION_BLOCK_SIZE 32

//
// FUNCTION DECLARATIONS
//

VOID
AlgCleanupModule(
    VOID
    );

BOOLEAN
AlgInitializeModule(
    VOID
    );

ULONG
APIENTRY
AlgRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
AlgRmStartComplete(
    VOID
    );

ULONG
APIENTRY
AlgRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
AlgRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
AlgRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
AlgRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
AlgRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
AlgRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
AlgRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
AlgRmPortMappingChanged(
    ULONG Index,
    UCHAR Protocol,
    USHORT Port
    );

#endif // _NATHLP_RMALG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\range.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    range.h

Abstract:

    This module implements an efficient mapping from an arbitrary range of
    IP addresses to a minimal set of IP address-mask pairs covering the range.

    The key to the approach is to regard the set of all possible IP addresses
    as a full 32-bit deep binary tree. Then a single IP address is a path
    through that tree, and a range of addresses is the area between two paths
    through the tree. We then describe such a path-delineated area by pruning
    full subtrees of the area recursively from left to right.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RANGE_H_
#define _NATHLP_RANGE_H_

typedef
VOID
(*PDECOMPOSE_RANGE_CALLBACK)(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );

VOID
DecomposeRange(
    ULONG StartAddress,
    ULONG EndAddress,
    ULONG Mask,
    PDECOMPOSE_RANGE_CALLBACK Callback,
    PVOID CallbackContext
    );

ULONG
MostGeneralMask(
    ULONG StartAddress,
    ULONG EndAddress
    );

#endif // _NATHLP_RANGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\pastlog.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    pastlog.h

Abstract:

    This module contains text messages used to generate event-log entries
    by the component.

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_PASTLOG_H_
#define _NATHLP_PASTLOG_H_

#define IP_PAST_LOG_BASE                       36000

#define IP_PAST_LOG_NAT_INTERFACE_IGNORED      (IP_PAST_LOG_BASE+1)
/*
 * The PAST transparent proxy detected network address translation (NAT)
 * enabled on the interface with index '%1'.
 * The agent has disabled itself on the interface in order to avoid
 * confusing clients.
 */

#define IP_PAST_LOG_ACTIVATE_FAILED            (IP_PAST_LOG_BASE+2)
/*
 * The PAST transparent proxy was unable to bind to the IP address %1.
 * This error may indicate a problem with TCP/IP networking.
 * The data is the error code.
 */

#define IP_PAST_LOG_RECEIVE_FAILED             (IP_PAST_LOG_BASE+3)
/*
 * The PAST transparent proxy encountered a network error while
 * attempting to receive messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_PAST_LOG_ALLOCATION_FAILED          (IP_PAST_LOG_BASE+4)
/*
 * The PAST transparent proxy was unable to allocate %1 bytes of memory.
 * This may indicate that the system is low on virtual memory,
 * or that the memory-manager has encountered an internal error.
 */

#define IP_PAST_LOG_ACCEPT_FAILED              (IP_PAST_LOG_BASE+5)
/*
 * The PAST transparent proxy encountered a network error while
 * attempting to accept connections on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_PAST_LOG_SEND_FAILED                (IP_PAST_LOG_BASE+7)
/*
 * The PAST transparent proxy encountered a network error while
 * attempting to send messages on the interface with IP address %1.
 * The data is the error code.
 */

#define IP_PAST_LOG_END                        (IP_PAST_LOG_BASE+999)
/*
 * end.
 */

#endif // _NATHLP_PASTLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmdns.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdns.h

Abstract:

    This module declares routines for the DNS allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMDNS_H_
#define _NATHLP_RMDNS_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE DnsComponentReference;
extern PIP_DNS_PROXY_GLOBAL_INFO DnsGlobalInfo;
extern CRITICAL_SECTION DnsGlobalInfoLock;
extern SOCKET DnsGlobalSocket;
extern HANDLE DnsNotificationEvent;
extern ULONG DnsProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS DnsRoutingCharacteristics;
extern IP_DNS_PROXY_STATISTICS DnsStatistics;
extern SUPPORT_FUNCTIONS DnsSupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_DNS() \
    REFERENCE_COMPONENT(&DnsComponentReference)

#define REFERENCE_DNS_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&DnsComponentReference,retcode)

#define DEREFERENCE_DNS() \
    DEREFERENCE_COMPONENT(&DnsComponentReference)

#define DEREFERENCE_DNS_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&DnsComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
DnsCleanupModule(
    VOID
    );

BOOLEAN
DnsInitializeModule(
    VOID
    );

BOOLEAN
DnsIsDnsEnabled(
    VOID
    );

BOOLEAN
DnsIsWinsEnabled(
    VOID
    );

ULONG
APIENTRY
DnsRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmStartComplete(
    VOID
    );

ULONG
APIENTRY
DnsRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
DnsRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
DnsRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DnsRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
DnsRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
DnsRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DnsRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DnsRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DnsRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DnsRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DnsRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DnsRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMDNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmapi.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmapi.h

Abstract:

    This module contains declarations for the part of the router-manager
    interface which is common to all the protocols in this component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMAPI_H_
#define _NATHLP_RMAPI_H_

typedef enum {
    NhUninitializedMode,
    NhSharedAccessMode,
    NhRoutingProtocolMode,
    NhMaximumMode
} NH_COMPONENT_MODE, *PNH_COMPONENT_MODE;

#define NhIsBoundaryInterface(i,b) NatIsBoundaryInterface((i),(b))
#define NhQuerySharedConnectionDomainName() NatQuerySharedConnectionDomainName()

extern NH_COMPONENT_MODE NhComponentMode;
extern CRITICAL_SECTION NhLock;
extern const WCHAR NhTcpipParametersString[];

//
// Application settings (response protocols) handling
//

extern LIST_ENTRY NhApplicationSettingsList;
extern LIST_ENTRY NhDhcpReservationList;
extern DWORD NhDhcpScopeAddress;
extern DWORD NhDhcpScopeMask;

typedef struct _NAT_APP_ENTRY
{
    LIST_ENTRY Link;
    UCHAR Protocol;
    USHORT Port;
    USHORT ResponseCount;
    HNET_RESPONSE_RANGE *ResponseArray;
} NAT_APP_ENTRY, *PNAT_APP_ENTRY;

typedef struct _NAT_DHCP_RESERVATION
{
    LIST_ENTRY Link;
    LPWSTR Name;
    ULONG Address;
} NAT_DHCP_RESERVATION, *PNAT_DHCP_RESERVATION;

typedef DWORD (CALLBACK *MAPINTERFACETOADAPTER)(DWORD);

VOID
NhBuildDhcpReservations(
    VOID
    );

ULONG
NhDialSharedConnection(
    VOID
    );

VOID
NhFreeApplicationSettings(
    VOID
    );

VOID
NhFreeDhcpReservations(
    VOID
    );

BOOLEAN
NhIsDnsProxyEnabled(
    VOID
    );

BOOLEAN
NhIsLocalAddress(
    ULONG Address
    );

BOOLEAN
NhIsWinsProxyEnabled(
    VOID
    );

PIP_ADAPTER_BINDING_INFO
NhQueryBindingInformation(
    ULONG AdapterIndex
    );

NTSTATUS
NhQueryDomainName(
    PCHAR* DomainName
    );

NTSTATUS
NhQueryValueKey(
    HANDLE Key,
    const WCHAR ValueName[],
    PKEY_VALUE_PARTIAL_INFORMATION* Information
    );

VOID
NhSignalNatInterface(
    ULONG Index,
    BOOLEAN Boundary
    );

ULONG
NhMapAddressToAdapter(
    ULONG Address
    );

ULONG
NhMapInterfaceToAdapter(
    ULONG Index
    );

extern
ULONG
NhMapInterfaceToRouterIfType(
    ULONG Index
    );

VOID
NhResetComponentMode(
    VOID
    );

BOOLEAN
NhSetComponentMode(
    NH_COMPONENT_MODE ComponentMode
    );

VOID
NhUpdateApplicationSettings(
    VOID
    );

ULONG
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS RoutingCharacteristics,
    IN OUT PMPR_SERVICE_CHARACTERISTICS ServiceCharacteristics
    );

#endif // _NATHLP_RMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmdhcp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmdhcp.h

Abstract:

    This module declares routines for the DHCP allocator module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMDHCP_H_
#define _NATHLP_RMDHCP_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE DhcpComponentReference;
extern PCHAR DhcpDomainName;
extern PIP_AUTO_DHCP_GLOBAL_INFO DhcpGlobalInfo;
extern CRITICAL_SECTION DhcpGlobalInfoLock;
extern HANDLE DhcpNotificationEvent;
extern ULONG DhcpProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS DhcpRoutingCharacteristics;
extern IP_AUTO_DHCP_STATISTICS DhcpStatistics;
extern SUPPORT_FUNCTIONS DhcpSupportFunctions;

extern BOOLEAN NoLocalDns; //whether DNS server is running or going to run on local host

//
// MACRO DECLARATIONS
//

#define REFERENCE_DHCP() \
    REFERENCE_COMPONENT(&DhcpComponentReference)

#define REFERENCE_DHCP_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&DhcpComponentReference,retcode)

#define DEREFERENCE_DHCP() \
    DEREFERENCE_COMPONENT(&DhcpComponentReference)

#define DEREFERENCE_DHCP_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&DhcpComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
DhcpCleanupModule(
    VOID
    );

BOOLEAN
DhcpInitializeModule(
    VOID
    );

ULONG
APIENTRY
DhcpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmStartComplete(
    VOID
    );

ULONG
APIENTRY
DhcpRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
DhcpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
DhcpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
DhcpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
DhcpRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
DhcpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
DhcpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DhcpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
DhcpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
DhcpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMDNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmftp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    rmftp.h

Abstract:

    This module declares routines for the FTP transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Qiang Wang  (qiangw)        10-Apr-2000

Revision History:

--*/

#ifndef _NATHLP_RMFTP_H_
#define _NATHLP_RMFTP_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE FtpComponentReference;
extern PIP_FTP_GLOBAL_INFO FtpGlobalInfo;
extern CRITICAL_SECTION FtpGlobalInfoLock;
extern HANDLE FtpNotificationEvent;
extern HANDLE FtpTimerQueueHandle;
extern HANDLE FtpPortReservationHandle;
extern ULONG FtpProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS FtpRoutingCharacteristics;
extern IP_FTP_STATISTICS FtpStatistics;
extern SUPPORT_FUNCTIONS FtpSupportFunctions;
extern HANDLE FtpTranslatorHandle;

//
// MACRO DECLARATIONS
//

#define REFERENCE_FTP() \
    REFERENCE_COMPONENT(&FtpComponentReference)

#define REFERENCE_FTP_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&FtpComponentReference,retcode)

#define DEREFERENCE_FTP() \
    DEREFERENCE_COMPONENT(&FtpComponentReference)

#define DEREFERENCE_FTP_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&FtpComponentReference, retcode)

#define FTP_PORT_RESERVATION_BLOCK_SIZE 32

//
// FUNCTION DECLARATIONS
//

VOID
FtpCleanupModule(
    VOID
    );

BOOLEAN
FtpInitializeModule(
    VOID
    );

ULONG
APIENTRY
FtpRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
FtpRmStartComplete(
    VOID
    );

ULONG
APIENTRY
FtpRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
FtpRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
FtpRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
FtpRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
FtpRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
FtpRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
FtpRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
FtpRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
FtpRmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
FtpRmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
FtpRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
FtpRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
FtpRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
FtpRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
FtpRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
FtpRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
FtpRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
FtpRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
FtpRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMFTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmnat.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmnat.h

Abstract:

    This module declares routines for the NAT module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_RMNAT_H_
#define _NATHLP_RMNAT_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE NatComponentReference;
extern PIP_NAT_GLOBAL_INFO NatGlobalInfo;
extern CRITICAL_SECTION NatGlobalInfoLock;
extern HANDLE NatNotificationEvent;
extern ULONG NatProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS NatRoutingCharacteristics;
extern SUPPORT_FUNCTIONS NatSupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_NAT() \
    REFERENCE_COMPONENT(&NatComponentReference)

#define REFERENCE_NAT_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&NatComponentReference,retcode)

#define DEREFERENCE_NAT() \
    DEREFERENCE_COMPONENT(&NatComponentReference)

#define DEREFERENCE_NAT_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&NatComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
NatCleanupModule(
    VOID
    );

BOOLEAN
NatInitializeModule(
    VOID
    );

ULONG
APIENTRY
NatRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmStartComplete(
    VOID
    );

ULONG
APIENTRY
NatRmStopProtocol(
    VOID
    );

ULONG
APIENTRY
NatRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
NatRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
NatRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
NatRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
NatRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
NatRmUnbindInterface(
    ULONG Index
    );

ULONG
NatRmEnableInterface(
    ULONG Index
    );

ULONG
NatRmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
NatRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
NatRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
NatRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
NatRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
NatRmConnectClient(
    ULONG Index,
    PVOID ClientAddress
    );

ULONG
APIENTRY
NatRmDisconnectClient(
    ULONG Index,
    PVOID ClientAddress
    );

#endif // _NATHLP_RMNAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\socket.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    socket.h

Abstract:

    This module contains declarations for socket-management.
    The routines declared here operate asynchronously on sockets
    associated with an I/O completion port. They are also integrated
    with the component-reference object, which may optionally be used
    by callers to control the number of outstanding entries into a component's
    address-space. (See 'COMPREF.H'.)

Author:

    Abolade Gbadegesin (aboladeg)   2-Mar-1998

Revision History:

    Abolade Gbadegesin (aboladeg)   23-May-1999

    Added support for stream sockets.

    Jonathan Burstein (jonburs)     12-April-2001

    Added support for raw datagram sockets.

--*/


#ifndef _NATHLP_SOCKET_H_
#define _NATHLP_SOCKET_H_

#define INET_NTOA(x)    inet_ntoa(*(struct in_addr*)&(x))

ULONG
NhAcceptStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ListeningSocket,
    SOCKET AcceptedSocket OPTIONAL,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE AcceptCompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhConnectStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET ConnectingSocket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE ConnectCompletionRoutine,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine OPTIONAL,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhCreateDatagramSocket(
    ULONG Address,
    USHORT Port,
    OUT SOCKET* Socketp
    );

ULONG
NhCreateRawDatagramSocket(
    OUT SOCKET* Socketp
    );

ULONG
NhCreateStreamSocket(
    ULONG Address OPTIONAL, // may be INADDR_NONE
    USHORT Port OPTIONAL,
    OUT SOCKET* Socketp
    );

#define NhDeleteDatagramSocket(s) NhDeleteSocket(s)
#define NhDeleteStreamSocket(s) NhDeleteSocket(s)

VOID
NhDeleteSocket(
    SOCKET Socket
    );

//
// BOOLEAN
// NhIsFatalSocketError(
//     ULONG Error
//     );
//
// Determines whether a request may be reissued on a socket,
// given the error-code from the previous issuance of the request.
// This macro is arranged to branch on the most common error-codes first.
//

#define \
NhIsFatalSocketError( \
    _Error \
    ) \
    ((_Error) != ERROR_OPERATION_ABORTED && \
    ((_Error) == WSAEDISCON || \
     (_Error) == WSAECONNRESET || \
     (_Error) == WSAETIMEDOUT || \
     (_Error) == WSAENETDOWN || \
     (_Error) == WSAENOTSOCK || \
     (_Error) == WSAESHUTDOWN || \
     (_Error) == WSAECONNABORTED))

ULONG
NhNotifyOnCloseStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CloseNotificationRoutine,
    PVOID Context,
    PVOID Context2
    );

VOID
NhQueryAcceptEndpoints(
    PUCHAR AcceptBuffer,
    PULONG LocalAddress OPTIONAL,
    PUSHORT LocalPort OPTIONAL,
    PULONG RemoteAddress OPTIONAL,
    PUSHORT RemotePort OPTIONAL
    );

ULONG
NhQueryAddressSocket(
    SOCKET Socket
    );

ULONG
NhQueryLocalEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

USHORT
NhQueryPortSocket(
    SOCKET Socket
    );

ULONG
NhQueryRemoteEndpointSocket(
    SOCKET Socket,
    PULONG Address OPTIONAL,
    PUSHORT Port OPTIONAL
    );

ULONG
NhReadDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhReadStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp OPTIONAL,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhWriteDatagramSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    ULONG Address,
    USHORT Port,
    PNH_BUFFER Bufferp,
    ULONG Length,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

ULONG
NhWriteStreamSocket(
    PCOMPONENT_REFERENCE Component,
    SOCKET Socket,
    PNH_BUFFER Bufferp,
    ULONG Length,
    ULONG Offset,
    PNH_COMPLETION_ROUTINE CompletionRoutine,
    PVOID Context,
    PVOID Context2
    );

#endif // _NATHLP_SOCKET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\timer.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    timer.h

Abstract:

    This module contains declarations for manipulating the timer-queue
    which is shared by all the components in this module.

    In addition to being used for protocol-related timers, the queue
    is used for periodically reissuing failed read-requests on sockets.

Author:

    Abolade Gbadegesin (aboladeg)   1-April-1998

Revision History:

--*/

#ifndef _NATHLP_TIMER_H_
#define _NATHLP_TIMER_H_

ULONG
NhInitializeTimerManagement(
    VOID
    );

NTSTATUS
NhSetTimer(
    PCOMPONENT_REFERENCE Component OPTIONAL,
    OUT HANDLE* Handlep OPTIONAL,
    WAITORTIMERCALLBACKFUNC TimerRoutine,
    PVOID Context,
    ULONG DueTime
    );

VOID
NhShutdownTimerManagement(
    VOID
    );

NTSTATUS
NhUpdateTimer(
    HANDLE Handle,
    ULONG DueTime
    );

#endif // _NATHLP_TIMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natapi\natapi.c ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natapi.c

Abstract:

    This module contains code for API routines which provide translation
    functionality to user-mode clients of the NAT. This functionality
    differs from the 'normal' mode, in which a boundary-interface is designated
    and packets are transparently modified as they cross the boundary.
    This module instead allows an application to stipulate that certain
    modifications be made to a packet on any interface it is received.

Author:

    Abolade Gbadegesin  (aboladeg)  08-May-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>

C_ASSERT(NAT_INVALID_IF_INDEX == INVALID_IF_INDEX);

//
// PRIVATE STRUCTURE DECLARATIONS
//

//
// Structure:   NAT_REDIRECT
//
// Encapsulates information about an outstanding redirect-instance.
// For a normal redirect, the structure holds the caller-specified
// completion-parameters and output statistics.
// For a dynamic redirect instance, the structure links this instance
// into the dynamic redirect's instance-list, and contains the notification
// event for the instance.
//

typedef struct _NAT_REDIRECT {
    union {
        struct _NAT_REDIRECT_TAIL {
            IO_STATUS_BLOCK IoStatus;
            PNAT_COMPLETION_ROUTINE CompletionRoutine;
            PVOID CompletionContext;
            IP_NAT_REDIRECT_STATISTICS Statistics;
        };
        struct _NAT_DYNAMIC_REDIRECT_TAIL {
            LIST_ENTRY Link;
            ULONG InstanceId;
            HANDLE Event;
            HANDLE WaitHandle;
            struct _NAT_DYNAMIC_REDIRECT_CONTEXT* Context;
        };
    };
} NAT_REDIRECT, *PNAT_REDIRECT;

//
// Structure:   NAT_DYNAMIC_REDIRECT
//
// Encapsulates information about an outstanding dynamic redirect.
// A dynamic redirect is automatically reissued using the caller's original
// parameters whenever the number of instances drops below a given minimum
// specified by the creator. We maintain a list of all instances of a dynamic
// redirect, and we replenish the list whenever an instance is activated
// or terminated without being activated.
//
// For each dynamic redirect, we maintain a reference-count which is used
// to control its lifetime. We make references to the dynamic redirect when
//  * the redirect is initially created, on behalf of its existence,
//  * an additional instance is issued, on behalf of the notification routine
//      for the instance.
//
// The usual rules for synchronization apply, to wit, to access any fields
// a reference must be held, and to add a reference the lock must be held,
// except at creation-time when the initial reference is made.
//

typedef struct _NAT_DYNAMIC_REDIRECT {
    CRITICAL_SECTION Lock;
    ULONG ReferenceCount;
    ULONG Flags;
    HANDLE TranslatorHandle;
    ULONG MinimumBacklog;
    LIST_ENTRY InstanceList;
    IP_NAT_CREATE_REDIRECT_EX CreateRedirect;
} NAT_DYNAMIC_REDIRECT, *PNAT_DYNAMIC_REDIRECT;

#define NAT_DYNAMIC_REDIRECT_FLAG_DELETED   0x80000000
#define NAT_DYNAMIC_REDIRECT_DELETED(d) \
    ((d)->Flags & NAT_DYNAMIC_REDIRECT_FLAG_DELETED)

#define NAT_REFERENCE_DYNAMIC_REDIRECT(d) \
    REFERENCE_OBJECT(d, NAT_DYNAMIC_REDIRECT_DELETED)

#define NAT_DEREFERENCE_DYNAMIC_REDIRECT(d) \
    DEREFERENCE_OBJECT(d, NatpCleanupDynamicRedirect)

#define DEFAULT_DYNAMIC_REDIRECT_BACKLOG 5

//
// Structure:   NAT_DYNAMIC_REDIRECT_CONTEXT
//
// Used as the context-parameter for the notification and completion routines
// of each instance of a dynamic redirect.
//

typedef struct _NAT_DYNAMIC_REDIRECT_CONTEXT {
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp;
    ULONG InstanceId;
} NAT_DYNAMIC_REDIRECT_CONTEXT, *PNAT_DYNAMIC_REDIRECT_CONTEXT;


//
// GLOBAL DATA DEFINITIONS
//

const WCHAR NatpServicePath[] =
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\IPNAT";
ULONG NextRedirectInstanceId = 0;
IO_STATUS_BLOCK UnusedIoStatus;
IP_NAT_REDIRECT_STATISTICS UnusedStatistics;

//
// FORWARD DECLARATIONS
//

VOID
NatCloseDriver(
    HANDLE FileHandle
    );

ULONG
NatLoadDriver(
    OUT PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    );

ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    );

VOID
NatpCleanupDynamicRedirect(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    );

VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

VOID NTAPI
NatpDynamicRedirectNotificationRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    );

BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

VOID NTAPI
NatpRedirectCompletionRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );

VOID
NatpCreateDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    );

VOID
NatpDeleteDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp,
    PNAT_REDIRECT Redirectp
    );

BOOLEAN
NatpValidateRedirectParameters(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL
    );

ULONG
NatUnloadDriver(
    HANDLE FileHandle
    );


ULONG
NatCancelDynamicRedirect(
    HANDLE DynamicRedirectHandle
    )

/*++

Routine Description:

    This routine is called to cancel the given dynamic redirect.
    It cancels all instances of the dynamic redirect and releases the initial
    reference to the dynamic redirect, thus causing cleanup to occur as soon
    as all active references are released.

Arguments:

    DynamicRedirectHandle - the handle to the dynamic redirect to be cancelled

Return Value:

    ULONG - Win32 status code.

--*/

{
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp =
        (PNAT_DYNAMIC_REDIRECT)DynamicRedirectHandle;

    //
    // Lock the dynamic redirect, mark it 'deleted' to ensure that
    // no more instances are created by our notification routines,
    // and delete all outstanding instances.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    if (NAT_DYNAMIC_REDIRECT_DELETED(DynamicRedirectp)) {
        LeaveCriticalSection(&DynamicRedirectp->Lock);
        return ERROR_INVALID_PARAMETER;
    }
    DynamicRedirectp->Flags |= NAT_DYNAMIC_REDIRECT_FLAG_DELETED;
    while (!IsListEmpty(&DynamicRedirectp->InstanceList)) {
        PNAT_REDIRECT Redirectp =
            CONTAINING_RECORD(
                DynamicRedirectp->InstanceList.Flink,
                NAT_REDIRECT,
                Link
                );
        NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    //
    // Release the initial reference to the dynamic redirect and return.
    //

    NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
    return NO_ERROR;
} // NatCancelDynamicRedirect


ULONG
NatCancelRedirect(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort
    )

/*++

Routine Description:

    This routine is invoked to cancel a redirect for a session.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    * - specify the redirect to be cancelled

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_LOOKUP_REDIRECT CancelRedirect;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CancelRedirect.Flags = 0;
    CancelRedirect.RedirectApcContext = NULL;
    CancelRedirect.Protocol = Protocol;
    CancelRedirect.DestinationAddress = DestinationAddress;
    CancelRedirect.DestinationPort = DestinationPort;
    CancelRedirect.SourceAddress = SourceAddress;
    CancelRedirect.SourcePort = SourcePort;
    CancelRedirect.NewDestinationAddress = NewDestinationAddress;
    CancelRedirect.NewDestinationPort = NewDestinationPort;
    CancelRedirect.NewSourceAddress = NewSourceAddress;
    CancelRedirect.NewSourcePort = NewSourcePort;

    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CANCEL_REDIRECT,
            (PVOID)&CancelRedirect,
            sizeof(CancelRedirect),
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatCancelRedirect


VOID
NatCloseDriver(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This routine is called to close a handle to the NAT driver's device-object.

Arguments:

    FileHandle - the handle to be closed.

Return Value:

    none.

--*/

{
    NtClose(FileHandle);
} // NatCloseDriver


ULONG
NatCreateDynamicFullRedirect(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG RestrictAdapterIndex OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

/*++

Routine Description:

    This routine is invoked to create a redirect which is dynamically
    managed to ensure that there are always at least a specified minimum
    number of instances active. It is suitable for use by transparent proxies,
    which require assurance that all sessions matching a given description
    will be redirected by the kernel-mode translation module.

    The routine creates and initializes a structure which encapsulates all the
    information required to establish an instance of the caller's redirect.
    It then creates a series of instances of the redirect, and returns.
    We rely on notification routines to replace each instance that is
    activated or terminated.

Arguments:

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

    RestrictSourceAddress - optionally specifies the source address to which
        the redirect should be applied

    RestrictAdapterIndex - optionally specifies the adapter index that this
        redirect should be restricted to

    MinimumBacklog - optionally specifies the number of pending redirect
        instances to leave as a backlog

    DynamicRedirectHandlep - on output, receives a handle to the newly-created
        dynamic redirect.

Return Value:

    ULONG - Win32 status code.

--*/

{
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp;
    ULONG Error;
    ULONG i;

    if (!DynamicRedirectHandlep ||
        !NatpValidateRedirectParameters(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            (Flags & NatRedirectFlagRestrictSource) ? RestrictSourceAddress : SourceAddress,
            SourcePort,
            NewDestinationAddress,
            NewDestinationPort,
            NewSourceAddress,
            NewSourcePort,
            RestrictAdapterIndex
            )) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Create and initialize the new dynamic redirect.
    //

    DynamicRedirectp = MALLOC(sizeof(*DynamicRedirectp));
    if (!DynamicRedirectp) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory(DynamicRedirectp, sizeof(*DynamicRedirectp));
    __try {
        InitializeCriticalSection(&DynamicRedirectp->Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        Error = GetExceptionCode();
        FREE(DynamicRedirectp);
        return Error;
    }
    DynamicRedirectp->ReferenceCount = 1;
    InitializeListHead(&DynamicRedirectp->InstanceList);
    DynamicRedirectp->TranslatorHandle = NULL;
    DynamicRedirectp->MinimumBacklog =
        (MinimumBacklog ? MinimumBacklog : DEFAULT_DYNAMIC_REDIRECT_BACKLOG);
    DynamicRedirectp->CreateRedirect.Flags =
        Flags | IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS;
    DynamicRedirectp->CreateRedirect.Protocol = Protocol;
    DynamicRedirectp->CreateRedirect.DestinationAddress = DestinationAddress;
    DynamicRedirectp->CreateRedirect.DestinationPort = DestinationPort;
    DynamicRedirectp->CreateRedirect.SourceAddress = SourceAddress;
    DynamicRedirectp->CreateRedirect.SourcePort = SourcePort;
    DynamicRedirectp->CreateRedirect.NewDestinationAddress =
        NewDestinationAddress;
    DynamicRedirectp->CreateRedirect.NewDestinationPort = NewDestinationPort;
    DynamicRedirectp->CreateRedirect.NewSourceAddress = NewSourceAddress;
    DynamicRedirectp->CreateRedirect.NewSourcePort = NewSourcePort;
    DynamicRedirectp->CreateRedirect.RestrictSourceAddress =
        RestrictSourceAddress;
    DynamicRedirectp->CreateRedirect.RestrictAdapterIndex =
        ((Flags & NatRedirectFlagRestrictAdapter)
            ? RestrictAdapterIndex
            : NAT_INVALID_IF_INDEX);

    //
    // Obtain a private handle to the kernel-mode translation module.
    // It is important that this handle be private because, as noted
    // in 'NatpDeleteDynamicRedirectInstance', we may mistakenly cancel
    // redirects during normal execution, and they had better belong to us.
    //

    if (Error = NatOpenDriver(&DynamicRedirectp->TranslatorHandle)) {
        NatpCleanupDynamicRedirect(DynamicRedirectp);
        return Error;
    }

    //
    // Issue the first set of redirects for the caller's minimum backlog.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    for (i = 0; i < DynamicRedirectp->MinimumBacklog; i++) {
        NatpCreateDynamicRedirectInstance(DynamicRedirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    *DynamicRedirectHandlep = (HANDLE)DynamicRedirectp;
    return NO_ERROR;

} // NatCreateDynamicFullRedirect


ULONG
NatCreateDynamicRedirect(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

{
    return
        NatCreateDynamicFullRedirect(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            0,
            0,
            NewDestinationAddress,
            NewDestinationPort,
            0,
            0,
            RestrictSourceAddress,
            0,
            MinimumBacklog,
            DynamicRedirectHandlep
            );
}


ULONG
NatCreateDynamicRedirectEx(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG RestrictSourceAddress OPTIONAL,
    ULONG RestrictAdapterIndex OPTIONAL,
    ULONG MinimumBacklog OPTIONAL,
    OUT PHANDLE DynamicRedirectHandlep
    )

{
    return
        NatCreateDynamicFullRedirect(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            0,
            0,
            NewDestinationAddress,
            NewDestinationPort,
            0,
            0,
            RestrictSourceAddress,
            RestrictAdapterIndex,
            MinimumBacklog,
            DynamicRedirectHandlep
            );
}


ULONG
NatCreateRedirect(
    HANDLE TranslatorHandle,
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    PNAT_COMPLETION_ROUTINE CompletionRoutine,
    PVOID CompletionContext,
    HANDLE NotifyEvent OPTIONAL
    )

{
    return NatCreateRedirectEx(
                TranslatorHandle,
                Flags,
                Protocol,
                DestinationAddress,
                DestinationPort,
                SourceAddress,
                SourcePort,
                NewDestinationAddress,
                NewDestinationPort,
                NewSourceAddress,
                NewSourcePort,
                0,
                CompletionRoutine,
                CompletionContext,
                NotifyEvent
                );
}


ULONG
NatCreateRedirectEx(
    HANDLE TranslatorHandle,
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL,
    PNAT_COMPLETION_ROUTINE CompletionRoutine,
    PVOID CompletionContext,
    HANDLE NotifyEvent OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to install a redirect for a session.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

    RestrictAdapterIndex - optionally specifies the adapter index that this
        redirect should be restricted to

    Completion* - specifies routine invoked on completion of the session,
        and the context to be passed to the routine

    NotifyEvent - optionally specifies an event to be signalled
        when a session matches the redirect.

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_REDIRECT_EX CreateRedirect;
    PNAT_REDIRECT Redirectp;
    PIO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE CompletionEvent;

    if (!NatpValidateRedirectParameters(
            Flags,
            Protocol,
            DestinationAddress,
            DestinationPort,
            SourceAddress,
            SourcePort,
            NewDestinationAddress,
            NewDestinationPort,
            NewSourceAddress,
            NewSourcePort,
            RestrictAdapterIndex
            )) {
        return ERROR_INVALID_PARAMETER;
    }

    if (!CompletionRoutine) {
        Redirectp = NULL;
        IoStatus = &UnusedIoStatus;
        CompletionEvent = NULL;
    } else if (IPNATAPI_SET_EVENT_ON_COMPLETION == CompletionRoutine) {
        Redirectp = NULL;
        IoStatus = &UnusedIoStatus;
        CompletionEvent = (HANDLE)CompletionContext;
    } else {
        Redirectp = (PNAT_REDIRECT)MALLOC(sizeof(*Redirectp));
        if (!Redirectp) { return ERROR_NOT_ENOUGH_MEMORY; }
        Redirectp->CompletionRoutine = CompletionRoutine;
        Redirectp->CompletionContext = CompletionContext;
        IoStatus = &Redirectp->IoStatus;
    }

    if (Flags & NatRedirectFlagRestrictSource) {
        CreateRedirect.RestrictSourceAddress = SourceAddress;
        SourceAddress = 0;
    } else {
        CreateRedirect.RestrictSourceAddress = 0;
    }

    CreateRedirect.Flags = Flags;
    CreateRedirect.Protocol = Protocol;
    CreateRedirect.DestinationAddress = DestinationAddress;
    CreateRedirect.DestinationPort = DestinationPort;
    CreateRedirect.SourceAddress = SourceAddress;
    CreateRedirect.SourcePort = SourcePort;
    CreateRedirect.NewDestinationAddress = NewDestinationAddress;
    CreateRedirect.NewDestinationPort = NewDestinationPort;
    CreateRedirect.NewSourceAddress = NewSourceAddress;
    CreateRedirect.NewSourcePort = NewSourcePort;
    CreateRedirect.NotifyEvent = NotifyEvent;
    CreateRedirect.RestrictAdapterIndex =
        ((Flags & NatRedirectFlagRestrictAdapter)
            ? RestrictAdapterIndex
            : NAT_INVALID_IF_INDEX);

    if (!CompletionRoutine
        || IPNATAPI_SET_EVENT_ON_COMPLETION == CompletionRoutine ) {
        
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                CompletionEvent,
                NULL,
                NULL,
                IoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&CreateRedirect,
                sizeof(CreateRedirect),
                (PVOID)&UnusedStatistics,
                sizeof(UnusedStatistics)
                );
    } else {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                NULL,
                NatpRedirectCompletionRoutine,
                Redirectp,
                IoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&CreateRedirect,
                sizeof(CreateRedirect),
                (PVOID)&Redirectp->Statistics,
                sizeof(Redirectp->Statistics)
                );
    }
    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatCreateRedirect


ULONG
NatInitializeTranslator(
    PHANDLE TranslatorHandle
    )

/*++

Routine Description:

    This routine is invoked to prepare for translation by loading the NAT
    and installing all local adapters as interfaces.

Arguments:

    TranslatorHandle - receives the file handle of the NAT driver

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    IP_NAT_GLOBAL_INFO GlobalInfo;

    //
    // Initialize the NAT's global configuration
    //

    ZeroMemory(&GlobalInfo, sizeof(GlobalInfo));
    GlobalInfo.Header.Version = IP_NAT_VERSION;
    GlobalInfo.Header.Size = FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry);

    //
    // Start the NAT module.
    // This step causes the driver to be loaded.
    //

    Error = NatLoadDriver(TranslatorHandle, &GlobalInfo);
    if (Error) {
        return Error;
    }

    return NO_ERROR;

} // NatInitializeTranslator


ULONG
NatLoadDriver(
    PHANDLE FileHandle,
    PIP_NAT_GLOBAL_INFO GlobalInfo
    )

/*++

Routine Description:

    This routine is invoked to initialize the NAT's data and start the driver.

Arguments:

    FileHandle - receives the handle for the NAT's file-object

    GlobalInfo - the global information for the NAT.

Return Value:

    ULONG - Win32 status code.

--*/

{
    UNICODE_STRING DeviceName;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;
    HANDLE WaitEvent;

#if 0
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Request that the service controller load the driver.
    // Note that this will either succeed immediately or fail immediately;
    // there is no 'checkpoint' processing for starting drivers.
    //

    if (!(ScmHandle = OpenSCManager(NULL, NULL, GENERIC_READ))) {
        Error = GetLastError();
    } else {
        if (!(ServiceHandle =
            OpenServiceA(ScmHandle, IP_NAT_SERVICE_NAME, GENERIC_EXECUTE))) {
            Error = GetLastError();
        } else {
            if (!StartService(ServiceHandle, 0, NULL) &&
                (Error = GetLastError()) != ERROR_SERVICE_ALREADY_RUNNING) {
            } else {
                Error = NO_ERROR;
            }
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }
    if (Error) {
        return Error;
    }
}
#else
{
    UNICODE_STRING ServicePath;
    BOOLEAN WasEnabled;

    //
    // Turn on our driver-loading ability
    //

    if (!NatpEnableLoadDriverPrivilege(&WasEnabled)) {
        return ERROR_ACCESS_DENIED;
    }

    RtlInitUnicodeString(&ServicePath, NatpServicePath);

    //
    // Load the driver
    //

    status = NtLoadDriver(&ServicePath);

    //
    // Turn off the privilege
    //

    NatpDisableLoadDriverPrivilege(&WasEnabled);

    //
    // See if the load-attempt succeeded
    //

    if (!NT_SUCCESS(status) && status != STATUS_IMAGE_ALREADY_LOADED) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }
}
#endif

    //
    // Obtain a handle to the NAT's device-object.
    //

    Error = NatOpenDriver(FileHandle);
    if (Error) {
        return Error;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Set the global configuration of the NAT
    //

    status =
        NtDeviceIoControlFile(
            *FileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_GLOBAL_INFO,
            (PVOID)GlobalInfo,
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + GlobalInfo->Header.Size,
            NULL,
            0
            );

    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(status)) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }

    return NO_ERROR;

} // NatLoadDriver


ULONG
NatLookupAndQueryInformationSessionMapping(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_SESSION_MAPPING_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine attempts to locate a particular session mapping using either
    its forward key or reverse key, and to query information for the mapping,
    if found.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    Protocol - the IP protocol for the mapping to be located

    Destination* - the destination endpoint for the mapping

    Source* - the source endpoint for the mapping

    Information - on output, receives the requested information

    InformationLength - on input, contains the length of the buffer
        at 'Information'; on output, receives the length of the information
        stored in 'Information', or the length of the buffer required.

    InformationClass - specifies

Return Value:

    ULONG - Win32 status code.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_LOOKUP_SESSION_MAPPING LookupMapping;
    NTSTATUS status;
    HANDLE WaitEvent;

    if (!InformationLength ||
        InformationClass >= NatMaximumSessionMappingInformation) {
        return ERROR_INVALID_PARAMETER;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LookupMapping.Protocol = Protocol;
    LookupMapping.DestinationAddress = DestinationAddress;
    LookupMapping.DestinationPort = DestinationPort;
    LookupMapping.SourceAddress = SourceAddress;
    LookupMapping.SourcePort = SourcePort;
    if (InformationClass == NatKeySessionMappingInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else if (InformationClass == NatStatisticsSessionMappingInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_STATISTICS,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else if (InformationClass == NatKeySessionMappingExInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_LOOKUP_SESSION_MAPPING_KEY_EX,
                (PVOID)&LookupMapping,
                sizeof(LookupMapping),
                (PVOID)Information,
                *InformationLength
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    } else {
        CloseHandle(WaitEvent);
        return ERROR_INVALID_PARAMETER;
    }
    CloseHandle(WaitEvent);
    if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }

    switch(InformationClass) {
        case NatKeySessionMappingInformation: {
            *InformationLength = sizeof(NAT_KEY_SESSION_MAPPING_INFORMATION);
            break;
        }
        case NatStatisticsSessionMappingInformation: {
            *InformationLength =
                sizeof(NAT_STATISTICS_SESSION_MAPPING_INFORMATION);
            break;
        }
        case NatKeySessionMappingExInformation: {
            *InformationLength =
                sizeof(NAT_KEY_SESSION_MAPPING_EX_INFORMATION);
            break;
        }
        default: {
            return ERROR_INVALID_PARAMETER;
        }
    }
    return NO_ERROR;
} // NatLookupAndQueryInformationSessionMapping


ULONG
NatOpenDriver(
    OUT PHANDLE FileHandle
    )

/*++

Routine Description:

    This routine is called to open the NAT driver's device-object.
    It assumes that the caller has loaded the driver already.

Arguments:

    FileHandle - on output, receives the new handle

Return Value:

    ULONG - Win32 status code.

--*/

{
    UNICODE_STRING DeviceName;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS status;

    //
    // Obtain a handle to the NAT's device-object.
    //

    RtlInitUnicodeString(&DeviceName, DD_IP_NAT_DEVICE_NAME);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    status =
        NtOpenFile(
            FileHandle,
            SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
            &ObjectAttributes,
            &IoStatus,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            0
            );
    if (!NT_SUCCESS(status)) {
        return RtlNtStatusToDosError(status);
    }
    return NO_ERROR;
} // NatOpenDriver


VOID
NatpCleanupDynamicRedirect(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    )

/*++

Routine Description:

    This routine is invoked when the last reference to a dynamic redirect
    is released. It is responsible for cleaning up all resources in use
    by the redirect.

Arguments:

    DynamicRedirectp - the dynamic redirect to be cleaned up.

Return Value:

    none.

Environment:

    Invoked from an arbitrary context.

--*/

{
    ASSERT(IsListEmpty(&DynamicRedirectp->InstanceList));
    if (DynamicRedirectp->TranslatorHandle) {
        NatCloseDriver(DynamicRedirectp->TranslatorHandle);
    }
    DeleteCriticalSection(&DynamicRedirectp->Lock);
    FREE(DynamicRedirectp);
} // NatpCleanupDynamicRedirect


VOID
NatpCreateDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp
    )

/*++

Routine Description:

    This routine is invoked to submit an additional instance of the given
    dynamic redirect. The redirect is associated with a notification event
    so that this module is notified when the redirect is either activated
    or terminated. In either case, another instance of the redirect will be
    created.

Arguments:

    DynamicRedirectp - the dynamic redirect to be reissued

Return Value:

    none.

Environment:

    Invoked with the dynamic-redirect's lock held by the caller.

--*/

{
    PNAT_REDIRECT Redirectp = NULL;
    NTSTATUS status;
    do {

        //
        // Allocate and initialize a new redirect-instance
        //

        if (!NAT_REFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp)) { break; }
        Redirectp = MALLOC(sizeof(*Redirectp));
        if (!Redirectp) {
            NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
            break;
        }
        ZeroMemory(Redirectp, sizeof(*Redirectp));
        Redirectp->InstanceId = InterlockedIncrement(&NextRedirectInstanceId);
        InsertTailList(&DynamicRedirectp->InstanceList, &Redirectp->Link);

        //
        // Create an event on which to receive notification of the redirect's
        // activation or termination, allocate a notification context block,
        // and register our notification routine for the event.
        //

        if (!(Redirectp->Event = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else if (!(Redirectp->Context =
                    MALLOC(sizeof(*Redirectp->Context)))) {
            break;
        } else {
            Redirectp->Context->DynamicRedirectp = DynamicRedirectp;
            Redirectp->Context->InstanceId = Redirectp->InstanceId;
            if (!RegisterWaitForSingleObject(
                    &Redirectp->WaitHandle,
                    Redirectp->Event,
                    NatpDynamicRedirectNotificationRoutine,
                    Redirectp->Context,
                    INFINITE,
                    WT_EXECUTEINIOTHREAD | WT_EXECUTEONLYONCE
                    )) {
                break;
            }
        }

        //
        // Issue the actual redirect request.
        // Now we will notified either by the kernel-mode translation module
        // when the instance is activated, or by the I/O manager when the
        // I/O control completes or is cancelled.
        //

        DynamicRedirectp->CreateRedirect.NotifyEvent = Redirectp->Event;
        status =
            NtDeviceIoControlFile(
                DynamicRedirectp->TranslatorHandle,
                Redirectp->Event,
                NULL,
                NULL,
                &UnusedIoStatus,
                IOCTL_IP_NAT_CREATE_REDIRECT_EX,
                (PVOID)&DynamicRedirectp->CreateRedirect,
                sizeof(DynamicRedirectp->CreateRedirect),
                (PVOID)&UnusedStatistics,
                sizeof(UnusedStatistics)
                );
        if (!NT_SUCCESS(status)) {
            if (UnregisterWait(Redirectp->WaitHandle)) {
                FREE(Redirectp->Context);
                NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
            }
            Redirectp->WaitHandle = NULL;
            break;
        }
        return;
    } while(FALSE);
    if (Redirectp) {
        NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
    }
} // NatpCreateDynamicRedirectInstance


VOID
NatpDeleteDynamicRedirectInstance(
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp,
    PNAT_REDIRECT Redirectp
    )

/*++

Routine Description:

    This routine is invoked to delete a given instance of a dynamic redirect.
    The redirect is cancelled, synchronizing with the notification-routine
    for the instance.

Arguments:

    DynamicRedirectp - the dynamic redirect whose instance is to be deleted

    Redirectp - the dynamic redirect instance to be deleted

Return Value:

    none.

Environment:

    Invoked with the dynamic redirect's lock held by the caller.

--*/

{
    //
    // We need to cancel the outstanding redirect, which will have been created
    // if the wait-handle is non-NULL. However, when we issue the cancellation
    // we have no way to know if the instance in question is already being
    // completed by the kernel-mode translation module. If that is the case,
    // our cancellation may affect some other instance issued on this
    // translator-handle. It will not affect any instance issued on any other
    // translator-handle since the kernel-mode translator will not allow
    // redirects issued on one file-object to be cancelled from another
    // file-object.
    //
    // Since we own the translation-handle, though, it is alright for us to
    // erroneously cancel instances in this manner. The notification routine
    // for the cancelled instance will just create a replacement.
    //
    // There is additional point of synchronization to be noted.
    // If the notification routine runs, it is responsible for deleting
    // the notification context and releasing the reference to the dynamic
    // redirect. However, if we unregister our wait and the notification
    // routine never runs, we are responsible for both tasks.
    // The return code from 'UnregisterWait' is therefore used below as an
    // indication of whether the two tasks should be performed here or left
    // for the notification routine to perform.
    //
    // Finally, the instance only needs to be cancelled if its wait-handle
    // is valid, since otherwise the instance must have never been issued.
    //

    if (Redirectp->WaitHandle) {
        if (UnregisterWait(Redirectp->WaitHandle)) {
            FREE(Redirectp->Context);
            NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
        }
        Redirectp->WaitHandle = NULL;
        NatCancelRedirect(
            DynamicRedirectp->TranslatorHandle,
            DynamicRedirectp->CreateRedirect.Protocol,
            DynamicRedirectp->CreateRedirect.DestinationAddress,
            DynamicRedirectp->CreateRedirect.DestinationPort,
            DynamicRedirectp->CreateRedirect.SourceAddress,
            DynamicRedirectp->CreateRedirect.SourcePort,
            DynamicRedirectp->CreateRedirect.NewDestinationAddress,
            DynamicRedirectp->CreateRedirect.NewDestinationPort,
            DynamicRedirectp->CreateRedirect.NewSourceAddress,
            DynamicRedirectp->CreateRedirect.NewSourcePort
            );
    }
    if (Redirectp->Event) {
        CloseHandle(Redirectp->Event); Redirectp->Event = NULL;
    }
    RemoveEntryList(&Redirectp->Link);
    FREE(Redirectp);
} // NatpDeleteDynamicRedirectInstance


VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This routine is invoked to disable the previously-enable 'LoadDriver'
    privilege for the calling thread.

Arguments:

    WasEnabled - on input, indicates whether the privilege was already enabled.

Return Value:

    none.

--*/
{

    NTSTATUS Status;

    //
    // See if we had to enable SE_LOAD_DRIVER_PRIVILEGE
    //

    if (!*WasEnabled) {

        //
        // relinquish "Load-Driver" privileges for this thread
        //

        Status =
            RtlAdjustPrivilege(
                SE_LOAD_DRIVER_PRIVILEGE,
                FALSE,
                TRUE,
                WasEnabled
                );
    }

    //
    // return the thread to its previous access token
    //

    RevertToSelf();

} // NatpDisableLoadDriverPrivilege


VOID NTAPI
NatpDynamicRedirectNotificationRoutine(
    PVOID Context,
    BOOLEAN WaitCompleted
    )

/*++

Routine Description:

    This routine is invoked upon activation or termination of one of a
    dynamic redirect's instantiated redirects by an incoming session.
    It attempts to locate the corresponding instance and, if successful,
    closes the wait-handle and event for the instance, and adds another
    instance of the dynamic redirect to replace the one which has been
    activated or terminated.

Arguments:

    Context - contains context information for the notification

    WaitCompleted - indicates whether the wait completed or timed out

Return Value:

    none.

Environment:

    Invoked in the context of a system wait thread.

--*/

{
    PNAT_DYNAMIC_REDIRECT_CONTEXT Contextp =
        (PNAT_DYNAMIC_REDIRECT_CONTEXT)Context;
    PNAT_DYNAMIC_REDIRECT DynamicRedirectp = Contextp->DynamicRedirectp;
    PLIST_ENTRY Link;
    PNAT_REDIRECT Redirectp;

    //
    // Search the dynamic redirect's list of instances for the instance
    // whose event has been signalled, and remove it after clearing the
    // wait-handle to ensure that the deletion-routine does not attempt
    // to cancel the redirect.
    //

    EnterCriticalSection(&DynamicRedirectp->Lock);
    for (Link = DynamicRedirectp->InstanceList.Flink;
         Link != &DynamicRedirectp->InstanceList; Link = Link->Flink) {
        Redirectp = CONTAINING_RECORD(Link, NAT_REDIRECT, Link);
        if (Redirectp->InstanceId == Contextp->InstanceId) {
            UnregisterWait(Redirectp->WaitHandle);
            Redirectp->WaitHandle = NULL;
            NatpDeleteDynamicRedirectInstance(DynamicRedirectp, Redirectp);
            break;
        }
    }

    FREE(Contextp);

    //
    // If the dynamic redirect has not been deleted,
    // replace the instance deleted above, if any.
    //

    if (!NAT_DYNAMIC_REDIRECT_DELETED(DynamicRedirectp)) {
        NatpCreateDynamicRedirectInstance(DynamicRedirectp);
    }
    LeaveCriticalSection(&DynamicRedirectp->Lock);

    //
    // Drop the original reference to the dynamic redirect, and return.
    //

    NAT_DEREFERENCE_DYNAMIC_REDIRECT(DynamicRedirectp);
} // NatpDynamicRedirectNotificationRoutine


BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This routine is invoked to enable the 'LoadDriver' privilege
    of the calling thread.

Arguments:

    WasEnabled - on output indicates whether the privilege was already enabled

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{
    NTSTATUS Status;

    //
    // Obtain the process' access token for the current thread
    //

    Status = RtlImpersonateSelf(SecurityImpersonation);

    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // request "Load-Driver" privileges for this thread
    //

    Status =
        RtlAdjustPrivilege(
            SE_LOAD_DRIVER_PRIVILEGE,
            TRUE,
            TRUE,
            WasEnabled
            );

    if (!NT_SUCCESS(Status)) {
        RevertToSelf();
        return FALSE;
    }

    return TRUE;

} // NatpEnableLoadDriverPrivilege


VOID NTAPI
NatpRedirectCompletionRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )

/*++

Routine Description:

    This routine is invoked upon completion of a redirect-IRP.

Arguments:

    Context - indicates the redirect which was completed

    IoStatus - contains the final status of the request

    Reserved - unused

Return Value:

    none.

--*/

{
    PNAT_REDIRECT Redirectp = (PNAT_REDIRECT)Context;
    if (Redirectp->CompletionRoutine) {
        Redirectp->CompletionRoutine(
            (HANDLE)Redirectp,
            (BOOLEAN)((IoStatus->Status == STATUS_CANCELLED) ? TRUE : FALSE),
            Redirectp->CompletionContext
            );
    }
    FREE(Redirectp);
} // NatpRedirectCompletionRoutine


BOOLEAN
NatpValidateRedirectParameters(
    ULONG Flags,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    ULONG RestrictAdapterIndex OPTIONAL
    )

/*++

Routine Description:

    This routine validates redirect parameters

Arguments:

    Flags - specifies options for the redirect

    Protocol - IP protocol of the session to be redirected

    Destination* - destination endpoint of the session to be redirected

    Source* - source endpoint of the session to be redirected

    NewDestination* - replacement destination endpoint for the session

    NewSource* - replacement source endpoint for the session

Return Value:

    BOOLEAN: TRUE if parameters are OK; FALSE otherwise

--*/

{
    //
    // Make sure no invalid flags are specified
    //

    if (Flags & ~NatRedirectFlagsAll)
    {
        return FALSE;
    }

    //
    // TCP and UDP are the only valid protocols
    //

    if (Protocol != NAT_PROTOCOL_TCP && Protocol != NAT_PROTOCOL_UDP)
    {
        return FALSE;
    }

    //
    // Validate endpoint information. There are two different sets of
    // behavior, based on the presence of NatRedirectFlagSourceRedirect
    //

    if (!(Flags & NatRedirectFlagSourceRedirect))
    {
        //
        // A destination address must be specified, unless
        // NatRedirectFlagPortRedirect is set
        //

        if (!DestinationAddress & !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // There must be a destination port
        //

        if (!DestinationPort)
        {
            return FALSE;
        }

        //
        // Both the replacement destination address and port must be specified
        //

        if (!NewDestinationAddress || !NewDestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement source address and port are both specified or
        // unspecified
        //

        if (!!NewSourceAddress ^ !!NewSourcePort)
        {
            return FALSE;
        }

        //
        // The source port must be unspecified if the source address
        // is unspecified
        //

        if (!SourceAddress && SourcePort)
        {
            return FALSE;
        }

        
        //
        // The replacement source is unspecified then the source port
        // is also unspecified.
        //

        if (!NewSourceAddress && SourcePort)
        {
            return FALSE;
        }

        //
        // If the source address is specified w/o a replacement source,
        // the caller must specify the restrict-source flag indicating
        // that this is a partial redirect restricted to a particular source.
        //

        if (!NewSourceAddress && SourceAddress
            && !(Flags & NatRedirectFlagRestrictSource))
        {
            return FALSE;
        }

        //
        // If the restrict-source flag is specified, the caller is specifiying
        // a partial redirect w/ a source address
        //

        if ((Flags & NatRedirectFlagRestrictSource)
            && (NewSourceAddress || !SourceAddress))
        {
            return FALSE;
        }

        //
        // If the port-redirect flag is specified, the caller is specifying
        // only the destination port, replacement destination address, and
        // replacement destination port
        //

        if ((Flags & NatRedirectFlagPortRedirect)
            && (DestinationAddress || SourceAddress || SourcePort
                || NewSourceAddress || NewSourcePort))
        {
            return FALSE;
        }
    }
    else
    {
        //
        // The source address must be specified, unless
        // NatRedirectFlagPortRedirect is specified
        //

        if (!SourceAddress && !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // The source port must be specified
        //

        if (!SourcePort)
        {
            return FALSE;
        }

        //
        // No destination information may be specified
        //

        if (DestinationAddress || DestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement destination address and port are both specified
        // or unspecified
        //

        if (!!NewDestinationAddress ^ !!NewDestinationPort)
        {
            return FALSE;
        }

        //
        // The replacement source address and port must be specified,
        // unless the port-redirect flag is set
        //

        if ((!NewSourceAddress || !NewSourcePort)
            && !(Flags & NatRedirectFlagPortRedirect))
        {
            return FALSE;
        }

        //
        // If the port-redirect flag is specified, the caller is specifying
        // only the source port, replacement destination address, and
        // replacement destination port
        //

        if ((Flags & NatRedirectFlagPortRedirect)
            && (SourceAddress || DestinationAddress || DestinationPort
                || NewSourceAddress || NewSourcePort))
        {
            return FALSE;
        }

        //
        // The restrict-source-address flag is invalid
        //

        if (Flags & NatRedirectFlagRestrictSource)
        {
            return FALSE;
        }
    }

    //
    // The unidirectional flag is specified only for UDP redirects
    //

    if (Flags & NatRedirectFlagUnidirectional
        && Protocol != NAT_PROTOCOL_UDP)
    {
        return FALSE;
    }

    //
    // If the restrict-adapter-index flag is specified, the caller
    // has given a valid, non-zero (i.e., local) interface index
    //

    if ((Flags & NatRedirectFlagRestrictAdapter)
        && (NAT_INVALID_IF_INDEX == RestrictAdapterIndex
            || LOCAL_IF_INDEX == RestrictAdapterIndex))
    {
        return FALSE;
    }

    return TRUE;
}


ULONG
NatQueryInformationRedirect(
    HANDLE TranslatorHandle,
    UCHAR Protocol,
    ULONG DestinationAddress,
    USHORT DestinationPort,
    ULONG SourceAddress,
    USHORT SourcePort,
    ULONG NewDestinationAddress,
    USHORT NewDestinationPort,
    ULONG NewSourceAddress,
    USHORT NewSourcePort,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine is called to obtain information about the session
    for a completed redirect.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

    * - specify the redirect to be queried

    Information - receives the retrieved information

    InformationLength - specifies the size of 'Information' on input;
        contains the required size on output

    InformationClass - indicates the class of information requested

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    IO_STATUS_BLOCK IoStatus;
    ULONG Length;
    IP_NAT_LOOKUP_REDIRECT QueryRedirect;
    IP_NAT_REDIRECT_STATISTICS RedirectStatistics;
    IP_NAT_REDIRECT_SOURCE_MAPPING RedirectSourceMapping;
    IP_NAT_REDIRECT_DESTINATION_MAPPING RedirectDestinationMapping;
    NTSTATUS status;
    HANDLE WaitEvent;

    if (!InformationLength ||
        InformationClass >= NatMaximumRedirectInformation) {
        return ERROR_INVALID_PARAMETER;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent== NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    QueryRedirect.Flags = 0;
    QueryRedirect.RedirectApcContext = NULL;
    QueryRedirect.Protocol = Protocol;
    QueryRedirect.DestinationAddress = DestinationAddress;
    QueryRedirect.DestinationPort = DestinationPort;
    QueryRedirect.SourceAddress = SourceAddress;
    QueryRedirect.SourcePort = SourcePort;
    QueryRedirect.NewDestinationAddress = NewDestinationAddress;
    QueryRedirect.NewDestinationPort = NewDestinationPort;
    QueryRedirect.NewSourceAddress = NewSourceAddress;
    QueryRedirect.NewSourcePort = NewSourcePort;

    if (InformationClass == NatDestinationMappingRedirectInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_DESTINATION_MAPPING,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectDestinationMapping,
                sizeof(RedirectDestinationMapping)
                );
    } else if (InformationClass == NatSourceMappingRedirectInformation) {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_SOURCE_MAPPING,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectSourceMapping,
                sizeof(RedirectSourceMapping)
                );
    } else {
        status =
            NtDeviceIoControlFile(
                TranslatorHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_GET_REDIRECT_STATISTICS,
                (PVOID)&QueryRedirect,
                sizeof(QueryRedirect),
                (PVOID)&RedirectStatistics,
                sizeof(RedirectStatistics)
                );
    }

    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(status)) { return RtlNtStatusToDosError(status); }

    switch (InformationClass) {
        case NatByteCountRedirectInformation: {
            PNAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount =
                (PNAT_BYTE_COUNT_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*ByteCount)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                ByteCount->BytesForward = RedirectStatistics.BytesForward;
                ByteCount->BytesReverse = RedirectStatistics.BytesReverse;
            }
            *InformationLength = sizeof(*ByteCount);
            break;
        }
        case NatRejectRedirectInformation: {
            PNAT_REJECT_REDIRECT_INFORMATION Reject =
                (PNAT_REJECT_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*Reject)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                Reject->RejectsForward = RedirectStatistics.RejectsForward;
                Reject->RejectsReverse = RedirectStatistics.RejectsReverse;
            }
            *InformationLength = sizeof(*Reject);
            break;
        }
        case NatDestinationMappingRedirectInformation: {
            PNAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping =
                (PNAT_DESTINATION_MAPPING_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*DestinationMapping)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                DestinationMapping->DestinationAddress =
                    RedirectDestinationMapping.DestinationAddress;
                DestinationMapping->DestinationPort =
                    RedirectDestinationMapping.DestinationPort;
                DestinationMapping->NewDestinationAddress =
                    RedirectDestinationMapping.NewDestinationAddress;
                DestinationMapping->NewDestinationPort =
                    RedirectDestinationMapping.NewDestinationPort;
            }
            *InformationLength = sizeof(*DestinationMapping);
            break;
        }
        case NatSourceMappingRedirectInformation: {
            PNAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping =
                (PNAT_SOURCE_MAPPING_REDIRECT_INFORMATION)Information;
            if (*InformationLength < sizeof(*SourceMapping)) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                SourceMapping->SourceAddress =
                    RedirectSourceMapping.SourceAddress;
                SourceMapping->SourcePort =
                    RedirectSourceMapping.SourcePort;
                SourceMapping->NewSourceAddress =
                    RedirectSourceMapping.NewSourceAddress;
                SourceMapping->NewSourcePort =
                    RedirectSourceMapping.NewSourcePort;
            }
            *InformationLength = sizeof(*SourceMapping);
            break;
        }
        default:
            return ERROR_INVALID_PARAMETER;
    }
    return Error;
} // NatQueryInformationRedirect


ULONG
NatQueryInformationRedirectHandle(
    HANDLE RedirectHandle,
    OUT PVOID Information,
    IN OUT PULONG InformationLength,
    NAT_REDIRECT_INFORMATION_CLASS InformationClass
    )

/*++

Routine Description:

    This routine is invoked to retrieve information about a redirect upon
    completion of the associated I/O request. At this point, the kernel-mode
    driver is no longer aware of the redirect, and hence we read the requested
    information from the output-buffer for the redirect.

Arguments:

    RedirectHandle - identifies the redirect to be queried

    Information - receives the retrieved information

    InformationLength - specifies the size of 'Information' on input;
        contains the required size on output

    InformationClass - indicates the class of information requested

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Length;
    PNAT_REDIRECT Redirectp;

    if (!InformationLength) { return ERROR_INVALID_PARAMETER; }
    Redirectp = (PNAT_REDIRECT)RedirectHandle;
    switch (InformationClass) {
        case NatByteCountRedirectInformation: {
            PNAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount =
                (PNAT_BYTE_COUNT_REDIRECT_INFORMATION)Information;
            Length = sizeof(*ByteCount);
            if (*InformationLength < Length) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                ByteCount->BytesForward = Redirectp->Statistics.BytesForward;
                ByteCount->BytesReverse = Redirectp->Statistics.BytesReverse;
            }
            *InformationLength = Length;
            break;
        }
        case NatRejectRedirectInformation: {
            PNAT_REJECT_REDIRECT_INFORMATION Reject =
                (PNAT_REJECT_REDIRECT_INFORMATION)Information;
            Length = sizeof(*Reject);
            if (*InformationLength < Length) {
                Error = ERROR_INSUFFICIENT_BUFFER;
            } else {
                Reject->RejectsForward = Redirectp->Statistics.RejectsForward;
                Reject->RejectsReverse = Redirectp->Statistics.RejectsReverse;
            }
            *InformationLength = Length;
            break;
        }
        default:
            return ERROR_INVALID_PARAMETER;
    }
    return Error;
} // NatQueryInformationRedirectHandle


VOID
NatShutdownTranslator(
    HANDLE TranslatorHandle
    )

/*++

Routine Description:

    This routine is invoked to shut down the NAT.

Arguments:

    TranslatorHandle - handle supplied by 'NatInitializeTranslator'

Return Value:

    none.

--*/

{
    NatUnloadDriver(TranslatorHandle);
} // NatShutdownTranslator


ULONG
NatUnloadDriver(
    HANDLE FileHandle
    )

/*++

Routine Description:

    This routine is invoked to unload the NAT driver as the protocol stops.

Arguments:

    FileHandle - identifies the file-object for the NAT driver

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;

    //
    // Close our file-handle to the driver
    //

    if (FileHandle) { NtClose(FileHandle); }

#if 0
{
    SC_HANDLE ScmHandle;
    SC_HANDLE ServiceHandle;
    SERVICE_STATUS ServiceStatus;

    //
    // Notify the service controller that the driver should be stopped.
    // If other processes are using the driver, this control will be ignored.
    //

    ScmHandle = OpenSCManager(NULL, NULL, GENERIC_READ);
    if (ScmHandle) {
        ServiceHandle =
            OpenServiceA(ScmHandle, IP_NAT_SERVICE_NAME, GENERIC_EXECUTE);
        if (ServiceHandle) {
            ControlService(ServiceHandle, SERVICE_CONTROL_STOP, &ServiceStatus);
            CloseServiceHandle(ServiceHandle);
        }
        CloseServiceHandle(ScmHandle);
    }
}
#else
{
    UNICODE_STRING ServicePath;
    NTSTATUS status;
    BOOLEAN WasEnabled;

    //
    // Turn on our driver-unloading ability
    //

    if (!NatpEnableLoadDriverPrivilege(&WasEnabled)) {
        return ERROR_ACCESS_DENIED;
    }

    RtlInitUnicodeString(&ServicePath, NatpServicePath);

    //
    // Load the driver
    //

    status = NtUnloadDriver(&ServicePath);

    //
    // Turn off the privilege
    //

    NatpDisableLoadDriverPrivilege(&WasEnabled);

    //
    // See if the unload-attempt succeeded
    //

    if (!NT_SUCCESS(status)) {
        Error = RtlNtStatusToDosError(status);
        return Error;
    }
}
#endif

    return NO_ERROR;

} // NatUnloadDriver
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\inc\rmh323.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmh323.h

Abstract:

    This module declares routines for the H.323 transparent proxy module's
    interface to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   18-Jun-1999

Revision History:

--*/

#ifndef _NATHLP_RMH323_H_
#define _NATHLP_RMH323_H_

//
// GLOBAL DATA DECLARATIONS
//

extern COMPONENT_REFERENCE H323ComponentReference;
extern PIP_H323_GLOBAL_INFO H323GlobalInfo;
extern CRITICAL_SECTION H323GlobalInfoLock;
extern HANDLE H323NotificationEvent;
extern ULONG H323ProtocolStopped;
extern const MPR_ROUTING_CHARACTERISTICS H323RoutingCharacteristics;
extern SUPPORT_FUNCTIONS H323SupportFunctions;

//
// MACRO DECLARATIONS
//

#define REFERENCE_H323() \
    REFERENCE_COMPONENT(&H323ComponentReference)

#define REFERENCE_H323_OR_RETURN(retcode) \
    REFERENCE_COMPONENT_OR_RETURN(&H323ComponentReference,retcode)

#define DEREFERENCE_H323() \
    DEREFERENCE_COMPONENT(&H323ComponentReference)

#define DEREFERENCE_H323_AND_RETURN(retcode) \
    DEREFERENCE_COMPONENT_AND_RETURN(&H323ComponentReference, retcode)

//
// FUNCTION DECLARATIONS
//

VOID
H323CleanupModule(
    VOID
    );

BOOLEAN
H323InitializeModule(
    VOID
    );

ULONG
APIENTRY
H323RmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmStartComplete(
    VOID
    );

ULONG
APIENTRY
H323RmStopProtocol(
    VOID
    );

ULONG
APIENTRY
H323RmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmDeleteInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    );

ULONG
APIENTRY
H323RmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
H323RmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    );

ULONG
APIENTRY
H323RmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    );

ULONG
APIENTRY
H323RmUnbindInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmEnableInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmDisableInterface(
    ULONG Index
    );

ULONG
APIENTRY
H323RmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    );

ULONG
APIENTRY
H323RmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    );

ULONG
APIENTRY
H323RmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
H323RmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    );

ULONG
APIENTRY
H323RmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

ULONG
APIENTRY
H323RmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    );

#endif // _NATHLP_RMH323_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natapi\portapi.c ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    portapi.c

Abstract:

    This module contains code for API routines which provide port-reservation
    functionality to user-mode clients of TCP/IP. This functionality allows
    applications to 'reserve' blocks of TCP/UDP port-numbers for private use,
    preventing any other processes from binding to the reserved port-numbers.

Author:

    Abolade Gbadegesin (aboladeg)   25-May-1999

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ipnatapi.h>
#include <ntddtcp.h>

//
// PRIVATE STRUCTURE DECLARATIONS
//

typedef struct _NAT_PORT_RESERVATION {
    HANDLE TcpipHandle;
    USHORT BlockSize;
    USHORT PortBlockSize;
    LIST_ENTRY PortBlockList;
} NAT_PORT_RESERVATION, *PNAT_PORT_RESERVATION;

typedef struct _NAT_PORT_BLOCK {
    LIST_ENTRY Link;
    ULONG StartHandle;
    RTL_BITMAP Bitmap;
    ULONG BitmapBuffer[0];
} NAT_PORT_BLOCK, *PNAT_PORT_BLOCK;

//
// FORWARD DECLARATIONS
//

NTSTATUS
NatpCreatePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK* PortBlockCreated
    );

VOID
NatpDeletePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK PortBlock
    );


ULONG
NatAcquirePortReservation(
    HANDLE ReservationHandle,
    USHORT PortCount,
    OUT PUSHORT ReservedPortBase
    )

/*++

Routine Description:

    This routine is called to reserve one or more contiguous port-numbers
    from the port-reservation handle supplied.

Arguments:

    ReservationHandle - supplies a port-reservation handle from which to
        acquire port-numbers

    PortCount - specifies the number of port-numbers required

    ReservedPortBase - receives the first port-number reserved,
        in network-order.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Index;
    PLIST_ENTRY Link;
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;
    NTSTATUS Status;

    //
    // Fail immediately if the caller has requested more port-numbers
    // than would exist in a completely unallocated block.
    // Otherwise, traverse the list of port-blocks to see if any of the blocks
    // have enough contiguous port-numbers to satisfy the caller's request.
    //

    if (PortCount > PortReservation->BlockSize) {
        return ERROR_INVALID_PARAMETER;
    }
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PortBlock = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        Index = RtlFindClearBitsAndSet(&PortBlock->Bitmap, PortCount, 0);
        if (Index != (ULONG)-1) {
            *ReservedPortBase =
                RtlUshortByteSwap((USHORT)(PortBlock->StartHandle + Index));
            return NO_ERROR;
        }
    }

    //
    // No port-block had the required number of contiguous port-numbers.
    // Attempt to create a new port-block, and if that succeeds use it
    // to satisfy the caller's request.
    //

    Status = NatpCreatePortBlock(PortReservation, &PortBlock);
    if (!NT_SUCCESS(Status)) { return RtlNtStatusToDosError(Status); }
    Index = RtlFindClearBitsAndSet(&PortBlock->Bitmap, PortCount, 0);
    *ReservedPortBase =
        RtlUshortByteSwap((USHORT)(PortBlock->StartHandle + Index));
    return NO_ERROR;
} // NatAcquirePortReservation


ULONG
NatInitializePortReservation(
    USHORT BlockSize,
    OUT PHANDLE ReservationHandle
    )

/*++

Routine Description:

    This routine is called to initialize a handle to the port-reservation
    module. The resulting handle is used to acquire and release ports
    from the dynamically-allocated block.

Arguments:

    BlockSize - indicates the number of ports to request each time
        an additional block is requested from the TCP/IP driver.

    ReservationHandle - on output, receives a handle to be used for
        acquiring and releasing ports.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG BitmapSize;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PNAT_PORT_RESERVATION PortReservation;
    NTSTATUS Status;
    HANDLE TcpipHandle;
    UNICODE_STRING UnicodeString;
    do {

        //
        // Open a handle to the TCP/IP driver.
        // This handle will later be used to issue reservation-requests.
        //

        RtlInitUnicodeString(&UnicodeString, DD_TCP_DEVICE_NAME);
        InitializeObjectAttributes(
            &ObjectAttributes, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL
            );
        Status =
            NtCreateFile(
                &TcpipHandle,
                SYNCHRONIZE|FILE_READ_DATA|FILE_WRITE_DATA,
                &ObjectAttributes,
                &IoStatus,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE,
                FILE_OPEN_IF,
                0,
                NULL,
                0
                );
        if (!NT_SUCCESS(Status)) { break; }

        //
        // Allocate and initialize a port-reservation context block.
        //

        PortReservation = MALLOC(sizeof(*PortReservation));
        if (!PortReservation) { Status = STATUS_NO_MEMORY; break; }
        PortReservation->TcpipHandle = TcpipHandle;
        PortReservation->BlockSize = BlockSize;
        BitmapSize = (BlockSize + sizeof(ULONG) * 8 - 1) / (sizeof(ULONG) * 8);
        PortReservation->PortBlockSize =
            (USHORT)FIELD_OFFSET(NAT_PORT_BLOCK, BitmapBuffer[BitmapSize]);
        InitializeListHead(&PortReservation->PortBlockList);
        *ReservationHandle = (HANDLE)PortReservation;
        return NO_ERROR;
    } while(FALSE);
    if (TcpipHandle) { NtClose(TcpipHandle); }
    return RtlNtStatusToDosError(Status);
} // NatInitializePortReservation


NTSTATUS
NatpCreatePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK* PortBlockCreated
    )

/*++

Routine Description:

    This routine is called to create a new port-block when the existing
    port-numbers have been exhausted.

Arguments:

    PortReservation - the reservation to which the port-block should be added

    PortBlockCreated - on output, receives the new port-block

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    PLIST_ENTRY Link;
    PNAT_PORT_BLOCK PortBlock;
    TCP_BLOCKPORTS_REQUEST Request;
    ULONG StartHandle;
    NTSTATUS Status;
    HANDLE WaitEvent;

    //
    // Allocate memory for the new port-block and its bitmap of free ports
    //

    PortBlock = MALLOC(PortReservation->PortBlockSize);
    if (!PortBlock) { return ERROR_NOT_ENOUGH_MEMORY; }

    //
    // Request a new block of ports from the TCP/IP driver
    //

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        FREE(PortBlock);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Request.ReservePorts = TRUE;
    Request.NumberofPorts = PortReservation->BlockSize;
    Status =
        NtDeviceIoControlFile(
            PortReservation->TcpipHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_TCP_BLOCK_PORTS,
            &Request,
            sizeof(Request),
            &StartHandle,
            sizeof(StartHandle)
            );
    if (Status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        Status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    if (!NT_SUCCESS(Status)) {
        FREE(PortBlock); return RtlNtStatusToDosError(Status);
    }

    //
    // Initialize the new port-block, and insert it in the list of ports.
    //

    PortBlock->StartHandle = StartHandle;
    RtlInitializeBitMap(
        &PortBlock->Bitmap,
        PortBlock->BitmapBuffer,
        PortReservation->BlockSize
        );
    RtlClearAllBits(&PortBlock->Bitmap);
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PNAT_PORT_BLOCK Temp = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        if (PortBlock->StartHandle > Temp->StartHandle) {
            continue;
        } else {
            break;
        }
        ASSERTMSG("NatpCreatePortBlock: duplicate port range\n", TRUE);
    }
    InsertTailList(Link, &PortBlock->Link);
    if (PortBlockCreated) { *PortBlockCreated = PortBlock; }
    return NO_ERROR;
} // NatpCreatePortBlock


VOID
NatpDeletePortBlock(
    PNAT_PORT_RESERVATION PortReservation,
    PNAT_PORT_BLOCK PortBlock
    )

/*++

Routine Description:

    This routine is called to delete a port-block when the port-numbers
    it contains have been released, or when the port-reservation is cleaned up.

Arguments:

    PortReservation - the reservation to which the port-block belongs

    PortBlock - the port block to be deleted

Return Value:

    none.

--*/

{
    IO_STATUS_BLOCK IoStatus;
    TCP_BLOCKPORTS_REQUEST Request;
    NTSTATUS Status;
    HANDLE WaitEvent;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        return;
    }

    //
    // Release the block of ports to the TCP/IP driver
    //

    Request.ReservePorts = FALSE;
    Request.StartHandle = PortBlock->StartHandle;
    Status =
        NtDeviceIoControlFile(
            PortReservation->TcpipHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_TCP_BLOCK_PORTS,
            &Request,
            sizeof(Request),
            NULL,
            0
            );
    if (Status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        Status = IoStatus.Status;
    }
    RemoveEntryList(&PortBlock->Link);
    FREE(PortBlock);
    CloseHandle(WaitEvent);
} // NatpDeletePortBlock


ULONG
NatReleasePortReservation(
    HANDLE ReservationHandle,
    USHORT ReservedPortBase,
    USHORT PortCount
    )

/*++

Routine Description:

    This routine is called to release all contiguous port-numbers obtained
    in a previous acquisition from the port-reservation handle supplied.

Arguments:

    ReservationHandle - supplies a port-reservation handle to which to
        release port-numbers

    ReservedPortBase - receives the first port-number reserved,
        in network-order.

    PortCount - specifies the number of port-numbers acquired

Return Value:

    ULONG - Win32 status code.

--*/

{
    PLIST_ENTRY Link;
    USHORT PortBase;
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;

    //
    // Convert the caller's port-base into host-order,
    // and search the sorted list of port-blocks for the entry
    // from which the acquisition was made.
    //

    PortBase = RtlUshortByteSwap(ReservedPortBase);
    for (Link = PortReservation->PortBlockList.Flink;
         Link != &PortReservation->PortBlockList; Link = Link->Flink) {
        PortBlock = CONTAINING_RECORD(Link, NAT_PORT_BLOCK, Link);
        if (PortBase < PortBlock->StartHandle) {
            break;
        } else if (PortBase <
                   (PortBlock->StartHandle + PortReservation->BlockSize)) {

            //
            // This should be the block from which the caller's port-numbers
            // were acquired. For good measure, check that the end of the
            // callers range also falls within this block.
            //

            if ((PortBase + PortCount - 1) >=
                (USHORT)(PortBlock->StartHandle + PortReservation->BlockSize)) {

                //
                // The caller has probably supplied an incorrect length,
                // or is releasing an allocation twice, or something.
                //

                return ERROR_INVALID_PARAMETER;
            } else {

                //
                // This is the caller's range. Clear the bits corresponding
                // to the caller's acquisition, and then see if there are
                // any bits left in the bitmap. If not, and if there are
                // other port-blocks, delete this port-block altogether.
                //

                RtlClearBits(
                    &PortBlock->Bitmap,
                    PortBase - PortBlock->StartHandle,
                    PortCount
                    );
                if (RtlFindSetBits(&PortBlock->Bitmap, 1, 0) == (ULONG)-1 &&
                    (PortBlock->Link.Flink != &PortReservation->PortBlockList ||
                     PortBlock->Link.Blink != &PortReservation->PortBlockList)
                    ) {
                    NatpDeletePortBlock(PortReservation, PortBlock);
                }
                return NO_ERROR;
            }
        } else {
            continue;
        }
    }

    //
    // We could not find the port-block from which the caller
    // allegedly acquired this range of port-numbers.
    //

    return ERROR_CAN_NOT_COMPLETE;
} // NatReleasePortReservation


VOID
NatShutdownPortReservation(
    HANDLE ReservationHandle
    )

/*++

Routine Description:

    This routine is called to clean up a handle to the port-reservation module.
    It releases all reservations acquired, and closes the handle to the TCP/IP
    driver.

Arguments:

    ReservationHandle - the handle to be cleaned up

Return Value:

    none.

--*/

{
    PNAT_PORT_BLOCK PortBlock;
    PNAT_PORT_RESERVATION PortReservation =
        (PNAT_PORT_RESERVATION)ReservationHandle;
    while (!IsListEmpty(&PortReservation->PortBlockList)) {
        PortBlock =
            CONTAINING_RECORD(
                PortReservation->PortBlockList.Flink, NAT_PORT_BLOCK, Link
                );
        NatpDeletePortBlock(PortReservation, PortBlock);
    }
    NtClose(PortReservation->TcpipHandle);
    FREE(PortReservation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natapi\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ipnat.h>
#include <ipnatapi.h>
#include <ntosp.h>
#include <zwapi.h>
#include <ndis.h>
#include <ipfirewall.h>
#include "natapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\csaupdate.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    csaupdate.cpp

Abstract:

    Implementation of CSharedAccessUpdate -- notification sink for
    configuration changes.

Author:

    Jonathan Burstein (jonburs)     20 April 2001

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include "beacon.h"

//
// Define a macro version of ntohs which can be applied to constants,
// and which can thus be computed at compile time.
//

#define NTOHS(p)    ((((p) & 0xFF00) >> 8) | (((UCHAR)(p) << 8)))


//
// H.323/LDAP proxy ports 
//

#define H323_Q931_PORT      NTOHS(1720)
#define H323_LDAP_PORT      NTOHS(389)
#define H323_LDAP_ALT_PORT  NTOHS(1002)

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// Interface methods
//

STDMETHODIMP
CSharedAccessUpdate::ConnectionPortMappingChanged(
    GUID *pConnectionGuid,
    GUID *pPortMappingGuid,
    BOOLEAN fProtocolChanged
    )
{
    BOOLEAN fEnabled;
    BOOLEAN fRebuildDhcpList = TRUE;
    HRESULT hr = S_OK;
    IHNetPortMappingBinding *pBinding;
    PNAT_CONNECTION_ENTRY pConnection;
    PNAT_PORT_MAPPING_ENTRY pPortMapping;
    IHNetPortMappingProtocol *pProtocol;
    ULONG ulError;
    USHORT usNewPort = 0;
    UCHAR ucNewProtocol = 0;
    USHORT usOldPort = 0;
    UCHAR ucOldProtocol = 0;

    PROFILE("ConnectionPortMappingChanged");

    EnterCriticalSection(&NatInterfaceLock);

    do
    {
        pConnection = NatFindConnectionEntry(pConnectionGuid);
        if (NULL == pConnection) { break; }

        //
        // If the connection is not yet bound then there's nothing
        // that we need to do here.
        //

        if (!NAT_INTERFACE_BOUND(&pConnection->Interface)) { break; }

        //
        // Locate the old port mapping entry. This entry won't exist if
        // this port mapping wasn't previously enabled.
        //

        pPortMapping = NatFindPortMappingEntry(pConnection, pPortMappingGuid);

        if (NULL != pPortMapping)
        {
            //
            // Remove this entry from the connection list and
            // delete the old ticket / UDP broadcast entry.
            //

            RemoveEntryList(&pPortMapping->Link);
            
            if (pPortMapping->fUdpBroadcastMapping)
            {
                if (0 != pPortMapping->pvBroadcastCookie)
                {
                    ASSERT(NULL != NhpUdpBroadcastMapper);
                    hr = NhpUdpBroadcastMapper->CancelUdpBroadcastMapping(
                            pPortMapping->pvBroadcastCookie
                            );

                    pPortMapping->pvBroadcastCookie = 0;
                }

                pConnection->UdpBroadcastPortMappingCount -= 1;
            }
            else
            {
                ulError =
                    NatDeleteTicket(
                        pConnection->AdapterIndex,
                        pPortMapping->ucProtocol,
                        pPortMapping->usPublicPort,
                        IP_NAT_ADDRESS_UNSPECIFIED,
                        pPortMapping->usPrivatePort,
                        pPortMapping->ulPrivateAddress
                        );

                pConnection->PortMappingCount -= 1;
            }

            //
            // Store the old protocol / port information so that
            // we can notify H.323 (if necessary) and the ALG manager.
            //

            ucOldProtocol = pPortMapping->ucProtocol;
            usOldPort = pPortMapping->usPublicPort;            

            //
            // Check to see if this mapping is still enabled. (We ignore
            // errors from above.)
            //

            hr = pPortMapping->pBinding->GetEnabled(&fEnabled);
            if (FAILED(hr) || !fEnabled)
            {
                //
                // We'll need to rebuild the DHCP reservation
                // list only if this was a named-based mapping.
                //

                fRebuildDhcpList = pPortMapping->fNameActive;
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }
        else
        {
            //
            // Allocate a new port mapping entry
            //

            pPortMapping =
                reinterpret_cast<PNAT_PORT_MAPPING_ENTRY>(
                    NH_ALLOCATE(sizeof(*pPortMapping))
                    );
            
            if (NULL == pPortMapping)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            ZeroMemory(pPortMapping, sizeof(*pPortMapping));
            pPortMapping->pProtocolGuid =
                reinterpret_cast<GUID*>(
                    CoTaskMemAlloc(sizeof(GUID))
                    );

            if (NULL != pPortMapping->pProtocolGuid)
            {
                CopyMemory(
                    pPortMapping->pProtocolGuid,
                    pPortMappingGuid,
                    sizeof(GUID));
            }
            else
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            
            //
            // Load the protocol and binding 
            //

            IHNetCfgMgr *pCfgMgr;
            IHNetProtocolSettings *pProtocolSettings;

            hr = NhGetHNetCfgMgr(&pCfgMgr);
            if (SUCCEEDED(hr))
            {
                hr = pCfgMgr->QueryInterface(
                        IID_PPV_ARG(IHNetProtocolSettings, &pProtocolSettings)
                        );
                pCfgMgr->Release();
            }

            if (SUCCEEDED(hr))
            {
                hr = pProtocolSettings->FindPortMappingProtocol(
                        pPortMappingGuid,
                        &pPortMapping->pProtocol
                        );

                if (SUCCEEDED(hr))
                {
                    hr = pConnection->pHNetConnection->GetBindingForPortMappingProtocol(
                            pPortMapping->pProtocol,
                            &pPortMapping->pBinding
                            );
                }

                pProtocolSettings->Release();
            }

            if (SUCCEEDED(hr))
            {
                //
                // Check if this protocol is enabled
                //

                hr = pPortMapping->pBinding->GetEnabled(&fEnabled);
            }

            if (FAILED(hr) || !fEnabled)
            {
                //
                // We don't need to rebuild the DHCP reservations.
                //

                fRebuildDhcpList = FALSE;
                NatFreePortMappingEntry(pPortMapping);
                break;
            }

            //
            // Since this is a new entry we always need to load the
            // protocol.
            //

            fProtocolChanged = TRUE;
        }

        //
        // Gather the new information
        //

        if (fProtocolChanged)
        {
            //
            // Need to reload the protocol information
            //

            hr = pPortMapping->pProtocol->GetIPProtocol(&pPortMapping->ucProtocol);

            if (SUCCEEDED(hr))
            {
                hr = pPortMapping->pProtocol->GetPort(&pPortMapping->usPublicPort);
            }

            if (FAILED(hr))
            {
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }

        //
        // Load the binding information
        //

        if (pConnection->HNetProperties.fIcsPublic)
        {
            hr = pPortMapping->pBinding->GetTargetComputerAddress(&pPortMapping->ulPrivateAddress);

            if (SUCCEEDED(hr)
                && INADDR_LOOPBACK_NO == pPortMapping->ulPrivateAddress)
            {
                //
                // If the port mapping targets the loopback address
                // we want to use the address from the binding
                // info instead.
                //
                
                pPortMapping->ulPrivateAddress =
                    pConnection->pBindingInfo->Address[0].Address;
            }
        }
        else
        {
            pPortMapping->ulPrivateAddress = pConnection->pBindingInfo->Address[0].Address;
        }

        if (SUCCEEDED(hr))
        {
            hr = pPortMapping->pBinding->GetTargetPort(&pPortMapping->usPrivatePort);
        }

        if (SUCCEEDED(hr))
        {
            BOOLEAN fOldNameActive = pPortMapping->fNameActive;
            hr = pPortMapping->pBinding->GetCurrentMethod(&pPortMapping->fNameActive);

            if (!fOldNameActive && !pPortMapping->fNameActive)
            {
                fRebuildDhcpList = FALSE;
            }
        }

        if (FAILED(hr))
        {
            NatFreePortMappingEntry(pPortMapping);
            break;
        }

        //
        // Create the ticket / UDP broadcast
        //

        if (NAT_PROTOCOL_UDP == pPortMapping->ucProtocol
            && 0xffffffff == pPortMapping->ulPrivateAddress)
        {
            DWORD dwAddress;
            DWORD dwMask;
            DWORD dwBroadcastAddress;

            if (NhQueryScopeInformation(&dwAddress, &dwMask))
            {
                dwBroadcastAddress = (dwAddress & dwMask) | ~dwMask;
                pPortMapping->fUdpBroadcastMapping = TRUE;

                hr = NhpUdpBroadcastMapper->CreateUdpBroadcastMapping(
                        pPortMapping->usPublicPort,
                        pConnection->AdapterIndex,
                        dwBroadcastAddress,
                        &pPortMapping->pvBroadcastCookie
                        );                        
            }
            else
            {
                hr = E_FAIL;
            }

            if (SUCCEEDED(hr))
            {
                InsertTailList(&pConnection->PortMappingList, &pPortMapping->Link);
                pConnection->UdpBroadcastPortMappingCount += 1;
            }
            else
            {
                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }
        else
        {
            ulError =
                NatCreateTicket(
                    pConnection->AdapterIndex,
                    pPortMapping->ucProtocol,
                    pPortMapping->usPublicPort,
                    IP_NAT_ADDRESS_UNSPECIFIED,
                    pPortMapping->usPrivatePort,
                    pPortMapping->ulPrivateAddress
                    );

            if (NO_ERROR == ulError)
            {
                InsertTailList(&pConnection->PortMappingList, &pPortMapping->Link);
                pConnection->PortMappingCount += 1;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ulError);
                NhTrace(
                    TRACE_FLAG_NAT,
                    "ConnectionPortMappingModified: NatCreateTicket=%d",
                    ulError
                    );

                NatFreePortMappingEntry(pPortMapping);
                break;
            }
        }

        //
        // Store the old protocol / port information so that
        // we can notify H.323 (if necessary) and the ALG manager.
        //

        ucNewProtocol = pPortMapping->ucProtocol;
        usNewPort = pPortMapping->usPublicPort;  
    }
    while (FALSE);

    //
    // Determine if we need to notify the H.323 proxy or
    // the ALG manager. We must have found a bound connection
    // above to do this.
    //

    if (NULL != pConnection && NAT_INTERFACE_BOUND(&pConnection->Interface))
    {
        //
        // If this connection is bound to the H.323 proxy and either
        // the old or new protocol/port combination is applicable
        // remove and add this connection from the that proxy.
        //

        if (NAT_INTERFACE_ADDED_H323(&pConnection->Interface)
            && (IsH323Protocol(ucOldProtocol, usOldPort)
                || IsH323Protocol(ucNewProtocol, usNewPort)))
        {
            H323RmDeleteInterface(pConnection->Interface.Index);
            pConnection->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_H323;

            ulError =
                H323RmAddInterface(
                    NULL,
                    pConnection->Interface.Index,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );

            if (NO_ERROR == ulError)
            {
                pConnection->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_H323;

                ulError =
                    H323RmBindInterface(
                        pConnection->Interface.Index,
                        pConnection->pBindingInfo
                        );
            }

            if (NO_ERROR == ulError)
            {
                ulError = H323RmEnableInterface(pConnection->Interface.Index);
            }
        }

        //
        // Inform the ALG manager of the changes
        //

        if (0 != ucOldProtocol && 0 != usOldPort)
        {
            AlgRmPortMappingChanged(
                pConnection->Interface.Index,
                ucOldProtocol,
                usOldPort
                );
        }

        if (0 != ucNewProtocol && 0 != usNewPort
            && (ucOldProtocol != ucNewProtocol
                || usOldPort != usNewPort))
        {
            AlgRmPortMappingChanged(
                pConnection->Interface.Index,
                ucNewProtocol,
                usNewPort
                );

        }
        
    }
        
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // We may also need to rebuild the DHCP reservation list
    //
        
    if (fRebuildDhcpList)
    {
        EnterCriticalSection(&NhLock);
        
        NhFreeDhcpReservations();
        NhBuildDhcpReservations();

        LeaveCriticalSection(&NhLock);
    }

    return hr;
}

//
// Private methods
//

BOOLEAN
CSharedAccessUpdate::IsH323Protocol(
    UCHAR ucProtocol,
    USHORT usPort
    )
{
    return (NAT_PROTOCOL_TCP == ucProtocol
            && (H323_Q931_PORT == usPort
                || H323_LDAP_PORT == usPort
                || H323_LDAP_ALT_PORT == usPort));
}


STDMETHODIMP
CSharedAccessUpdate::PortMappingListChanged()
{
    HRESULT hr = S_OK;

    hr = FireNATEvent_PortMappingsChanged();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\cudpbcast.cpp ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cudpbcast.cpp

Abstract:

    Implementation of CUdpBroadcastMapper -- support for mapping
    a public UDP port to the private network's broadcast address.

Author:

    Jonathan Burstein (jonburs)     12 April 2001

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// ATL Methods
//

HRESULT
CUdpBroadcastMapper::FinalConstruct()
{
    HRESULT hr = S_OK;
    DWORD dwError;

    //
    // Create our UDP listening socket and obtain
    // its port.
    //

    dwError =
        NhCreateDatagramSocket(
            INADDR_LOOPBACK_NO,
            0,
            &m_hsUdpListen
            );

    if (ERROR_SUCCESS == dwError)
    {
        m_usUdpListenPort = NhQueryPortSocket(m_hsUdpListen);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create our raw UDP send socket
        //

        dwError = NhCreateRawDatagramSocket(&m_hsUdpRaw);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Obtain a handle to the NAT
        //

        dwError = NatOpenDriver(&m_hNat);
        if (ERROR_SUCCESS != dwError)
        {
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    
    return hr;
}

HRESULT
CUdpBroadcastMapper::FinalRelease()
{
    if (INVALID_SOCKET != m_hsUdpListen)
    {
        closesocket(m_hsUdpListen);
    }

    if (INVALID_SOCKET != m_hsUdpRaw)
    {
        closesocket(m_hsUdpRaw);
    }

    if (NULL != m_hNat)
    {
        CloseHandle(m_hNat);
    }

    ASSERT(IsListEmpty(&m_MappingList));

    return S_OK;
}

//
// Initialization
//

HRESULT
CUdpBroadcastMapper::Initialize(
    PCOMPONENT_REFERENCE pComponentReference
    )
{
    HRESULT hr = S_OK;

    if (NULL != pComponentReference)
    {
        m_pCompRef = pComponentReference;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//
// IUdpBroadcastMapper methods
//

STDMETHODIMP
CUdpBroadcastMapper::CreateUdpBroadcastMapping(
    USHORT usPublicPort,
    DWORD dwPublicInterfaceIndex,
    ULONG ulDestinationAddress,
    VOID **ppvCookie
    )
{
    HRESULT hr = S_OK;
    CUdpBroadcast *pMapping;
    CUdpBroadcast *pDuplicate;
    PLIST_ENTRY pInsertionPoint;
    ULONG ulError;

    if (NULL != ppvCookie)
    {
        *ppvCookie = NULL;

        if (0 == usPublicPort
            || 0 == dwPublicInterfaceIndex
            || 0 == ulDestinationAddress)
        {
            hr = E_INVALIDARG;
        }
        else if (!m_fActive)
        {
            //
            // We've already been shutdown
            //

            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_POINTER;
    }

    if (SUCCEEDED(hr))
    {
        pMapping = new CUdpBroadcast(
                        usPublicPort,
                        dwPublicInterfaceIndex,
                        ulDestinationAddress
                        );
        if (NULL == pMapping)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Check for duplicate and insert on list. It's OK for
        // the entry to be on the list before we've created the
        // dynamic redirect for it.
        //

        Lock();

        pDuplicate =
            LookupMapping(
                usPublicPort,
                dwPublicInterfaceIndex,
                &pInsertionPoint
                );

        if (NULL == pDuplicate)
        {
            InsertTailList(pInsertionPoint, &pMapping->Link);
        }
        else
        {
            delete pMapping;
            hr = HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS);
        }

        Unlock(); 
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the dynamic redirect for this entry
        //

        ulError =
            NatCreateDynamicAdapterRestrictedPortRedirect(
                NatRedirectFlagReceiveOnly,
                NAT_PROTOCOL_UDP,
                usPublicPort,
                INADDR_LOOPBACK_NO,
                m_usUdpListenPort,
                dwPublicInterfaceIndex,
                0,
                &pMapping->hDynamicRedirect
                );

        if (ERROR_SUCCESS != ulError)
        {
            hr = HRESULT_FROM_WIN32(ulError);

            Lock();
            RemoveEntryList(&pMapping->Link);
            Unlock();
                
            delete pMapping;
        }              
    }

    if (SUCCEEDED(hr))
    {
        //
        // Make sure that we've posted a read on our UDP socket
        //

        hr = StartUdpRead();

        if (SUCCEEDED(hr))
        {
            *ppvCookie = reinterpret_cast<PVOID>(pMapping);
        }
        else
        {
            NatCancelDynamicRedirect(pMapping->hDynamicRedirect);

            Lock();
            RemoveEntryList(&pMapping->Link);
            Unlock();

            delete pMapping;
        }
    }
    
    return hr;
}

STDMETHODIMP
CUdpBroadcastMapper::CancelUdpBroadcastMapping(
    VOID *pvCookie
    )
{
    HRESULT hr = S_OK;
    CUdpBroadcast *pMapping;
    ULONG ulError;

    if (NULL != pvCookie)
    {
        pMapping = reinterpret_cast<CUdpBroadcast*>(pvCookie);

        Lock();
        RemoveEntryList(&pMapping->Link);
        Unlock();

        ASSERT(NULL != pMapping->hDynamicRedirect);

        ulError = NatCancelDynamicRedirect(pMapping->hDynamicRedirect);
        if (ERROR_SUCCESS != ulError)
        {
            hr = HRESULT_FROM_WIN32(ulError);
        }

        delete pMapping;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP
CUdpBroadcastMapper::Shutdown()
{
    InterlockedExchange(
        reinterpret_cast<LPLONG>(&m_fActive),
        FALSE
        );

    //
    // We need to close our read socket handle so that any
    // pending reads complete. We don't need to close our
    // raw send socket since for that completion will never
    // be blocked waiting for an incoming packet.
    //

    Lock();

    if (INVALID_SOCKET != m_hsUdpListen)
    {
        closesocket(m_hsUdpListen);
        m_hsUdpListen = INVALID_SOCKET;
    }

    Unlock();
    
    return S_OK;
}

//
// Protected methods
//

CUdpBroadcast*
CUdpBroadcastMapper::LookupMapping(
    USHORT usPublicPort,
    DWORD dwInterfaceIndex,
    PLIST_ENTRY * ppInsertionPoint
    )
{
    PLIST_ENTRY pLink;
    CUdpBroadcast *pMapping;
    CUdpBroadcast *pMappingToReturn = NULL;

    //
    // The caller should have already locked the object before calling
    // this method to guarantee that what we return will still be
    // valid. However, we'll still grab the lock again to ensure that
    // it's safe to traverse the list.
    //

    Lock();

    for (pLink = m_MappingList.Flink;
         pLink != &m_MappingList;
         pLink = pLink->Flink)
    {
        pMapping = CONTAINING_RECORD(pLink, CUdpBroadcast, Link);

        if (pMapping->usPublicPort < usPublicPort)
        {
            continue;
        }
        else if (pMapping->usPublicPort > usPublicPort)
        {
            break;
        }

        //
        // Primary key matches, check secondary key
        //

        if (pMapping->dwInterfaceIndex < dwInterfaceIndex)
        {
            continue;
        }
        else if (pMapping->dwInterfaceIndex > dwInterfaceIndex)
        {
            break;
        }

        //
        // Found it.
        //

        pMappingToReturn = pMapping;
        break;
    }

    Unlock();

    if (NULL == pMappingToReturn
        && NULL != ppInsertionPoint)
    {
        *ppInsertionPoint = pLink;
    }

    return pMappingToReturn;
}

HRESULT
CUdpBroadcastMapper::StartUdpRead()
{
    HRESULT hr = S_OK;
    ULONG ulError;
    LONG fReadStarted;

    Lock();
    
    if (!m_fReadStarted)
    {
        AddRef();
        ulError =
            NhReadDatagramSocket(
                m_pCompRef,
                m_hsUdpListen,
                NULL,
                UdpReadCompletionRoutine,
                this,
                m_pCompRef
                );

        if (ERROR_SUCCESS == ulError)
        {
            m_fReadStarted = TRUE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ulError);
            Release();
        }
    }

    Unlock();

    return hr;
}

VOID
CUdpBroadcastMapper::UdpReadCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        )
{
    CUdpBroadcastMapper *pMapper;
    PCOMPONENT_REFERENCE pCompRef;

    pMapper = reinterpret_cast<CUdpBroadcastMapper*>(pBuffer->Context);
    pCompRef = reinterpret_cast<PCOMPONENT_REFERENCE>(pBuffer->Context2);

    ASSERT(NULL != pMapper);
    ASSERT(NULL != pCompRef);

    //
    // Do the actual work
    //

    pMapper->ProcessUdpRead(ulError, ulBytesTransferred, pBuffer);

    //
    // Release the references obtained on both the object and
    // the component
    //

    pMapper->Release();
    ReleaseComponentReference(pCompRef); 
}

VOID
CUdpBroadcastMapper::ProcessUdpRead(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        )
{
    NAT_KEY_SESSION_MAPPING_EX_INFORMATION MappingInfo;
    ULONG ulBufferSize;
    DWORD dwError;
    CUdpBroadcast *pMapping;
    ULONG ulDestinationAddress = 0;
    
    //
    // If an error occured check to see if we should repost
    // the read. If we're not active release the buffer
    // and exit.
    //

    if (ERROR_SUCCESS != ulError || !Active())
    {
        Lock();
        
        if (Active()
            && !NhIsFatalSocketError(ulError)
            && INVALID_SOCKET != m_hsUdpListen)
        {
            AddRef();
            dwError =
                NhReadDatagramSocket(
                    m_pCompRef,
                    m_hsUdpListen,
                    pBuffer,
                    UdpReadCompletionRoutine,
                    this,
                    m_pCompRef
                    );
            if (ERROR_SUCCESS != dwError)
            {
                Release();
                NhReleaseBuffer(pBuffer);
            }
        }
        else
        {
            NhReleaseBuffer(pBuffer);
        }

        Unlock();

        return;
    }

    //
    // Lookup the original destination address for this packet.
    //

    ulBufferSize = sizeof(MappingInfo); 
    dwError =
        NatLookupAndQueryInformationSessionMapping(
            m_hNat,
            NAT_PROTOCOL_UDP,
            INADDR_LOOPBACK_NO,
            m_usUdpListenPort,
            pBuffer->ReadAddress.sin_addr.s_addr,
            pBuffer->ReadAddress.sin_port,
            &MappingInfo,
            &ulBufferSize,
            NatKeySessionMappingExInformation
            );

    if (ERROR_SUCCESS == dwError)
    {
        //
        // See if we have a port mapping for the original destination,
        // and, if so, get the destination address
        //

        Lock();

        pMapping =
            LookupMapping(
                MappingInfo.DestinationPort,
                MappingInfo.AdapterIndex,
                NULL
                );

        if (NULL != pMapping)
        {
            ulDestinationAddress = pMapping->ulDestinationAddress;
        }

        Unlock();
    }

    if (0 != ulDestinationAddress)
    {
        //
        // Construct the new packet and send it on its way
        //

        BuildAndSendRawUdpPacket(
            ulDestinationAddress,
            MappingInfo.DestinationPort,
            pBuffer
            );
    }

    //
    // If we're still active repost the read, otherwise free the
    // buffer.
    //

    Lock();

    if (Active()
        && INVALID_SOCKET != m_hsUdpListen)
    {
        AddRef();
        dwError =
            NhReadDatagramSocket(
                m_pCompRef,
                m_hsUdpListen,
                pBuffer,
                UdpReadCompletionRoutine,
                this,
                m_pCompRef
                );
        if (ERROR_SUCCESS != dwError)
        {
            Release();
            NhReleaseBuffer(pBuffer);
        }
    }
    else
    {
        NhReleaseBuffer(pBuffer);
    }

    Unlock();
    
}

HRESULT
CUdpBroadcastMapper::BuildAndSendRawUdpPacket(
    ULONG ulDestinationAddress,
    USHORT usDestinationPort,
    PNH_BUFFER pPacketData
    )
{
    HRESULT hr = S_OK;
    PNH_BUFFER pBuffer;
    ULONG ulPacketSize;
    PIP_HEADER pIpHeader;
    UDP_HEADER UNALIGNED *pUdpHeader;
    PUCHAR pucData;
    DWORD dwError;

    //
    // Allocate a buffer large enough for the headers and packet data
    //

    ulPacketSize =
        sizeof(IP_HEADER) + sizeof(UDP_HEADER) + pPacketData->BytesTransferred;

    pBuffer = NhAcquireVariableLengthBuffer(ulPacketSize);

    if (NULL != pBuffer)
    {
        //
        // Locate offsets w/in the buffer
        //

        pIpHeader = reinterpret_cast<PIP_HEADER>(pBuffer->Buffer);
        pUdpHeader =
            reinterpret_cast<UDP_HEADER UNALIGNED *>(pBuffer->Buffer + sizeof(IP_HEADER));
        pucData = pBuffer->Buffer + sizeof(IP_HEADER) + sizeof(UDP_HEADER);

        //
        // Copy over the packet data
        //

        CopyMemory(pucData, pPacketData->Buffer, pPacketData->BytesTransferred);

        //
        // Fill out the IP header
        //

        pIpHeader->VersionAndHeaderLength =
            (4 << 4) | (sizeof(IP_HEADER) / sizeof(ULONG));
        pIpHeader->TypeOfService = 0;
        pIpHeader->TotalLength = htons(static_cast<USHORT>(ulPacketSize));
        pIpHeader->Identification = htons(++m_usIpId);
        pIpHeader->OffsetAndFlags = 0;
        pIpHeader->TimeToLive = 128;
        pIpHeader->Protocol = NAT_PROTOCOL_UDP;
        pIpHeader->Checksum = 0;
        pIpHeader->SourceAddress = pPacketData->ReadAddress.sin_addr.s_addr;
        pIpHeader->DestinationAddress = ulDestinationAddress;

        //
        // Fill out the UDP header
        //

        pUdpHeader->SourcePort = pPacketData->ReadAddress.sin_port;
        pUdpHeader->DestinationPort = usDestinationPort;
        pUdpHeader->Length =
            htons(
                static_cast<USHORT>(
                    sizeof(UDP_HEADER) + pPacketData->BytesTransferred
                    )
                );
        pUdpHeader->Checksum = 0;

        //
        // Send the buffer on its way
        //

        AddRef();
        dwError =
            NhWriteDatagramSocket(
                m_pCompRef,
                m_hsUdpRaw,
                ulDestinationAddress,
                usDestinationPort,
                pBuffer,
                ulPacketSize,
                RawWriteCompletionRoutine,
                this,
                m_pCompRef
                );
        if (ERROR_SUCCESS != dwError)
        {
            Release();
            NhReleaseBuffer(pBuffer);
            hr = HRESULT_FROM_WIN32(dwError);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

VOID
CUdpBroadcastMapper::RawWriteCompletionRoutine(
    ULONG ulError,
    ULONG ulBytesTransferred,
    PNH_BUFFER pBuffer
    )
{
    CUdpBroadcastMapper *pMapper;
    PCOMPONENT_REFERENCE pCompRef;

    pMapper = reinterpret_cast<CUdpBroadcastMapper*>(pBuffer->Context);
    pCompRef = reinterpret_cast<PCOMPONENT_REFERENCE>(pBuffer->Context2);

    ASSERT(NULL != pMapper);
    ASSERT(NULL != pCompRef);

    //
    // Free the passed-in buffer
    //

    NhReleaseBuffer(pBuffer);
    
    //
    // Release the references obtained on both the object and
    // the component
    //

    pMapper->Release();
    ReleaseComponentReference(pCompRef);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\fwlogger.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    fwlogger.h

Abstract:

    Support for firewall logging to a text file.

Author:

    Jonathan Burstein (jonburs)     18 September 2000

Revision History:

--*/

#pragma once

#include <wmistr.h>
#include <evntrace.h>
#include <ntwmi.h>
#include "natschma.h"

//
// Protocol constants
//

#define NAT_PROTOCOL_ICMP       0x01
#define NAT_PROTOCOL_IGMP       0x02
#define NAT_PROTOCOL_TCP        0x06
#define NAT_PROTOCOL_UDP        0x11
#define NAT_PROTOCOL_PPTP       0x2F

#define TCP_FLAG_FIN            0x0100
#define TCP_FLAG_SYN            0x0200
#define TCP_FLAG_RST            0x0400
#define TCP_FLAG_PSH            0x0800
#define TCP_FLAG_ACK            0x1000
#define TCP_FLAG_URG            0x2000

//
// Structures
//

#define FW_LOG_BUFFER_SIZE 4096 - sizeof(OVERLAPPED) - sizeof(PCHAR)
#define FW_LOG_BUFFER_REMAINING(pBuffer) \
            FW_LOG_BUFFER_SIZE - ((pBuffer)->pChar - (pBuffer)->Buffer)

typedef struct _FW_LOG_BUFFER
{
    OVERLAPPED Overlapped;
    PCHAR pChar;
    CHAR Buffer[FW_LOG_BUFFER_SIZE];
} FW_LOG_BUFFER, *PFW_LOG_BUFFER;

//
// Prototypes
//

VOID
FwCleanupLogger(
    VOID
    );

DWORD
FwInitializeLogger(
    VOID
    );

VOID
FwStartLogging(
    VOID
    );

VOID
FwStopLogging(
    VOID
    );

VOID
FwUpdateLoggingSettings(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\csaupdate.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    csaupdate.h

Abstract:

    Declarations for CSharedAccessUpdate -- notification sink for
    configuration changes.

Author:

    Jonathan Burstein (jonburs)     20 April 2001

Revision History:

--*/

#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "saupdate.h"

class ATL_NO_VTABLE CSharedAccessUpdate :
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
    public CComCoClass<CSharedAccessUpdate, &CLSID_SAUpdate>,
    public ISharedAccessUpdate
{
public:

    DECLARE_NO_REGISTRY()
    DECLARE_NOT_AGGREGATABLE(CSharedAccessUpdate)
    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CSharedAccessUpdate)
        COM_INTERFACE_ENTRY(ISharedAccessUpdate)
    END_COM_MAP()

    CSharedAccessUpdate()
    {
    };

    STDMETHODIMP
    ConnectionPortMappingChanged(
        GUID *pConnectionGuid,
        GUID *pPortMappingGuid,
        BOOLEAN fProtocolChanged
        );

    STDMETHODIMP
    PortMappingListChanged();


private:

    BOOLEAN
    IsH323Protocol(
        UCHAR ucProtocol,
        USHORT usPort
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\fwlogger.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    fwlogger.cpp

Abstract:

    Support for firewall logging to a text file.

Author:

    Jonathan Burstein (jonburs)     18 September 2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if DBG

//
// Module state -- interlocked access only. This information
// is only used on debug builds.
//

typedef enum {
    FwUninitialized = 0,
    FwInitialized
} FW_MODULE_STATE;

FW_MODULE_STATE FwpModuleState = FwUninitialized;

#endif // DBG

//
// Globals. If both locks need to be held at the same time,
// g_FwFileLock must be acquired first.
//

CRITICAL_SECTION g_FwLock;
HNET_FW_LOGGING_SETTINGS *g_pSettings;
TRACEHANDLE g_hSession;
HANDLE g_hThread;
BOOLEAN g_fTracingActive;
ULONG g_ulKernelEventsLostAtShutdown;

CRITICAL_SECTION g_FwFileLock;
HANDLE g_hFile;
DWORD g_dwFileOffset;
PFW_LOG_BUFFER g_pCurrentBuffer;
PFW_LOG_BUFFER g_pReserveBuffer;
BOOLEAN g_fIOPending;
HANDLE g_hIOEvent;
ULONG g_ulDroppedEventCount;
ULONG g_ulKernelEventsLost;
HANDLE g_hDroppedEventTimer;

//
// Constants
//

GUID c_ConnectionCreationEventGuid = MSIPNAT_ConnectionCreationEventGuid;
GUID c_ConnectionDeletionEventGuid = MSIPNAT_ConnectionDeletionEventGuid;
GUID c_PacketDroppedEventGuid = MSIPNAT_PacketDroppedEventGuid;

WCHAR c_wszLogSessionName[] = L"FirewallLogSession";
WCHAR c_wszBackupFileExtension[] = L".old";

CHAR c_szConnectionFormat[] = "%04d-%02d-%02d %02d:%02d:%02d %s %s %s %s %u %u - - - - - - - -\r\n";
CHAR c_szTcpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP TCP %s %s %u %u %u %s %u %u %u - - -\r\n";
CHAR c_szUdpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP UDP %s %s %u %u %u - - - - - - -\r\n";
CHAR c_szIcmpPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP ICMP %s %s - - %u - - - - %u %u -\r\n";
CHAR c_szDroppedPacketFormat[] = "%04d-%02d-%02d %02d:%02d:%02d DROP %u %s %s - - %u - - - - - - -\r\n";
CHAR c_szEventsLostFormat[] = "%04d-%02d-%02d %02d:%02d:%02d INFO-EVENTS-LOST - - - - - - - - - - - - %u\r\n";

CHAR c_szAcceptInbound[] = "OPEN-INBOUND";
CHAR c_szAcceptOutbound[] = "OPEN";
CHAR c_szTcp[] = "TCP";
CHAR c_szUdp[] = "UDP";
CHAR c_szLogFileHeader[]
    = "#Verson: 1.0\r\n#Software: Microsoft Internet Connection Firewall\r\n#Time Format: Local\r\n#Fields: date time action protocol src-ip dst-ip src-port dst-port size tcpflags tcpsyn tcpack tcpwin icmptype icmpcode info\r\n\r\n";

//
// Function Prototypes
//

DWORD
FwpAllocateBuffer(
    PFW_LOG_BUFFER *ppBuffer
    );

PEVENT_TRACE_PROPERTIES
FwpAllocateTraceProperties(
    VOID
    );

DWORD
FwpBackupFile(
    LPWSTR pszwPath
    );

VOID
FwpCleanupTraceThreadResources(
    VOID
    );

VOID
CALLBACK
FwpCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED pOverlapped
    );

VOID
WINAPI
FwpConnectionCreationCallback(
    PEVENT_TRACE pEvent
    );

VOID
WINAPI
FwpConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    );

VOID
FwpConvertUtcFiletimeToLocalSystemtime(
    FILETIME *pFiletime,
    SYSTEMTIME *pSystemtime
    );

VOID
CALLBACK
FwpDroppedEventTimerRoutine(
    PVOID pvParameter,
    BOOLEAN fWaitTimeout
    );

DWORD
FwpFlushCurrentBuffer(
    VOID
    );

DWORD
FwpOpenLogFile(
    HANDLE *phFile,
    BOOLEAN *pfNewFile
    );

VOID
WINAPI
FwpPacketDroppedCallback(
    PEVENT_TRACE pEvent
    );

DWORD
FwpLaunchTraceSession(
    HNET_FW_LOGGING_SETTINGS *pSettings,
    TRACEHANDLE *phSession
    );
    

HRESULT
FwpLoadSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    );

DWORD
WINAPI
FwpTraceProcessingThreadRoutine(
    LPVOID pvParam
    );

DWORD
FwpWriteLogHeaderToBuffer(
    PFW_LOG_BUFFER pBuffer
    );


VOID
FwCleanupLogger(
    VOID
    )

/*++

Routine Description:

    This routine is called to cleanup the logging subsystem. All
    resources in use will be freed. After this call, the only valid
    routine in this module is FwInitializeLogger.

Arguments:

    none.
    
Return Value:

    none.

Environment:

    Caller must not be holding g_FwFileLock or g_FwLock

--*/

{
    PROFILE("FwCleanupLogger");

    //
    // Make sure the logging is stopped
    //

    FwStopLogging();
    
    ASSERT(FwInitialized ==
            (FW_MODULE_STATE) InterlockedExchange(
                                    (LPLONG) &FwpModuleState,
                                    (LONG) FwUninitialized
                                    ));

    EnterCriticalSection(&g_FwLock);
    
    ASSERT(NULL == g_hSession);
    ASSERT(NULL == g_hThread);
    ASSERT(INVALID_HANDLE_VALUE == g_hFile);
    
    if (g_pSettings) HNetFreeFirewallLoggingSettings(g_pSettings);

    LeaveCriticalSection(&g_FwLock);
    DeleteCriticalSection(&g_FwLock);
    DeleteCriticalSection(&g_FwFileLock);
    
} // FwCleanupLogger


DWORD
FwInitializeLogger(
    VOID
    )

/*++

Routine Description:

    This routine is called to control to initialize the logging subsystem.
    It must be called before any of the other routines in this module, and
    may not be called again until after a call to FwCleanupLogger.
    
Arguments:

    none.

Return Value:

    DWORD -- Win32 error code

--*/

{
    DWORD dwError = NO_ERROR;
    BOOLEAN fFirstLockInitialized = FALSE;

    PROFILE("FwInitializeLogger");

    ASSERT(FwUninitialized ==
            (FW_MODULE_STATE) InterlockedExchange(
                                    (LPLONG) &FwpModuleState,
                                    (LONG) FwInitialized
                                    ));

    __try
    {
        InitializeCriticalSection(&g_FwLock);
        fFirstLockInitialized = TRUE;
        InitializeCriticalSection(&g_FwFileLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwInitializeLogger: exception %d creating lock",
            dwError = GetExceptionCode()
            );

        if (fFirstLockInitialized)
        {
            DeleteCriticalSection(&g_FwLock);
        }

#if DBG
        InterlockedExchange(
            (LPLONG) &FwpModuleState,
            (LONG) FwUninitialized
            );
#endif
    }

    g_pSettings = NULL;
    g_hSession = NULL;
    g_hThread = NULL;
    g_fTracingActive = FALSE;
    g_ulKernelEventsLostAtShutdown = 0;

    g_hFile = INVALID_HANDLE_VALUE;
    g_dwFileOffset = 0;
    g_pCurrentBuffer = NULL;
    g_pReserveBuffer = NULL;
    g_fIOPending = FALSE;
    g_hIOEvent = NULL;
    g_ulDroppedEventCount = 0;
    g_ulKernelEventsLost = 0;
    g_hDroppedEventTimer = NULL;
                                    
    return dwError;
} // FwInitializeLogger


DWORD
FwpAllocateBuffer(
    PFW_LOG_BUFFER *ppBuffer
    )

/*++

Routine Description:

    Allocates an initializes an FW_LOG_BUFFER structure

Arguments:

    ppBuffer - receives a pointer to the newly-allocated structure

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError = ERROR_SUCCESS;

    PROFILE("FwpAllocateBuffer");
    ASSERT(NULL != ppBuffer);

    *ppBuffer =
        reinterpret_cast<PFW_LOG_BUFFER>(
            NH_ALLOCATE(sizeof(**ppBuffer))
            );

    if (NULL != *ppBuffer)
    {
        ZeroMemory(&(*ppBuffer)->Overlapped, sizeof(OVERLAPPED));
        (*ppBuffer)->pChar = (*ppBuffer)->Buffer;
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;        
    }

    return dwError;
} // FwpAllocateBuffer


PEVENT_TRACE_PROPERTIES
FwpAllocateTraceProperties(
    VOID
    )

/*++

Routine Description:

    Allocates and partially initializes an EVENT_TRACE_PROPERTIES structure.

Arguments:

    none.

Return Value:

    PEVENT_TRACE_PROPERTIES - pointer to the allocated structure. The caller
        must call HeapFree(GetProcessHeap(),...) on this pointer.

--*/

{
    PEVENT_TRACE_PROPERTIES pProperties = NULL;
    ULONG ulSize;

    ulSize = sizeof(*pProperties)
            + ((wcslen(c_wszLogSessionName) + 1) * sizeof(WCHAR));

    pProperties = (PEVENT_TRACE_PROPERTIES) HeapAlloc(
                                                GetProcessHeap(),
                                                HEAP_ZERO_MEMORY,
                                                ulSize
                                                );

    if (NULL == pProperties)
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpAllocateTraceProperties: Unable to allocate %d bytes",
            ulSize
            );

        return NULL;
    }

    pProperties->Wnode.BufferSize = ulSize;
    pProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    pProperties->Wnode.ClientContext = EVENT_TRACE_CLOCK_SYSTEMTIME;
    pProperties->LogFileMode = EVENT_TRACE_REAL_TIME_MODE; 
    pProperties->LoggerNameOffset = sizeof(*pProperties);
    
    return pProperties;
} // FwpAllocateTraceProperties


DWORD
FwpBackupFile(
    LPWSTR pszwPath
    )

/*++

Routine Description:

    Backs-up a file to filename.xxx.old

Arguments:

    pszwPath - path to the file to backup

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fResult;
    LPWSTR wszBuffer;

    ASSERT(NULL != pszwPath);

    //
    // Allocate buffer to hold new filename
    //

    wszBuffer =
        new WCHAR[wcslen(pszwPath) + wcslen(c_wszBackupFileExtension) + 1];

    if (NULL != wszBuffer)
    {
        lstrcpyW(wszBuffer, pszwPath);
        lstrcatW(wszBuffer, c_wszBackupFileExtension);

        fResult = MoveFileEx(pszwPath, wszBuffer, MOVEFILE_REPLACE_EXISTING);

        if (FALSE == fResult)
        {
            dwError = GetLastError();

            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpBackupFile: MoveFileEx = %d",
                dwError
                );
        }
    }
    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpBackupFile: Unable to allolcate buffer"
            );
    }
    
    return dwError;
} // FwpBackupFile


VOID
FwpCleanupTraceThreadResources(
    VOID
    )

/*++

Routine Description:

    Cleans up resources used by the trace processing thread:
    * revokes event callbacks
    * waits for IO to complete, if pending
    * closes the log file
    * frees buffers

Arguments:

    none.
    
Return Value:

    none.

Environment:

    The caller must not hold g_FwFileLock or g_FwLock.

--*/

{
    DWORD dwError;
    
    PROFILE("FwpCleanupTraceThreadResources");

    //
    // Unregister the trace callbacks. It is safe to call these even
    // if the callbacks weren't registered to begin with.
    //

    RemoveTraceCallback(&c_PacketDroppedEventGuid);
    RemoveTraceCallback(&c_ConnectionCreationEventGuid);
    RemoveTraceCallback(&c_ConnectionDeletionEventGuid);

    EnterCriticalSection(&g_FwFileLock);

    //
    // Cancel the dropped packet timer
    //

    if (NULL != g_hDroppedEventTimer)
    {
        DeleteTimerQueueTimer(
            NULL,
            g_hDroppedEventTimer,
            INVALID_HANDLE_VALUE
            );
            
        g_hDroppedEventTimer = NULL;
    }

    //
    // If necessary, wait for any pending IO operations to complete
    //

    if (g_fIOPending)
    {   
        g_hIOEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (NULL != g_hIOEvent)
        {
            HANDLE hEvent = g_hIOEvent;
            
            LeaveCriticalSection(&g_FwFileLock);

            dwError = WaitForSingleObject(hEvent, 20 * 1000);

            if (WAIT_OBJECT_0 != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessingRoutine: Wait(g_hIOEvent) = %d/%d",
                    dwError,
                    GetLastError()
                    );

                //
                // It should never take 20 seconds for an IO to complete,
                // so let's get immediate notification of this on debug
                // builds.
                //
                
                ASSERT(WAIT_OBJECT_0 == dwError);
            }

            EnterCriticalSection(&g_FwFileLock);
            CloseHandle(g_hIOEvent);
            g_hIOEvent = NULL;
        }
    }

    g_fIOPending = FALSE;

    //
    // Close the log file
    //

    if (INVALID_HANDLE_VALUE != g_hFile)
    {
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
    }

    g_dwFileOffset = 0;

    //
    // Clean up our buffers
    //

    if (NULL != g_pCurrentBuffer)
    {
        NH_FREE(g_pCurrentBuffer);
        g_pCurrentBuffer = NULL;
    }

    if (NULL != g_pReserveBuffer)
    {
        NH_FREE(g_pReserveBuffer);
        g_pReserveBuffer = NULL;
    }

    //
    // Reset dropped event counts
    //

    g_ulDroppedEventCount = 0;
    g_ulKernelEventsLost = 0;

    LeaveCriticalSection(&g_FwFileLock);
    

} // FwpCleanupTraceThreadResources


VOID
CALLBACK
FwpCompletionRoutine(
    DWORD dwErrorCode,
    DWORD dwBytesTransferred,
    LPOVERLAPPED pOverlapped
    )

/*++

Routine Description:

    Completion routine called by the system thread pool when our
    IO operation is finished. Responsible for updating the file
    position and starting a new IO operation if necessary.

Arguments:

    dwErrorCode - result of the IO operation

    dwBytesTransferred - number of bytes transferred during the operation

    pOverlapped - pointer to the overlapped structure for the operation. We
                  can recover the FW_LOG_BUFFER structure from this pointer.
                  
Return Value:

    none.

--*/

{
    PFW_LOG_BUFFER pBuffer;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Adjust our file offset
    //

    if (ERROR_SUCCESS == dwErrorCode)
    {
        g_dwFileOffset += dwBytesTransferred;
    }
    else
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpCompletionRoutine: dwErrorCode = %d",
            dwErrorCode
            );
    }

    g_fIOPending = FALSE;

    //
    // Reset the buffer that was passed in 
    //

    ASSERT(NULL != pOverlapped);
    
    pBuffer = CONTAINING_RECORD(pOverlapped, FW_LOG_BUFFER, Overlapped);
    ZeroMemory(&pBuffer->Overlapped, sizeof(OVERLAPPED));
    pBuffer->pChar = pBuffer->Buffer;

    //
    // Check if the file is at the size limit
    //

    EnterCriticalSection(&g_FwLock);

    ASSERT(NULL != g_pSettings);

    if (g_dwFileOffset >= g_pSettings->ulMaxFileSize)
    {
        DWORD dwError;
        BOOLEAN fNewFile;
        
        CloseHandle(g_hFile);
        g_hFile = INVALID_HANDLE_VALUE;
        
        //
        // If FwpBackupFile fails, FwpOpenFile will still do
        // the right thing.
        //

        FwpBackupFile(g_pSettings->pszwPath);

        g_dwFileOffset = 0;
        dwError = FwpOpenLogFile(&g_hFile, &fNewFile);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpCompletionRoutine: FwpOpenLogFile = %d",
                dwError
                );

            NH_FREE(pBuffer);

            LeaveCriticalSection(&g_FwLock);
            LeaveCriticalSection(&g_FwFileLock);
            
            FwStopLogging();

            return;
        }
        else if (TRUE == fNewFile)
        {
            //
            // Need to write header.
            //

            if (ERROR_SUCCESS == FwpWriteLogHeaderToBuffer(pBuffer))
            {
                PFW_LOG_BUFFER pTempBuffer = g_pCurrentBuffer;
                g_pCurrentBuffer = pBuffer;

                FwpFlushCurrentBuffer();

                g_pCurrentBuffer = pTempBuffer;
                pBuffer = NULL;
            }
            
        }
        else
        {
            g_dwFileOffset = GetFileSize(g_hFile, NULL);

            if ((DWORD)-1 == g_dwFileOffset)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpCompletionRoutine: GetFileSize = %d",
                    GetLastError()
                    );
                    
                NH_FREE(pBuffer);

                LeaveCriticalSection(&g_FwLock);
                LeaveCriticalSection(&g_FwFileLock);

                FwStopLogging();

                return;
            }
        }
    }

    LeaveCriticalSection(&g_FwLock);

    //
    // See if we need to start a new operation.
    //

    if (FALSE == g_fIOPending && NULL != g_pCurrentBuffer)
    {
        if (g_pCurrentBuffer->pChar != g_pCurrentBuffer->Buffer)
        {
            //
            // Current buffer needs to be flushed
            //

            FwpFlushCurrentBuffer();
        }
    }

    //
    // Place buffer into storage. If we're using the buffer
    // to write the log header, it will be NULL at this point
    //

    if (NULL != pBuffer)
    {
        if (NULL == g_pCurrentBuffer)
        {
            g_pCurrentBuffer = pBuffer;
        }
        else if (NULL == g_pReserveBuffer)
        {
            g_pReserveBuffer = pBuffer;
        }
        else
        {
            //
            // Both buffer slots are already in use -- unexpected.
            // Assert and free the extra buffer
            //

            ASSERT(NULL == g_pCurrentBuffer || NULL == g_pReserveBuffer);
            NH_FREE(pBuffer);
        }
    }

    //
    // Check to see if we need to signal the IO finished event
    //

    if (!g_fIOPending && NULL != g_hIOEvent)
    {
        if (!SetEvent(g_hIOEvent))
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpCompletionRoutine: SetEvent = %d",
                GetLastError()
                );
        }
    }

    LeaveCriticalSection(&g_FwFileLock);
    
} // FwpCompletionRoutine


VOID
WINAPI
FwpConnectionCreationCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a connection creation event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_ConnectionCreationEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    PCHAR pszAction;
    PCHAR pszProtocol;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    USHORT usSrcPort;
    USHORT usDstPort;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpConnectionCreationCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_ConnectionCreationEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    if (pEventData->InboundConnection)
    {
        pszAction = c_szAcceptInbound;
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->RemoteAddress));
        usSrcPort = ntohs(pEventData->RemotePort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->LocalAddress));
        usDstPort = ntohs(pEventData->LocalPort);
    }
    else
    {
        pszAction = c_szAcceptOutbound;
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->LocalAddress));
        usSrcPort = ntohs(pEventData->LocalPort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->RemoteAddress));
        usDstPort = ntohs(pEventData->RemotePort);
    }

    pszProtocol =
        NAT_PROTOCOL_TCP == pEventData->Protocol ?
            c_szTcp :
            c_szUdp;           
                    
    
    //
    // Write the event data to the buffer
    //

    cch =
        _snprintf(
            g_pCurrentBuffer->pChar,
            FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
            c_szConnectionFormat,
            stLocalTime.wYear,
            stLocalTime.wMonth,
            stLocalTime.wDay,
            stLocalTime.wHour,
            stLocalTime.wMinute,
            stLocalTime.wSecond,
            pszAction,
            pszProtocol,
            szSrcAddress,
            szDstAddress,
            usSrcPort,
            usDstPort
            );

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);

} // FwpConnectionCreationCallback


VOID
WINAPI
FwpConnectionDeletionCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a connection deletion event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_ConnectionDeletionEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    PCHAR pszProtocol;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    USHORT usSrcPort;
    USHORT usDstPort;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpConnectionDeletionCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_ConnectionDeletionEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    if (pEventData->InboundConnection)
    {
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->RemoteAddress));
        usSrcPort = ntohs(pEventData->RemotePort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->LocalAddress));
        usDstPort = ntohs(pEventData->LocalPort);
    }
    else
    {
        lstrcpyA(szSrcAddress, INET_NTOA(pEventData->LocalAddress));
        usSrcPort = ntohs(pEventData->LocalPort);
        lstrcpyA(szDstAddress, INET_NTOA(pEventData->RemoteAddress));
        usDstPort = ntohs(pEventData->RemotePort);
    }

    pszProtocol =
        NAT_PROTOCOL_TCP == pEventData->Protocol ?
            c_szTcp :
            c_szUdp;           
                    
    
    //
    // Write the event data to the buffer
    //

    cch =
        _snprintf(
            g_pCurrentBuffer->pChar,
            FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
            c_szConnectionFormat,
            stLocalTime.wYear,
            stLocalTime.wMonth,
            stLocalTime.wDay,
            stLocalTime.wHour,
            stLocalTime.wMinute,
            stLocalTime.wSecond,
            "CLOSE",
            pszProtocol,
            szSrcAddress,
            szDstAddress,
            usSrcPort,
            usDstPort
            );

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);

} // FwpConnectionDeletionCallback


VOID
FwpConvertUtcFiletimeToLocalSystemtime(
    FILETIME *pFiletime,
    SYSTEMTIME *pSystemtime
    )

/*++

Routine Description:

    Converts UTC time in a FILETIME struct to local time in
    a SYSTEMTIME struct
    
Arguments:

    pFiletime - pointer to UTC filetime structure

    pSystemtime - pointer to systemtime structure that is to receive
                  the local time

Return Value:

    none.

--*/

{
    FILETIME ftLocalTime;
    
    ASSERT(NULL != pFiletime);
    ASSERT(NULL != pSystemtime);

    if (!FileTimeToLocalFileTime(pFiletime, &ftLocalTime)
        || !FileTimeToSystemTime(&ftLocalTime, pSystemtime))
    {
        //
        // Conversion failed -- use zero time
        //
        
        ZeroMemory( pSystemtime, sizeof(*pSystemtime));
    }
    
} // FwpConvertUtcFiletimeToLocalSystemtime


VOID
CALLBACK
FwpDroppedEventTimerRoutine(
    PVOID pvParameter,
    BOOLEAN fWaitTimeout
    )

/*++

Routine Description:

    Checks if there are any dropped events, and, if so, writes
    an event to the log.
    
Arguments:

    pvParameter -- NULL if called by the timer. If called directly, a PULONG
        to the number of events dropped by WMI. In the later situation, this
        routine will not query the trace session for the number of dropped
        events.

    fWaitTimeout -- unused

Return Value:

    none.

--*/

{
    ULONG ulKernelEvents = 0;
    PEVENT_TRACE_PROPERTIES pProperties;
    SYSTEMTIME stLocalTime;
    DWORD dwError;
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Check to see if we we're given the kernel mode drop count, as
    // would happen during shutdown
    //

    if (NULL != pvParameter)
    {
        ulKernelEvents = *((PULONG)pvParameter);
    }
    else
    {
        //
        // Query the trace session for number of events dropped
        // in kernel mode. If g_hSession is NULL, then we are shutting
        // down and should exit w/o logging -- this call is the result
        // of the timer firing after FwStopLogging has stopped the
        // trace session.
        //

        EnterCriticalSection(&g_FwLock);

        if (NULL != g_hSession)
        {
            pProperties = FwpAllocateTraceProperties();

            if (NULL != pProperties)
            {
                dwError =
                    ControlTrace(
                        g_hSession,
                        NULL,
                        pProperties,
                        EVENT_TRACE_CONTROL_QUERY
                        );

                if (ERROR_SUCCESS == dwError)
                {
                    ulKernelEvents = pProperties->EventsLost;
                }
                else
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpDroppedEventTimerRoutine: ControlTrace = %d",
                        dwError
                        );
                }

                HeapFree(GetProcessHeap(), 0, pProperties);
            }
        }
        else
        {
            //
            // Timer callback after trace session stopped - exit
            //

            LeaveCriticalSection(&g_FwLock);
            LeaveCriticalSection(&g_FwFileLock);
            return;
        }

        LeaveCriticalSection(&g_FwLock);
    }

    //
    // Record the dropped events, if there are any
    //

    if (ulKernelEvents > g_ulKernelEventsLost
        || g_ulDroppedEventCount > 0)
    {

        //
        // Get a buffer to write to.
        //

        if (NULL == g_pCurrentBuffer)
        {
            if (NULL == g_pReserveBuffer)
            {
                if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpDroppedEventTimerRoutine: Unable to allocate buffer"
                        );

                    LeaveCriticalSection(&g_FwFileLock);
                    return;
                }
            }
            else
            {
                g_pCurrentBuffer = g_pReserveBuffer;
                g_pReserveBuffer = NULL;
            }
        }

        ASSERT(NULL != g_pCurrentBuffer);

        //
        // Get the current time
        //

        GetLocalTime(&stLocalTime);

        //
        // Write the dropped packet event to the buffer. The actual number of
        // dropped events that we're logging is:
        //
        // ulKernelEvents - g_ulKernelEventsLost + g_ulDroppedEventCount
        //

        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szEventsLostFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                ulKernelEvents - g_ulKernelEventsLost + g_ulDroppedEventCount
                );

        if (cch > 0)
        {
            //
            // Move the buffer pointer to the end of the data we just wrote.
            // If cch were negative, then there wasn't enough room to write
            // then entire entry; by not adjusting the pointer, we essentially
            // drop this event.
            //

            g_pCurrentBuffer->pChar += cch;

            //
            // Adjust the dropped event counter
            //

            g_ulKernelEventsLost = ulKernelEvents;
            g_ulDroppedEventCount = 0;
        }
        else
        {
            //
            // This doesn't count as a dropped event.
            //
        }

        //
        // If there is no current IO, flush the buffer
        //

        if (FALSE == g_fIOPending)
        {
            FwpFlushCurrentBuffer();
        }
    }

    LeaveCriticalSection(&g_FwFileLock);
    
} // FwpDroppedEventTimerRoutine


DWORD
FwpFlushCurrentBuffer(
    VOID
    )

/*++

Routine Description:

    Writes the current buffer to disk.
    
Arguments:

    none.

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError;
    DWORD dwBytesWritten;
    DWORD dwBytesToWrite;
    BOOL fResult;

    EnterCriticalSection(&g_FwFileLock);

    ASSERT(FALSE == g_fIOPending);
    ASSERT(NULL != g_pCurrentBuffer);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.Internal);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.InternalHigh);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.Offset);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.OffsetHigh);
    ASSERT(0 == g_pCurrentBuffer->Overlapped.hEvent);
    
    g_pCurrentBuffer->Overlapped.Offset = g_dwFileOffset;
    dwBytesToWrite = (DWORD)(g_pCurrentBuffer->pChar - g_pCurrentBuffer->Buffer);

    fResult =
        WriteFile(
            g_hFile,
            g_pCurrentBuffer->Buffer,
            dwBytesToWrite,
            &dwBytesWritten,
            &g_pCurrentBuffer->Overlapped
            );

    dwError = GetLastError();

    if (FALSE != fResult || ERROR_IO_PENDING == dwError)
    {
        //
        // The write succeeded or is pending; our completion routine
        // is therefore guaranteed to be called.
        //
        
        g_fIOPending = TRUE;
        g_pCurrentBuffer = g_pReserveBuffer;
        g_pReserveBuffer = NULL;
    }
    else
    {
        //
        // Unexpected error. Reset the buffer for future use.
        //

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpFlushCurrentBuffer: WriteFile = %d",
            dwError
            );

        ZeroMemory(&g_pCurrentBuffer->Overlapped, sizeof(OVERLAPPED));
        g_pCurrentBuffer->pChar = g_pCurrentBuffer->Buffer;
    }
                

    LeaveCriticalSection(&g_FwFileLock);

    return dwError;
} // FwpFlushCurrentBuffer


DWORD
FwpOpenLogFile(
    HANDLE *phFile,
    BOOLEAN *pfNewFile
    )

/*++

Routine Description:

    Opens the file used for logging and associates it with the thread pool's
    IO completion port.

Arguments:

    phFile - receives the file handle for the opened log file.

    pfNewFile - receives TRUE if a new file was created; false otherwise

Return Value:

    DWORD - Win32 error code

--*/

{
    DWORD dwError;
    DWORD dwFileSize;

    ASSERT(NULL != phFile);
    ASSERT(NULL != pfNewFile);

    EnterCriticalSection(&g_FwLock);

    ASSERT(NULL != g_pSettings);
    ASSERT(NULL != g_pSettings->pszwPath);

    *pfNewFile = FALSE;
    dwError = ERROR_SUCCESS;

    *phFile =
        CreateFile(
            g_pSettings->pszwPath,
            GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_ALWAYS,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
            NULL
            );

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        //
        // Check if this is a new or existing file
        //

        if (ERROR_ALREADY_EXISTS == GetLastError())
        {
            //
            // Check to see if existing file size is > 95% of
            // our max; if so, backup now and create new file
            //

            dwFileSize = GetFileSize(*phFile, NULL);

            if ((DWORD)-1 == dwFileSize)
            {
                //
                // Unable to get file size. This is quite unexpected...
                //

                dwError = GetLastError();
                CloseHandle(*phFile);
                *phFile = INVALID_HANDLE_VALUE;

                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpOpenLogFile: GetFileSize = %d",
                    dwError
                    );
            }
            else if (dwFileSize > 0.95 * g_pSettings->ulMaxFileSize)
            {
                //
                // Close the current file handle
                //

                CloseHandle(*phFile);

                //
                // Rename the current log file. This call will delete any
                // previous backups. If this fails, we'll just overwrite
                // the current log file.
                //

                FwpBackupFile(g_pSettings->pszwPath);

                //
                // Open again
                //

                *pfNewFile = TRUE;
                *phFile =
                    CreateFile(
                        g_pSettings->pszwPath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                        NULL
                        );

                if (INVALID_HANDLE_VALUE == *phFile)
                {
                    dwError = GetLastError();

                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwpOpenLogFile: Error %d creating %S after backup",
                        dwError,
                        g_pSettings->pszwPath
                        );
                }
            }
        }
        else
        {
            *pfNewFile = TRUE;
        }
    }
    else
    {
        dwError = GetLastError();

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpOpenLogFile: Error %d opening %S",
            dwError,
            g_pSettings->pszwPath
            );
    }

    if (INVALID_HANDLE_VALUE != *phFile)
    {
        //
        // Associate the file handle w/ the thread pool completion port
        //

        if (!BindIoCompletionCallback(*phFile, FwpCompletionRoutine, 0))
        {
            dwError = GetLastError();
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
        }
    }
            
    LeaveCriticalSection(&g_FwLock);

    return dwError;
} // FwpOpenLogFile


VOID
WINAPI
FwpPacketDroppedCallback(
    PEVENT_TRACE pEvent
    )

/*++

Routine Description:

    This routine is called to process a dropped packet event.

Arguments:

    pEvent - pointer to the event structure

Return Value:

    none.

--*/

{
    PMSIPNAT_PacketDroppedEvent pEventData;
    FILETIME ftUtcTime;
    SYSTEMTIME stLocalTime;
    CHAR szSrcAddress[16];
    CHAR szDstAddress[16];
    int cch;
    
    EnterCriticalSection(&g_FwFileLock);

    //
    // Get a buffer to write to.
    //

    if (NULL == g_pCurrentBuffer)
    {
        if (NULL == g_pReserveBuffer)
        {
            if (ERROR_SUCCESS != FwpAllocateBuffer(&g_pCurrentBuffer))
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpPacketDroppedCallback: Unable to allocate buffer"
                    );

                //
                // Record the dropped event
                //
                
                g_ulDroppedEventCount += 1;

                LeaveCriticalSection(&g_FwFileLock);
                return;
            }
        }
        else
        {
            g_pCurrentBuffer = g_pReserveBuffer;
            g_pReserveBuffer = NULL;
        }
    }

    ASSERT(NULL != g_pCurrentBuffer);

    //
    // Crack logging data
    //

    pEventData = (PMSIPNAT_PacketDroppedEvent) pEvent->MofData;
    
    ftUtcTime.dwLowDateTime = pEvent->Header.TimeStamp.LowPart;
    ftUtcTime.dwHighDateTime = pEvent->Header.TimeStamp.HighPart;
    FwpConvertUtcFiletimeToLocalSystemtime(&ftUtcTime, &stLocalTime);

    lstrcpyA(szSrcAddress, INET_NTOA(pEventData->SourceAddress)); 
    lstrcpyA(szDstAddress, INET_NTOA(pEventData->DestinationAddress));

    //
    // Write the event data to the buffer
    //

    if (NAT_PROTOCOL_TCP == pEventData->Protocol)
    {
        CHAR szBuffer[10];
        UINT i = 0;

        if (pEventData->ProtocolData4 & TCP_FLAG_SYN)
        {
            szBuffer[i++] = 'S';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_FIN)
        {
            szBuffer[i++] = 'F';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_ACK)
        {
            szBuffer[i++] = 'A';
        }
        
        if (pEventData->ProtocolData4 & TCP_FLAG_RST)
        {
            szBuffer[i++] = 'R';
        }
        
        if (pEventData->ProtocolData4 & TCP_FLAG_URG)
        {
            szBuffer[i++] = 'U';
        }

        if (pEventData->ProtocolData4 & TCP_FLAG_PSH)
        {
            szBuffer[i++] = 'P';
        }

        if (0 == i)
        {
            //
            // No flags on this packet
            //
            
            szBuffer[i++] = '-';
        }

        szBuffer[i] = NULL;
            
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szTcpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                ntohs(pEventData->SourceIdentifier),
                ntohs(pEventData->DestinationIdentifier),
                pEventData->PacketSize,
                szBuffer,
                ntohl(pEventData->ProtocolData1),
                ntohl(pEventData->ProtocolData2),
                ntohs((USHORT)pEventData->ProtocolData3)
                );
                
    }
    else if (NAT_PROTOCOL_UDP == pEventData->Protocol)
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szUdpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                ntohs(pEventData->SourceIdentifier),
                ntohs(pEventData->DestinationIdentifier),
                pEventData->PacketSize
                );
    }
    else if (NAT_PROTOCOL_ICMP == pEventData->Protocol)
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szIcmpPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                szSrcAddress,
                szDstAddress,
                pEventData->PacketSize,
                pEventData->ProtocolData1,
                pEventData->ProtocolData2
                );
    }
    else
    {
        cch =
            _snprintf(
                g_pCurrentBuffer->pChar,
                FW_LOG_BUFFER_REMAINING(g_pCurrentBuffer),
                c_szDroppedPacketFormat,
                stLocalTime.wYear,
                stLocalTime.wMonth,
                stLocalTime.wDay,
                stLocalTime.wHour,
                stLocalTime.wMinute,
                stLocalTime.wSecond,
                pEventData->Protocol,
                szSrcAddress,
                szDstAddress,
                pEventData->PacketSize
                );
    }

    if (cch > 0)
    {
        //
        // Move the buffer pointer to the end of the data we just wrote.
        // If cch were negative, then there wasn't enough room to write
        // then entire entry; by not adjusting the pointer, we essentially
        // drop this event.
        //

        g_pCurrentBuffer->pChar += cch;
    }
    else
    {
        //
        // Record the dropped event
        //
        
        g_ulDroppedEventCount += 1;
    }

    //
    // If there is no current IO, flush the buffer
    //

    if (FALSE == g_fIOPending)
    {
        FwpFlushCurrentBuffer();
    }

    LeaveCriticalSection(&g_FwFileLock);
        
} // FwpPacketDroppedCallback


DWORD
FwpLaunchTraceSession(
    HNET_FW_LOGGING_SETTINGS *pSettings,
    TRACEHANDLE *phSession
    )

/*++

Routine Description:

    This routine is called to start a trace session.

Arguments:

    pSettings - pointer to an fw logging settings structure. Only
                fLogDroppedPackets and fLogConnections are examined,
                and at least one of the two must be true.

    phSession - on success, receives the trace handle for the session

Return Value:

    DWORD -- win32 error code

--*/

{
    DWORD dwError;
    PEVENT_TRACE_PROPERTIES pProperties = NULL;

    PROFILE("FwpLaunchTraceSession");
    ASSERT(NULL != pSettings);
    ASSERT(pSettings->fLogDroppedPackets || pSettings->fLogConnections);
    ASSERT(NULL != phSession);

    do
    {

        //
        // Allocate the tracing properties. We need to include space for
        // the name of the logging session, even though we don't have
        // to copy the string into the properties ourselves
        //

        pProperties = FwpAllocateTraceProperties();

        if (NULL == pProperties)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        //
        // Initialize the trace properties. When events are coming at a
        // low rate (which is expected), there will be at most a 13 second
        // latency for event delivery. During high event rate periods, our
        // memory usage for trace buffering is capped at 60k.
        //

        pProperties->FlushTimer = 13;
        pProperties->BufferSize = 4;
        pProperties->MaximumBuffers = 15;

        //
        // Start the trace
        //
        
        dwError = StartTrace(phSession, c_wszLogSessionName, pProperties);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpLaunchTraceSession: StartTrace = %d",
                dwError
                );
            *phSession = NULL;
            break;
        }

        //
        // Enable the appropriate events
        //

        if (pSettings->fLogDroppedPackets)
        {
            dwError = EnableTrace(
                        TRUE,
                        0,
                        0,
                        &c_PacketDroppedEventGuid,
                        *phSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLaunchTraceSession: EnableTrace (packets) = %d",
                    dwError
                    );

                //
                // Stop the trace
                //

                ControlTrace(
                    *phSession,
                    NULL,
                    pProperties,
                    EVENT_TRACE_CONTROL_STOP
                    );
                *phSession = NULL;
                break;
            }
        }

        if (pSettings->fLogConnections)
        {
            dwError = EnableTrace(
                        TRUE,
                        0,
                        0,
                        &c_ConnectionCreationEventGuid,
                        *phSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLaunchTraceSession: EnableTrace (connections) = %d",
                    dwError
                    );

                //
                // Stop the trace
                //

                ControlTrace(
                    *phSession,
                    NULL,
                    pProperties,
                    EVENT_TRACE_CONTROL_STOP
                    );
                *phSession = NULL;
                break;
            }
        }
    } while (FALSE);

    if (NULL != pProperties)
    {
        HeapFree(GetProcessHeap(), 0, pProperties);
    }
    
    return dwError;
} // FwpLaunchTraceSession


HRESULT
FwpLoadSettings(
    HNET_FW_LOGGING_SETTINGS **ppSettings
    )

/*++

Routine Description:

    This routine is called to retrieve the firewall logging settings.

Arguments:

    ppSettings - receives a pointer to the settings structure on success.
                 The caller is responsible for calling
                 HNetFreeFirewallLoggingSettings on this pointer.

Return Value:

    standard HRESULT

--*/

{
    HRESULT hr = S_OK;
    IHNetCfgMgr *pCfgMgr;
    IHNetFirewallSettings *pFwSettings;

    PROFILE("FwpLoadSettings");
    ASSERT(NULL != ppSettings);

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (SUCCEEDED(hr))
    {
        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetFirewallSettings, &pFwSettings)
                );

        pCfgMgr->Release();

        if (SUCCEEDED(hr))
        {
            hr = pFwSettings->GetFirewallLoggingSettings(ppSettings);

            pFwSettings->Release();

            if (SUCCEEDED(hr))
            {
                //
                // Make sure that the minimum file size is at least 1024 bytes.
                //

                if ((*ppSettings)->ulMaxFileSize < 1024)
                {
                    (*ppSettings)->ulMaxFileSize = 1024;
                }
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpLoadSettings: GetFirewallLoggingSettings = 0x%08x",
                    hr
                    );
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpLoadSettings: QueryInterface = 0x%08x",
                hr
                );
        }
    }
    else
    {
        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpLoadSettings: NhGetHNetCfgMgr = 0x%08x",
            hr
            );
    }
    
    return hr;
} // FwpLoadSettings


DWORD
WINAPI
FwpTraceProcessingThreadRoutine(
    LPVOID pvParam
    )

/*++

Routine Description:

    This routine is the entrypoint for our trace processing thread. It
    does the following:
    1) Creates the file that we are logging to
    2) Sets up the trace callback routines
    3) Calls ProcessTrace. This call blocks until the trace session is
       finished (i.e,, FwStopLogging is called)

Arguments:

    pvParam - unused

Return Value:

    DWORD - Win32 error code

--*/

{
    TRACEHANDLE hTraceSession;
    EVENT_TRACE_LOGFILE LogFile;
    BOOLEAN fNewFile;
    DWORD dwError;
    BOOL fSucceeded;
    ULONG ulKernelEventsLostAtShutdown;

    PROFILE("FwpTraceProcessingThreadRoutine");

    EnterCriticalSection(&g_FwFileLock);

    ASSERT(INVALID_HANDLE_VALUE == g_hFile);
    ASSERT(0 == g_dwFileOffset);
    ASSERT(NULL == g_pCurrentBuffer);
    ASSERT(NULL == g_pReserveBuffer);
    ASSERT(FALSE == g_fIOPending);
    ASSERT(NULL == g_hIOEvent);
    ASSERT(0 == g_ulDroppedEventCount);
    ASSERT(NULL == g_hDroppedEventTimer);
    ASSERT(0 == g_ulKernelEventsLost);

    do
    {
        //
        // Create/Open the logfile.
        //

        dwError = FwpOpenLogFile(&g_hFile, &fNewFile);

        if (ERROR_SUCCESS != dwError) break;

        //
        // Allocate the initial working buffer
        //

        dwError = FwpAllocateBuffer(&g_pCurrentBuffer);
        if (ERROR_SUCCESS != dwError)
        {
            LeaveCriticalSection(&g_FwFileLock);

            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingRoutine: Unable to allocate buffer"
                );
                
            break;
        }

        if (fNewFile)
        {
            //
            // Write the log header
            //

            g_dwFileOffset = 0;
            dwError = FwpWriteLogHeaderToBuffer(g_pCurrentBuffer);

            if (ERROR_SUCCESS == dwError)
            {
                FwpFlushCurrentBuffer();
            }
            else
            {
                //
                // Even though we failed in writing the header, we'll still
                // try to log as much as possible
                //
                
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessinRoutine: FwpWriteLogHeaderToBuffer = %d",
                    dwError
                    );
            }
        }
        else
        {
            //
            // Find the end-of-file position
            //

            g_dwFileOffset = GetFileSize(g_hFile, NULL);

            if ((DWORD)-1 == g_dwFileOffset)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwpTraceProcessingRoutine: GetFileSize = %d",
                    GetLastError()
                    );

                LeaveCriticalSection(&g_FwFileLock);
                break;
            }
        }

        //
        // Launch our dropped event timer. When this timer fires,
        // the callback routine will check if any events have
        // been dropped (both in kernel mode and user mode),
        // and, if so, log that fact.
        //

        fSucceeded =
            CreateTimerQueueTimer(
                &g_hDroppedEventTimer,
                NULL,
                FwpDroppedEventTimerRoutine,
                NULL,
                0,
                1000 * 60 * 5, // 5 minutes
                0
                );

        if (FALSE == fSucceeded)
        {
            //
            // Even though we weren't able to create the timer,
            // we'll still try to log as much as possible.
            //
            
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessinRoutine: CreateTimerQueueTimer = %d",
                GetLastError()
                );
        }

        LeaveCriticalSection(&g_FwFileLock);

        //
        // Register our callback routines. We will attempt to continue
        // even if errors occur here.
        //

        dwError = SetTraceCallback(
                    &c_PacketDroppedEventGuid,
                    FwpPacketDroppedCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (packets dropped) = %d",
                dwError
                );
        }

        dwError = SetTraceCallback(
                    &c_ConnectionCreationEventGuid,
                    FwpConnectionCreationCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (connection creation) = %d",
                dwError
                );
        }

        dwError = SetTraceCallback(
                    &c_ConnectionDeletionEventGuid,
                    FwpConnectionDeletionCallback
                    );

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: SetTraceCallback (connection deletion) = %d",
                dwError
                );
        }

        //
        // Open the trace stream
        //

        ZeroMemory(&LogFile, sizeof(LogFile));
        LogFile.LoggerName = c_wszLogSessionName;
        LogFile.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;

        hTraceSession = OpenTrace(&LogFile);
        
        if ((TRACEHANDLE)INVALID_HANDLE_VALUE == hTraceSession)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: OpenTrace = %d",
                GetLastError()
                );

            break;
        }

        //
        // Start processing the trace stream. This call will block until
        // the trace session is closed (i.e., FwStopLogging is called).
        //

        dwError = ProcessTrace(&hTraceSession, 1, NULL, NULL);

        NhTrace(
            TRACE_FLAG_FWLOG,
            "FwpTraceProcessingThreadRoutine: ProcessTrace = %d",
            dwError
            );

        dwError = CloseTrace(hTraceSession);

        if (ERROR_SUCCESS != dwError)
        {
            NhTrace(
                TRACE_FLAG_FWLOG,
                "FwpTraceProcessingThreadRoutine: CloseTrace = %d",
                dwError
                );
        }
            
    } while (FALSE);

    //
    // Make sure that all dropped events are properly logged
    //

    EnterCriticalSection(&g_FwLock);
    ulKernelEventsLostAtShutdown = g_ulKernelEventsLostAtShutdown;
    LeaveCriticalSection(&g_FwLock);

    //
    // Since we're shutting down, we pass in the number of lost kernel
    // events. This will prevent the timer routine from attempting to
    // query the stopped trace session
    //

    FwpDroppedEventTimerRoutine((PVOID)&ulKernelEventsLostAtShutdown, FALSE);

    //
    // Cleanup tracing thread resources
    //

    FwpCleanupTraceThreadResources();

    return dwError;
} // FwpTraceProcessingThreadRoutine


DWORD
FwpWriteLogHeaderToBuffer(
    PFW_LOG_BUFFER pBuffer
    )

/*++

Routine Description:

    Writes the log file header to the passed in buffer

Arguments:

    pBuffer - the buffer to write the header to.

Return Value:

    DWORD - Win32 error

--*/

{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwHeaderSize;
    
    ASSERT(NULL != pBuffer);

    dwHeaderSize = lstrlenA(c_szLogFileHeader);

    if (FW_LOG_BUFFER_REMAINING(pBuffer) < dwHeaderSize)
    {
        dwError = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        RtlCopyMemory(pBuffer->pChar, c_szLogFileHeader, dwHeaderSize);
        pBuffer->pChar += dwHeaderSize;
    }

    return dwError;    
} // FwpWriteLogHeaderToBuffer


VOID
FwStartLogging(
    VOID
    )

/*++

Routine Description:

    This routine is called to start logging operations (depending on
    the current logging settings). It is safe to call this routine when
    logging has already started.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr = S_OK;
    DWORD dwError;
    
    PROFILE("FwStartLogging");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    g_fTracingActive = TRUE;

    if (NULL == g_pSettings)
    {
        hr = FwpLoadSettings(&g_pSettings);
    }

    if (SUCCEEDED(hr))
    {
        if ((g_pSettings->fLogDroppedPackets || g_pSettings->fLogConnections)
            && NULL == g_hSession)
        {
            ASSERT(NULL == g_hThread);

            //
            // Start the tracing session
            //

            dwError = FwpLaunchTraceSession(g_pSettings, &g_hSession);

            if (ERROR_SUCCESS == dwError)
            {
                //
                // Launch the trace processing thread. We're not using
                // any thread-specific crt routines (e.g., strtok) so
                // there's no need to call __beginthreadex
                //

                g_hThread = CreateThread(
                                NULL,       // SD
                                0,          // stack size
                                FwpTraceProcessingThreadRoutine,
                                NULL,       // thread argument
                                0,          // flags
                                NULL        // thread ID
                                );

                if (NULL == g_hThread)
                {
                    NhTrace(
                        TRACE_FLAG_FWLOG,
                        "FwStartLogging: CreateThread = %d",
                        GetLastError()
                        );

                    LeaveCriticalSection(&g_FwLock);
                    FwStopLogging();
                    return;
                }               
            }
        }
    }

    LeaveCriticalSection(&g_FwLock);
} // FwStartLogging


VOID
FwStopLogging(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop logging operations. It is safe to call
    this routine when logging is stopped.

Arguments:

    none.

Return Value:

    none.

Environment:

    The caller must not hold g_FwFileLock or g_FwLock.

--*/

{
    DWORD dwError;
    PEVENT_TRACE_PROPERTIES pProperties;
    
    PROFILE("FwStopLogging");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    g_fTracingActive = FALSE;

    //
    // Stop the trace session if it is currently active
    //

    if (NULL != g_hSession)
    {
        pProperties = FwpAllocateTraceProperties();

        if (NULL != pProperties)
        {
            dwError = ControlTrace(
                        g_hSession,
                        0,
                        pProperties,
                        EVENT_TRACE_CONTROL_STOP
                        );

            if (ERROR_SUCCESS == dwError)
            {
                g_hSession = NULL;
                g_ulKernelEventsLostAtShutdown = pProperties->EventsLost;

                if (NULL != g_hThread)
                {
                    HANDLE hThread;
                    
                    //
                    // Wait for thread to exit
                    //

                    hThread = g_hThread;

                    LeaveCriticalSection(&g_FwLock);

                    dwError = WaitForSingleObject(hThread, 45 * 1000);

                    if (WAIT_TIMEOUT == dwError)
                    {
                        NhTrace(
                            TRACE_FLAG_FWLOG,
                            "FwStopLogging: Timeout waiting for thread"
                            );
                            
                        //
                        // The logging thread still hasn't exited; kill
                        // it hard and make sure that all resources are
                        // properly freed...
                        //

                        EnterCriticalSection(&g_FwFileLock);
                        EnterCriticalSection(&g_FwLock);

                        //
                        // TerminateThread is a very dangerous call. However,
                        // since we control the thread we're about to kill,
                        // we can guarantee that this will be safe. In
                        // particular, since we hold both critical sections,
                        // there is no danger of them being orphaned, or of
                        // any of our global data being in an inconsistent
                        // state.
                        //

                        if (!TerminateThread(g_hThread, ERROR_TIMEOUT))
                        {
                            NhTrace(
                                TRACE_FLAG_FWLOG,
                                "FwStopLogging: TerminateThread = %d",
                                GetLastError()
                                );
                        }

                        LeaveCriticalSection(&g_FwLock);
                        LeaveCriticalSection(&g_FwFileLock);

                        //
                        // Cleanup thread resources. It is safe to call this
                        // routine multiple times.
                        //

                        FwpCleanupTraceThreadResources();
  
                    }
                    else if (WAIT_OBJECT_0 != dwError)
                    {
                        NhTrace(
                            TRACE_FLAG_FWLOG,
                            "FwStopLogging: wait for thread = %d/%d",
                            dwError,
                            GetLastError()
                            );
                    }

                    EnterCriticalSection(&g_FwLock);

                    if (NULL != g_hThread)
                    {
                        CloseHandle(g_hThread);
                    }
                    
                    g_hThread = NULL;
                }

                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwStopLogging: Stopped w/ %d events and %d buffers lost",
                    pProperties->EventsLost,
                    pProperties->RealTimeBuffersLost
                    );

                g_ulKernelEventsLostAtShutdown = 0;
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwStopLogging: ControlTrace = %d",
                    dwError
                    );

                //
                // Since the trace session has not yet been stopped,
                // we leave g_hSession unchanged.
                //
            }

            HeapFree(GetProcessHeap(), 0, pProperties);
        }
    }

    LeaveCriticalSection(&g_FwLock);
} // FwStopLogging


VOID
FwUpdateLoggingSettings(
    VOID
    )

/*++

Routine Description:

    This routine is called to notify the logging subsystem that the
    logging settings have changed.

Arguments:

    none.

Return Value:

    none.

--*/

{
    HRESULT hr;
    HNET_FW_LOGGING_SETTINGS *pSettings;
    DWORD dwError;

    PROFILE("FwUpdateLoggingSettings");
    ASSERT(FwInitialized == FwpModuleState);

    EnterCriticalSection(&g_FwLock);

    do
    {
        if (FALSE == g_fTracingActive)
        {
            //
            // Since tracing is not currently active, there is no
            // need to retrieve the current settings. Furthermore, free
            // any stored settings that we might have so that stale
            // settings are not used.
            //

            if (g_pSettings)
            {
                HNetFreeFirewallLoggingSettings(g_pSettings);
                g_pSettings = NULL;
            }

            break;
        }

        //
        // Obtain the current settings
        //

        hr = FwpLoadSettings(&pSettings);

        if (FAILED(hr))
        {
            break;
        }

        if (NULL == g_pSettings)
        {
            //
            // Since we don't have any cached settings (previous failure
            // in FwpLoadSettings?) simply store what we just retrieved
            // and call FwStartLogging.
            //

            g_pSettings = pSettings;
            FwStartLogging();
            break;
        }

        if (NULL == g_hSession)
        {
            //
            // There is no log session at the moment. Free the old settings,
            // store the new ones, and call FwStartLogging.
            //

            ASSERT(NULL == g_hThread);

            HNetFreeFirewallLoggingSettings(g_pSettings);
            g_pSettings = pSettings;

            FwStartLogging();
            break;
        }

        //
        // Compare the settings to see what, if anything, has changed
        //

        if (wcscmp(g_pSettings->pszwPath, pSettings->pszwPath))
        {
            //
            // Our log file has changed -- we need to stop and restart
            // everything so that logging is properly moved to the
            // new file.
            //

            LeaveCriticalSection(&g_FwLock);
            FwStopLogging();
            EnterCriticalSection(&g_FwLock);

            if (NULL != g_pSettings)
            {
                HNetFreeFirewallLoggingSettings(g_pSettings);
            }
            
            g_pSettings = pSettings;

            FwStartLogging();
            break;
        }

        //
        // Only possible changes are to enabled events
        //

        if (!!g_pSettings->fLogDroppedPackets
            != !!pSettings->fLogDroppedPackets)
        {
            dwError = EnableTrace(
                        pSettings->fLogDroppedPackets,
                        0,
                        0,
                        &c_PacketDroppedEventGuid,
                        g_hSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwUpdateLoggingSettings: EnableTrace (packets) = %d",
                    dwError
                    );
            }
        }

        if (!!g_pSettings->fLogConnections
            != !!pSettings->fLogConnections)
        {
            dwError = EnableTrace(
                        pSettings->fLogConnections,
                        0,
                        0,
                        &c_ConnectionCreationEventGuid,
                        g_hSession
                        );

            if (ERROR_SUCCESS != dwError)
            {
                NhTrace(
                    TRACE_FLAG_FWLOG,
                    "FwUpdateLoggingSettings: EnableTrace (connections) = %d",
                    dwError
                    );
            }
        }

        //
        // Free old settings and store new
        //

        HNetFreeFirewallLoggingSettings(g_pSettings);
        g_pSettings = pSettings;
        
    } while (FALSE);

    LeaveCriticalSection(&g_FwLock);
    
} // FwUpdateLoggingSettings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\natarp.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natarp.h

Abstract:

    This module contains declarations for the NAT's user-mode proxy-ARP
    entry management. Proxy-ARP entries are installed on dedicated interfaces
    which have address-translation enabled.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#ifndef _NATHLP_NATARP_H_
#define _NATHLP_NATARP_H_

struct _NAT_INTERFACE;

VOID
NatUpdateProxyArp(
    struct _NAT_INTERFACE* Interfacep,
    BOOLEAN AddEntries
    );

#endif // _NATHLP_NATARP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\natarp.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natarp.c

Abstract:

    This module contains code for the NAT's user-mode proxy-ARP entry
    management. Proxy-ARP entries are installed on dedicated interfaces
    which have address-translation enabled.

Author:

    Abolade Gbadegesin (aboladeg)   20-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// FORWARD DECLARATIONS
//

VOID
NatpCreateProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );

VOID
NatpDeleteProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    );


VOID
NatpCreateProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to remove a proxy-ARP entry.

Arguments:

    Address - the address to remove

    Mask - the mask associated with 'Address'

    Context - context-field holding the entry's interface

Return Value:

    none.

--*/

{
    ULONG Error;
    DEFINE_MIB_BUFFER(Info, MIB_PROXYARP, Entry);
    PROFILE("NatpCreateProxyArpCallback");
    //
    // Install an entry for the range, unless the host-portion is 1 bit wide,
    // in which case the range consists only of an all-zeroes and all-ones host.
    // The stack will refuse to answer ARP queries for either one,
    // so adding such a range would be a waste.
    //
    Info->dwId = PROXY_ARP;
    if (~Mask != 1) {
        Entry->dwAddress = (Address & Mask);
        Entry->dwMask = Mask;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        Error =
            NatSupportFunctions.MIBEntryCreate(
                IPRTRMGR_PID,
                MIB_INFO_SIZE(MIB_PROXYARP),
                Info
                );
        if (Error) {
            CHAR MaskString[16];
            lstrcpyA(MaskString, INET_NTOA(Mask));
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpCreateProxyArpCallback: error %d adding %s/%s",
                Error, INET_NTOA(Address), MaskString
                );
            NhInformationLog(
                IP_NAT_LOG_UPDATE_ARP_FAILED,
                Error,
                "%I%I",
                Address,
                Mask
                );
        }
    }
    //
    // If the mask is not all-ones, also install entries for the all-zeroes
    // and all-ones host-portions of the range; otherwise IP will refuse
    // to answer ARP queries for these.
    //
    if (~Mask) {
        Entry->dwAddress = (Address & Mask);
        Entry->dwMask = 0xffffffff;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryCreate(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Info
            );
        Entry->dwAddress = (Address | ~Mask);
        Entry->dwMask = 0xffffffff;
        Entry->dwIfIndex = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryCreate(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Info
            );
    }

} // NatpCreateProxyArpCallback


VOID
NatpDeleteProxyArpCallback(
    ULONG Address,
    ULONG Mask,
    PVOID Context
    )

/*++

Routine Description:

    This routine is invoked to remove a proxy-ARP entry.

Arguments:

    Address - the address to remove

    Mask - the mask associated with 'Address'

    Context - context-field holding the entry's interface

Return Value:

    none.

--*/

{
    BYTE Buffer[FIELD_OFFSET(MIB_OPAQUE_QUERY, rgdwVarIndex) + 3*sizeof(DWORD)];
    ULONG Error;
    PMIB_OPAQUE_QUERY Query = (PMIB_OPAQUE_QUERY)Buffer;
    PROFILE("NatpDeleteProxyArpCallback");
    Query->dwVarId = PROXY_ARP;
    Query->rgdwVarIndex[0] = (Address & Mask);
    Query->rgdwVarIndex[1] = Mask;
    Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
    Error =
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
    if (Error) {
        CHAR MaskString[16];
        lstrcpyA(MaskString, INET_NTOA(Mask));
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpDeleteProxyArpCallback: error %d deleting %s/%s",
            Error, INET_NTOA(Address), MaskString
            );
        NhInformationLog(
            IP_NAT_LOG_UPDATE_ARP_FAILED,
            Error,
            "%I%I",
            Address,
            Mask
            );
    }
    //
    // If the mask is not all-ones, also remove the entries for the all-zeroes
    // and all-ones host-portions of the range.
    //
    if (~Mask) {
        Query->rgdwVarIndex[0] = (Address & Mask);
        Query->rgdwVarIndex[1] = 0xffffffff;
        Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
        Query->rgdwVarIndex[0] = (Address | ~Mask);
        Query->rgdwVarIndex[1] = 0xffffffff;
        Query->rgdwVarIndex[2] = ((PNAT_INTERFACE)Context)->Index;
        NatSupportFunctions.MIBEntryDelete(
            IPRTRMGR_PID,
            MIB_INFO_SIZE(MIB_PROXYARP),
            Buffer
            );
    }

} // NatpDeleteProxyArpCallback


VOID
NatUpdateProxyArp(
    PNAT_INTERFACE Interfacep,
    BOOLEAN CreateEntries
    )

/*++

Routine Description:

    This routine is invoked to install or remove the proxy-ARP entries
    corresponding to the address-ranges configured on the given interface.

Arguments:

    Interfacep - the interface on which to operate

    CreateEntries - TRUE to install entries, FALSE to remove

Return Value:

    none.

Environment:

    Invoked with the interface list locked by the caller.

--*/

{
    ULONG Count;
    ULONG Error;
    ULONG i;
    PIP_NAT_ADDRESS_RANGE Range;

    PROFILE("NatUpdateProxyArp");

    if (!Interfacep->Info ||
        !NatSupportFunctions.MIBEntryCreate ||
        !NatSupportFunctions.MIBEntryDelete
        ) {
        return;
    }

    //
    // Locate the address-ranges, if any
    //

    Error =
        MprInfoBlockFind(
            &Interfacep->Info->Header,
            IP_NAT_ADDRESS_RANGE_TYPE,
            NULL,
            &Count,
            (PUCHAR*)&Range
            );
    if (Error || NULL == Range) { return; }

    //
    // Now go through the ranges, decomposing each one
    //

    for (i = 0; i < Count; i++) {
        DecomposeRange(
            Range[i].StartAddress,
            Range[i].EndAddress,
            MostGeneralMask(Range[i].StartAddress, Range[i].EndAddress),
            CreateEntries
                ? NatpCreateProxyArpCallback : NatpDeleteProxyArpCallback,
            Interfacep
            );
    }

} // NatUpdateProxyArp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\cudpbcast.h ===
/*++

Copyright (c) 2001, Microsoft Corporation

Module Name:

    cudpbcast.h

Abstract:

    Declarations for CUdpBroadcastMapper -- support for mapping
    a public UDP port to the private network's broadcast address.

Author:

    Jonathan Burstein (jonburs)     12 April 2001

Revision History:

--*/

#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#include "udpbcast.h"

class CUdpBroadcast
{
public:
    LIST_ENTRY Link;
    USHORT usPublicPort;
    DWORD dwInterfaceIndex;
    ULONG ulDestinationAddress;
    HANDLE hDynamicRedirect;

    CUdpBroadcast(
        USHORT usPublicPort,
        DWORD dwInterfaceIndex,
        ULONG ulDestinationAddress
        )
    {
        InitializeListHead(&Link);
        this->usPublicPort = usPublicPort;
        this->dwInterfaceIndex = dwInterfaceIndex;
        this->ulDestinationAddress = ulDestinationAddress;
        hDynamicRedirect = NULL;
    };
};

class ATL_NO_VTABLE CUdpBroadcastMapper :
    public CComObjectRootEx<CComMultiThreadModel>,
    public IUdpBroadcastMapper
{
protected:

    //
    // The list of UDP Broadcast Mappings
    //

    LIST_ENTRY m_MappingList;

    //
    // Our UDP listening socket, to which the received
    // UDP packets on the public side will be redirected,
    // and the port of that socket
    //

    SOCKET m_hsUdpListen;
    USHORT m_usUdpListenPort;

    //
    // Our raw UDP socket, used to send the constructed
    // broadcast packet to the private network
    //

    SOCKET m_hsUdpRaw;

    //
    // Handle to the NAT
    //

    HANDLE m_hNat;

    //
    // Pointer to the NAT's component reference (needed
    // for asynch. socket routines
    //

    PCOMPONENT_REFERENCE m_pCompRef;

    //
    // Tracks whether or not we've been shutdown.
    //

    BOOL m_fActive;

    //
    // Tracks whether or not we've posted a read buffer.
    //

    BOOL m_fReadStarted;

    //
    // IP Identifier. This number has no intrinsic meaning --
    // it exists only so we don't send out ever packet w/
    // 0 in this field. Thread safety does not matter when
    //

    USHORT m_usIpId;

public:

    BEGIN_COM_MAP(CUdpBroadcastMapper)
        COM_INTERFACE_ENTRY(IUdpBroadcastMapper)
    END_COM_MAP()

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    //
    // Inline Constructor
    //

    CUdpBroadcastMapper()
    {
        InitializeListHead(&m_MappingList);
        m_hsUdpListen = INVALID_SOCKET;
        m_hsUdpRaw = INVALID_SOCKET;
        m_hNat = NULL;
        m_pCompRef = NULL;
        m_fActive = TRUE;
        m_fReadStarted = FALSE;
        m_usIpId = 0;
    };

    //
    // ATL Methods
    //

    HRESULT
    FinalConstruct();

    HRESULT
    FinalRelease();

    //
    // Initialization
    //

    HRESULT
    Initialize(
        PCOMPONENT_REFERENCE pComponentReference
        );

    //
    // IUdpBroadcastMapper methods
    //

    STDMETHODIMP
    CreateUdpBroadcastMapping(
        USHORT usPublicPort,
        DWORD dwPublicInterfaceIndex,
        ULONG ulDestinationAddress,
        VOID **ppvCookie
        );

    STDMETHODIMP
    CancelUdpBroadcastMapping(
        VOID *pvCookie
        );

    STDMETHODIMP
    Shutdown();

protected:

    BOOL
    Active()
    {
        return m_fActive;
    };

    CUdpBroadcast*
    LookupMapping(
        USHORT usPublicPort,
        DWORD dwInterfaceIndex,
        PLIST_ENTRY *ppInsertionPoint
        );

    HRESULT
    StartUdpRead();

    static
    VOID
    UdpReadCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );

    VOID
    ProcessUdpRead(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );    

    HRESULT
    BuildAndSendRawUdpPacket(
        ULONG ulDestinationAddress,
        USHORT usDestinationPort,
        PNH_BUFFER pPacketData
        );

    static
    VOID
    RawWriteCompletionRoutine(
        ULONG ulError,
        ULONG ulBytesTransferred,
        PNH_BUFFER pBuffer
        );

};

#include <packon.h>

typedef struct _IP_HEADER {
    UCHAR VersionAndHeaderLength;
    UCHAR TypeOfService;
    USHORT TotalLength;
    USHORT Identification;
    USHORT OffsetAndFlags;
    UCHAR TimeToLive;
    UCHAR Protocol;
    USHORT Checksum;
    ULONG SourceAddress;
    ULONG DestinationAddress;
} IP_HEADER, *PIP_HEADER;

typedef struct _UDP_HEADER {
    USHORT SourcePort;
    USHORT DestinationPort;
    USHORT Length;
    USHORT Checksum;
} UDP_HEADER, *PUDP_HEADER;

#include <packoff.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\natconn.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natconn.c

Abstract:

    This module contains code for the NAT's RAS connection management.
    This includes
    * code to support 'shared-access', in which a RAS client-connection
        serves as the NAT public network.
    * code to support 'on-demand dialing', in which a routing-failure
        results in our attempting to establish a dialup connection
        with the help of the autodial service.

Author:

    Abolade Gbadegesin (aboladeg)   2-May-1998

Revision History:

    Jonathan Burstein (jonburs)     6-July-2000
    Updated to new config APIs

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <dnsapi.h>
#include "beacon.h"

//
// EXTERNAL DECLARATIONS
//

extern "C"
ULONG APIENTRY
RasGetEntryHrasconnW(
    LPCWSTR Phonebook,
    LPCWSTR EntryName,
    LPHRASCONN Hrasconn
    );

extern "C"
ULONG
SetIpForwardEntryToStack(
    PMIB_IPFORWARDROW IpForwardRow
    );

extern "C"
ULONG
NhpAllocateAndGetInterfaceInfoFromStack(
    IP_INTERFACE_NAME_INFO** Table,
    PULONG Count,
    BOOL SortOutput,
    HANDLE AllocationHeap,
    ULONG AllocationFlags
    );

//
// Notifications
//

HANDLE NatConfigurationChangedEvent = NULL;
HANDLE NatpConfigurationChangedWaitHandle = NULL;
HANDLE NatConnectionNotifyEvent = NULL;
HANDLE NatpConnectionNotifyWaitHandle = NULL;
HANDLE NatpEnableRouterEvent = NULL;
OVERLAPPED NatpEnableRouterOverlapped;
HANDLE NatpEnableRouterWaitHandle = NULL;
IO_STATUS_BLOCK NatpRoutingFailureIoStatus;
IP_NAT_ROUTING_FAILURE_NOTIFICATION NatpRoutingFailureNotification;


//
// Connection information
//

LIST_ENTRY NatpConnectionList = {NULL, NULL};
ULONG NatpFirewallConnectionCount = 0;
BOOLEAN NatpSharedConnectionPresent = FALSE;
PCHAR NatpSharedConnectionDomainName = NULL;
LONG NatpNextInterfaceIndex = 1;

#define INADDR_LOOPBACK_NO 0x0100007f   // 127.0.0.1 in network order

//
// FORWARD DECLARATIONS
//

HRESULT
NatpAddConnectionEntry(
    IUnknown *pUnk
    );

ULONG
NatpBindConnection(
    PNAT_CONNECTION_ENTRY pConEntry,
    HRASCONN Hrasconn,
    ULONG AdapterIndex OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo OPTIONAL
    );

HRESULT
NatpBuildPortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO pBindingInfo
    );

VOID NTAPI
NatpConfigurationChangedCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
NatpConnectionNotifyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID NTAPI
NatpEnableRouterCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    );

VOID
NatpFreeConnectionEntry(
    PNAT_CONNECTION_ENTRY pConEntry
    );

VOID
NatpFreePortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry
    );

PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );

ULONG
NatpQueryConnectionAdapter(
    ULONG Index
    );

PIP_NAT_INTERFACE_INFO
NatpQueryConnectionInformation(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    );

VOID
NatpProcessConfigurationChanged(
    VOID
    );

VOID
NatpProcessConnectionNotify(
    VOID
    );

VOID NTAPI
NatpRoutingFailureCallbackRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    );

VOID NTAPI
NatpRoutingFailureWorkerRoutine(
    PVOID Context
    );

ULONG
NatpStartSharedConnectionManagement(
    VOID
    );

ULONG
NatpStopSharedConnectionManagement(
    VOID
    );

VOID
NatpUpdateSharedConnectionDomainName(
    ULONG AdapterIndex
    );

BOOLEAN
NatpUnbindConnection(
    PNAT_CONNECTION_ENTRY pConEntry
    );


PNAT_CONNECTION_ENTRY
NatFindConnectionEntry(
    GUID *pGuid
    )

/*++

Routine Description:

    Locates a connection entry by guid

Arguments:

    pGuid - identifies the connection to locate
    
Return Value:

    PNAT_CONNECTION_ENTRY - a pointer to the connection, or NULL
        if not found
    
Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PNAT_CONNECTION_ENTRY pConnection;
    PLIST_ENTRY pLink;

    for (pLink = NatpConnectionList.Flink;
         pLink != &NatpConnectionList;
         pLink = pLink->Flink)
    {
        pConnection = CONTAINING_RECORD(pLink, NAT_CONNECTION_ENTRY, Link);
        if (IsEqualGUID(pConnection->Guid, *pGuid))
        {
            return pConnection;
        }
    }

    return NULL;
} // NatFindConnectionEntry


PNAT_PORT_MAPPING_ENTRY
NatFindPortMappingEntry(
    PNAT_CONNECTION_ENTRY pConnection,
    GUID *pGuid
    )

/*++

Routine Description:

    Locates a port mapping entry for a connection
    
Arguments:

    pConnection - the connection to search 
    
    pGuid - identifies the port mapping entry to locate
    
Return Value:

    PNAT_PORT_MAPPING_ENTRY - a pointer to the port mapping, or NULL
        if not found
    
Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PNAT_PORT_MAPPING_ENTRY pMapping;
    PLIST_ENTRY pLink;

    for (pLink = pConnection->PortMappingList.Flink;
         pLink != &pConnection->PortMappingList;
         pLink = pLink->Flink)
    {
        pMapping = CONTAINING_RECORD(pLink, NAT_PORT_MAPPING_ENTRY, Link);
        if (IsEqualGUID(*pMapping->pProtocolGuid, *pGuid))
        {
            return pMapping;
        }
    }

    return NULL;
} // NatFindPortMappingEntry


VOID
NatFreePortMappingEntry(
    PNAT_PORT_MAPPING_ENTRY pEntry
    )

/*++

Routine Description:

    Frees all resources associated with a port mapping entry. This
    entry must have already been removed from the containing port
    mapping list and destroyed at the kernel / UDP broadcast mapper
    level.

Arguments:

    pEntry - the entry to free

Return Value:

    none.

--*/

{
    ASSERT(NULL != pEntry);
    
    if (NULL != pEntry->pProtocolGuid)
    {
        CoTaskMemFree(pEntry->pProtocolGuid);
    }

    if (NULL != pEntry->pProtocol)
    {
        pEntry->pProtocol->Release();
    }

    if (NULL != pEntry->pBinding)
    {
        pEntry->pBinding->Release();
    }

    NH_FREE(pEntry);
} // NatFreePortMappingEntry


HRESULT
NatpAddConnectionEntry(
    IUnknown *pUnk
    )

/*++

Routine Description:

    Creates a NAT_CONNECTION_ENTRY for a firewalled or Ics public connection.

Arguments:

    pUnk - pointer to an IHNetFirewalledConnection or IHNetIcsPublicConnection.
           This need not be the canonical IUnknown (i.e., it's fine to pass in a
           pointer of either of the above interfaces).

Return Value:

    Standard HRESULT

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    HRESULT hr = S_OK;
    PNAT_CONNECTION_ENTRY pNewEntry = NULL;
    IHNetConnection *pNetCon = NULL;

    //
    // Allocate new entry stucture
    //

    pNewEntry = reinterpret_cast<PNAT_CONNECTION_ENTRY>(
                    NH_ALLOCATE(sizeof(*pNewEntry))
                    );

    if (NULL != pNewEntry)
    {
        RtlZeroMemory(pNewEntry, sizeof(*pNewEntry));
        InitializeListHead(&pNewEntry->Link);
        InitializeListHead(&pNewEntry->PortMappingList);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Get IHNetConnection interface
    //

    if (S_OK == hr)
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IHNetConnection, &pNetCon));

        if (SUCCEEDED(hr))
        {
            pNewEntry->pHNetConnection = pNetCon;
            pNewEntry->pHNetConnection->AddRef();

            HNET_CONN_PROPERTIES *pProps;

            //
            // Get the properties for the connection
            //

            hr = pNetCon->GetProperties(&pProps);

            if (SUCCEEDED(hr))
            {
                //
                // Copy properties into entry
                //

                RtlCopyMemory(
                    &pNewEntry->HNetProperties,
                    pProps,
                    sizeof(*pProps)
                    );

                CoTaskMemFree(pProps);
            }
        }

        if (SUCCEEDED(hr))
        {
            GUID *pGuid;

            //
            // Get the guid of the connectoin
            //

            hr = pNetCon->GetGuid(&pGuid);

            if (SUCCEEDED(hr))
            {
                RtlCopyMemory(&pNewEntry->Guid, pGuid, sizeof(GUID));
                CoTaskMemFree(pGuid);
            }
        }

        if (SUCCEEDED(hr) && !pNewEntry->HNetProperties.fLanConnection)
        {
            //
            // Get the RAS phonebook path. We don't cache the
            // name since that can change over time.
            //

            hr = pNetCon->GetRasPhonebookPath(
                    &pNewEntry->wszPhonebookPath
                    );
        }
    }

    if (SUCCEEDED(hr) && pNewEntry->HNetProperties.fFirewalled)
    {
        //
        // Get the firewall control interface
        //

        hr = pNetCon->GetControlInterface(
                IID_PPV_ARG(IHNetFirewalledConnection, &pNewEntry->pHNetFwConnection)
                );

        if (SUCCEEDED(hr))
        {
            NatpFirewallConnectionCount += 1;
        }
    }

    if (SUCCEEDED(hr) && pNewEntry->HNetProperties.fIcsPublic)
    {
        //
        // Get the ICS public control interface
        //

        hr = pNetCon->GetControlInterface(
                IID_PPV_ARG(IHNetIcsPublicConnection, &pNewEntry->pHNetIcsPublicConnection)
                );

        if (SUCCEEDED(hr))
        {
            //
            // Remember that we now have a shared connection
            //

            NatpSharedConnectionPresent = TRUE;
        }
    }

    if (NULL != pNetCon)
    {
        pNetCon->Release();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Add the new entry to the connection list. Ordering doesn't matter.
        //

        InsertTailList(&NatpConnectionList, &pNewEntry->Link);
    }
    else if (NULL != pNewEntry)
    {
        //
        // Cleanup the partially constructed entry
        //

        NatpFreeConnectionEntry(pNewEntry);
    }

    return hr;
}


ULONG
NatpBindConnection(
    PNAT_CONNECTION_ENTRY pConEntry,
    HRASCONN Hrasconn,
    ULONG AdapterIndex,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is responsible for binding the shared-connection.

Arguments:

    pConEntry - the entry to bind

    Hrasconn - if the connection is a dialup connection,
        contains the handle for the active RAS connection.

    AdapterIndex - if the connection is a LAN connection,
        contains the adapter index for the active LAN connection.

    BindingInfo - if the connection is a LAN connection,
        contains the binding information for the active LAN interface.

Return Value:

    ULONG - Win32 error.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    ULONG Error;
    MIB_IPFORWARDROW IpForwardRow;
    GUID Guid;
    RASPPPIPA RasPppIp;
    ULONG Size;
    PLIST_ENTRY InsertionPoint;
    PLIST_ENTRY Link;
    PNAT_PORT_MAPPING_ENTRY PortMapping;
    HRESULT hr;


    if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
        return NO_ERROR;
    }

    //
    // LAN public interfaces are handled differently than RAS public interfaces.
    // With a LAN interface, the binding information is passed in from
    // 'NatpProcessConnectionNotify'.
    // With a RAS inteface, though, we retrieve the projection-information
    // for the active connection, and map the address to an adapter index.
    //

    if (!pConEntry->HNetProperties.fLanConnection) {

        //
        // Allocate space for the binding info, if this has not yet
        // occured. (This memory will be freed in NatpFreeConnectionEntry.)
        //

        if (NULL == pConEntry->pBindingInfo) {
            
            pConEntry->pBindingInfo =
                reinterpret_cast<PIP_ADAPTER_BINDING_INFO>(
                    NH_ALLOCATE(
                        FIELD_OFFSET(IP_ADAPTER_BINDING_INFO, Address)
                        + sizeof(IP_LOCAL_BINDING)
                        )
                    );

            if (NULL == pConEntry->pBindingInfo) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpBindConnection: Unable to allocate binding info"
                    );
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // Retrieve the PPP projection information for the interface.
        //

        ZeroMemory(&RasPppIp, sizeof(RasPppIp));
        Size = RasPppIp.dwSize = sizeof(RasPppIp);
        Error =
            RasGetProjectionInfoA(
                Hrasconn,
                RASP_PppIp,
                &RasPppIp,
                &Size
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpBindConnection: RasGetProjectionInfoA=%d",
                Error
                );
            return Error;
        }

        //
        // Convert the projection information to our format
        //

        BindingInfo = pConEntry->pBindingInfo;
        BindingInfo->AddressCount = 1;
        BindingInfo->RemoteAddress = 0;
        BindingInfo->Address[0].Address = inet_addr(RasPppIp.szIpAddress);
        BindingInfo->Address[0].Mask = 0xffffffff;

        //
        // Attempt to find the TCP/IP adapter index for the connection
        //

        AdapterIndex = NhMapAddressToAdapter(BindingInfo->Address[0].Address);
        if (AdapterIndex == (ULONG)-1) {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpBindConnection: MapAddressToAdapter failed"
                );
            return ERROR_NO_SUCH_INTERFACE;
        }

        //
        // Install a default route through the interface, if this is
        // the shared connection. (We don't want to do this for a
        // firewall-only connection.)
        //

        if (pConEntry->HNetProperties.fIcsPublic) {
            ZeroMemory(&IpForwardRow, sizeof(IpForwardRow));
            IpForwardRow.dwForwardNextHop =
                BindingInfo->Address[0].Address;
            IpForwardRow.dwForwardIfIndex = AdapterIndex;
            IpForwardRow.dwForwardType = MIB_IPROUTE_TYPE_DIRECT;
            IpForwardRow.dwForwardProto = PROTO_IP_NAT;
            IpForwardRow.dwForwardMetric1 = 1;

            Error = SetIpForwardEntryToStack(&IpForwardRow);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpBindConnection: SetIpForwardEntryToStack=%d",
                    Error
                    );
                return Error;
            }
        }
    }

    pConEntry->AdapterIndex = AdapterIndex;

    //
    // Make sure the interface type is correct.
    //

    pConEntry->Interface.Type = ROUTER_IF_TYPE_INTERNAL;

    //
    // Set the interface index value. This can be anything except 0
    // (as 0 is reserved for the private connection).
    //

    do
    {
        pConEntry->Interface.Index =
            static_cast<ULONG>(InterlockedIncrement(&NatpNextInterfaceIndex));
    } while (0 == pConEntry->Interface.Index);

    //
    // Build the port mapping list for this connection
    //

    hr = NatpBuildPortMappingList(pConEntry, BindingInfo);
    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection: NatpBuildPortMappingList=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Bind the interface, building its configuration to include
    // any port-mappings configured as part of shared access settings.
    //

    pConEntry->Interface.Info =
        NatpQueryConnectionInformation(pConEntry, BindingInfo);

    if (NULL == pConEntry->Interface.Info) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection[%i]: NatpQueryConnectionInformation failed",
            pConEntry->Interface.Index
            );

        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);
        
        return ERROR_CAN_NOT_COMPLETE;
    }

    Error =
        NatBindInterface(
            pConEntry->Interface.Index,
            &pConEntry->Interface,
            BindingInfo,
            AdapterIndex
            );

    if (Error) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBindConnection[%i]: NatBindInterface=%d",
            pConEntry->Interface.Index,
            Error
            );

        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);

        return Error;
    }

    //
    // At this point NAT_INTERFACE_FLAG_BOUND has been set on the
    // interface, so we don't need to clean up the port mapping
    // list on error, as the list will be cleaned up in
    // NatpUnbindConnection.
    //

    //
    // Create UDP broadcast mappings if this is the ICS
    // public connection.
    //

    if (pConEntry->HNetProperties.fIcsPublic
        && 0 != pConEntry->UdpBroadcastPortMappingCount)
    {
        DWORD dwAddress;
        DWORD dwMask;
        DWORD dwBroadcastAddress;

        ASSERT(NULL != NhpUdpBroadcastMapper);
        ASSERT(!IsListEmpty(&pConEntry->PortMappingList));

        if (NhQueryScopeInformation(&dwAddress, &dwMask))
        {
            dwBroadcastAddress = (dwAddress & dwMask) | ~dwMask;
            
            for (Link = pConEntry->PortMappingList.Flink;
                 Link != &pConEntry->PortMappingList;
                 Link = Link->Flink)
            {
                PortMapping =
                    CONTAINING_RECORD(Link, NAT_PORT_MAPPING_ENTRY, Link);

                if (!PortMapping->fUdpBroadcastMapping) { continue; }

                hr = NhpUdpBroadcastMapper->CreateUdpBroadcastMapping(
                        PortMapping->usPublicPort,
                        AdapterIndex,
                        dwBroadcastAddress,
                        &PortMapping->pvBroadcastCookie
                        );

                if (FAILED(hr))
                {
                    //
                    // We'll continue if an error occurs here.
                    //
                    
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NatpBindConnection: CreateUdpBroadcastMapping=0x%08x",
                        hr
                        );
                }
            }
        }
    }

    //
    // Make sure that the interface is on the global list (so that the
    // FTP, ALG, and H.323 proxies will be able to find its configuration).
    //

    if (!NatpLookupInterface(
            pConEntry->Interface.Index,
            &InsertionPoint
            )) {
        InsertTailList(InsertionPoint, &pConEntry->Interface.Link);
    }

#ifndef NO_FTP_PROXY
    //
    // Add the interface the the FTP proxy, if this has not yet
    // happened.
    //

    if (!NAT_INTERFACE_ADDED_FTP(&pConEntry->Interface)) {
        Error =
            FtpRmAddInterface(
                NULL,
                pConEntry->Interface.Index,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NatpBindConnection: FtpRmAddInterface=%d",
                Error
                );
            return Error;
        }

        pConEntry->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_FTP;
    }

    //
    // Bind and enable the interface for FTP
    //

    Error = FtpRmBindInterface(pConEntry->Interface.Index, BindingInfo);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: FtpRmBindInterface=%d",
            Error
            );
        return Error;
    }

    Error = FtpRmEnableInterface(pConEntry->Interface.Index);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: FtpRmEnableInterface=%d",
            Error
            );
        return Error;
    }
#endif

    //
    // Add the interface the the ALG proxy, if this has not yet
    // happened.
    //

    if (!NAT_INTERFACE_ADDED_ALG(&pConEntry->Interface)) {
        Error =
            AlgRmAddInterface(
                NULL,
                pConEntry->Interface.Index,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NatpBindConnection: AlgRmAddInterface=%d",
                Error
                );
            return Error;
        }

        pConEntry->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_ALG;
    }

    //
    // Bind and enable the interface for ALG
    //

    Error = AlgRmBindInterface(pConEntry->Interface.Index, BindingInfo);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: AlgRmBindInterface=%d",
            Error
            );
        return Error;
    }

    Error = AlgRmEnableInterface(pConEntry->Interface.Index);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: AlgRmEnableInterface=%d",
            Error
            );
        return Error;
    }

    //
    // Add the interface the the H.323 proxy, if this has not yet
    // happened.
    //

    if (!NAT_INTERFACE_ADDED_H323(&pConEntry->Interface)) {
        Error =
            H323RmAddInterface(
                NULL,
                pConEntry->Interface.Index,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NatpBindConnection: H323RmAddInterface=%d",
                Error
                );
            return Error;
        }

        pConEntry->Interface.Flags |= NAT_INTERFACE_FLAG_ADDED_H323;
    }

    //
    // Bind and enable the interface for H323
    //

    Error = H323RmBindInterface(pConEntry->Interface.Index, BindingInfo);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: H323RmBindInterface=%d",
            Error
            );
        return Error;
    }

    Error = H323RmEnableInterface(pConEntry->Interface.Index);
    if (Error) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatpBindConnection: H323RmEnableInterface=%d",
            Error
            );
        return Error;
    }

    if (pConEntry->HNetProperties.fIcsPublic) {

        //
        // Finally, update the DNS domain name cached for the shared connection.
        //

        NatpUpdateSharedConnectionDomainName(AdapterIndex);
    }

    return NO_ERROR;
} // NatpBindConnection


HRESULT
NatpBuildPortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO pBindingInfo
    )

/*++

Routine Description:

    Builds the list of port mappings for a connection entry

Arguments:

    pConEntry - the entry to build the list for

    pBindingInfo - the binding info for that entry

Return Value:

    Standard HRESULT.

Environment:

    NatInterfaceLock must be held by the caller.
    
--*/

{
    HRESULT hr;
    IHNetPortMappingBinding *pBinding;
    PNAT_PORT_MAPPING_ENTRY pEntry;
    IEnumHNetPortMappingBindings *pEnum;
    PLIST_ENTRY pLink;
    IHNetPortMappingProtocol *pProtocol;
    ULONG ulCount;
    
    PROFILE("NatpBuildPortMappingList");

    hr = pConEntry->pHNetConnection->EnumPortMappings(TRUE, &pEnum);

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpBuildPortMappingList: EnumPortMappings 0x%08x",
            hr
            );

        return hr;
    }

    //
    // Process enumeration, creating the port mapping entries.
    //

    do
    {
        hr = pEnum->Next(1, &pBinding, &ulCount);

        if (SUCCEEDED(hr) && 1 == ulCount)
        {
            pEntry =
                reinterpret_cast<PNAT_PORT_MAPPING_ENTRY>(
                    NH_ALLOCATE(sizeof(*pEntry))
                    );

            if (NULL != pEntry)
            {
                ZeroMemory(pEntry, sizeof(*pEntry));
                
                //
                // Get the protocol for the binding
                //

                hr = pBinding->GetProtocol(&pProtocol);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (SUCCEEDED(hr))
            {
                //
                // Fill out the entry
                //

                hr = pProtocol->GetGuid(&pEntry->pProtocolGuid);

                if (SUCCEEDED(hr))
                {
                    hr = pProtocol->GetIPProtocol(&pEntry->ucProtocol);
                }

                if (SUCCEEDED(hr))
                {
                    hr = pProtocol->GetPort(&pEntry->usPublicPort);
                }

                if (SUCCEEDED(hr))
                {
                    hr = pBinding->GetTargetPort(&pEntry->usPrivatePort);
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // We need to know if the name is active in order to
                    // avoid rebuilding the DHCP reservation list more
                    // than necessary.
                    //
                    
                    hr = pBinding->GetCurrentMethod(&pEntry->fNameActive);
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // If this is a FW-only connection, use the address from
                    // our binding info instead of the protocol binding.
                    //

                    if (!pConEntry->HNetProperties.fIcsPublic)
                    {
                        pEntry->ulPrivateAddress =
                            pBindingInfo->Address[0].Address;
                    }
                    else
                    {
                        hr = pBinding->GetTargetComputerAddress(
                                &pEntry->ulPrivateAddress
                                );

                        if (SUCCEEDED(hr)
                            && INADDR_LOOPBACK_NO == pEntry->ulPrivateAddress)
                        {
                            //
                            // If the port mapping targets the loopback address
                            // we want to use the address from the binding
                            // info instead.
                            //
                            
                            pEntry->ulPrivateAddress =
                                pBindingInfo->Address[0].Address;
                        }

                    }
                }

                if (SUCCEEDED(hr))
                {
                    pEntry->pBinding = pBinding;
                    pEntry->pBinding->AddRef();
                    pEntry->pProtocol = pProtocol;
                    pEntry->pProtocol->AddRef();

                        //
                        // Check to see if this mapping is:
                        // 1) targeted at the broadcast address, and
                        // 2) is UDP.
                        //

                    if (NAT_PROTOCOL_UDP == pEntry->ucProtocol
                        && 0xffffffff == pEntry->ulPrivateAddress)
                    {
                        pEntry->fUdpBroadcastMapping = TRUE;
                        pConEntry->UdpBroadcastPortMappingCount += 1;
                    }
                    else
                    {
                        pConEntry->PortMappingCount += 1;
                    }

                    InsertTailList(&pConEntry->PortMappingList, &pEntry->Link);
                }
                else
                {
                    NatFreePortMappingEntry(pEntry);
                }

                pProtocol->Release();
            }

            //
            // If anything failed above we still want to continue operation --
            // it's preferable to have the firewall running w/ some port
            // mapping entries missing instead of not having the firewall
            // run at all.
            //

            hr = S_OK;

            pBinding->Release();
        }
    } while (SUCCEEDED(hr) && 1 == ulCount);

    pEnum->Release();

    if (FAILED(hr))
    {
        //
        // Free the port mapping list
        //

        NatpFreePortMappingList(pConEntry);
    }

    return hr;
}// NatpBuildPortMappingList


VOID NTAPI
NatpConfigurationChangedCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon a change in the NAT/Firewall
    configuration.
    It may also be invoked when cleanup is in progress.

Arguments:

    Context - unused

    TimedOut - unused

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    BOOLEAN ComInitialized = TRUE;
    HRESULT hr;
    PROFILE("NatpConfigurationChangedCallbackRoutine");

    //
    // See whether cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConfigurationChangedEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference to the component (and release
    // our original reference on failure).
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }

    //
    // Make sure the thread is COM-initialized
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (FAILED(hr))
    {
        ComInitialized = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            ASSERT(FALSE);
            hr = S_OK;

            NhTrace(
                TRACE_FLAG_NAT,
                "NatpConfigurationChangedCallbackRoutine: Unexpectedly in STA."
                );
        }
    }

    //
    // Process connection notifications
    //

    if (SUCCEEDED(hr))
    {
        NatpProcessConfigurationChanged();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

    //
    // Release our original reference to the component.
    //
    
    DEREFERENCE_NAT();

} // NatpConfigurationChangedCallbackRoutine



VOID NTAPI
NatpConnectionNotifyCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon connection or disconnection
    of a RAS phonebook entry.
    It may also be invoked when cleanup is in progress.

Arguments:

    Context - unused

    TimedOut - unused

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    BOOLEAN ComInitialized = TRUE;
    HRESULT hr;
    PROFILE("NatpConnectionNotifyCallbackRoutine");

    //
    // See whether cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference to the component (and release
    // our original reference on failure).
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }

    //
    // Make sure the thread is COM-initialized
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
    if (FAILED(hr))
    {
        ComInitialized = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            ASSERT(FALSE);
            hr = S_OK;

            NhTrace(
                TRACE_FLAG_NAT,
                "NatpConnectionNotifyCallbackRoutine: Unexpectedly in STA."
                );
        }
    }

    //
    // Process connection notifications
    //

    if (SUCCEEDED(hr))
    {
        NatpProcessConnectionNotify();
    }

    //
    // Uninitialize COM, if necessary
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }

    //
    // Release our original reference to the component.
    //
    
    DEREFERENCE_NAT();

} // NatpConnectionNotifyCallbackRoutine


VOID NTAPI
NatpEnableRouterCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked upon completion or cancellation of an outstanding
    request to enable IP forwarding. It determines whether the module is still
    running and, if so, re-enables forwarding. Otherwise, it cancels any
    existing request and returns control immediately.

Arguments:

    none used.

Return Value:

    none.

Environment:

    The routine runs in the context of an Rtl wait-thread.
    (See 'RtlRegisterWait'.)
    A reference to the component will have been made on our behalf
    when 'RtlRegisterWait' was called. The reference is released
    and re-acquired here.

--*/

{
    ULONG Error;
    HANDLE UnusedHandle;
    PROFILE("NatpEnableRouterCallbackRoutine");

    //
    // See whether cleanup has occurred and, if so, restore forwarding
    // to its original setting. Otherwise, acquire a new reference to the
    // component, and release the original reference.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatpEnableRouterEvent || !REFERENCE_NAT()) {
        UnenableRouter(&NatpEnableRouterOverlapped, NULL);
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }

    DEREFERENCE_NAT();

    //
    // Re-enable forwarding
    //

    ZeroMemory(&NatpEnableRouterOverlapped, sizeof(OVERLAPPED));
    NatpEnableRouterOverlapped.hEvent = NatpEnableRouterEvent;
    Error = EnableRouter(&UnusedHandle, &NatpEnableRouterOverlapped);
    if (Error != ERROR_IO_PENDING) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatpEnableRouterCallbackRoutine: EnableRouter=%d", Error
            );
    }
    LeaveCriticalSection(&NatInterfaceLock);
} // NatpEnableRouterCallbackRoutine


VOID
NatpFreeConnectionEntry(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    Frees all resources associated with a connection entry. This entry
    must have already been removed from the connection list.

Arguments:

    pConEntry - the entry to free

Return Value:

    none.

--*/

{
    PROFILE("NatpFreeConnectionEntry");

    if (NULL != pConEntry->pInterfaceInfo)
    {
        NH_FREE(pConEntry->pInterfaceInfo);
    }

    if (NULL != pConEntry->pBindingInfo)
    {
        NH_FREE(pConEntry->pBindingInfo);
    }

    if (NULL != pConEntry->pHNetConnection)
    {
        pConEntry->pHNetConnection->Release();
    }

    if (NULL != pConEntry->pHNetFwConnection)
    {
        pConEntry->pHNetFwConnection->Release();
    }

    if (NULL != pConEntry->pHNetIcsPublicConnection)
    {
        pConEntry->pHNetIcsPublicConnection->Release();
    }

    if (NULL != pConEntry->wszPhonebookPath)
    {
        CoTaskMemFree(pConEntry->wszPhonebookPath);
    }

    NatpFreePortMappingList(pConEntry);

    NH_FREE(pConEntry);

} // NatpFreeConnectionEntry


VOID
NatpFreePortMappingList(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    Frees the port mapping list for a connection entry. This
    includes cancelling any active UDP broadcast mappings.

Arguments:

    pConEntry - the entry to free

Return Value:

    none.

Environment:

    Invoked w/ NatInterfaceLock held by the caller

--*/

{
    PLIST_ENTRY pLink;
    PNAT_PORT_MAPPING_ENTRY pMapping;
    
    while (!IsListEmpty(&pConEntry->PortMappingList))
    {   
        pLink = RemoveHeadList(&pConEntry->PortMappingList);
        pMapping = CONTAINING_RECORD(pLink, NAT_PORT_MAPPING_ENTRY, Link);

        if (pMapping->fUdpBroadcastMapping &&
            NULL != pMapping->pvBroadcastCookie)
        {
            ASSERT(NULL != NhpUdpBroadcastMapper);
            NhpUdpBroadcastMapper->CancelUdpBroadcastMapping(
                pMapping->pvBroadcastCookie
                );
        }
        
        NatFreePortMappingEntry(pMapping);
    }

    pConEntry->PortMappingCount = 0;
    pConEntry->UdpBroadcastPortMappingCount = 0;
} // NatpFreePortMappingList


VOID
NatpProcessConfigurationChanged(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to see when the NAT/Firewall configuration
    changes. It unbinds the old interfaces, and binds the new ones.
    It is also responsible for making sure that the autodial service
    is running.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr = NULL;
    IHNetFirewallSettings *pFwSettings;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetFirewalledConnections *pFwEnum;
    IHNetFirewalledConnection *pFwConn;
    IEnumHNetIcsPublicConnections *pIcsEnum;
    IHNetIcsPublicConnection *pIcsConn;
    ULONG ulCount;
    UNICODE_STRING UnicodeString;

    PROFILE("NatpProcessConfigurationChanged");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Start by deleting all of our current connections
    //

    while (!IsListEmpty(&NatpConnectionList))
    {
        Link = RemoveHeadList(&NatpConnectionList);
        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

        NatpUnbindConnection(pConEntry);
        NatpFreeConnectionEntry(pConEntry);
    }

    //
    // Reset other items to initial state
    //

    NatpFirewallConnectionCount = 0;
    NatpSharedConnectionPresent = FALSE;
    if (NULL != NatpSharedConnectionDomainName)
    {
        NH_FREE(NatpSharedConnectionDomainName);
        NatpSharedConnectionDomainName = NULL;
    }

    //
    // Get the configuration manager
    //

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (NhPolicyAllowsFirewall)
    {
        if (SUCCEEDED(hr))
        {
            //
            // Get the firewall settings interface
            //

            hr = pCfgMgr->QueryInterface(
                    IID_PPV_ARG(IHNetFirewallSettings, &pFwSettings)
                    );
        }

        if (SUCCEEDED(hr))
        {
            //
            // Get the enumeration of firewalled connections
            //

            hr = pFwSettings->EnumFirewalledConnections(&pFwEnum);
            pFwSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            // Process the enumeration
            //

            do
            {
                hr = pFwEnum->Next(1, &pFwConn, &ulCount);

                if (SUCCEEDED(hr) && 1 == ulCount)
                {
                    //
                    // We don't check the return code for NatpAddConnectionEntry.
                    // NatpAddConnectionEntry will clean up gracefully if an
                    // error occurs and will leave the system in a consistent
                    // state, so an error will not prevent us from processing
                    // the rest of the connections.
                    //
                    
                    NatpAddConnectionEntry(pFwConn);
                    pFwConn->Release();
                }
            }
            while (SUCCEEDED(hr) && 1 == ulCount);

            pFwEnum->Release();
        }
    }

    //
    // If we don't yet have a shared connection (i.e., none of the
    // firewalled connections were also IcsPublic), retrieve that
    // enumeration now.
    //

    if (FALSE == NatpSharedConnectionPresent
        && NULL != pCfgMgr
        && NhPolicyAllowsSharing)
    {
        //
        // Get the IcsSettings interface
        //

        hr = pCfgMgr->QueryInterface(
                IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings)
                );

        if (SUCCEEDED(hr))
        {
            //
            // Get the enumeration of ICS public connections
            //

            hr = pIcsSettings->EnumIcsPublicConnections(&pIcsEnum);
            pIcsSettings->Release();
        }

        if (SUCCEEDED(hr))
        {
            //
            // See if we can get a connection out of the enum
            //

            hr = pIcsEnum->Next(1, &pIcsConn, &ulCount);

            if (SUCCEEDED(hr) && 1 == ulCount)
            {
                //
                // We don't check the return code for NatpAddConnectionEntry.
                // NatpAddConnectionEntry will clean up gracefully if an
                // error occurs and will leave the system in a consistent
                // state, so an error will not prevent us from processing
                // the rest of the connections.
                //
                
                NatpAddConnectionEntry(pIcsConn);
                pIcsConn->Release();
            }

            pIcsEnum->Release();
        }
    }

    if (TRUE == NatpSharedConnectionPresent && NhPolicyAllowsSharing)
    {
        //
        // Make sure shared connection management is started
        //

        NatpStartSharedConnectionManagement();
    }
    else
    {
        //
        // Stop shared connection management
        //

        NatpStopSharedConnectionManagement();
    }

    //
    // Notify the firewall subsystem as to whether it needs to
    // start or stop logging. (These calls are effectively no-ops if
    // the logger is already in the correct state.)
    //

    if (NatpFirewallConnectionCount > 0 && NhPolicyAllowsFirewall)
    {
        FwStartLogging();
    }
    else
    {
        FwStopLogging();
    }

    //
    // Bind connections
    //

    NatpProcessConnectionNotify();

    if (NULL != pCfgMgr)
    {
        pCfgMgr->Release();
    }

    LeaveCriticalSection(&NatInterfaceLock);

} // NatpProcessConfigurationChanged


VOID
NatpProcessConnectionNotify(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to see if the shared or firewall connections,
    if any, have been connected or disconnected since its last invocation.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    BOOLEAN Active;
    ULONG i;
    ULONG AdapterIndex;
    PIP_ADAPTER_BINDING_INFO BindingInfo = NULL;
    ULONG Error;
    HRASCONN Hrasconn;
    GUID Guid;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;

    BOOLEAN bUPnPEventAlreadyFired = FALSE;

    PROFILE("NatpProcessConnectionNotify");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Walk through the connection list
    //

    for (Link = NatpConnectionList.Flink;
         Link != &NatpConnectionList;
         Link = Link->Flink)
    {

        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

        //
        // If the connection is a LAN connection,
        // it is always active.
        //
        // If the connection is a dialup connection,
        // find out whether the connection is active.
        //


        if (pConEntry->HNetProperties.fLanConnection) {
            Hrasconn = NULL;
            Active = TRUE;

            //
            // The connection is a LAN connection, so we need to detect
            // any changes to its IP address if it is already bound.
            // To do so we retrieve the current binding information
            // and compare it to the active binding information.
            // If the two are different, we unbind the interface and rebind.
            //

            Status =
                RtlStringFromGUID(pConEntry->Guid, &UnicodeString);
            if (NT_SUCCESS(Status)) {
                AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
                RtlFreeUnicodeString(&UnicodeString);
            } else {
                AdapterIndex = (ULONG)-1;
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpProcessConnectionNotify: RtlStringFromGUID failed\n"
                    );
            }
            if (AdapterIndex == (ULONG)-1) {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatpProcessConnectionNotify: MapGuidToAdapter failed\n"
                    );
                Active = FALSE;
            } else {

                BindingInfo = NhQueryBindingInformation(AdapterIndex);
                if (!BindingInfo) {
                    NhTrace(
                        TRACE_FLAG_NAT,
                        "NatpProcessConnectionNotify: QueryBinding failed\n"
                        );
                    Active = FALSE;
                } else if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {

                    //
                    // The interface is already bound;
                    // compare the retrieved binding to the active binding,
                    // and unbind the connection if they are different.
                    //

                    if (!pConEntry->pBindingInfo ||
                        BindingInfo->AddressCount !=
                        pConEntry->pBindingInfo->AddressCount ||
                        !BindingInfo->AddressCount ||
                        !RtlEqualMemory(
                            &BindingInfo->Address[0],
                            &pConEntry->pBindingInfo->Address[0],
                            sizeof(IP_LOCAL_BINDING)
                            )) {
                        NatpUnbindConnection(pConEntry);

                        if ( pConEntry->HNetProperties.fIcsPublic )
                        {
                           FireNATEvent_PublicIPAddressChanged();
                           bUPnPEventAlreadyFired = TRUE;                       
                        }
                    } else {

                        //
                        // The bindings are the same, and the interface is bound
                        // already, so we won't be needing the newly-retrieved
                        // binding information.
                        //

                        NH_FREE(BindingInfo);
                        BindingInfo = NULL;
                    }
                }
            }
        } else {
            AdapterIndex = (ULONG)-1;
            Hrasconn = NULL;
            
            //
            // Obtain the name of the connection
            //

            HRESULT hr;
            LPWSTR wszEntryName;         

            hr = pConEntry->pHNetConnection->GetName(&wszEntryName);

            if (SUCCEEDED(hr)) {
                Error =
                    RasGetEntryHrasconnW(
                        pConEntry->wszPhonebookPath,
                        wszEntryName,
                        &Hrasconn
                        );
                        
                CoTaskMemFree(wszEntryName);
            }
            
            Active = ((FAILED(hr) || Error || !Hrasconn) ? FALSE : TRUE);

        }

        //
        // Activate or deactivate the shared-connection as needed;
        // when activating a LAN connection, we save the binding information
        // so we can detect address changes later on.
        //

        if (!Active && NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
            NatpUnbindConnection(pConEntry);
            if (pConEntry->HNetProperties.fIcsPublic && 
                (FALSE == bUPnPEventAlreadyFired))
            {
                FireNATEvent_PublicIPAddressChanged();
            }
        } else if (Active && !NAT_INTERFACE_BOUND(&pConEntry->Interface)) {

            //
            // N.B. When a media-sense event occurs and TCP/IP revokes the IP
            // address for a LAN connection, the connection's IP address becomes
            // 0.0.0.0. We treat that as though we don't have an IP address at all,
            // and bypass the binding below. When the IP address is reinstated,
            // we will rebind correctly, since we will then detect the change.
            //

            if (pConEntry->HNetProperties.fLanConnection) {
                if (BindingInfo->AddressCount != 1 ||
                    BindingInfo->Address[0].Address) {
                    NatpBindConnection(pConEntry, Hrasconn, AdapterIndex, BindingInfo);
                }
                if (pConEntry->pBindingInfo) {
                    NH_FREE(pConEntry->pBindingInfo);
                }
                pConEntry->pBindingInfo = BindingInfo;
            } else {
                NatpBindConnection(pConEntry, Hrasconn, AdapterIndex, BindingInfo);
            }
            
            if ( pConEntry->HNetProperties.fIcsPublic &&
                 (FALSE == bUPnPEventAlreadyFired) && 
                 NAT_INTERFACE_BOUND(&pConEntry->Interface))
            {
                FireNATEvent_PublicIPAddressChanged();
            }

        }
    }

    //
    // If we have a shared connection, also need to update the private interface
    //

    if (NatpSharedConnectionPresent) {
        NhUpdatePrivateInterface();
    }

    LeaveCriticalSection(&NatInterfaceLock);

} // NatpProcessConnectionNotify


ULONG
NatpQueryConnectionAdapter(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    This routine is invoked to determine the adapter index corresponding
    to a connection, if active.

Arguments:

    pConEntry - the connection entry

Return Value:

    ULONG - the adapter index if found, otherwise (ULONG)-1.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG Error;
    HRASCONN Hrasconn = NULL;
    RASPPPIPA RasPppIp;
    ULONG Size;
    UNICODE_STRING UnicodeString;

    if (pConEntry->HNetProperties.fLanConnection) {
        RtlStringFromGUID(pConEntry->Guid, &UnicodeString);
        AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
        RtlFreeUnicodeString(&UnicodeString);
    } else {
        HRESULT hr;
        LPWSTR wszEntryName;

        hr = pConEntry->pHNetConnection->GetName(&wszEntryName);

        if (SUCCEEDED(hr))
        {
            Error =
                RasGetEntryHrasconnW(
                    pConEntry->wszPhonebookPath,
                    wszEntryName,
                    &Hrasconn
                    );
            if (!Error && Hrasconn) {
                ZeroMemory(&RasPppIp, sizeof(RasPppIp));
                Size = RasPppIp.dwSize = sizeof(RasPppIp);
                Error =
                    RasGetProjectionInfoA(
                        Hrasconn,
                        RASP_PppIp,
                        &RasPppIp,
                        &Size
                        );
                if (!Error) {
                    AdapterIndex =
                        NhMapAddressToAdapter(inet_addr(RasPppIp.szIpAddress));
                }
            }

            CoTaskMemFree(wszEntryName);
        }
    }
    NhTrace(TRACE_FLAG_NAT, "NatpQueryConnectionAdapter: %d", AdapterIndex);
    return AdapterIndex;
} // NatpQueryConnectionAdapter


PIP_NAT_INTERFACE_INFO
NatpQueryConnectionInformation(
    PNAT_CONNECTION_ENTRY pConEntry,
    PIP_ADAPTER_BINDING_INFO BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to construct the configuration
    of a connection. The configuration consists of basic settings
    (e.g. interface type and flags) as well as extended information loaded
    from the configuration store (e.g. port mappings).

Arguments:

    pConEntry - the connection entry

    BindingInfo - the binding info for the connection

Return Value:

    PIP_NAT_INTERFACE_INFO - the configuration allocated;
        on error, returns NULL

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    PIP_NAT_PORT_MAPPING Array = NULL;
    ULONG Count = 0;
    ULONG Error;
    PIP_NAT_INTERFACE_INFO Info;
    PRTR_INFO_BLOCK_HEADER Header;
    HRESULT hr;
    ULONG Length;
    PLIST_ENTRY Link;
    PRTR_INFO_BLOCK_HEADER NewHeader;
    PNAT_PORT_MAPPING_ENTRY PortMapping;

    PROFILE("NatpQueryConnectionInformation");

    //
    // Build the port mapping array from the list
    //

    if (pConEntry->PortMappingCount)
    {
        Array =
            reinterpret_cast<PIP_NAT_PORT_MAPPING>(
                NH_ALLOCATE(pConEntry->PortMappingCount * sizeof(IP_NAT_PORT_MAPPING))
                );

        if (NULL == Array)
        {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpQueryConnectionInformation: Unable to allocate array"
                );
            return NULL;
        }

        for (Link = pConEntry->PortMappingList.Flink;
             Link != &pConEntry->PortMappingList;
             Link = Link->Flink)
        {
            PortMapping = CONTAINING_RECORD(Link, NAT_PORT_MAPPING_ENTRY, Link);

            if (PortMapping->fUdpBroadcastMapping) { continue; }

            Array[Count].PublicAddress = IP_NAT_ADDRESS_UNSPECIFIED;
            Array[Count].Protocol = PortMapping->ucProtocol;
            Array[Count].PublicPort = PortMapping->usPublicPort;
            Array[Count].PrivateAddress = PortMapping->ulPrivateAddress;
            Array[Count].PrivatePort = PortMapping->usPrivatePort;

            Count += 1;
        }

        ASSERT(Count == pConEntry->PortMappingCount);     
    }

    //
    // Create an info-block header and add the port-mapping array
    // as the single entry in the info-block.
    // This info-block header will occupy the 'Header' field
    // of the final 'IP_NAT_INTERFACE_INFO'.
    //

    Error = MprInfoCreate(IP_NAT_VERSION, reinterpret_cast<LPVOID*>(&Header));
    if (Error) {
        if (Array) {
            NH_FREE(Array);
        }
        return NULL;
    }

    if (Count) {
        Error =
            MprInfoBlockAdd(
                Header,
                IP_NAT_PORT_MAPPING_TYPE,
                sizeof(IP_NAT_PORT_MAPPING),
                Count,
                (PUCHAR)Array,
                reinterpret_cast<LPVOID*>(&NewHeader)
                );
        MprInfoDelete(Header); NH_FREE(Array); Header = NewHeader;
        if (Error) {
            return NULL;
        }
    } else if (Array) {
        NH_FREE(Array);
    }

    //
    // For firewalled entries, get ICMP settings
    //

    if (pConEntry->HNetProperties.fFirewalled && NhPolicyAllowsFirewall)
    {
        HNET_FW_ICMP_SETTINGS *pIcmpSettings;
        DWORD dwIcmpFlags = 0;

        hr = pConEntry->pHNetConnection->GetIcmpSettings(&pIcmpSettings);

        if (SUCCEEDED(hr))
        {
            if (pIcmpSettings->fAllowOutboundDestinationUnreachable)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_DEST_UNREACH;
            }

            if (pIcmpSettings->fAllowOutboundSourceQuench)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_SOURCE_QUENCH;
            }

            if (pIcmpSettings->fAllowRedirect)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_REDIRECT;
            }

            if (pIcmpSettings->fAllowInboundEchoRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_ECHO;
            }

            if (pIcmpSettings->fAllowInboundRouterRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_ROUTER;
            }

            if (pIcmpSettings->fAllowOutboundTimeExceeded)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_TIME_EXCEEDED;
            }

            if (pIcmpSettings->fAllowOutboundParameterProblem)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_OB_PARAM_PROBLEM;
            }

            if (pIcmpSettings->fAllowInboundTimestampRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_TIMESTAMP;
            }

            if (pIcmpSettings->fAllowInboundMaskRequest)
            {
                dwIcmpFlags |= IP_NAT_ICMP_ALLOW_IB_MASK;
            }

            CoTaskMemFree(pIcmpSettings);

            Error =
                MprInfoBlockAdd(
                    Header,
                    IP_NAT_ICMP_CONFIG_TYPE,
                    sizeof(DWORD),
                    1,
                    (PUCHAR)&dwIcmpFlags,
                    reinterpret_cast<LPVOID*>(&NewHeader)
                    );

            if (NO_ERROR == Error)
            {
                MprInfoDelete(Header);
                Header = NewHeader;
            }
        }
        else
        {
            NhTrace(
                TRACE_FLAG_NAT,
                "NatpQueryConnectionInformation: GetIcmpSettings 0x%08x",
                hr
                );

            //
            // This is a 'soft' error -- we'll still continue even if we
            // couldn't get the ICMP settings, as our default stance
            // is more secure than if any of the flags were set.
            //
        }
    }

    //
    // Allocate an 'IP_NAT_INTERFACE_INFO' which is large enough to hold
    // the info-block header which we've just constructed.
    //

    Length = FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) + Header->Size;
    Info = reinterpret_cast<PIP_NAT_INTERFACE_INFO>(NH_ALLOCATE(Length));

    if (Info)
    {
        RtlZeroMemory(Info, FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header));

        //
        // Set appropriate flags
        //

        if (pConEntry->HNetProperties.fFirewalled && NhPolicyAllowsFirewall)
        {
            Info->Flags |= IP_NAT_INTERFACE_FLAGS_FW;
        }

        if (pConEntry->HNetProperties.fIcsPublic && NhPolicyAllowsSharing)
        {
            Info->Flags |=
                IP_NAT_INTERFACE_FLAGS_BOUNDARY | IP_NAT_INTERFACE_FLAGS_NAPT;
        }

        //
        // Copy the info-block header into the info structure
        //

        RtlCopyMemory(&Info->Header, Header, Header->Size);
    }

    MprInfoDelete(Header);

    return Info;
} // NatpQuerySharedConnectionInformation


VOID NTAPI
NatpRoutingFailureCallbackRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )

/*++

Routine Description:

    This routine is invoked when a routing-failure notification occurs,
    or when the request is cancelled (e.g. because the request's thread exited).

Arguments:

    Context - unused

    IoStatus - contains the status of the operation

    Reserved - unused

Return Value:

    none.

Environment:

    Invoked with a reference made to the component on our behalf.
    That reference is released here, and if notification is re-requested,
    it is re-acquired.

--*/

{
    CHAR DestinationAddress[32];
    ULONG Error;
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;

    PROFILE("NatpRoutingFailureCallbackRoutine");

    //
    // See if cleanup has occurred
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Acquire a new reference, and release the old one
    //

    if (!REFERENCE_NAT()) { DEREFERENCE_NAT(); return; }
    DEREFERENCE_NAT();

    lstrcpyA(
        DestinationAddress,
        inet_ntoa(*(PIN_ADDR)&NatpRoutingFailureNotification.DestinationAddress)
        );
    NhTrace(
        TRACE_FLAG_NAT,
        "NatpRoutingFailureCallbackRoutine: %s->%s",
        inet_ntoa(*(PIN_ADDR)&NatpRoutingFailureNotification.SourceAddress),
        DestinationAddress
        );

    //
    // Request an automatic connection if the notification succeeded
    //

    if (NT_SUCCESS(IoStatus->Status)) {

        //
        // First see if this is a known autodial destination,
        // requesting a connection if so.
        //

        ULONG Count;
        ULONG Size;

        Size = 0;
        Error =
            RasGetAutodialAddressA(
                DestinationAddress,
                NULL,
                NULL,
                &Size,
                &Count
                );
        if (Error != ERROR_BUFFER_TOO_SMALL) {

            //
            // This is not a known destination;
            // try the default shared connection, if any
            //

            NhDialSharedConnection();
        } else {

            //
            // Try initiating a normal autodial connection;
            // normal autodial may yet lead to the shared-connection.
            //

            HINSTANCE Hinstance = LoadLibraryA("RASADHLP.DLL");
            if (Hinstance) {
                BOOL (*WSAttemptAutodialAddr)(PSOCKADDR_IN, INT) =
                    (BOOL (*)(PSOCKADDR_IN, INT))
                        GetProcAddress(
                            Hinstance,
                            "WSAttemptAutodialAddr"
                            );
                if (WSAttemptAutodialAddr) {
                    SOCKADDR_IN SockAddr;
                    SockAddr.sin_family = AF_INET;
                    SockAddr.sin_addr.s_addr =
                        NatpRoutingFailureNotification.DestinationAddress;
                    WSAttemptAutodialAddr(&SockAddr, sizeof(SockAddr));
                }
                FreeLibrary(Hinstance);
            }
        }
    }

    //
    // Submit a new request
    //

    EnterCriticalSection(&NatInterfaceLock);
    RequestNotification.Code = NatRoutingFailureNotification;
    NtDeviceIoControlFile(
        NatFileHandle,
        NULL,
        NatpRoutingFailureCallbackRoutine,
        NULL,
        &NatpRoutingFailureIoStatus,
        IOCTL_IP_NAT_REQUEST_NOTIFICATION,
        (PVOID)&RequestNotification,
        sizeof(RequestNotification),
        &NatpRoutingFailureNotification,
        sizeof(NatpRoutingFailureNotification)
        );
    LeaveCriticalSection(&NatInterfaceLock);

} // NatpRoutingFailureCallbackRoutine


VOID NTAPI
NatpRoutingFailureWorkerRoutine(
    PVOID Context
    )

/*++

Routine Description:

    This routine initiates the notification of routing-failures.

Arguments:

    none used.

Return Value:

    none.

Environment:

    Invoked in the context of an alertable I/O worker thread.

--*/

{
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;
    PROFILE("NatpRoutingFailureWorkerRoutine");

    //
    // Request notification of routing-failures
    //

    EnterCriticalSection(&NatInterfaceLock);
    RequestNotification.Code = NatRoutingFailureNotification;
    NtDeviceIoControlFile(
        NatFileHandle,
        NULL,
        NatpRoutingFailureCallbackRoutine,
        NULL,
        &NatpRoutingFailureIoStatus,
        IOCTL_IP_NAT_REQUEST_NOTIFICATION,
        (PVOID)&RequestNotification,
        sizeof(RequestNotification),
        &NatpRoutingFailureNotification,
        sizeof(NatpRoutingFailureNotification)
        );
    LeaveCriticalSection(&NatInterfaceLock);
} // NatpRoutingFailureWorkerRoutine


ULONG
NatpStartSharedConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to install routing failure-notification, and
    to enable the router

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    BOOL SharedAutoDial;
    NTSTATUS status;

    PROFILE("NatpStartSharedConnectionManagement");

    //
    // See if the user has enabled shared-autodial.
    // If so, make sure the autodial service is running,
    // since it will be needed for performing on-demand dialing.
    //
    // (IHNetIcsSettings::GetAutodialEnabled just calls the RAS api below,
    // which is why we're not getting the information that way right now...)
    //

    if (!RasQuerySharedAutoDial(&SharedAutoDial) && SharedAutoDial) {
        SC_HANDLE ScmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (ScmHandle) {
            SC_HANDLE ServiceHandle =
                OpenService(ScmHandle, TEXT("RasAuto"), SERVICE_ALL_ACCESS);
            if (ServiceHandle) {
                StartService(ServiceHandle, 0, NULL);
                CloseServiceHandle(ServiceHandle);
            }
            CloseServiceHandle(ScmHandle);
        }
    }

    EnterCriticalSection(&NatInterfaceLock);
    if (NatpEnableRouterEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;
    }

    //
    // Acquire a component-reference on behalf of
    // (1) the enable-router callback routine
    // (2) the routing-failure-notification worker routine.
    //

    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        return ERROR_CAN_NOT_COMPLETE;
    } else if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return ERROR_CAN_NOT_COMPLETE;
    }

    do {
        //
        // Start DNS and DHCP modules
        //
        Error = NhStartICSProtocols();
        if (Error) break;

        //
        // Enable IP forwarding:
        // Create an event to be used in the overlapped I/O structure
        // that will be passed to the 'EnableRouter' API routine,
        // set up the overlapped structure, and schedule the request
        // by signalling the event.
        //

        NatpEnableRouterEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatpEnableRouterEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpEnableRouterWaitHandle,
                NatpEnableRouterEvent,
                NatpEnableRouterCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        SetEvent(NatpEnableRouterEvent);

        //
        // Queue a work item in whose context we will make a request
        // for routing-failure notification from the NAT driver.
        // We use a work-item rather than issuing the request directly
        // to avoid having our I/O request cancelled if and when the current
        // (thread pool) thread exits.
        //

        RtlQueueWorkItem(
            NatpRoutingFailureWorkerRoutine,
            NULL,
            WT_EXECUTEINIOTHREAD
            );

        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;

    } while (FALSE);

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }
    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
    }

    LeaveCriticalSection(&NatInterfaceLock);
    DEREFERENCE_NAT();
    DEREFERENCE_NAT();

    return Error;

} // NatpStartSharedConnectionManagement


ULONG
NatpStopSharedConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop the DNS & DHCP modules and also
    to remove the routing failure-notification, and
    to disable the router

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;

    PROFILE("NatpStopSharedConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Stop the DHCP, DNS, QoSWindowAdjustment and Beacon modules
    //
    Error = NhStopICSProtocols();

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }

    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
        NatpEnableRouterCallbackRoutine(NULL, FALSE);
    }

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatpStopSharedConnectionManagement


BOOLEAN
NatpUnbindConnection(
    PNAT_CONNECTION_ENTRY pConEntry
    )

/*++

Routine Description:

    This routine is invoked to unbind a currently-active connection.

Arguments:

    Index - index into the connection array

Return Value:

    TRUE if the entry was previously bound; FALSE otherwise.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{
    LIST_ENTRY *pLink;
    PNAT_PORT_MAPPING_ENTRY pMapping;
    
    PROFILE("NatpUnbindConnection");

    if (NAT_INTERFACE_BOUND(&pConEntry->Interface)) {
        NatUnbindInterface(
            pConEntry->Interface.Index,
            &pConEntry->Interface
            );


#ifndef NO_FTP_PROXY
        if (NAT_INTERFACE_ADDED_FTP(&pConEntry->Interface)) {
            FtpRmDeleteInterface(pConEntry->Interface.Index);
            pConEntry->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_FTP;
        }
#endif
        if (NAT_INTERFACE_ADDED_ALG(&pConEntry->Interface)) {
            AlgRmDeleteInterface(pConEntry->Interface.Index);
            pConEntry->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_ALG;
        }

        if (NAT_INTERFACE_ADDED_H323(&pConEntry->Interface)) {
            H323RmDeleteInterface(pConEntry->Interface.Index);
            pConEntry->Interface.Flags &= ~NAT_INTERFACE_FLAG_ADDED_H323;
        }

        RemoveEntryList(&pConEntry->Interface.Link);
        InitializeListHead(&pConEntry->Interface.Link);

        if (pConEntry->Interface.Info) {
            NH_FREE(pConEntry->Interface.Info);
            pConEntry->Interface.Info = NULL;
        }

        //
        // Clean up the port mapping list
        //

        NatpFreePortMappingList(pConEntry);

        return TRUE;
    }
    return FALSE;
} // NatpUnbindConnection


VOID
NatpUpdateSharedConnectionDomainName(
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is called to update the cached DNS domain name, if any,
    for the shared connection.

Arguments:

    AdapterIndex - the index of the adapter for the shared connection

Return Value:

    none.

--*/

{
    PADAPTER_INFORMATION AdapterInformation;
    ANSI_STRING AnsiString;
    ULONG Count;
    ULONG Error;
    ULONG i;
    PDNS_NETWORK_INFORMATION NetworkInformation = NULL;
    PIP_INTERFACE_NAME_INFO Table = NULL;
    UNICODE_STRING UnicodeString;
    PROFILE("NatpUpdateSharedConnectionDomainName");

    RtlInitAnsiString(&AnsiString, NULL);
    RtlInitUnicodeString(&UnicodeString, NULL);
    EnterCriticalSection(&NatInterfaceLock);
    if (AdapterIndex == (ULONG)-1)
    {
        PLIST_ENTRY Link;
        PNAT_CONNECTION_ENTRY pConEntry;

        //
        // Make sure that the connection list has been initialized; if
        // it hasn't, Flink will be NULL.
        //

        if (!NatpConnectionList.Flink) {
            LeaveCriticalSection(&NatInterfaceLock);
            return;
        }

        //
        // See if we actually have a shared connection
        //

        for (Link = NatpConnectionList.Flink;
             Link != &NatpConnectionList;
             Link = Link->Flink)
        {
            pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);

            if (pConEntry->HNetProperties.fIcsPublic)
            {
                AdapterIndex = NatpQueryConnectionAdapter(pConEntry);
                break;
            }
        }

        if (AdapterIndex == (ULONG)-1) {
            LeaveCriticalSection(&NatInterfaceLock);
            return;
        }
    }

    do {

        //
        // Obtain the GUID for the adapter with the given index,
        // by querying TCP/IP for information on all available interfaces.
        // The GUID will then be used to map the shared connection's adapter
        // to a DNS domain name.
        //

        Error =
            NhpAllocateAndGetInterfaceInfoFromStack(
                &Table, &Count, FALSE, GetProcessHeap(), 0
                );
        if (Error != NO_ERROR) { break; }

        for (i = 0; i < Count && Table[i].Index != AdapterIndex; i++) { }
        if (i >= Count) { Error = ERROR_INTERNAL_ERROR; break; }

        RtlStringFromGUID(Table[i].DeviceGuid, &UnicodeString);
        RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, TRUE);

        //
        // Query the DNS client for the current network parameters,
        // and search through the network parameters to find the entry
        // for the shared-connection's current adapter.
        //

        NetworkInformation = (PDNS_NETWORK_INFORMATION)
                             DnsQueryConfigAlloc(
                                    DnsConfigNetworkInformation,
                                    NULL );
        if (!NetworkInformation) { Error = ERROR_INTERNAL_ERROR; break; }
        for (i = 0; i < NetworkInformation->cAdapterCount; i++) {
            AdapterInformation = NetworkInformation->aAdapterInfoList[i];
            if (lstrcmpiA(
                    AnsiString.Buffer, AdapterInformation->pszAdapterGuidName
                    ) == 0) {
                break;
            }
        }
        if (i >= NetworkInformation->cAdapterCount) {
            Error = ERROR_INTERNAL_ERROR;
            break;
        }

        //
        // 'AdapterInformation' is the entry for the shared-connection's
        // current adapter.
        // Clear the previously-cached string, and read in the new value,
        // if any.
        //

        if (NatpSharedConnectionDomainName) {
            NH_FREE(NatpSharedConnectionDomainName);
            NatpSharedConnectionDomainName = NULL;
        }
        if (AdapterInformation->pszDomain) {
            NatpSharedConnectionDomainName =
                reinterpret_cast<PCHAR>(
                    NH_ALLOCATE(lstrlenA(AdapterInformation->pszDomain) + 1)
                    );
            if (!NatpSharedConnectionDomainName) {
                Error = ERROR_INTERNAL_ERROR;
                break;
            }
            lstrcpyA(
                NatpSharedConnectionDomainName,
                AdapterInformation->pszDomain
                );
        }
        Error = NO_ERROR;

    } while(FALSE);

    if (UnicodeString.Buffer) {
        RtlFreeUnicodeString(&UnicodeString);
    }
    if (AnsiString.Buffer) {
        RtlFreeAnsiString(&AnsiString);
    }
    if (NetworkInformation) {
        DnsFreeConfigStructure(
            NetworkInformation,
            DnsConfigNetworkInformation );
    }
    if (Table) {
        HeapFree(GetProcessHeap(), 0, Table);
    }
    if (Error) {
        if (NatpSharedConnectionDomainName) {
            NH_FREE(NatpSharedConnectionDomainName);
            NatpSharedConnectionDomainName = NULL;
        }
    }

    LeaveCriticalSection(&NatInterfaceLock);
} // NatpUpdateSharedConnectionDomainName


PCHAR
NatQuerySharedConnectionDomainName(
    VOID
    )

/*++

Routine Description:

    This routine is called to retrieve a copy of the DNS domain name
    cached for the shared connection, if available. Otherwise, it returns
    the primary DNS domain name for the local machine.

Arguments:

    none.

Return Value:

    PCHAR - contains the allocated copy of the DNS domain name.

--*/

{
    PCHAR DomainName;
    PROFILE("NatQuerySharedConnectionDomainName");

    //
    // See if there is a cached domain name for the shared connection.
    // If not, refresh the cache. If there is still no domain name,
    // return a copy of the local machine's primary DNS domain name.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!NatpSharedConnectionDomainName) {
        NatpUpdateSharedConnectionDomainName((ULONG)-1);
    }
    if (NatpSharedConnectionDomainName) {
        DomainName =
            reinterpret_cast<PCHAR>(
                NH_ALLOCATE(lstrlenA(NatpSharedConnectionDomainName) + 1)
                );
        if (DomainName) {
            lstrcpyA(DomainName, NatpSharedConnectionDomainName);
        }
    } else {
        PCHAR DnsDomainName = (PCHAR) DnsQueryConfigAlloc(
                                        DnsConfigPrimaryDomainName_A,
                                        NULL );
        if (!DnsDomainName) {
            DomainName = NULL;
        } else {
            DomainName =
                reinterpret_cast<PCHAR>(
                    NH_ALLOCATE(lstrlenA(DnsDomainName) + 1)
                    );
            if (DomainName) {
                lstrcpyA(DomainName, DnsDomainName);
            }
            DnsFreeConfigStructure(
                DnsDomainName,
                DnsConfigPrimaryDomainName_A );
        }
    }
    LeaveCriticalSection(&NatInterfaceLock);
    return DomainName;
} // NatQuerySharedConnectionDomainName


ULONG
NatStartConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is called to install connection change-notification.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    NTSTATUS status;

    PROFILE("NatStartConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);
    if (NatConnectionNotifyEvent) {
        LeaveCriticalSection(&NatInterfaceLock);
        return NO_ERROR;
    }

    //
    // Initialize the connection list
    //

    InitializeListHead(&NatpConnectionList);

    //
    // Acquire a component-reference on behalf of
    // (1) the connection-notification routine
    // (2) the configuration-changed routine
    //

    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        return ERROR_CAN_NOT_COMPLETE;
    }
    if (!REFERENCE_NAT()) {
        LeaveCriticalSection(&NatInterfaceLock);
        DEREFERENCE_NAT();
        return ERROR_CAN_NOT_COMPLETE;
    }

    do {
        //
        // Create the connection-notification event, register a wait
        // on the event, and register for connect and disconnect notification.
        // We expect at least one invocation as a result of this registration,
        // hence the reference made to the NAT module above.
        //

        NatConnectionNotifyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatConnectionNotifyEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpConnectionNotifyWaitHandle,
                NatConnectionNotifyEvent,
                NatpConnectionNotifyCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        Error =
            RasConnectionNotification(
                (HRASCONN)INVALID_HANDLE_VALUE,
                NatConnectionNotifyEvent,
                RASCN_Connection|RASCN_Disconnection
                );
        if (Error) { break; }

        //
        // Create the configuartion-change event and register a wait
        // on the event.
        //

        NatConfigurationChangedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (!NatConfigurationChangedEvent) {
            Error = GetLastError(); break;
        }

        status =
            RtlRegisterWait(
                &NatpConfigurationChangedWaitHandle,
                NatConfigurationChangedEvent,
                NatpConfigurationChangedCallbackRoutine,
                NULL,
                INFINITE,
                0
                );
        if (!NT_SUCCESS(status)) {
            Error = RtlNtStatusToDosError(status); break;
        }

        LeaveCriticalSection(&NatInterfaceLock);

        //
        // Pick up any existing connections, by signalling the configuration
        // change event. We cannot invoke the function directly
        // because it invokes service-control functions to start autodial,
        // and we could currently be running in a service-controller thread.
        //

        NtSetEvent(NatConfigurationChangedEvent, NULL);
        return NO_ERROR;

    } while(FALSE);

    //
    // A failure occurred; perform cleanup
    //

    if (NatpConnectionNotifyWaitHandle) {
        RtlDeregisterWait(NatpConnectionNotifyWaitHandle);
        NatpConnectionNotifyWaitHandle = NULL;
    }
    if (NatConnectionNotifyEvent) {
        CloseHandle(NatConnectionNotifyEvent);
        NatConnectionNotifyEvent = NULL;
    }
    if (NatpConfigurationChangedWaitHandle) {
        RtlDeregisterWait(NatpConfigurationChangedWaitHandle);
        NatpConfigurationChangedWaitHandle = NULL;
    }
    if (NatConfigurationChangedEvent) {
        CloseHandle(NatConfigurationChangedEvent);
        NatConfigurationChangedEvent = NULL;
    }


    LeaveCriticalSection(&NatInterfaceLock);
    DEREFERENCE_NAT();
    DEREFERENCE_NAT();

    return Error;

} // NatStartConnectionManagement


VOID
NatStopConnectionManagement(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the connection-monitoring activity
    initiated by 'NatStartConnectionManagement' above.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked when 'StopProtocol' is received from the IP router-manager.

--*/

{
    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    PROFILE("NatStopConnectionManagement");

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Cleanup the wait-handle and event used to receive notification
    // of RAS connections and disconnections.
    //

    if (NatpConnectionNotifyWaitHandle) {
        RtlDeregisterWait(NatpConnectionNotifyWaitHandle);
        NatpConnectionNotifyWaitHandle = NULL;
    }

    if (NatConnectionNotifyEvent) {
        RasConnectionNotification(
            (HRASCONN)INVALID_HANDLE_VALUE,
            NatConnectionNotifyEvent,
            0
            );
        CloseHandle(NatConnectionNotifyEvent);
        NatConnectionNotifyEvent = NULL;
        NatpConnectionNotifyCallbackRoutine(NULL, FALSE);
    }

    if (NatpEnableRouterWaitHandle) {
        RtlDeregisterWait(NatpEnableRouterWaitHandle);
        NatpEnableRouterWaitHandle = NULL;
    }

    if (NatpEnableRouterEvent) {
        CloseHandle(NatpEnableRouterEvent);
        NatpEnableRouterEvent = NULL;
        NatpEnableRouterCallbackRoutine(NULL, FALSE);
    }

    if (NatpConfigurationChangedWaitHandle) {
        RtlDeregisterWait(NatpConfigurationChangedWaitHandle);
        NatpConfigurationChangedWaitHandle = NULL;
    }

    if (NatConfigurationChangedEvent) {
        CloseHandle(NatConfigurationChangedEvent);
        NatConfigurationChangedEvent = NULL;
        NatpConfigurationChangedCallbackRoutine(NULL, FALSE);
    }

    if (NatpConnectionList.Flink)
    {
        //
        // Make certain that all of our connections are disabled
        //

        NatUnbindAllConnections();

        //
        // Walk through the connection list, freeing all of the entries
        //

        while (!IsListEmpty(&NatpConnectionList))
        {
            Link = RemoveHeadList(&NatpConnectionList);
            pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);
            NatpFreeConnectionEntry(pConEntry);
        }

        //
        // Make sure all ICS protocols are stopped
        //

        NhStopICSProtocols();
    }

    //
    // Clean up the DNS domain name cached for the shared connection.
    //

    if (NatpSharedConnectionDomainName) {
        NH_FREE(NatpSharedConnectionDomainName);
        NatpSharedConnectionDomainName = NULL;
    }

    //
    // Reset tracking variables to initial state
    //

    NatpFirewallConnectionCount = 0;
    NatpSharedConnectionPresent = FALSE;

    LeaveCriticalSection(&NatInterfaceLock);

} // NatStopConnectionManagement


BOOLEAN
NatUnbindAllConnections(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to unbind a currently-active connection.

Arguments:

    Index - index into the connection array

Return Value:

    BOOLEAN - TRUE if any interfaces were unbound.

Environment:

    Invoked with 'NatInterfaceLock' held by the caller.

--*/

{

    PLIST_ENTRY Link;
    PNAT_CONNECTION_ENTRY pConEntry;
    BOOLEAN Result = FALSE;
    PROFILE("NatUnbindAllConnections");

    for (Link = NatpConnectionList.Flink;
         Link != &NatpConnectionList;
         Link = Link->Flink)
    {
        pConEntry = CONTAINING_RECORD(Link, NAT_CONNECTION_ENTRY, Link);
        Result |= NatpUnbindConnection(pConEntry);
    }

    return Result;
} // NatpUnbindConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\natio.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    natio.h

Abstract:

    This module contains declarations for the NAT's I/O interface
    to the kernel-mode driver.

Author:

    Abolade Gbadegesin (aboladeg)   10-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>

//
// PRIVATE GLOBAL VARIABLES
//

HANDLE NatFileHandle;
LIST_ENTRY NatInterfaceList;
//
// Controls access to 'NatFileHandle' and 'NatInterfaceList'.
//
CRITICAL_SECTION NatInterfaceLock;

//
// FORWARD DECLARATIONS
//

VOID
NatpDisableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

BOOLEAN
NatpEnableLoadDriverPrivilege(
    PBOOLEAN WasEnabled
    );

PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    );


ULONG
NatBindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep OPTIONAL,
    PIP_ADAPTER_BINDING_INFO BindingInfo,
    ULONG AdapterIndex
    )

/*++

Routine Description:

    This routine is invoked to bind the NAT to an interface.

Arguments:

    Index - the interface to be bound

    Interfacep - optionally supplies the interface-structure to be bound
        (See 'NATCONN.C' which passes in a static interface-structure).

    BindingInfo - the interface's address-information

    AdapterIndex - optionally specifies the interface's TCP/IP adapter index.
        This is set only for home-router interfaces.

Return Value:

    ULONG - Win32 status code.

--*/

{
    PIP_NAT_CREATE_INTERFACE CreateInterface;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatBindInterface");

    Error = NO_ERROR;

    //
    // Look up the interface to be bound
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!Interfacep && !(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface isn't already bound
    //

    if (NAT_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: interface %d is already bound",
            Index
            );
        return ERROR_ADDRESS_ALREADY_ASSOCIATED;
    }

    //
    // Allocate the bind-structure
    //

    Size =
        sizeof(IP_NAT_CREATE_INTERFACE) +
        SIZEOF_IP_BINDING(BindingInfo->AddressCount);

    CreateInterface = reinterpret_cast<PIP_NAT_CREATE_INTERFACE>(
                        NH_ALLOCATE(Size));

    if (!CreateInterface) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: allocation failed for interface %d binding",
            Index
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Interfacep->AdapterIndex =
        (AdapterIndex != (ULONG)-1)
            ? AdapterIndex
            : NhMapInterfaceToAdapter(Interfacep->Index);
    if (Interfacep->AdapterIndex == (ULONG)-1) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: NhMapInterfaceToAdapter failed for %d",
            Index
            );
        return ERROR_INVALID_INDEX;
    }
    CreateInterface->Index = Interfacep->AdapterIndex;
    CopyMemory(
        CreateInterface->BindingInfo,
        BindingInfo,
        SIZEOF_IP_BINDING(BindingInfo->AddressCount)
        );

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: CreateEvent failed [%d] for interface %d",
            GetLastError(),
            Index
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Install the interface
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_INTERFACE,
            (PVOID)CreateInterface,
            Size,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    NH_FREE(CreateInterface);

    if (!NT_SUCCESS(status)) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: status %08x binding interface %d",
            status,
            Index
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
        return Error;
    }

    //
    // Now set its configuration
    //

    Interfacep->Info->Index = Interfacep->AdapterIndex;
    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        Interfacep->Info->Header.Size;

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_INTERFACE_INFO,
            (PVOID)Interfacep->Info,
            Size,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        ULONG AdapterIndex = Interfacep->AdapterIndex;
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatBindInterface: status %08x setting info for interface %d (%d)",
            status,
            Index,
            AdapterIndex
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_INTERFACE,
                (PVOID)&AdapterIndex,
                sizeof(ULONG),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
        CloseHandle(WaitEvent);
        return Error;
    }

    Interfacep->Flags |= NAT_INTERFACE_FLAG_BOUND;

    if (Interfacep->Type == ROUTER_IF_TYPE_DEDICATED) {
        NatUpdateProxyArp(Interfacep, TRUE);
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatBindInterface


ULONG
NatConfigureDriver(
    PIP_NAT_GLOBAL_INFO GlobalInfo
    )

/*++

Routine Description:

    This routine is called to update the configuration for the NAT driver.

Arguments:

    GlobalInfo - the new configuration for the NAT.

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error = NO_ERROR;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatConfigureDriver");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureDriver: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Attempt to configure the driver
    //

    EnterCriticalSection(&NatInterfaceLock);
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_SET_GLOBAL_INFO,
            (PVOID)GlobalInfo,
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + GlobalInfo->Header.Size,
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    LeaveCriticalSection(&NatInterfaceLock);

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureDriver: status %08x setting global info",
            status
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    }

    CloseHandle(WaitEvent);

    return Error;

} // NatConfigureDriver


ULONG
NatConfigureInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is invoked to set the configuration for a NAT interface.

Arguments:

    Index - the interface to be configured

    InterfaceInfo - the configuration for the interface

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_NAT_INTERFACE_INFO Info;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;

    PROFILE("NatConfigureInterface");

    if (!InterfaceInfo) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: no interface info for %d",
            Index
            );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make a copy of the information
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        InterfaceInfo->Header.Size;

    Info = (PIP_NAT_INTERFACE_INFO)NH_ALLOCATE(Size);

    if (!Info) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: error allocating copy of configuration"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(
        Info,
        InterfaceInfo,
        Size
        );

    //
    // Look up the interface to be configured
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: interface %d not found",
            Index
            );
        NH_FREE(Info);
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // See if the configuration changed
    //

    if ((Size ==
            FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
            Interfacep->Info->Header.Size) &&
        memcmp(InterfaceInfo, Interfacep->Info, Size) == 0
        ) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: no change to interface %d configuration",
            Index
            );
        NH_FREE(Info);
        return NO_ERROR;
    }


    //
    // See if the interface is bound;
    // if so we need to update the kernel-mode driver's configuration.
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {
        status = STATUS_SUCCESS;
    } else {
        HANDLE WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (WaitEvent != NULL) {
            Info->Index = Interfacep->AdapterIndex;

            //
            // Attempt to configure the interface
            //

            status =
                NtDeviceIoControlFile(
                    NatFileHandle,
                    WaitEvent,
                    NULL,
                    NULL,
                    &IoStatus,
                    IOCTL_IP_NAT_SET_INTERFACE_INFO,
                    (PVOID)Info,
                    Size,
                    NULL,
                    0
                    );
            if (status == STATUS_PENDING) {
                WaitForSingleObject(WaitEvent, INFINITE);
                status = IoStatus.Status;
            }
            CloseHandle(WaitEvent);
        } else {
            status = STATUS_UNSUCCESSFUL;
            NhTrace(
                TRACE_FLAG_NAT,
                "NatConfigureInterface: CreateEvent failed [%d]",
                GetLastError()
                );
        }
    }

    if (!NT_SUCCESS(status)) {
        NH_FREE(Info);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatConfigureInterface: status %08x setting interface info",
            status
            );
        Error = RtlNtStatusToDosError(status);
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    } else {
        Error = NO_ERROR;

        //
        // Update proxy ARP entries for LAN interfaces
        //

        if (NAT_INTERFACE_BOUND(Interfacep) &&
            Interfacep->Type == ROUTER_IF_TYPE_DEDICATED
            ) {
            NatUpdateProxyArp(Interfacep, FALSE);
        }

        if (Interfacep->Info) { NH_FREE(Interfacep->Info); }
        Interfacep->Info = Info;

        if (NAT_INTERFACE_BOUND(Interfacep) &&
            Interfacep->Type == ROUTER_IF_TYPE_DEDICATED
            ) {
            NatUpdateProxyArp(Interfacep, TRUE);
        }
    }

    LeaveCriticalSection(&NatInterfaceLock);

    if (NT_SUCCESS(status)) {
        if (InterfaceInfo->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY) {
            NhSignalNatInterface(
                Index,
                TRUE
                );
        } else {
            NhSignalNatInterface(
                Index,
                FALSE
                );
        }
    }

    return Error;

} // NatConfigureInterface


ULONG
NatCreateInterface(
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    PIP_NAT_INTERFACE_INFO InterfaceInfo
    )

/*++

Routine Description:

    This routine is invoked to create an interface with the NAT driver.

Arguments:

    Index - the index of the new interface

    InterfaceInfo - the configuration for the new interface

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PIP_NAT_INTERFACE_INFO Info;
    PLIST_ENTRY InsertionPoint;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG Size;
    NTSTATUS status;
    ROUTER_INTERFACE_TYPE IfType;

    PROFILE("NatCreateInterface");

    if (!InterfaceInfo) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: no interface info for %d",
            Index
            );
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check for the interface in our table
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (NatpLookupInterface(Index, &InsertionPoint)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: interface %d already exists",
            Index
            );
        return ERROR_INTERFACE_ALREADY_EXISTS;
    }

    //
    // Allocate a new interface
    //

    Interfacep =
        reinterpret_cast<PNAT_INTERFACE>(NH_ALLOCATE(sizeof(NAT_INTERFACE)));

    if (!Interfacep) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: error allocating interface"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            sizeof(NAT_INTERFACE)
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Make a copy of the information
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        InterfaceInfo->Header.Size;

    Info = (PIP_NAT_INTERFACE_INFO)NH_ALLOCATE(Size);

    if (!Info) {
        LeaveCriticalSection(&NatInterfaceLock);
        NH_FREE(Interfacep);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateInterface: error allocating copy of configuration"
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory(
        Info,
        InterfaceInfo,
        Size
        );

    //
    // Initialize the new interface
    //

    ZeroMemory(Interfacep, sizeof(*Interfacep));

    Interfacep->Index = Index;
    Interfacep->AdapterIndex = (ULONG)-1;
    Interfacep->Type = IfType =
        ((Type == PERMANENT)
            ? ROUTER_IF_TYPE_DEDICATED
            : ROUTER_IF_TYPE_FULL_ROUTER);
    Interfacep->Info = Info;
    InsertTailList(InsertionPoint, &Interfacep->Link);

    LeaveCriticalSection(&NatInterfaceLock);

    if (InterfaceInfo->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY) {
        NhSignalNatInterface(
            Index,
            TRUE
            );
    } else {
        NhSignalNatInterface(
            Index,
            FALSE
            );
    }

    return NO_ERROR;

} // NatCreateInterface


ULONG
NatCreateTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to add a ticket (static port mapping)
    to an interface.

Arguments:

    InterfaceIndex - the interface to which to add the ticket

    Protocol, PublicPort, PublicAddress, PrivatePort, PrivateAddress -
        describes the ticket to be created

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET CreateTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatCreateTicket");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateTicket: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CreateTicket.InterfaceIndex = InterfaceIndex;
    CreateTicket.PortMapping.Protocol = Protocol;
    CreateTicket.PortMapping.PublicPort = PublicPort;
    CreateTicket.PortMapping.PublicAddress = PublicAddress;
    CreateTicket.PortMapping.PrivatePort = PrivatePort;
    CreateTicket.PortMapping.PrivateAddress = PrivateAddress;

    EnterCriticalSection(&NatInterfaceLock);

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_TICKET,
            (PVOID)&CreateTicket,
            sizeof(CreateTicket),
            NULL,
            0
            );

    LeaveCriticalSection(&NatInterfaceLock);
    
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Error = NO_ERROR;
    } else {
        Error = RtlNtStatusToDosError(status);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatCreateTicket: Ioctl = %d",
            Error
            );
    }
    
    CloseHandle(WaitEvent);
    
    return Error;
} // NatCreateTicket


ULONG
NatDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to remove an interface from the NAT.

Arguments:

    Index - the interface to be removed

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatDeleteInterface");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Retrieve the interface to be deleted.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    Error = NO_ERROR;
    if (NAT_INTERFACE_BOUND(Interfacep)) {

        //
        // Delete the interface from the kernel-mode driver
        //

        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_INTERFACE,
                (PVOID)&Interfacep->AdapterIndex,
                sizeof(ULONG),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {
            Error = NO_ERROR;
        } else {
            Error = RtlNtStatusToDosError(status);
            NhErrorLog(
                IP_NAT_LOG_IOCTL_FAILED,
                Error,
                ""
                );
        }
    }
    CloseHandle(WaitEvent);

    //
    // Remove the interface from our list
    //

    RemoveEntryList(&Interfacep->Link);
    if (Interfacep->Info) {
        NH_FREE(Interfacep->Info);
    }
    NH_FREE(Interfacep);

    LeaveCriticalSection(&NatInterfaceLock);

    NhSignalNatInterface(
        Index,
        FALSE
        );

    return Error;

} // NatDeleteInterface


ULONG
NatDeleteTicket(
    ULONG InterfaceIndex,
    UCHAR Protocol,
    USHORT PublicPort,
    ULONG PublicAddress,
    USHORT PrivatePort,
    ULONG PrivateAddress
    )

/*++

Routine Description:

    This routine is invoked to remove a ticket (static port mapping)
    from an interface.

Arguments:

    InterfaceIndex - the interface from which to remove the ticket

    Protocol, PublicPort, PublicAddress, PrivatePort, PrivateAddress -
        describes the ticket to be deleted

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET DeleteTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatDeleteTicket");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteTicket: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DeleteTicket.InterfaceIndex = InterfaceIndex;
    DeleteTicket.PortMapping.Protocol = Protocol;
    DeleteTicket.PortMapping.PublicPort = PublicPort;
    DeleteTicket.PortMapping.PublicAddress = PublicAddress;
    DeleteTicket.PortMapping.PrivatePort = PrivatePort;
    DeleteTicket.PortMapping.PrivateAddress = PrivateAddress;

    EnterCriticalSection(&NatInterfaceLock);

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_DELETE_TICKET,
            (PVOID)&DeleteTicket,
            sizeof(DeleteTicket),
            NULL,
            0
            );

    LeaveCriticalSection(&NatInterfaceLock);
    
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (NT_SUCCESS(status)) {
        Error = NO_ERROR;
    } else {
        Error = RtlNtStatusToDosError(status);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatDeleteTicket: Ioctl = %d",
            Error
            );
    }
    
    CloseHandle(WaitEvent);
    
    return Error;
} // NatDeleteTicket



ULONG
NatGetInterfaceCharacteristics(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given interface:
    1) Is a NAT boundary interface
    2) Is a NAT private interface
    3) Has the firewall enabled

    Note that this routine may be invoked even when the NAT
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized in 'DllMain'.

Arguments:

    Index - the interface in question

    IsNatInterface - optionally set to TRUE if the given index
        is at all a NAT interface.

Return Value:

    BOOLEAN - TRUE if the interface is a NAT boundary interface,
        FALSE otherwise.

--*/

{
    ULONG Result = 0;
    PNAT_INTERFACE Interfacep;
    PROFILE("NatGetInterfaceCharacteristics");

    EnterCriticalSection(&NatInterfaceLock);
    
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        return Result;
    }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_FW)) {
        Result = NAT_IF_CHAR_FW;
    }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY)) {
        
        Result |= NAT_IF_CHAR_BOUNDARY;
    } else if (!NAT_IFC_FW(Result)) {

        //
        // As the interface isn't public and isn't firewalled, it must
        // be a private interface (or we wouldn't have a record of it).
        //
        
        Result |= NAT_IF_CHAR_PRIVATE;
    }

    LeaveCriticalSection(&NatInterfaceLock);
    
    return Result;
} // NatGetInterfaceCharacteristics


VOID
NatInstallApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to update the application settings
    (i.e., dynamic tickets) stored with the kernel-mode translation module.

Arguments:

    none

Return Value:

    none.

--*/

{
    PNAT_APP_ENTRY pAppEntry;
    ULONG Count;
    PIP_NAT_CREATE_DYNAMIC_TICKET CreateTicket;
    IO_STATUS_BLOCK IoStatus;
    ULONG Length;
    PLIST_ENTRY Link;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatInstallApplicationSettings");

    //
    // Install a dynamic ticket for each entry in the applications list
    //

    EnterCriticalSection(&NatInterfaceLock);
    EnterCriticalSection(&NhLock);

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NhLock);
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatInstallSharedAccessSettings: CreateEvent failed [%d]",
            GetLastError()
            );
        return;
    }

    for (Link = NhApplicationSettingsList.Flink;
         Link != &NhApplicationSettingsList;
         Link = Link->Flink)
    {

        //
        // Each 'application' has a list of 'responses' which specify
        // the ports on which response-sessions are expected.
        // Enumerate the responses and allocate a ticket-structure
        // large enough to hold the list as an array.
        //

        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);

        Length =
            pAppEntry->ResponseCount * sizeof(CreateTicket->ResponseArray[0]) +
            FIELD_OFFSET(IP_NAT_CREATE_DYNAMIC_TICKET, ResponseArray);

        if (!(CreateTicket =
                reinterpret_cast<PIP_NAT_CREATE_DYNAMIC_TICKET>(
                    NH_ALLOCATE(Length)
                    )))
        { break; }

        //
        // Fill in the ticket structure from the application entry
        // and its list of response-entries.
        //

        CreateTicket->Protocol = pAppEntry->Protocol;
        CreateTicket->Port = pAppEntry->Port;
        CreateTicket->ResponseCount = pAppEntry->ResponseCount;
        
        for (Count = 0; Count < pAppEntry->ResponseCount; Count++)
        {
            CreateTicket->ResponseArray[Count].Protocol =
                pAppEntry->ResponseArray[Count].ucIPProtocol;
            CreateTicket->ResponseArray[Count].StartPort =
                pAppEntry->ResponseArray[Count].usStartPort;
            CreateTicket->ResponseArray[Count].EndPort =
                pAppEntry->ResponseArray[Count].usEndPort;
        }

        //
        // Install the dynamic ticket for this application, and continue.
        //

        status = NtDeviceIoControlFile(
                     NatFileHandle,
                     WaitEvent,
                     NULL,
                     NULL,
                     &IoStatus,
                     IOCTL_IP_NAT_CREATE_DYNAMIC_TICKET,
                     (PVOID)CreateTicket,
                     Length,
                     NULL,
                     0
                     );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
        NH_FREE(CreateTicket);
    }

    LeaveCriticalSection(&NhLock);
    LeaveCriticalSection(&NatInterfaceLock);

    CloseHandle(WaitEvent);
} // NatInstallApplicationSettings


BOOLEAN
NatIsBoundaryInterface(
    ULONG Index,
    PBOOLEAN IsNatInterface OPTIONAL
    )

/*++

Routine Description:

    This routine is invoked to determine whether the given interface
    has the NAT enabled and is marked as a boundary interface.
    Note that this routine may be invoked even when the NAT
    is neither installed nor running; it operates as expected,
    since the interface list and lock are always initialized in 'DllMain'.

Arguments:

    Index - the interface in question

    IsNatInterface - optionally set to TRUE if the given index
        is at all a NAT interface.

Return Value:

    BOOLEAN - TRUE if the interface is a NAT boundary interface,
        FALSE otherwise.

--*/

{
    PNAT_INTERFACE Interfacep;
    PROFILE("NatIsBoundaryInterface");

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        if (IsNatInterface) { *IsNatInterface = FALSE; }
        return FALSE;
    }

    if (IsNatInterface) { *IsNatInterface = TRUE; }

    if (Interfacep->Info &&
        (Interfacep->Info->Flags & IP_NAT_INTERFACE_FLAGS_BOUNDARY)) {
        LeaveCriticalSection(&NatInterfaceLock);
        return TRUE;
    }
    LeaveCriticalSection(&NatInterfaceLock);
    return FALSE;

} // NatIsBoundaryInterface


PNAT_INTERFACE
NatpLookupInterface(
    ULONG Index,
    OUT PLIST_ENTRY* InsertionPoint OPTIONAL
    )

/*++

Routine Description:

    This routine is called to retrieve an interface given its index.

Arguments:

    Index - the index of the interface to be retrieved

    InsertionPoint - if the interface is not found, optionally receives
        the point where the interface would be inserted in the interface list

Return Value:

    PNAT_INTERFACE - the interface, if found; otherwise, NULL.

Environment:

    Invoked internally from an arbitrary context, with 'NatInterfaceLock'
    held by caller.

--*/

{
    PNAT_INTERFACE Interfacep;
    PLIST_ENTRY Link;

    PROFILE("NatpLookupInterface");

    for (Link = NatInterfaceList.Flink; Link != &NatInterfaceList;
         Link = Link->Flink) {
        Interfacep = CONTAINING_RECORD(Link, NAT_INTERFACE, Link);
        if (Index > Interfacep->Index) {
            continue;
        } else if (Index < Interfacep->Index) {
            break;
        }
        return Interfacep;
    }

    if (InsertionPoint) { *InsertionPoint = Link; }

    return NULL;

} // NatpLookupInterface


ULONG
NatQueryInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_INFO InterfaceInfo,
    PULONG InterfaceInfoSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the information for a NAT interface.

Arguments:

    Index - the interface whose information is to be queried

    InterfaceInfo - receives the information

    InterfaceInfoSize - receives the information size

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PNAT_INTERFACE Interfacep;
    ULONG Size;

    PROFILE("NatQueryInterface");

    //
    // Look up the interface to be queried
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Compute the required size
    //

    Size =
        FIELD_OFFSET(IP_NAT_INTERFACE_INFO, Header) +
        Interfacep->Info->Header.Size;

    if (Size >= *InterfaceInfoSize) {
        *InterfaceInfoSize = Size;
        Error = ERROR_INSUFFICIENT_BUFFER;
    } else {
        *InterfaceInfoSize = Size;
        CopyMemory(
            InterfaceInfo,
            Interfacep->Info,
            Size
            );
        Error = NO_ERROR;
    }

    LeaveCriticalSection(&NatInterfaceLock);

    return Error;

} // NatQueryInterface


ULONG
NatQueryInterfaceMappingTable(
    ULONG Index,
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the session mappings for an interface.

Arguments:

    EnumerateTable - receives the enumerated mappings

    EnumerateTableSize - indicates the size of 'EnumerateTable'

Return Value:

    ULONG - Win32 error code.

--*/

{
    IP_NAT_ENUMERATE_SESSION_MAPPINGS Enumerate;
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    ULONG RequiredSize;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryInterfaceMappingTable");

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterfaceMappingTable: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    if (!NAT_INTERFACE_BOUND(Interfacep)) {

        //
        // The interface is not bound, so there aren't any mappings.
        // Indicate zero mappings in the caller's request-buffer.
        //

        LeaveCriticalSection(&NatInterfaceLock);

        RequiredSize =
            FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]);

        if (*EnumerateTableSize < RequiredSize) {
            *EnumerateTableSize = RequiredSize;
            return ERROR_INSUFFICIENT_BUFFER;
        }

        EnumerateTable->Index = Index;
        EnumerateTable->EnumerateContext[0] = 0;
        EnumerateTable->EnumerateCount = 0;
        *EnumerateTableSize = RequiredSize;

        return NO_ERROR;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryInterfaceMappingTable: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Determine the amount of space required
    //

    Enumerate.Index = Interfacep->AdapterIndex;
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)&Enumerate,
            sizeof(Enumerate)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    if (!NT_SUCCESS(status)) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        *EnumerateTableSize = 0;
        return RtlNtStatusToDosError(status);
    }

    RequiredSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        Enumerate.EnumerateTotalHint * sizeof(IP_NAT_SESSION_MAPPING);

    //
    // If the caller doesn't have enough space for all these mappings, fail
    //

    if (*EnumerateTableSize < RequiredSize) {
        CloseHandle(WaitEvent);
        LeaveCriticalSection(&NatInterfaceLock);
        *EnumerateTableSize = RequiredSize + 5 * sizeof(IP_NAT_SESSION_MAPPING);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Attempt to read the mappings
    //

    Enumerate.Index = Interfacep->AdapterIndex;
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)EnumerateTable,
            *EnumerateTableSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    CloseHandle(WaitEvent);
    LeaveCriticalSection(&NatInterfaceLock);

    EnumerateTable->Index = Index;
    *EnumerateTableSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        EnumerateTable->EnumerateCount * sizeof(IP_NAT_SESSION_MAPPING);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryInterfaceMappingTable


ULONG
NatQueryMappingTable(
    PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable,
    PULONG EnumerateTableSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the session mappings for an interface.

Arguments:

    EnumerateTable - receives the enumerated mappings

    EnumerateTableSize - indicates the size of 'EnumerateTable'

Return Value:

    ULONG - Win32 error code.

--*/

{
    IP_NAT_ENUMERATE_SESSION_MAPPINGS Enumerate;
    IO_STATUS_BLOCK IoStatus;
    ULONG RequiredSize;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryMappingTable");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryMappingTable: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    EnterCriticalSection(&NatInterfaceLock);

    //
    // Determine the amount of space required
    //
    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)&Enumerate,
            sizeof(Enumerate)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        *EnumerateTableSize = 0;
        return RtlNtStatusToDosError(status);
    }

    RequiredSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        Enumerate.EnumerateTotalHint * sizeof(IP_NAT_SESSION_MAPPING);

    //
    // If the caller doesn't have enough space for all these mappings, fail
    //

    if (*EnumerateTableSize < RequiredSize) {
        LeaveCriticalSection(&NatInterfaceLock);
        CloseHandle(WaitEvent);
        *EnumerateTableSize = RequiredSize + 5 * sizeof(IP_NAT_SESSION_MAPPING);
        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Attempt to read the mappings
    //

    Enumerate.EnumerateCount = 0;
    Enumerate.EnumerateContext[0] = 0;
    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_MAPPING_TABLE,
            (PVOID)&Enumerate,
            sizeof(Enumerate),
            (PVOID)EnumerateTable,
            *EnumerateTableSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    EnumerateTable->Index = (ULONG)-1;
    *EnumerateTableSize =
        FIELD_OFFSET(IP_NAT_ENUMERATE_SESSION_MAPPINGS, EnumerateTable[0]) +
        EnumerateTable->EnumerateCount * sizeof(IP_NAT_SESSION_MAPPING);

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryMappingTable


ULONG
NatQueryStatisticsInterface(
    ULONG Index,
    PIP_NAT_INTERFACE_STATISTICS InterfaceStatistics,
    PULONG InterfaceStatisticsSize
    )

/*++

Routine Description:

    This routine is invoked to retrieve the statistics for a NAT interface.

Arguments:

    Index - the index of the interface whose statistics are to be retrieved

Return Value:

    ULONG - Win32 error code.

--*/

{
    PNAT_INTERFACE Interfacep;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatQueryStatisticsInterface");

    //
    // Look up the interface to be queried
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryStatisticsInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // If the interface is not bound, supply zero statistics.
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {

        LeaveCriticalSection(&NatInterfaceLock);

        if (*InterfaceStatisticsSize < sizeof(IP_NAT_INTERFACE_STATISTICS)) {
            *InterfaceStatisticsSize = sizeof(IP_NAT_INTERFACE_STATISTICS);
            return ERROR_INSUFFICIENT_BUFFER;
        }

        *InterfaceStatisticsSize = sizeof(IP_NAT_INTERFACE_STATISTICS);
        ZeroMemory(InterfaceStatistics, sizeof(IP_NAT_INTERFACE_STATISTICS));

        return NO_ERROR;
    }

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatQueryStatisticsInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Attempt to read the statistics for the interface
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_GET_INTERFACE_STATISTICS,
            (PVOID)&Interfacep->AdapterIndex,
            sizeof(ULONG),
            (PVOID)InterfaceStatistics,
            *InterfaceStatisticsSize
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    CloseHandle(WaitEvent);

    LeaveCriticalSection(&NatInterfaceLock);

    if (NT_SUCCESS(status) && IoStatus.Information > *InterfaceStatisticsSize) {
        *InterfaceStatisticsSize = (ULONG)IoStatus.Information;
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *InterfaceStatisticsSize = (ULONG)IoStatus.Information;

    return NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

} // NatQueryStatisticsInterface


VOID
NatRemoveApplicationSettings(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to remove the advanced application settings (i.e.,
    dynamic tickets), and supply the settings to the kernel-mode translation
    module.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PNAT_APP_ENTRY pAppEntry;
    IP_NAT_DELETE_DYNAMIC_TICKET DeleteTicket;
    IO_STATUS_BLOCK IoStatus;
    PLIST_ENTRY Link;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatRemoveApplicationSettings");

    //
    // Each 'application' entry in the shared access settings
    // corresponds to a dynamic ticket for the kernel-mode translator.
    // We begin by removing the dynamic tickets for the old settings, if any,
    // and then we free the old settings in preparation for reloading.
    //

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatRemoveSharedAccessSettings: CreateEvent failed [%d]",
            GetLastError()
            );
        return;
    }

    EnterCriticalSection(&NatInterfaceLock);
    EnterCriticalSection(&NhLock);
    
    for (Link = NhApplicationSettingsList.Flink;
         Link != &NhApplicationSettingsList;
         Link = Link->Flink)
    {
        pAppEntry = CONTAINING_RECORD(Link, NAT_APP_ENTRY, Link);
        DeleteTicket.Protocol = pAppEntry->Protocol;
        DeleteTicket.Port = pAppEntry->Port;
        status =
            NtDeviceIoControlFile(
                NatFileHandle,
                WaitEvent,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_NAT_DELETE_DYNAMIC_TICKET,
                (PVOID)&DeleteTicket,
                sizeof(DeleteTicket),
                NULL,
                0
                );
        if (status == STATUS_PENDING) {
            WaitForSingleObject(WaitEvent, INFINITE);
            status = IoStatus.Status;
        }
    }
        
    LeaveCriticalSection(&NhLock);
    LeaveCriticalSection(&NatInterfaceLock);

    CloseHandle(WaitEvent);
} // NatRemoveSharedAccessSettings


ULONG
NatUnbindInterface(
    ULONG Index,
    PNAT_INTERFACE Interfacep
    )

/*++

Routine Description:

    This routine is invoked to remove a binding from the NAT.

Arguments:

    Index - the interface to be unbound

    Interfacep - optionally supplies the interface-structure to be unbound
        (See 'NATCONN.C' which passes in a static interface-structure).

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatUnbindInterface");

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: CreateEvent failed [%d]",
            GetLastError()
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Retrieve the interface to be unbound.
    //

    EnterCriticalSection(&NatInterfaceLock);
    if (!Interfacep && !(Interfacep = NatpLookupInterface(Index, NULL))) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: interface %d not found",
            Index
            );
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // Make sure the interface is not already unbound
    //

    if (!NAT_INTERFACE_BOUND(Interfacep)) {
        LeaveCriticalSection(&NatInterfaceLock);
        NhTrace(
            TRACE_FLAG_NAT,
            "NatUnbindInterface: interface %d already unbound",
            Index
            );
        return ERROR_ADDRESS_NOT_ASSOCIATED;
    }

    Interfacep->Flags &= ~NAT_INTERFACE_FLAG_BOUND;

    if (Interfacep->Type == ROUTER_IF_TYPE_DEDICATED) {
        NatUpdateProxyArp(Interfacep, FALSE);
    }

    //
    // Remove the interface from the kernel-mode driver
    //

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_DELETE_INTERFACE,
            (PVOID)&Interfacep->AdapterIndex,
            sizeof(ULONG),
            NULL,
            0
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }
    LeaveCriticalSection(&NatInterfaceLock);
    CloseHandle(WaitEvent);

    Error = NT_SUCCESS(status) ? NO_ERROR : RtlNtStatusToDosError(status);

    if (Error) {
        NhErrorLog(
            IP_NAT_LOG_IOCTL_FAILED,
            Error,
            ""
            );
    }

    return Error;

} // NatUnbindInterface


ULONG
NatLookupPortMappingAdapter(
    ULONG AdapterIndex,
    UCHAR Protocol,
    ULONG PublicAddress,
    USHORT PublicPort,
    PIP_NAT_PORT_MAPPING PortMappingp
    )

/*++

Routine Description:

    This routine is invoked to find a mapping that matches the given adapter,
    protocol, public address and public port number. The routine tries to
    match both port and address mapping.

Arguments:

    AdapterIndex - the adapter to be looked up
    Protocol - protocol used to match a mapping
    PublicAddress - public address used to match a mapping
    PublicPort - public port number used to match a mapping
    PortMappingp - pointer to a caller-supplied storage to save the mapping if
        found

Return Value:

    ULONG - Win32 status code.

--*/

{
    IP_NAT_CREATE_TICKET LookupTicket;
    ULONG Error;
    IO_STATUS_BLOCK IoStatus;
    NTSTATUS status;
    HANDLE WaitEvent;

    PROFILE("NatLookupPortMappingAdapter");

    Error = NO_ERROR;

    WaitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (WaitEvent == NULL) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatLookupPortMappingAdapter:"
            " CreateEvent failed [%d] for adapter %d",
            GetLastError(),
            AdapterIndex
            );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LookupTicket.InterfaceIndex = AdapterIndex;
    LookupTicket.PortMapping.Protocol = Protocol;
    LookupTicket.PortMapping.PublicPort = PublicPort;
    LookupTicket.PortMapping.PublicAddress = PublicAddress;
    LookupTicket.PortMapping.PrivatePort = 0;
    LookupTicket.PortMapping.PrivateAddress = 0;

    status =
        NtDeviceIoControlFile(
            NatFileHandle,
            WaitEvent,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_LOOKUP_TICKET,
            (PVOID)&LookupTicket,
            sizeof(LookupTicket),
            (PVOID)PortMappingp,
            sizeof(*PortMappingp)
            );
    if (status == STATUS_PENDING) {
        WaitForSingleObject(WaitEvent, INFINITE);
        status = IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {
        NhTrace(
            TRACE_FLAG_NAT,
            "NatLookupPortMappingAdapter:"
            " status %08x getting info for adapter %d",
            status,
            AdapterIndex
            );
        Error = RtlNtStatusToDosError(status);
    }

    CloseHandle(WaitEvent);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsock2.h>
#include <objbase.h>
#include <objidl.h>
#include <stdio.h>

#include <mprapi.h>
#include <mprerror.h>
#include <routprot.h>
#include <rtutils.h>
#include <iphlpapi.h>
#include <ipnat.h>
#include <ipnatapi.h>
#include <ipnathlp.h>
#include <ntddip.h>
#include <ipfltinf.h>
#include <sainfo.h>
#include <hnetcfg.h>
#include <netconp.h>
#include <tcguid.h>
#include <wmium.h>

#include "nathlpp.h"
#include "debug.h"
#include "compref.h"
#include "buffer.h"
#include "socket.h"
#include "range.h"
#include "rmapi.h"
#include "rmdhcp.h"
#include "rmdns.h"
#include "rmftp.h"
#include "rmALG.h"
#include "rmh323.h"
#include "rmnat.h"
#include "natapip.h"
#include "natarp.h"
#include "natio.h"
#include "natconn.h"
#include "natlog.h"
#include "svcmain.h"
#include "timer.h"
#include "fwlogger.h"
#include "cudpbcast.h"
#include "csaupdate.h"


#define IID_PPV_ARG(Type, Expr) \
    __uuidof(Type), reinterpret_cast<void**>(static_cast<Type **>((Expr)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\rmnat.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    rmnat.c

Abstract:

    This module contains routines for the NAT module's interface
    to the IP router-manager. (See ROUTPROT.H for details).

Author:

    Abolade Gbadegesin (aboladeg)   4-Mar-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

COMPONENT_REFERENCE NatComponentReference;
PIP_NAT_GLOBAL_INFO NatGlobalInfo = NULL;
CRITICAL_SECTION NatGlobalInfoLock;
HANDLE NatNotificationEvent;
ULONG NatProtocolStopped = 0;
const MPR_ROUTING_CHARACTERISTICS NatRoutingCharacteristics =
{
    MS_ROUTER_VERSION,
    MS_IP_NAT,
    RF_ROUTING,
    NatRmStartProtocol,
    NatRmStartComplete,
    NatRmStopProtocol,
    NatRmGetGlobalInfo,
    NatRmSetGlobalInfo,
    NULL,
    NULL,
    NatRmAddInterface,
    NatRmDeleteInterface,
    NatRmInterfaceStatus,
    NatRmGetInterfaceInfo,
    NatRmSetInterfaceInfo,
    NatRmGetEventMessage,
    NULL,
    NatRmConnectClient,
    NatRmDisconnectClient,
    NULL,
    NULL,
    NatRmMibCreate,
    NatRmMibDelete,
    NatRmMibGet,
    NatRmMibSet,
    NatRmMibGetFirst,
    NatRmMibGetNext,
    NULL,
    NULL
};
SUPPORT_FUNCTIONS NatSupportFunctions;

//
// FORWARD DECLARATIONS
//

VOID APIENTRY
NatpProcessClientWorkerRoutine(
    PVOID Context
    );


VOID
NatCleanupModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the NAT module.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within a 'DllMain' routine on 'DLL_PROCESS_DETACH'.

--*/

{
    DeleteCriticalSection(&NatInterfaceLock);
    DeleteCriticalSection(&NatGlobalInfoLock);
    DeleteComponentReference(&NatComponentReference);

} // NatCleanupModule


VOID
NatCleanupProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to cleanup the NAT protocol-component
    after a 'StopProtocol'.

Arguments:

    none.

Return Value:

    none.

Environment:

    Invoked from within an arbitrary context with no locks held.

--*/

{
    PROFILE("NatCleanupProtocol");

    //
    // Stop the NAT driver.
    //

    NatUnloadDriver(NULL);
    if (NatGlobalInfo) { NH_FREE(NatGlobalInfo); NatGlobalInfo = NULL; }

    //
    // Notify the router-manager.
    //

    InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 1);
    SetEvent(NatNotificationEvent);

    //
    // Reset the component reference
    //

    ResetComponentReference(&NatComponentReference);

    //
    // Return the component to the uninitialized mode,
    // whatever the original mode might have been.
    //

    NhResetComponentMode();

    //
    // Free up HNetCfgMgr pointers
    //

    if (NULL != NhGITp)
    {
        HRESULT hr;
        BOOLEAN ComInitialized = FALSE;

        //
        // Make sure COM is initialized
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr))
        {
            ComInitialized = TRUE;
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            //
            // Release the CfgMgr from the GIT
            //

            NhGITp->RevokeInterfaceFromGlobal(NhCfgMgrCookie);
            NhCfgMgrCookie = 0;

            //
            // Release the GIT
            //

            NhGITp->Release();
            NhGITp = NULL;
        }

        if (TRUE == ComInitialized)
        {
            CoUninitialize();
        }
    }
} // NatCleanupProtocol


BOOLEAN
NatInitializeModule(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to initialize the NAT module.

Arguments:

    none.

Return Value:

    BOOLEAN - TRUE if initialization succeeded, FALSE otherwise

Environment:

    Invoked in the context of a 'DllMain' routine on 'DLL_PROCESS_ATTACH'.

--*/

{
    InitializeListHead(&NatInterfaceList);

    if (InitializeComponentReference(
            &NatComponentReference, NatCleanupProtocol
            )) {
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&NatGlobalInfoLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        DeleteComponentReference(&NatComponentReference);
        return FALSE;
    }

    __try {
        InitializeCriticalSection(&NatInterfaceLock);
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        DeleteCriticalSection(&NatGlobalInfoLock);
        DeleteComponentReference(&NatComponentReference);
        return FALSE;
    }

    ZeroMemory(&NatSupportFunctions, sizeof(NatSupportFunctions));

    return TRUE;

} // NatInitializeModule


ULONG
APIENTRY
NatRmStartProtocol(
    HANDLE NotificationEvent,
    PSUPPORT_FUNCTIONS SupportFunctions,
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to indicate the component's operation should begin.

Arguments:

    NotificationEvent - event on which we notify the router-manager
        about asynchronous occurrences

    SupportFunctions - functions for initiating router-related operations

    GlobalInfo - configuration for the component

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error = NO_ERROR;
    ULONG Size;

    PROFILE("NatRmStartProtocol");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER); }

    do {

        //
        // Copy the global configuration
        //

        EnterCriticalSection(&NatGlobalInfoLock);

        Size = 
            FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
            ((PIP_NAT_GLOBAL_INFO)GlobalInfo)->Header.Size;
        NatGlobalInfo = reinterpret_cast<PIP_NAT_GLOBAL_INFO>(NH_ALLOCATE(Size));
        if (!NatGlobalInfo) {
            LeaveCriticalSection(&NatGlobalInfoLock);
            NhTrace(
                TRACE_FLAG_INIT,
                "NatRmStartProtocol: cannot allocate global info"
                );
            NhErrorLog(
                IP_NAT_LOG_ALLOCATION_FAILED,
                0,
                "%d",
                Size
                );
            Error = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        CopyMemory(NatGlobalInfo, GlobalInfo, Size);
        LeaveCriticalSection(&NatGlobalInfoLock);

        //
        // Save the notification event and the support functions
        //

        NatNotificationEvent = NotificationEvent;

        EnterCriticalSection(&NatInterfaceLock);
        if (!SupportFunctions) {
            ZeroMemory(&NatSupportFunctions, sizeof(NatSupportFunctions));
        } else {
            CopyMemory(
                &NatSupportFunctions,
                SupportFunctions,
                sizeof(*SupportFunctions)
                );
        }
        LeaveCriticalSection(&NatInterfaceLock);

        //
        // Attempt to load and start the NAT driver.
        //

        Error = NatLoadDriver(
                    &NatFileHandle,
                    reinterpret_cast<PIP_NAT_GLOBAL_INFO>(GlobalInfo)
                    );

        NhUpdateApplicationSettings();
        NatInstallApplicationSettings();

        InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 0);

    } while (FALSE);

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmStartProtocol


ULONG
APIENTRY
NatRmStartComplete(
    VOID
    )

/*++

Routine Description:

    This routine is invoked when the router has finished adding the initial
    configuration

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    return NO_ERROR;
} // NatRmStartComplete


ULONG
APIENTRY
NatRmStopProtocol(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to stop the protocol.

Arguments:

    none.

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PLIST_ENTRY Link;
    PNAT_APP_ENTRY pAppEntry;
    //
    // Reference the module to make sure it's running
    //

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    NatStopConnectionManagement();

    EnterCriticalSection(&NhLock);

    //
    // Free application list
    //

    NhFreeApplicationSettings();
    
    LeaveCriticalSection(&NhLock);

    //
    // Close our handle to the driver, thus cancelling all outstanding I/O.
    //

    EnterCriticalSection(&NatInterfaceLock);
    NtClose(NatFileHandle);
    NatFileHandle = NULL;
    LeaveCriticalSection(&NatInterfaceLock);

    //
    // Drop the initial reference to cause a cleanup
    //

    ReleaseInitialComponentReference(&NatComponentReference);

    return DEREFERENCE_NAT() ? NO_ERROR : ERROR_PROTOCOL_STOP_PENDING;

} // NatRmStopProtocol


ULONG
APIENTRY
NatRmAddInterface(
    PWCHAR Name,
    ULONG Index,
    NET_INTERFACE_TYPE Type,
    ULONG MediaType,
    USHORT AccessType,
    USHORT ConnectionType,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to add an interface to the component.

Arguments:

    Name - the name of the interface (unused)

    Index - the index of the interface

    Type - the type of the interface

    InterfaceInfo - the configuration information for the interface

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmAddInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatCreateInterface(
            Index,
            Type,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmAddInterface


ULONG
APIENTRY
NatRmDeleteInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to delete an interface from the component.

Arguments:

    Index - the index of the interface

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmDeleteInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatDeleteInterface(
            Index
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmDeleteInterface


ULONG
APIENTRY
NatRmGetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS* Event,
    OUT MESSAGE* Result
    )

/*++

Routine Description:

    This routine is invoked to retrieve an event message from the component.
    The only event message we generate is the 'ROUTER_STOPPED' message.

Arguments:

    Event - receives the generated event

    Result - receives the associated result

Return Value:

    ULONG - Win32 status code.

--*/

{
    PROFILE("NatRmGetEventMessage");

    if (InterlockedExchange(reinterpret_cast<LPLONG>(&NatProtocolStopped), 0)) {
        *Event = ROUTER_STOPPED;
        return NO_ERROR;
    }

    return ERROR_NO_MORE_ITEMS;

} // NatRmGetEventMessage


ULONG
APIENTRY
NatRmGetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    IN OUT PULONG InterfaceInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be queried

    InterfaceInfo - receives the query results

    InterfaceInfoSize - receives the amount of data retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmGetInterfaceInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatQueryInterface(
            Index,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo,
            InterfaceInfoSize
            );
    *StructureSize = *InterfaceInfoSize;
    if (StructureCount) {*StructureCount = 1;}
    
    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmGetInterfaceInfo


ULONG
APIENTRY
NatRmSetInterfaceInfo(
    ULONG Index,
    PVOID InterfaceInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the component's per-interface
    configuration.

Arguments:

    Index - the index of the interface to be updated

    InterfaceInfo - supplies the new configuration

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmSetInterfaceInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error = 
        NatConfigureInterface(
            Index,
            (PIP_NAT_INTERFACE_INFO)InterfaceInfo
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmSetInterfaceInfo


ULONG
APIENTRY
NatRmInterfaceStatus(
    ULONG Index,
    BOOL InterfaceActive,
    ULONG StatusType,
    PVOID StatusInfo
    )

/*++

Routine Description:

    This routine is invoked to bind/unbind, enable/disable an interface

Arguments:

    Index - the interface to be bound

    InterfaceActive - whether the interface is active

    StatusType - type of status being changed (bind or enabled)

    StatusInfo - Info pertaining to the state being changed

Return Value:

    ULONG - Win32 Status code

Environment:

    The routine runs in the context of an IP router-manager thread.
    
--*/

{
    ULONG Error = NO_ERROR;

    switch(StatusType) {
        case RIS_INTERFACE_ADDRESS_CHANGE: {
            PIP_ADAPTER_BINDING_INFO BindInfo =
                (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if (BindInfo->AddressCount) {
                Error = NatRmBindInterface(Index, StatusInfo);
            } else {
                Error = NatRmUnbindInterface(Index);
            }
            break;
        }

        case RIS_INTERFACE_ENABLED: {
            Error = NatRmEnableInterface(Index);
            break;
        }

        case RIS_INTERFACE_DISABLED: {
            Error = NatRmDisableInterface(Index);
            break;
        }

    }

    return Error;
    
} // NatRmInterfaceStatus


ULONG
NatRmBindInterface(
    ULONG Index,
    PVOID BindingInfo
    )

/*++

Routine Description:

    This routine is invoked to bind an interface to its IP address(es).

Arguments:

    Index - the interface to be bound

    BindingInfo - the addressing information

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmBindInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatBindInterface(
            Index,
            NULL,
            (PIP_ADAPTER_BINDING_INFO)BindingInfo,
            (ULONG)-1
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmBindInterface


ULONG
NatRmUnbindInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to unbind an interface from its IP address(es).

Arguments:

    Index - the interface to be unbound

Return Value:

    ULONG - Win32 status code.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PROFILE("NatRmUnbindInterface");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    Error =
        NatUnbindInterface(
            Index,
            NULL
            );

    DEREFERENCE_NAT_AND_RETURN(Error);

} // NatRmUnbindInterface


ULONG
NatRmEnableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to enable operation on an interface.
    The NAT ignores the invocation.

Arguments:

    none unused.

Return Value:

    NO_ERROR.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("NatRmEnableInterface");

    return NO_ERROR;

} // NatRmEnableInterface


ULONG
NatRmDisableInterface(
    ULONG Index
    )

/*++

Routine Description:

    This routine is invoked to disable operation on an interface.
    The NAT ignores the invocation.

Arguments:

    none unused.

Return Value:

    NO_ERROR.

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    PROFILE("NatRmDisableInterface");

    return NO_ERROR;

} // NatRmDisableInterface


ULONG
APIENTRY
NatRmGetGlobalInfo(
    PVOID GlobalInfo,
    IN OUT PULONG GlobalInfoSize,
    IN OUT PULONG StructureVersion,
    IN OUT PULONG StructureSize,
    IN OUT PULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to retrieve the configuration for the component.

Arguments:

    GlobalInfo - receives the configuration

    GlobalInfoSize - receives the size of the configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Size;
    PROFILE("NatRmGetGlobalInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfoSize || (*GlobalInfoSize && !GlobalInfo)) {
        DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER);
    } else if (!NatGlobalInfo) {
        *GlobalInfoSize = 0;
        DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    }

    EnterCriticalSection(&NatGlobalInfoLock);
    Size =
        FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) + NatGlobalInfo->Header.Size;
    if (*GlobalInfoSize < Size) {
        LeaveCriticalSection(&NatGlobalInfoLock);
        *StructureSize = *GlobalInfoSize = Size;
        if (StructureCount) {*StructureCount = 1;}
        DEREFERENCE_NAT_AND_RETURN(ERROR_INSUFFICIENT_BUFFER);
    }
    CopyMemory(GlobalInfo, NatGlobalInfo, Size);
    LeaveCriticalSection(&NatGlobalInfoLock);
    *StructureSize = *GlobalInfoSize = Size;
    if (StructureCount) {*StructureCount =1;}

    DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    
} // NatRmGetGlobalInfo


ULONG
APIENTRY
NatRmSetGlobalInfo(
    PVOID GlobalInfo,
    ULONG StructureVersion,
    ULONG StructureSize,
    ULONG StructureCount
    )

/*++

Routine Description:

    This routine is invoked to change the configuration for the component.

Arguments:

    GlobalInfo - the new configuration

Return Value:

    ULONG - Win32 status code

Environment:

    The routine runs in the context of an IP router-manager thread.

--*/

{
    ULONG Error;
    PIP_NAT_GLOBAL_INFO NewInfo;
    ULONG Size;

    PROFILE("NatRmSetGlobalInfo");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (!GlobalInfo) { DEREFERENCE_NAT_AND_RETURN(ERROR_INVALID_PARAMETER); }

    Size =
        FIELD_OFFSET(IP_NAT_GLOBAL_INFO, Header) +
        ((PIP_NAT_GLOBAL_INFO)GlobalInfo)->Header.Size;
    NewInfo = reinterpret_cast<PIP_NAT_GLOBAL_INFO>(NH_ALLOCATE(Size));
    if (!NewInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NatRmSetGlobalInfo: error reallocating global info"
            );
        NhErrorLog(
            IP_NAT_LOG_ALLOCATION_FAILED,
            0,
            "%d",
            Size
            );
        DEREFERENCE_NAT_AND_RETURN(ERROR_NOT_ENOUGH_MEMORY);
    }
    CopyMemory(NewInfo, GlobalInfo, Size);

    Error =
        NatConfigureDriver(
            NewInfo
            );

    if (Error) {
        NH_FREE(NewInfo);
    } else {
        EnterCriticalSection(&NatGlobalInfoLock);
        NH_FREE(NatGlobalInfo);
        NatGlobalInfo = NewInfo;
#ifdef DIALIN_SHARING
        if (!(NatGlobalInfo->Flags & IP_NAT_ALLOW_RAS_CLIENTS) &&
            REFERENCE_NAT()) {
            //
            // Clean up any dial-in clients allowed access through the NAT
            //
            Error = QueueWorkItem(NatpProcessClientWorkerRoutine, NULL, TRUE);
            if (Error) { DEREFERENCE_NAT(); }
        }
#endif
        LeaveCriticalSection(&NatGlobalInfoLock);
    }

    NatRemoveApplicationSettings();
    NhUpdateApplicationSettings();
    NatInstallApplicationSettings();

    DEREFERENCE_NAT_AND_RETURN(Error);
    
} // NatRmSetGlobalInfo


ULONG
APIENTRY
NatRmMibCreate(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibDelete(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGet(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )

/*++

Routine Description:

    The NAT exposes two items to the MIB; its per-interface statistics,
    and its per-interface mapping table.

Arguments:

    InputDataSize - the MIB query data size

    InputData - specifies the MIB object to be retrieved

    OutputDataSize - the MIB response data size

    OutputData - receives the MIB object retrieved

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    ULONG Index;
    PIP_NAT_MIB_QUERY Oidp;

    PROFILE("NatRmMibGet");

    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    if (InputDataSize < sizeof(*Oidp) || !OutputDataSize) {
        Error = ERROR_INVALID_PARAMETER;
    } else {
        Oidp = (PIP_NAT_MIB_QUERY)InputData;
        switch(Oidp->Oid) {
            case IP_NAT_INTERFACE_STATISTICS_OID: {
                if (*OutputDataSize <
                        sizeof(*Oidp) + sizeof(IP_NAT_INTERFACE_STATISTICS)) {
                    *OutputDataSize =
                        sizeof(*Oidp) + sizeof(IP_NAT_INTERFACE_STATISTICS);
                    Error = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Index = Oidp->Index[0];
                    Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                    Oidp->Oid = IP_NAT_INTERFACE_STATISTICS_OID;
                    *OutputDataSize -= sizeof(*Oidp);
                    Error =
                        NatQueryStatisticsInterface(
                            Index,
                            (PIP_NAT_INTERFACE_STATISTICS)Oidp->Data,
                            OutputDataSize
                            );
                    *OutputDataSize += sizeof(*Oidp);
                }
                break;
            }
            case IP_NAT_INTERFACE_MAPPING_TABLE_OID: {
                PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable = NULL;
                Index =  Oidp->Index[0];
                Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                if (Oidp) {
                    Oidp->Oid = IP_NAT_INTERFACE_MAPPING_TABLE_OID;
                    EnumerateTable =
                        (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)Oidp->Data;
                }
                if (*OutputDataSize) { *OutputDataSize -= sizeof(*Oidp); }
                Error =
                    NatQueryInterfaceMappingTable(
                        Index,
                        EnumerateTable,
                        OutputDataSize
                        );
                *OutputDataSize += sizeof(*Oidp);
                break;
            }
            case IP_NAT_MAPPING_TABLE_OID: {
                PIP_NAT_ENUMERATE_SESSION_MAPPINGS EnumerateTable = NULL;
                Oidp = (PIP_NAT_MIB_QUERY)OutputData;
                if (Oidp) {
                    Oidp->Oid = IP_NAT_MAPPING_TABLE_OID;
                    EnumerateTable =
                        (PIP_NAT_ENUMERATE_SESSION_MAPPINGS)Oidp->Data;
                }
                if (*OutputDataSize) { *OutputDataSize -= sizeof(*Oidp); }
                Error =
                    NatQueryMappingTable(
                        EnumerateTable,
                        OutputDataSize
                        );
                *OutputDataSize += sizeof(*Oidp);
                break;
            }
            default: {
                NhTrace(
                    TRACE_FLAG_NAT,
                    "NatRmMibGet: oid %d invalid",
                    Oidp->Oid
                    );
                Error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
    }

    DEREFERENCE_NAT_AND_RETURN(Error);
}


ULONG
APIENTRY
NatRmMibSet(
    ULONG InputDataSize,
    PVOID InputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGetFirst(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}

ULONG
APIENTRY
NatRmMibGetNext(
    ULONG InputDataSize,
    PVOID InputData,
    OUT PULONG OutputDataSize,
    OUT PVOID OutputData
    )
{
    return ERROR_NOT_SUPPORTED;
}


ULONG
APIENTRY
NatRmConnectClient(
    ULONG Index,
    PVOID ClientAddress
    )

/*++

Routine Description:

    This routine is called upon establishment of an incoming connection
    by a RAS client.
    We automatically enable NAT access for incoming clients who connect
    over direct-cable/infra-red connections.

Arguments:

    Index - unused

    ClientAddress - unused

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmConnectClient");
#ifdef DIALIN_SHARING
    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    EnterCriticalSection(&NatGlobalInfoLock);
    if (!(NatGlobalInfo->Flags & IP_NAT_ALLOW_RAS_CLIENTS)) {
        LeaveCriticalSection(&NatGlobalInfoLock);
        DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    }
    LeaveCriticalSection(&NatGlobalInfoLock);

    NatStartConnectionManagement();
    Error = QueueWorkItem(NatpProcessClientWorkerRoutine, NULL, TRUE);
    if (Error) { DEREFERENCE_NAT(); }
#endif
    return NO_ERROR;
}


ULONG
APIENTRY
NatRmDisconnectClient(
    ULONG Index,
    PVOID ClientAddress
    )

/*++

Routine Description:

    This routine is called upon disconnection of a RAS client.
    It cleans up NAT access if it was enabled for the disconnected client.

Arguments:

    Index - unused

    ClientAddress - unused

Return Value:

    ULONG - Win32 status code.

--*/

{
    ULONG Error;
    PROFILE("NatRmDisconnectClient");
#ifdef DIALIN_SHARING
    REFERENCE_NAT_OR_RETURN(ERROR_CAN_NOT_COMPLETE);

    EnterCriticalSection(&NatGlobalInfoLock);
    if (!(NatGlobalInfo->Flags & IP_NAT_ALLOW_RAS_CLIENTS)) {
        LeaveCriticalSection(&NatGlobalInfoLock);
        DEREFERENCE_NAT_AND_RETURN(NO_ERROR);
    }
    LeaveCriticalSection(&NatGlobalInfoLock);

    NatStartConnectionManagement();
    Error = QueueWorkItem(NatpProcessClientWorkerRoutine, NULL, TRUE);
    if (Error) { DEREFERENCE_NAT(); }
#endif
    return NO_ERROR;
}


VOID APIENTRY
NatpProcessClientWorkerRoutine(
    PVOID Context
    )
{
#ifdef DIALIN_SHARING
    NatProcessClientConnection();
#endif
    DEREFERENCE_NAT();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\svcmain.cpp ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    svcmain.c

Abstract:

    This module contains code for the module's shared-access mode,
    in which the module runs as a service rather than as a routing component.

Author:

    Abolade Gbadegesin (aboladeg)   31-Aug-1998

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <ras.h>
#include <rasuip.h>
#include <raserror.h>
#include <rasman.h>
#include "beacon.h"

HANDLE NhpAddressChangeEvent = NULL;
OVERLAPPED NhpAddressChangeOverlapped;
HANDLE NhpAddressChangeWaitHandle = NULL;
SERVICE_STATUS NhpServiceStatus;
SERVICE_STATUS_HANDLE NhpServiceStatusHandle = 0;
PIP_ADAPTER_BINDING_INFO NhpSharedPrivateLanBindingInfo = NULL;
GUID NhpSharedPrivateLanGuid;
ULONG NhpSharedPrivateLanIndex = (ULONG)-1;
HANDLE NhpStopDhcpEvent = NULL;
HANDLE NhpStopDnsEvent = NULL;
#ifndef NO_FTP_PROXY
	HANDLE NhpStopFtpEvent = NULL;
#endif
HANDLE NhpStopAlgEvent = NULL;
HANDLE NhpStopH323Event = NULL;
HANDLE NhpStopNatEvent = NULL;
BOOLEAN NhpRasmanReferenced = FALSE;
BOOLEAN NhpFwLoggingInitialized = FALSE;
BOOL NhPolicyAllowsFirewall = TRUE;
BOOL NhPolicyAllowsSharing = TRUE;
BOOLEAN NoLocalDns = TRUE;  //whether DNS server is running or going to run on local host
BOOLEAN NhpNoLocalDhcp = TRUE; //whether DHCP server is running or goint to run on local host
BOOLEAN NhpQoSEnabled = FALSE;
IUdpBroadcastMapper *NhpUdpBroadcastMapper = NULL;
BOOLEAN NhpClassObjectsRegistered = FALSE;


//
// Pointer to the GlobalInterfaceTable for the process
//

IGlobalInterfaceTable *NhGITp = NULL;

//
// GIT cookie for the IHNetCfgMgr instance
//

DWORD NhCfgMgrCookie = 0;

const TCHAR c_szDnsServiceName[] = TEXT("DNS");
const TCHAR c_szDhcpServiceName[] = TEXT("DHCPServer");

ULONG
NhpEnableQoSWindowSizeAdjustment(
    BOOLEAN fEnable
    );

VOID
NhpStartAddressChangeNotification(
    VOID
    );

VOID
NhpStopAddressChangeNotification(
    VOID
    );

VOID
NhpUpdateConnectionsFolder(
    VOID
    );

VOID
NhpUpdatePolicySettings(
    VOID
    );


HRESULT
NhGetHNetCfgMgr(
    IHNetCfgMgr **ppCfgMgr
    )

/*++

Routine Description:

    This routine obtains a pointer to the home networking configuration
    manager.

Arguments:

    ppCfgMgr - receives the IHNetCfgMgr pointer. The caller must release
               this pointer.

Return Value:

    standard HRESULT

Environment:

COM must be initialized on the calling thread

--*/

{
    HRESULT hr = S_OK;
    
    if (NULL == NhGITp)
    {
        EnterCriticalSection(&NhLock);

        if (NULL == NhGITp)
        {
            IHNetCfgMgr *pCfgMgr;
            
            //
            // Create the global interface table
            //
            
            hr = CoCreateInstance(
                    CLSID_StdGlobalInterfaceTable,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IGlobalInterfaceTable, &NhGITp)
                    );

            if (SUCCEEDED(hr))
            {
                //
                // Create the homenet configuration manager
                //
                
                hr = CoCreateInstance(
                        CLSID_HNetCfgMgr,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IHNetCfgMgr, &pCfgMgr)
                        );

                if (FAILED(hr))
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NhGetHNetCfgMgr: Unable to create HNetCfgMgr (0x%08x)",
                        hr
                        );
                }
            }
            else
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhGetHNetCfgMgr: Unable to create GIT (0x%08x)",
                    hr
                    );
            }

            if (SUCCEEDED(hr))
            {
                //
                // Store the CfgMgr pointer in the GIT
                //

                hr = NhGITp->RegisterInterfaceInGlobal(
                                pCfgMgr,
                                IID_IHNetCfgMgr,
                                &NhCfgMgrCookie
                                );

                pCfgMgr->Release();

                if (FAILED(hr))
                {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "NhGetHNetCfgMgr: Unable to register HNetCfgMgr (0x%08x)",
                        hr
                        );
                }
            }
        }
        
        LeaveCriticalSection(&NhLock);
    }

    if (SUCCEEDED(hr))
    {
        hr = NhGITp->GetInterfaceFromGlobal(
                NhCfgMgrCookie,
                IID_PPV_ARG(IHNetCfgMgr, ppCfgMgr)
                );
    }

    return hr;
} // NhGetHNetCfgMgr


ULONG
NhMapGuidToAdapter(
    PWCHAR Guid
    )

/*++

Routine Description:

    This routine is invoked to map a GUID to an adapter index.
    It does so by querying 'GetInterfaceInfo' for the array of interfaces,
    which contains the GUID and adapter index for each interface.

Arguments:

    Guid - the GUID to be mapped to an adapter index.

Return Value:

    ULONG - the required adapter index

--*/

{
    ULONG AdapterIndex = (ULONG)-1;
    ULONG i;
    ULONG GuidLength;
    PIP_INTERFACE_INFO Info;
    PWCHAR Name;
    ULONG NameLength;
    ULONG Size;
    PROFILE("NhMapGuidToAdapter");
    Size = 0;
    GuidLength = lstrlenW(Guid);
    if (GetInterfaceInfo(NULL, &Size) == ERROR_INSUFFICIENT_BUFFER) {
        Info = reinterpret_cast<PIP_INTERFACE_INFO>(
                HeapAlloc(GetProcessHeap(), 0, Size)
                );
        if (Info) {
            if (GetInterfaceInfo(Info, &Size) == NO_ERROR) {
                for (i = 0; i < (ULONG)Info->NumAdapters; i++) {
                    NameLength = lstrlenW(Info->Adapter[i].Name);
                    if (NameLength < GuidLength) { continue; }
                    Name = Info->Adapter[i].Name + (NameLength - GuidLength);
                    if (lstrcmpiW(Guid, Name) == 0) {
                        AdapterIndex = Info->Adapter[i].Index;
                        break;
                    }
                }
            }
            HeapFree(GetProcessHeap(), 0, Info);
        }
    }
    return AdapterIndex;
} // NhMapGuidToAdapter


VOID NTAPI
NhpAddressChangeCallbackRoutine(
    PVOID Context,
    BOOLEAN TimedOut
    )

/*++

Routine Description:

    This routine is invoked when a change to a local address is signalled.
    It is responsible for updating the bindings of the private and public
    interfaces, and re-requesting change notification.

Arguments:

    none used.

Return Value:

    none.

--*/

{
    PROFILE("NhpAddressChangeCallbackRoutine");
    NtSetEvent(NatConnectionNotifyEvent, NULL);
    NhpStartAddressChangeNotification();

} // NhpAddressChangeCallbackRoutine


VOID
NhpDeletePrivateInterface(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to remove the private interface
    from each shared-access component.

Arguments:

    none.

Return Value:

    none.

--*/

{
    PROFILE("NhpDeletePrivateInterface");

    if (NhpStopDnsEvent) { DnsRmDeleteInterface(0); }
    if (NhpStopDhcpEvent) { DhcpRmDeleteInterface(0); }
#ifndef NO_FTP_PROXY
    if (NhpStopFtpEvent) { FtpRmDeleteInterface(0); }
#endif
    if (NhpStopAlgEvent) { AlgRmDeleteInterface(0); }
    if (NhpStopH323Event) { H323RmDeleteInterface(0); }
    if (NhpStopNatEvent) { NatRmDeleteInterface(0); }
    RtlZeroMemory(&NhpSharedPrivateLanGuid, sizeof(NhpSharedPrivateLanGuid));
} // NhpDeletePrivateInterface


ULONG
NhpEnableQoSWindowSizeAdjustment(
    BOOLEAN fEnable
    )

/*++

Routine Description:

    Instructs PSCHED to enable or disable window size adjustment.

Arguments:

    fEnable -- TRUE if adjustments are to be enabled; FALSE, to be disabled

Return Value:

    ULONG -- Win32 error

--*/

{
    ULONG ulError = ERROR_SUCCESS;
    DWORD dwValue;
    WMIHANDLE hDataBlock = NULL;
    GUID qosGuid;
    
    PROFILE("NhpEnableQoSWindowSizeAdjustment");

    do
    {
        //
        // WmiOpenBlock doesn't take a const guid, se we need to
        // copy the defind value
        //

        CopyMemory(&qosGuid, &GUID_QOS_ENABLE_WINDOW_ADJUSTMENT, sizeof(GUID));

        
        //
        // Obtain a handle to the data block
        //

        ulError =
            WmiOpenBlock(
                &qosGuid,
                GENERIC_WRITE,
                &hDataBlock
                );

        if (ERROR_SUCCESS != ulError)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableQoSWindowSizeAdjustment: WmiOpenBlock = %u",
                ulError
                );
            break;                
        }

        //
        // Set the value for the data block
        //

        dwValue = (fEnable ? 1 : 0);

        ulError = 
            WmiSetSingleInstanceW(
                hDataBlock,
                L"PSCHED",
                0,
                sizeof(dwValue),
                &dwValue
                );

        if (ERROR_SUCCESS != ulError)
        {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhpEnableQoSWindowSizeAdjustment: WmiSetSingleInstanceW = %u",
                ulError
                );
            break;                
        }

    } while (FALSE);

    if (NULL != hDataBlock)
    {
        WmiCloseBlock(hDataBlock);
    }

    return ulError;    
} // NhpEnableQoSWindowSizeAdjustment


VOID
NhpStartAddressChangeNotification(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to request notifications of changes
    to local IP addresses. The notifications are signalled on an event
    which is created in this routine, and are acted on in a callback routine
    which is registered in this routine.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error;
    NTSTATUS status;
    HANDLE TcpipHandle;
    PROFILE("NhpStartAddressChangeNotification");

    //
    // Create an event on which to receive notifications
    // and register a callback routine to be invoked if the event is signalled.
    // Then request notification of address changes on the event.
    //

    do {

        EnterCriticalSection(&NhLock);

        if (!NhpAddressChangeEvent) {
            status =
                NtCreateEvent(
                    &NhpAddressChangeEvent,
                    EVENT_ALL_ACCESS,
                    NULL,
                    SynchronizationEvent,
                    FALSE
                    );
            if (!NT_SUCCESS(status)) { break; }
    
            status =
                RtlRegisterWait(
                    &NhpAddressChangeWaitHandle,
                    NhpAddressChangeEvent,
                    NhpAddressChangeCallbackRoutine,
                    NULL,
                    INFINITE,
                    0
                    );
            if (!NT_SUCCESS(status)) { break; }
        }
    
        ZeroMemory(&NhpAddressChangeOverlapped, sizeof(OVERLAPPED));
        NhpAddressChangeOverlapped.hEvent = NhpAddressChangeEvent;

        Error = NotifyAddrChange(&TcpipHandle, &NhpAddressChangeOverlapped);
        if (Error != ERROR_IO_PENDING) { break; }

        LeaveCriticalSection(&NhLock);
        return;

    } while(FALSE);

    //
    // A failure has occurred, so cleanup and quit.
    // We proceed in this case without notification of address changes.
    //

    NhpStopAddressChangeNotification();
    LeaveCriticalSection(&NhLock);

} // NhpStartAddressChangeNotification


VOID
NhpStopAddressChangeNotification(
    VOID
    )

/*++

Routine Description:

    This routine is called to stop notification of local IP address changes,
    and to clean up resources used for handling notifications.

Arguments:

    none.

Return Value:

    none.

--*/

{
    EnterCriticalSection(&NhLock);
    if (NhpAddressChangeWaitHandle) {
        RtlDeregisterWait(NhpAddressChangeWaitHandle);
        NhpAddressChangeWaitHandle = NULL;
    }
    if (NhpAddressChangeEvent) {
        NtClose(NhpAddressChangeEvent);
        NhpAddressChangeEvent = NULL;
    }
    LeaveCriticalSection(&NhLock);
} // NhpStopAddressChangeNotification


VOID
NhpUpdateConnectionsFolder(
    VOID
    )

/*++

Routine Description:

    This routine is called to refresh the connections folder UI.

Arguments:

    None.
    
Return Value:

    None.

Environment:

    COM must be initialized on the calling thread.

--*/

{
    HRESULT hr;
    INetConnectionRefresh *pNetConnectionRefresh;

    hr = CoCreateInstance(
            CLSID_ConnectionManager,
            NULL,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_PPV_ARG(INetConnectionRefresh, &pNetConnectionRefresh)
            );

    if (SUCCEEDED(hr))
    {
        pNetConnectionRefresh->RefreshAll();
        pNetConnectionRefresh->Release();
    }
} // NhpUpdateConnectionsFolder


VOID
NhpUpdatePolicySettings(
    VOID
    )

{
    INetConnectionUiUtilities *pNetConnUiUtil;
    HRESULT hr;
    BOOL fPolicyAllowsFirewall;
    BOOL fPolicyAllowsSharing;
    
    hr = CoCreateInstance(
                CLSID_NetConnectionUiUtilities,
                NULL,
                CLSCTX_ALL,
                IID_PPV_ARG(INetConnectionUiUtilities, &pNetConnUiUtil)
                );

    if (SUCCEEDED(hr))
    {
        fPolicyAllowsFirewall =
            pNetConnUiUtil->UserHasPermission(NCPERM_PersonalFirewallConfig);
        fPolicyAllowsSharing =
            pNetConnUiUtil->UserHasPermission(NCPERM_ShowSharedAccessUi);

        pNetConnUiUtil->Release();
    }
    else
    {
        //
        // On failure assume that policy permits everything.
        //

        fPolicyAllowsFirewall = TRUE;
        fPolicyAllowsSharing = TRUE;

        NhTrace(
            TRACE_FLAG_INIT,
            "NhpUpdatePolicySettings: Unable to create INetConnectionUiUtilities (0x%08x)",
            hr
            );
    }

    //
    // Update global variables w/ new settings
    //

    InterlockedExchange(
        reinterpret_cast<LPLONG>(&NhPolicyAllowsFirewall),
        static_cast<LONG>(fPolicyAllowsFirewall)
        );

    InterlockedExchange(
        reinterpret_cast<LPLONG>(&NhPolicyAllowsSharing),
        static_cast<LONG>(fPolicyAllowsSharing)
        );

    NhTrace(
        TRACE_FLAG_INIT,
        "NhpUpdatePolicySettings: NhPolicyAllowsFirewall=%i, NhPolicyAllowsSharing=%i",
        NhPolicyAllowsFirewall,
        NhPolicyAllowsSharing
        );
    
} // NhpUpdatePolicySettings


BOOLEAN
NhQueryScopeInformation(
    PULONG Address,
    PULONG Mask
    )

/*++

Routine Description:

    This routine is called to retrieve information about the current scope
    for automatic addressing.

Arguments:

    Address - receives the address of the scope

    Mask - receives the network mask of the scope

Return Value:

    BOOLEAN - TRUE if successful, FALSE otherwise.

--*/

{
    EnterCriticalSection(&NhLock);
    if (0 == NhDhcpScopeAddress) {
        LeaveCriticalSection(&NhLock);
        return FALSE;
    } 

    *Address = NhDhcpScopeAddress;
    *Mask = NhDhcpScopeMask;
    LeaveCriticalSection(&NhLock);
    return TRUE;

} // NhQueryScopeInformation

ULONG NhpQueryServiceStartType(SC_HANDLE hService, DWORD * pdwStartType)
{
    ASSERT(hService);
    ASSERT(pdwStartType);

    ULONG Error = ERROR_SUCCESS;
    DWORD cbBuf = sizeof (QUERY_SERVICE_CONFIG) +
                              5 * (32 * sizeof(WCHAR));
    LPQUERY_SERVICE_CONFIG  pConfig  = NULL;

    pConfig = (LPQUERY_SERVICE_CONFIG) NH_ALLOCATE(cbBuf);
    if (!pConfig)
        return ERROR_NOT_ENOUGH_MEMORY;

    do {
        if (!QueryServiceConfig(hService, pConfig, cbBuf, &cbBuf))
        {
            Error = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
                NH_FREE(pConfig);
                pConfig = (LPQUERY_SERVICE_CONFIG) NH_ALLOCATE(cbBuf);
                if (NULL == pConfig)
                {
                    Error = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }


                if (!QueryServiceConfig(hService, pConfig, cbBuf, &cbBuf))
                {
                    Error = GetLastError();
                    break;
                }
            }
            else
            {
                break;
            }
        }

        Error = ERROR_SUCCESS;
        *pdwStartType = pConfig->dwStartType;

    } while(FALSE);

    if (pConfig)
        NH_FREE(pConfig);

    return Error;
}

BOOL NhpIsServiceRunningOrGoingToRun(SC_HANDLE hScm, LPCTSTR pSvcName)
{
    BOOL bRet = FALSE;
    SC_HANDLE hService = NULL;
    DWORD dwStartType = 0;

    hService = OpenService(hScm, pSvcName, SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);

    if (hService)
    {
        SERVICE_STATUS Status;
        ZeroMemory(&Status, sizeof(Status));

        if (ERROR_SUCCESS == NhpQueryServiceStartType(hService, &dwStartType) &&
             SERVICE_AUTO_START == dwStartType)
        {
            bRet = TRUE;
        }
        else if (QueryServiceStatus(hService, &Status) && 
             (SERVICE_RUNNING == Status.dwCurrentState || 
              SERVICE_START_PENDING == Status.dwCurrentState))
        {
            bRet = TRUE;
        }

        CloseServiceHandle(hService);
    }

    return bRet;
}

ULONG
NhStartICSProtocols(
    VOID
    )
    
/*++

Routine Description:

    This routine starts the DNS and DHCP modules.

Arguments:

    Argument* - count and array of arguments specified to the service

Return Value:

    none.

--*/

{
    ULONG Error;
    IP_AUTO_DHCP_GLOBAL_INFO DhcpInfo = {
        IPNATHLP_LOGGING_ERROR,
        0,
        7 * 24 * 60,
        DEFAULT_SCOPE_ADDRESS,
        DEFAULT_SCOPE_MASK,
        0
    };
    IP_DNS_PROXY_GLOBAL_INFO DnsInfo = {
        IPNATHLP_LOGGING_ERROR,
        IP_DNS_PROXY_FLAG_ENABLE_DNS,
        3
    };

    //
    // Get ICS settings to see if these should be started...
    //

    do {

        SC_HANDLE hScm = OpenSCManager(NULL, NULL, GENERIC_READ);
        
        //dont start the DNS module if DNS server is running on local host
        if (hScm) 
        {
            NoLocalDns = !NhpIsServiceRunningOrGoingToRun(hScm, c_szDnsServiceName);
        }

        if (NoLocalDns)
        {
            if (!(NhpStopDnsEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
                break;
            } else {
                Error =
                    DnsRmStartProtocol(
                        NhpStopDnsEvent,
                        NULL,
                        &DnsInfo,
                        IP_NAT_VERSION,
                        sizeof(DnsInfo),
                        1
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "ServiceMain: DnsRmStartProtocol=%d",
                        Error
                        );
                    CloseHandle(NhpStopDnsEvent); NhpStopDnsEvent = NULL; break;
                }
            }
        }

        //dont start the DHCP module if DNS server is running on local host
        
        if (hScm) 
        {
            NhpNoLocalDhcp = !NhpIsServiceRunningOrGoingToRun(hScm, c_szDhcpServiceName);
        }

        if (NhpNoLocalDhcp)
        {
            if (!(NhpStopDhcpEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
                break;
            } else {
                NhQueryScopeInformation(
                    &DhcpInfo.ScopeNetwork, &DhcpInfo.ScopeMask
                    );
                DhcpInfo.ScopeNetwork &= DhcpInfo.ScopeMask;
                Error =
                    DhcpRmStartProtocol(
                        NhpStopDhcpEvent,
                        NULL,
                        &DhcpInfo,
                        IP_NAT_VERSION,
                        sizeof(DhcpInfo),
                        1
                        );
                if (Error) {
                    NhTrace(
                        TRACE_FLAG_INIT,
                        "ServiceMain: DhcpRmStartProtocol=%d",
                        Error
                        );
                    CloseHandle(NhpStopDhcpEvent); NhpStopDhcpEvent = NULL; break;
                }
            }
        }


        if (hScm)
            CloseServiceHandle(hScm);

        //
        // Instruct QoS to enable window size adjustments. Any error that
        // occurs here is not propagated, as ICS will still work correctly
        // if this fails.
        //

        ULONG Error2 = NhpEnableQoSWindowSizeAdjustment(TRUE);
        if (ERROR_SUCCESS == Error2)
        {
            NhpQoSEnabled = TRUE;
        }

        //
        // Create the UDP broadcast mapper
        //

        HRESULT hr;
        CComObject<CUdpBroadcastMapper> *pUdpBroadcast;
        
        hr = CComObject<CUdpBroadcastMapper>::CreateInstance(&pUdpBroadcast);
        if (SUCCEEDED(hr))
        {
            pUdpBroadcast->AddRef();

            hr = pUdpBroadcast->Initialize(&NatComponentReference);
            if (SUCCEEDED(hr))
            {
                hr = pUdpBroadcast->QueryInterface(
                        IID_PPV_ARG(IUdpBroadcastMapper, &NhpUdpBroadcastMapper)
                        );
            }

            pUdpBroadcast->Release();
        }

        if (FAILED(hr))
        {
            Error = ERROR_CAN_NOT_COMPLETE;
            break;
        }
        
        //
        // Start the Beaconing Service
        //
        
        StartBeaconSvr();
        
        return NO_ERROR;
    } while (FALSE);

    return Error;
}


ULONG
NhStopICSProtocols(
    VOID
    )
    
/*++

Routine Description:

    This routine stops the "ICS" modules (DNS, DHCP, QoSWindow, Beacon etc.)

Arguments:

    none.

Return Value:

    none.

--*/

{
    ULONG Error = NO_ERROR;

    //
    // Stop the Beaconing Service
    //

    StopBeaconSvr();

    //
    // Cleanup the UDP broadcast mapper
    //

    if (NULL != NhpUdpBroadcastMapper)
    {
        NhpUdpBroadcastMapper->Shutdown();
        NhpUdpBroadcastMapper->Release();
        NhpUdpBroadcastMapper = NULL;
    }        

    //
    // Instruct QoS to disable window size adjustments
    //

    if (NhpQoSEnabled) {
        NhpEnableQoSWindowSizeAdjustment(FALSE);
        NhpQoSEnabled = FALSE;
    }
    
    //
    // Remove the private interface from each shared-access component
    //

    NhpDeletePrivateInterface();

    //
    // Stop DHCP followed by DNS
    //

    if (NhpStopDhcpEvent) {
        DhcpRmStopProtocol();
        WaitForSingleObject(NhpStopDhcpEvent, INFINITE);
        CloseHandle(NhpStopDhcpEvent); NhpStopDhcpEvent = NULL;
    }
    
    if (NhpStopDnsEvent) {
        DnsRmStopProtocol();
        WaitForSingleObject(NhpStopDnsEvent, INFINITE);
        CloseHandle(NhpStopDnsEvent); NhpStopDnsEvent = NULL;
    }
        
    return Error;
}


ULONG
NhUpdatePrivateInterface(
    VOID
    )

/*++

Routine Description:

    This routine is invoked to add the private interface to each
    shared-access component. It is also invoked when the private interface
    is already added, but some change has occurred which requires that it
    be updated (e.g. IP address change).
    
Arguments:

    none.

Return Value:

    Win32 error.

--*/

{
    ULONG AdapterIndex;
    PIP_ADAPTER_BINDING_INFO BindingInfo;
    ULONG Error;
    ULONG Count;
    GUID *pLanGuid;
    HRESULT hr;
    IHNetCfgMgr *pCfgMgr;
    IHNetIcsSettings *pIcsSettings;
    IEnumHNetIcsPrivateConnections *pEnum;
    IHNetIcsPrivateConnection *pIcsConn;
    IHNetConnection *pConn;
    
    IP_NAT_INTERFACE_INFO NatInfo =
    {
        0,
        0,
        { IP_NAT_VERSION, sizeof(RTR_INFO_BLOCK_HEADER), 0, { 0, 0, 0, 0 }}
    };
    UNICODE_STRING UnicodeString;



    PROFILE("NhUpdatePrivateInterface");

    //
    // We begin by reading the GUID from the configuration store,
    // and we then map that GUID to an adapter index.
    // Using that adapter index, we obtain the binding information
    // for the private interface.
    // We can then determine whether a change has occurred
    // by comparing the previous and new GUID and binding information.
    //

    //
    // Get the CfgMgr pointer out of the GIT
    //

    hr = NhGetHNetCfgMgr(&pCfgMgr);

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: GetInterfaceFromGlobal=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the ICS settings interface
    //

    hr = pCfgMgr->QueryInterface(IID_PPV_ARG(IHNetIcsSettings, &pIcsSettings));
    pCfgMgr->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QI for IHNetIcsSettings=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the enumeration of the ICS private interfaces
    //

    hr = pIcsSettings->EnumIcsPrivateConnections(&pEnum);
    pIcsSettings->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: EnumIcsPrivateConnections=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the private connection
    //

    hr = pEnum->Next(1, &pIcsConn, &Count);
    pEnum->Release();

    if (FAILED(hr) || 1 != Count)
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: pEnum->Next=0x%08x, Count=%d",
            hr,
            Count
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // QI for the IHNetConnection
    //

    hr = pIcsConn->QueryInterface(IID_PPV_ARG(IHNetConnection, &pConn));
    pIcsConn->Release();

    if (FAILED(hr))
    {   
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QI for IHNetConnection=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }

    //
    // Get the GUID for the connection
    //

    hr = pConn->GetGuid(&pLanGuid);
    pConn->Release();

    if (FAILED(hr))
    {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: GetGuid=0x%08x",
            hr
            );
        return ERROR_CAN_NOT_COMPLETE;
    }
        
    //
    // Determine the adapter-index corresponding to the GUID
    //

    RtlStringFromGUID(*pLanGuid, &UnicodeString);
    AdapterIndex = NhMapGuidToAdapter(UnicodeString.Buffer);
    RtlFreeUnicodeString(&UnicodeString);
    if (AdapterIndex == (ULONG)-1) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: MapGuidToAdapter"
            );
        CoTaskMemFree(pLanGuid);
        return ERROR_CAN_NOT_COMPLETE;
    }
    
    //
    // Retrieve the binding information for the adapter
    //

    BindingInfo = NhQueryBindingInformation(AdapterIndex);
    if (!BindingInfo) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: QueryBindingInformation failed(2)\n"
            );
        CoTaskMemFree(pLanGuid);
        return ERROR_NO_SUCH_INTERFACE;
    }

    //
    // See if any change has occurred which requires an update.
    //

    if (RtlEqualMemory(pLanGuid, &NhpSharedPrivateLanGuid, sizeof(GUID)) &&
        AdapterIndex == NhpSharedPrivateLanIndex &&
        NhpSharedPrivateLanBindingInfo &&
        BindingInfo->AddressCount ==
        NhpSharedPrivateLanBindingInfo->AddressCount &&
        BindingInfo->AddressCount &&
        RtlEqualMemory(
            &BindingInfo->Address[0],
            &NhpSharedPrivateLanBindingInfo->Address[0],
            sizeof(IP_LOCAL_BINDING)
            )) {
        NhTrace(
            TRACE_FLAG_INIT,
            "NhUpdatePrivateInterface: no changes detected"
            );
        NH_FREE(BindingInfo);
        CoTaskMemFree(pLanGuid);
        return NO_ERROR;
    }

    //
    // A change has occurred which requires an update.
    // First we get rid of any existing private LAN interface,
    // then we add the new interface to each component (NAT, DHCP, DNS proxy)
    // and bind and enable the new interface.
    //

    NhpDeletePrivateInterface();

    do {

        Error =
            NatRmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                &NatInfo,
                IP_NAT_VERSION,
                sizeof(NatInfo),
                1
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: NatRmAddInterface=%d",
                Error
                );
            break;
        }

        if (NhpNoLocalDhcp)
        {
            Error =
                DhcpRmAddInterface(
                    NULL,
                    0,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmAddInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error =
                DnsRmAddInterface(
                    NULL,
                    0,
                    PERMANENT,
                    IF_TYPE_OTHER,
                    IF_ACCESS_BROADCAST,
                    IF_CONNECTION_DEDICATED,
                    NULL,
                    IP_NAT_VERSION,
                    0,
                    0
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmAddInterface=%d",
                    Error
                    );
                break;
            }
        }

#ifndef NO_FTP_PROXY
        Error =
            FtpRmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: FtpRmAddInterface=%d",
                Error
                );
            break;
        }
#endif
        Error =
            AlgRmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmAddInterface=%d",
                Error
                );
            break;
        }

        Error =
            H323RmAddInterface(
                NULL,
                0,
                PERMANENT,
                IF_TYPE_OTHER,
                IF_ACCESS_BROADCAST,
                IF_CONNECTION_DEDICATED,
                NULL,
                IP_NAT_VERSION,
                0,
                0
                );
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmAddInterface=%d",
                Error
                );
            break;
        }

        //
        // Bind the private interface of each component
        //

        Error = NatBindInterface(0, NULL, BindingInfo, AdapterIndex);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: NatRmBindInterface=%d",
                Error
                );
            break;
        }

        if (NhpNoLocalDhcp)
        {
            Error = DhcpRmBindInterface(0, BindingInfo);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmBindInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error = DnsRmBindInterface(0, BindingInfo);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmBindInterface=%d",
                    Error
                    );
                break;
            }
        }

#ifndef NO_FTP_PROXY
        Error = FtpRmBindInterface(0, BindingInfo);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: FtpRmBindInterface=%d",
                Error
                );
            break;
        }
#endif
        Error = AlgRmBindInterface(0, BindingInfo);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmBindInterface=%d",
                Error
                );
            break;
        }

        Error = H323RmBindInterface(0, BindingInfo);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmBindInterface=%d",
                Error
                );
            break;
        }

        //
        // Enable the private interface for the components.
        // The NAT private interface is always enabled, and therefore
        // requires no additional call.
        //

        if (NhpNoLocalDhcp)
        {
            Error = DhcpRmEnableInterface(0);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DhcpRmEnableInterface=%d",
                    Error
                    );
                break;
            }
        }

        if (NoLocalDns)
        {
            Error = DnsRmEnableInterface(0);
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "NhUpdatePrivateInterface: DnsRmEnableInterface=%d",
                    Error
                    );
                break;
            }
        }

#ifndef NO_FTP_PROXY
        Error = FtpRmEnableInterface(0);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: FtpRmEnableInterface=%d",
                Error
                );
            break;
        }
#endif
        Error = AlgRmEnableInterface(0);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: AlgRmEnableInterface=%d",
                Error
                );
            break;
        }

        Error = H323RmEnableInterface(0);
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "NhUpdatePrivateInterface: H323RmEnableInterface=%d",
                Error
                );
            break;
        }

        //
        // The interface was activated successfully.
        //

        RtlCopyMemory(&NhpSharedPrivateLanGuid, pLanGuid, sizeof(GUID));
        NhpSharedPrivateLanIndex = AdapterIndex;
        CoTaskMemFree(pLanGuid);
        if (NhpSharedPrivateLanBindingInfo) {
            NH_FREE(NhpSharedPrivateLanBindingInfo);
        }
        NhpSharedPrivateLanBindingInfo = BindingInfo;        
        return NO_ERROR;
    
    } while(FALSE);

    NH_FREE(BindingInfo);
    CoTaskMemFree(pLanGuid);
    return Error;

} // NhUpdatePrivateInterface


VOID
ServiceHandler(
    ULONG ControlCode
    )

/*++

Routine Description:

    This routine is called to control the 'SharedAccess' service.

Arguments:

    ControlCode - indicates the requested operation

Return Value:

    none.

--*/

{
    BOOLEAN ComInitialized = FALSE;
    HRESULT hr;

    PROFILE("ServiceHandler");
    if (ControlCode == IPNATHLP_CONTROL_UPDATE_CONNECTION) {

        //
        // Update our policy settings
        //

        NhpUpdatePolicySettings();

        //
        // Signal the configuration-changed event
        //

        NtSetEvent(NatConfigurationChangedEvent, NULL);
        SignalBeaconSvr();
        
    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_SETTINGS) {

        //
        // Update all state which depends on shared access settings
        //

        NatRemoveApplicationSettings();
        NhUpdateApplicationSettings();
        NatInstallApplicationSettings();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_FWLOGGER) {

        FwUpdateLoggingSettings();

    } else if (ControlCode == IPNATHLP_CONTROL_UPDATE_AUTODIAL) {

        NtSetEvent(NatConnectionNotifyEvent, NULL);

    } else if (ControlCode == SERVICE_CONTROL_STOP &&
                NhpServiceStatus.dwCurrentState != SERVICE_STOPPED &&
                NhpServiceStatus.dwCurrentState != SERVICE_STOP_PENDING) {


        NhpServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
        if (NhpServiceStatusHandle) {
            SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        }

        if (NhpClassObjectsRegistered) {
            _Module.RevokeClassObjects();
            NhpClassObjectsRegistered = FALSE;
        }

        NhpStopAddressChangeNotification();

        if (NhpStopNatEvent) {
            NatRmStopProtocol();
            WaitForSingleObject(NhpStopNatEvent, INFINITE);
            CloseHandle(NhpStopNatEvent); NhpStopNatEvent = NULL;
        }

        if (NhpStopAlgEvent) {
            AlgRmStopProtocol();

            WaitForSingleObject(NhpStopAlgEvent, INFINITE);
            CloseHandle(NhpStopAlgEvent); NhpStopAlgEvent = NULL;
        }

#ifndef NO_FTP_PROXY
        if (NhpStopFtpEvent) {
            FtpRmStopProtocol();
            WaitForSingleObject(NhpStopFtpEvent, INFINITE);
            CloseHandle(NhpStopFtpEvent); NhpStopFtpEvent = NULL;
        }
#endif

        if (NhpStopH323Event) {
            H323RmStopProtocol();
            WaitForSingleObject(NhpStopH323Event, INFINITE);
            CloseHandle(NhpStopH323Event); NhpStopH323Event = NULL;
        }

        EnterCriticalSection(&NhLock);
        NhFreeApplicationSettings();
        if (NhpSharedPrivateLanBindingInfo) {
            NH_FREE(NhpSharedPrivateLanBindingInfo);
            NhpSharedPrivateLanBindingInfo = NULL;
        }
        LeaveCriticalSection(&NhLock);
        NhpServiceStatus.dwCurrentState = SERVICE_STOPPED;
        NhResetComponentMode();

        //
        // Shutdown the firewall logging subsystem
        //

        if (NhpFwLoggingInitialized) {
            FwCleanupLogger();
            NhpFwLoggingInitialized = FALSE;
        }

        //
        // Release our reference to RasMan
        //

        if (NhpRasmanReferenced) {
            RasReferenceRasman(FALSE);
            NhpRasmanReferenced = FALSE;
        }
        
        //
        // Update the network connections folder (so that the firewall icons
        // will disappear as necessary).
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr)) {
            ComInitialized = TRUE;
        } else if (RPC_E_CHANGED_MODE == hr) {
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            NhpUpdateConnectionsFolder();
        }

        if (TRUE == ComInitialized) {
            CoUninitialize();
        }

    }
    if (NhpServiceStatusHandle) {
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
    }
} // ServiceHandler


VOID
ServiceMain(
    ULONG ArgumentCount,
    PWCHAR ArgumentArray[]
    )

/*++

Routine Description:

    This routine is the entrypoint for the connection-sharing service.
    It is responsible for initializing the module and starting operation.

Arguments:

    Argument* - count and array of arguments specified to the service

Return Value:

    none.

--*/

{
    HRESULT hr;
    ULONG Error;
    BOOLEAN ComInitialized = FALSE;
    
#ifndef NO_FTP_PROXY
    IP_FTP_GLOBAL_INFO FtpInfo = {
        IPNATHLP_LOGGING_ERROR,
        0
    };
#endif
	
    IP_ALG_GLOBAL_INFO AlgInfo = {
        IPNATHLP_LOGGING_ERROR,
        0
    };

    IP_H323_GLOBAL_INFO H323Info = {
        IPNATHLP_LOGGING_ERROR,
        0
    };
    IP_NAT_GLOBAL_INFO NatInfo = {
        IPNATHLP_LOGGING_ERROR,
        0,
        { IP_NAT_VERSION, FIELD_OFFSET(RTR_INFO_BLOCK_HEADER, TocEntry), 0,
        { 0, 0, 0, 0 }}
    };

    PROFILE("ServiceMain");

    do {

        //
        // Initialize service status, register a service control handler,
        // and indicate that the service is starting
        //
    
        ZeroMemory(&NhpServiceStatus, sizeof(NhpServiceStatus));
        NhpServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
        NhpServiceStatus.dwCurrentState = SERVICE_START_PENDING;
        NhpServiceStatusHandle =
            RegisterServiceCtrlHandler(
                TEXT("SharedAccess"), ServiceHandler
                );
        if (!NhpServiceStatusHandle) { break; }

        //
        // Attempt to set the component into 'Shared Access' mode.
        // This module implements both shared-access and connection-sharing
        // which are mutually exclusive, so we need to ensure that
        // connection-sharing is not operational before proceeding.
        //

        if (!NhSetComponentMode(NhSharedAccessMode)) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: cannot enable Shared Access mode"
                );
            break;
        }

        //
        // Make sure COM is initialized on this thread
        //

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );
        if (SUCCEEDED(hr))
        {
            ComInitialized = TRUE;
        }
        else
        {
            if (RPC_E_CHANGED_MODE != hr)
            {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: Unable to initialize COM (0x%08x)",
                    hr
                    );
                break;
            }
            else
            {
                ASSERT(FALSE);
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: Unexpectedly in STA!"
                    );
            }
        }

        //
        // Obtain the current policy settings.
        //

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhpUpdatePolicySettings();

        //
        // Reference RasMan. As we live in the same process as rasman, the
        // normal SC dependency mechanism won't necessarily keep the rasman
        // service alive (119042)
        //

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (ERROR_SUCCESS != (Error = RasReferenceRasman(TRUE))) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: Unable to reference RasMan (0x%08x)",
                Error
                );
            break;
        }

        NhpRasmanReferenced = TRUE;

        //
        // Initialize the firewall logging subsystem
        //

        Error = FwInitializeLogger();
        if (ERROR_SUCCESS != Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: FwInitializeLogger=%d",
                Error
                );
            break;
        }

        NhpFwLoggingInitialized = TRUE;

        //
        // Register the class object for our notification sink
        //

        hr = _Module.RegisterClassObjects(
                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                REGCLS_MULTIPLEUSE
                );

        if (FAILED(hr)) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: _Module.RegisterClassObjects=0x%08x",
                hr
                );
            break;
        }

        NhpClassObjectsRegistered = TRUE;

        //
        // Start operations by loading the NAT,  Ftp, ALG, and H.323 modules
        //
    
        NhpServiceStatus.dwWaitHint = 30000;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopNatEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                NatRmStartProtocol(
                    NhpStopNatEvent,
                    NULL,
                    &NatInfo,
                    IP_NAT_VERSION,
                    sizeof(NatInfo),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: NatRmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopNatEvent); NhpStopNatEvent = NULL; break;
            }
        }

#ifndef NO_FTP_PROXY
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopFtpEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                FtpRmStartProtocol(
                    NhpStopFtpEvent,
                    NULL,
                    &FtpInfo,
                    IP_NAT_VERSION,
                    sizeof(FtpInfo),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: FtpRmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopFtpEvent); NhpStopFtpEvent = NULL; break;
            }
        }
#endif
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopAlgEvent = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                AlgRmStartProtocol(
                    NhpStopAlgEvent,
                    NULL,
                    &AlgInfo,
                    IP_NAT_VERSION,
                    sizeof(AlgInfo),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: AlgRmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopAlgEvent); NhpStopAlgEvent = NULL; break;
            }
        }

        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        if (!(NhpStopH323Event = CreateEvent(NULL, FALSE, FALSE, NULL))) {
            break;
        } else {
            Error =
                H323RmStartProtocol(
                    NhpStopH323Event,
                    NULL,
                    &H323Info,
                    IP_NAT_VERSION,
                    sizeof(H323Info),
                    1
                    );
            if (Error) {
                NhTrace(
                    TRACE_FLAG_INIT,
                    "ServiceMain: H323RmStartProtocol=%d",
                    Error
                    );
                CloseHandle(NhpStopH323Event); NhpStopH323Event = NULL; break;
            }
        }

        //
        // Start connection management. If needed, this will load the DNS and
        // DHCP modules. The Beacon Service is also started.
        //
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        Error = NatStartConnectionManagement();
        if (Error) {
            NhTrace(
                TRACE_FLAG_INIT,
                "ServiceMain: NatStartConnectionManagement=%d",
                Error
                );
            break;
        }
        
        NhpServiceStatus.dwCheckPoint++;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhpStartAddressChangeNotification();

        //
        // Indicate that the service is now up and running.
        //
    
        NhpServiceStatus.dwCurrentState = SERVICE_RUNNING;
        NhpServiceStatus.dwWaitHint = 0;
        NhpServiceStatus.dwCheckPoint = 0;
        NhpServiceStatus.dwControlsAccepted =
            SERVICE_ACCEPT_STOP|SERVICE_ACCEPT_PARAMCHANGE;
        SetServiceStatus(NhpServiceStatusHandle, &NhpServiceStatus);
        NhTrace(TRACE_FLAG_INIT, "ServiceMain: service started successfully");

        //
        // Ask the connections folder to update itself.
        //

        NhpUpdateConnectionsFolder();

        //
        // Uninitialize COM
        //

        if (TRUE == ComInitialized)
        {
            CoUninitialize();
        }

        return;
    
    } while(FALSE);

    //
    // A failure occurred; do cleanup
    //

    NhpServiceStatus.dwWaitHint = 0;
    NhpServiceStatus.dwCheckPoint = 0;
    NhTrace(TRACE_FLAG_INIT, "ServiceMain: service could not start");
    StopBeaconSvr();

    //
    // Uninitialize COM
    //

    if (TRUE == ComInitialized)
    {
        CoUninitialize();
    }
    
    ServiceHandler(SERVICE_CONTROL_STOP);

} // ServiceMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\natsvc\svcmain.h ===
/*++

Copyright (c) 1998, Microsoft Corporation

Module Name:

    svcmain.h

Abstract:

    This module contains declarations for the module's shared-access mode,
    in which the module runs as a service rather than as a routing component.

Author:

    Abolade Gbadegesin (aboladeg)   4-Sep-1998

Revision History:

--*/

#pragma once

#ifndef _NATHLP_SVCMAIN_H_
#define _NATHLP_SVCMAIN_H_

#include "udpbcast.h"

//
// Pointer to the GlobalInterfaceTable for the process
//

extern IGlobalInterfaceTable *NhGITp;

//
// GIT cookie for the IHNetCfgMgr instance
//

extern DWORD NhCfgMgrCookie;

//
// UDP Broadcast mapper
//

extern IUdpBroadcastMapper *NhpUdpBroadcastMapper;


//
// Policy information
//

extern BOOL NhPolicyAllowsFirewall;
extern BOOL NhPolicyAllowsSharing;

//
// Function prototypes
//

HRESULT
NhGetHNetCfgMgr(
    IHNetCfgMgr **ppCfgMgr
    );

ULONG
NhMapGuidToAdapter(
    PWCHAR Guid
    );

BOOLEAN
NhQueryScopeInformation(
    PULONG Address,
    PULONG Mask
    );
    
ULONG
NhStartICSProtocols(
    VOID
    );

ULONG
NhStopICSProtocols(
    VOID
    );

ULONG
NhUpdatePrivateInterface(
    VOID
    );

VOID
ServiceHandler(
    ULONG ControlCode
    );

VOID
ServiceMain(
    ULONG ArgumentCount,
    PWCHAR ArgumentArray[]
    );

#endif // _NATHLP_SVCMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\priority\priority.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    net\ip\rtrmgr\priority\priority.h

Abstract:
    IP Router Manager code

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <dim.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtm.h>
#include <fltdefs.h>
#include <rtinfo.h>
#include <ipinfoid.h>
#include <iprtinfo.h>
#include <iprtprio.h>
#include <priopriv.h>

#define HASH_TABLE_SIZE 17

//
// Block inserted into the hash table of protocol->metric mapping
//

struct RoutingProtocolBlock 
{
    LIST_ENTRY	        RPB_List ;
    PROTOCOL_METRIC     RPB_ProtocolMetric ;
};

typedef struct RoutingProtocolBlock RoutingProtocolBlock ;

//
// pointer to memory holding all the protocol->metric mapping blocks
//

RoutingProtocolBlock *RoutingProtocolBlockPtr ;

//
// Lock for accessing protocol->metric mapping blocks
//

CRITICAL_SECTION PriorityLock ;

//
// Hash table for accessing protocol->metric mappings given the protocolid
//

LIST_ENTRY HashTable[HASH_TABLE_SIZE] ;

//
// Count of number of protocol->metric mappings
//

DWORD NumProtocols ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\priority\priority.c ===
/*++

  
Copyright (c) 1995  Microsoft Corporation


Module Name:

    routing\ip\priority\priority.c

Abstract:

    Route Priority DLL

Revision History:

    Gurdeep Singh Pall		7/19/95	Created

--*/

#include    "priority.h"

PRTR_TOC_ENTRY
GetPointerToTocEntry(
    DWORD                  dwType,
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )
{
    DWORD   i;

    if(pInfoHdr == NULL)
    {
        return NULL;
    }

    for(i = 0; i < pInfoHdr->TocEntriesCount; i++)
    {
        if(pInfoHdr->TocEntry[i].InfoType == dwType)
        {
            return &(pInfoHdr->TocEntry[i]);
        }
    }

    return NULL; 
}

VOID
InitHashTable(
    VOID
    )

/*++

Routine Description

    Initializes the hash tables where the priority information is kept

Locks

    None

Arguments

    None

Return Value

    None    

--*/

{
    DWORD i;

    for(i=0; i < HASH_TABLE_SIZE; i++)
    {
        InitializeListHead(&HashTable[i]);
    }
}

BOOL
InitPriorityDLL (
    HANDLE  hInst, 
    DWORD   ulCallReason,
    PVOID   pReserved
    )
{
    static BOOL bPriorityLockInitialized = FALSE;

    switch(ulCallReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Not interested in any XXX_THREAD_XXX reasons
            //
            
            DisableThreadLibraryCalls(hInst);
            
            //
            // Initialize Critical Section for routing protocol list
            //
            
            try
            {
                InitializeCriticalSection(&PriorityLock);
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                return FALSE;
            }

            bPriorityLockInitialized = TRUE;

            //
            // Initialize Hash Table
            //
            
            InitHashTable();

            break;
        }
        
        case DLL_PROCESS_DETACH:
        {
            if ( bPriorityLockInitialized )
            {
                DeleteCriticalSection(&PriorityLock);
                bPriorityLockInitialized = FALSE;
            }

            break;
        }

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        {
            break;
        }

    }

    return TRUE;
}

DWORD
ComputeRouteMetric(
    IN DWORD    dwProtoId
    )

/*++

Routine Description

    This is the main function that computes the priority of a route.
    The priority is filled into the

Locks

    Takes the lock guarding the hash table

Arguments

    pRoute  Pointer to route 

Return Value

    DWORD priority for the protocol    

--*/

{
    PLIST_ENTRY             pleNode;
    RoutingProtocolBlock    *pProtoBlk;
    DWORD                   dwMetric;
    
    //
    // Initialize in case the specified protocol is not in the list
    //
    
    dwMetric    = IP_PRIORITY_DEFAULT_METRIC;
    
    EnterCriticalSection(&PriorityLock);

    //
    // Walk the hash bucket for the protocol
    //
    
    for(pleNode  = HashTable[dwProtoId % HASH_TABLE_SIZE].Flink;
        pleNode != &(HashTable[dwProtoId % HASH_TABLE_SIZE]);
        pleNode  = pleNode->Flink) 
    {
        //
        // Cast to appropriate structure
        //
        
        pProtoBlk = CONTAINING_RECORD(pleNode,
                                      RoutingProtocolBlock,
                                      RPB_List);

        //
        // If the info is for the protocol, copy out the priority metric
        //
        
        if(pProtoBlk->RPB_ProtocolMetric.dwProtocolId == dwProtoId)
        {
            dwMetric = pProtoBlk->RPB_ProtocolMetric.dwMetric;
            
            break;
        }
    }

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection(&PriorityLock);
    
    return dwMetric;
}


DWORD
SetPriorityInfo(
    PRTR_INFO_BLOCK_HEADER pInfoHdr
    )

/*++

Routine Description

    This function is called by the IP Router Manager to set the priority
    information in the DLL. The structure and contents of this information
    are opaque to all but the setup and this DLL

Locks

    Takes the hash table lock since the information is changing

Arguments

    pInfoHdr    Pointer to the InfoBlock header

Return Value

    NO_ERROR                Everything worked OK
    ERROR_NOT_ENOUGH_MEMORY Couldnt allocate memory

--*/

{
    DWORD                   i;
    PLIST_ENTRY             pleListHead;
    PPRIORITY_INFO          pInfo;
    RoutingProtocolBlock    *currentblock;
    PRTR_TOC_ENTRY          pToc;
 
    pToc = GetPointerToTocEntry(IP_PROT_PRIORITY_INFO,
                                pInfoHdr);

    //
    // No info means leave things as they are
    //
    
    if(!pToc)
    {
        return NO_ERROR;
    }

    pInfo = (PPRIORITY_INFO)GetInfoFromTocEntry(pInfoHdr,
                                                pToc);
    
    if(!pInfo)
    {
        return NO_ERROR;
    }

    //
    // *** Exclusion Begin ***
    //
    
    EnterCriticalSection(&PriorityLock);

    //
    // If we already have the hash table populated - free the whole table.
    //
    
    if(RoutingProtocolBlockPtr) 
    {
        HeapFree(GetProcessHeap(),
                 0,
                 RoutingProtocolBlockPtr);
        
        InitHashTable();
    }
    
    if(pToc->InfoSize == 0)
    {
        //
        // Means delete all the info - which is done above
        //
        
        LeaveCriticalSection(&PriorityLock);
        
        return NO_ERROR;
    }

    //
    // Allocate enough RoutingProtocolBlocks to hold the newly specified info
    //
    
    RoutingProtocolBlockPtr =
        HeapAlloc(GetProcessHeap(), 
                  HEAP_ZERO_MEMORY,
                  pInfo->dwNumProtocols * sizeof (RoutingProtocolBlock));
    
    if(RoutingProtocolBlockPtr == NULL)
    {
        //
        // *** Exclusion End ***
        //
        
        LeaveCriticalSection (&PriorityLock);
        
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Keep a count of the number of protocols
    //
    
    NumProtocols = pInfo->dwNumProtocols;

    //
    // Go thru pInfo and add each protocol and metric to the hash table
    //
    
    currentblock = RoutingProtocolBlockPtr;
    
    for(i=0; i < NumProtocols; i++) 
    {
        currentblock->RPB_ProtocolMetric.dwProtocolId = 
            pInfo->ppmProtocolMetric[i].dwProtocolId;
        
        currentblock->RPB_ProtocolMetric.dwMetric     = 
            pInfo->ppmProtocolMetric[i].dwMetric;
        
        pleListHead = &HashTable[pInfo->ppmProtocolMetric[i].dwProtocolId % HASH_TABLE_SIZE];
        
        InsertTailList(pleListHead,
                       &currentblock->RPB_List);
        
        currentblock++;
    }

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection (&PriorityLock);

    return NO_ERROR;
}

DWORD
GetPriorityInfo(
    IN  PVOID   pvBuffer,
    OUT PDWORD  pdwBufferSize
    )

/*++

Routine Description

    Called by router manager to get a copy of our priority information

Locks

    Takes the table lock to ensure consistency

Arguments

    pvBuffer        Pointer to buffer into which info is to be written
    pdwBufferSize   [IN]  Size of the buffer pointed to by pvBuffer
                    [OUT] Size of data copied out, or size of buffer needed
Return Value

    NO_ERROR                    Buffer of size *pdwBufferSize was copied out
    ERROR_INSUFFICIENT_BUFFER   The buffer was too small to copy out the info
                                The size of buffer needed is in *pdwBufferSize

--*/

{
    DWORD           i, dwSizeReqd;
    PPRIORITY_INFO  ppiPriorityInfo;
    RoutingProtocolBlock *currentblock;

    ppiPriorityInfo = pvBuffer;
    
    //
    // *** Exclusion Begin ***
    //
    
    EnterCriticalSection (&PriorityLock);

    dwSizeReqd = SIZEOF_PRIORITY_INFO(NumProtocols);

    if(dwSizeReqd > *pdwBufferSize)
    {
        *pdwBufferSize = dwSizeReqd;

        //
        // *** Exclusion End ***
        //
        
        LeaveCriticalSection (&PriorityLock);
        
        return ERROR_INSUFFICIENT_BUFFER;
    }

    *pdwBufferSize = dwSizeReqd;
    
    //
    // Go thru pinfo and get each protocol and metric 
    //
    
    currentblock = RoutingProtocolBlockPtr;
    
    for(i=0; i < NumProtocols; i++) 
    {
        ppiPriorityInfo->ppmProtocolMetric[i].dwProtocolId = 
            currentblock->RPB_ProtocolMetric.dwProtocolId;

        ppiPriorityInfo->ppmProtocolMetric[i].dwMetric =     
            currentblock->RPB_ProtocolMetric.dwMetric;

        currentblock++;
    }

    ppiPriorityInfo->dwNumProtocols = NumProtocols;

    //
    // *** Exclusion End ***
    //
    
    LeaveCriticalSection(&PriorityLock);

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\nathlp\test\nhtest.cpp ===
#include "precomp.h"
#pragma hdrstop
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <mswsock.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ipnatapi.h>

HANDLE Event;


VOID
ReadCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    printf(
        "ReadCompletionRoutine: e=%u, b=%u, '%s'\n",
        ErrorCode, BytesTransferred, Bufferp->Buffer
        );
    NhReleaseBuffer(Bufferp);
    SetEvent(Event);
}

VOID
WriteCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    printf(
        "WriteCompletionRoutine: e=%u, b=%u, %08x\n",
        ErrorCode, BytesTransferred, Bufferp
        );
    NhReleaseBuffer(Bufferp);
    SetEvent(Event);
}


VOID
AcceptCompletionRoutine(
    ULONG ErrorCode,
    ULONG BytesTransferred,
    PNH_BUFFER Bufferp
    )
{
    SOCKET AcceptedSocket;
    SOCKET ListeningSocket;
    printf(
        "AcceptCompletionRoutine: e=%u, b=%u\n",
        ErrorCode, BytesTransferred
        );
    ListeningSocket = (SOCKET)Bufferp->Context;
    AcceptedSocket = (SOCKET)Bufferp->Context2;
    ErrorCode =
        setsockopt(
            AcceptedSocket,
            SOL_SOCKET,
            SO_UPDATE_ACCEPT_CONTEXT,
            (PCHAR)&ListeningSocket,
            sizeof(ListeningSocket)
            );
    if (ErrorCode == SOCKET_ERROR) {
        printf("error %d updating accept context\n", WSAGetLastError());
        NhReleaseBuffer(Bufferp);
        SetEvent(Event);
    } else {
        ErrorCode =
            NhReadStreamSocket(
                NULL,
                AcceptedSocket,
                Bufferp,
                NH_BUFFER_SIZE,
                0,
                ReadCompletionRoutine,
                NULL,
                NULL
                );
        if (ErrorCode != NO_ERROR) {
            printf("error %d reading from accepted socket\n", ErrorCode);
            NhReleaseBuffer(Bufferp);
            SetEvent(Event);
        }
    }
}

VOID
TestApiCompletionRoutine(
    HANDLE RedirectHandle,
    BOOLEAN Cancelled,
    PVOID CompletionContext
    )
{
    NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
    ULONG Error;
    ULONG Length = sizeof(ByteCount);
    printf("TestApiCompletionRoutine=%x,%d\n", RedirectHandle, Cancelled);
    Error =
        NatQueryInformationRedirectHandle(
            RedirectHandle,
            &ByteCount,
            &Length,
            NatByteCountRedirectInformation
            );
    printf(
        "TestApiCompletionRoutine=%d,bc={%I64d,%I64d},l=%d\n",
        Error, ByteCount.BytesForward, ByteCount.BytesReverse, Length
        );
}


VOID
TestRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreateRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            inet_addr(argv[7]),
            htons((USHORT)atol(argv[8])),
            inet_addr(argv[9]),
            htons((USHORT)atol(argv[10])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreateRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)atol(argv[8])),
                    inet_addr(argv[9]),
                    htons((USHORT)atol(argv[10])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            inet_addr(argv[7]),
                            htons((USHORT)atol(argv[8])),
                            inet_addr(argv[9]),
                            htons((USHORT)atol(argv[10])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationRedirect=%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)atol(argv[8])),
                    inet_addr(argv[9]),
                    htons((USHORT)atol(argv[10]))
                    );
            printf("NatCancelRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePartialRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePartialRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePortRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePortRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                NAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping;
                ULONG Length;
                CHAR src[32], newsrc[32], dst[32], newdst[32];
                Length = sizeof(SourceMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                Length = sizeof(DestinationMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &DestinationMapping,
                    &Length,
                    NatDestinationMappingRedirectInformation
                    );
                lstrcpyA(
                    dst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.DestinationAddress)
                    );
                lstrcpyA(
                    newdst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.NewDestinationAddress)
                    );
                printf("redirect activated: %s:%s->%s:%s\n", src, dst, newsrc, newdst);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPortRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            htons((USHORT)atol(argv[3])),
                            inet_addr(argv[4]),
                            htons((USHORT)atol(argv[5])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPortRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5]))
                    );
            printf("NatCancelPortRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestReceiveOnlyPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreatePortRedirect(
            TranslatorHandle,
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreatePortRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                NAT_DESTINATION_MAPPING_REDIRECT_INFORMATION DestinationMapping;
                ULONG Length;
                CHAR src[32], newsrc[32], dst[32], newdst[32];
                Length = sizeof(SourceMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                Length = sizeof(DestinationMapping);
                NatQueryInformationPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5])),
                    &DestinationMapping,
                    &Length,
                    NatDestinationMappingRedirectInformation
                    );
                lstrcpyA(
                    dst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.DestinationAddress)
                    );
                lstrcpyA(
                    newdst,
                    inet_ntoa(*(PIN_ADDR)&DestinationMapping.NewDestinationAddress)
                    );
                printf("redirect activated: %s:%s->%s:%s\n", src, dst, newsrc, newdst);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPortRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            htons((USHORT)atol(argv[3])),
                            inet_addr(argv[4]),
                            htons((USHORT)atol(argv[5])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPortRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPortRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    htons((USHORT)atol(argv[3])),
                    inet_addr(argv[4]),
                    htons((USHORT)atol(argv[5]))
                    );
            printf("NatCancelPortRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestReceiveOnlyDynamicPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE DynamicRedirectHandle;

    Error =
        NatCreateDynamicPartialRedirect(
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            atol(argv[7]),
            &DynamicRedirectHandle
            );
    printf("NatCreateDynamicPartialRedirect=%d\n", Error);
    if (!Error) {
        printf("Press <Enter> to cancel the dynamic redirect...");
        while (!_kbhit()) { Sleep(1000); }
        Error = NatCancelDynamicPartialRedirect(DynamicRedirectHandle);
        printf("NatCancelDynamicPartialRedirect=%d\n", Error);
    }
    printf("done\n");
}


VOID
TestReceiveOnlyDynamicPortRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE DynamicRedirectHandle;

    Error =
        NatCreateDynamicPortRedirect(
            NatRedirectFlagReceiveOnly,
            (UCHAR)atol(argv[2]),
            htons((USHORT)atol(argv[3])),
            inet_addr(argv[4]),
            htons((USHORT)atol(argv[5])),
            atol(argv[6]),
            &DynamicRedirectHandle
            );
    printf("NatCreateDynamicPortRedirect=%d\n", Error);
    if (!Error) {
        printf("Press <Enter> to cancel the dynamic redirect...");
        while (!_kbhit()) { Sleep(1000); }
        Error = NatCancelDynamicPortRedirect(DynamicRedirectHandle);
        printf("NatCancelDynamicPortRedirect=%d\n", Error);
    }
    printf("done\n");
}


VOID
TestRestrictedPartialRedirect(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    Error =
        NatCreateRestrictedPartialRedirect(
            TranslatorHandle,
            0,
            (UCHAR)atol(argv[2]),
            inet_addr(argv[3]),
            htons((USHORT)atol(argv[4])),
            inet_addr(argv[5]),
            htons((USHORT)atol(argv[6])),
            inet_addr(argv[7]),
            TestApiCompletionRoutine,
            NULL,
            Event
            );
    printf("NatCreateRestrictedPartialRedirect=%d\n", Error);
    if (!Error) {
        for (;;) {
            Error = WaitForSingleObjectEx(Event, 1000, TRUE);
            printf("WaitForSingleObjectEx=%d\n", Error);
            if (Error == WAIT_IO_COMPLETION) {
                break;
            } else if (Error == WAIT_OBJECT_0) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf("redirect activated: %s->%s\n", src, newsrc);
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (Error != WAIT_IO_COMPLETION) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestDuplicateRedirect(
    int argc,
    char* argv[]
    )
{
#define REDIRECT_COUNT 5
    ULONG Count;
    ULONG Error;
    HANDLE EventHandle[REDIRECT_COUNT];
    ULONG i;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    for (i = 0, Count = 0; i < REDIRECT_COUNT; i++) {
        EventHandle[i] = CreateEvent(NULL, FALSE, FALSE, NULL);
        Error =
            NatCreateRedirect(
                TranslatorHandle,
                0,
                (UCHAR)atol(argv[2]),
                inet_addr(argv[3]),
                htons((USHORT)atol(argv[4])),
                0,
                0,
                inet_addr(argv[5]),
                htons((USHORT)atol(argv[6])),
                inet_addr(argv[7]),
                htons((USHORT)(atol(argv[8]) + i)),
                TestApiCompletionRoutine,
                NULL,
                EventHandle[i]
                );
        printf("NatCreateRedirect=%d\n", Error);
        if (!Error) { ++Count; }
    }
    for (;;) {
        ULONG Error2;
        Error =
            WaitForMultipleObjectsEx(
                REDIRECT_COUNT,
                EventHandle,
                FALSE,
                1000,
                TRUE
                );
        printf("WaitForSingleObjectEx=%d\n", Error);
        if (Error == WAIT_IO_COMPLETION) {
            if (!--Count) { break; }
        } else if ((Error - WAIT_OBJECT_0) < REDIRECT_COUNT) {
            NAT_KEY_SESSION_MAPPING_INFORMATION Key;
            ULONG Length = sizeof(Key);
            CHAR src[32], newsrc[32];
            i = Error - WAIT_OBJECT_0;
            Error2 =
                NatLookupAndQueryInformationSessionMapping(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)(atol(argv[8]) + i)),
                    &Key,
                    &Length,
                    NatKeySessionMappingInformation
                    );
            lstrcpyA(
                src,
                inet_ntoa(*(PIN_ADDR)&Key.SourceAddress)
                );
            lstrcpyA(
                newsrc,
                inet_ntoa(*(PIN_ADDR)&Key.NewSourceAddress)
                );
            printf("redirect activated[%d]: %s->%s\n", Error2, src, newsrc);
        }
        if (_kbhit()) {
            switch(getchar()) {
                case 'q': { break; }
                case 's': {
                    NAT_STATISTICS_SESSION_MAPPING_INFORMATION Statistics;
                    for (i = 0; i < REDIRECT_COUNT; i++) {
                        ULONG Length = sizeof(Statistics);
                        Error2 =
                            NatLookupAndQueryInformationSessionMapping(
                                TranslatorHandle,
                                (UCHAR)atol(argv[2]),
                                inet_addr(argv[5]),
                                htons((USHORT)atol(argv[6])),
                                inet_addr(argv[7]),
                                htons((USHORT)(atol(argv[8]) + i)),
                                &Statistics,
                                &Length,
                                NatStatisticsSessionMappingInformation
                                );
                        printf(
                            "NatLookupAndQueryInformationSessionMapping=%d,{%I64d,%I64d}\n",
                            Error2,
                            Statistics.BytesForward,
                            Statistics.BytesReverse
                            );
                    }
                    // fall-through
                }
                default: continue;
            }
            break;
        }
    }
    if (Error != WAIT_IO_COMPLETION) {
        for (i = 0; i < REDIRECT_COUNT; i++) {
            Error =
                NatCancelRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    0,
                    0,
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    inet_addr(argv[7]),
                    htons((USHORT)(atol(argv[8]) + i))
                    );
            printf("NatCancelRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}



VOID
TestDatagramIo(
    int argc,
    char* argv[]
    )
{
    SOCKET Socket;
    NhInitializeTraceManagement();
    NhInitializeBufferManagement();
    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (lstrcmpiA(argv[1], "-s") == 0) {
        NhCreateDatagramSocket(
            inet_addr(argv[2]),
            htons(1000),
            &Socket
            );
        NhReadDatagramSocket(
            NULL,
            Socket,
            NULL,
            ReadCompletionRoutine,
            NULL,
            NULL
            );
    } else if (lstrcmpiA(argv[1], "-c") == 0) {
        PNH_BUFFER Bufferp;
        NhCreateDatagramSocket(
            inet_addr(argv[2]),
            0,
            &Socket
            );
        Bufferp = NhAcquireBuffer();
        lstrcpyA(Bufferp->Buffer, "client-to-server message");
        NhWriteDatagramSocket(
            NULL,
            Socket,
            inet_addr(argv[3]),
            htons(1000),
            Bufferp,
            lstrlenA(Bufferp->Buffer),
            WriteCompletionRoutine,
            NULL,
            NULL
            );
    }
    WaitForSingleObject(Event, INFINITE);
    NhDeleteDatagramSocket(Socket);
}


VOID
TestStreamIo(
    int argc,
    char* argv[]
    )
{
    SOCKET AcceptedSocket;
    ULONG Error;
    SOCKET ListeningSocket;
    NhInitializeTraceManagement();
    NhInitializeBufferManagement();
    Event = CreateEvent(NULL, FALSE, FALSE, NULL);
    Error = NhCreateStreamSocket(INADDR_ANY, htons(1000), &ListeningSocket);
    if (Error != NO_ERROR) {
        printf("error %d creating listening socket\n", Error);
    } else {
        Error = NhCreateStreamSocket(INADDR_NONE, 0, &AcceptedSocket);
        if (Error != NO_ERROR) {
            printf("error %d creating accepted socket\n", Error);
        } else {
            Error = listen(ListeningSocket, SOMAXCONN);
            if (Error == SOCKET_ERROR) {
                printf("error %d listening on socket\n", WSAGetLastError());
            } else {
                Error =
                    NhAcceptStreamSocket(
                        NULL,
                        ListeningSocket,
                        AcceptedSocket,
                        NULL,
                        AcceptCompletionRoutine,
                        (PVOID)ListeningSocket,
                        (PVOID)AcceptedSocket
                        );
                if (Error != NO_ERROR) {
                    printf("error %d accepting on socket\n", WSAGetLastError());
                } else {
                    WaitForSingleObject(Event, INFINITE);
                }
            }
            NhDeleteStreamSocket(AcceptedSocket);
        }
        NhDeleteStreamSocket(ListeningSocket);
    }
}


VOID
TestNotification(
    int argc,
    char* argv[]
    )
{
    ULONG Error;
    HANDLE TranslatorHandle;
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_REQUEST_NOTIFICATION RequestNotification;
    IP_NAT_ROUTING_FAILURE_NOTIFICATION RoutingFailureNotification;
    NTSTATUS status;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    printf("waiting for notification...");
    RequestNotification.Code = NatRoutingFailureNotification;
    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            NULL,
            NULL,
            NULL,
            &IoStatus,
            IOCTL_IP_NAT_REQUEST_NOTIFICATION,
            (PVOID)&RequestNotification,
            sizeof(RequestNotification),
            &RoutingFailureNotification,
            sizeof(RoutingFailureNotification)
            );
    if (status == STATUS_PENDING) {
        NtWaitForSingleObject(TranslatorHandle, FALSE, NULL);
        status = IoStatus.Status;
    }
    {
        CHAR address[32];
        lstrcpyA(
            address,
            inet_ntoa(*(PIN_ADDR)&RoutingFailureNotification.DestinationAddress)
            );
        printf(
            "status=%x,destination=%s,source=%s\n", status, address,
            inet_ntoa(*(PIN_ADDR)&RoutingFailureNotification.SourceAddress)
            );
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    printf("done\n");
}


VOID
TestIoCompletionPartialRedirect(
    int argc,
    char* argv[]
    )
{
    IP_NAT_CREATE_REDIRECT CreateRedirect;
    ULONG Error;
    FILE_COMPLETION_INFORMATION CompletionInformation;
    HANDLE IoCompletionHandle;
    IO_STATUS_BLOCK IoStatus;
    IP_NAT_REDIRECT_STATISTICS RedirectStatistics;
    NTSTATUS status;
    HANDLE TranslatorHandle;

    Error = NatInitializeTranslator(&TranslatorHandle);
    if (Error) {
        printf("NatInitializeTranslator=%d\n", Error);
        return;
    }

    Event = CreateEvent(NULL, FALSE, FALSE, NULL);

    status =
        NtCreateIoCompletion(
            &IoCompletionHandle,
            IO_COMPLETION_ALL_ACCESS,
            NULL,
            0
            );
    if (!NT_SUCCESS(status)) {
        printf("NtCreateIoCompletion=%x\n", status);
        return;
    }

    CompletionInformation.Port = IoCompletionHandle;
    CompletionInformation.Key = (PVOID)0xAB01ADE9;
    status =
        NtSetInformationFile(
            TranslatorHandle,
            &IoStatus,
            &CompletionInformation,
            sizeof(CompletionInformation),
            FileCompletionInformation
            );
    if (!NT_SUCCESS(status)) {
        printf("NtSetInformationFile=%x\n", status);
        return;
    }

    ZeroMemory(&CreateRedirect, sizeof(CreateRedirect));
    CreateRedirect.Flags =
        IP_NAT_REDIRECT_FLAG_ASYNCHRONOUS|
        IP_NAT_REDIRECT_FLAG_IO_COMPLETION;
    CreateRedirect.Protocol = (UCHAR)atol(argv[2]);
    CreateRedirect.DestinationAddress = inet_addr(argv[3]);
    CreateRedirect.DestinationPort = htons((USHORT)atol(argv[4]));
    CreateRedirect.NewDestinationAddress = inet_addr(argv[5]);
    CreateRedirect.NewDestinationPort = htons((USHORT)atol(argv[6]));

    status =
        NtDeviceIoControlFile(
            TranslatorHandle,
            Event,
            NULL,
            (PVOID)0x12345678,
            &IoStatus,
            IOCTL_IP_NAT_CREATE_REDIRECT,
            &CreateRedirect,
            sizeof(CreateRedirect),
            &RedirectStatistics,
            sizeof(RedirectStatistics)
            );
    if (status != STATUS_PENDING) {
        printf("NtDeviceIoControlFile=%x\n", status);
    } else {
        PVOID ApcContext;
        PVOID KeyContext;
        LARGE_INTEGER Timeout;
        Timeout.LowPart = (1000 * 1000 * 10);
        Timeout.HighPart = 0;
        Timeout = RtlLargeIntegerNegate(Timeout);
        IoStatus.Status = STATUS_CANCELLED;
        for (;;) {
            status =
                NtRemoveIoCompletion(
                    IoCompletionHandle,
                    &KeyContext,
                    &ApcContext,
                    &IoStatus,
                    &Timeout
                    );
            printf("NtRemoveIoCompletion=%x\n", status);
            if (status == STATUS_SUCCESS &&
                IoStatus.Status != STATUS_PENDING) {
                //
                // Redirect completed.
                //
                printf("redirect %x:%x completed\n", KeyContext, ApcContext);
                break;
            } else if (status == STATUS_SUCCESS &&
                       IoStatus.Status == STATUS_PENDING) {
                NAT_SOURCE_MAPPING_REDIRECT_INFORMATION SourceMapping;
                ULONG Length = sizeof(SourceMapping);
                CHAR src[32], newsrc[32];
                //
                // Redirect is activated.
                //
                NatQueryInformationPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6])),
                    &SourceMapping,
                    &Length,
                    NatSourceMappingRedirectInformation
                    );
                lstrcpyA(
                    src,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.SourceAddress)
                    );
                lstrcpyA(
                    newsrc,
                    inet_ntoa(*(PIN_ADDR)&SourceMapping.NewSourceAddress)
                    );
                printf(
                    "redirect %x:%x activated: %s->%s\n",
                    KeyContext, ApcContext, src, newsrc
                    );
            }
            if (_kbhit()) {
                switch(getchar()) {
                    case 'q': { break; }
                    case 's': {
                        NAT_BYTE_COUNT_REDIRECT_INFORMATION ByteCount;
                        ULONG Length = sizeof(ByteCount);
                        NatQueryInformationPartialRedirect(
                            TranslatorHandle,
                            (UCHAR)atol(argv[2]),
                            inet_addr(argv[3]),
                            htons((USHORT)atol(argv[4])),
                            inet_addr(argv[5]),
                            htons((USHORT)atol(argv[6])),
                            &ByteCount,
                            &Length,
                            NatByteCountRedirectInformation
                            );
                        printf(
                            "NatQueryInformationPartialRedirect="
                            "%d,{%I64d,%I64d}\n",
                            Error,
                            ByteCount.BytesForward,
                            ByteCount.BytesReverse
                            );
                        // fall-through
                    }
                    default: continue;
                }
                break;
            }
        }
        if (status != STATUS_SUCCESS) {
            Error =
                NatCancelPartialRedirect(
                    TranslatorHandle,
                    (UCHAR)atol(argv[2]),
                    inet_addr(argv[3]),
                    htons((USHORT)atol(argv[4])),
                    inet_addr(argv[5]),
                    htons((USHORT)atol(argv[6]))
                    );
            printf("NatCancelPartialRedirect=%d\n", Error);
        }
    }

    printf("NatShutdownTranslator...");
    NatShutdownTranslator(TranslatorHandle);
    NtClose(IoCompletionHandle);
    printf("done\n");
}


VOID
TestPortReservation(
    int argc,
    char* argv[]
    )
{
    HANDLE ReservationHandle;
    for (;;) {
        enum {
            PrInitialize,
            PrAcquire,
            PrRelease,
            PrQuit
        } PrOption;
        NTSTATUS Status;
        printf("Options:\n");
        printf("%d - initialize\n", PrInitialize);
        printf("%d - acquire ports\n", PrAcquire);
        printf("%d - release ports\n", PrRelease);
        printf("%d - quit\n", PrQuit);
        printf("> ");
        scanf("%d", &PrOption);
        switch(PrOption) {
            case PrInitialize: {
                USHORT BlockSize;
                printf("enter block size: ");
                scanf("%u", &BlockSize);
                Status =
                    NatInitializePortReservation(BlockSize, &ReservationHandle);
                if (NT_SUCCESS(Status)) {
                    printf("succeeded.\n");
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrAcquire: {
                USHORT PortBase;
                USHORT PortCount;
                printf("enter port count: ");
                scanf("%u", &PortCount);
                Status =
                    NatAcquirePortReservation(
                        ReservationHandle, PortCount, &PortBase
                        );
                if (NT_SUCCESS(Status)) {
                    printf("succeeded: base port %d\n", ntohs(PortBase));
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrRelease: {
                USHORT PortBase;
                USHORT PortCount;
                printf("enter base port: ");
                scanf("%u", &PortBase);
                printf("enter port count: ");
                scanf("%u", &PortCount);
                Status =
                    NatReleasePortReservation(
                        ReservationHandle, ntohs(PortBase), PortCount
                        );
                if (NT_SUCCESS(Status)) {
                    printf("succeeded\n", ntohs(PortBase));
                } else {
                    printf("status: %x\n", Status);
                }
                break;
            }
            case PrQuit: {
                NatShutdownPortReservation(ReservationHandle);
                break;
            }
        }
    }
}


int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    WSADATA wd;
    WSAStartup(MAKEWORD(2,2), &wd);
    if (!lstrcmpiA(argv[1], "-accept") && argc == 2) {
        TestStreamIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-c") && argc == 4) {
        TestDatagramIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-s") && argc == 3) {
        TestDatagramIo(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-n") && argc == 2) {
        TestNotification(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-r") && argc == 11) {
        TestRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-p") && argc == 7) {
        TestPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-port") && argc == 6) {
        TestPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvport") && argc == 6) {
        TestReceiveOnlyPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rp") && argc == 8) {
        TestRestrictedPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-m") && argc == 9) {
        TestDuplicateRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-iop") && argc == 7) {
        TestIoCompletionPartialRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-portreservation") && argc == 2) {
        TestPortReservation(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvdynport") && argc == 7) {
        TestReceiveOnlyDynamicPortRedirect(argc, argv);
    } else if (!lstrcmpiA(argv[1], "-rcvdynp") && argc == 7) {
        TestReceiveOnlyDynamicPartialRedirect(argc, argv);
    } else {
        printf("'nhtest -accept' to test connection-acceptance\n");
        printf("'nhtest -c <client-addr> <server-addr>' to start client\n");
        printf("'nhtest -s <server-addr>' to start server\n");
        printf("'nhtest -n' to wait for notification of routing-failure\n");
        printf("'nhtest -r <p> <da> <dp> <sa> <sp> <da> <dp> <sa> <sp>'\n");
        printf("    creates a full-redirect and waits for activation.\n");
        printf("'nhtest -p <p> <da> <dp> <da> <dp>'\n");
        printf("    creates a partial-redirect and waits for activation.\n");
        printf("'nhtest -port <p> <dp> <da> <dp>'\n");
        printf("    creates a port-redirect and waits for activation.\n");
        printf("'nhtest -rcvport <p> <dp> <da> <dp>'\n");
        printf("    creates a port-redirect for received-packets only\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -rp <p> <da> <dp> <da> <dp> <sa>'\n");
        printf("    creates a restricted partial-redirect\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -m <p> <da> <dp> <da> <dp> <sa> <sp>'\n");
        printf("    creates multiple redirects with the same parameters,\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -iop <p> <da> <dp> <da> <dp>'\n");
        printf("    creates a restricted partial-redirect,\n");
        printf("    associates it with an I/O completion port,\n");
        printf("    and waits for activation.\n");
        printf("'nhtest -portreservation'\n");
        printf("    launches interactive port-reservation API test shell\n");
        printf("'nhtest -rcvdynport <p> <dp> <da> <dp> <backlog>'\n");
        printf("    creates a dynamic port-redirect for received-packets\n");
        printf("    only and waits for interruption.\n");
        printf("'nhtest -rcvdynp <p> <da> <dp> <da> <dp> <backlog>'\n");
        printf("    creates a dynamic partial-redirect for received-packets\n");
        printf("    only and waits for interruption.\n");
    }
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\log.h ===
//============================================================================
// Copyright (c) 1996, Microsoft Corporation
//
// File:    log.h
//
// History:
//  Abolade Gbadegesin  Jan-12-1996     Created.
//
// This file is processed by mapmsg to produce a .mc file,
// then the .mc file is compiled by the message compiler,
// and the resulting binary is included in IPRIP's resource file.
//
// Don't change the comments following the manifest constants
// without understanding how mapmsg works.
//============================================================================


#define IPRIPLOG_BASE                           30000

#define IPRIPLOG_INIT_CRITSEC_FAILED            (IPRIPLOG_BASE + 1)
/*
 * IPRIPv2 was unable to initialize a critical section.
 * The data is the exception code.
 */

#define IPRIPLOG_HEAP_CREATE_FAILED             (IPRIPLOG_BASE + 2)
/*
 * IPRIPv2 was unable to create a heap.
 * The data is the error code.
 */

#define IPRIPLOG_HEAP_ALLOC_FAILED              (IPRIPLOG_BASE + 3)
/*
 * IPRIPv2 was unable to allocate memory from its heap.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_ALREADY_STARTED          (IPRIPLOG_BASE + 4)
/*
 * IPRIPv2 received a start request when it was already running.
 */

#define IPRIPLOG_WSASTARTUP_FAILED              (IPRIPLOG_BASE + 5)
/*
 * IPRIPv2 was unable to start Windows Sockets.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_RWL_FAILED              (IPRIPLOG_BASE + 6)
/*
 * IPRIPv2 was unable to create a synchronization object.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_EVENT_FAILED            (IPRIPLOG_BASE + 7)
/*
 * IPRIPv2 was unable to create an event.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_IF_TABLE_FAILED         (IPRIPLOG_BASE + 8)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about configured network interfaces.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_PEER_TABLE_FAILED       (IPRIPLOG_BASE + 9)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about neighboring IPRIP routers.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_BINDING_TABLE_FAILED    (IPRIPLOG_BASE + 10)
/*
 * IPRIPv2 was unable to initialize a table to hold information
 * about local IP addresses.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SEMAPHORE_FAILED        (IPRIPLOG_BASE + 11)
/*
 * IPRIPv2 was unable to create a semaphore.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SOCKET_FAILED           (IPRIPLOG_BASE + 12)
/*
 * IPRIPv2 was unable to create a socket.
 * The data is the error code.
 */

#define IPRIPLOG_RTM_REGISTER_FAILED            (IPRIPLOG_BASE + 13)
/*
 * IPRIPv2 was unable to register with the Routing Table Manager.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_THREAD_FAILED           (IPRIPLOG_BASE + 14)
/*
 * IPRIPv2 was unable to create a thread.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_STARTED                  (IPRIPLOG_BASE + 15)
/*
 * IPRIPv2 has started successfully.
 */

#define IPRIPLOG_BIND_IF_FAILED                 (IPRIPLOG_BASE + 16)
/*
 * IPRIPv2 could not bind to IP address %1.
 * Please make sure TCP/IP is installed and configured correctly.
 * The data is the error code.
 */

#define IPRIPLOG_QUEUE_WORKER_FAILED            (IPRIPLOG_BASE + 17)
/*
 * IPRIPv2 could not schedule a task to be executed.
 * This may have been caused by a memory allocation failure.
 * The data is the error code.
 */

#define IPRIPLOG_ADD_ROUTE_FAILED_1             (IPRIPLOG_BASE + 18)
/*
 * IPRIPv2 was unable to add a route to the Routing Table Manager.
 * The route is to network %1 with next-hop %3.
 * The data is the error code.
 */

#define IPRIPLOG_SELECT_FAILED                  (IPRIPLOG_BASE + 19)
/*
 * IPRIPv2 received an error in a call to select().
 * This may indicate underlying network problems.
 * The data is the error code.
 */

#define IPRIPLOG_RECVFROM_FAILED                (IPRIPLOG_BASE + 20)
/*
 * IPRIPv2 was unable to receive an incoming message
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_PACKET_TOO_SMALL               (IPRIPLOG_BASE + 21)
/*
 * IPRIPv2 received a packet which was smaller than the minimum size
 * allowed for IPRIP packets. The packet has been discarded.
 * It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IPRIPLOG_PACKET_VERSION_INVALID         (IPRIPLOG_BASE + 22)
/*
 * IPRIPv2 received a packet with an invalid version in its header.
 * The packet has been discarded. It was received on the local interface
 * with IP address %1, and it came from the neighboring router
 * with IP address %2.
 */ 

#define IPRIPLOG_PACKET_HEADER_CORRUPT          (IPRIPLOG_BASE + 23)
/*
 * IPRIPv2 received a packet with an invalid header. The packet has been
 * discarded. It was received on the local interface with IP address %1,
 * and it came from the neighboring router with IP address %2.
 */

#define IPRIPLOG_SENDTO_FAILED                  (IPRIPLOG_BASE + 24)
/*
 * IPRIPv2 was unable to send a packet from the interface with IP address %1
 * to the IP address %2.
 * The data is the error code.
 */

#define IPRIPLOG_RESPONSE_FILTERED              (IPRIPLOG_BASE + 25)
/*
 * IPRIPv2 discarded a response packet from a neighbor with IP address %1.
 * IPRIPv2 is not configured to accept packets from the above neighbor.
 */

#define IPRIPLOG_PACKET_VERSION_MISMATCH        (IPRIPLOG_BASE + 26)
/*
 * IPRIPv2 discarded a version %1 packet received on the interface
 * with IP address %2 from a neighbor with IP address %3.
 * The above interface is configured to accept only version %4 packets.
 */

#define IPRIPLOG_AUTHENTICATION_FAILED          (IPRIPLOG_BASE + 27)
/*
 * IPRIPv2 discarded a packet received on the interface with IP address %1
 * from a neighboring router with IP address %2, because the packet
 * failed authentication.
 */

#define IPRIPLOG_ROUTE_CLASS_INVALID            (IPRIPLOG_BASE + 28)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2 which was advertised
 * by a neighbor with IP address %3. The route's network class is invalid.
 */

#define IPRIPLOG_LOOPBACK_ROUTE_INVALID         (IPRIPLOG_BASE + 29)
/*
 * IPRIPv2 is ignoring a route to the loopback network %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3.
 */

#define IPRIPLOG_BROADCAST_ROUTE_INVALID        (IPRIPLOG_BASE + 30)
/*
 * IPRIPv2 is ignoring a route to the broadcast network %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3.
 */

#define IPRIPLOG_HOST_ROUTE_INVALID             (IPRIPLOG_BASE + 31)
/*
 * IPRIPv2 is ignoring a host route to %1 with next-hop %2 which was
 * advertised by a neighbor with IP address %3, because the interface
 * on which the route was received is configured to reject host routes.
 */

#define IPRIPLOG_DEFAULT_ROUTE_INVALID          (IPRIPLOG_BASE + 32)
/*
 * IPRIPv2 is ignoring a default route with next-hop %2 which was
 * advertised by a neighbor with IP address %3, because the interface
 * on which the route was received is configured to reject default routes.
 */

#define IPRIPLOG_ROUTE_FILTERED                 (IPRIPLOG_BASE + 33)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2 which was advertised
 * by a neighbor with IP address %3, because the interface on which
 * the route was received has a filter configured which excluded this route.
 */

#define IPRIPLOG_ADD_ROUTE_FAILED_2             (IPRIPLOG_BASE + 34)
/*
 * IPRIPv2 was unable to add a route to the Routing Table Manager.
 * The route is to %1 with next-hop %2 and it was received from a neighbor
 * with IP address %3.
 * The data is the error code.
 */

#define IPRIPLOG_RTM_ENUMERATE_FAILED           (IPRIPLOG_BASE + 35)
/*
 * IPRIPv2 was unable to enumerate the routes in the Routing Table Manager.
 * The data is the error code.
 */

#define IPRIPLOG_IPRIP_STOPPED                  (IPRIPLOG_BASE + 36)
/*
 * IPRIPv2 has stopped.
 */

#define IPRIPLOG_NEW_ROUTE_LEARNT_1             (IPRIPLOG_BASE + 37)
/*
 * IPRIPv2 has learnt of a new route. The route is to network %1
 * with next-hop %2, and the route was learnt from the neighbor
 * with IP address %3.
 */

#define IPRIPLOG_ROUTE_NEXTHOP_CHANGED          (IPRIPLOG_BASE + 38)
/*
 * IPRIPv2 has changed the next-hop of the route to %1.
 * The new next-hop is %2.
 */

#define IPRIPLOG_ROUTE_METRIC_CHANGED           (IPRIPLOG_BASE + 39)
/*
 * IPRIPv2 has learnt of a change in metric for its route to %1 
 * with next-hop %2. The new metric is %3.
 */

#define IPRIPLOG_NEW_ROUTE_LEARNT_2             (IPRIPLOG_BASE + 40)
/*
 * IPRIPv2 has learnt of a new route. The route is to network %1
 * with next-hop %2.
 */

#define IPRIPLOG_ROUTE_EXPIRED                  (IPRIPLOG_BASE + 41)
/*
 * IPRIPv2 has timed-out its route to %1 with next-hop %2,
 * since no neighboring routers announced the route.
 * The route will now be marked for deletion.
 */

#define IPRIPLOG_ROUTE_DELETED                  (IPRIPLOG_BASE + 42)
/*
 * IPRIPv2 has deleted its route to %1 with next-hop %2,
 * since the route timed-out and no neighboring routers announced the route.
 */

#define IPRIPLOG_ROUTE_ENTRY_IGNORED            (IPRIPLOG_BASE + 43)
/*
 * IPRIPv2 is ignoring a route on the local interface with IP address %1.
 * The route is to the network %1 and it was received from a neighbor
 * with IP address %2.
 * The route is being ignored because it contains some invalid information.
 */

#define IPRIPLOG_ROUTE_METRIC_INVALID           (IPRIPLOG_BASE + 44)
/*
 * IPRIPv2 is ignoring a route to %1 with next-hop %2
 * which was advertised by a neighbor with IP address %3,
 * since the route was advertised with an invalid metric.
 * The data is the metric.
 */

#define IPRIPLOG_ENUM_NETWORK_EVENTS_FAILED     (IPRIPLOG_BASE + 45)
/*
 * IPRIPv2 was unable to enumerate network events on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_INPUT_RECORD_ERROR             (IPRIPLOG_BASE + 46)
/*
 * IPRIPv2 detected an error on the local interface with IP address %1.
 * The error occurred while the interface was receiving packets.
 * The data is the error code.
 */

#define IPRIPLOG_EVENTSELECT_FAILED             (IPRIPLOG_BASE + 47)
/*
 * IPRIPv2 was unable to request notification of events
 * on the socket for the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_SOCKET_FAILED_2         (IPRIPLOG_BASE + 48)
/*
 * IPRIPv2 was unable to create a socket for the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_ENABLE_BROADCAST_FAILED        (IPRIPLOG_BASE + 49)
/*
 * IPRIPv2 could not enable broadcasting on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_BIND_FAILED                    (IPRIPLOG_BASE + 50)
/*
 * IPRIPv2 could not bind to port 520 on the socket for
 * the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_SET_MCAST_IF_FAILED            (IPRIPLOG_BASE + 51)
/*
 * IPRIPv2 could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_JOIN_GROUP_FAILED              (IPRIPLOG_BASE + 52)
/*
 * IPRIPv2 could not join the multicast group 224.0.0.9
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define IPRIPLOG_INVALID_PORT                   (IPRIPLOG_BASE + 25)
/*
 * IPRIPv2 discarded a response packet from a neighbor with IP address %1.
 * The packet was not sent from the standard IP RIP port (520).
 */

#define IPRIPLOG_REGISTER_WAIT_FAILED           (IPRIPLOG_BASE + 26)
/*
 * IPRIPv2 could not register an event with the Ntdll wait thread.
 * The data is the error code.
 */

#define IPRIPLOG_CREATE_TIMER_QUEUE_FAILED      (IPRIPLOG_BASE + 27)
/*
 * IPRIPv2 could not register a timer queue with the Ntdll thread.
 * The data is the error code.
 */

#define IPRIPLOG_INVALID_IF_CONFIG              (IPRIPLOG_BASE + 28)
/*
 * IPRIPV2 could not be enabled on the interface.
 * Parameter %1 has an invalid value %2.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\makefile.inc ===
$(O)\ipripmsg.mc: log.h
    mapmsg NET IPRIPLOG_BASE log.h > $(O)\ipripmsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\api.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: api.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Contains definitions for the API entry-points used by Router Manager.
//============================================================================

#ifndef _API_H_
#define _API_H_



BOOL 
DllStartup(
    );

BOOL
DllCleanup(
    );

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PVOID pConfig
    );

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    );



//
// function declarations for router manager interface:
//

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    );

DWORD
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
APIENTRY 
StartComplete(
    VOID
    );

DWORD
APIENTRY
StopProtocol(
    VOID
    );

DWORD WINAPI
GetGlobalInfo (
    PVOID OutGlobalInfo,
    PULONG GlobalInfoSize,
    PULONG   StructureVersion,
    PULONG   StructureSize,
    PULONG   StructureCount
    );

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    );

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT MESSAGE *pResult
    );

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    );

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    );

DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    );

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    );

DWORD
APIENTRY
UnBindInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    );

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    );

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    );


#endif // _API_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\pchrip.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: pchrip.h
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// Precompiled header for IPRIP
//============================================================================

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#define FD_SETSIZE      256
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>
#include <rtmv2.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ipriprm.h>
#include "defs.h"
#include "sync.h"
#include "route.h"
#include "queue.h"
#include "table.h"
#include "work.h"
#include "api.h"
#include "iprip.h"
#include "log.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\api.c ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: api.c
//
// History:
//      Abolade Gbadegesin  Aug-8-1995  Created.
//
// router manager API implementations
//============================================================================

#include "pchrip.h"
#pragma hdrstop



//
// Definition of sole global variable for IPRIP
//

IPRIP_GLOBALS ig;



//----------------------------------------------------------------------------
// Function:    DLLMAIN
//
// This is the DLL entrypoint handler. It calls DllStartup
// to initialize locking and event queue and to create IPRIP's heap,
// and calls DllCleanup to delete the lock and event queue.
//----------------------------------------------------------------------------

BOOL
WINAPI
DLLMAIN(
    HINSTANCE hInstance,
    DWORD dwReason,
    PVOID pUnused
    ) {

    BOOL bErr;


    bErr = FALSE;

    switch(dwReason) {
        case DLL_PROCESS_ATTACH:

            DisableThreadLibraryCalls(hInstance);

            bErr = DllStartup();
            break;

        case DLL_PROCESS_DETACH:

            bErr = DllCleanup();
            break;

        default:

            bErr = TRUE;
            break;
    }

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllStartup
//
// Initializes IPRIP's function lock, event queue, and global heap.
//----------------------------------------------------------------------------

BOOL
DllStartup(
    ) {

    BOOL bErr;
    DWORD dwErr;


    bErr = TRUE;

    do { // error breakout loop

        ZeroMemory(&ig, sizeof(IPRIP_GLOBALS));


        //
        // create the global critical section and set IPRIP's status
        //

        try {
            InitializeCriticalSection(&ig.IG_CS);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            bErr = FALSE;
            break;
        }

        ig.IG_Status = IPRIP_STATUS_STOPPED;


        //
        // attempt to create a private heap for IPRIP
        //

        ig.IG_IpripGlobalHeap = HeapCreate(0, 0, 0);

        if (ig.IG_IpripGlobalHeap == NULL) {

            bErr = FALSE;
            break;
        }


        //
        // create the router manager message queue
        //


        ig.IG_EventQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_EventQueue == NULL) {

            bErr = FALSE;
            break;
        }


        //
        // initialize the Router Manager event queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_EventQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            bErr = FALSE;
            break;
        }


    } while(FALSE);

    return bErr;
}



//----------------------------------------------------------------------------
// Function:    DllCleanup
//
// Deletes the global heap, event queue, and function lock.
//----------------------------------------------------------------------------

BOOL
DllCleanup(
    ) {

    BOOL bErr;


    bErr = TRUE;


    do { // error breakout loop

        //
        // destroy the router manager event queue
        //

        if (ig.IG_EventQueue != NULL) {

            if (LOCKED_LIST_CREATED(ig.IG_EventQueue)) {

                DELETE_LOCKED_LIST(
                    ig.IG_EventQueue, EVENT_QUEUE_ENTRY, EQE_Link
                    );
            }

            RIP_FREE(ig.IG_EventQueue);
        }


        if (ig.IG_IpripGlobalHeap != NULL) {
            HeapDestroy(ig.IG_IpripGlobalHeap);
        }



        //
        // delete the global critical section
        //

        DeleteCriticalSection(&ig.IG_CS);


        RouterLogDeregister(ig.IG_LogHandle);
        if (ig.IG_TraceID != INVALID_TRACEID) {
            TraceDeregister(ig.IG_TraceID);
        }
        
    } while(FALSE);


    return bErr;
}




//----------------------------------------------------------------------------
// Function:    ProtocolStartup
//
// This is called by StartProtocol. Initializes data structures,
// creates IPRIP threads.
//----------------------------------------------------------------------------

DWORD
ProtocolStartup(
    HANDLE hEventEvent,
    PVOID pConfig
    ) {

    WSADATA wd;
    HANDLE hThread;
    BOOL bCleanupWinsock;
    DWORD dwErr, dwSize, dwThread;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;



    EnterCriticalSection(&ig.IG_CS);

    ig.IG_TraceID = TraceRegister("IPRIP2");
    ig.IG_LogHandle = RouterLogRegister("IPRIP2");


    //
    // make certain RIP is not already running
    //

    if (ig.IG_Status != IPRIP_STATUS_STOPPED) {

        TRACE0(START, "ERROR: StartProtocol called with IPRIP already running");
        LOGWARN0(IPRIP_ALREADY_STARTED, NO_ERROR);

        LeaveCriticalSection(&ig.IG_CS);
        return ERROR_CAN_NOT_COMPLETE;
    }



    bCleanupWinsock = FALSE;


    do { // break-out construct



        TRACE0(ENTER, "IPRIP is starting up");


        //
        // save the Router Manager notification event
        //

        ig.IG_EventEvent = hEventEvent;


        //
        // find the size of the global configuration passed in
        //

        pgcsrc = (PIPRIP_GLOBAL_CONFIG)pConfig;

        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // allocate a block to hold the configuration
        //

        ig.IG_Config = pgcdst = RIP_ALLOC(dwSize);

        if (pgcdst == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for global config",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy the supplied configuration
        //

        CopyMemory(pgcdst, pgcsrc, dwSize);
        ig.IG_LogLevel = pgcsrc->GC_LoggingLevel;


        //
        // attempt to start Winsock
        //

        dwErr = (DWORD)WSAStartup(MAKEWORD(1,1), &wd);

        if (dwErr != 0) {

            TRACE1(START, "error %d starting Windows Sockets.", dwErr);
            LOGERR0(WSASTARTUP_FAILED, dwErr);

            break;
        }

        bCleanupWinsock = TRUE;


        //
        // attempt to create synchronization object for global config
        //

        dwErr = CreateReadWriteLock(&ig.IG_RWL);
        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d creating read-write lock", dwErr);
            LOGERR0(CREATE_RWL_FAILED, dwErr);

            break;
        }


        //
        // register a timer queue with Ntdll timer thread
        //

        ig.IG_TimerQueueHandle = CreateTimerQueue();

        if ( !ig.IG_TimerQueueHandle) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering time queue with NtdllTimer thread",
                dwErr
                );
            LOGERR0(CREATE_TIMER_QUEUE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for an interface table
        //

        ig.IG_IfTable = RIP_ALLOC(sizeof(IF_TABLE));
        if (ig.IG_IfTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for interface table",
                dwErr, sizeof(IF_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the interface table
        //

        dwErr = CreateIfTable(ig.IG_IfTable);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing interface table", dwErr);
            LOGERR0(CREATE_IF_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the peer statistics table
        //

        ig.IG_PeerTable = RIP_ALLOC(sizeof(PEER_TABLE));

        if (ig.IG_PeerTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for peer table",
                dwErr, sizeof(PEER_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the peer statistics table
        //

        dwErr = CreatePeerTable(ig.IG_PeerTable);

        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d initializing peer statistics table", dwErr);
            LOGERR0(CREATE_PEER_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the binding table
        //

        ig.IG_BindingTable = RIP_ALLOC(sizeof(BINDING_TABLE));

        if (ig.IG_BindingTable == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for binding table",
                dwErr, sizeof(PEER_TABLE)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the binding table
        //

        dwErr = CreateBindingTable(ig.IG_BindingTable);
        if (dwErr != NO_ERROR) {

            TRACE1(START, "error %d creating binding table", dwErr);
            LOGERR0(CREATE_BINDING_TABLE_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the send queue
        //

        ig.IG_SendQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_SendQueue == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for send-queue",
                dwErr, sizeof(LOCKED_LIST)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the send queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_SendQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "exception %d initializing send queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);

            break;
        }


        //
        // allocate space for the receive queue
        //

        ig.IG_RecvQueue = RIP_ALLOC(sizeof(LOCKED_LIST));

        if (ig.IG_RecvQueue == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for receive queue",
                dwErr, sizeof(LOCKED_LIST)
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // initialize the receive queue
        //

        try {
            CREATE_LOCKED_LIST(ig.IG_RecvQueue);
        }
        except (EXCEPTION_EXECUTE_HANDLER) {

            dwErr = GetExceptionCode();
            TRACE1(START, "exception %d initializing receive queue", dwErr);
            LOGERR0(INIT_CRITSEC_FAILED, dwErr);

            break;
        }



        //
        // create event signalled by WinSock when input arrives
        // and register it with the NtdllWait thread
        //

        ig.IG_IpripInputEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (ig.IG_IpripInputEvent == NULL) {

            dwErr = GetLastError();
            TRACE1(START, "error %d creating event to signal input", dwErr);
            LOGERR0(CREATE_EVENT_FAILED, dwErr);

            break;
        }

         
        if (! RegisterWaitForSingleObject(
                  &ig.IG_IpripInputEventHandle,
                  ig.IG_IpripInputEvent,
                  CallbackFunctionNetworkEvents,
                  NULL,
                  INFINITE,
                  (WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE)
                  )) {

            dwErr = GetLastError();
            
            TRACE1(START,
                "error %d registering input event with NtdllWait thread",
                dwErr);
            LOGERR0(REGISTER_WAIT_FAILED, dwErr);

            break;
        }


        //
        // initialize the count of threads which are active in IPRIP
        // (includes IpripThread and worker threads),
        // and create the semaphore released by each thread when it is done
        //

        ig.IG_ActivityCount = 0;

        ig.IG_ActivitySemaphore = CreateSemaphore(NULL, 0, 0xfffffff, NULL);

        if (ig.IG_ActivitySemaphore == NULL) {

            dwErr = GetLastError();
            TRACE1(
                START, "error %d creating semaphore for IPRIP threads", dwErr
                );
            LOGERR0(CREATE_SEMAPHORE_FAILED, dwErr);

            break;
        }



        //
        // register with RTMv2
        //

        ig.IG_RtmEntityInfo.RtmInstanceId = 0;
        ig.IG_RtmEntityInfo.AddressFamily = AF_INET;
        ig.IG_RtmEntityInfo.EntityId.EntityProtocolId = PROTO_IP_RIP;
        ig.IG_RtmEntityInfo.EntityId.EntityInstanceId = 0;
        
        dwErr = RtmRegisterEntity(
                    &ig.IG_RtmEntityInfo, NULL,
                    ProcessRtmNotification,
                    FALSE, &ig.IG_RtmProfile,
                    &ig.IG_RtmHandle
                    );

        if (dwErr != NO_ERROR ) {
        
            TRACE1(START, "error %d registering with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);

            break;
        }

        dwErr = RtmRegisterForChangeNotification(
                    ig.IG_RtmHandle,
                    RTM_VIEW_MASK_UCAST,
                    RTM_CHANGE_TYPE_BEST,
                    NULL,
                    &ig.IG_RtmNotifHandle
                    );

        if (dwErr != NO_ERROR ) {
        
            TRACE1(START, "error %d registering for change with RTM", dwErr);
            LOGERR0(RTM_REGISTER_FAILED, dwErr);

            break;
        }

                    
        //
        // set IPRIP's status to running now, before we attempt
        // to queue the MIB display work-item;
        // QueueRipWorker() will check the status,
        // and it will refuse to queue any work-items
        // unless the status is IPRIP_STATUS_RUNNING
        //

        ig.IG_Status = IPRIP_STATUS_RUNNING;


#if CONFIG_DBG

        //
        // queue work item to display IPRIP's MIB tables periodically
        //

        ig.IG_MibTraceID = TraceRegisterEx("IPRIPMIB", TRACE_USE_CONSOLE);

        if (ig.IG_MibTraceID != INVALID_TRACEID) {
        
            //
            // create the persistent timer for the timer queue
            //

            if (!CreateTimerQueueTimer(
                    &ig.IG_MibTimerHandle, ig.IG_TimerQueueHandle,
                    WorkerFunctionMibDisplay, NULL,
                    0, 10000, 0)) {

                dwErr = GetLastError();
                
                TRACE1(START, "error %d creating MIB display timer", dwErr);
            }
        }

#endif


        TRACE0(START, "IPRIP has started successfully");
        LOGINFO0(IPRIP_STARTED, NO_ERROR);

        LeaveCriticalSection(&ig.IG_CS);

        return NO_ERROR;


    } while (FALSE);



    //
    // something went wrong, so we cleanup.
    // Note that we needn't worry about the main thread,
    // since when we finally leave this critical section it will find
    // that the status is IPRIP_STATUS_STOPPED, and it will immediately quit
    //

    TRACE0(START, "IPRIP failed to start");

    ProtocolCleanup(bCleanupWinsock);


    LeaveCriticalSection(&ig.IG_CS);

    return (dwErr == NO_ERROR ? ERROR_CAN_NOT_COMPLETE : dwErr);
}



//----------------------------------------------------------------------------
// Function: ProtocolCleanup
//
// This function deallocates allocated memory, closes open handles, and
// cleans up the global struct. It leaves IPRIP in clean state, so that
// it should be possible to do StartProtocol again with no memory leaks.
//----------------------------------------------------------------------------

DWORD
ProtocolCleanup(
    BOOL bCleanupWinsock
    ) {

    DWORD dwErr;
    
    // EnterCriticalSection(&ig.IG_CS);


#ifdef CONFIG_DBG
    TraceDeregister(ig.IG_MibTraceID);
    ig.IG_MibTraceID = INVALID_TRACEID;
#endif


    if ( ig.IG_RtmNotifHandle != NULL ) {
    
        dwErr = RtmDeregisterFromChangeNotification(
                    ig.IG_RtmHandle, ig.IG_RtmNotifHandle
                    );

        if ( dwErr != NO_ERROR ) {

            TRACE1(STOP, "error %d deregistering change notification", dwErr);
        }    
    }

    if (ig.IG_RtmHandle != NULL) {
    
        dwErr = RtmDeregisterEntity(ig.IG_RtmHandle);

        if ( dwErr != NO_ERROR ) {

            TRACE1(STOP, "error %d deregistering from RTM", dwErr);
        }    
    }
        

    if (ig.IG_ActivitySemaphore != NULL) {

        CloseHandle(ig.IG_ActivitySemaphore);
        ig.IG_ActivitySemaphore = NULL;
    }


    if (ig.IG_IpripInputEvent != NULL) {

        CloseHandle(ig.IG_IpripInputEvent);
        ig.IG_IpripInputEvent = NULL;
    }



    if (ig.IG_RecvQueue != NULL) {

        if (LOCKED_LIST_CREATED(ig.IG_RecvQueue)) {

            FlushRecvQueue(ig.IG_RecvQueue);

            DELETE_LOCKED_LIST(ig.IG_RecvQueue, RECV_QUEUE_ENTRY, RQE_Link);
        }

        RIP_FREE(ig.IG_RecvQueue);
        ig.IG_RecvQueue = NULL;
    }


    if (ig.IG_SendQueue != NULL) {

        if (LOCKED_LIST_CREATED(ig.IG_SendQueue)) {

            FlushSendQueue(ig.IG_SendQueue);

            DELETE_LOCKED_LIST(ig.IG_SendQueue, SEND_QUEUE_ENTRY, SQE_Link);
        }

        RIP_FREE(ig.IG_SendQueue);
        ig.IG_SendQueue = NULL;
    }


    if (ig.IG_BindingTable != NULL) {
        if (BINDING_TABLE_CREATED(ig.IG_BindingTable)) {
            DeleteBindingTable(ig.IG_BindingTable);
        }

        RIP_FREE(ig.IG_BindingTable);
        ig.IG_BindingTable = NULL;
    }


    if (ig.IG_PeerTable != NULL) {

        if (PEER_TABLE_CREATED(ig.IG_PeerTable)) {
            DeletePeerTable(ig.IG_PeerTable);
        }

        RIP_FREE(ig.IG_PeerTable);
        ig.IG_PeerTable = NULL;
    }


    if (ig.IG_IfTable != NULL) {

        if (IF_TABLE_CREATED(ig.IG_IfTable)) {
            DeleteIfTable(ig.IG_IfTable);
        }

        RIP_FREE(ig.IG_IfTable);
        ig.IG_IfTable = NULL;
    }


    if (READ_WRITE_LOCK_CREATED(&ig.IG_RWL)) {
        DeleteReadWriteLock(&ig.IG_RWL);
    }


    if (bCleanupWinsock) {
        WSACleanup();
    }


    if (ig.IG_Config != NULL) {

        RIP_FREE(ig.IG_Config);
        ig.IG_Config = NULL;
    }


    ig.IG_Status = IPRIP_STATUS_STOPPED;

    // LeaveCriticalSection(&ig.IG_CS);

    return NO_ERROR;

}




//----------------------------------------------------------------------------
// Function:    RegisterProtocol
//
// Returns protocol ID and functionality for IPRIP
//----------------------------------------------------------------------------

DWORD
APIENTRY
RegisterProtocol(
    IN OUT PMPR_ROUTING_CHARACTERISTICS pRoutingChar,
    IN OUT PMPR_SERVICE_CHARACTERISTICS pServiceChar
    )
{
    if(pRoutingChar->dwProtocolId != MS_IP_RIP)
    {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Since we are not a service advertiser (and IPX thing)
    //

    pServiceChar->fSupportedFunctionality = 0;

    if((pRoutingChar->fSupportedFunctionality & (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES)) !=
       (RF_ROUTING|RF_DEMAND_UPDATE_ROUTES))
    {
        return ERROR_NOT_SUPPORTED;
    }

    pRoutingChar->fSupportedFunctionality = (RF_ROUTING | RF_DEMAND_UPDATE_ROUTES);

   pRoutingChar->fSupportedFunctionality = RF_ROUTING;

   pRoutingChar->pfnStartProtocol      = StartProtocol;
   pRoutingChar->pfnStartComplete      = StartComplete;
   pRoutingChar->pfnStopProtocol       = StopProtocol;
   pRoutingChar->pfnGetGlobalInfo      = GetGlobalInfo;
   pRoutingChar->pfnSetGlobalInfo      = SetGlobalInfo;
   pRoutingChar->pfnQueryPower         = NULL;
   pRoutingChar->pfnSetPower           = NULL;

   pRoutingChar->pfnAddInterface       = AddInterface;
   pRoutingChar->pfnDeleteInterface    = DeleteInterface;
   pRoutingChar->pfnInterfaceStatus    = InterfaceStatus;
   pRoutingChar->pfnGetInterfaceInfo   = GetInterfaceConfigInfo;
   pRoutingChar->pfnSetInterfaceInfo   = SetInterfaceConfigInfo;

   pRoutingChar->pfnGetEventMessage    = GetEventMessage;

   pRoutingChar->pfnUpdateRoutes       = DoUpdateRoutes;

   pRoutingChar->pfnConnectClient      = NULL;
   pRoutingChar->pfnDisconnectClient   = NULL;

   pRoutingChar->pfnGetNeighbors       = NULL;
   pRoutingChar->pfnGetMfeStatus       = NULL;

   pRoutingChar->pfnMibCreateEntry     = MibCreate;
   pRoutingChar->pfnMibDeleteEntry     = MibDelete;
   pRoutingChar->pfnMibGetEntry        = MibGet;
   pRoutingChar->pfnMibSetEntry        = MibSet;
   pRoutingChar->pfnMibGetFirstEntry   = MibGetFirst;
   pRoutingChar->pfnMibGetNextEntry    = MibGetNext;

    return NO_ERROR;
}




//----------------------------------------------------------------------------
// Function:    StartProtocol
//
// creates events, tables and queues used by IPRIP, registers with RTM,
// and starts threads.
//----------------------------------------------------------------------------

DWORD
WINAPI
StartProtocol (
    HANDLE              NotificationEvent,
    SUPPORT_FUNCTIONS   *SupportFunctions,
    LPVOID              GlobalInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    ig.IG_SupportFunctions = *SupportFunctions;
    
    return ProtocolStartup(NotificationEvent, GlobalInfo);
}


//----------------------------------------------------------------------------
// Function:    StartComplete
//
// Invoked by RouterManager to inform protocol that startup (init + interface
// additions are complete).  Protocol is expected to wait for this before
// starting protocol specfic behavior
//----------------------------------------------------------------------------

DWORD
APIENTRY 
StartComplete(
    VOID
    )
{
    return NO_ERROR;
}

//----------------------------------------------------------------------------
// Function:    StopProtocol
//
// This function is onvoked by Router Manager. It informs the main thread
// that it should exit, and then queues a work-item which waits for it
// to exit as well as any active or queued work-items.
//----------------------------------------------------------------------------

DWORD
APIENTRY
StopProtocol(
    VOID
    ) {

    LONG lThreadCount;



    EnterCriticalSection(&ig.IG_CS);


    //
    // cannot stop if already stopped
    //

    if (ig.IG_Status != IPRIP_STATUS_RUNNING) {

        LeaveCriticalSection(&ig.IG_CS);
        return ERROR_CAN_NOT_COMPLETE;
    }



    TRACE0(ENTER, "entering StopProtocol");


    //
    // set IPRIP's status to STOPPING;
    // this prevents any more work-items from being queued,
    // and it prevents the ones already queued from executing
    //

    ig.IG_Status = IPRIP_STATUS_STOPPING;


    //
    // find out how many threads are active in IPRIP;
    // we will have to wait for this many threads to exit
    // before we clean up RIP's resources
    //

    lThreadCount = ig.IG_ActivityCount;

    TRACE1(STOP, "%d threads are active in IPRIP", lThreadCount);


    LeaveCriticalSection(&ig.IG_CS);


    //
    // queue the stopprotocol work-item, and return PENDING to Router Manager
    //

    QueueUserWorkItem(
        (LPTHREAD_START_ROUTINE)WorkerFunctionFinishStopProtocol,
        (PVOID)UlongToPtr(lThreadCount), 0
        );



    TRACE0(LEAVE, "leaving StopProtocol");

    return ERROR_PROTOCOL_STOP_PENDING;
}



//----------------------------------------------------------------------------
// Function:    GetGlobalInfo
//
// Copies to the given buffer the global information currently in use by
// IPRIP.
//----------------------------------------------------------------------------

DWORD WINAPI
GetGlobalInfo (
    PVOID   OutGlobalInfo,
    PULONG  GlobalInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }


    TRACE2(ENTER, "entering GetGlobalInfo: 0x%08x 0x%08x", OutGlobalInfo, GlobalInfoSize);


    dwErr = NO_ERROR;


    ACQUIRE_GLOBAL_LOCK_SHARED();


    do {


        //
        // check the arguments
        //

        if (GlobalInfoSize == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pgcsrc = ig.IG_Config;
        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // check the buffer size
        //

        if (*GlobalInfoSize < dwSize || OutGlobalInfo == NULL) {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
        else {
            pgcdst = (PIPRIP_GLOBAL_CONFIG)OutGlobalInfo;

            *StructureVersion    = 1;
            *StructureSize       = dwSize;
            *StructureCount      = 1;

            CopyMemory(pgcdst, pgcsrc, dwSize);
        }

        *GlobalInfoSize = dwSize;

    } while(FALSE);

    RELEASE_GLOBAL_LOCK_SHARED();


    TRACE1(LEAVE, "leaving GetGlobalInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetGlobalInfo
//
// Changes IPRIP's global configuration to the supplied values.
//----------------------------------------------------------------------------

DWORD WINAPI
SetGlobalInfo (
    PVOID   GlobalInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIPRIP_GLOBAL_CONFIG pgcsrc, pgcdst;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering SetGlobalInfo: 0x%08x", GlobalInfo);

    dwErr = NO_ERROR;


    ACQUIRE_GLOBAL_LOCK_EXCLUSIVE();


    do {

        //
        // check the argument
        //

        if (GlobalInfo == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        pgcsrc = (PIPRIP_GLOBAL_CONFIG)GlobalInfo;


        //
        // find the size of the new global config
        //

        dwSize = IPRIP_GLOBAL_CONFIG_SIZE(pgcsrc);


        //
        // allocate space for the private copy of the config
        //

        pgcdst = (PIPRIP_GLOBAL_CONFIG)RIP_ALLOC(dwSize);

        if (pgcdst == NULL) {

            dwErr = GetLastError();
            TRACE2(
                ANY, "error %d allocating %d bytes for global config",
                dwErr, dwSize
                );
            LOGERR0(HEAP_ALLOC_FAILED, dwErr);

            break;
        }


        //
        // copy from the buffer
        //

        CopyMemory(pgcdst, pgcsrc, dwSize);
        InterlockedExchange(&ig.IG_LogLevel, pgcsrc->GC_LoggingLevel);

        if (ig.IG_Config != NULL) { RIP_FREE(ig.IG_Config); }

        ig.IG_Config = pgcdst;


    } while(FALSE);


    RELEASE_GLOBAL_LOCK_EXCLUSIVE();


    TRACE1(LEAVE, "leaving SetGlobalInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    AddInterface
//
// This function is called to add an interface with the given configuration
// to IPRIP. The interface is created inactive.
//----------------------------------------------------------------------------

DWORD WINAPI
AddInterface (
    PWCHAR              pwszInterfaceName,
    ULONG               InterfaceIndex,
    NET_INTERFACE_TYPE  InterfaceType,
    DWORD               MediaType,
    WORD                AccessType,
    WORD                ConnectionType,
    PVOID               InterfaceInfo,
    ULONG               StructureVersion,
    ULONG               StructureSize,
    ULONG               StructureCount
    )
{
    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering AddInterface: %d %d 0x%08x", InterfaceIndex, InterfaceType, InterfaceInfo
        );



    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = CreateIfEntry(ig.IG_IfTable, InterfaceIndex, InterfaceType, InterfaceInfo, NULL);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving AddInterface: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DeleteInterface
//
// This removes the interface with the given index, deactivating it if
// necessary.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DeleteInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering DeleteInterface: %d", dwIndex);


    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = DeleteIfEntry(ig.IG_IfTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving DeleteInterface: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetEventMessage
//
// Dequeues a message for Router Manager from IPRIP's event queue.
//----------------------------------------------------------------------------

DWORD
APIENTRY
GetEventMessage(
    OUT ROUTING_PROTOCOL_EVENTS *pEvent,
    OUT PMESSAGE pResult
    ) {

    DWORD dwErr;



    //
    // note that GetEventMessage does not use the
    // ENTER_RIP_API()/LEAVE_RIP_API() mechanism,
    // since it may be called after RIP has stopped, when the
    // Router Manager is retrieving the ROUTER_STOPPED message
    //

    TRACE2(ENTER, "entering GetEventMessage: 0x%08x 0x%08x", pEvent, pResult);


    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);


    dwErr = DequeueEvent(ig.IG_EventQueue, pEvent, pResult);


    RELEASE_LIST_LOCK(ig.IG_EventQueue);



    TRACE1(LEAVE, "leaving GetEventMessage: %d", dwErr);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    GetInterfaceConfigInfo
//
// Copies to the caller's buffer the configuration for the interface
// with the specified index.
//----------------------------------------------------------------------------

DWORD WINAPI
GetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   OutInterfaceInfo,
    PULONG  InterfaceInfoSize,
    PULONG  StructureVersion,
    PULONG  StructureSize,
    PULONG  StructureCount
    )
{
    DWORD dwErr, dwSize;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;
    PIPRIP_IF_CONFIG picsrc, picdst;


    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE3(
        ENTER, "entering GetInterfaceConfigInfo: %d 0x%08x 0x%08x",
        InterfaceIndex,, OutInterfaceInfo, InterfaceInfoSize
        );



    dwErr = NO_ERROR;

    do {

        //
        // check the arguments
        //

        if (InterfaceInfoSize == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pTable = ig.IG_IfTable;


        ACQUIRE_IF_LOCK_SHARED();


        //
        // find the interface specified
        //

        pite = GetIfByIndex(pTable, InterfaceIndex);

        if (pite == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else {


            //
            // get the size of the interface config
            //

            picsrc = pite->ITE_Config;
            dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);


            //
            // check the buffer size
            //

            if (*InterfaceInfoSize < dwSize) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {


                picdst = (PIPRIP_IF_CONFIG)OutInterfaceInfo;


                //
                // copy the interface config, and set the IP address
                //

                CopyMemory(picdst, picsrc, dwSize);


                *StructureVersion    = 1;
                *StructureSize       = dwSize;
                *StructureCount      = 1;

                picdst->IC_State = 0;

                if (IF_IS_ENABLED(pite)) {
                    picdst->IC_State |= IPRIP_STATE_ENABLED;
                }

                if (IF_IS_BOUND(pite)) {
                    picdst->IC_State |= IPRIP_STATE_BOUND;
                }
            }

            *InterfaceInfoSize = dwSize;

        }


        RELEASE_IF_LOCK_SHARED();

    } while(FALSE);



    TRACE1(LEAVE, "leaving GetInterfaceConfigInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    SetInterfaceConfigInfo
//
// This sets the configuration for the interface with the given index.
//----------------------------------------------------------------------------

DWORD WINAPI
SetInterfaceConfigInfo (
    ULONG   InterfaceIndex,
    PVOID   InterfaceInfo,
    ULONG   StructureVersion,
    ULONG   StructureSize,
    ULONG   StructureCount
    )
{
    DWORD dwErr;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(
        ENTER, "entering SetInterfaceConfigInfo: %d, 0x%08x", InterfaceIndex, InterfaceInfo
        );



    dwErr = NO_ERROR;

    do {


        if (InterfaceInfo == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }


        pTable = ig.IG_IfTable;

        ACQUIRE_IF_LOCK_EXCLUSIVE();


        dwErr = ConfigureIfEntry(pTable, InterfaceIndex, InterfaceInfo);


        RELEASE_IF_LOCK_EXCLUSIVE();

    } while(FALSE);



    TRACE1(LEAVE, "leaving SetInterfaceConfigInfo: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;

}

DWORD WINAPI
InterfaceStatus(
    ULONG    InterfaceIndex,
    BOOL     InterfaceActive,
    DWORD    StatusType,
    PVOID    StatusInfo
    )
{
    DWORD   dwResult;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    switch(StatusType)
    {
        case RIS_INTERFACE_ADDRESS_CHANGE:
        {
            PIP_ADAPTER_BINDING_INFO    pBindInfo;

            pBindInfo = (PIP_ADAPTER_BINDING_INFO)StatusInfo;

            if(pBindInfo->AddressCount)
            {
                dwResult = BindInterface(InterfaceIndex,
                                         pBindInfo);
            }
            else
            {
                dwResult = UnBindInterface(InterfaceIndex);
            }

            break;
        }

        case RIS_INTERFACE_ENABLED:
        {
            dwResult = EnableInterface(InterfaceIndex);

            break;
        }

        case RIS_INTERFACE_DISABLED:
        {
            dwResult = DisableInterface(InterfaceIndex);

            break;

        }

        default:
        {
            RTASSERT(FALSE);

            dwResult = ERROR_INVALID_PARAMETER;
        }
    }

    LEAVE_RIP_API();

    return dwResult;
}



//---------------------------------------------------------------------------
// Function:    BindInterface
//
// This function is called to supply the binding information
// for an interface
//---------------------------------------------------------------------------

DWORD
APIENTRY
BindInterface(
    IN DWORD dwIndex,
    IN PVOID pBinding
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE2(ENTER, "entering BindInterface: %d 0x%08x", dwIndex, pBinding);


    if (pBinding == NULL) {

        TRACE0(IF, "error: binding struct pointer is NULL");
        TRACE1(LEAVE, "leaving BindInterface: %d", ERROR_INVALID_PARAMETER);

        return ERROR_INVALID_PARAMETER;
    }



    //
    // now bind the interface in the interface table
    //


    pTable = ig.IG_IfTable;


    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = BindIfEntry(pTable, dwIndex, pBinding);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving BindInterface: %d", dwErr);

    return dwErr;
}




//---------------------------------------------------------------------------
// Function:    UnBindInterface
//
// This function removes the binding for an interface.
//---------------------------------------------------------------------------

DWORD
APIENTRY
UnBindInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;
    PIF_TABLE_ENTRY pite;

    TRACE1(ENTER, "entering UnBindInterface: %d", dwIndex);


    pTable = ig.IG_IfTable;


    //
    // unbind the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = UnBindIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();


    TRACE1(LEAVE, "leaving UnBindInterface: %d", dwErr);


    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    EnableInterface
//
// This function starts IPRIP activity over the interface with
// the given index, using the given binding information.
//----------------------------------------------------------------------------

DWORD
APIENTRY
EnableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE1(ENTER, "entering EnableInterface: %d", dwIndex);



    pTable = ig.IG_IfTable;


    //
    // activate the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = EnableIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving EnableInterface: %d", dwErr);

    return dwErr;

}



//----------------------------------------------------------------------------
// Function:    DisableInterface
//
// This function stops IPRIP activity on an interface, also removing
// routes associated with the interface from RTM and purging the network
// of such routes.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DisableInterface(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;
    PIF_TABLE pTable;

    TRACE1(ENTER, "entering DisableInterface: %d", dwIndex);



    pTable = ig.IG_IfTable;


    //
    // stop activity on the interface
    //

    ACQUIRE_IF_LOCK_EXCLUSIVE();


    dwErr = DisableIfEntry(pTable, dwIndex);


    RELEASE_IF_LOCK_EXCLUSIVE();



    TRACE1(LEAVE, "leaving DisableInterface: %d", dwIndex);

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    DoUpdateRoutes
//
// This function begins a demand-update of routes, by queuing a work-item
// which will send out requests on the specified interface.
//----------------------------------------------------------------------------

DWORD
APIENTRY
DoUpdateRoutes(
    IN DWORD dwIndex
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE1(ENTER, "entering DoUpdateRoutes: %d", dwIndex);


    //
    // queue the work-item; perhaps we could call the function directly,
    // but using a worker-thread lets us return to Router Manager right away
    //

    dwErr = QueueRipWorker(
                WorkerFunctionStartDemandUpdate,
                (PVOID)UlongToPtr(dwIndex)
                );


    TRACE1(LEAVE,"leaving DoUpdateRoutes(), errcode %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibCreate
//
// This function does nothing, since IPRIP does not support creation of
// interface objects via SNMP. However, this could be implemented as a call
// to CreateIfEntry() followed by a call to ActivateIfEntry(), and the input
// data would have to contain the interface's index, configuration,
// and binding.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibCreate(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibCreate: %d 0x%08x", dwInputSize, pInputData);


    dwErr = ERROR_CAN_NOT_COMPLETE;


    TRACE1(LEAVE, "leaving MibCreate: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibDelete
//
// This function does nothing, since IPRIP does not support deletion of
// interface objects via SNMP. This could be implemented as a call to
// DeactivateIfEntry() followed by a call to DeleteIfEntry(), and the
// input data would have to contain the interface's index
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibDelete(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibDelete: %d 0x%08x", dwInputSize, pInputData);


    dwErr = ERROR_CAN_NOT_COMPLETE;


    TRACE1(LEAVE, "leaving MibDelete: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibSet
//
// The function sets global or interface configuration.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibSet(
    IN DWORD dwInputSize,
    IN PVOID pInputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_SET_INPUT_DATA pimsid;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE2(ENTER, "entering MibSet: %d 0x%08x", dwInputSize, pInputData);


    dwErr = NO_ERROR;

    do { // breakout loop

        if (pInputData == NULL) {
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }

        if (dwInputSize < sizeof(IPRIP_MIB_SET_INPUT_DATA)) {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            break;
        }


        pimsid = (PIPRIP_MIB_SET_INPUT_DATA)pInputData;

        switch (pimsid->IMSID_TypeID) {

            case IPRIP_GLOBAL_CONFIG_ID: {

                PIPRIP_GLOBAL_CONFIG pigc;


                if (pimsid->IMSID_BufferSize < sizeof(IPRIP_GLOBAL_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                dwErr = SetGlobalInfo(pimsid->IMSID_Buffer,1,0,1);

                if (dwErr == NO_ERROR) {

                    MESSAGE msg = {0, 0, 0};

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue, SAVE_GLOBAL_CONFIG_INFO, msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }

                break;
            }

            case IPRIP_IF_CONFIG_ID: {

                DWORD dwSize;
                PIF_TABLE pTable;
                PIPRIP_IF_CONFIG pic;
                PIF_TABLE_ENTRY pite;

                if (pimsid->IMSID_BufferSize < sizeof(IPRIP_IF_CONFIG)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                    break;
                }

                pic = (PIPRIP_IF_CONFIG)pimsid->IMSID_Buffer;


                pTable = ig.IG_IfTable;


                ACQUIRE_IF_LOCK_EXCLUSIVE();


                //
                // retrieve the interface to be configured
                //

                pite = GetIfByIndex(
                            pTable, pimsid->IMSID_IfIndex
                            );
                if (pite == NULL) {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
                else {

                    dwErr = ConfigureIfEntry(pTable, pite->ITE_Index, pic);
                }


                //
                // notify Router Manager
                //

                if (dwErr == NO_ERROR) {

                    MESSAGE msg = {0, 0, 0};

                    msg.InterfaceIndex = pite->ITE_Index;

                    ACQUIRE_LIST_LOCK(ig.IG_EventQueue);
                    EnqueueEvent(
                        ig.IG_EventQueue, SAVE_INTERFACE_CONFIG_INFO, msg
                        );
                    SetEvent(ig.IG_EventEvent);
                    RELEASE_LIST_LOCK(ig.IG_EventQueue);
                }

                RELEASE_IF_LOCK_EXCLUSIVE();


                break;
            }

            default: {
                dwErr = ERROR_INVALID_PARAMETER;
            }
        }

    } while(FALSE);


    TRACE1(LEAVE, "leaving MibSet: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}




//----------------------------------------------------------------------------
// Function:    MibGetInternal
//
// Forward declaration of internal implementation function
//----------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    );


//----------------------------------------------------------------------------
// Function:    MibGet
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGet(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGet: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_EXACT);

    }


    TRACE1(LEAVE, "leaving MibGet: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetFirst
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats. It differs from
// MibGet() in that it always returns the FIRST entry in whichever table
// is being queried. There is only one entry in the global stats and config
// tables, but the interface config, interface stats, and peer stats tables
// are sorted by IP address; this function returns the first entry from these.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGetFirst(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;


    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetFirst: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {
        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_FIRST);
    }


    TRACE1(LEAVE, "leaving MibGetFirst: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetNext
//
// This function retrieves global or interface configuration, as well as
// global stats, interface stats, and peer-router stats. It differs from both
// MibGet() and MibGetFirst(0 in that it always returns the entry AFTER the
// specified in the specified table. Thus, in the interface config, interface
// stats, and peer stats tables, this function supplies the entry after the
// one with the address passed in.
//
// If the end of the table being queried has been reached, this function will
// return the FIRST entry from the NEXT table, where "NEXT" here means the
// table whose ID is one greater than the ID passed in.
// Thus calling MibGetNext() for the last entry in the interface
// stats table (ID==2) will return the first entry in the interface config
// table (ID==3).
//
// In any case, this function writes the required size to pdwOutputSize and
// writes the ID of the object that WOULD have been returned into the output
// buffer.
//----------------------------------------------------------------------------

DWORD
APIENTRY
MibGetNext(
    IN DWORD dwInputSize,
    IN PVOID pInputData,
    IN OUT PDWORD pdwOutputSize,
    OUT PVOID pOutputData
    ) {

    DWORD dwErr, dwOutSize = 0, dwBufSize = 0;
    PIPRIP_MIB_GET_INPUT_DATA pimgid;
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod;

    if (!ENTER_RIP_API()) { return ERROR_CAN_NOT_COMPLETE; }

    TRACE4(
        ENTER, "entering MibGetNext: %d 0x%08x 0x%08x 0x%08x",
        dwInputSize, pInputData, pdwOutputSize, pOutputData
        );


    if (pInputData == NULL ||
        dwInputSize < sizeof(IPRIP_MIB_GET_INPUT_DATA) ||
        pdwOutputSize == NULL) {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else {

        pimgid = (PIPRIP_MIB_GET_INPUT_DATA)pInputData;
        pimgod = (PIPRIP_MIB_GET_OUTPUT_DATA)pOutputData;

        dwOutSize = *pdwOutputSize;

        dwErr = MibGetInternal(pimgid, pimgod, pdwOutputSize, GETMODE_NEXT);


        if (dwErr == ERROR_NO_MORE_ITEMS) {

            //
            // need to wrap to the first entry in the next table,
            // if there is a next table
            //

            TRACE1(
                CONFIG, "MibGetNext is wrapping to table %d",
                pimgid->IMGID_TypeID + 1
                );

            *pdwOutputSize = dwOutSize;

            //
            // wrap to next table by incrementing the type ID
            //

            ++pimgid->IMGID_TypeID;
            if (pimgid->IMGID_TypeID <= IPRIP_PEER_STATS_ID) {
            
                dwErr = MibGetInternal(
                            pimgid, pimgod, pdwOutputSize, GETMODE_FIRST
                            );
            }
            --pimgid->IMGID_TypeID;
        }
    }


    TRACE1(LEAVE, "leaving MibGetNext: %d", dwErr);

    LEAVE_RIP_API();

    return dwErr;
}



//----------------------------------------------------------------------------
// Function:    MibGetInternal
//
// This handles the actual structure access required to read MIB data.
// Each table supported by IPRIP supports three modes of querying;
// EXACT, FIRST, and NEXT, which correspond to the functions MibGet(),
// MibGetFirst(), and MibGetNext() respectively.
//----------------------------------------------------------------------------

DWORD
MibGetInternal(
    PIPRIP_MIB_GET_INPUT_DATA pimgid,
    PIPRIP_MIB_GET_OUTPUT_DATA pimgod,
    PDWORD pdwOutputSize,
    DWORD dwGetMode
    ) {


    DWORD dwErr, dwBufferSize, dwSize;
    ULONG ulVersion, ulSize, ulCount;


    dwErr = NO_ERROR;



    //
    // first we use pdwOutputSize to compute the size of the buffer
    // available for storing returned structures (the size of IMGOD_Buffer)
    //

    if (pimgod == NULL) {
        dwBufferSize = 0;
    }
    else {
        if (*pdwOutputSize < sizeof(IPRIP_MIB_GET_OUTPUT_DATA)) {
            dwBufferSize = 0;
        }
        else {
            dwBufferSize = *pdwOutputSize - sizeof(IPRIP_MIB_GET_OUTPUT_DATA) + 1;
        }
    }

    *pdwOutputSize = 0;


    //
    // determine which type of data is to be returned
    //

    switch (pimgid->IMGID_TypeID) {

        case IPRIP_GLOBAL_STATS_ID: {


            //
            // the global stats structure is constant size.
            // there is only one instance, so if the mode is GETMODE_NEXT
            // we always return ERROR_NO_MORE_ITEMS
            //


            PIPRIP_GLOBAL_STATS pigsdst, pigssrc;


            //
            // set the output size required for this entry,
            // as well as the type of data to be returned
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_GLOBAL_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_GLOBAL_STATS_ID; }


            //
            // only GETMODE_EXACT and GETMODE_FIRST are valid for
            // the global stats object, since there is only one entry
            //

            if (dwGetMode == GETMODE_NEXT) {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }


            if (pimgod == NULL) { dwErr = ERROR_INSUFFICIENT_BUFFER; break; }


            //
            // check that the output buffer is big enough
            //

            if (dwBufferSize < sizeof(IPRIP_GLOBAL_STATS)) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // since access to this structure is not synchronized,
                // we must copy it field by field
                //

                pigssrc = &ig.IG_Stats;
                pigsdst = (PIPRIP_GLOBAL_STATS)pimgod->IMGOD_Buffer;

                pigsdst->GS_SystemRouteChanges = pigssrc->GS_SystemRouteChanges;
                pigsdst->GS_TotalResponsesSent = pigssrc->GS_TotalResponsesSent;
            }


            break;
        }



        case IPRIP_GLOBAL_CONFIG_ID: {

            //
            // the global config struct is variable length,
            // so we wait until it has been retrieved
            // before we set the size.
            // furthermore, there is only one global config object,
            // so GETMODE_NEXT doesn't make any sense
            //

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_GLOBAL_CONFIG_ID; }

            if (dwGetMode == GETMODE_NEXT) {
                dwErr = ERROR_NO_MORE_ITEMS;
                break;
            }



            //
            // Use GetGlobalInfo to retrieve the global information.
            // It will decide whether the buffer is large enough,
            // and if not will set the required size. Then all we need do
            // is write out the size set by GetGlobalInfo() and
            // relay its return-value to the caller
            //

            if (pimgod == NULL) {
                dwErr = GetGlobalInfo(NULL, &dwBufferSize, &ulVersion, &ulSize, &ulCount);
            }
            else {

                dwErr = GetGlobalInfo(
                            pimgod->IMGOD_Buffer, &dwBufferSize, &ulVersion, &ulSize, &ulCount
                            );
            }

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             dwBufferSize;

            break;
        }



        case IPRIP_IF_STATS_ID: {


            //
            // the interface statistics struct is fixed-length.
            // there may be multiple instances.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_STATS pissrc, pisdst;



            //
            // set the size needed right away
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_IF_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_STATS_ID; }


            pTable = ig.IG_IfTable;


            ACQUIRE_IF_LOCK_SHARED();


            //
            // retrieve the interface whose stats are to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was not found, it may mean
            // the specified index was invalid, or it may mean
            // that the GETMODE_NEXT was called on the last interface
            // in which case ERROR_NO_MORE_ITEMS was returned.
            // In any case, we make sure dwErr indicates an error
            // and then return the value.
            //
            // if the interface was found but no output buffer was passed,
            // indicate in the error that memory needs to be allocated.
            //
            // otherwise, copy the stats struct of the interface
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else
            if (pimgod == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // set the index of the interface returned
                //

                pimgod->IMGOD_IfIndex = pite->ITE_Index;


                //
                // if the buffer is large enough, copy over the stats
                //

                if (dwBufferSize < sizeof(IPRIP_IF_STATS)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // since access to this structure is not synchronized,
                    // we must copy it field by field
                    //

                    pissrc = &pite->ITE_Stats;
                    pisdst = (PIPRIP_IF_STATS)pimgod->IMGOD_Buffer;

                    pisdst->IS_State = 0;

                    if (IF_IS_ENABLED(pite)) {
                        pisdst->IS_State |= IPRIP_STATE_ENABLED;
                    }

                    if (IF_IS_BOUND(pite)) {
                        pisdst->IS_State |= IPRIP_STATE_BOUND;
                    }


                    pisdst->IS_SendFailures =
                            pissrc->IS_SendFailures;
                    pisdst->IS_ReceiveFailures =
                            pissrc->IS_ReceiveFailures;
                    pisdst->IS_RequestsSent =
                            pissrc->IS_RequestsSent;
                    pisdst->IS_RequestsReceived =
                            pissrc->IS_RequestsReceived;
                    pisdst->IS_ResponsesSent =
                            pissrc->IS_ResponsesSent;
                    pisdst->IS_RequestsReceived =
                            pissrc->IS_RequestsReceived;
                    pisdst->IS_ResponsesReceived =
                            pissrc->IS_ResponsesReceived;
                    pisdst->IS_BadResponsePacketsReceived =
                            pissrc->IS_BadResponsePacketsReceived;
                    pisdst->IS_BadResponseEntriesReceived =
                            pissrc->IS_BadResponseEntriesReceived;
                    pisdst->IS_TriggeredUpdatesSent =
                            pissrc->IS_TriggeredUpdatesSent;
                }
            }

            RELEASE_IF_LOCK_SHARED();


            break;
        }



        case IPRIP_IF_CONFIG_ID: {

            //
            // the interface configuration is variable-length.
            // thus we must actually retrieve the requested interface
            // before we know how large a buffer is needed.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_CONFIG picsrc, picdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_CONFIG_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_IF_LOCK_SHARED();


            //
            // retrieve the interface whose config is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned.
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else {

                //
                // compute the size of the interface config retrieved,
                // and write it over the caller's supplied size
                //

                picsrc = pite->ITE_Config;
                dwSize = IPRIP_IF_CONFIG_SIZE(picsrc);
                *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                                 dwSize;


                //
                // if no buffer was specified, indicate one should be allocated
                //

                if (pimgod == NULL) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {


                    //
                    // if the buffer is not large enough,
                    // indicate that it should be enlarged
                    //

                    if (dwBufferSize < dwSize) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // copy the configuration
                        //

                        picdst = (PIPRIP_IF_CONFIG)pimgod->IMGOD_Buffer;

                        CopyMemory(picdst, picsrc, dwSize);
                        ZeroMemory(
                            picdst->IC_AuthenticationKey, IPRIP_MAX_AUTHKEY_SIZE
                            );

                        picdst->IC_State = 0;

                        if (IF_IS_ENABLED(pite)) {
                            picdst->IC_State |= IPRIP_STATE_ENABLED;
                        }

                        if (IF_IS_BOUND(pite)) {
                            picdst->IC_State |= IPRIP_STATE_BOUND;
                        }
                    }


                    pimgod->IMGOD_IfIndex = pite->ITE_Index;
                }
            }

            RELEASE_IF_LOCK_SHARED();

            break;
        }



        case IPRIP_IF_BINDING_ID: {

            //
            // the interface binding is variable-length
            // thus we must actually retrieve the requested interface
            // before we know how large a buffer is needed.
            //

            PIF_TABLE pTable;
            PIF_TABLE_ENTRY pite;
            PIPRIP_IF_BINDING pibsrc, pibdst;

            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_IF_BINDING_ID; }

            pTable = ig.IG_IfTable;

            ACQUIRE_IF_LOCK_SHARED();

            //
            // retrieve the interface whose binding is to be read
            //

            pite = GetIfByListIndex(
                        pTable, pimgid->IMGID_IfIndex, dwGetMode, &dwErr
                        );


            //
            // if the interface was found, it may mean that the index
            // specified was invalid, or it may mean that a GETMODE_NEXT
            // retrieval was attempted on the last interface, in which case
            // ERROR_NO_MORE_ITEMS would have been returned.
            //

            if (pite == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else {

                //
                // compute the size of the interface binding retrieved,
                // and write it over the caller's supplied size
                //

                pibsrc = pite->ITE_Binding;
                dwSize = (pibsrc ? IPRIP_IF_BINDING_SIZE(pibsrc)
                                 : sizeof(IPRIP_IF_BINDING));
                *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                                 dwSize;


                //
                // if no buffer was specified, indicate one should be allocated
                //

                if (pimgod == NULL) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {


                    //
                    // if the buffer is not large enough,
                    // indicate that it should be enlarged
                    //

                    if (dwBufferSize < dwSize) {
                        dwErr = ERROR_INSUFFICIENT_BUFFER;
                    }
                    else {

                        //
                        // copy the binding
                        //

                        pibdst = (PIPRIP_IF_BINDING)pimgod->IMGOD_Buffer;

                        if (pibsrc) { CopyMemory(pibdst, pibsrc, dwSize); }
                        else { pibdst->IB_AddrCount = 0; }

                        pibdst->IB_State = 0;

                        if (IF_IS_ENABLED(pite)) {
                            pibdst->IB_State |= IPRIP_STATE_ENABLED;
                        }

                        if (IF_IS_BOUND(pite)) {
                            pibdst->IB_State |= IPRIP_STATE_BOUND;
                        }
                    }


                    pimgod->IMGOD_IfIndex = pite->ITE_Index;
                }
            }

            RELEASE_IF_LOCK_SHARED();

            break;
        }

        case IPRIP_PEER_STATS_ID: {


            //
            // the peer statistics struct is fixed-length.
            //

            DWORD dwAddress;
            PPEER_TABLE pTable;
            PPEER_TABLE_ENTRY ppte;
            PIPRIP_PEER_STATS ppssrc, ppsdst;


            //
            // set the output size right away
            //

            *pdwOutputSize = sizeof(IPRIP_MIB_GET_OUTPUT_DATA) - 1 +
                             sizeof(IPRIP_PEER_STATS);
            if (pimgod) { pimgod->IMGOD_TypeID = IPRIP_PEER_STATS_ID; }


            pTable = ig.IG_PeerTable;
            dwAddress = pimgid->IMGID_PeerAddress;


            ACQUIRE_PEER_LOCK_SHARED();


            //
            // retrieve the peer specified
            //

            ppte = GetPeerByAddress(pTable, dwAddress, dwGetMode, &dwErr);



            //
            // if no struct was returned, it means that either
            // an invalid address was specifed, or GETMODE_NExT
            // was attempted on the last peer.
            // In either case, we return an error code.
            //
            // if no buffer was specifed, return ERROR_INSUFFICIENT_BUFFER
            // to indicate to the caller that a buffer should be allocated
            //

            if (ppte == NULL) {
                if (dwErr == NO_ERROR) { dwErr = ERROR_NOT_FOUND; }
            }
            else
            if (pimgod == NULL) {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
            else {

                //
                // save the address of the peer retrieved
                //

                pimgod->IMGOD_PeerAddress = ppte->PTE_Address;


                //
                // if the buffer is not large enough,
                // return an error to indicate it should be enlarged
                //

                if (dwBufferSize < sizeof(IPRIP_PEER_STATS)) {
                    dwErr = ERROR_INSUFFICIENT_BUFFER;
                }
                else {

                    //
                    // since access to this structure is not synchronized,
                    // we must copy it field by field
                    //

                    ppssrc = &ppte->PTE_Stats;
                    ppsdst = (PIPRIP_PEER_STATS)pimgod->IMGOD_Buffer;

                    ppsdst->PS_LastPeerRouteTag =
                            ppssrc->PS_LastPeerRouteTag;
                    ppsdst->PS_LastPeerUpdateTickCount =
                            ppssrc->PS_LastPeerUpdateTickCount;
                    ppsdst->PS_LastPeerUpdateVersion =
                            ppssrc->PS_LastPeerUpdateVersion;
                    ppsdst->PS_BadResponsePacketsFromPeer =
                            ppssrc->PS_BadResponsePacketsFromPeer;
                    ppsdst->PS_BadResponseEntriesFromPeer =
                            ppssrc->PS_BadResponseEntriesFromPeer;
                }
            }

            RELEASE_PEER_LOCK_SHARED();


            break;

        }

        default: {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\defs.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: defs.h
//
// History:
//      Abolade Gbadegesin  Aug-7-1995  Created.
//
// Contains miscellaneous definitions and declarations
//============================================================================


#ifndef _DEFS_H_
#define _DEFS_H_


//
// type definitions for IPRIP network packet templates
//

#pragma pack(1)


typedef struct _IPRIP_HEADER {

    BYTE    IH_Command;
    BYTE    IH_Version;
    WORD    IH_Reserved;

} IPRIP_HEADER, *PIPRIP_HEADER;



typedef struct _IPRIP_ENTRY {

    WORD    IE_AddrFamily;
    WORD    IE_RouteTag;
    DWORD   IE_Destination;
    DWORD   IE_SubnetMask;
    DWORD   IE_Nexthop;
    DWORD   IE_Metric;

} IPRIP_ENTRY, *PIPRIP_ENTRY;



typedef struct _IPRIP_AUTHENT_ENTRY {

    WORD    IAE_AddrFamily;
    WORD    IAE_AuthType;
    BYTE    IAE_AuthKey[IPRIP_MAX_AUTHKEY_SIZE];

} IPRIP_AUTHENT_ENTRY, *PIPRIP_AUTHENT_ENTRY;



#pragma pack()



#define ADDRFAMILY_REQUEST      0
#define ADDRFAMILY_INET         ntohs(AF_INET)
#define ADDRFAMILY_AUTHENT      0xFFFF
#define MIN_PACKET_SIZE         (sizeof(IPRIP_HEADER) + sizeof(IPRIP_ENTRY))
#define MAX_PACKET_SIZE         512
#define MAX_PACKET_ENTRIES                                                  \
            ((MAX_PACKET_SIZE - sizeof(IPRIP_HEADER)) / sizeof(IPRIP_ENTRY))
#define MAX_UPDATE_REQUESTS     3

//
// this structure exists so that a RIP packet can be copied
// via structure-assignment rather than having to call CopyMemory
//

typedef struct _IPRIP_PACKET {

    BYTE        IP_Packet[MAX_PACKET_SIZE];

} IPRIP_PACKET, *PIPRIP_PACKET;


//
// definitions for IPRIP packet fields
//

#define IPRIP_PORT              520
#define IPRIP_REQUEST           1
#define IPRIP_RESPONSE          2
#define IPRIP_INFINITE          16
#define IPRIP_MULTIADDR         ((DWORD)0x090000E0)



//
// Time conversion constants and macros
//

#define SYSTIME_UNITS_PER_MSEC  (1000 * 10)
#define SYSTIME_UNITS_PER_SEC   (1000 * SYSTIME_UNITS_PER_MSEC)


//
// macro to get system time in 100-nanosecond units
//

#define RipQuerySystemTime(p)   NtQuerySystemTime((p))


//
// macros to convert time between 100-nanosecond, 1millsec, and 1 sec units
//

#define RipSystemTimeToMillisecs(p) {                                       \
    DWORD _r;                                                               \
    *(p) = RtlExtendedLargeIntegerDivide(*(p), SYSTIME_UNITS_PER_MSEC, &_r);\
}

#define RipMillisecsToSystemTime(p)                                         \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_PER_MSEC)   

#define RipSecsToSystemTime(p)                                              \
    *(p) = RtlExtendedIntegerMultiply(*(p), SYSTIME_UNITS_PER_SEC)   

#define RipSecsToMilliSecs(p)                                               \
            (p) * 1000

//
// Network classification constants and macros
//

#define CLASSA_MASK         ((DWORD)0x000000ff)
#define CLASSB_MASK         ((DWORD)0x0000ffff)
#define CLASSC_MASK         ((DWORD)0x00ffffff)
#define CLASSD_MASK         ((DWORD)0x000000e0)
#define CLASSE_MASK         ((DWORD)0xffffffff)

#define CLASSA_ADDR(a)      (((*((PBYTE)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)      (((*((PBYTE)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)      (((*((PBYTE)&(a))) & 0xe0) == 0xc0)
#define CLASSD_ADDR(a)      (((*((PBYTE)&(a))) & 0xf0) == 0xe0)

//
// NOTE: 
// This check for class E addresses doesn't weed out the address range from
// 248.0.0.0 to 255.255.255.254
//
#define CLASSE_ADDR(a)      ((((*((PBYTE)&(a)))& 0xf0) == 0xf0) &&  \
                             ((a) != 0xffffffff))

#define IS_LOOPBACK_ADDR(a) (((a) & 0xff) == 0x7f)

//
// Checks if the address is a broadcast
// Determines the class of the address passed in, and then uses the net mask
// corresponding to that class to determine if it is a broadcast address.
// Also identifies an all 1's address as a broadcast address.
// This macro can't be used for identifying subnet directed broadcasts
//
#define IS_BROADCAST_ADDR(a)                                                \
            ((a) == INADDR_BROADCAST ||                                     \
             (CLASSA_ADDR(a) && (((a) & ~CLASSA_MASK) == ~CLASSA_MASK)) ||  \
             (CLASSB_ADDR(a) && (((a) & ~CLASSB_MASK) == ~CLASSB_MASK)) ||  \
             (CLASSC_ADDR(a) && (((a) & ~CLASSC_MASK) == ~CLASSC_MASK))) 

//
// Checks if the address is a directed broadcast
// The ~mask == TRUE check makes sure that host addresses with a mask
// of all ones, don't get classified as directed broadcasts
// But this also means that anytime the mask is all 1's (which is what 
// NETCLASS_MASK macro returns, if the address passed in is not an A, B, C or
// D class address) the IS_DIRECTED_BROADCAST macro will return 0
//
#define IS_DIRECTED_BROADCAST_ADDR(a, mask)                              \
             ( (~(mask)) && (((a) & ~(mask)) == ~(mask)) )

//
// checks if an address is 255.255.255.255
//
#define IS_LOCAL_BROADCAST_ADDR(a)                                       \
             ( (a) == INADDR_BROADCAST )


#define HOSTADDR_MASK       0xffffffff

#define NETCLASS_MASK(a)                                        \
            (CLASSA_ADDR(a) ? CLASSA_MASK :                     \
            (CLASSB_ADDR(a) ? CLASSB_MASK :                     \
            (CLASSC_ADDR(a) ? CLASSC_MASK :                     \
            (CLASSD_ADDR(a) ? CLASSD_MASK : CLASSE_MASK))))


//
// This macro compares two IP addresses in network order by
// masking off each pair of octets and doing a subtraction;
// the result of the final subtraction is stored in the third argument.
//

#define INET_CMP(a,b,c)                                                     \
            (((c) = (((a) & 0x000000ff) - ((b) & 0x000000ff))) ? (c) :      \
            (((c) = (((a) & 0x0000ff00) - ((b) & 0x0000ff00))) ? (c) :      \
            (((c) = (((a) & 0x00ff0000) - ((b) & 0x00ff0000))) ? (c) :      \
            (((c) = ((((a)>>8) & 0x00ff0000) - (((b)>>8) & 0x00ff0000)))))))

#define IPV4_ADDR_LEN       32
#define IPV4_SOURCE_MASK    0xFFFFFFFF

#endif // _DEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\iprip.h ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File: iprip.h
//
// History:
//      Abolade Gbadegesin  Aug-7-1995  Created.
//
// Contains type definitions and declarations for IP RIP.
//============================================================================

#ifndef _IPRIP_H_
#define _IPRIP_H_



//
// various codes describing states of IPRIP.
//

typedef enum _IPRIP_STATUS_CODE {
    IPRIP_STATUS_STARTING   = 100,
    IPRIP_STATUS_RUNNING    = 101,
    IPRIP_STATUS_STOPPING   = 102,
    IPRIP_STATUS_STOPPED    = 103
} IPRIP_STATUS_CODE, *PIPRIP_STATUS_CODE;



//
// type:    IPRIP_GLOBALS
//
//
// The critical section IPRIP_GLOBALS::IG_CS protects the fields IG_Status,
// IG_ActivityCount, IG_ActivitySemaphore, IG_InterruptReason, and
// IG_InterruptSocket
//
// The read-write lock IPRIP_GLOBALS::IG_RWL protects the field IG_Config
//
// When more than one field must be locked, the order
// of locking must be as follows (locks for fields listed on the same line
// should never be held by the same thread at once):
//      IG_IfTable.IT_RWL
//      IG_PeerTable.PT_RWL
//      IG_IfTable.IT_CS
//      IG_BindingTable.BT_RWL
//      IG_RWL
//      IG_TimerQueue  IG_EventQueue  IG_SendQueue  IG_RecvQueue
//      IG_CS
//
// It is assumed that the field IG_SendQueueSize will only
// be accessed while the send queue is locked, and thus
// it is protected implicitly by the send-queue critical section.
//
// Likewise, it is assumed that the field IG_RecvQueueSize will only
// be accessed while the recv-queue is locked, and thus
// it is protected implicitly by the recv-queue critical section.
//

typedef struct _IPRIP_GLOBALS {

    CRITICAL_SECTION    IG_CS;
    IPRIP_STATUS_CODE   IG_Status;
    READ_WRITE_LOCK     IG_RWL;
    DWORD               IG_TraceID;
    IPRIP_GLOBAL_STATS  IG_Stats;
    PIPRIP_GLOBAL_CONFIG IG_Config;
    PIF_TABLE           IG_IfTable;
    PPEER_TABLE         IG_PeerTable;
    PBINDING_TABLE      IG_BindingTable;
    DWORD               IG_LogLevel;
    HANDLE              IG_LogHandle;
    HANDLE              IG_RtmHandle;
    HANDLE              IG_RtmNotifHandle;
    RTM_ENTITY_INFO     IG_RtmEntityInfo;
    RTM_REGN_PROFILE    IG_RtmProfile;
    HANDLE              IG_TimerQueueHandle;
    PLOCKED_LIST        IG_EventQueue;
    PLOCKED_LIST        IG_SendQueue;
    LONG                IG_SendQueueSize;
    PLOCKED_LIST        IG_RecvQueue;
    LONG                IG_RecvQueueSize;
    HANDLE              IG_EventEvent;
    HANDLE              IG_IpripInputEvent;
    HANDLE              IG_IpripInputEventHandle;
    HANDLE              IG_IpripGlobalHeap;
    LONG                IG_ActivityCount;
    HANDLE              IG_ActivitySemaphore;
    DWORD               IG_MibTraceID;
    HANDLE              IG_MibTimerHandle;
    SUPPORT_FUNCTIONS   IG_SupportFunctions;
} IPRIP_GLOBALS, *PIPRIP_GLOBALS;



//
// external declaration of the global IPRIP struct
//

extern IPRIP_GLOBALS ig;



//
// memory-allocation constants and macros
//

#define GLOBAL_HEAP     ig.IG_IpripGlobalHeap
#define RIP_ALLOC(size) HeapAlloc(GLOBAL_HEAP, 0, size)
#define RIP_FREE(ptr)   HeapFree(GLOBAL_HEAP, 0, ptr)



//
// macros invoked when entering API or worker functions
//

#define ENTER_RIP_API()         EnterRipAPI()
#define ENTER_RIP_WORKER()      EnterRipWorker()


//
// macro invoked when leaving API or worker functions
//

#define LEAVE_RIP_API()         LeaveRipWorker()
#define LEAVE_RIP_WORKER()      LeaveRipWorker()



//
// macros used for locking and unlocking protected structures
//

#define ACQUIRE_GLOBAL_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_RWL)

#define RELEASE_GLOBAL_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_RWL)

#define ACQUIRE_GLOBAL_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_RWL)

#define RELEASE_GLOBAL_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_RWL)


#define ENTER_GLOBAL_SECTION() \
        EnterCriticalSection(&ig.IG_CS)

#define LEAVE_GLOBAL_SECTION() \
        LeaveCriticalSection(&ig.IG_CS)


#define ACQUIRE_IF_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_IfTable->IT_RWL)

#define RELEASE_IF_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_IfTable->IT_RWL)

#define ACQUIRE_IF_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_IfTable->IT_RWL)

#define RELEASE_IF_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_IfTable->IT_RWL)


#define ENTER_IF_SECTION() \
        EnterCriticalSection(&ig.IG_IfTable->IT_CS)

#define LEAVE_IF_SECTION() \
        LeaveCriticalSection(&ig.IG_IfTable->IT_CS)


#define ACQUIRE_PEER_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_PeerTable->PT_RWL)

#define RELEASE_PEER_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_PeerTable->PT_RWL)

#define ACQUIRE_PEER_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_PeerTable->PT_RWL)

#define RELEASE_PEER_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_PeerTable->PT_RWL)


#define ACQUIRE_BINDING_LOCK_EXCLUSIVE() \
        AcquireWriteLock(&ig.IG_BindingTable->BT_RWL)

#define RELEASE_BINDING_LOCK_EXCLUSIVE() \
        ReleaseWriteLock(&ig.IG_BindingTable->BT_RWL)

#define ACQUIRE_BINDING_LOCK_SHARED() \
        AcquireReadLock(&ig.IG_BindingTable->BT_RWL)

#define RELEASE_BINDING_LOCK_SHARED() \
        ReleaseReadLock(&ig.IG_BindingTable->BT_RWL)



//
// constants and macros used for tracing 
//

#define IPRIP_TRACE_ANY             ((DWORD)0xFFFF0000 | TRACE_USE_MASK)
#define IPRIP_TRACE_ENTER           ((DWORD)0x00010000 | TRACE_USE_MASK)
#define IPRIP_TRACE_LEAVE           ((DWORD)0x00020000 | TRACE_USE_MASK)
#define IPRIP_TRACE_TIMER           ((DWORD)0x00040000 | TRACE_USE_MASK)
#define IPRIP_TRACE_IF              ((DWORD)0x00080000 | TRACE_USE_MASK)
#define IPRIP_TRACE_ROUTE           ((DWORD)0x00100000 | TRACE_USE_MASK)
#define IPRIP_TRACE_SEND            ((DWORD)0x00200000 | TRACE_USE_MASK)
#define IPRIP_TRACE_RECEIVE         ((DWORD)0x00400000 | TRACE_USE_MASK)
#define IPRIP_TRACE_CONFIG          ((DWORD)0x00800000 | TRACE_USE_MASK)
#define IPRIP_TRACE_START           ((DWORD)0x01000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_STOP            ((DWORD)0x02000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_REQUEST         ((DWORD)0x04000000 | TRACE_USE_MASK)
#define IPRIP_TRACE_RESPONSE        ((DWORD)0x08000000 | TRACE_USE_MASK)


#define TRACEID         ig.IG_TraceID


#define TRACE0(l,a)             \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a)
#define TRACE1(l,a,b)           \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b)
#define TRACE2(l,a,b,c)         \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c)
#define TRACE3(l,a,b,c,d)       \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d)
#define TRACE4(l,a,b,c,d,e)     \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d, e)
#define TRACE5(l,a,b,c,d,e,f)   \
    if (TRACEID != INVALID_TRACEID) TracePrintfEx(TRACEID, IPRIP_TRACE_ ## l, a, b, c, d, e, f)

#define TRACEDUMP(l,a,b,c)      \
            TraceDumpEx(TRACEID,l,a,b,c,TRUE)



//
// Event logging macros
//

#define LOGLEVEL        ig.IG_LogLevel
#define LOGHANDLE       ig.IG_LogHandle
#define LOGERR          RouterLogError
#define LOGWARN         RouterLogWarning
#define LOGINFO         RouterLogInformation
#define LOGWARNDATA     RouterLogWarningData


// Error logging

#define LOGERR0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGERR1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,1,&(a),(err))
#define LOGERR2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGERR3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGERR4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_ERROR) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGERR(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }


// Warning logging

#define LOGWARN0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGWARN1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,1,&(a),(err))
#define LOGWARN2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGWARN3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGWARN4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGWARN(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }

#define LOGWARNDATA2(msg,a,b,dw,buf) \
        if (LOGLEVEL >= IPRIP_LOGGING_WARN) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGWARNDATA(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(dw),(buf)); \
        }


// Information logging

#define LOGINFO0(msg,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,0,NULL,(err))
#define LOGINFO1(msg,a,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,1,&(a),(err))
#define LOGINFO2(msg,a,b,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[2] = { (a), (b) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,2,_asz,(err)); \
        }
#define LOGINFO3(msg,a,b,c,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[3] = { (a), (b), (c) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,3,_asz,(err)); \
        }
#define LOGINFO4(msg,a,b,c,d,err) \
        if (LOGLEVEL >= IPRIP_LOGGING_INFO) { \
            LPSTR _asz[4] = { (a), (b), (c), (d) }; \
            LOGINFO(LOGHANDLE,IPRIPLOG_ ## msg,4,_asz,(err)); \
        }



//
// IP address conversion macro:
//  calls inet_ntoa directly on a DWORD, by casting it as an IN_ADDR.
//

#define INET_NTOA(dw) inet_ntoa( *(PIN_ADDR)&(dw) )


//
// external declaration of the main thread
//

DWORD
IpripThread(
    PVOID pParam
    );


//
//
//

DWORD
QueueRipWorker(
    WORKERFUNCTION pFunction,
    PVOID pContext
    );

BOOL
EnterRipAPI(
    );

BOOL
EnterRipWorker(
    );

VOID
LeaveRipWorker(
    );

#endif // _IPRIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\rras\ip\rip\riptest.cxx ===
//============================================================================
// Copyright (c) 1995, Microsoft Corporation
//
// File:    riptest.cxx
//
// History:
//  Abolade Gbadegesin  Oct-16-1995     Created.
//
// Code for RIP test program
//============================================================================

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>
#define FD_SETSIZE      256
#include <winsock.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <malloc.h>

#include <ipexport.h>
#include <ipinfo.h>
#include <llinfo.h>

#include <rtm.h>
#include <routprot.h>
#include <mprerror.h>
#include <rtutils.h>
#include <ipriprm.h>
#include <iprtrmib.h>
#include <dim.h>
#include <mprapi.h>
#include <iphlpapi.h>

#include "defs.h"


#include "riptest.h"

DWORD g_TraceID;

RIPTEST_IF_CONFIG g_cfg;

RIPTEST_IF_CONFIG g_def = {
    50,             // 50 routes
    0x000000c0,     // starting with 192.0.0.0
    0x0000ffff,     // using netmask 255.255.0.0
    0x00000000,     // and a next hop of 0
    0x00000000,     // and a route-tag of 0
    0xffffffff,     // sent to the broadcast address
    0,              // don't use a timeout to remove routes
    2,              // send version 2 packets
    0,              // random-sized packets
    100,            // use 100-millisecond packet gap
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", // all-zeroes authentication key
    IPRIP_AUTHTYPE_NONE,                // no authentication
    262144          // and set the send and recv buffers to this size
};


DWORD g_seed;
RIPTEST_IF_BINDING g_bind;



REG_OPTION g_options[] = {

    {
        STR_ROUTECOUNT,
        sizeof(DWORD),
        &g_cfg.RIC_RouteCount,
        &g_def.RIC_RouteCount,
        RegGetDWORD 
    },
    {
        STR_ROUTESTART,
        sizeof(DWORD),
        &g_cfg.RIC_RouteStart,
        &g_def.RIC_RouteStart,
        RegGetAddress
    },
    {
        STR_ROUTEMASK,
        sizeof(DWORD),
        &g_cfg.RIC_RouteMask,
        &g_def.RIC_RouteMask,
        RegGetAddress
    },
    {
        STR_ROUTENEXTHOP,
        sizeof(DWORD),
        &g_cfg.RIC_RouteNexthop,
        &g_def.RIC_RouteNexthop,
        RegGetAddress
    },
    {
        STR_ROUTETAG,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTag,
        &g_def.RIC_RouteTag,
        RegGetDWORD
    },
    {
        STR_ROUTETARGET,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTarget,
        &g_def.RIC_RouteTarget,
        RegGetAddress
    },
    {
        STR_ROUTETIMEOUT,
        sizeof(DWORD),
        &g_cfg.RIC_RouteTimeout,
        &g_def.RIC_RouteTimeout,
        RegGetDWORD
    },
    {
        STR_PACKETVERSION,
        sizeof(DWORD),
        &g_cfg.RIC_PacketVersion,
        &g_def.RIC_PacketVersion,
        RegGetDWORD
    },
    {
        STR_PACKETENTRYCOUNT,
        sizeof(DWORD),
        &g_cfg.RIC_PacketEntryCount,
        &g_def.RIC_PacketEntryCount,
        RegGetDWORD
    },
    {
        STR_PACKETGAP,
        sizeof(DWORD),
        &g_cfg.RIC_PacketGap,
        &g_def.RIC_PacketGap,
        RegGetDWORD
    },
    {
        STR_AUTHKEY,
        IPRIP_MAX_AUTHKEY_SIZE,
        g_cfg.RIC_AuthKey,
        g_def.RIC_AuthKey,
        RegGetBinary
    },
    {
        STR_AUTHTYPE,
        sizeof(DWORD),
        &g_cfg.RIC_AuthType,
        &g_def.RIC_AuthType,
        RegGetDWORD
    },
    {
        STR_SOCKBUFSIZE,
        sizeof(DWORD),
        &g_cfg.RIC_SockBufSize,
        &g_def.RIC_SockBufSize,
        RegGetDWORD
    }
};




INT __cdecl
main(
    INT iArgc,
    PSTR ppszArgv[]
    )
{

    WSADATA wd;
    DWORD dwErr;

    //
    // must be at least one argument
    //

    if (iArgc != 2) {

        PrintUsage();
        return ERROR_INVALID_PARAMETER;
    }


    //
    // see if the user is just asking for instructions
    //

    if (strcmp(ppszArgv[1], "-?") == 0 || strcmp(ppszArgv[1], "/?") == 0) {

        PrintUsage();
        return 0;
    }


    //
    // first and only argument is name of interface
    //

    mbstowcs(g_bind.RIB_Netcard, ppszArgv[1], mbstowcs(NULL, ppszArgv[1], -1));


    //
    // register with the Tracing DLL
    //

    g_TraceID = PRINTREGISTER("RipTest");

    //
    // startup Winsock
    //

    dwErr = WSAStartup(MAKEWORD(1, 1), &wd);

    if (dwErr != NO_ERROR) {
        PRINTDEREGISTER(g_TraceID);
        return (INT)dwErr;
    }


    //
    // get the binding for the interface over which to send routes
    //

    dwErr = RegGetIfBinding();

    if (dwErr != NO_ERROR) {

        WSACleanup();
        PRINTDEREGISTER(g_TraceID);
        return (INT)dwErr;
    }



    //
    // seed the random number generator 
    //

    g_seed = GetTickCount();

    srand(g_seed);


    while (TRUE) {

        PRINT0("\n\nbeginning test cycle...");
    
        //
        // get the parameters for the interface,
        // and quit if an error occurred or the defaults were written
        //
    
        dwErr = RegGetConfig();
        if (dwErr != NO_ERROR) { break; }
    
    
        //
        // run one test cycle
        //

        dwErr = RipTest();

        PRINT0("completed test cycle...");
    }

    WSACleanup();

    PRINTDEREGISTER(g_TraceID);

    return dwErr;
}



DWORD
RegGetIfBinding(
    VOID
    )
{
#if 1
    PMIB_IPADDRTABLE AddrTable = NULL;
    DWORD dwErr;
    DWORD dwPrefixLength = lstrlen("\\DEVICE\\TCPIP_");
    DWORD dwSize;
    DWORD i;
    DWORD j;
    PIP_INTERFACE_INFO IfTable = NULL;

    //
    // Load the address table and interface table
    //

    do {

        dwSize = 0;

        dwErr = GetInterfaceInfo(IfTable, &dwSize);
    
        if (dwErr != ERROR_INSUFFICIENT_BUFFER) {
            PRINT1("error %d obtaining interface-table size", dwErr);
            break;
        }
    
        IfTable = (PIP_INTERFACE_INFO)HeapAlloc(GetProcessHeap(), 0, dwSize);

        if (!IfTable) {
            dwErr = GetLastError();
            PRINT2("error %d allocating %d-byte for interfaces", dwErr, dwSize);
            dwErr = ERROR_INSUFFICIENT_BUFFER; break;
        }
    
        dwErr = GetInterfaceInfo(IfTable, &dwSize);

        if (dwErr != NO_ERROR) {
            PRINT1("error %d getting interface table", dwErr);
            break;
        }

        dwSize = 0;

        dwErr = GetIpAddrTable(AddrTable, &dwSize, FALSE);
