-------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    const SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetObjectRectsChangingWIndowPos    [overridable]
//=--------------------------------------------------------------------------=
// called just before we perform a SetWindowPos in the SetObjectRects
// function. gives a control the opportunity to change the flags.
//
// Notes:
//
void COleControl::OnSetObjectRectsChangingWindowPos(DWORD *dwFlag)
{
    *dwFlag = 0;
}

void COleControl::OnVerb(LONG lVerb)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"


//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;
    DWORD   dw;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    if (pContainer->cbSize < sizeof(QACONTAINER)) return E_UNEXPECTED;
    if (pControl->cbSize < sizeof(QACONTROL)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = Advise(pContainer->pAdviseSink, &dw);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"
#include <windows.h>

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

const BYTE g_rgcbPromotedDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(int ),           // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(double),         // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(int),            // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}


//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));

    return;
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
    COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    pUnk->QueryInterface(IID_IControlPrv, (void **)&pCtl);

    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.
// Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LeaveCriticalSection(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    if (g_hwndParking != NULL)
       ++g_cLocks;

    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return g_hwndParking;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE

// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR        dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if we are windowless, then we just pass this on to the end control code.
    //
    if (m_fInPlaceActive) {

        // give them a rectangle with which to draw
        //
        //ASSERT(!m_fInPlaceActive || !prcBounds, "Inplace active and somebody passed in prcBounds!!!");
        if (prcBounds)
		memcpy(&rc, prcBounds, sizeof(rc));
	else
		memcpy(&rc, &m_rcLocation, sizeof(rc));
    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (!m_fInPlaceActive) {
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC && hicTargetDevice) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)(LPBYTE)&rc + sizeof(SIZEL), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);

    // 
    //
    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)HeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if ((pDevModeA != &DevModeA) && pDevModeA) HeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// CtlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.

#include "IPServer.H"
#include "CtrlObj.H"
#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//	  BOOL                - [in] whether to enable IDispatchEx functionality
//							to allow dynamic adding of properties
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface,
	BOOL     fExpandoEnabled
)
: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface, fExpandoEnabled),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_nFreezeEvents = 0;

    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 0;
    m_Size.cy = 0;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hRgn = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_nFreezeEvents = 0;
    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    // if we've still got a window, go and kill it now.
    //
    if (m_hwnd) {
        // so our window proc doesn't crash.
        //
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
    }

    if (m_hwndReflect) {
        SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    if (m_hRgn != NULL)
    {
       DeleteObject(m_hRgn);
       m_hRgn = NULL;
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) {
        // private interface for prop page support
        case Data1_IControlPrv:
          if(DO_GUIDS_MATCH(riid, IID_IControlPrv)) {
            *ppvObjOut = (void *)this;
            ExternalAddRef();
            return S_OK;
          }
          goto NoInterface;
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, IConnectionPointContainer);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)HeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        HeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::m_pOleControl
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    COleControl *
//
// Notes:
//
inline COleControl *COleControl::CConnectionPoint::m_pOleControl
(
    void
)
{
    return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(COleControl, m_cpEvents)
                                          : offsetof(COleControl, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG COleControl::CConnectionPoint::AddRef
(
    void
)
{
    return m_pOleControl()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG COleControl::CConnectionPoint::Release
(
    void
)
{
    return m_pOleControl()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT)
        *piid = EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pOleControl()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) {

        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
        hr = pUnk->QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType), &pv);
        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //

    if (!m_cSinks) {
        m_SingleSink = (IUnknown *) pv;
        *pdwCookie = (DWORD)-1;
        m_cSinks = 1;
        return S_OK;
    }

    // Allocated the array yet?
    if (!m_rgSinks) {
        rgUnkNew = (IUnknown **)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, 8 * sizeof(IUnknown *));
        RETURN_ON_NULLALLOC(rgUnkNew);
        m_cAllocatedSinks = 8;
        m_rgSinks = rgUnkNew;
        m_rgSinks[0] = m_SingleSink;
        m_rgSinks[1] = (IUnknown *)pv;
        m_SingleSink = NULL;
        m_cSinks = 2;
        *pdwCookie = 2;
        return S_OK;
    }

    // Find an empty slot.
    for (i = 0; i < m_cAllocatedSinks; i++) {
        if (!m_rgSinks[i]) {
            m_rgSinks[i] = (IUnknown *)pv;
            i++;
            *pdwCookie = i;
            m_cSinks++;
            return S_OK;
        }
    }

    // Didn't find one, grow the array.
    rgUnkNew = (IUnknown **)HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, m_rgSinks, (m_cAllocatedSinks + 8) * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(rgUnkNew);
    m_rgSinks = rgUnkNew;
    m_rgSinks[m_cAllocatedSinks] = (IUnknown *)pv;
    i = m_cAllocatedSinks+1;
    m_cAllocatedSinks += 8;

    *pdwCookie = i;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;

    if (!dwCookie)
        return S_OK;

    if (dwCookie == (DWORD) -1) {
        pUnk = m_SingleSink;
        m_SingleSink = NULL;
        if (m_rgSinks) {
            m_rgSinks[0] = NULL;
        }
    } else {
        if (dwCookie <= (DWORD)m_cAllocatedSinks) {
            if (m_rgSinks) {
                pUnk = m_rgSinks[dwCookie-1];
                m_rgSinks[dwCookie-1] = NULL;
            } else {
                return CONNECT_E_NOCONNECTION;
            }
        } else {
            return CONNECT_E_NOCONNECTION;
        }
    }

    m_cSinks--;

    if (!m_cSinks && m_rgSinks) {
        HeapFree(g_hHeap, 0, m_rgSinks);
        m_cAllocatedSinks = 0;
        m_rgSinks = NULL;
    }

    if (pUnk) {
        pUnk->Release();
        return S_OK;
    } else {
        return CONNECT_E_NOCONNECTION;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    unsigned int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)HeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        if ((m_cSinks == 1) && !m_rgSinks) {
            rgConnectData[0].pUnk = m_SingleSink;
            rgConnectData[0].dwCookie = (DWORD)-1;
        } else {
            for (unsigned int x = 0, i=0; x < m_cAllocatedSinks; x++) {
                if (m_rgSinks[x]) {
                    rgConnectData[i].pUnk = m_rgSinks[x];
                    rgConnectData[i].dwCookie = x+1;
                    i++;
                }
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut) {
        if (rgConnectData)
        {
            HeapFree(g_hHeap, 0, rgConnectData);
        }
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
COleControl::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_SingleSink)
        ((IUnknown *)m_SingleSink)->Release();
    else {
        for (x = 0; x < m_cAllocatedSinks; x++) {
    	    if (m_rgSinks[x]) {
                QUICK_RELEASE(m_rgSinks[x]);
	        }
        }
        HeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void COleControl::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IDispatch *)m_SingleSink)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
	        }
    	}
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void COleControl::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IPropertyNotifySink *)m_SingleSink)->OnChanged(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
            }
	    }
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL COleControl::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_SingleSink) {
        hr =((IPropertyNotifySink *)m_SingleSink)->OnRequestEdit(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
                if (hr != S_OK)
	        	    break;
    	    }
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    HRESULT hr;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        } else
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            hr = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f);
            if (FAILED(hr) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, (LONG_PTR)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            BeforeDestroyWindow();
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
            DestroyWindow(m_hwnd);
            m_hwnd = NULL;
            return m_hwnd;
        }

        // if we didn't create the window visible, show it now.
        //
		
        if (fVisible)
		{
			if (GetParent(m_hwnd) != m_hwndParent)
				// SetWindowPos fails if parent hwnd is passed in so keep
				// this behaviour in those cases without ripping.
				SetWindowPos(m_hwnd, m_hwndParent, 0, 0, 0, 0,
							 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | ((fNoRedraw) ? SWP_NOREDRAW : 0));
		}
    }

    // finally, tell the host of this
    //
    if (m_pClientSite)
        m_pClientSite->ShowObject();

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
        SetParent(GetOuterWindow(), hwndParent);
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult;
    DWORD   dwCookie;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if (!pCtl) {
        pCtl = s_pLastControlCreated;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pCtl);
            // This test and else clause, which you would resonably expect to never
            // ever happen, is needed for the plugin control when hosting the SGI
            // COSMO plugin.  That plugin queries GWL_USERDATA and uses it as a pointer.
            // In IE4.0 we in-place deactivate it when IE3 did not, causing the window
            // to be destroyed, and the SGI COSMO plugin to fault.  The fix is for the
            // Plugin control to never use the GWL_USERDATA == -1 mechanism.
            // -Tomsn, 1/2/97 (happy new year), IE4 bug 13292.
        if( pCtl != NULL ) {
            pCtl->m_hwnd = hwnd;
        }
        else {
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
    } else if ((LONG_PTR)pCtl == (LONG_PTR)0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) return lResult;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
            hdc = BeginPaint(hwnd, &ps);
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
            EndPaint(hwnd, &ps);
        }
        break;

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);
        break;
    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        // after this point, the window doesn't exist any more
        //
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(msg == WM_SETFOCUS);
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return SetGUIFocus(hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetGUIFocus
//=--------------------------------------------------------------------------=
// does the work of setting the Windows GUI focus to the specified window
//
// Parameters:
//    HWND              - [in] window that should get focus
//
// Output:
//    BOOL              - [out] whether setting focus succeeded
//
// Notes:
//    we do this because some controls host non-ole window hierarchies, like
// the Netscape plugin ocx.  in such cases, the control may need to be UIActive
// to function properly in the document, but cannot take the windows focus
// away from one of its child windows.  such controls may override this method
// and respond as appropriate.
//
BOOL COleControl::SetGUIFocus
(
    HWND hwndSet
)
{
    return (::SetFocus(hwndSet) == hwndSet);
}


//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl;

    switch (msg) {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
        case WM_SETFOCUS:
        case WM_SIZE:
            pCtl = (COleControl *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pCtl)
                return SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise [or if the operation fails ...]
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        m_fModeFlagValid = TRUE;
        GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f);
        m_fRunMode = f;
    }

    return !m_fRunMode;
}


//=--------------------------------------------------------------------------=
// COleControl::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl COleControl::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4)
                V_I4(pv) = va_arg(valist, long);
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        InvalidateRect(m_hwnd, lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev = HWND_TOP;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LeaveCriticalSection(&g_CriticalSection);
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "IPServer.H"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            SetCapture(m_hwnd);
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive)
            return InvalidateRect(m_hwnd, prcInvalidate, TRUE);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelp.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//

#ifndef _CTLHELP_H_

//=--------------------------------------------------------------------------=
// these two tables are used to get information on sizes about data types
// the first is used mostly in persistence, while the second is used for
// events
//
extern const BYTE g_rgcbDataTypeSize [];
extern const BYTE g_rgcbPromotedDataTypeSize [];



//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#define _CTLHELP_H_
#endif // _CTLHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// CtlPsst.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"

// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM";

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//
#ifdef DEBUG


#include "IPServer.H"
#include <stdlib.h>


//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\dwinvers.h ===
#define vszMakeDate	"April 10, 1996\0"
#define vszMakeVers	"Version 2810 - DEBUG - ntfs-f\0\0"
#define vszVersNum	"2810\0"
#define vszVersNumAll	"5.00.2810\0"
#define vusVersNuml2	10
#define vusVersNumf2	28
#define vszCopyright	"Copyright  1987-1996 Microsoft Corp.\0\0"
#define VBA_VERHI	0x50000
#define VBA_VERLO	0x183C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\extobj.cpp ===
////
//
// CExpandoObject
//
// Notes:
// 1) If the LCID passed to this object changes from call to call we are in trouble. This is hard to
// create an ASSERT for because it would require memoizing the LCID at some point.
// 2) There is a maximum on the number of slots allowed (this is currently 2048)
// 3) This is not a thread safe structure.
// 4) I'm currently using malloc -- this is probably wrong for IE.
//

// for ASSERT and FAIL
//

#include "IPServer.H"
#include "LocalSrv.H"
#include "Globals.H"
#include "extobj.h"
#include "Util.H"
#define GTR_MALLOC(size)  CoTaskMemAlloc(size)
#define GTR_FREE(pv) CoTaskMemFree(pv)

SZTHISFILE
////
//
// Private Utility Functions
//
////

////
//
// Get the ID of a Name
//

HRESULT CExpandoObject::GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;

	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		if (slot->CompareName(name, hash, caseSensitive))
		{
			*id = slot->DispId();
			goto Exit;
		}
	}

	// not found
	hr = DISP_E_UNKNOWNNAME;
	*id = DISPID_UNKNOWN;

Exit:
	return hr;
}

////
//
// Add a new slot to the object
//

HRESULT CExpandoObject::AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;
	DISPID	dispId;

	// first check if the slot exists
	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		// bail if the name matches
		if (slot->CompareName(name, hash, caseSensitive))
		{
			hr = E_INVALIDARG;
			goto Exit;
		}
	}

	// allocate a slot
	dispId = (DISPID) m_totalSlots;
	slot = AllocSlot();
	if (slot == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Initialize it
	// BUGBUG robwell 8May96 If this fails and the initialValue is not VT_EMTPY or VT_NULL
	// there in no cleanup code.
	hr = slot->Init(name, lcid, dispId + m_dispIdBase, initialValue);
	if (FAILED(hr))
	{
		// free the slot and dispId
		m_totalSlots -= 1;
		goto Exit;
	}

	// intern the slot into the proper hash table
	slot->Insert(m_slots, m_hashTable[hashIndex]);

	// set the DISPID return value
	*id = slot->DispId();

Exit:
	return hr;
}

////
//
// Slot allocation
//
// Because slots are never freed there is no free method
//

CExpandoObjectSlot* CExpandoObject::AllocSlot()
{
	// limit on the number of slots
	if (m_totalSlots >= kMaxTotalSlots)
		return NULL;

	// do we need to realloc the array?
	if (m_totalSlots == m_slotTableSize)
	{
		UINT i;
		UINT newSize;
		CExpandoObjectSlot* newSlots;

		// allocate twice as many slots unless first time around
		if (m_slotTableSize == 0)
			newSize = kInitialSlotTableSize;
		else
			newSize = m_slotTableSize * 2;

		// allocate the space for the slots
		newSlots = (CExpandoObjectSlot*) GTR_MALLOC(sizeof(CExpandoObjectSlot)*newSize);
		if (newSlots == NULL)
			return NULL;

		// copy the old values if the old m_slots is not NULL
		if (m_slots)
		{
			// copy the slots
			memcpy(newSlots, m_slots, sizeof(CExpandoObjectSlot)*m_totalSlots);
			// free the old values
			GTR_FREE(m_slots);
		}

		// construct all of the unused slots
		for (i=m_totalSlots; i<newSize; ++i)
			newSlots[i].Construct();

		// make the new array the new table and fix the total size
		m_slots = newSlots;
		m_slotTableSize = newSize;
	}

	// return a pointer to the slot and bump the totalSlots count
	return &m_slots[m_totalSlots++];
}

////
//
// Free all of the slots
//

void CExpandoObject::FreeAllSlots()
{
	UINT i;
	UINT initedSlotCount;
	CExpandoObjectSlot* slots;

	// first clear the hash table
	ClearHashTable();

	// detach the slots
	slots = m_slots;
	initedSlotCount = m_totalSlots;

	// clear the object info
	m_totalSlots = 0;
	m_slotTableSize = 0;
	m_slots = NULL;

	// only need to destruct those slots in use
	for (i=0; i<initedSlotCount; ++i)
		slots[i].Destruct();

	// free the storage
	if (slots)
		GTR_FREE(slots);
}



////
//
// IDispatch Methods
//
////

HRESULT CExpandoObject::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	return NOERROR;
}

HRESULT CExpandoObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	*pptinfo = NULL;
	return E_NOTIMPL;
}

HRESULT CExpandoObject::GetIDsOfNames(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgdispid
)
{
	HRESULT hr;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgdispid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}

	// Otherwise look on our expanded properties

	if (cpsz == 0)
		return NOERROR;

	// get the ids for the name
	hr = GetIDOfName(prgpsz[0], lcid, FALSE, &prgdispid[0]);

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		if (SUCCEEDED(hr))
			hr = DISP_E_UNKNOWNNAME;
		prgdispid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

HRESULT CExpandoObject::Invoke(
	DISPID dispID,
	REFIID riid,
	LCID lcid,
	WORD wFlags,
	DISPPARAMS *pdispparams,
	VARIANT *pvarRes,
	EXCEPINFO *pexcepinfo,
	UINT *puArgErr
)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr;

	// First try the outer object's invoke
	if (m_pdisp)
	{
		hr = m_pdisp->Invoke(
				dispID,
				riid,
				lcid,
				wFlags,
				pdispparams,
				pvarRes,
				pexcepinfo,
				puArgErr
		);

		// If that succeeded, we're done
		if (SUCCEEDED(hr))
			return hr;
	}
	
	// Otherwise, try the expando object's invoke	
	if (NULL != puArgErr)
		*puArgErr = 0;

	if (wFlags & DISPATCH_PROPERTYGET)
	{
		if (NULL == pvarRes)
			return NOERROR;

		if (NULL != pdispparams && 0 != pdispparams->cArgs)
			return E_INVALIDARG;

		// clear the result slot
		pvarRes->vt = VT_EMPTY;
		return GetSlot(dispID, pvarRes);
	}

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
	{
		if (NULL == pdispparams
		|| 1 != pdispparams->cArgs
		|| 1 != pdispparams->cNamedArgs
		|| DISPID_PROPERTYPUT != pdispparams->rgdispidNamedArgs[0]
		)
			return DISP_E_PARAMNOTOPTIONAL;

		return SetSlot(dispID, &pdispparams->rgvarg[0]);
	}

	return DISP_E_MEMBERNOTFOUND;
}

////
//
// IDispatchEx methods
//
////

// Get dispID for names, with options
HRESULT STDMETHODCALLTYPE CExpandoObject::GetIDsOfNamesEx(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgid,
	DWORD grfdex
)
{
	HRESULT hr;
	BOOL caseSensitive = ((grfdex & fdexCaseSensitive) != 0);


	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}


	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cpsz == 0)
		return NOERROR;

	// check the array arguments
	if (prgpsz == NULL || prgid == NULL)
		return E_INVALIDARG;

	// get the id from the name
	hr = GetIDOfName(prgpsz[0], lcid, caseSensitive, &prgid[0]);

	// create the slot?
	if (hr == DISP_E_UNKNOWNNAME && (grfdex & fdexDontCreate) == 0)
	{
		VARIANT initialValue;

		if (grfdex & fdexInitNull)
			initialValue.vt = VT_NULL;
		else
			initialValue.vt = VT_EMPTY;

		hr = AddSlot(prgpsz[0], lcid, caseSensitive, &initialValue, &prgid[0]);
	}

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		hr = DISP_E_UNKNOWNNAME;
		prgid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

// Enumerate dispIDs and their associated "names".
// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
// error code if the call fails.
HRESULT STDMETHODCALLTYPE CExpandoObject::GetNextDispID(
	DISPID id,
	DISPID *pid,
	BSTR *pbstrName
)
{
	HRESULT hr;
	CExpandoObjectSlot* slot;

	// check the outgoing parameters
	if (pid == NULL || pbstrName == NULL)
		return E_INVALIDARG;

	// set to the default failure case
	*pid = DISPID_UNKNOWN;
	*pbstrName = NULL;

	// get the next slot
	hr = Next(id, slot);
	if (hr == NOERROR)
	{
		BSTR name;

		// allocate the result string
		name = SysAllocString(slot->Name());
		if (name == NULL)
			return E_OUTOFMEMORY;

		// fill in the outgoing parameters
		*pid = slot->DispId();
		*pbstrName = name;
	}

	return hr;
}

// Copy all of the expando-object properties from obj
HRESULT
CExpandoObject::CloneProperties(CExpandoObject& obj)
{
    // BUGBUG  PhilBo
    // The initialization code below is copied from the default constructor.
    // This should be factored out into a shared method.

	// Copy each of the properties from the original object
    HRESULT hr = S_OK;
    DISPID dispid = 0;
    BSTR bstrName = NULL;

    while (obj.GetNextDispID(dispid, &dispid, &bstrName) == S_OK)
    {
        // Get the value of the property from the original object
        VARIANT varResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VariantInit(&varResult);

        hr = obj.Invoke(
		        dispid,
		        IID_NULL,
		        LOCALE_SYSTEM_DEFAULT,
		        DISPATCH_PROPERTYGET,
		        &dispparamsNoArgs, &varResult, NULL, NULL);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        // Set the property on the new object
        DISPID dispidNew = 0;
	    hr = GetIDsOfNamesEx(IID_NULL, &bstrName, 1, LOCALE_SYSTEM_DEFAULT,
		    &dispidNew, 0);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        DISPPARAMS dispparams = {0};
        dispparams.rgvarg[0] = varResult;

        DISPID rgdispid[] = {DISPID_PROPERTYPUT};
        dispparams.rgdispidNamedArgs = rgdispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;

        hr = Invoke(
		    dispidNew,
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_PROPERTYPUT,
		    &dispparams, NULL, NULL, NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\internet.cpp ===
//=--------------------------------------------------------------------------=
// Internet.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains internet helper classes CDownloadSink and CInternetControl
//
#include "IPServer.H"
#include "Internet.H"
#include "Util.H"

static VARTYPE rgI4[] = { VT_I4 };

typedef enum {
    InternetEvent_Progress = 0,
    InternetEvent_ReadyStateChange = 1
} INTERNETEVENTS;

static EVENTINFO rgEvents [] = {
    { DISPID_PROGRESS, 1, rgI4 },           // (long percentDone)
    { DISPID_READYSTATECHANGE, 1, rgI4 },       // (OLE_READYSTATE newState)
};


// local class for doing async monitoring. It's not really all that
// general purpose, but it does the job...


class CDownloadSink : public IBindStatusCallback
{
public:
    CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID );
    ~CDownloadSink();

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

        STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

        STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

        STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);



        CDownloadSink * Next()                  { return(m_next); }
        void            Next(CDownloadSink *n)  { m_next = n; }

        DISPID          DispId()  { return(m_propId); }
        IBinding *      Binding() { return(m_binding); }

private:

        CDownloadSink *         m_next;
        CInternetControl *      m_control;
        DISPID                  m_propId;
        IBinding *              m_binding;
        DWORD                   m_ref;
                IStream *                               m_stream;

};


CDownloadSink::CDownloadSink
(
        IUnknown *              punkOuter,
        CInternetControl *      control,
        DISPID                  propId
)
{
//      CHECK_POINTER(control);

        m_control = control;
        m_control->AddRef();

        m_propId  = propId;
        m_next    = 0;
        m_binding = 0;
        m_ref     = 0;
        m_stream  = 0;
}

CDownloadSink::~CDownloadSink()
{
        if( m_control )
                m_control->Release();
        if( m_binding )
                m_binding->Release();
        if( m_stream )
                m_stream->Release();
}

STDMETHODIMP
CDownloadSink::QueryInterface(const GUID &iid,void **ppv )
{
        if( IsEqualGUID(iid,IID_IUnknown) || IsEqualGUID(iid,IID_IBindStatusCallback) )
        {
                *ppv = this;
                AddRef();
                return(NOERROR);
        }
        return( E_NOINTERFACE );
}

STDMETHODIMP_(ULONG)
CDownloadSink::AddRef()
{
        return(++m_ref);
}

STDMETHODIMP_(ULONG)
CDownloadSink::Release()
{
        if(!--m_ref)
        {
                delete this;
                return(0);
        }
        return( m_ref );
}


STDMETHODIMP
CDownloadSink::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *pib)
{
        // BUGBUG: should check to see options are what we think they are
        m_binding = pib;
        pib->AddRef();
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::GetPriority( LONG *pnPriority)
{
        return(E_NOTIMPL);
}

STDMETHODIMP
CDownloadSink::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
        return(m_control->OnProgress(m_propId,ulProgress,
                                                        ulProgressMax,ulStatusCode,pwzStatusText) );
}

STDMETHODIMP
CDownloadSink::OnDataAvailable
(
     DWORD                      grfBSCF,
     DWORD                      dwSize,
     FORMATETC *        pFmtetc,
         STGMEDIUM *    pstgmed
)
{
#ifdef DEBUG
        char msg[200];
        wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)\n",grfBSCF,dwSize,
                pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL" );
        OutputDebugString(msg);
#endif

    if( !m_stream )
                m_stream = pstgmed->pstm;

        return(m_control->OnData(       m_propId,
                                                                grfBSCF,
                                                                m_stream,
                                                                dwSize ));
}

STDMETHODIMP
CDownloadSink::OnObjectAvailable
(
        REFIID riid,
    IUnknown *punk
)
{
        return(E_NOTIMPL);
}


STDMETHODIMP
CDownloadSink::OnLowResource( DWORD reserved)
{
        // BUGBUG: really should have this kind of harsh policy on this ...
        m_binding->Abort();
        return(S_OK);
}

STDMETHODIMP
CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
        m_binding->Release();
        m_binding = 0;
        m_control->Release();
        m_control = 0;

        return(NOERROR);
}



//------------------------------------------------------
//
// class CInternetControl
//
//
CInternetControl::CInternetControl
(
        IUnknown *      pUnkOuter,
        int                     iPrimaryDispatch,
        void *          pMainInterface
)
        : COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface)
{
        m_host = 0;
        m_readyState = READYSTATE_LOADING;
}

CInternetControl::~CInternetControl()
{
        if( m_host )
                m_host->Release();
}


HRESULT CInternetControl::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;
     return COleControl::InternalQueryInterface(riid, ppvObjOut);
}



HRESULT
CInternetControl::GetBindHost()
{

        if( m_host )
                return(NOERROR);

    // Try service provider first...

        IServiceProvider * serviceProvider = 0;

        HRESULT hr = m_pClientSite->QueryInterface
                                                                        (
                                                                                IID_IServiceProvider,
                                                                                (void**)&serviceProvider
                                                                        );

        if( SUCCEEDED(hr) )
    {
                hr = serviceProvider->QueryService
                                    (
                                        SID_IBindHost,
                                        IID_IBindHost,
                                        (void**)&m_host
                                    );
                serviceProvider->Release();
    }

    if( FAILED(hr) )
    {
        // Some containers put IBindHost directly on the client site

        hr = m_pClientSite->QueryInterface
                                                                        (
                                        IID_IBindHost,
                                        (void**)&m_host
                                                                        );


    }

        return(hr);

}


HRESULT CInternetControl::GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
        HRESULT hr = GetBindHost();

        if( SUCCEEDED(hr) )
                hr = m_host->CreateMoniker(url,NULL, ppmkr,0);

        if( FAILED(hr) )
    {
           // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
       hr = ::CreateURLMoniker(0,url,ppmkr);
       // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
    }

        return( hr );
}


HRESULT CInternetControl::SetupDownload( LPOLESTR url, DISPID propId )
{
        CHECK_POINTER(url);

        IMoniker * pmkr;

        HRESULT hr = GetAMoniker( url, &pmkr );

        IBindCtx * pBindCtx = 0;

        if( SUCCEEDED(hr) )
    {
        hr = ::CreateBindCtx(0,&pBindCtx);
    }

        CDownloadSink * sink = 0;

        if( SUCCEEDED(hr) )
        {
                sink = new CDownloadSink(0,this,propId);
                if( sink )
                        sink->AddRef();
        }

        if( SUCCEEDED(hr) && !sink )
                hr = E_OUTOFMEMORY;

        if( SUCCEEDED(hr) )
        {
                // BUGBUG: There should be a define for 0x77
                hr = ::RegisterBindStatusCallback(pBindCtx, sink,0, 0) ;
        }

        IStream * strm = 0;

        if( SUCCEEDED(hr) )
                hr = pmkr->BindToStorage( pBindCtx, 0, IID_IStream, (void**)&strm );

        if( strm )
                strm->Release();

        if( pBindCtx )
                pBindCtx->Release();

        if( FAILED(hr) && sink )
                sink->Release();

        return(hr);

}


HRESULT CInternetControl::OnData( DISPID, DWORD,IStream *, DWORD)
{
        return(NOERROR);
}

HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR)
{
        return(NOERROR);
}


HRESULT CInternetControl::FireReadyStateChange( long newState )
{
        FireEvent( &::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState );
        return(S_OK);
}

HRESULT CInternetControl::FireProgress( ULONG dwAmount )
{
        FireEvent( &::rgEvents[InternetEvent_Progress], dwAmount );
        return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// IPServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Globals.H"
#include "Unknown.H"
#include "Util.H"

//=--------------------------------------------------------------------------=
// Private module level data
//
// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;


//=--------------------------------------------------------------------------=
// allow controls to register for DLL_THREAD_ATTACH and DLL_THREAD_DETACH 
//
THRDNFYPROC g_pfnThreadProc = NULL;

extern "C" void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify)
{
    if ((g_pfnThreadProc = pfnThreadNotify) == NULL)
        DisableThreadLibraryCalls((HMODULE)g_hInstance);
}


// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }

        // initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // give the user a chance to initialize whatever
        //
        InitializeLibrary();

        // if they didn't ask for thread notifications then optimize by turning
        // them off for our DLL.
        //
        if (!g_pfnThreadProc)
            DisableThreadLibraryCalls((HMODULE)hInstance);
        }
        break;

      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
        if (g_pfnThreadProc)
            g_pfnThreadProc(hInstance, dwReason, pvReserved);
        break;

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

        // clean up our critical seciton
        //
        DeleteCriticalSection(&g_CriticalSection);

        // unregister all the registered window classes.
        //
        i = 0;

        while (!ISEMPTYOBJECT(i)) {
            if (g_ObjectInfo[i].usType == OI_CONTROL) {
                if (CTLWNDCLASSREGISTERED(i))
                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
            }
            i++;
        }

        // clean up our parking window.
        //
        if (g_hwndParking) {
            DestroyWindow(g_hwndParking);
            UnregisterClass("CtlFrameWork_Parking", g_hInstance);
            --g_cLocks;
        }

        // clean up after reflection, if appropriate.
        //
        if (g_fRegisteredReflect)
            UnregisterClass(g_szReflectClassName, g_hInstance);

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();
        break;
    }

    return TRUE;
}



//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{
    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
    return (g_cLocks) ? S_FALSE : S_OK;
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
        return CLASS_E_CLASSNOTAVAILABLE;

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    int     x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x));
            break;

          case OI_AUTOMATION:
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                     *g_pLibid, CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),
                                  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
                                  BITMAPIDOFCONTROL(x));
            break;

        }
        x++;
    }

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);
        hr = LoadTypeLib(pwsz, &pTypeLib);
        RETURN_ON_FAILURE(hr);
        hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
        pTypeLib->Release();
        RETURN_ON_FAILURE(hr);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
HRESULT UnregisterAllObjects
(
    void
)
{
    int x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library [this isn't an API function
    // -- we've implemented this ourselves]
    //
    if (g_pLibid)
        UnregisterTypeLibrary(*g_pLibid);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "IPServer.H"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropPage.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "IPServer.H"
#include "PropPage.H"
#include "Util.H"
#include "Globals.H"

// for ASSERT and FAIL
//
SZTHISFILE

// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_cObjects = 0;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xffffffff);
        DestroyWindow(m_hwnd);
    }

    // release all the objects we're holding on to.
    //
    m_ReleaseAllObjects();

    // release the site
    //
    QUICK_RELEASE(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = m_EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    // blow away yon window.
    //
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    m_hwnd = NULL;
    m_fActivated = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    m_EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) CoTaskMemFree(pPropPageInfo->pszDocString);
    if (pPropPageInfo->pszHelpFile) CoTaskMemFree(pPropPageInfo->pszHelpFile);
    if (pPropPageInfo->pszTitle) CoTaskMemFree(pPropPageInfo->pszTitle);

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    // free up all the old objects first.
    //
    m_ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)HeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the object that there are new objects
    //
    hr = S_OK;
    m_cObjects = cObjects;
    // if we've got a window, go and notify it that we've got new objects.
    //
    if (m_hwnd)
        SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
    if (SUCCEEDED(hr)) m_fDirty = FALSE;

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;
            if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir
)
{
    BOOL f;

    ASSERT(m_hwnd, "How can somebody have clicked Help, but we don't have an hwnd?");

    // oblige them and show the help.
    //
    MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
    f = WinHelp(m_hwnd, psz, HELP_CONTEXT, HELPCONTEXTOFPROPPAGE(m_ObjectType));

    return f ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");

    // just pass this message on to the dialog proc and see if they want it.
    //
    return IsDialogMessage(m_hwnd, pmsg) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::m_EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastPageCreated = this;

    // create the dialog window
    //
    CreateDialog(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), GetParkingWindow(),
                          CPropertyPage::PropPageDlgProc);
    ASSERT(m_hwnd, "Couldn't load Dialog Resource!!!");
    if (!m_hwnd) {
        LeaveCriticalSection(&g_CriticalSection);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::m_ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    if (!m_cObjects)
        return;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    HeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
INT_PTR CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pPropertyPage == (CPropertyPage *)-1)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    if (m_pPropertyPageSite)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LeaveCriticalSection(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "IPServer.H"
#include "Unknown.H"
#include <stddef.h>


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\strcoll.cpp ===
//=--------------------------------------------------------------------------=
// StrColl.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for our simple strings collections.
//
#include "IPServer.H"

#include "SimpleEnumVar.H"
#include "StringsColl.H"


// for asserts
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CStringsCollection::CStringsCollection
//=--------------------------------------------------------------------------=
// constructor. sets up the safearray pointer.
//
// Parameters:
//    SAFEARRAY        - [in] the collection we're working with.
//
// Notes:
//
CStringCollection::CStringCollection
(
    SAFEARRAY *psa
)
: m_psa(psa)
{
    ASSERT(m_psa, "Bogus Safearray pointer!");
}

//=--------------------------------------------------------------------------=
// CStringCollection::~CStringCollection
//=--------------------------------------------------------------------------=
//
// Notes:
//
CStringCollection::~CStringCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Count
//=--------------------------------------------------------------------------=
// returns the count of the things in the collection
//
// Parameters:
//    long *         - [out] the count
//
// Output:
//    HRESULT        - S_OK, one of the SAFEARRAY Scodes.
//
// Notes:
//    - we're assuming the safearray's lower bound is zero!
//
STDMETHODIMP CStringCollection::get_Count
(
    long *plCount
)
{
    HRESULT hr;

    ASSERT(m_psa, "Who created a collection without a SAFEARRAY?");

    CHECK_POINTER(plCount);

    // get the bounds.
    //
    hr = SafeArrayGetUBound(m_psa, 1, plCount);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // add one since we're zero-offset
    //
    (*plCount)++;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Item
//=--------------------------------------------------------------------------=
// returns a string given an INDEX
//
// Parameters:
//    long          - [in]  the index to get it from
//    BSTR *        - [out] the item
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get_Item
(
    long  lIndex,
    BSTR *pbstrItem
)
{
    HRESULT hr;

    CHECK_POINTER(pbstrItem);

    // get the element from the safearray
    //
    hr = SafeArrayGetElement(m_psa, &lIndex, pbstrItem);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // otherwise, we've got it, so we can return
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get__NewEnum
//=--------------------------------------------------------------------------=
// returns a new IEnumVARIANT object with the collection in it.
//
// Parameters:
//    IUnknown     **    - [out] new enumvariant object.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get__NewEnum
(
    IUnknown **ppUnkNewEnum
)
{
    HRESULT hr;
    long    l;

    CHECK_POINTER(ppUnkNewEnum);

    // get the count of things in the SAFEARRAY
    //
    hr = get_Count(&l);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // create the object.
    //
    *ppUnkNewEnum = (IUnknown *) new CSimpleEnumVariant(m_psa, l);
    if (!*ppUnkNewEnum)
        CLEARERRORINFORET(E_OUTOFMEMORY);

    // refcount is already 1, so we can leave.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// CStringDynaCollection::CStringDynaCollection
//=--------------------------------------------------------------------------=
// constructor for this object.  doesn't do very much.
//
// Parameters:
//    same as for CStringCollection
//
// Notes:
//
CStringDynaCollection::CStringDynaCollection
(
    SAFEARRAY *psa
)
: CStringCollection(psa)
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::~CStringDynaCollection
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CStringDynaCollection::~CStringDynaCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::put_Item
//=--------------------------------------------------------------------------=
// sets the value of an item in the array.
//
// Parameters:
//    long         - [in] index at which to put it
//    BSTR         - [in] new value.
//
// Output:
//    HRESULT      - S_OK, safearray Scode.
//
// Notes:
//    - NULLs are converted to ""
//
STDMETHODIMP CStringDynaCollection::put_Item
(
    long lIndex,
    BSTR bstr
)
{
    HRESULT hr;
    long l;
    BSTR bstr2 = NULL;

    // get the count and verify our index
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);
    if (lIndex < 0 || lIndex >= l)
        CLEARERRORINFORET(E_INVALIDARG);
    
    // put out the string, convert NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &lIndex, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Add
//=--------------------------------------------------------------------------=
// adds a new string to the end of the collection.
//
// Parameters:
//    BSTR         - [in] the new string to add
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Add
(
    BSTR bstr
)
{
    SAFEARRAYBOUND sab;
    BSTR    bstr2 = NULL;
    HRESULT hr;
    long    l;

    // get the current size of the array.
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);

    // add one new elemnt
    //
    sab.cElements = l + 1;
    sab.lLbound = 0;

    // redim the array.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // put the out string, converting NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &l, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Remove
//=--------------------------------------------------------------------------=
// removes an element from the collection, and shuffles all the rest down to
// fill up the space.
//
// Parameters:
//    long         - [in] index of dude to remove.
//
// Output:
//    HRESULT      - S_OK, safearray Scodes.
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Remove
(
    long lIndex
)
{
    SAFEARRAYBOUND sab;
    HRESULT hr;
    BSTR    bstr;
    long    lCount;
    long    x, y;

    // first get the count of things in our array.
    //
    hr = get_Count(&lCount);
    RETURN_ON_FAILURE(hr);

    // check the index
    //
    if (lIndex < 0 || lIndex >= lCount)
        CLEARERRORINFORET(E_INVALIDARG);

    // let's go through, shuffling everything down one.
    //
    for (x = lIndex, y = x + 1; x < lCount - 1; x++, y++) {
        // get the next element.
        //
        hr = SafeArrayGetElement(m_psa, &y, &bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);

        // set it at the current location
        //
        hr = SafeArrayPutElement(m_psa, &x, bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);
    }

    // we're at the last element.  let's go and kill it.
    //
    sab.cElements = lCount - 1;
    sab.lLbound = 0;

    // CONSIDER: 9.95 -- there is a bug in oleaut32.dll which causes the
    //         below to fail if cElements = 0.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // we're done.  go bye-bye.
    //
    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StdEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "IPServer.H"
#include "StdEnum.H"
#include "Globals.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) HeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, m_iid)) {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum;

    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\datapath.h ===
#ifndef __datapath_h__
#define __datapath_h__

#ifdef __cplusplus
extern "C"{
#endif

#include <ocidl.h>

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\framewrk\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "IPServer.H"

#include "Globals.H"
#include "Util.H"
#define DECL_CRTFREE
#define DEFINE_FLOAT_STUFF
#include <crtfree.h>

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz = NULL;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1,
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpy(szScratch, pszLibName);
    lstrcat(szScratch, ".");
    lstrcat(szScratch, pszObjectName);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId
)
{
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    LONG    l;

    // first register all the automation information for this.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    // now set up the MiscStatus Bits...
    //
    RegCloseKey(hkSub);
    hkSub = NULL;
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    // now set up the toolbox bitmap
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
    lstrcat(szTmp, szGuidStr);

    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%ld.0", lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    BOOL f;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject);
    if (!f) return FALSE;

    // delete everybody of the form:
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
    //
    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
    //
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
//    - REWRITTEN: To actually work as expected (07/30/97 -- jaym)
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPSTR   pszSubKey
)
{
    DWORD   dwRet;
    HKEY    hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (dwRet == ERROR_SUCCESS)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = sizeof(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = sizeof(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (dwRet == NO_ERROR)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (RegEnumKey(  hkSubKey,
                                --dwIndex,
                                szSubKeyName,
                                cchSubKeyName) == ERROR_SUCCESS)
            {
                DeleteKeyAndSubKeys(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkIn, pszSubKey);
    }

    return (dwRet == ERROR_SUCCESS);
}


//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    EnterCriticalSection(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE GetResourceHandle
(
    void
)
{
    int i;
    char szExtension[5], szTmp[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];

    // crit sect this so that we don't mess anything up.
    //
    EnterCriticalSection(&g_CriticalSection);

    // don't do anything if we don't have to
    //
    if (g_hInstResources || !g_fSatelliteLocalization)
        goto CleanUp;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(g_lcidLocale, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

    // got the basename and the extention. go and combine them, and then add
    // on the .DLL for them.
    //
    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension);

    // try to load in the DLL
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    _MakePath(szTmp, szDllName, szFinalName);

    g_hInstResources = LoadLibrary(szFinalName);

    // if we couldn't find it with the entire LCID, try it with just the primary
    // langid
    //
    if (!g_hInstResources) {
        LPSTR psz;
        LCID lcid;
        lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
        i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
        if (!i) goto CleanUp;

        // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
        // hacky, but it should be fine.  there are no DBCS lang identifiers.
        // finally, retry the load
        //
        psz = szFinalName + lstrlen(szFinalName);
        memcpy((LPBYTE)psz - 7, szExtension, 3);
        g_hInstResources = LoadLibrary(szFinalName);
    }

  CleanUp:
    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!g_hInstResources) g_hInstResources = g_hInstance;
    LeaveCriticalSection(&g_CriticalSection);

    return g_hInstResources;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutoObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOOBJ_H_

// all automation objects will use the Unknown object that supports aggegation.
//
#include "Unknown.H"

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"
#include "extobj.h"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    const IID   *riid;                           // object's type
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define INTERFACEOFOBJECT(index)       *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile


#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \

enum {EXPANDO_DISABLED=FALSE, EXPANDO_ENABLED=TRUE};

//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *, BOOL fExpandoEnabled=FALSE);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
	BYTE  m_fExpandoEnabled;
	CExpandoObject* m_pexpando;
};


#define _AUTOOBJ_H_
#endif // _AUTOOBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else  // DEBUG

#define SZTHISFILE
#define ASSERT(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// CtrlObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CTRLOBJ_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include <olectl.h>

// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    const IID      *piidEvents;                    // IID of primary event interface
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.

} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \


#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define EVENTIIDOFCONTROL(index)         (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->piidEvents))
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass


//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObject,
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public IConnectionPointContainer, public ISpecifyPropertyPages,
                    public IProvideClassInfo, public IPointerInactive,
                    public IQuickActivate
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(ULONG_PTR dwContinue),
                    ULONG_PTR dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface,
		BOOL fExpandoEnabled=FALSE);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);
    HINSTANCE    GetResourceHandle(void);


    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window
    HRGN                m_hRgn;

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual BOOL      SetGUIFocus(HWND hwndSet);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

    // little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(const SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual void    OnSetObjectRectsChangingWindowPos(DWORD *dwFlag);
    virtual void    OnVerb(LONG lVerb);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned short    m_nFreezeEvents;             // count of freezes versus thaws
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?

  protected:
    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        COleControl *m_pOleControl();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
            m_cAllocatedSinks = 0;
            m_SingleSink = NULL;
        }
        ~CConnectionPoint();

        BYTE   m_bType;
        unsigned short m_cSinks;
        IUnknown *m_SingleSink;
        unsigned short m_cAllocatedSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};

#define _CTRLOBJ_H_
#endif // _CTRLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;
extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)

#define _GLOBALS_H_
#endif // _GLOBALS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\extobj.h ===
#ifndef __EXTOBJ_H
#define __EXTOBJ_H
////
//
// ExpandoObject header file
//
//
//
#include "IPServer.H"

////
//
// IDispatchEx
//
////

////
//
// the GUID
//

// {A0AAC450-A77B-11cf-91D0-00AA00C14A7C}
DEFINE_GUID(IID_IDispatchEx, 0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);

////
//
// IDispatchEx flags:
//

enum
{
	fdexNil = 0x00,				// empty
	fdexDontCreate = 0x01,		// don't create slot if non-existant otherwise do
	fdexInitNull = 0x02,		// init a new slot to VT_NULL as opposed to VT_EMPTY
	fdexCaseSensitive = 0x04,	// match names as case sensitive
};

////
//
// This is the interface for extensible IDispatch objects.
//

class IDispatchEx : public IDispatch
{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	) = 0;
};

////
//
// Globals and definitions
//
////

#define NUM_EXPANDO_DISPIDS		250
#define	NUM_CORE_DISPIDS		250
#define NUM_RESERVED_EXTENDER_DISPIDS (NUM_CORE_DISPIDS + NUM_EXPANDO_DISPIDS)
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) & 0xFFFF0000 ) == EXTENDER_DISPID_BASE )

////
//
// Slot: the state of a value slot
//

inline WCHAR ToUpper(WCHAR ch)
{
	if (ch>='a' && ch <= 'z')
		return ch - 'a' + 'A';
	else
		return ch;

}

class CExpandoObjectSlot
{
public:
	////
	//
	// Constructor/Destructor
	//

	// because these monsters are malloc'ed, we need a manual constructor and destructor methods
	void Construct()
	{
		m_name = NULL;
		m_next = -1;
		VariantInit(&m_value);
		// set hash and dispId to dummy values
		m_hash = 0;
		m_dispId = DISPID_UNKNOWN;
	}

	void Destruct()
	{
		if (m_name)
			SysFreeString(m_name);
		VariantClear(&m_value);
	}

private:
	// the constructors and destructors are private because they should never be called ...
	// we could use in-place construction if we wanted to be clever ...
	CExpandoObjectSlot()
	{
	}

	~CExpandoObjectSlot()
	{
	}

public:
	////
	//
	// Init the slot
	//

	HRESULT Init(LPOLESTR name, LCID lcid, DISPID dispId, VARIANT* value)
	{
		// allocate the string
		m_name = SysAllocString(name);
		if (m_name == NULL)
			return E_OUTOFMEMORY;

		// compute the hash: uses the standard OLE string hashing function
		// note that this function is case insensitive
		m_hash = LHashValOfName(lcid, name);

		// set the dispId
		m_dispId = dispId;

		// Copy the variant value
		return VariantCopy(&m_value, value);
	}

	////
	//
	// Name information
	//

	// get the name
	BSTR Name()
	{ return m_name; }

	// compare two names
	BOOL CompareName(LPOLESTR name, ULONG hash, BOOL caseSensitive)
	{

		// hash should be the same, length should be the same, and strings should compare
		// BUGBUG robwell 8May96 These functions are probably verboten.
		if (hash != m_hash)
			return FALSE;

		if (!name)
			return !m_name;

		WCHAR *c1 = name;
		WCHAR *c2 = m_name;

		// Travel down both strings until we reach a mismatched character
		// or the end of one (or both) of the strings

		if (caseSensitive)
			while (*c1 && *c2 && *c1++==*c2++);
		else
			while (*c1 && *c2 && ToUpper(*c1++)==ToUpper(*c2++));

		// The strings match if we reached the end of both without a mismatch
		return !*c1 && !*c2;
 	}

	////
	//
	// DispId information
	//

	// get the dispatch id
	DISPID DispId()
	{ return m_dispId; }

	////
	//
	// Get and set the property values
	//

	HRESULT Get(VARIANT* result)
	{ return VariantCopy(result, &m_value); }

	HRESULT Set(VARIANT* value)
	{ return VariantCopy(&m_value, value); }

	////
	//
	// List management
	//

	CExpandoObjectSlot* Next(CExpandoObjectSlot* base)
	{ return m_next == -1? NULL: &base[m_next]; }

	CExpandoObjectSlot* Insert(CExpandoObjectSlot* base, LONG& prev)
	{
		m_next = prev;
		prev = (LONG)(this - base);
		return this;
	}

private:
	// the DispId
	DISPID		m_dispId;
	// the name
	LPOLESTR	m_name;
	// the name hash
	ULONG		m_hash;
	// the property value
	VARIANT		m_value;
	// the hash bucket link (index based)
	LONG		m_next;
};

// NB: CExpandoObject implements a crippled version of aggegation.
// It delegates all IUnknown calls to its controlling IUnknown, and has no
// private IUnknown interface.
// If you want the CExpandoObject to go away, simply call delete on it.
class CExpandoObject: public IDispatchEx
{
public:

	////
	//
	// Constructor/Destructor
	//

	CExpandoObject(IUnknown *punkOuter, IDispatch *pdisp, ULONG dispIdBase = EXTENDER_DISPID_BASE + NUM_CORE_DISPIDS)
	{
		// remember our controlling outer
		m_punkOuter = punkOuter;

		// remember the IDispatch to try first for IDispatch functionality
		m_pdisp = pdisp;
		
		// clear the name hash table
		ClearHashTable();
		// set the total slots and the table of slots to 0 and empty respectively)
		m_totalSlots = 0;
		m_slotTableSize = 0;
		m_slots = NULL;
		m_dispIdBase = dispIdBase;
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG)Release()
	{
		return m_punkOuter->Release();
	}

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObjOut)
	{
		return m_punkOuter->QueryInterface(riid, ppvObjOut);
	}

    virtual ~CExpandoObject(void)
	{
		FreeAllSlots();
	}


    // Copy all of the properties from obj
   	HRESULT CloneProperties(CExpandoObject& obj);

	////
	//
	//
	// Utility functions
	//

	// free all slots
	void FreeAllSlots();

	// IDispatch methods
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		UINT itinfo,
		LCID lcid,
		ITypeInfo **pptinfo
	);
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgdispID
	);
	virtual HRESULT STDMETHODCALLTYPE Invoke(
		DISPID dispID,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pdispparams,
		VARIANT *pvarRes,
		EXCEPINFO *pexcepinfo,
		UINT *puArgErr
	);

	// IDispatchEx methods

	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	);

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	);

private:
	////
	//
	// Implementation constants
	//

	enum
	{
		kSlotHashTableSize = 10,
		kInitialSlotTableSize = 4,
		kMaxTotalSlots = NUM_EXPANDO_DISPIDS
	};

	////
	//
	// Utility functions
	//

	//
	CExpandoObjectSlot* GetHashTableHead(UINT hashIndex)
	{
		LONG index;

		return (index = m_hashTable[hashIndex]) == -1? NULL: &m_slots[index];
	}

	// get the ID of from a slot name
	HRESULT GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id);
	// add a slot to the object
	HRESULT AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id);
	// allocate a slot from the slot table
	CExpandoObjectSlot* AllocSlot();
	// clear the hash table
	void ClearHashTable()
	{
		UINT i;

		for (i=0; i<kSlotHashTableSize; ++i)
			m_hashTable[i] = -1;
	}

	////
	//
	// Slot operations
	//
	// DISPIDS start at kInitialDispId so we need to offset them by that amount
	// in this code.
	//

	HRESULT GetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Get(result);
	}

	HRESULT SetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Set(result);
	}

	////
	//
	// Iteration operations
	//

	UINT	NumDispIds()
	{ return m_totalSlots; }

	DISPID	First()
	{ return m_dispIdBase; }

	DISPID	Last()
	{ return m_totalSlots + m_dispIdBase - 1; }

	BOOL	ValidDispId(DISPID id)
	{ return id >= First() && id <= Last(); }

	HRESULT	Next(DISPID key, CExpandoObjectSlot*& slot)
	{
		// zero restarts the enumerator
		if (key == 0)
		{
			// if there are no slots we are done
			if (NumDispIds() == 0)
				return S_FALSE;

			// return the first slot
			slot = &m_slots[0];
			return NOERROR;
		}
		else
		if (key == Last())
		{
			// the key was the last slot so we are done
			return S_FALSE;
		}
		else
		if (ValidDispId(key))
		{
			// return the next slot
			slot = &m_slots[key-m_dispIdBase+1];
			return NOERROR;
		}
		else
			// the key must be invalid
			return E_INVALIDARG;
	}

	////
	//
	// The local state of the object
	//

	// the objects reference count
	ULONG	m_ref;

	// the base of objectIds
	ULONG	m_dispIdBase;

	// the hash table of slots - for fast GetIDSofNames lookup
	LONG	m_hashTable[kSlotHashTableSize];

	// the number of slots (and the next dispId to allocate)
	UINT	m_totalSlots;

	// the size of the allocated array of slots
	UINT	m_slotTableSize;

	// a pointer to the allocated array of slots
	CExpandoObjectSlot* m_slots;

	// controlling unknown
	IUnknown *m_punkOuter;

	// controlling IDispatch
	IDispatch *m_pdisp;
};

#endif // __EXTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\internet.h ===
//=--------------------------------------------------------------------------=
// Internet.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the URLDib2 control.
//
#ifndef _INTERNET_H
#define _INTERNET_H

#define DISPID_PROGRESS 1958

#ifndef __MKTYPLIB__

#include "urlmon.H"
#include "ocidl.h"
#include "datapath.h" // for IBindHost
#include "docobj.h"   // for IServiceProvider

#include "IPServer.H"
#include "CtrlObj.H"



class CInternetControl : public COleControl
{
public:
	CInternetControl(IUnknown *     pUnkOuter, 
					int                     iPrimaryDispatch, 
					void *          pMainInterface);

	virtual ~CInternetControl();

    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

	// Call this method to start the download of a URL. 'propId' will 
	//      be passed back to you OnData below.
	HRESULT SetupDownload( LPOLESTR url, DISPID propId);


	//      Derived classes implement this method. It will be called when
	//      data has arrived for a given dispid.
	virtual HRESULT OnData( DISPID id, DWORD grfBSCF,
					IStream * bitstrm, DWORD amount );


	//      Derived classes can implement this method. It will be
	//      called at various times during the download.
	virtual HRESULT OnProgress( DISPID id, ULONG ulProgress,
					ULONG ulProgressMax,
					ULONG ulStatusCode,
					LPCWSTR pwzStatusText);

	//      Call this method to turn a URL into a Moniker.
	HRESULT GetAMoniker( LPOLESTR   url, IMoniker ** );


    HRESULT FireReadyStateChange( long newState );
	HRESULT FireProgress( ULONG dwAmount );


	// Override base class implementation...

    virtual HRESULT InternalQueryInterface(REFIID, void **);

protected:
	HRESULT GetBindHost();

    IBindHost *             m_host;
    long                    m_readyState;

    // BUGBUG: We should track all the downloads

};

#endif __MKTYPLIB__

#endif _INTERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\ipserver.h ===
//=--------------------------------------------------------------------------=
// IPServer.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _IPSERVER_H_

//#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// controls can register for thread notifications in their InitializeLibrary()
//
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef void (CALLBACK *THRDNFYPROC)(HANDLE, DWORD, void *);
void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify);

#ifdef __cplusplus
}
#endif // __cplusplus
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#include "extobj.h"


#define _IPSERVER_H_
#endif // _IPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalSrv.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1995 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSRV_H_

void      WINAPI InitializeLibrary(void);
void      WINAPI UninitializeLibrary(void);
BOOL      WINAPI RegisterData(void);
BOOL      WINAPI UnregisterData(void);
BOOL      WINAPI CheckForLicense();
BOOL      WINAPI CheckLicenseKey(LPWSTR wszCheckme);
BSTR      WINAPI GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSRV_H_
#endif // _LOCALSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\proppage.h ===
//=--------------------------------------------------------------------------=
// PropPage.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPPAGE_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject, public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    int      m_ObjectType;                        // what type of object we are
    UINT     m_cObjects;                          // how many objects we're holding on to

    void     m_ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  m_EnsureLoaded(void);                // forces the load of the page.

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    // default dialog proc for a page.
    //
    static INT_PTR CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual INT_PTR DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPPAGE_H_
#endif // _PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\tools.inc ===
#=------------------------------------------------------------------------=
# Tools.Inc
#=------------------------------------------------------------------------=
# Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# sets up the various tools required to build a control.
#


CC=cl
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
ML=asaxp
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
ML=cl
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
ML=pas
!else
ML=ml
!endif
RC=rc
LINK=link
MKTYPLIB=mktyplib
MKDEP=mkdep
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StdEnum.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STDENUM_H_

#include "Unknown.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STDENUM_H_
#endif // _STDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\strcoll.h ===
//=--------------------------------------------------------------------------=
// StrColl.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRCOLL_H_
#endif // _STRCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { InterlockedDecrement(&g_cLocks); }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif


#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SNDMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        SNDMSG(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\corepch.cxx ===
//+----------------------------------------------------------------------------
//  File:       corepch.hxx  
//
//  Synopsis:   Pre-compiled header
//
//-----------------------------------------------------------------------------

// Includes -------------------------------------------------------------------
#include <core.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\urlhlink.h ===
#ifndef __URLHLINK_H
#define __URLHLINK_H

#include "urlmon.h"

#ifdef __cplusplus
extern "C" {
#endif


// Flags for the UrlDownloadToCacheFile
#define	URLOSTRM_USECACHEDCOPY_ONLY		0x1								// Only get from cache
#define	URLOSTRM_USECACHEDCOPY			URLOSTRM_USECACHEDCOPY_ONLY	+1	// Get from cache if available else download
#define	URLOSTRM_GETNEWESTVERSION		URLOSTRM_USECACHEDCOPY		+1	// Get new version only. But put it in cache too


typedef HRESULT (STDAPICALLTYPE *LPFNUOSCALLBACK)(LPBINDSTATUSCALLBACK);


STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenStream  URLOpenStreamW
#else
#define URLOpenStream  URLOpenStreamA
#endif // !UNICODE
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenPullStream  URLOpenPullStreamW
#else
#define URLOpenPullStream  URLOpenPullStreamA
#endif // !UNICODE
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToFile  URLDownloadToFileW
#else
#define URLDownloadToFile  URLDownloadToFileA
#endif // !UNICODE

STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToCacheFile  URLDownloadToCacheFileW
#else
#define URLDownloadToCacheFile  URLDownloadToCacheFileA
#endif // !UNICODE

STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenBlockingStream  URLOpenBlockingStreamW
#else
#define URLOpenBlockingStream  URLOpenBlockingStreamA
#endif // !UNICODE

#define UOSM_PUSH  0
#define UOSM_PULL  1
#define UOSM_BLOCK 2
#define UOSM_FILE  3

#define UOS_URLENCODEPOSTDATA BINDINFOF_URLENCODESTGMEDDATA
#define UOS_URLENCODEURL      BINDINFOF_URLENCODEDEXTRAINFO

typedef struct _UOSHTTPINFOA
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCSTR  	szURL;
	LPCSTR  	szVerb;
	LPCSTR  	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCSTR  	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOA, * LPUOSHTTPINFOA; 
typedef struct _UOSHTTPINFOW
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCWSTR 	szURL;
	LPCWSTR 	szVerb;
	LPCWSTR 	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCWSTR 	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOW, * LPUOSHTTPINFOW; 
#ifdef UNICODE
typedef UOSHTTPINFOW UOSHTTPINFO;
typedef LPUOSHTTPINFOW LPUOSHTTPINFO;
#else
typedef UOSHTTPINFOA UOSHTTPINFO;
typedef LPUOSHTTPINFOA LPUOSHTTPINFO;
#endif // UNICODE

STDAPI URLOpenHttpStreamA(LPUOSHTTPINFOA);
STDAPI URLOpenHttpStreamW(LPUOSHTTPINFOW);
#ifdef UNICODE
#define URLOpenHttpStream  URLOpenHttpStreamW
#else
#define URLOpenHttpStream  URLOpenHttpStreamA
#endif // !UNICODE

struct IBindStatusCallback;

STDAPI HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkGoBack(IUnknown *pUnk);
STDAPI HlinkGoForward(IUnknown *pUnk);
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\basecom.cxx ===
//+----------------------------------------------------------------------------
//  File:       basecom.cxx
//
//  Synopsis:   This file contains implementations of the root COM objects
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


//+----------------------------------------------------------------------------
//  Function:   SRelease, SClear
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
SRelease(
    IUnknown *  pUnk)
{
    if (pUnk)
    {
        pUnk->Release();
    }
}


void
SClear(
    IUnknown ** ppUnk)
{
    Assert(ppUnk);

    if (*ppUnk)
    {
        (*ppUnk)->Release();
        *ppUnk = NULL;
    }
}


//+----------------------------------------------------------------------------
//  Function:   PublicQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CComponent::PublicQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    return _pUnkOuter->QueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   PublicAddRef
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::PublicAddRef()
{
    return _pUnkOuter->AddRef();
}


//+----------------------------------------------------------------------------
//  Function:   PublicRelease
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::PublicRelease()
{
    return _pUnkOuter->Release();
}


//+----------------------------------------------------------------------------
//  Function:   PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CComponent::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (void *)(IUnknown *)&_Unk;
        return S_OK;
    }
    return E_NOINTERFACE;
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::QueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CComponent::CUnknown::QueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    hr = OWNING_CLASS(CComponent, _Unk)->PrivateQueryInterface(riid, ppvObj);

    if (!hr)
    {
        Assert(*ppvObj);
        ((IUnknown *)*ppvObj)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::AddRef
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::CUnknown::AddRef()
{
    return ++(OWNING_CLASS(CComponent, _Unk)->_cRefs);
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::Release
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::CUnknown::Release()
{
    CComponent *    pComp = OWNING_CLASS(CComponent, _Unk);

    Assert(OWNING_CLASS(CComponent, _Unk)->_cRefs);

    if (!--pComp->_cRefs)
    {
        pComp->_cRefs += REF_GUARD;
        delete pComp;
        return 0;
    }
    return pComp->_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\dll.cxx ===
//+----------------------------------------------------------------------------
//  File:       dll.cxx
//
//  Synopsis:   This file contains the core routines and globals for creating
//              DLLs
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Globals --------------------------------------------------------------------
static THREADSTATE *    g_pts = NULL;
HANDLE                  g_hinst = NULL;
HANDLE                  g_heap = NULL;
DWORD                   g_tlsThreadState = NULL_TLS;
LONG                    g_cUsage = 0;
GINFO                   g_ginfo = { 0 };

DECLARE_LOCK(DLL);


// Prototypes -----------------------------------------------------------------
class CClassFactory : public CComponent,
                      public IClassFactory2
{
    typedef CComponent parent;

public:
    CClassFactory(CLASSFACTORY * pcf);

    // IUnknown methods
    DEFINE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid, void ** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
	STDMETHOD(GetLicInfo)(LICINFO * pLicInfo);
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR * pbstrKey);
	STDMETHOD(CreateInstanceLic)(IUnknown * pUnkOuter,
	                             IUnknown * pUnkReserved,
	                             REFIID riid, BSTR bstrKey,
	                             void ** ppvObj);

private:
    CLASSFACTORY *  _pcf;

    HRESULT PrivateQueryInterface(REFIID riid, void ** ppvObj);
};

static HRESULT DllProcessAttach();
static void    DllProcessDetach();
static HRESULT DllThreadAttach();
static void    DllThreadDetach(THREADSTATE * pts);

static void    DllProcessPassivate();
static void    DllThreadPassivate();


//+----------------------------------------------------------------------------
//  Function:   DllMain
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" BOOL WINAPI
DllMain(
    HINSTANCE   hinst,
    DWORD       nReason,
    void *      )           // pvReserved - Unused
{
    HRESULT hr = S_OK;

    g_hinst = hinst;

    switch (nReason)
    {
    case DLL_PROCESS_ATTACH:
        hr = DllProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        {
            THREADSTATE *   pts = (THREADSTATE *)TlsGetValue(g_tlsThreadState);
            DllThreadDetach(pts);
        }
        break;
    }

    return !hr;
}


//+----------------------------------------------------------------------------
//  Function:   DllGetClassObject
//
//  Synopsis:
//
//  NOTE: This code limits class objects to supporting IUnknown and IClassFactory
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    void **     ppv)
{
    CLASSFACTORY *  pcf;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        return hr;

    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid != IID_IClassFactory &&
        riid != IID_IClassFactory2)
        return E_NOINTERFACE;

    for (pcf=g_acf; pcf->pclsid; pcf++)
    {
        if (*(pcf->pclsid) == rclsid)
            break;
    }
    if (!pcf)
        return CLASS_E_CLASSNOTAVAILABLE;

    if (riid == IID_IClassFactory2 && !pcf->pfnLicense)
        return E_NOINTERFACE;

    CClassFactory * pCF = new CClassFactory(pcf);
    if (!pCF)
        return E_OUTOFMEMORY;

    *ppv = (void *)(IClassFactory2 *)pCF;
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
    return ((g_cUsage==0)
                ? S_OK
                : S_FALSE);
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessAttach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
DllProcessAttach()
{
    PFN_PATTACH *   ppfnPAttach;
    HRESULT         hr = S_OK;

    g_tlsThreadState = TlsAlloc();
    if (g_tlsThreadState == NULL_TLS)
    {
        return GetWin32Hresult();
    }

    INIT_LOCK(DLL);

    g_heap = GetProcessHeap();

    for (ppfnPAttach=g_apfnPAttach; *ppfnPAttach; ppfnPAttach++)
    {
        hr = (**ppfnPAttach)();
        if (hr)
            goto Error;
    }

Cleanup:
    return hr;

Error:
    DllProcessDetach();
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessDetach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllProcessDetach()
{
    THREADSTATE *   pts;
    PFN_PDETACH *   ppfnPDetach;

    Implies(g_pts, g_tlsThreadState != NULL_TLS);

    while (g_pts)
    {
        pts = g_pts;
        Verify(TlsSetValue(g_tlsThreadState, pts));
        DllThreadDetach(pts);

        Assert(!TlsGetValue(g_tlsThreadState));
        Assert(g_pts != pts);
    }

    for (ppfnPDetach=g_apfnPDetach; *ppfnPDetach; ppfnPDetach++)
        (**ppfnPDetach)();

    DEINIT_LOCK(DLL);

    if (g_tlsThreadState != NULL_TLS)
    {
        TlsFree(g_tlsThreadState);
    }
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadAttach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
DllThreadAttach()
{
    THREADSTATE *   pts;
    PFN_TATTACH *   ppfnTAttach;
    HRESULT         hr;

    LOCK(DLL);

    Assert(g_tlsThreadState != NULL_TLS);
    Assert(!::TlsGetValue(g_tlsThreadState));
    hr = AllocateThreadState(&pts);
    if (hr)
        goto Error;

    Assert(pts);
    pts->dll.idThread = GetCurrentThreadId();
    Verify(TlsSetValue(g_tlsThreadState, pts));

    Verify(SUCCEEDED(::CoGetMalloc(1, &pts->dll.pmalloc)));

    for (ppfnTAttach=g_apfnTAttach; *ppfnTAttach; ppfnTAttach++)
    {
        hr = (**ppfnTAttach)(pts);
        if (hr)
            goto Error;
    }

    pts->ptsNext = g_pts;
    g_pts = pts;

Cleanup:
    return hr;

Error:
    DllThreadDetach(pts);
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadDetach
//
//  Synopsis:
//
//  NOTE: Under Win95, DllThreadDetach may be called to clear memory on a
//        thread which did not allocate the memory.
//
//-----------------------------------------------------------------------------
void
DllThreadDetach(
    THREADSTATE * pts)
{
    THREADSTATE **  ppts;
    PFN_TDETACH *   ppfnTDetach;

    LOCK(DLL);

    if (!pts)
        return;

    Assert(!pts->dll.cUsage);
    Assert(pts == (THREADSTATE *)TlsGetValue(g_tlsThreadState));

    for (ppfnTDetach=g_apfnTDetach; *ppfnTDetach; ppfnTDetach++)
        (**ppfnTDetach)(pts);

    ::SRelease(pts->dll.pmalloc);

    ::TlsSetValue(g_tlsThreadState, NULL);

    for (ppts=&g_pts; *ppts && *ppts != pts; ppts=&((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;
    }
    delete pts;
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessPassivate
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllProcessPassivate()
{
    PFN_PPASSIVATE *    ppfnPPassivate;

    LOCK(DLL);

    Assert(!g_cUsage);

    // BUGBUG: What are the respective roles of process/thread passivation?
    // BUGBUG: This is an unsafe add into g_cUsage...fix this!
    g_cUsage += REF_GUARD;
    for (ppfnPPassivate=g_apfnPPassivate; *ppfnPPassivate; ppfnPPassivate++)
        (**ppfnPPassivate)();
    g_cUsage -= REF_GUARD;
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadPassivate
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllThreadPassivate()
{
    THREADSTATE *       pts = GetThreadState();
    PFN_TPASSIVATE *    ppfnTPassivate;

    Assert(!pts->dll.cUsage);
    pts->dll.cUsage += REF_GUARD;
    for (ppfnTPassivate=g_apfnTPassivate; *ppfnTPassivate; ppfnTPassivate++)
        (**ppfnTPassivate)(pts);
    pts->dll.cUsage -= REF_GUARD;
}


//+----------------------------------------------------------------------------
//  Function:   CClassFactory
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
CClassFactory::CClassFactory(
    CLASSFACTORY *  pcf)
    : CComponent(NULL)
{
    Assert(pcf);
    Assert(pcf->pfnFactory);
    _pcf = pcf;
}


//+----------------------------------------------------------------------------
//  Function:   CreateInstance
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    void **     ppvObj)
{
    if (!ppvObj)
        return E_INVALIDARG;
    *ppvObj = NULL;

    // BUGBUG: What error should be returned?
    if (pUnkOuter && riid != IID_IUnknown)
        return E_INVALIDARG;

    // BUGBUG: Should the factory just create the object and let this
    //         code perform the appropriate QI?
    // BUGBUG: This code should automatically handle aggregation
    Assert(_pcf);
    Assert(_pcf->pfnFactory);
    return _pcf->pfnFactory(pUnkOuter, riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   LockServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::LockServer(
    BOOL    fLock)
{
    if (fLock)
    {
        AddRef();
        IncrementThreadUsage();
    }
    else
    {
        DecrementThreadUsage();
        Release();
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   GetLicInfo
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::GetLicInfo(
    LICINFO *   pLicInfo)

{
    Assert(_pcf->pfnLicense);
    return _pcf->pfnLicense(LICREQUEST_INFO, pLicInfo);
}


//+----------------------------------------------------------------------------
//  Function:   RequestLicKey
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::RequestLicKey(
    DWORD   ,   // dwReserved
    BSTR *  pbstrKey)
{
    Assert(_pcf->pfnLicense);
    return _pcf->pfnLicense(LICREQUEST_OBTAIN, pbstrKey);
}


//+----------------------------------------------------------------------------
//  Function:   CreateInstanceLic
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstanceLic(
    IUnknown *  pUnkOuter,
    IUnknown *  ,           // pUnkReserved
    REFIID      riid,
    BSTR        bstrKey,
    void **     ppvObj)
{
    Assert(_pcf->pfnLicense);

    if (!ppvObj)
        return E_INVALIDARG;
    *ppvObj = NULL;

    if (_pcf->pfnLicense(LICREQUEST_VALIDATE, bstrKey) != S_OK)
    {
        return CLASS_E_NOTLICENSED;
    }

    return CreateInstance(pUnkOuter, riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CClassFactory::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IClassFactory)
    {
        *ppvObj = (void *)(IClassFactory *)this;
    }
    else if (riid == IID_IClassFactory2)
    {
        if (_pcf->pfnLicense)
        {
            *ppvObj = (void *)(IClassFactory2 *)this;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        return parent::PrivateQueryInterface(riid, ppvObj);
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   GetWin32Hresult
//
//  Synopsis:   Return an HRESULT derived from the current Win32 error
//
//-----------------------------------------------------------------------------
HRESULT
GetWin32Hresult()
{
    return HRESULT_FROM_WIN32(GetLastError());
}


//+----------------------------------------------------------------------------
//  Function:   EnsureThreadState
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
EnsureThreadState()
{
    extern DWORD g_tlsThreadState;
    Assert(g_tlsThreadState != NULL_TLS);
    if (!TlsGetValue(g_tlsThreadState))
        return DllThreadAttach();
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   IncrementProcessUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
IncrementProcessUsage()
{
#ifdef _DEBUG
    Verify(InterlockedIncrement(&g_cUsage) > 0);
#else
    InterlockedIncrement(&g_cUsage);
#endif
}


//+----------------------------------------------------------------------------
//  Function:   DecrementProcessUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DecrementProcessUsage()
{
#if DBG==1
    if( 0 == g_cUsage )
    {
        DebugBreak();   // ref counting problem
    }
#endif
    if (!InterlockedDecrement(&g_cUsage))
    {
        DllProcessPassivate();
    }
}



//+----------------------------------------------------------------------------
//  Function:   IncrementThreadUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
IncrementThreadUsage()
{
#ifdef _DEBUG
    Verify(++TLS(dll.cUsage) > 0);
#else
    ++TLS(dll.cUsage);
#endif
    IncrementProcessUsage();
}


//+----------------------------------------------------------------------------
//  Function:   DecrementThreadUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DecrementThreadUsage()
{
    THREADSTATE *   pts = GetThreadState();
    if(pts)
    {
        pts->dll.cUsage--;
        Assert(pts->dll.cUsage >= 0);
        if (!pts->dll.cUsage)
        {
            DllThreadPassivate();
        }
    }
    DecrementProcessUsage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\inc\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"


//=--------------------------------------------------------------------------=
// Misc Helper Routines
//=--------------------------------------------------------------------------=
//
HWND      GetParkingWindow(void);
HINSTANCE GetResourceHandle(void);

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
BOOL UnregisterUnknownObject(REFCLSID riidObject);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject
BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);


//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


#define _UTIL_H_
#endif // _UTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\dllreg.cxx ===
//+----------------------------------------------------------------------------
//  File:       dllreg.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Prototypes -----------------------------------------------------------------
static const TCHAR * DeleteSubkeys(HKEY hkeyParent, const TCHAR * pszKey);
static const TCHAR * RegisterKey(HKEY hkeyParent, const TCHAR * pszKey);


//+----------------------------------------------------------------------------
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer()
{
    const TCHAR **  ppszKey;
    const TCHAR *   pszKey;
    HKEY            hkey;
    LONG            lError;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        goto Cleanup;

    for (ppszKey=g_aszKeys; *ppszKey; ppszKey++)
    {
        pszKey = *ppszKey;

        lError = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                pszKey, 0, KEY_ALL_ACCESS,
                                &hkey);
        if (lError != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            break;
        }

        pszKey += _tcslen(pszKey) + 1;
        Assert(*pszKey);

        if (!RegisterKey(hkey, pszKey))
        {
            hr = E_FAIL;
            break;
        }

#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllUnregisterServer()
{
    const TCHAR **  ppszKey;
    const TCHAR *   pszKey;
    HKEY            hkey;
    LONG            lError;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        goto Cleanup;

    for (ppszKey=g_aszKeys; *ppszKey; ppszKey++)
    {
        pszKey = *ppszKey;

        lError = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                pszKey, 0, KEY_ALL_ACCESS,
                                &hkey);
        if (lError != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            break;
        }

        pszKey += _tcslen(pszKey) + 1;
        Assert(*pszKey);

        if (!DeleteSubkeys(hkey, pszKey) ||
            ::RegDeleteKey(hkey, pszKey) != ERROR_SUCCESS)
        {
            hr = E_FAIL;
        }
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DeleteSubkeys
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
const TCHAR *
DeleteSubkeys(
    HKEY            hkeyParent,
    const TCHAR *   pszKey)
{
    const TCHAR *   psz;
    HKEY            hkey = NULL;
    LONG            lError;

    lError = ::RegOpenKeyEx(hkeyParent, pszKey, 0, KEY_ALL_ACCESS, &hkey);
    if (lError != ERROR_SUCCESS)
        goto Error;

    pszKey += _tcslen(pszKey) + 1;

    while (*pszKey)
    {
        switch (*pszKey)
        {
        case chDEFAULT_SECTION:
            pszKey++;
            pszKey += _tcslen(pszKey) + 1;
            break;

        case chVALUES_SECTION:
            pszKey++;
            while (*pszKey)
            {
                pszKey += _tcslen(pszKey) + 1;
                pszKey += _tcslen(pszKey) + 1;
            }
            pszKey++;
            break;

        case chSUBKEY_SECTION:
            pszKey++;
            psz = pszKey;
            pszKey = DeleteSubkeys(hkey, pszKey);
            if (!pszKey)
                goto Error;
            lError = ::RegDeleteKey(hkey, psz);
            if (lError != ERROR_SUCCESS)
                goto Error;
            break;

#ifdef _DEBUG
        default:
            AssertF("Invalid section in registry key data");
#endif
        }
    }

    pszKey++;

Cleanup:
    if (hkey)
    {
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }
    return pszKey;

Error:
    pszKey = NULL;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   RegisterKey
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
const TCHAR *
RegisterKey(
    HKEY            hkeyParent,
    const TCHAR *   pszKey)
{
    const TCHAR *   psz;
    HKEY            hkey = NULL;
    DWORD           dwDisposition;
    LONG            lError;

    lError = ::RegCreateKeyEx(hkeyParent, pszKey, 0, _T(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL,
                            &hkey, &dwDisposition);
    if (lError != ERROR_SUCCESS)
        goto Error;

    pszKey += _tcslen(pszKey) + 1;

    while (*pszKey)
    {
        switch (*pszKey)
        {
        case chDEFAULT_SECTION:
            pszKey++;
            if (!::lstrcmpi(pszKey, szMODULE_PATH))
            {
                TCHAR   szModule[MAX_PATH+1];

                Verify(::GetModuleFileName((HMODULE)g_hinst, szModule, ARRAY_SIZE(szModule)));
                lError = ::RegSetValueEx(hkey, NULL, 0,
                                        REG_SZ,
                                        (const BYTE *)szModule,
                                        sizeof(TCHAR) * (_tcslen(szModule) + 1));
            }
            else
            {
                lError = ::RegSetValueEx(hkey, NULL, 0,
                                        REG_SZ,
                                        (const BYTE *)pszKey,
                                        sizeof(TCHAR) * (_tcslen(pszKey) + 1));
            }
            if (lError != ERROR_SUCCESS)
                goto Error;
            pszKey += _tcslen(pszKey) + 1;
            break;

        case chVALUES_SECTION:
            pszKey++;
            while (*pszKey)
            {
                psz = pszKey;
                pszKey += _tcslen(pszKey) + 1;

                lError = ::RegSetValueEx(hkey, psz, 0,
                                        REG_SZ,
                                        (const BYTE *)pszKey,
                                        sizeof(TCHAR) * (_tcslen(pszKey) + 1));
                if (lError != ERROR_SUCCESS)
                    goto Error;

                pszKey += _tcslen(pszKey) + 1;
            }
            pszKey++;
            break;

        case chSUBKEY_SECTION:
            pszKey++;
            pszKey = RegisterKey(hkey, pszKey);
            if (!pszKey)
                goto Error;
            break;

#ifdef _DEBUG
        default:
            AssertF("Invalid section in registry key data");
#endif
        }
    }

    pszKey++;

Cleanup:
    if (hkey)
    {
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }
    return pszKey;

Error:
    pszKey = NULL;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\mime64.cxx ===
//+----------------------------------------------------------------------------
//  File:       mime64.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Constants ------------------------------------------------------------------
const LARGE_INTEGER LIB_ZERO = { 0, 0 };
const ULONG BUFFER_SIZE      = 256;
const UCHAR INVALID_CHAR     = (UCHAR)-2;
const UCHAR IGNORE_CHAR      = (UCHAR)-1;
const UCHAR CH_TERMINATION   = '=';
const char  achAlpha[]       = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                               "abcdefghijklmnopqrstuvwxyz"
                               "0123456789+/";


// Globals --------------------------------------------------------------------
UCHAR   g_anBinary[256];


// Prototypes -----------------------------------------------------------------
inline ULONG BinaryFromASCII(UCHAR ch)  { return g_anBinary[ch]; }


//+----------------------------------------------------------------------------
//  Function:   ProcessAttachMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
ProcessAttachMIME64()
{
    UCHAR   ubin;
    UCHAR   ch;
    int     i;

    // BUGBUG: Hard code this table
    for (i=0; i < ARRAY_SIZE(g_anBinary); i++)
    {
        ch = (UCHAR)i;

        switch (ch)
        {
            case ' ' :
            case '\t':
            case '\n':
            case '\r':
                ubin = IGNORE_CHAR;
                break;

            default:
                if ((ch >= 'A') && (ch <= 'Z'))
                    ubin = (UCHAR)(ch - 'A');
                else if ((ch >= 'a') && (ch <= 'z'))
                    ubin = (UCHAR)(26 + (ch - 'a'));
                else if ((ch >= '0') && (ch <= '9'))
                    ubin = (UCHAR)(52 + (ch - '0'));
                else
                    ubin = INVALID_CHAR;
                break;

            case '+':
                ubin = 62;
                break;

            case '/':
                ubin = 63;
                break;
        }

        g_anBinary[i] = ubin;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   EncodeMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
EncodeMIME64(
    BYTE *      pbSrc,
    UINT        cbSrc,
    IStream *   pstmDest,
    ULONG *     pcbWritten)
{
    UCHAR   achOut[(2 * sizeof(UCHAR)) + CB_NEWLINE];
    ULONG   ichOut = 0;
    ULONG   cbWritten;
    ULONG   cbTotalWritten;
    ULONG   bAccum = 0;
    ULONG   cShift = 0;
    HRESULT hr = S_OK;

    Assert(pbSrc);
    Assert(pstmDest);

    if (!pcbWritten)
    {
        pcbWritten = &cbTotalWritten;
    }

    // Convert the source string, 6-bits at a time, to ASCII characters
    while (cbSrc)
    {
        bAccum <<= 8;
        cShift += 8;
        bAccum |= *pbSrc++;
        cbSrc--;

        while (cShift >= 6)
        {
            cShift -= 6;
            hr = pstmDest->Write(&achAlpha[(bAccum >> cShift) & 0x3FL], 1, &cbWritten);
            *pcbWritten += cbWritten;
            if (hr)
                goto Cleanup;
        }
    }

    // If there are bits not yet written, pad with zeros and write the resulting character
    if (cShift)
    {
        bAccum <<= 6 - cShift;
        achOut[ichOut++] = achAlpha[(bAccum >> cShift) & 0x3FL];
    }

    // Add a termination character and newline
    achOut[ichOut++] = CH_TERMINATION;
    ::memcpy(achOut+ichOut, SZ_NEWLINE, CB_NEWLINE);
    ichOut += CB_NEWLINE;

    hr = pstmDest->Write(achOut, ichOut, &cbWritten);
    *pcbWritten += cbWritten;
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DecodeMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
DecodeMIME64(
    IStream *   pstmSrc,
    IStream *   pstmDest,
    ULONG *     pcbWritten)
{
    UCHAR   ch;
    UCHAR   achOut[BUFFER_SIZE];
    ULONG   ichOut = 0;
    ULONG   cbRead;
    ULONG   cbWritten;
    ULONG   cbTotalWritten = 0;
    ULONG   bAccum = 0;
    ULONG   cShift = 0;
    ULONG   bValue;
    HRESULT hr;

    if (!pcbWritten)
    {
        pcbWritten = &cbTotalWritten;
    }

    // As long as characters remain, convert them to binary
    // (This loop skips "whitespace" and stops when it encounters an out-of-range value)
    for (;;)
    {
        hr = pstmSrc->Read(&ch, sizeof(ch), &cbRead);
        if (hr)
            goto Cleanup;

        // Stop when no more characters remain
        if (!cbRead)
            break;

        bValue = BinaryFromASCII(ch);

        // Convert known characters back to binary
        if (bValue < 64)
        {
            bAccum <<= 6;
            cShift += 6;
            bAccum |= bValue;

            if (cShift >= 8)
            {
                cShift -= 8;
                achOut[ichOut++] = (UCHAR)((bAccum >> cShift) & 0xFF);

                if (ichOut >= ARRAY_SIZE(achOut))
                {
                    hr = pstmDest->Write(achOut, ichOut, &cbWritten);
                    *pcbWritten += cbWritten;
                    if (hr)
                        goto Cleanup;
                    ichOut = 0;
                }
            }
        }

        // Skip "whitespace"
        else if (bValue == IGNORE_CHAR)
            ;

        // Stop if anything else is encountered
        else
            break;
    }

    // If characters remain to be written, write them now
    if (ichOut)
    {
        hr = pstmDest->Write(achOut, ichOut, &cbWritten);
        *pcbWritten += cbWritten;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\mgrpch.cxx ===
//+----------------------------------------------------------------------------
//  File:       mgrpch.hxx  
//
//  Synopsis:   Pre-compiled header
//
//-----------------------------------------------------------------------------

// Includes -------------------------------------------------------------------
#define	DLL_EXPORT
#include <mgr.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\array.cxx ===
//+----------------------------------------------------------------------------
//  File:       array.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>


//+----------------------------------------------------------------------------
//
//  Member:     AddClass
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::AddClass(
    REFCLSID    rclsid,
    int *       piLic)
{
    IClassFactory2 *    pcf2 = NULL;
    LICINFO             licinfo;
    BSTR                bstrLic;
    int                 iLic;
    HRESULT             hr;

    Assert(piLic);
    Assert(!FindClass(rclsid, &iLic));

    // Get the class factory for the CLSID
    hr = ::CoGetClassObject(rclsid,
                            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                            NULL,
                            IID_IClassFactory2, (void **)&pcf2);
    if (hr)
        goto Cleanup;
    Assert(pcf2);

    // Determine if the object supports the creation of runtime licenses
    licinfo.cbLicInfo = sizeof(LICINFO);
    hr = pcf2->GetLicInfo(&licinfo);
    if (hr)
        goto Cleanup;

    if (!licinfo.fRuntimeKeyAvail ||
        !licinfo.fLicVerified)
    {
        hr = CLASS_E_NOTLICENSED;
        goto Cleanup;
    }

    // Obtain the object's runtime license
    hr = pcf2->RequestLicKey(0, &bstrLic);
    if (hr)
        goto Cleanup;
    Assert(bstrLic);

    // Add the object and its runtime license to the array of CLSID-License pairs
    // (The class is added in ascending order based upon the first DWORD of the CLSID)
    hr = _aryLic.SetSize(_aryLic.Size()+1);
    if (hr)
        goto Cleanup;

    for (iLic = 0; iLic < (_aryLic.Size()-1); iLic++)
    {
        if (rclsid.Data1 < _aryLic[iLic].clsid.Data1)
            break;
    }

    if (iLic < (_aryLic.Size()-1))
    {
        ::memmove(&_aryLic[iLic+1], &_aryLic[iLic], sizeof(_aryLic[0])*(_aryLic.Size()-iLic-1));
    }

    _aryLic[iLic].clsid = rclsid;
    _aryLic[iLic].bstrLic = bstrLic;
    _aryLic[iLic].pcf2 = pcf2;
    pcf2 = NULL;
    *piLic = iLic;
    _fDirty = TRUE;

Cleanup:
    ::SRelease(pcf2);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     FindClass
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
BOOL
CLicenseManager::FindClass(
    REFCLSID    rclsid,
    int *       piLic)
{
    int iLic;

    Assert(piLic);

    // BUGBUG: Consider using a more efficient search if the number of classes is large
    for (iLic=0; iLic < _aryLic.Size(); iLic++)
    {
        if (_aryLic[iLic].clsid.Data1 == rclsid.Data1 &&
            _aryLic[iLic].clsid == rclsid)
            break;
    }

    if (iLic < _aryLic.Size())
    {
        *piLic = iLic;
    }
    return (iLic < _aryLic.Size());
}


//+----------------------------------------------------------------------------
//
//  Member:     OnChangeInRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::OnChangeInRequiredClasses(
    IRequireClasses *   pRequireClasses)
{
    ULONG   cClasses;
    ULONG   iClass;
    int     cLic;
    int     iLic;
    CLSID   clsid;
    BOOL    fClassUsed;
    BOOL    fClassNotLicensed = FALSE;
    HRESULT hr;

    if (!pRequireClasses)
        return E_INVALIDARG;

    // Determine the number of required classes
    hr = pRequireClasses->CountRequiredClasses(&cClasses);
    if (hr)
        goto Cleanup;

    // Add new classes to the array of required classes
    // NOTE: During this pass, all required classes are also marked as "in use"
    //       Because of this, the second loop must also alway run, even when errors occur,
    //       to remove these marks; that is, this loop cannot "goto Cleanup"
    for (iClass = 0; iClass < cClasses; iClass++)
    {
        // Get the CLSID of the required class
        hr = pRequireClasses->GetRequiredClasses(iClass, &clsid);
        if (hr)
            break;

        // Check if the class is already known; if not, add it
        // (Ignore "false" errors which occur during adding the class and treat it as unlicensed)
        fClassUsed = TRUE;                      // Assume the class will be used
        if (!FindClass(clsid, &iLic))
        {
            hr = AddClass(clsid, &iLic);
            if (hr)
            {
                if (hr == E_OUTOFMEMORY)
                    break;
                fClassUsed = FALSE;             // Class was not found nor added
                fClassNotLicensed = TRUE;
                hr = S_OK;
            }
        }

        // Mark the class as "in use" by setting the high-order bit of the factory address
        if (fClassUsed)
        {
            Assert((ULONG)(_aryLic[iLic].pcf2) < (ULONG_PTR)ADDRESS_TAG_BIT);
            _aryLic[iLic].pcf2 = (IClassFactory2 *)((ULONG_PTR)(_aryLic[iLic].pcf2) | ADDRESS_TAG_BIT);
        }
    }

    // Remove from the array classes no longer required
    // NOTE: If hr is not S_OK, then this loop should still execute, but only to clear
    //       the mark bits on the IClassFactory2 interface pointers, no other changes
    //       should occur
    //       Also, early exits from this loop (using "break" for example) must not occur
    for (cLic = iLic = 0; iLic < _aryLic.Size(); iLic++)
    {
        // If the class is "in use", clear the mark bit
        if ((ULONG_PTR)(_aryLic[iLic].pcf2) & ADDRESS_TAG_BIT)
        {
            _aryLic[iLic].pcf2 = (IClassFactory2 *)((ULONG_PTR)(_aryLic[iLic].pcf2) & (ADDRESS_TAG_BIT-1));

            // If classes have been removed, shift this class down to the first open slot
            if (!hr && iLic > cLic)
            {
                _aryLic[cLic] = _aryLic[iLic];
                ::memset(&(_aryLic[iLic]), 0, sizeof(_aryLic[iLic]));
            }
        }

        // Otherwise, free the class and remove it from the array
        else if (!hr)
        {
            ::SysFreeString(_aryLic[iLic].bstrLic);
            ::SRelease(_aryLic[iLic].pcf2);
            ::memset(&(_aryLic[iLic]), 0, sizeof(_aryLic[iLic]));
            _fDirty = TRUE;
        }

        // As long as it points at a valid class, increment the class counter
        if (_aryLic[cLic].clsid != CLSID_NULL)
        {
            cLic++;
        }
    }
    Implies(hr, cLic == _aryLic.Size());
    Implies(!hr, (ULONG)cLic <= cClasses);
    Verify(SUCCEEDED(_aryLic.SetSize(cLic)));

Cleanup:
    // If a real error occurred, return it
    // Otherwise return CLASS_E_NOTLICENSED if any un-licensed objects were encountered
    return (hr
                ? hr
                : (fClassNotLicensed
                        ? CLASS_E_NOTLICENSED
                        : S_OK));
}


//+----------------------------------------------------------------------------
//
//  Member:     CreateInstance
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::CreateInstance(
    CLSID       clsid,
    IUnknown *  pUnkOuter,
    REFIID      riid,
    DWORD       dwClsCtx,
    void **     ppvObj)
{
    int     iLic;
    HRESULT hr;

    // If there is a runtime license for the class, create it using IClassFactory2
    if (FindClass(clsid, &iLic))
    {
        if (!_aryLic[iLic].pcf2)
        {
            //
            // The following code calls CoGetClassObject for an IClassFactory
            // then QIs for an IClassFactory2. This is because of an apparent
            // bug in ole32.dll.  On a win95 system if the call to
            // CoGetClassObject is remoted and you ask for IClassFactory2 the
            // process hangs.
            //

		    IClassFactory *pIClassFactory;

            hr = ::CoGetClassObject(clsid, dwClsCtx, NULL,
                                    IID_IClassFactory, (void **)&(pIClassFactory));

            if (SUCCEEDED(hr)) {

                hr = pIClassFactory->QueryInterface(IID_IClassFactory2,
                                                    (void **)&(_aryLic[iLic].pcf2));

                pIClassFactory->Release();
            }

            if (hr)			
                goto Cleanup;

        }

        Assert(_aryLic[iLic].pcf2);
        Assert(_aryLic[iLic].bstrLic != NULL);
        hr = _aryLic[iLic].pcf2->CreateInstanceLic(pUnkOuter, NULL,
                                                   riid, _aryLic[iLic].bstrLic, ppvObj);
    }

    // Otherwise, use the standard COM mechanisms
    else
    {
        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsCtx, riid, ppvObj);
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetTypeLibOfClsid
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetTypeLibOfClsid(
    CLSID       clsid,
    ITypeLib ** ptlib)
{
    UNREF(clsid);
    UNREF(ptlib);
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClassObjectOfClsid
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClassObjectOfClsid(
    REFCLSID    rclsid,
    DWORD       dwClsCtx,
    LPVOID      lpReserved,
    REFIID      riid,
    void **     ppcClassObject)
{
    // Load the class object
    return ::CoGetClassObject(rclsid, dwClsCtx, lpReserved, riid, ppcClassObject);
}


//+----------------------------------------------------------------------------
//
//  Member:     CountRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::CountRequiredClasses(
    ULONG * pcClasses)
{
    if (!pcClasses)
        return E_INVALIDARG;

    // Return the current number of classes
    *pcClasses = _aryLic.Size();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetRequiredClasses(
    ULONG   iClass,
    CLSID * pclsid)
{
    if (!pclsid || iClass >= (ULONG)_aryLic.Size())
        return E_INVALIDARG;

    // Return the requested CLSID
    *pclsid = _aryLic[iClass].clsid;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\version.h ===
#define rmj 1
#define rmm 0
#define rup 0
#define szVerName "licmgr"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\main.cxx ===
//+----------------------------------------------------------------------------
//  File:       main.cxx
//
//  Synopsis:   This file contains the core routines and globals for creating
//              LICMGR.DLL
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>


// Globals --------------------------------------------------------------------
BEGIN_PROCESS_ATTACH
    ATTACH_METHOD(ProcessAttachMIME64)
END_PROCESS_ATTACH

BEGIN_PROCESS_DETACH
END_PROCESS_DETACH

BEGIN_THREAD_ATTACH
END_THREAD_ATTACH

BEGIN_THREAD_DETACH
END_THREAD_DETACH

BEGIN_PROCESS_PASSIVATE
END_PROCESS_PASSIVATE

BEGIN_THREAD_PASSIVATE
END_THREAD_PASSIVATE

BEGIN_CLASS_FACTORIES
    FACTORY(CLSID_LicenseManager, LicenseManagerFactory, NULL)
END_CLASS_FACTORIES

DEFINE_REGISTRY_SECKEY(LicenseManagerCLSID, CLSID, {5220cb21-c88d-11cf-b347-00aa00a28331})
    DEFAULT_VALUE(Microsoft Licensed Class Manager 1.0)
    BEGIN_SUBKEY(Implemented Categories)
        BEGIN_SUBKEY({7DD95801-9882-11CF-9FA9-00AA006C42C4})
        END_SUBKEY
        BEGIN_SUBKEY({7DD95802-9882-11CF-9FA9-00AA006C42C4})
        END_SUBKEY
    END_SUBKEY
    BEGIN_SUBKEY(InprocServer32)
        DEFAULT_VALUE(<m>)
        BEGIN_NAMED_VALUES
            NAMED_VALUE(ThreadingModel, Apartment)
        END_NAMED_VALUES
    END_SUBKEY
    BEGIN_SUBKEY(MiscStatus)
        DEFAULT_VALUE(0)
    END_SUBKEY
    BEGIN_SUBKEY(ProgID)
        DEFAULT_VALUE(License.Manager.1)
    END_SUBKEY
    BEGIN_SUBKEY(Version)
        DEFAULT_VALUE(1.0)
    END_SUBKEY
    BEGIN_SUBKEY(VersionIndependentProgID)
        DEFAULT_VALUE(License.Manager)
    END_SUBKEY
END_REGISTRY_KEY

DEFINE_REGISTRY_KEY(LicenseManagerProgID, License.Manager.1)
    DEFAULT_VALUE(Microsoft Licensed Class Manager 1.0)
    BEGIN_SUBKEY(CLSID)
        DEFAULT_VALUE({5220cb21-c88d-11cf-b347-00aa00a28331})
    END_SUBKEY
END_REGISTRY_KEY

DEFINE_REGISTRY_KEY(LicenseManagerVProgID, License.Manager)
    DEFAULT_VALUE(Microsoft Licensed Class Manager)
    BEGIN_SUBKEY(CurVer)
        DEFAULT_VALUE(License.Manager.1)
    END_SUBKEY
END_REGISTRY_KEY

BEGIN_REGISTRY_KEYS
    REGISTRY_KEY(LicenseManagerCLSID)
    REGISTRY_KEY(LicenseManagerProgID)
    REGISTRY_KEY(LicenseManagerVProgID)
END_REGISTRY_KEYS


//+----------------------------------------------------------------------------
//  Function:   AllocateThreadState
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
AllocateThreadState(
    THREADSTATE **  ppts)
{
    Assert(ppts);

    *ppts = new THREADSTATE;
    if (!*ppts)
    {
        return E_OUTOFMEMORY;
    }

    memset(*ppts, 0, sizeof(THREADSTATE));
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   LicensedClassManagerFactory
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
LicenseManagerFactory(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    void **     ppvObj)
{
    CLicenseManager *  plcmgr = new CLicenseManager(pUnkOuter);

    if (!plcmgr)
    {
        *ppvObj = NULL;
        return E_OUTOFMEMORY;
    }

    return plcmgr->PrivateQueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLicenseManager
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
CLicenseManager::CLicenseManager(
    IUnknown *  pUnkOuter)
 : CComponent(pUnkOuter)
{
    _pUnkSite = NULL;

    _fDirty  = FALSE;
    _fLoaded = FALSE;
    _fPersistPBag   = FALSE;
    _fPersistStream = FALSE;

    _guidLPK = GUID_NULL;
}


//+----------------------------------------------------------------------------
//
//  Member:     ~CLicenseManager
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
CLicenseManager::~CLicenseManager()
{
    int i;

    for (i = _aryLic.Size()-1; i >= 0; i--)
    {
        ::SysFreeString(_aryLic[i].bstrLic);
        ::SRelease(_aryLic[i].pcf2);
    }

    ::SRelease(_pUnkSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     SetSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::SetSite(
    IUnknown *  pUnkSite)
{
    ::SClear(&_pUnkSite);

    _pUnkSite = pUnkSite;
    if (_pUnkSite)
    {
        _pUnkSite->AddRef();
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetSite(
    REFIID  riid,
    void ** ppvSite)
{
    HRESULT hr;

    if (!ppvSite)
        return E_INVALIDARG;

    if (_pUnkSite)
    {
        hr = _pUnkSite->QueryInterface(riid, ppvSite);
    }
    else
    {
        *ppvSite = NULL;
        hr = E_FAIL;
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetClientSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::SetClientSite(
    IOleClientSite *    pClientSite)
{
    return SetSite(pClientSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClientSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClientSite(
    IOleClientSite **   ppClientSite)
{
    return GetSite(IID_IOleClientSite, (void **)ppClientSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IObjectWithSite)
        *ppvObj = (IObjectWithSite *)this;

    else if (riid == IID_IOleObject)
        *ppvObj = (IOleObject *)this;

    else if (riid == IID_ILicensedClassManager)
        *ppvObj = (ILicensedClassManager *)this;

    else if (riid == IID_ILocalRegistry)
        *ppvObj = (ILocalRegistry *)this;

    else if (riid == IID_IRequireClasses)
        *ppvObj = (IRequireClasses *)this;

    else if (riid == IID_IPersistStream && !_fPersistPBag)
    {
        _fPersistStream = TRUE;
        *ppvObj = (IPersistStream *)this;
    }

    else if (riid == IID_IPersistStreamInit && !_fPersistPBag)
    {
        _fPersistStream = TRUE;
        *ppvObj = (IPersistStreamInit *)this;
    }

    else if (riid == IID_IPersistPropertyBag && !_fPersistStream)
    {
        _fPersistPBag = TRUE;
        *ppvObj = (IPersistPropertyBag *)this;
    }

    if (*ppvObj)
        return S_OK;
    else
        return parent::PrivateQueryInterface(riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\guids.cxx ===
//+----------------------------------------------------------------------------
//  File:       guids.cxx
//
//  Synopsis:   COM GUIDs
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#define INITGUID
#include <mgr.hxx>


// Globals --------------------------------------------------------------------
const char g_pszLPKVersion1[] = "{3d25aba1-caec-11cf-b34a-00aa00a28331}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\debug.c ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "iexplore.h"
//#include <windows.h>
//#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "iexplore"
#define SZ_MODULE           "IEXPLORE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\mgr\persist.cxx ===
//+----------------------------------------------------------------------------
//  File:       persist.cxx
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>
#include "wininet.h"

// Constants ------------------------------------------------------------------
const LARGE_INTEGER LIB_ZERO   = { 0, 0 };
const ULONG BUFFER_SIZE        = 256;
const ULONG CHARS_PER_LINE     = 65;
const WCHAR LPKPATH[]          = L"LPKPath";
const TCHAR SZ_URLMON[]        = _T("URLMON.DLL");
const TCHAR SZ_ISVALIDURL[]    = _T("IsValidURL");
const TCHAR SZ_URLDOWNLOADTOCACHEFILE[] = _T("URLDownloadToCacheFileW");

typedef HRESULT (STDMETHODCALLTYPE *ISVALIDURL)(LPBC, LPCWSTR, DWORD);
typedef HRESULT (STDMETHODCALLTYPE *URLDOWNLOADTOCACHEFILE)(LPUNKNOWN,LPCWSTR,LPWSTR,
                                                            DWORD,DWORD,LPBINDSTATUSCALLBACK);


//+----------------------------------------------------------------------------
//
//  Member:     FindInStream
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::FindInStream(
    IStream *           pstm,
    BYTE *              pbData,
    ULONG               cbData)
{
    BYTE    bByte;
    ULONG   cbRead;
    ULONG   ibData = 0;
    HRESULT hr;

    Assert(pstm);
    Assert(pbData);
    Assert(cbData);

    // Read through the stream looking for the data
    for (;;)
    {
        // Read a byte of data
        hr = pstm->Read(&bByte, sizeof(BYTE), &cbRead);
        if (hr)
            goto Cleanup;
        if (!cbRead)
            break;

        if (bByte == pbData[ibData])
        {
            ibData++;
            if (ibData >= cbData)
                break;
        }
    }

    // If the data was found, return success
    hr = (ibData == cbData
                ? S_OK
                : E_FAIL);

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   Return the object's CLSID
//
//  Arguments:  pclsid - Location at which to return the object's CLSID
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClassID(
    CLSID * pclsid)
{
    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = CLSID_LicenseManager;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   Return whether the object is dirty or not
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::IsDirty()
{
    return (_fDirty
                ? S_OK
                : S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Load(
    IStream *   pstm)
{
    CBufferedStream bstm(pstm);
    LARGE_INTEGER   libCur;
    ULARGE_INTEGER  uibSize;
    HRESULT         hr;

    Assert(_fPersistStream || _fPersistPBag);

    if (!pstm)
        return E_INVALIDARG;

    if (_fLoaded)
        return E_UNEXPECTED;

    // Prepare the buffered stream for use
    hr = bstm.SetBufferSize(BUFFER_SIZE);
    if (hr)
        goto Cleanup;

    // Determine the size of the stream
    hr = pstm->Seek(LIB_ZERO, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&libCur);
    if (hr)
        goto Cleanup;
    hr = pstm->Seek(LIB_ZERO, STREAM_SEEK_END, &uibSize);
    if (hr)
        goto Cleanup;
    hr = pstm->Seek(libCur, STREAM_SEEK_SET, NULL);
    if (hr)
        goto Cleanup;

    // Load from the buffered stream
    Assert(!uibSize.HighPart);
    hr = Load(&bstm, uibSize.LowPart);

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::Load(
    IStream *   pstm,
    ULONG       cbSize)
{
    CMemoryStream   mstm;
    ULARGE_INTEGER  uibSize = { cbSize, 0 };
    char *          psz = NULL;
    OLECHAR *       polechar = NULL;
    DWORD           cch;
    DWORD           cchMax = 0;
    DWORD           cLic;
    DWORD           iLic;
    BOOL            fSkipClass;
    HRESULT         hr;

    // Scan for the LPK version identifier and skip over it
    cch = ::lstrlenA(g_pszLPKVersion1);
    hr = FindInStream(pstm, (BYTE *)g_pszLPKVersion1, cch);
    if (hr)
        goto Cleanup;

    // Allocate a memory-based stream to hold the binary data
    hr = mstm.SetSize(uibSize);
    if (hr)
        goto Cleanup;

    // Convert and load the LPK identifier
    hr = DecodeMIME64(pstm, &mstm, NULL);
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = mstm.Read((void *)&_guidLPK, sizeof(_guidLPK), NULL);
    if (hr)
        goto Cleanup;

    // Convert and load the number of CLSID-License pairs
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = DecodeMIME64(pstm, &mstm, NULL);
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = mstm.Read((void *)&cLic, sizeof(DWORD), NULL);
    if (hr)
        goto Cleanup;
    hr = _aryLic.SetSize((int)cLic);
    if (hr)
        goto Cleanup;
    ::memset((LICENSE *)_aryLic, 0, sizeof(LICENSE)*cLic);

    // Convert the remainder of the stream and from it load each CLSID-License pair
    // (If, somehow, invalid CLSIDs end up in the stream, skip over them during load)
    for (iLic = 0; iLic < cLic; )
    {
        Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
        hr = DecodeMIME64(pstm, &mstm, NULL);
        if (hr)
            goto Cleanup;
        Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));

        hr = mstm.Read((void *)&(_aryLic[iLic].clsid), sizeof(_aryLic[0].clsid), NULL);
        if (hr)
            goto Cleanup;

        fSkipClass = (_aryLic[iLic].clsid == CLSID_NULL);

        hr = mstm.Read((void *)&cch, sizeof(DWORD), NULL);
        if (hr)
            goto Cleanup;

        if (cch > cchMax)
        {
            delete [] psz;
            delete [] polechar;

            psz      = new char[cch*sizeof(OLECHAR)]; // Review:JulianJ
            polechar = new OLECHAR[cch];
            if (!psz || !polechar)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchMax = cch;
        }
        Assert(psz);
        Assert(polechar);

		//
		// REVIEW JulianJ read cch*2 bytes as we persisted entire string
		//
        hr = mstm.Read((void *)psz, cch*sizeof(OLECHAR), NULL);
        if (hr)
            goto Cleanup;

        if (!fSkipClass)
        {
#if 1
			::memcpy(polechar, psz, cch*sizeof(OLECHAR));
#else
#ifndef _PPCMAC
            ::MultiByteToWideChar(CP_ACP, 0, psz, cch, polechar, cch);
#else
            ::memcpy(polechar, psz, cch);
#endif
#endif
            _aryLic[iLic].bstrLic = ::SysAllocStringLen(polechar, cch);
            if (!_aryLic[iLic].bstrLic)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            iLic++;
        }
        else
        {
            cLic--;
        }
    }

    // Ensure the array size is correct (in case any classes were skipped during load)
    if (cLic < (DWORD)_aryLic.Size())
    {
        Verify(SUCCEEDED(_aryLic.SetSize(cLic)));
    }

Cleanup:
    delete [] psz;
    delete [] polechar;
    _fLoaded = TRUE;
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Save(
    IStream *   pstm,
    BOOL        fClearDirty)
{
    CBufferedStream bstm(pstm, CHARS_PER_LINE, FALSE);
    ULARGE_INTEGER  uibCur;
    TCHAR           szString[MAX_PATH];
    DWORD           cbBuf = 0;
    DWORD           cbLic;
    DWORD           cb;
    BYTE *          pb = NULL;
    BYTE *          pbNext;
    int             iLic;
    HRESULT         hr = S_OK;

    Assert(_fPersistStream);

    if (!pstm)
        return E_INVALIDARG;

    // If this is a new LPK, generate an identifying GUID
    if (_guidLPK == GUID_NULL)
    {
        Assert(!_fLoaded);
        Verify(SUCCEEDED(::CoCreateGuid(&_guidLPK)));
    }

    // Write the text header to the LPK
    for (iLic=IDS_COPYTEXT; iLic <= IDS_COPYTEXT_MAX; iLic++)
    {
        cb = ::LoadString((HINSTANCE)g_hinst, iLic, szString, ARRAY_SIZE(szString));

        hr = pstm->Write(szString, cb, NULL);
        if (hr)
            goto Cleanup;
        hr = pstm->Write(SZ_NEWLINE, CB_NEWLINE, NULL);
        if (hr)
            goto Cleanup;
    }

    // Write the version GUID to the LPK
    hr = pstm->Write(g_pszLPKVersion1, ::lstrlenA(g_pszLPKVersion1), NULL);
    if (hr)
        goto Cleanup;
    hr = pstm->Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Prepare the buffered stream as the target for encoding
    hr = bstm.SetBufferSize(BUFFER_SIZE);
    if (hr)
        goto Cleanup;
    
    // Write the identifying GUID to the LPK
    hr = EncodeMIME64((BYTE *)&_guidLPK, sizeof(_guidLPK), &bstm, NULL);
    if (hr)
        goto Cleanup;
    hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Write the number of CLSID-License pairs to the LPK
    cb = (DWORD)_aryLic.Size();
    hr = EncodeMIME64((BYTE *)&cb, sizeof(cb), &bstm, NULL);
    if (hr)
        goto Cleanup;
    hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Write each CLSID-License pair to the LPK
    // (If the array contains empty entries, they are still persisted; this is necessary
    //  because the number of entries persisted must match the count already written)
    for (iLic = 0; iLic < _aryLic.Size(); iLic++)
    {
        // Determine the amount of class data and ensure the buffer is sufficiently large
        cbLic = ::SysStringLen(_aryLic[iLic].bstrLic);
        cb    = sizeof(CLSID) + sizeof(DWORD) + (sizeof(OLECHAR) * cbLic);

        if (cb > cbBuf)
        {
            cbBuf = cb;
            delete [] pb;
            pb = new BYTE[cbBuf];
            if (!pb)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        pbNext = pb;

        // Fill the buffer with the persistent state of the class
        *((CLSID *)pbNext) = _aryLic[iLic].clsid;
        pbNext += sizeof(CLSID);

        *((DWORD *)pbNext) = cbLic;
        pbNext += sizeof(DWORD);

		//
		// REVIEW JulianJ, Weird - we seem to get back a length prefixed ansi string!
		//
#if 1
		memcpy(pbNext, _aryLic[iLic].bstrLic, cbLic * (sizeof(OLECHAR)));
#else
#ifndef _PPCMAC
        ::WideCharToMultiByte(CP_ACP, 0, _aryLic[iLic].bstrLic, cbLic, (LPSTR)pbNext, cbLic, NULL, NULL);
#else
        ::memcpy(pbNext, _aryLic[iLic].bstrLic, cbLic);
#endif
#endif
        // Encode the class to the stream
        hr = EncodeMIME64(pb, cb, &bstm, NULL);
        if (hr)
            goto Cleanup;
        hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
        if (hr)
            goto Cleanup;
    }

    // Flush the buffered stream and mark the end of data
    // (Since not all streams support Seek and SetSize, errors from those methods
    //  are ignored; since the stream contains a count, it can be safely loaded
    //  without truncating unnecessary bytes)
    hr = bstm.Flush();
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(pstm->Seek(LIB_ZERO, STREAM_SEEK_CUR, &uibCur)));
    Verify(SUCCEEDED(pstm->SetSize(uibCur)));

Cleanup:
    delete [] pb;
    _fLoaded = TRUE;
    _fDirty  = !fClearDirty && SUCCEEDED(hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetSizeMax
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetSizeMax(
    ULARGE_INTEGER *    pcbSize)
{
    if (!pcbSize)
        return E_INVALIDARG;

    pcbSize->LowPart  =
    pcbSize->HighPart = 0;
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member:     InitNew
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::InitNew()
{
    if (_fLoaded)
        return E_UNEXPECTED;
    _fLoaded = TRUE;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Load(
    IPropertyBag *  pPropBag,
    IErrorLog *     pErrorLog)
{
    HMODULE hURLMon = NULL;
    VARIANT var;
    HRESULT hr;

    Assert(_fPersistPBag);

    if (!pPropBag)
        return E_INVALIDARG;

    if (_fLoaded)
        return E_UNEXPECTED;

    ::VariantInit(&var);
    V_VT(&var)   = VT_BSTR;
    V_BSTR(&var) = NULL;

    // Read the path from which to load the LPK file
    hr = pPropBag->Read(LPKPATH, &var, pErrorLog);
    if (!hr)
    {
        CFileStream     fstm;
        FARPROC         fpIsValidURL;
        FARPROC         fpURLDownloadToCacheFileW;
        WCHAR           szCachedFilename[MAX_PATH];

        // Load the URL moniker library
        hURLMon = (HMODULE)::LoadLibrary(SZ_URLMON);
        if (!hURLMon)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }

        // Check the path, if it is for an absolute URL, reject it
        // (Only relative URLs are accepted)
        fpIsValidURL = GetProcAddress(hURLMon, SZ_ISVALIDURL);
        if (!fpIsValidURL)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }
        hr = (*((ISVALIDURL)fpIsValidURL))(NULL, V_BSTR(&var), 0);
        if (hr == S_OK)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }


        // Download the .LPK to a locally cached file
        fpURLDownloadToCacheFileW = GetProcAddress(hURLMon, SZ_URLDOWNLOADTOCACHEFILE);
        if (!fpURLDownloadToCacheFileW)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }

		//
		// Get the service provider from our site
		//
		IServiceProvider * pServiceProvider;
		hr = GetSite(IID_IServiceProvider, (void**)&pServiceProvider);
		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Get an IBindHost from the service provider
		//
		IBindHost *pBindHost;
		hr = pServiceProvider->QueryService( 
			SID_IBindHost, IID_IBindHost, (void**)&pBindHost);
		pServiceProvider->Release();

		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Now create a full moniker
		//
		IMoniker *pMoniker;
		hr = pBindHost->CreateMoniker(V_BSTR(&var), NULL, &pMoniker,0);
		pBindHost->Release();
		
		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Create a bind context
		//
		IBindCtx * pBindCtx;
		hr = CreateBindCtx(0, &pBindCtx);
		if (!SUCCEEDED(hr))
		{
			pMoniker->Release();
			goto Cleanup;
		}

		//
		// Extract display name
		//
		LPOLESTR wszFullLPKPath;
		hr = pMoniker->GetDisplayName(pBindCtx, NULL, &wszFullLPKPath);
		pMoniker->Release();
		pBindCtx->Release();

		if (!SUCCEEDED(hr))
			goto Cleanup;

        hr = (*((URLDOWNLOADTOCACHEFILE)fpURLDownloadToCacheFileW))(
				_pUnkOuter,
				wszFullLPKPath,
				szCachedFilename,
				URLOSTRM_GETNEWESTVERSION,
				0, NULL);

		CoTaskMemFree(wszFullLPKPath);

        if (hr)
            goto Cleanup;

        // Open a stream on the file and load from the stream
        hr = fstm.Init(szCachedFilename, GENERIC_READ);
        if (!hr)
        {
            CBufferedStream mstm(&fstm);
            ULONG           cbSize;

            hr = mstm.SetBufferSize(BUFFER_SIZE);
            if (hr)
                goto Cleanup;

            Verify(SUCCEEDED(fstm.GetFileSize(&cbSize)));
            hr = Load(&mstm, cbSize);
        }
    }

Cleanup:
    _fLoaded = TRUE;
    ::VariantClear(&var);
    if (hURLMon)
    {
        ::FreeLibrary(hURLMon);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Save(
    IPropertyBag *  pPropBag,
    BOOL            fClearDirty,
    BOOL            fSaveAllProperties)
{
    UNREF(pPropBag);
    UNREF(fClearDirty);
    UNREF(fSaveAllProperties);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iecontrols\licmgr\core\util.cxx ===
//+----------------------------------------------------------------------------
//  File:       util.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Globals --------------------------------------------------------------------
const UCHAR SZ_NEWLINE[] = "\n\r";


//+----------------------------------------------------------------------------
//  Function:   CopyStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CopyStream(
    IStream *           pstmDest,
    IStream *           pstmSrc,
    ULARGE_INTEGER      cbCopy,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    DWORD   cb     = cbCopy.LowPart;
    DWORD   cbStep = min(cb, 0xFFFF);
    DWORD   cbRead, cbWritten;
    DWORD   cbTotalRead = 0;
    DWORD   cbTotalWritten = 0;
    void *  pv = NULL;
    HRESULT hr = S_OK;

    if (cbCopy.HighPart)
        return E_INVALIDARG;

    pv = new BYTE[cbStep];
    if (!pv)
        return E_OUTOFMEMORY;

    while (cb)
    {
        cbRead = min(cbStep, cb);

        hr = pstmSrc->Read(pv, cbRead, &cbRead);
        if (hr || !cbRead)
            break;

        cbTotalRead += cbRead;

        hr = pstmDest->Write(pv, cbRead, &cbWritten);
        if (hr)
            break;

        cbTotalWritten += cbWritten;

        if (cbWritten != cbRead)
        {
            hr = E_UNEXPECTED;
            break;
        }

        cb -= cbRead;
    }

    if (pcbRead)
    {
        pcbRead->HighPart = 0;
        pcbRead->LowPart  = cbTotalRead;
    }

    if (pcbWritten)
    {
        pcbWritten->HighPart = 0;
        pcbWritten->LowPart  = cbTotalWritten;
    }

    delete [] pv;
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    Assert(_pbData);
    Assert(_ibPos <= _cbSize);

    cb = min(cb, _cbSize - _ibPos);

    ::memcpy(pv, _pbData + _ibPos, cb);
    _ibPos += cb;

    if (pcbRead)
    {
        *pcbRead = cb;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    HRESULT hr = S_OK;

    Assert(_pbData);
    Assert(_ibPos <= _cbSize);

    if ((_ibPos + cb) > _cbSize)
    {
        hr = STG_E_MEDIUMFULL;
        goto Cleanup;
    }

    ::memcpy(_pbData + _ibPos, pv, cb);
    _ibPos += cb;

Cleanup:
    if (pcbWritten)
    {
        *pcbWritten = (!hr
                            ? cb
                            : 0);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Seek
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Seek(
    LARGE_INTEGER       dlibMove,
    DWORD               dwOrigin,
    ULARGE_INTEGER *    plibNewPosition)
{
    LONG    ibOffset = (LONG)dlibMove.LowPart;

    Assert(_pbData);

    // Ensure only 32-bits is in-use
    if (!(dlibMove.HighPart ==  0 && ibOffset >= 0) &&
        !(dlibMove.HighPart == -1 && ibOffset < 0))
        return E_INVALIDARG;

    switch (dwOrigin)
    {
        case STREAM_SEEK_SET:
            break;

        case STREAM_SEEK_CUR:
            ibOffset = (LONG)_ibPos + ibOffset;
            break;

        case STREAM_SEEK_END:
            ibOffset = (LONG)_cbSize + ibOffset;
            break;

        default:
            return E_INVALIDARG;
    }

    // Ensure the new offset is within the correct range
    if ((ULONG)ibOffset > _cbSize)
        return E_INVALIDARG;

    // Store the new offset and return it
    _ibPos = (ULONG)ibOffset;

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = _ibPos;
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     SetSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::SetSize(
    ULARGE_INTEGER  libNewSize)
{
    if (libNewSize.HighPart)
        return STG_E_MEDIUMFULL;

    if (libNewSize.LowPart <= _cbSize)
    {
        _cbSize = libNewSize.LowPart;
    }
    else
    {
        BYTE *  pbData = new BYTE[libNewSize.LowPart];
        
        if (!pbData)
            return STG_E_MEDIUMFULL;

        if (_pbData && _cbSize)
        {
            ::memcpy(pbData, _pbData, _cbSize);
        }

        delete [] _pbData;
        _cbSize = libNewSize.LowPart;
        _pbData = pbData;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     CopyTo
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::CopyTo(
    IStream *           pstm,
    ULARGE_INTEGER      cb,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    if (!pstm)
        return STG_E_INVALIDPOINTER;

    if (cb.HighPart || ((_ibPos + cb.LowPart) > _cbSize))
        return E_INVALIDARG;

    Assert(_pbData);
    return ::CopyStream(pstm, this, cb, pcbRead, pcbWritten);
}


//+----------------------------------------------------------------------------
//  Member:     CBufferedStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CBufferedStream::CBufferedStream(
    IStream *   pstm,
    ULONG       cbNewLine,
    BOOL        fRead)
{
    Assert(_pstm);

    _fRead = fRead;
    _pb = NULL;
    _cb = 0;
    _ib = 0;
    _cbLine    = 0;
    _cbNewLine = cbNewLine;
    _cbTotal   = 0;
    _pstm = ::SAddRef(pstm);
}


//+----------------------------------------------------------------------------
//  Member:     ~CBufferedStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CBufferedStream::~CBufferedStream()
{
    Verify(SUCCEEDED(Flush()));
    ::SRelease(_pstm);
}


//+----------------------------------------------------------------------------
//  Member:     Flush
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::Flush(
    ULONG * pcbWritten)
{
    ULONG   cbWritten;
    HRESULT hr = S_OK;

    Assert(_pstm);
    Implies(_cbNewLine, _ib <= (_cb + CB_NEWLINE));
    Implies(!_cbNewLine, _ib <= _cb);

    if (!pcbWritten)
    {
        pcbWritten = &cbWritten;
    }
    *pcbWritten = 0;

    // For read-only streams, "read" the rest of the buffer by setting the buffer index
    // (This will force a re-load during the next read)
    if (_fRead)
    {
        _ib = _cb;
    }

    // For write-only streams, write the buffer to the stream
    else if (_ib)
    {
        Assert(!_fRead);
        hr = _pstm->Write(_pb, _ib, pcbWritten);
        _cbTotal += *pcbWritten;
        if (!hr)
        {
            Assert(*pcbWritten == _ib);
            _ib = 0;
        }
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Load
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::Load()
{
    HRESULT hr;

    Assert(_fRead);

    hr = _pstm->Read(_pb, _cb, &_cbTotal);
    if (hr)
        goto Cleanup;
    _ib = 0;

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     SetBufferSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::SetBufferSize(
    ULONG   cb)
{
    // The buffer size cannot be changed once it has been set
    // Also, it is illegal to use a zero-sized buffer
    if (_pb || !cb)
        return E_FAIL;

    // Allocate a new buffer of the requested size
    // (If the caller requested automatic interjection of NEWLINEs, slightly increase
    //  allocated buffer; the remembered size will continue to be that which they
    //  requested)
    _pb = new BYTE[cb + (_cbNewLine ? CB_NEWLINE : 0)];
    if (!_pb)
        return E_OUTOFMEMORY;
    _cb = cb;
    _ib = (_fRead ? _cb : 0);

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CBufferedStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    ULONG   cbTotalRead;
    ULONG   cbRead;
    HRESULT hr = S_OK;

    Assert(_pb);
    Assert(_cb);
    Assert(_ib <= _cb);

    if (!pv)
        return E_INVALIDARG;

    if (!pcbRead)
    {
        pcbRead = &cbTotalRead;
    }
    *pcbRead = 0;

    // If bytes remain in the buffer, "read" those first
    if (_ib < _cbTotal)
    {
        cbRead = min(cb, _cbTotal-_ib);
        ::memcpy(pv, _pb+_ib, cbRead);
        _ib += cbRead;
        cb  -= cbRead;
        pv   = (void *)(((const BYTE *)pv) + cbRead);
        *pcbRead += cbRead;
    }

    // If bytes remain to be read, fetch them now
    if (cb)
    {
        Assert(_ib >= _cbTotal);
        Assert(_cbTotal <= _cb);

        // If the request fits within half of the buffer, then load a buffer full
        if (cb < (_cb/2))
        {
            hr = Load();
            if (hr)
                goto Cleanup;

            cbRead = min(cb, _cbTotal);
            ::memcpy(pv, _pb, cbRead);

            _ib = cbRead;
            *pcbRead += cbRead;
        }

        // Otherwise, read directly into the callers buffer
        else
        {
            hr = _pstm->Read(pv, cb, pcbRead);
        }
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CBufferedStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    const BYTE *    pbSrc = (const BYTE *)pv;
    ULONG           ibSrc = 0;
    ULONG           cbWritten;
    HRESULT         hr = S_OK;

    Assert(_pb);
    Assert(_cb);
    Assert(_ib <= _cb);

    if (!pv)
        return E_INVALIDARG;

    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    // Treat calls to write on a read-only stream as if the stream is full
    if (_fRead)
    {
        hr = STG_E_MEDIUMFULL;
        goto Cleanup;
    }

    // Write the bytes to the stream
    while (cb)
    {
        // Determine the number of bytes to write this time through
        cbWritten = min(cb, _cb-_ib);
        if (_cbNewLine)
        {
            cbWritten = min(cbWritten, _cbNewLine-_cbLine);
        }

        // Write the bytes to the local buffer
        ::memcpy(_pb + _ib, pbSrc + ibSrc, cbWritten);

        // Update the counters reflecting what has been written
        // (Adding a newline if necessary)
        cb    -= cbWritten;
        ibSrc += cbWritten;
        _ib   += cbWritten;
        if (_cbNewLine)
        {
            _cbLine += cbWritten;
            if (_cbLine >= _cbNewLine)
            {
                ::memcpy(_pb + _ib, SZ_NEWLINE, CB_NEWLINE);
                _cbLine = 0;
                _ib    += CB_NEWLINE;
            }
        }

        // If the buffer is full, write it to the stream
        if (_ib >= _cb)
        {
            hr = Flush(&cbWritten);
            if (pcbWritten)
            {
                *pcbWritten += cbWritten;
            }
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     CFileStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CFileStream::CFileStream()
{
    _hFile = NULL;
}


//+----------------------------------------------------------------------------
//  Member:     ~CFileStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CFileStream::~CFileStream()
{
    if (_hFile)
    {
        ::CloseHandle(_hFile);
    }
}


//+----------------------------------------------------------------------------
//  Member:     Init
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::Init(
    LPCWSTR                 wszFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   pSecurityAttributes,
    DWORD                   dwCreationDistribution,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile)
{
	int len = WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, 0, 0, NULL, NULL);
	LPSTR psz = new CHAR[len];

    if (psz)
    {
        if (::WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, (LPSTR)psz, len, NULL, NULL))
        {
	        _hFile = ::CreateFileA(psz, dwDesiredAccess, dwShareMode, pSecurityAttributes,	
                                dwCreationDistribution,	dwFlagsAndAttributes, hTemplateFile);
        }
	    delete psz;
    }
    else
    {
        return E_OUTOFMEMORY;
    }

	// CreateFile succeeded if we didn't get back INVALID_HANDLE_VALUE
    return ((_hFile != INVALID_HANDLE_VALUE)
                ? S_OK
                : GetWin32Hresult());
}


//+----------------------------------------------------------------------------
//  Member:     GetFileSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::GetFileSize(
    ULONG * pcbSize)
{
    Assert(_hFile);
    Assert(pcbSize);
    *pcbSize = ::GetFileSize(_hFile, NULL);
    return (*pcbSize == 0xFFFFFFFF
                ? GetWin32Hresult()
                : S_OK);
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    ULONG   cbRead;
    HRESULT hr = S_OK;

    if (!pv)
        return E_INVALIDARG;

    if (!pcbRead)
    {
        pcbRead = &cbRead;
    }

    hr = (::ReadFile(_hFile, pv, cb, pcbRead, NULL)
                ? S_OK
                : S_FALSE);

    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    ULONG   cbWritten;
    HRESULT hr;

    if (!pv)
        return E_INVALIDARG;

    if (!pcbWritten)
    {
        pcbWritten = &cbWritten;
    }

    hr = (::WriteFile(_hFile, pv, cb, pcbWritten, NULL)
                ? S_OK
                : STG_E_MEDIUMFULL);
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Seek
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Seek(
    LARGE_INTEGER       dlibMove,
    DWORD               dwOrigin,
    ULARGE_INTEGER *    plibNewPosition)
{
    DWORD           dwMoveMethod;
    ULARGE_INTEGER  libNewPosition;
    HRESULT         hr;

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart  = 0;
    }

    switch(dwOrigin)
    {
        case STREAM_SEEK_SET: dwMoveMethod = FILE_BEGIN; break;
        case STREAM_SEEK_CUR: dwMoveMethod = FILE_CURRENT; break;
        case STREAM_SEEK_END: dwMoveMethod = FILE_END; break;
        default:
            return E_INVALIDARG;
    }

    libNewPosition.LowPart = ::SetFilePointer(_hFile, dlibMove.LowPart, &dlibMove.HighPart, dwMoveMethod);
    libNewPosition.HighPart = dlibMove.HighPart;

    if (libNewPosition.LowPart == 0xFFFFFFFF &&
        ::GetLastError() != NO_ERROR)
    {
        hr = STG_E_INVALIDPOINTER;
    }
    else
    {
        if (plibNewPosition)
        {
            *plibNewPosition = libNewPosition;
        }
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetSize
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::SetSize(
    ULARGE_INTEGER  libNewSize)
{
    LONG    curLow, curHigh;
    BOOL    fEOFSet;

    curHigh = 0;
    curLow = ::SetFilePointer(_hFile, 0, &curHigh, FILE_CURRENT);
    if (0xFFFFFFFF == ::SetFilePointer(_hFile, libNewSize.LowPart,
                                        (LONG *)&libNewSize.HighPart, FILE_BEGIN))
    {
        return STG_E_INVALIDFUNCTION;
    }

    fEOFSet = ::SetEndOfFile(_hFile);
#ifdef _DEBUG
    Verify(0xFFFFFFFF != ::SetFilePointer(_hFile, curLow, &curHigh, FILE_BEGIN));
#else
    ::SetFilePointer(_hFile, curLow, &curHigh, FILE_BEGIN);
#endif

    return (fEOFSet
                ? S_OK
                : STG_E_MEDIUMFULL);
}


//+----------------------------------------------------------------------------
//
//  Member:     CopyTo
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::CopyTo(
    IStream *           pstm,
    ULARGE_INTEGER      cb,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    if (!pstm)
        return STG_E_INVALIDPOINTER;

    return ::CopyStream(pstm, this, cb, pcbRead, pcbWritten);
}


//+----------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IStream)
        *ppvObj = (IStream *)this;

    if (*ppvObj)
        return S_OK;
    else
        return parent::PrivateQueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   CoAlloc
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void *
CoAlloc(
    ULONG   cb)
{
    Assert(TLS(dll.pmalloc));
    return TLS(dll.pmalloc)->Alloc(cb);
}


//+----------------------------------------------------------------------------
//  Function:   CoFree
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CoFree(
    void *  pv)
{
    if (!pv)
        return;

    Assert(TLS(dll.pmalloc));
    Assert(CoDidAlloc(pv));
    TLS(dll.pmalloc)->Free(pv);
}


//+----------------------------------------------------------------------------
//  Function:   CoGetSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
ULONG
CoGetSize(
    void *  pv)
{
    Assert(TLS(dll.pmalloc));
    Assert(CoDidAlloc(pv));
    return (ULONG)(TLS(dll.pmalloc)->GetSize(pv));
}


//+----------------------------------------------------------------------------
//  Function:   CoDidAlloc
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
BOOL
CoDidAlloc(
    void *  pv)
{
    Assert(TLS(dll.pmalloc));
    return (!pv || TLS(dll.pmalloc)->DidAlloc(pv) == 1
                ? TRUE
                : FALSE);
}


#ifdef _NOCRT
//+----------------------------------------------------------------------------
//  Function:   purecall
//
//  Synopsis:   _SHIP build replacement for CRT vtable routine
//
//-----------------------------------------------------------------------------
int __cdecl
_purecall()
{
    return 0;
}


//+----------------------------------------------------------------------------
//  Function:   _tcslen
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" size_t __cdecl
_tcslen(
    const TCHAR *   psz)
{
    for (size_t i=0; *psz; psz++, i++);
    return i;
}


//+----------------------------------------------------------------------------
//  Function:   memcmp
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" int __cdecl
memcmp(
    const void *    pv1,
    const void *    pv2,
    size_t          cb)
{
    size_t  i;
    int     d;
    for (i=0, d=0; i < cb && !d; i++)
        d = (*(const BYTE *)pv1) - (*(const BYTE *)pv2);
    return d;
}


//+----------------------------------------------------------------------------
//  Function:   memcpy
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memcpy(
    void *          pvDest,
    const void *    pvSrc,
    size_t          cb)
{
    for (size_t i=0; i < cb; i++)
        ((BYTE *)pvDest)[i] = ((const BYTE *)pvSrc)[i];
    return pvDest;
}


//+----------------------------------------------------------------------------
//  Function:   memset
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memset(
    void *  pv,
    int     c,
    size_t  cb)
{
    for (size_t i=0; i < cb; i++)
        ((BYTE *)pv)[i] = (BYTE)c;
    return pv;
}


//+----------------------------------------------------------------------------
//  Function:   memmove
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memmove(
    void *          pvDest,
    const void *    pvSrc,
    size_t          cb)
{
    BYTE *  pb1;
    BYTE *  pb2;

    if (pvSrc < pvDest)
    {
        pb1 = (BYTE *)pvDest + cb;
        pb2 = (BYTE *)pvSrc  + cb;
        for (; cb; cb--)
        {
            *pb1-- = *pb2--;
        }
    }
    else if (pvSrc > pvDest)
    {
        pb1 = (BYTE *)pvDest;
        pb2 = (BYTE *)pvSrc;
        for (; cb; cb--)
        {
            *pb1++ = *pb2++;
        }
    }
    return pvDest;
}
#endif // _NOCRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\unixstuff.h ===
#include <stdlib.h>
#include <mainwin.h>

#define IEREMOTE_CMDLINE        1
#define IEREMOTECLASS           TEXT("IEFrame")

BOOL ConnectRemoteIE(LPTSTR pszCmdLine, HINSTANCE hInstance);
BOOL IsCommandSwitch(LPTSTR lpszCmdLine, LPTSTR pszSwitch);
BOOL RemoteIENewWindow(LPTSTR pszCmdLine);

#if defined(UNIX)

#include <sys/time.h>
#include <sys/resource.h>

#define INCREASE_FILEHANDLE_LIMIT  \
    struct rlimit rl; \
    if ( 0 == getrlimit(RLIMIT_NOFILE, &rl)) { \
       rl.rlim_cur = rl.rlim_max; \
       setrlimit(RLIMIT_NOFILE, &rl); \
    } \

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\iexplore.h ===
#undef  STRICT
#define STRICT
#define _INC_OLE        // REVIEW: don't include ole.h in windows.h

#define OEMRESOURCE

// For dllload: change function prototypes to not specify declspec import
#define _SHDOCVW_      

#include <windows.h>

#include <stddef.h>

#include <commctrl.h>
#include <windowsx.h>
#include <ole2.h>
#include <shlobj.h>     // Includes <fcext.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#include <ccstock.h>
#include <crtfree.h>
#include <port32.h>
// #include <heapaloc.h>
#include <debug.h>      // our version of Assert etc.
#include <shellp.h>
#include <wininet.h>
#include <shdocvw.h>


// Debug and trace message values
#define DF_DELAYLOADDLL         0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\apwizhlp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1994
*
*  TITLE:	APWIZHLP.H
*
*  VERSION:	1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/8/94
*
*  Help IDs for Add/Remove Programs.
*  NOTE:  These IDs are reserved in the HELP.H file.  The IDs refer to entries
*	  in the main windows help file.
*
*******************************************************************************/


#ifndef _INC_APWIZHLP
#define _INC_APWIZHLP

//  Net install page
#define IDH_APPWIZ_NETINSTALL_INSTRUCT	5600
#define IDH_APPWIZ_NETINSTALL_LIST	5601
#define IDH_APPWIZ_NETINTALLL_BUTTON	5602

// Install/Uninstall Page
#define IDH_APPWIZ_DISKINSTALL_INSTRUCT 5610
#define IDH_APPWIZ_DISKINTALLL_BUTTON	5611
#define IDH_APPWIZ_UNINSTALL_INSTRUCT	5612
#define IDH_APPWIZ_UNINSTALL_LIST	5613
#define IDH_APPWIZ_UNINSTALL_BUTTON	5614

// Windows Setup page
#define IDH_APPWIZ_WINSETUP_INSTRUCT	5620
#define IDH_APPWIZ_WINSETUP_LIST	5621

// Startup Disk page
#define IDH_APPWIZ_STARTDISK_INSTRUCT	5630
#define IDH_APPWIZ_STARTDISK_BUTTON	5631

#endif // _INC_APWIZHLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\unixstuff.cpp ===
#include "iexplore.h"
#include "unixstuff.h"

//
// BOOL ConnectRemoteIE(LPTSTR pszCommandLine)
//
// This function will be called when -remote parameter is specified during the 
// invokation of IE. That's the same format as Netscape uses, see 
// http://home.netscape.com/newsref/std/x-remote.html. 
// For now, the only special action supported is openURL(URL), because we need 
// it for the NetShow. We just put it as the URL was specified as iexplorer 
// param. To be done - connection to the existent browser.
// Returns TRUE if succeed to connect to the existent browser.
//
#define c_szSpace TEXT(' ')

static BOOL IsOpenURL(LPCTSTR pszBeginCommand, LPCTSTR pszEndCommand, LPTSTR pszURL)
{
    const TCHAR c_szOpenURL[] = TEXT("openURL");
    const TCHAR c_szLBracket  = TEXT('(');
    const TCHAR c_szRBracket  = TEXT(')');
    const TCHAR c_szSQuote    = TEXT('\'');
    const TCHAR c_szDQuote  = TEXT('\"');
    LPCTSTR pszBeginURL, pszEndURL;
    BOOL bRet = TRUE;

    // Skip the leading/trailing spaces.
    while (*pszBeginCommand == c_szSpace) pszBeginCommand++;
    while ((*pszEndCommand == c_szSpace) && (pszBeginCommand <= pszEndCommand))
        pszEndCommand--;

    // Now, parse the value and replace in the cmd line, 
    // if there is openURL there. More formats later...
    if (StrCmpNI(pszBeginCommand, c_szOpenURL, lstrlen(c_szOpenURL)) ||
        (*pszEndCommand != c_szRBracket)) {
        pszBeginURL = pszBeginCommand;
        bRet = FALSE;
	pszEndURL = pszEndCommand;
    }
    else{
        pszBeginURL = pszBeginCommand+lstrlen(c_szOpenURL);
	while (*pszBeginURL == c_szSpace) pszBeginURL++;    
	if ((*pszBeginURL != c_szLBracket) || 
	    (pszBeginURL == pszEndCommand-1)) {
	    pszURL[0] = '\0';
	    return FALSE;
	}
	pszBeginURL++;
	pszEndURL = pszEndCommand-1;
    }

    // Skip the leading/trailing spaces.
    while (*pszBeginURL == c_szSpace) pszBeginURL++;    
    while (*pszEndURL == c_szSpace) pszEndURL--;

    // Take off quotes.
    if (((*pszBeginURL == c_szSQuote) && (*pszEndURL == c_szSQuote)) || 
	((*pszBeginURL == c_szDQuote) && (*pszEndURL == c_szDQuote))) {
        while (*pszBeginURL == c_szSpace) pszBeginURL++;    
	while (*pszEndURL == c_szSpace) pszEndURL--;
	if (pszBeginURL >= pszEndURL) {
	    pszURL[0] = '\0';
	    return FALSE;
	}
    }

    StrCpyN(pszURL, pszBeginURL, (pszEndURL-pszBeginURL)/sizeof(TCHAR) +2); 
    if (bRet) 
        bRet = pszURL[0];

    return bRet;
}


static BOOL ConnectExistentIE(LPCTSTR pszURL, HINSTANCE hInstance)
{
    HWND hwnd; 
   
    if (hwnd = FindWindow(IEREMOTECLASS, NULL))
    {
        COPYDATASTRUCT cds;
        cds.dwData = IEREMOTE_CMDLINE;
        cds.cbData = pszURL ? (lstrlen(pszURL)+1)*sizeof(TCHAR) : 0;
        cds.lpData = pszURL;
        SetForegroundWindow(hwnd);
        SendMessage(hwnd, WM_COPYDATA, (WPARAM)WMC_DISPATCH, (LPARAM)&cds);
	ExitProcess(0);
    }
    return FALSE;
}

BOOL ConnectRemoteIE(LPTSTR pszCmdLine, HINSTANCE hInstance)
{
    const TCHAR c_szDblQuote  = TEXT('"');
    const TCHAR c_szQuote     = TEXT('\'');

    LPTSTR pszBeginRemote, pszEndRemote;
    LPTSTR pszBeginCommand, pszEndCommand;
    TCHAR  szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR  szRestCmdLine[INTERNET_MAX_URL_LENGTH * 2];

    // If we start with a quote, finish with a quote.
    // If we start with something else, finish 1 symbol before space
    // or end of string.
    pszBeginRemote = pszBeginCommand = pszCmdLine;
    
    if (*pszBeginCommand == c_szQuote || *pszBeginCommand == c_szDblQuote) {
        pszEndRemote = pszEndCommand = StrChr(pszBeginCommand+1, (WORD)(*pszBeginCommand));
        pszBeginCommand++;       
    }
    else {
        pszEndCommand = StrChr(pszBeginCommand, (WORD)c_szSpace);
        if (pszEndCommand == NULL)
            pszEndCommand = pszBeginCommand+lstrlen(pszBeginCommand);
       pszEndRemote = pszEndCommand-1;
    }

    if ((pszEndCommand == NULL) || (lstrlen(pszBeginCommand) <= 1))
        return FALSE;
    pszEndCommand--;

    //
    // Now, check the remote command and execute.
    // For now, we just replace the URL in the cmd line, 
    // if there is openURL there. More formats later...
    IsOpenURL(pszBeginCommand, pszEndCommand, szURL);
    if (ConnectExistentIE(szURL, hInstance))
        return TRUE;
    StrCpyN(szRestCmdLine, pszEndRemote+1, ARRAYSIZE(szRestCmdLine));
    *pszBeginRemote = '\0';   
    StrCat(pszCmdLine, szURL);
    StrCat(pszCmdLine, szRestCmdLine);

    // No connection with an existent IE was done.
    return FALSE;

}

#if 0
#define WMC_UNIX_NEWWINDOW            (WM_USER + 0x0400)
BOOL RemoteIENewWindow(LPTSTR pszCmdLine)
{
    HWND hwnd; 
    LPTSTR pszCurrent = pszCmdLine;

    while (*pszCurrent == TEXT(' '))
        pszCurrent++;
    if (*pszCurrent == TEXT('-'))
        return FALSE;
   
    if (hwnd = FindWindow(IEREMOTECLASS, NULL))
    {
        COPYDATASTRUCT cds;
        cds.dwData = IEREMOTE_CMDLINE;
        cds.cbData = pszCmdLine ? (lstrlen(pszCmdLine)+1)*sizeof(TCHAR) : 0;
        cds.lpData = pszCmdLine;
        SetForegroundWindow(hwnd);
        SendMessage(hwnd, WM_COPYDATA, (WPARAM)WMC_UNIX_NEWWINDOW, (LPARAM)&cds);
	printf("Opening a new window in the currently running Internet Explorer.\n");
	printf("To start a new instance of Internet Explorer, type \"iexplorer -new\".\n");
	return TRUE;
    }
    return FALSE;    
}
#endif

// Entry point for Mainwin is WinMain so create this function and call
// ModuleEntry() from here.

#if defined(MAINWIN)
EXTERN_C int _stdcall ModuleEntry(void);

EXTERN_C int WINAPI WinMain( HINSTANCE hinst, HINSTANCE hprev, LPSTR lpcmdline, int cmd )
{
        return ModuleEntry ();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\rcids.h ===
//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

//
// IE 2.0 icon ids
//
// NOTE for IE 2.0 compatibilty these icons MUST be in this order
//
#define RES_ICO_FRAME           32528
#define RES_ICO_HTML            32529
#define RES_ICO_EXTRA_1         32530
#define RES_ICO_EXTRA_2         32531
#define RES_ICO_EXTRA_3         32532
#define RES_ICO_EXTRA_4         32533
#define IDI_APPEARANCE          32534
#define IDI_ADVANCED            32535
#undef IDI_HOMEPAGE
#define IDI_HOMEPAGE            32536
#define IDI_GOTOURL             32537
#define IDI_FINDTEXT            32538
#define IDI_UNKNOWN_FILETYPE    32539
#define RES_ICO_JPEG            32540
#define RES_ICO_GIF             32541
#define IDI_INTERNET            32542
#define RES_ICON_FOLDER_OPEN    32543
#define RES_ICON_FOLDER_CLOSED  32544
#define RES_ICON_URL_FILE       32545
#define IDI_SECURITY            32546
#define RES_ICO_NOICON          32547
#define RES_ICO_FINDING         32548
#define RES_ICO_CONNECTING      32549
#define RES_ICO_ACCESSING       32550
#define RES_ICO_RECEIVING       32551
#define IDI_NEWS                32552
#define IDI_VRML                32553
#define IDI_MHTMLFILE           32554


// String IDS which are actually used:
#define IDS_COMPATMODEWARNING        700
#define IDS_COMPATMODEWARNINGTITLE   701
#define IDS_INTERNETEXPLORER         702


// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_FILECLOSE         (FCIDM_BROWSER_FILE+0x0001)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002)
#define FCIDM_ENTER		(FCIDM_BROWSER_FILE+0x0003)

// these aren't real menu commands, but they map to accelerators or other things
#define FCIDM_NEXTCTL           (FCIDM_BROWSER_FILE+0x0010)
#define FCIDM_DROPDRIVLIST      (FCIDM_BROWSER_FILE+0x0011)

//---------------------------------------------------------------------------
#define FCIDM_VIEWTOOLBAR     (FCIDM_BROWSERFIRST + 0x0010)
#define FCIDM_VIEWSTATUSBAR   (FCIDM_BROWSERFIRST + 0x0011)
#define FCIDM_VIEWOPTIONS     (FCIDM_BROWSERFIRST + 0x0012)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_HELP      (FCIDM_BROWSERFIRST+0x0100)

#define FCIDM_HELPSEARCH        (FCIDM_BROWSER_HELP+0x0001)
#define FCIDM_HELPABOUT         (FCIDM_BROWSER_HELP+0x0002)

//----------------------------------------------------------------
#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0110)
#define FCIDM_NAVIGATEBACK      (FCIDM_BROWSER_EXPLORE+0x0001)
#define FCIDM_NAVIGATEFORWARD   (FCIDM_BROWSER_EXPLORE+0x0002)
#define FCIDM_BROWSEROPTIONS    (FCIDM_BROWSER_EXPLORE+0x0003)
#define FCIDM_RECENTMENU        (FCIDM_BROWSER_EXPLORE+0x0010)
#define FCIDM_RECENTFIRST       (FCIDM_BROWSER_EXPLORE+0x0011)
#define FCIDM_RECENTLAST        (FCIDM_BROWSER_EXPLORE+0x0050)
#define FCIDM_FAVORITES         (FCIDM_BROWSER_EXPLORE+0x0052)
#define FCIDM_ADDTOFAVORITES    (FCIDM_BROWSER_EXPLORE+0x0053)
#define FCIDM_FAVORITEFIRST     (FCIDM_BROWSER_EXPLORE+0x0055)
#define FCIDM_FAVORITELAST      (FCIDM_BROWSER_EXPLORE+0x0100)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVORITES)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)

#define MH_POPUPS	700
#define MH_ITEMS	(800-FCIDM_FIRST)
#define MH_TTBASE               (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))
#define IDS_TT_PREVIOUSFOLDER   (MH_TTBASE+FCIDM_PREVIOUSFOLDER)
#define IDS_TT_NAVIGATEBACK             (MH_TTBASE + FCIDM_NAVIGATEBACK)
#define IDS_TT_NAVIGATEFORWARD          (MH_TTBASE + FCIDM_NAVIGATEFORWARD)
#define IDS_TT_FAVORITES             (MH_TTBASE + FCIDM_FAVORITES)
#define IDS_TT_ADDTOFAVORITES          (MH_TTBASE + FCIDM_ADDTOFAVORITES)

// Define string ids that go into resource file
#define IDS_MH_DRIVELIST        (MH_ITEMS+FCIDM_DRIVELIST)
#define IDS_MH_MENU_FILE        (MH_ITEMS+FCIDM_MENU_FILE)
#define IDS_MH_MENU_EXPLORE     (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_MENU_HELP        (MH_ITEMS+FCIDM_MENU_HELP)
#define IDS_MH_FILECLOSE        (MH_ITEMS+FCIDM_FILECLOSE)
#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_HELPSEARCH       (MH_ITEMS+FCIDM_HELPSEARCH)
#define IDS_MH_HELPABOUT        (MH_ITEMS+FCIDM_HELPABOUT)
#define IDS_MH_NAVIGATEBACK	(MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEBACK     (MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEFORWARD  (MH_ITEMS+FCIDM_NAVIGATEFORWARD)
#define IDS_MH_RECENTMENU       (MH_ITEMS+FCIDM_RECENTMENU)
#define IDS_MH_MENU_FAVORITES   (MH_ITEMS+FCIDM_MENU_FAVORITES)
#define IDS_MH_FAVORITES        (MH_ITEMS+FCIDM_FAVORITES)
#define IDS_MH_ADDTOFAVORITES   (MH_ITEMS+FCIDM_ADDTOFAVORITES)

#define IDS_NAVIGATEBACKTO  720
#define IDS_NAVIGATEFORWARDTO 721

#define IDS_OPTIONS	722
#define IDS_TITLE	723
#define IDS_ERROR_GOTO	724

#define IDS_NONE        725
#define IDS_NAME        726     // Used for NAME member function for fram programmability

// Accelerator ID
#define ACCEL_MERGE	0x100

// Menu ID
#define MENU_TEMPLATE	0x100
#define MENU_FAVORITES  0x101
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\autosecurity.h ===
/*****************************************************************************\
    FILE: autosecurity.h

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/20/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _AUTOMATION_SECURITY_H_
#define _AUTOMATION_SECURITY_H_

#include <ocidl.h>          // IObjectWithSite
#include <shlwapip.h>        // IUnknown_AtomicRelease
#include <ccstock.h>        // ATOMICRELEASE

#include <mshtml.h>
#include <cowsite.h>        // CObjectWithSite
#include <objsafe.h>        // IObjectSafety
#include <cobjsafe.h>       // CObjectSafety


/***************************************************************\
    DESCRIPTION:
        This class will provide standard security functions that
    most ActiveX Controls or scriptable COM objects need.

    HOW TO USE THIS CLASS:
    1. If you don't want any security, don't implement this
       interface and don't implement IObjectSafety.  This should
       prevent your class from being used from any unsafe hosts.
    2. Create a list of any of your automation methods and actions
       invoked from your ActiveX Control's UI that can harm the user.
    3. For each of those methods/actions, decide if:
       A) It's only safe from hosts that are always safe (like HTA)
       B) It's only safe from hosts if their content is from
          a safe zone (Local Zone/Local Machine).
       C) If an UrlAction needs to be checked before the operation
          can be carried out.
    4. Based on #3, use IsSafeHost(), IsHostLocalZone(),
       or IsUrlActionAllowed() respectively.
    5. Call MakeObjectSafe on any object you create unless you
       can GUARANTEE that it will be IMPOSSIBLE for an unsafe
       caller to use it directly or indirectly to do something
       unsafe.
       
       An example of a direct case is a collection object
       creating an item object and then returning it to the unsafe
       host.  Since the host didn't create the object, it didn't
       get a chance to correctly use IObjectSafety, so
       MakeObjectSafe() is needed.

       An example of an indirect case is where unsafe code calls
       one of your automation methods and you decide to carry out
       the action.  If you create a helper object to perform a task
       and you can't guarantee that it will be safe, you need to
       call MakeObjectSafe on that object so it can decide
       internally if it's safe.

       WARNING: If MakeObjectSafe returns a FAILED(hr),
          then ppunk will be FREED because it isn't safe to use.
\***************************************************************/
#define    CAS_NONE            0x00000000  // None
#define    CAS_REG_VALIDATION  0x00000001  // Verify the host HTML is registered
#define    CAS_PROMPT_USER     0x00000002  // If the HTML isn't registered, prompt the user if they want to use it anyway.

class CAutomationSecurity   : public CObjectWithSite
                            , public CObjectSafety
{
public:
    //////////////////////////////////////////////////////
    // Public Methods
    //////////////////////////////////////////////////////
    BOOL IsSafeHost(OUT OPTIONAL HRESULT * phr);
    BOOL IsHostLocalZone(IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr);
    BOOL IsUrlActionAllowed(IN IInternetHostSecurityManager * pihsm, IN DWORD dwUrlAction, IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr);

    HRESULT MakeObjectSafe(IN OUT IUnknown ** ppunk);
};


#endif // _AUTOMATION_SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\mainloop.cpp ===
#include "iexplore.h"
#include "rcids.h"
#include "shlwapi.h"
#include "msodw.h"

#include <platform.h>

#ifdef UNIX
#include "unixstuff.h"
#endif

static const TCHAR c_szBrowseNewProcessReg[] = REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess");
static const TCHAR c_szBrowseNewProcess[] = TEXT("BrowseNewProcess");

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);


STDAPI_(int) ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
#ifdef UNICODE
    LPTSTR pszCmdLine = GetCommandLine();
#else
    // for multibyte should make it unsigned
    BYTE * pszCmdLine = (BYTE *)GetCommandLine();
#endif


#if defined(UNIX) 
    // IEUNIX: On solaris we are getting out of file handles with new code pages added to mlang
    // causing more nls files to be mmapped.
    INCREASE_FILEHANDLE_LIMIT;
#endif

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if(StopWatchMode() & SPMODE_BROWSER)  // Used to get the start of browser total download time
    {
        StopWatch_Start(SWID_BROWSER_FRAME, TEXT("Browser Frame Start"), SPMODE_BROWSER | SPMODE_DEBUGOUT);
    }
    
    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    si.cb = sizeof(si);

    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, (LPTSTR)pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

#ifndef UNIX  
    ExitThread(i);  // We only come here when we are not the shell...
#else
// there seem to be some desirable side effect calling ExitThread on Windows
    ExitProcess(i); 
#endif
    return i;
}

//
// Create a unique event name
//
HANDLE AppendEvent(COPYDATASTRUCT *pcds)
{
    static DWORD dwNextID = 0;
    TCHAR szEvent[MAX_IEEVENTNAME];

    wsprintf(szEvent, "IE-%08X-%08X", GetCurrentThreadId(), dwNextID++);
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, szEvent);
    if (hEvent)
    {
        //
        // Put the (UNICODE) event name at the end of the cds data
        //
        LPWSTR pwszBufferEvent = (LPWSTR)(((BYTE *)pcds->lpData) + pcds->cbData);
#ifdef UNICODE
        lstrcpy(pwszBufferEvent, szEvent);
#else
        MultiByteToWideChar(CP_ACP, 0, szEvent, -1, pwszBufferEvent, ARRAYSIZE(szEvent));
#endif
        pcds->cbData += (lstrlenW(pwszBufferEvent) + 1) * sizeof(WCHAR);
    }

    return hEvent;
}

BOOL IsCommandSwitch(LPTSTR lpszCmdLine, LPTSTR pszSwitch, BOOL fRemoveSwitch)
{
    LPTSTR lpsz;
    
    if ((lpsz=StrStrI(lpszCmdLine, pszSwitch)) && (lpsz == lpszCmdLine))
    {
        int cch = lstrlen(pszSwitch);

        if (*(lpsz+cch) == 0 || *(lpsz+cch) == TEXT(' '))
        {
            while (*(lpsz+cch) == TEXT(' '))
                cch++;

            if (fRemoveSwitch)
            {
                // Remove the switch by copying everything up.
                *lpsz=0;
                lstrcat(lpsz, lpsz+cch);
            }
            return TRUE;
        }
    } 
    return FALSE;
}

BOOL CheckForNeedingAppCompatWindow(void)
{
    // Which I could simply get the Process of who spawned me.  For now
    // try hack to get the foreground window and go from there...
    TCHAR szClassName[80];
    HWND hwnd = GetForegroundWindow();

    if (hwnd && GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName)) > 0)
    {
        if (lstrcmpi(szClassName, TEXT("MauiFrame")) == 0)
            return TRUE;
    }
    return FALSE;
}

//
// AppCompat - Sequel NetPIM execs a browser and then waits forever
// looking for a visible top level window owned by this process.
//
HWND CreateAppCompatWindow(HINSTANCE hinst)
{
    HWND hwnd;
    static const TCHAR c_szClass[] = TEXT("IEDummyFrame");  // IE3 used "IEFrame"

    WNDCLASS wc = { 0, DefWindowProc, 0, 0, hinst, NULL, NULL, NULL, NULL, c_szClass };
    RegisterClass(&wc);

    // Netmanage ECCO Pro asks to get the menu...
    HMENU hmenu = CreateMenu();
    hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, c_szClass, TEXT(""), 0,
                          0x00007FF0, 0x00007FF0, 0, 0,
                          NULL, hmenu, hinst, NULL);
    // Don't open SHOWDEFAULT or this turkey could end up maximized
    ShowWindow(hwnd, SW_SHOWNA);

    return hwnd;
}

#define USERAGENT_POST_PLATFORM_PATH_TO_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\User Agent\\Post Platform")
void SetCompatModeUserAgentString(void)
{
    HKEY hkey;
    const char szcompat[]=TEXT("compat");
    
    if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, USERAGENT_POST_PLATFORM_PATH_TO_KEY, &hkey))
    {
        RegSetValueEx( hkey,
                       szcompat,
                       0,
                       REG_BINARY,
                       (LPBYTE)NULL, 0);
        RegCloseKey(hkey);
    }
    
}

// Tell the user they are running in compat mode and not all the features will be available.
#define IECOMPAT_REG_VAL    TEXT("CompatWarningFor")

void WarnCompatMode(HINSTANCE hinst)
{
    TCHAR szFqFilename[MAX_PATH];
    TCHAR szRegVal[MAX_PATH];
    TCHAR szTitle[255];
    TCHAR szMsg[1024];
    LPTSTR szFile;

    GetModuleFileName(NULL, szFqFilename, ARRAYSIZE(szFqFilename));
    szFile = PathFindFileName(szFqFilename);
    

    // Build up string "compatmodewarningfor <exe name>" as value for reg key
    lstrcpy(szRegVal, IECOMPAT_REG_VAL);
    lstrcat(szRegVal, szFile);

    LoadString(hinst, IDS_COMPATMODEWARNINGTITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(hinst, IDS_COMPATMODEWARNING, szMsg, ARRAYSIZE(szMsg));

    SHMessageBoxCheck(NULL, szMsg, szTitle, MB_OK, FALSE, szRegVal);
}

#ifdef WINNT

// this is the same code that is in explorer.exe (initcab.c)
#define RSA_PATH_TO_KEY    TEXT("Software\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Base Cryptographic Provider v1.0")
#define CSD_REG_PATH       TEXT("System\\CurrentControlSet\\Control\\Windows")
#define CSD_REG_VALUE      TEXT("CSDVersion")


// the signatures we are looking for in the regsitry so that we can patch up 

#ifdef _M_IX86
static  BYTE  SP3Sig[] = {0xbd, 0x9f, 0x13, 0xc5, 0x92, 0x12, 0x2b, 0x72,
                          0x4a, 0xba, 0xb6, 0x2a, 0xf9, 0xfc, 0x54, 0x46,
                          0x6f, 0xa1, 0xb4, 0xbb, 0x43, 0xa8, 0xfe, 0xf8,
                          0xa8, 0x23, 0x7d, 0xd1, 0x85, 0x84, 0x22, 0x6e,
                          0xb4, 0x58, 0x00, 0x3e, 0x0b, 0x19, 0x83, 0x88,
                          0x6a, 0x8d, 0x64, 0x02, 0xdf, 0x5f, 0x65, 0x7e,
                          0x3b, 0x4d, 0xd4, 0x10, 0x44, 0xb9, 0x46, 0x34,
                          0xf3, 0x40, 0xf4, 0xbc, 0x9f, 0x4b, 0x82, 0x1e,
                          0xcc, 0xa7, 0xd0, 0x2d, 0x22, 0xd7, 0xb1, 0xf0,
                          0x2e, 0xcd, 0x0e, 0x21, 0x52, 0xbc, 0x3e, 0x81,
                          0xb1, 0x1a, 0x86, 0x52, 0x4d, 0x3f, 0xfb, 0xa2,
                          0x9d, 0xae, 0xc6, 0x3d, 0xaa, 0x13, 0x4d, 0x18,
                          0x7c, 0xd2, 0x28, 0xce, 0x72, 0xb1, 0x26, 0x3f,
                          0xba, 0xf8, 0xa6, 0x4b, 0x01, 0xb9, 0xa4, 0x5c,
                          0x43, 0x68, 0xd3, 0x46, 0x81, 0x00, 0x7f, 0x6a,
                          0xd7, 0xd1, 0x69, 0x51, 0x47, 0x25, 0x14, 0x40,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#else // other than _M_IX86
static  BYTE  SP3Sig[] = {0x8a, 0x06, 0x01, 0x6d, 0xc2, 0xb5, 0xa2, 0x66,
                          0x12, 0x1b, 0x9c, 0xe4, 0x58, 0xb1, 0xf8, 0x7d,
                          0xad, 0x17, 0xc1, 0xf9, 0x3f, 0x87, 0xe3, 0x9c,
                          0xdd, 0xeb, 0xcc, 0xa8, 0x6b, 0x62, 0xd0, 0x72,
                          0xe7, 0xf2, 0xec, 0xd6, 0xd6, 0x36, 0xab, 0x2d,
                          0x28, 0xea, 0x74, 0x07, 0x0e, 0x6c, 0x6d, 0xe1,
                          0xf8, 0x17, 0x97, 0x13, 0x8d, 0xb1, 0x8b, 0x0b,
                          0x33, 0x97, 0xc5, 0x46, 0x66, 0x96, 0xb4, 0xf7,
                          0x03, 0xc5, 0x03, 0x98, 0xf7, 0x91, 0xae, 0x9d,
                          0x00, 0x1a, 0xc6, 0x86, 0x30, 0x5c, 0xc8, 0xc7,
                          0x05, 0x47, 0xed, 0x2d, 0xc2, 0x0b, 0x61, 0x4b,
                          0xce, 0xe5, 0xb7, 0xd7, 0x27, 0x0c, 0x9e, 0x2f,
                          0xc5, 0x25, 0xe3, 0x81, 0x13, 0x9d, 0xa2, 0x67,
                          0xb2, 0x26, 0xfc, 0x99, 0x9d, 0xce, 0x0e, 0xaf,
                          0x30, 0xf3, 0x30, 0xec, 0xa3, 0x0a, 0xfe, 0x16,
                          0xb6, 0xda, 0x16, 0x90, 0x9a, 0x9a, 0x74, 0x7a,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif      // _M_IX86

void CheckForSP3RSAOverwrite( void )
{
    // check for them having installed NTSP3 over the top of IE4, it nukes
    // the RSABASE reg stuff, so we have to re-do it. (our default platform is NT + SP3, but this
    // problem doesn't occur on NT5, so ignore it.

    OSVERSIONINFO osVer;

    ZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);

    if( GetVersionEx(&osVer) && (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) 
        && (osVer.dwMajorVersion == 4))
    {
        // now check to see we are on SP3 ...
        DWORD dwValue = 0;
        DWORD dwSize = sizeof( dwValue );
        
        if ( ERROR_SUCCESS == SHGetValue( HKEY_LOCAL_MACHINE, CSD_REG_PATH, CSD_REG_VALUE, NULL,
             &dwValue, &dwSize) && LOWORD( dwValue ) == 0x300 )
        {
            BYTE rgbSig[136];
            dwSize = sizeof(rgbSig);
            
            if (ERROR_SUCCESS == SHGetValue ( HKEY_LOCAL_MACHINE, RSA_PATH_TO_KEY, TEXT("Signature"), NULL,
                rgbSig, &dwSize))
            {
                if ((dwSize == sizeof(SP3Sig)) && 
                    (0 == memcmp(SP3Sig, rgbSig, sizeof(SP3Sig))))
                {
                    // need to do a DLLRegisterServer on RSABase
                    HINSTANCE hInst = LoadLibrary(TEXT("rsabase.dll"));
                    if ( hInst )
                    {
                        FARPROC pfnDllReg = GetProcAddress( hInst, "DllRegisterServer");
                        if ( pfnDllReg )
                        {
                            __try
                            {
                                pfnDllReg();
                            }
                            __except( EXCEPTION_EXECUTE_HANDLER)
                            {
                            }
                            __endexcept
                        }

                        FreeLibrary( hInst );
                    }
                }
            }
        }           
    }
}
#else
#define CheckForSP3RSAOverwrite() 
#endif


#define TEN_SECONDS (10 * 1000)

LONG WINAPI DwExceptionFilter(LPEXCEPTION_POINTERS pep)
{
    EXCEPTION_RECORD         *per;
    HANDLE                    hFileMap = NULL;
    DWSharedMem              *pdwsm = NULL;
    SECURITY_ATTRIBUTES       sa;
    LONG                      lReturn = 0;
    
    // we keep local copies of these in case another thread is trashing memory
    // it much more likely to trash the heap than our stack
    HANDLE                    hEventDone = NULL;          // event DW signals when done
    HANDLE                    hEventAlive = NULL;         // heartbeat event DW signals per EVENT_TIMEOUT
    HANDLE                    hMutex = NULL;              // to protect the signaling of EventDone  
    
    CHAR                      szCommandLine[MAX_PATH * 2];

    DWORD                     dwSize, dwType, dw;
    TCHAR                     tchURL[INTERNET_MAX_URL_LENGTH];
    
    BOOL                      fDwRunning;  
    
    STARTUPINFOA              si;
    PROCESS_INFORMATION       pi;
    
    // init
    if (pep)
    {
        per = pep->ExceptionRecord;
        if (EXCEPTION_BREAKPOINT == per->ExceptionCode)
            goto Cleanup;
    }

    // create shared memory
    memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    
    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0, 
                      sizeof(DWSharedMem), NULL);
    if (hFileMap == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }
        
    pdwsm = (DWSharedMem *) MapViewOfFile(hFileMap, 
                                          FILE_MAP_READ | FILE_MAP_WRITE,
                                          0, 0, 0);
    if (pdwsm == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }

    memset(pdwsm, 0, sizeof(DWSharedMem));

    hEventAlive = CreateEvent(&sa, FALSE, FALSE, NULL);
    hEventDone = CreateEvent(&sa, FALSE, FALSE, NULL);
    hMutex = CreateMutex(&sa, FALSE, NULL);

    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), 
                    GetCurrentProcess(), &pdwsm->hProc, PROCESS_ALL_ACCESS,
                    TRUE, 0))
    {
        lReturn = 1;
        goto Cleanup;
    }

    if (hEventAlive == NULL || hEventDone == NULL || hMutex == NULL
        || pdwsm->hProc == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }

    // setup interface structure
    pdwsm->pid = GetCurrentProcessId();
    pdwsm->tid = GetCurrentThreadId();
    pdwsm->hEventAlive = hEventAlive;
    pdwsm->hEventDone = hEventDone;
    pdwsm->hMutex = hMutex;
    pdwsm->dwSize = sizeof(DWSharedMem);
    pdwsm->pep = pep;
    if (pep)
        pdwsm->eip = (DWORD_PTR) pep->ExceptionRecord->ExceptionAddress;
    pdwsm->bfmsoctdsOffer = MSODWRESTARTQUIT;
    pdwsm->lcidUI = MLGetUILanguage();

    StrCpyNW(pdwsm->wzFormalAppName, L"Microsoft Internet Explorer", DW_APPNAME_LENGTH);

    StrCpyN(pdwsm->szRegSubPath, "Microsoft\\Office\\10.0\\Common", DW_MAX_REGSUBPATH);
    
    // Our language key?
    StrCpyN(pdwsm->szLCIDKeyValue, 
           "HKCU\\Software\\Microsoft\\Office\\10.0\\Common\\LanguageResources\\UILanguage", DW_MAX_PATH);

    // Hey, they're pointing to our PID!  That's cool.
    StrCpyN(pdwsm->szPIDRegKey, 
           "HKLM\\Software\\Microsoft\\Internet Explorer\\Registration\\DigitalProductID", DW_MAX_PATH);

    // Okay, I'll send it there.
    //
    dwSize = INTERNET_MAX_URL_LENGTH;

    if (ERROR_SUCCESS == SHGetValueA(HKEY_LOCAL_MACHINE,
                                     "Software\\Microsoft\\Internet Explorer\\Main",
                                     "IEWatsonURL",
                                     &dwType, tchURL, &dwSize))
    {
        StrCpyN(pdwsm->szServer, tchURL, DW_MAX_SERVERNAME);
    }
    else
    {
        StrCpyN(pdwsm->szServer, "watson.microsoft.com", DW_MAX_SERVERNAME);
    }

    // Do not set details string.
    //StrCpyNW(pdwsm->wzErrorMessage, L"Internet Explorer has encountered an internal error.", DW_MAX_ERROR_CWC);

    // Core modules
    StrCpyNW(pdwsm->wzDotDataDlls, L"browseui.dll\0shdocvw.dll\0mshtml.dll\0urlmon.dll\0wininet.dll\0", DW_MAX_PATH);

    // This will usually be "IEXPLORE.EXE"
    GetModuleFileNameWrapW(NULL, pdwsm->wzModuleFileName, DW_MAX_PATH);

    // ok, now we don't want to accidently change this
        
    memset(&si, 0, sizeof(STARTUPINFOA));
    si.cb = sizeof(STARTUPINFOA);
    memset(&pi, 0, sizeof(PROCESS_INFORMATION));
    
    wnsprintfA(szCommandLine, sizeof(szCommandLine),
              "dw15 -x -s %u", 
              (DWORD_PTR) hFileMap); 

    if (CreateProcessA(NULL, szCommandLine, NULL, NULL, TRUE, 
                  CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS, NULL,
                  NULL, &si, &pi))
    {
        fDwRunning = TRUE;
        while (fDwRunning)
        {
            if (WaitForSingleObject(hEventAlive, DW_TIMEOUT_VALUE) 
                == WAIT_OBJECT_0)
            {
                if (WaitForSingleObject(hEventDone, 1) == WAIT_OBJECT_0)
                {
                    fDwRunning = FALSE;
                }
                continue;
            }
                
             // we timed-out waiting for DW to respond, try to quit
            dw = WaitForSingleObject(hMutex, DW_TIMEOUT_VALUE);
            if (dw == WAIT_TIMEOUT)
                fDwRunning = FALSE; // either DW's hung or crashed, we must carry on  
            else if (dw == WAIT_ABANDONED)
            {
                fDwRunning = FALSE;
                ReleaseMutex(hMutex);
            }
            else
            {
                // DW has not woken up?
                if (WaitForSingleObject(hEventAlive, 1) != WAIT_OBJECT_0)
                    // tell DW we're through waiting for it's sorry self
                {
                    SetEvent(hEventDone);
                    fDwRunning = FALSE;
                }
                else
                {
                    // are we done
                    if (WaitForSingleObject(hEventDone, 1) 
                        == WAIT_OBJECT_0)
                        fDwRunning = FALSE;
                }
                ReleaseMutex(hMutex);
            }
        }

    } // end if CreateProcess succeeded
    
    
Cleanup:
    if (hEventAlive)
        CloseHandle(hEventAlive);
    if (hEventDone)
        CloseHandle(hEventDone);
    if (hMutex)
        CloseHandle(hMutex);
    if (pdwsm)
        UnmapViewOfFile(pdwsm);
    if (hFileMap)
        CloseHandle(hFileMap);

    return lReturn;
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
#ifdef DEBUG
    CcshellGetDebugFlags();
#endif
    int  iRet = TRUE;
    HWND hwndDesktop ;
    BOOL fNowait = FALSE;
    BOOL fInproc = FALSE;
    BOOL fEval   = FALSE;
#ifdef UNIX
    BOOL fRemote = FALSE;
#endif


    // DwExceptionFilter(NULL);  For testing.

    while (1) {
#ifdef UNIX
        if (IsCommandSwitch(lpszCmdLine, TEXT("-remote"), TRUE))
        {
            fRemote = TRUE;
        }
#endif
        if (IsCommandSwitch(lpszCmdLine, TEXT("-eval"), TRUE))
        {
            fInproc = TRUE;
            fEval   = TRUE;
        } else if (IsCommandSwitch(lpszCmdLine, TEXT("-new"), TRUE))
        {
            fInproc = TRUE;
        }
        else if (IsCommandSwitch(lpszCmdLine, TEXT("-nowait"), TRUE)) 
        {
            fNowait = TRUE;
        } 
        else
            break;
    }

#ifndef UNIX
    if (!GetModuleHandle(TEXT("IEXPLORE.EXE")))
    {
        // For side by side install auto dection, if IExplore.exe is renamed, assume this is a side by side do dah
        // and we want to run in "evaluation" mode.
        fInproc = TRUE;
        fEval   = TRUE;        
    }
#endif

    
    // Should we run browser in a new process?
    if (fInproc || SHRegGetBoolUSValue(c_szBrowseNewProcessReg, c_szBrowseNewProcess, FALSE, FALSE))
    {
        goto InThisProcess;
    }

#ifdef UNIX
    if (!(fRemote && ConnectRemoteIE(lpszCmdLine, hinst)))
#endif
    
    if (WhichPlatform() == PLATFORM_INTEGRATED && (hwndDesktop = GetShellWindow()))
    {
        //
        // Integrated browser mode - package up a bunch of data into a COPYDATASTRUCT,
        // and send it to the desktop window via SendMessage(WM_COPYDATA).
        //
        COPYDATASTRUCT cds;
        cds.dwData = nCmdShow;

        //
        // First piece of data is a wide string version of the command line params.
        //
        LPWSTR pwszBuffer = (LPWSTR)LocalAlloc(LPTR, (INTERNET_MAX_URL_LENGTH + 2 * MAX_IEEVENTNAME) * sizeof(WCHAR));;
        if (pwszBuffer)
        {
#ifdef UNICODE
            lstrcpy(pwszBuffer, lpszCmdLine);
#else
            int cch = MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, pwszBuffer, INTERNET_MAX_URL_LENGTH);
            Assert(cch);
#endif
            cds.lpData = pwszBuffer;
            cds.cbData = sizeof(WCHAR) * (lstrlenW((LPCWSTR)cds.lpData) + 1);

            //
            // Second piece of data is the event to fire when
            // the browser window reaches WM_CREATE.
            //
            HANDLE hEventReady = AppendEvent(&cds);
            if (hEventReady)
            {
                //
                // Third piece of data is the event to fire when
                // the browser window closes.  This is optional,
                // we only create it (and wait for it) when there
                // are command line parameters.
                //
                HANDLE hEventDead = NULL;

                // The hard part is to figure out when we need the command line and when
                // we don't. For the most part if there is a command line we will assume that
                // we will need it (potentially) we could look for the -nowait flag.  But then
                // there are others like NetManage ECCO Pro who do their equiv of ShellExecute
                // who don't pass a command line...

                if ((*lpszCmdLine || CheckForNeedingAppCompatWindow()) && !fNowait)
                {
                    hEventDead = AppendEvent(&cds);
                }
                
                if (hEventDead || !*lpszCmdLine || fNowait)
                {
                    //
                    // Send that message!
                    //
                    int iRet = (int)SendMessage(hwndDesktop, WM_COPYDATA, (WPARAM)hwndDesktop, (LPARAM)&cds);

                    //
                    // Nobody needs the string anymore.
                    //
                    LocalFree(pwszBuffer);
                    pwszBuffer = NULL;

                    if (iRet)
                    {
                        //
                        // First, we wait for the browser window to hit WM_CREATE.
                        // When this happens, all DDE servers will have been registered.
                        //
                        DWORD dwRet = WaitForSingleObject(hEventReady, TEN_SECONDS);
                        ASSERT(dwRet == WAIT_OBJECT_0);

                        if (hEventDead)
                        {
                            //
                            // Create an offscreen IE-lookalike window
                            // owned by this process for app compat reasons.
                            //
                            HWND hwnd = CreateAppCompatWindow(hinst);

                            do
                            {
                                //
                                // Calling MsgWait... will cause any threads blocked
                                // on WaitForInputIdle(IEXPLORE) to resume execution.
                                // This is fine because the browser has already
                                // registered its DDE servers by now.
                                //
                                dwRet = MsgWaitForMultipleObjects(1, &hEventDead, FALSE, INFINITE, QS_ALLINPUT);

                                if (dwRet == WAIT_OBJECT_0)
                                {
                                    //
                                    // Kill our helper window cleanly too.
                                    //
                                    DestroyWindow(hwnd);
                                }

                                MSG msg;
                                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                                {
                                    if (msg.message == WM_QUIT)
                                    {
                                        //
                                        // We got a quit message, drop out.
                                        //
                                        dwRet = WAIT_OBJECT_0;
                                        break;
                                    }

                                    TranslateMessage(&msg);
                                    DispatchMessage(&msg);
                                }
                            }
                            while(dwRet != WAIT_OBJECT_0);
                        }
                    }

                    iRet = !iRet;
                }
                if (hEventDead)
                {
                    CloseHandle(hEventDead);
                }

                CloseHandle(hEventReady);
            }
        }
        if (pwszBuffer)
        {
            LocalFree(pwszBuffer);
            pwszBuffer = NULL;
        }
    }        
    else
    {

InThisProcess:
        // Browser only mode, check the SP3 bug
        CheckForSP3RSAOverwrite();

        if (fEval)
        {
            // Set "compat" mode user agent
            WarnCompatMode(hinst);

            // #75454... let the compat mode setup set useragent in HKLM.
            //SetCompatModeUserAgentString();
            
            // Run in eval mode. So we want everything from this dir.
            LoadLibrary("comctl32.DLL");
            LoadLibrary("browseui.DLL");            
            LoadLibrary("shdocvw.DLL");
            LoadLibrary("wininet.dll");
            LoadLibrary("urlmon.dll");
            LoadLibrary("mlang.dll");
            LoadLibrary("mshtml.dll");
            LoadLibrary("jscript.DLL");            
        }

        // On downlevel (non-Whistler), we set up a top-level exception filter so that we can report faults
        // using the Watson technology.
        //
        // In Whistler, this support is built in to the Kernel so we don't run this code.
        //
        if (!IsOS(OS_WHISTLERORGREATER))
        {

            DWORD  dw, dwSize, dwType;

            // As a policy check, look at HKLM before HKCU
            //
        
            dw = 1;  // Default to enabled.
            dwSize = sizeof(dw);

            if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                             "Software\\Microsoft\\Internet Explorer\\Main",
                                             "IEWatsonEnabled",
                                             &dwType, &dw, &dwSize))
            {
                // Check current user if we didn't find anything for the local machine.
                dwSize = sizeof(dw);
                SHGetValue(HKEY_CURRENT_USER,
                            "Software\\Microsoft\\Internet Explorer\\Main",
                            "IEWatsonEnabled",
                            &dwType, &dw, &dwSize);
            }

            if (dw)
            {
                SetUnhandledExceptionFilter(DwExceptionFilter);
            }
        }
                
        iRet = IEWinMain(lpszCmdLine, nCmdShow);
    }

    return iRet;
}

// DllGetLCID
//
// this API is for Office to retrieve our UI language
// when they are hosted by iexplore.
//
STDAPI_(LCID) DllGetLCID (IBindCtx * pbc)
{
     return MLGetUILanguage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\iexplore\msodw.h ===
#pragma once

/****************************************************************************
	MsoDW.h

	Owner: MRuhlen
	Copyright (c) 1999 Microsoft Corporation

	This files contains the handshake structure with which apps will launch
	DW (aka OfficeWatson, aka whatever the marketroids call it)
****************************************************************************/

#ifndef MSODW_H
#define MSODW_H
#pragma pack(push, msodw_h)
#pragma pack(4)

#define DW_TIMEOUT_VALUE	20000
#define DW_MUTEX_TIMEOUT    DW_TIMEOUT_VALUE / 2
#define DW_NOTIFY_TIMEOUT   120000 // 2 minutes
#define DW_MAX_ASSERT_CCH   1024
#define DW_MAX_PATH         260
#define DW_APPNAME_LENGTH	56
#define DW_MAX_SERVERNAME   DW_MAX_PATH
#define DW_MAX_ERROR_CWC    260 // must be at least max_path
#define DW_MAX_REGSUBPATH   200
#define DW_CMDLINE_RESPONSE "DwResponse="
#define DW_CMDLINE_REPORT   "DwReportResponse="

#define DW_BLUEPATH         "blue"
#define DW_WHISTLER_EVENTLOG_SOURCE L"Application Error"

// the following are the fields that can be specified in a manifest file to 
// launch DW in a file based reporting mode

// these are required

#define DW_MANIFEST_TITLENAME    L"TitleName="  
#define DW_MANIFEST_ERRORTEXT    L"ErrorText="
#define DW_MANIFEST_HDRTEXT      L"HeaderText="
#define DW_MANIFEST_ERRORSIG     L"ErrorSig="
#define DW_MANIFEST_ERRORDETAIL  L"ErrorDetail="
#define DW_MANIFEST_SERVERNAME   L"Server="
#define DW_MANIFEST_URL2         L"Stage2URL="
#define DW_MANIFEST_LCID         L"UI LCID="
#define DW_MANIFEST_DATAFILES    L"DataFiles="

// the following are optional, DW has default behavior for all of these

#define DW_MANIFEST_FLAGS        L"Flags="
#define DW_MANIFEST_BRAND        L"Brand="
#define DW_MANIFEST_EVENTSOURCE  L"EventLogSource="
#define DW_MANIFEST_EVENTID      L"EventID="
#define DW_MANIFEST_URL1         L"Stage1URL="
#define DW_MANIFEST_ERRORSUBPATH L"ErrorSubPath="
#define DW_MANIFEST_REGSUBPATH   L"RegSubPath="
#define DW_MANIFEST_DIGPIDPATH   L"DigPidRegPath="    
#define DW_MANIFEST_ICONFILE     L"IconFile="
#define DW_MANIFEST_CAPTION      L"Caption="
#define DW_MANIFEST_REPORTEE     L"Reportee="
#define DW_MANIFEST_PLEA         L"Plea="
#define DW_MANIFEST_REPORTBTN    L"ReportButton="
#define DW_MANIFEST_NOREPORTBTN  L"NoReportButton="

// Seperator for file lists (Manifest DataFiles and Exception Additional Files
#define DW_FILESEPA              '|'
#define DW_FILESEP_X(X)          L##X
#define DW_FILESEP_Y(X)          DW_FILESEP_X(X)
#define DW_FILESEP               DW_FILESEP_Y(DW_FILESEPA)

#ifdef DEBUG
enum // AssertActionCodes
{
	DwAssertActionFail = 0,
	DwAssertActionDebug,
	DwAssertActionIgnore,
	DwAssertActionAlwaysIgnore,
	DwAssertActionIgnoreAll,
	DwAssertActionQuit,
};	
#endif

//  Caller is the app that has experienced an exception and launches DW

enum // ECrashTimeDialogStates	// msoctds
{
	msoctdsNull          = 0x00000000,
	msoctdsQuit          = 0x00000001,
	msoctdsRestart       = 0x00000002,
	msoctdsRecover       = 0x00000004,
	msoctdsUnused        = 0x00000008,
	msoctdsDebug         = 0x00000010,
};

#define MSODWRECOVERQUIT (msoctdsRecover | msoctdsQuit)
#define MSODWRESTARTQUIT (msoctdsRestart | msoctdsQuit)
#define MSODWRESPONSES (msoctdsQuit | msoctdsRestart | msoctdsRecover)

// THIS IS PHASED OUT -- DON'T USE
enum  // EMsoCrashHandlerFlags  // msochf
{
	msochfNull                = 0x00000000,

	msochfUnused              = msoctdsUnused,  // THESE MUST BE THE SAME
	msochfCanRecoverDocuments = msoctdsRecover,
	
	msochfObsoleteCanDebug    = 0x00010001,  // not used anymore
	msochfCannotSneakyDebug   = 0x00010002,  // The "hidden" debug feature won't work
	msochfDefaultDontReport   = 0x00010004,
	msochReportingDisabled    = 0x00010008,  // User cannot change default reporting choice
};


// 
enum  // EMsoCrashHandlerResults  // msochr
{
	msochrNotHandled        = msoctdsNull,
	msochrUnused            = msoctdsUnused,
	msochrDebug             = msoctdsDebug,
	msochrRecoverDocuments  = msoctdsRecover,
	msochrRestart           = msoctdsRestart,
	msochrQuit              = msoctdsQuit,
};

enum  // EDwBehaviorFlags
{
	fDwOfficeApp            = 0x00000001,
	fDwNoReporting          = 0x00000002,   // don't report
	fDwCheckSig             = 0x00000004,   // checks the signatures of the App/Mod list
	fDwGiveAppResponse      = 0x00000008,   // hands szResponse to app on command line
	fDwWhistler             = 0x00000010,   // Whistler's exception handler is caller
	fDwUseIE                = 0x00000020,   // always launch w/ IE
	fDwDeleteFiles          = 0x00000040,   // delete the additional files after use.
	fDwHeadless             = 0x00000080,   // DW will auto-report. policy required to enable
	fDwUseHKLM              = 0x00000100,   // DW reg from HKLM instead of HKCU
	fDwUseLitePlea          = 0x00000200,   // DW won't suggest product change in report plea
	fDwUsePrivacyHTA        = 0x00000400,   // DW won't suggest product change in report plea
	fDwManifestDebug        = 0x00000800,   // DW will provide a debug button in manifset mode
	fDwReportChoice         = 0x00001000,   // DW will tack on the command line of the user
};


typedef struct _DWSharedMem10
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	char szFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	char szInformalAppName[DW_APPNAME_LENGTH]; // the app name for display to user (ie "Word")
	char szModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileNameA(NULL)
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC];    // Error message to show user.
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#ifdef DEBUG
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem10;

typedef struct _DWSharedMem15
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	WCHAR wzFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	WCHAR wzModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileName(NULL)
	
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC]; // (optional) Error details message to show user.
	WCHAR wzErrorText[DW_MAX_ERROR_CWC];    // (optional) substitue error text (e.g. "you might have lost information")
	WCHAR wzCaption[DW_MAX_ERROR_CWC];      // (optional) substitue caption
	WCHAR wzHeader[DW_MAX_ERROR_CWC];       // (optional) substitue main dialog header text
	WCHAR wzReportee[DW_APPNAME_LENGTH];    // (optional) on whom's behalf we request the report
	WCHAR wzPlea[DW_MAX_ERROR_CWC];         // (optional) substitue report plea text
	WCHAR wzReportBtn[DW_APPNAME_LENGTH];   // (optional) substitue "Report Problem" text
	WCHAR wzNoReportBtn[DW_APPNAME_LENGTH]; // (optional) substitue "Don't Report" text
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	LCID lcidUI;                       // will try this UI langauge if non-zero
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#if 0
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem15, DWSharedMem;

#pragma pack(pop, msodw_h)
#endif // MSODW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\backtrace.h ===
struct BACKTRACE {
BACKTRACE(const BACKTRACE &other);
~BACKTRACE();
BACKTRACE(INT nMax, INT nSkip); 
bool BACKTRACE::operator <(const BACKTRACE &second) const;
BOOL BACKTRACE::ComputeSymbolic(BOOL fOverWrite);
LPSTR pszSymbolicStack;
int nQuick;
LPVOID *ppNumeric;
int cch;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\bands.h ===
#ifndef BANDS_H_
#define BANDS_H_

#include "cowsite.h"

// this is a virtual class!
class CToolBand : public IDeskBand
                , public CObjectWithSite
                , public IInputObject
                , public IPersistStream
                , public IOleCommandTarget
                , public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) = 0;
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm) = 0;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                             IUnknown* punkToolbarSite,
                                             BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) PURE;

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

protected:
    CToolBand();
    virtual ~CToolBand();

    HRESULT _BandInfoChanged();

    int         _cRef;
    HWND        _hwnd;
    HWND        _hwndParent;
    //IUnknown* CObjectWithSite::_punkSite;
    BOOL        _fCanFocus:1;   // we accept focus (see UIActivateIO)
    DWORD       _dwBandID;
};


IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl);
IDeskBand* CSearchBand_Create();

#define CX_FILENAME_AVG    (6 * 12)    // '8.3' name in 'typical' font (approx)






class CToolbarBand: public CToolBand,
                    public IWinEventHandler
{
public:
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

protected:
    HRESULT _PushChevron(BOOL bLast);
    LRESULT _OnHotItemChange(LPNMTBHOTITEM pnmtb);
    virtual LRESULT _OnNotify(LPNMHDR pnmh);
};



#endif  // BANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\browseui.h ===
// #include <shlobj.h> or <shellapi.h> before this to get the right
// BROWSEUIAPI macro definitions.
#ifdef BROWSEUIAPI

#ifndef _BROWSEUI_H_
#define _BROWSEUI_H_

#include <iethread.h>
#include "fldset.h"

BROWSEUIAPI SHOpenNewFrame(LPITEMIDLIST pidlNew, ITravelLog *ptl, DWORD dwBrowserIndex, UINT uFlags);

BROWSEUIAPI_(BOOL) SHOpenFolderWindow(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(BOOL) SHParseIECommandLine(LPCWSTR * ppszCmdLine, IETHREADPARAM * piei);
BROWSEUIAPI_(IETHREADPARAM*) SHCreateIETHREADPARAM(LPCWSTR pszCmdLineIn, int nCmdShowIn, ITravelLog *ptlIn, IEFreeThreadedHandShake* piehsIn);
BROWSEUIAPI_(IETHREADPARAM*) SHCloneIETHREADPARAM(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(void) SHDestroyIETHREADPARAM(IETHREADPARAM* piei);
#ifndef _SHELL32_   // shell32 has its own implementation of this function
BROWSEUIAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);
#endif // _SHELL32_
// Exported from browseui, but also in shell\lib\brutil.cpp -- why?
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);

//
// The following four apis are exported for use by the channel oc (shdocvw).
// If the channel oc is moved into browseui these protoypes can be removed.
//
BROWSEUIAPI_(LPITEMIDLIST) Channel_GetFolderPidl(void);
BROWSEUIAPI_(IDeskBand *) ChannelBand_Create(LPCITEMIDLIST pidlDefault);
#ifndef _SHELL32_   // shell32 has its own implementation these functions
BROWSEUIAPI_(void) Channels_SetBandInfoSFB(IUnknown* punkBand);
BROWSEUIAPI IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);
#endif // _SHELL32_
//
// Exported to support IE4 channel quick launch button.
//
BROWSEUIAPI_(HRESULT) Channel_QuickLaunch(void);

// NOTE: this export is new to IE5, so it can move to browseui
// along with the rest of this proxy desktop code
BROWSEUIAPI_(BOOL) SHOnCWMCommandLine(LPARAM lParam);

BROWSEUIAPI_(void) SHCreateSavedWindows(void);

BROWSEUIAPI SHCreateBandForPidl(LPCITEMIDLIST pidl, IUnknown** ppunk, BOOL fAllowBrowserBand);

BROWSEUIAPI_(DWORD) IDataObject_GetDeskBandState(IDataObject *pdtobj);

//-------------------------------------------------------------------------
//
// Default folder settings
//
//  Make sure to keep INIT_DEFFOLDERSETTINGS in sync.
//
//  dwDefRevCount is used to make sure that "set as settings for all new
//  folders" works.  When settings are loaded from the cache, we check
//  the dwDefRevCount.  If it's different from the one stored as the
//  global settings then it means that somebody changed the global settings
//  since we saved our settings, so we chuck our settings and use the
//  global settings.

typedef struct {
    BOOL bDefStatusBar : 1;     // win95
    BOOL bDefToolBarSingle : 1; // win95
    BOOL bDefToolBarMulti : 1;  // win95
    BOOL bUseVID : 1;           // nash.1

    UINT uDefViewMode;          // win95
    UINT fFlags;                // nash.0 - additional flags that get or'ed in
    SHELLVIEWID vid;            // nash.1

    DWORD dwStructVersion;      // nash.2
    DWORD dwDefRevCount;        // nash.3 - Rev count of the default folder settings

    DWORD dwViewPriority;       // whistler - view priority so we can tell the difference between "all like this" and "reset"

} DEFFOLDERSETTINGS;

typedef struct {
    BOOL bDefStatusBar : 1;     // win95
    BOOL bDefToolBarSingle : 1; // win95
    BOOL bDefToolBarMulti : 1;  // win95
    BOOL bUseVID : 1;           // nash.1

    UINT uDefViewMode;          // win95
    UINT fFlags;                // nash.0 - additional flags that get or'ed in
    SHELLVIEWID vid;            // nash.1

    DWORD dwStructVersion;      // nash.2
    DWORD dwDefRevCount;        // nash.3 - Rev count of the default folder settings
} DEFFOLDERSETTINGS_W2K;

#define DFS_NASH_VER 3
#define DFS_WHISTLER_VER 4
#define DFS_CURRENT_VER 4
#define DFS_VID_Default VID_WebView

//
//  This macro is used to initialize the default `default folder settings'.
//
#define INIT_DEFFOLDERSETTINGS                          \
    {                                                   \
        !(IsOS(OS_WHISTLERORGREATER) && (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL))),           /* bDefStatusBar        */      \
        TRUE,           /* bDefToolBarSingle    */      \
        FALSE,          /* bDefToolBarMulti     */      \
        TRUE,           /* bUseVID              */      \
        FVM_ICON,       /* uDefViewMode         */      \
        0              ,/* fFlags               */      \
        { 0, 0, 0, { 0, 0,  0,  0,  0,  0,  0,  0 } }, /* vid                  */      \
        DFS_CURRENT_VER,/* dwStructVersion      */      \
        0,              /* dwDefRevCount        */      \
        VIEW_PRIORITY_CACHEMISS /*dwViewPriority*/      \
    }                                                   \

#undef  INTERFACE
#define INTERFACE   IGlobalFolderSettings

DECLARE_INTERFACE_(IGlobalFolderSettings, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGlobalFolderSettings methods ***
    STDMETHOD(Get)(THIS_ DEFFOLDERSETTINGS *pdfs, int cbDfs) PURE;
    STDMETHOD(Set)(THIS_ const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags) PURE;
};

//
//  Flags for IGlobalFolderSettings::Set
//
#define GFSS_SETASDEFAULT   0x0001  // These settings become default
#define GFSS_VALID          0x0001  // Logical-or of all valid flags

#ifndef _SHELL32_   // shell32 has its own implementation these functions
// FEATURE these two are TEMPORARILY exported for the favorites to shdocvw split
BROWSEUIAPI_(HRESULT) SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);
BROWSEUIAPI_(BOOL)    GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
#endif // _SHELL32_

int SHDosDateTimeToVariantTime(unsigned short wDosDate, unsigned short wDosTime, VARIANT * pvtime);
int SHVariantTimeToDosDateTime(const VARIANT * pvtime, unsigned short * pwDosDate, unsigned short * pwDosTime);
int SHVariantTimeToSystemTime(const VARIANT * pvtime, SYSTEMTIME * pst);

#define REG_MEDIA_STR           TEXT("Software\\Microsoft\\Internet Explorer\\Media")
#define REG_WMP8_STR            TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{6BF52A52-394A-11d3-B153-00C04F79FAA6}")

#endif // _BROWSEUI_H_

#endif // BROWSEUIAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\batmeter.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       BATMETER.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        31 Dec 1993
*
*
*******************************************************************************/

// Private BatMeter window message.
#define WM_DESTROYBATMETER WM_USER+100

// This structure encapsulates what is displayed for each battery
// and the composite system.

typedef struct _BATTERY_STATE{
    ULONG                  ulSize;                 // Size of structure.
    struct _BATTERY_STATE  *bsNext;                // Next in list
    struct _BATTERY_STATE  *bsPrev;                // Previous in list
    ULONG                  ulBatNum;               // Display battery number.
    ULONG                  ulTag;                  // Zero implies no battery.
    HANDLE                 hDevice;                // Handle to the battery device.
#ifdef WINNT
    HDEVNOTIFY             hDevNotify;             // Device notification handle.
#endif
    UINT                   uiIconIDcache;          // Cache of the last Icon ID.
    HICON                  hIconCache;             // Cache of the last Icon handle.
    HICON                  hIconCache16;           // As above but 16x16.
    LPTSTR                 lpszDeviceName;         // The name of the battery device
    ULONG                  ulFullChargedCapacity;  // Same as PBATTERY_INFORMATION->FullChargedCapacity.
    ULONG                  ulPowerState;           // Same flags as PBATTERY_STATUS->PowerState.
    ULONG                  ulBatLifePercent;       // Battery life remaining as percentage.
    ULONG                  ulBatLifeTime;          // Battery life remaining as time in seconds.
    ULONG                  ulLastTag;              // Previous value of ulTag.
    ULONG                  ulLastPowerState;       // Previous value of ulPowerState.
    ULONG                  ulLastBatLifePercent;   // Previous value of ulBatLifePercent.
    ULONG                  ulLastBatLifeTime;      // Previous value of ulBatLifeTime.
} BATTERY_STATE, *PBATTERY_STATE;

// Power management UI help file:
#define PWRMANHLP TEXT("PWRMN.HLP")

// Number of batteries that battery meter can display.
#define NUM_BAT 8

#define BATTERY_RELATED_FLAGS (BATTERY_FLAG_HIGH | BATTERY_FLAG_LOW | BATTERY_FLAG_CRITICAL | BATTERY_FLAG_CHARGING | BATTERY_FLAG_NO_BATTERY)

// Public function prototypes:
BOOL PowerCapabilities();
BOOL BatMeterCapabilities(PUINT*);
BOOL UpdateBatMeter(HWND, BOOL, BOOL, PBATTERY_STATE);
HWND CreateBatMeter(HWND, HWND, BOOL, PBATTERY_STATE);
HWND DestroyBatMeter(HWND);

// DisplayFreeStr bFree parameters:
#define FREE_STR    TRUE
#define NO_FREE_STR FALSE

// Private functions implemented in BATMETER.C
LPTSTR  CDECL     LoadDynamicString( UINT StringID, ... );
LPTSTR            DisplayFreeStr(HWND, UINT, LPTSTR, BOOL);
LRESULT CALLBACK  BatMeterDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL              SwitchDisplayMode(HWND, BOOL);
BOOL              UpdateBatMeterProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
UINT              GetBatteryDriverNames(LPTSTR*);
BOOL              UpdateDriverList(LPTSTR*, UINT);
VOID              FreeBatteryDriverNames(LPTSTR*);
UINT              MapBatInfoToIconID(PBATTERY_STATE);
HICON PASCAL      GetBattIcon(HWND, UINT, HICON, BOOL, UINT);

// Private functions implemented in DETAILS.C
LRESULT CALLBACK  BatDetailDlgProc(HWND, UINT, WPARAM, LPARAM);

// WalkBatteryState pbsStart parameters:
#define ALL     &g_bs
#define DEVICES g_bs.bsNext

// WalkBatteryState enum proc declaration.
typedef LRESULT (CALLBACK *WALKENUMPROC)(PBATTERY_STATE, HWND, LPARAM, LPARAM);

// RemoveMissingProc lParam2 parameters:
#define REMOVE_MISSING  0
#define REMOVE_ALL      1

// Private functions implemented in BATSTATE.C
BOOL WalkBatteryState(PBATTERY_STATE, WALKENUMPROC, HWND, LPARAM, LPARAM);
BOOL RemoveBatteryStateDevice(PBATTERY_STATE);
BOOL RemoveMissingProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL FindNameProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL UpdateBatInfoProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL SimUpdateBatInfoProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);

void SystemPowerStatusToBatteryState(LPSYSTEM_POWER_STATUS, PBATTERY_STATE);

PBATTERY_STATE AddBatteryStateDevice(LPTSTR, ULONG);
PBATTERY_STATE SimAddBatteryStateDevice(LPTSTR, ULONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\brutil.h ===
#ifndef _BRUTIL_H_
#define _BRUTIL_H_

STDAPI_(BOOL) IsBrowseNewProcess();
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer();
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut);
STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk);
STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib);
STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg);
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid);
STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl);
STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName);
STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName);
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch);
STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl);
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout);
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);
STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj);
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl);
STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath);
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI GetBrowserFrameOptions(IUnknown *punkFolder, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf);

// non-munging menu operations to work around the menu munging code
// in the shlwapi wrappers. for more info see the comment in the brutil.cpp.

STDAPI_(HMENU)  LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName);
STDAPI_(BOOL)   InsertMenu_PrivateNoMungeW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
STDAPI_(HMENU)  LoadMenuPopup_PrivateNoMungeW(UINT id);

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl);
HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl);
BOOL IsSpecialUrl(LPCWSTR pchURL);

void DrawFocusRectangle (HWND hwnd, HDC hdc);

void RenderStringToEditControlW (HWND hwndDlg,LPCWSTR pwsz,WNDPROC wndproc, UINT uID);

#endif // _BRUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\bands.cpp ===
#include "bands.h"

#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

//=================================================================
// Implementation of CToolBand
//=================================================================

ULONG CToolBand::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CToolBand::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CToolBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CToolBand, IDeskBand),         // IID_IDeskBand
        QITABENTMULTI(CToolBand, IOleWindow, IDeskBand),        // IID_IOleWindod
        QITABENTMULTI(CToolBand, IDockingWindow, IDeskBand),    // IID_IDockingWindow
        QITABENT(CToolBand, IInputObject),      // IID_IInputObject
        QITABENT(CToolBand, IOleCommandTarget), // IID_IOleCommandTarget
        QITABENT(CToolBand, IServiceProvider),  // IID_IServiceProvider
        QITABENT(CToolBand, IPersistStream),    // IID_IPersistStream
        QITABENTMULTI(CToolBand, IPersist, IPersistStream),     // IID_IPersist
        QITABENT(CToolBand, IObjectWithSite),   // IID_IObjectWithSite
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

//  *** IOleCommandTarget methods ***

HRESULT CToolBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return E_NOTIMPL;
}

//  *** IServiceProvider methods ***

HRESULT CToolBand::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
}

//  *** IOleWindow methods ***

HRESULT CToolBand::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    if (*lphwnd)
        return S_OK;

    return E_FAIL;
}

//  *** IInputObject methods ***

HRESULT CToolBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::HasFocusIO()
{
    HRESULT hres;
    HWND hwndFocus = GetFocus();

    hres = SHIsChildOrSelf(_hwnd, hwndFocus);
    ASSERT(hwndFocus != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);

    return hres;
}

HRESULT CToolBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    TraceMsg(DM_FOCUS, "ctb.uiaio(fActivate=%d) _fCanFocus=%d _hwnd=%x GF()=%x", fActivate, _fCanFocus, _hwnd, GetFocus());

    if (!_fCanFocus) {
        TraceMsg(DM_FOCUS, "ctb.uiaio: !_fCanFocus ret S_FALSE");
        return S_FALSE;
    }

    if (fActivate)
    {
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        SetFocus(_hwnd);
    }

    return S_OK;
}

HRESULT CToolBand::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    return S_OK;
}


HRESULT CToolBand::ShowDW(BOOL fShow)
{
    return S_OK;
}

HRESULT CToolBand::SetSite(IUnknown *punkSite)
{
    if (punkSite != _punkSite)
    {
        IUnknown_Set(&_punkSite, punkSite);
        IUnknown_GetWindow(_punkSite, &_hwndParent);
    }
    return S_OK;
}

HRESULT CToolBand::_BandInfoChanged()
{
    VARIANTARG v = {0};
    VARIANTARG* pv = NULL;
    if (_dwBandID != (DWORD)-1)
    {
        v.vt = VT_I4;
        v.lVal = _dwBandID;
        pv = &v;
    }
    else
    {
        // if this fires, fix your band's GetBandInfo to set _dwBandID.
        // o.w. it's a *big* perf loss since we refresh *all* bands rather
        // than just yours.
        // do *not* remove this ASSERT, bad perf *is* a bug.
        ASSERT(_dwBandID != (DWORD)-1);
    }
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, pv, NULL);
}

//  *** IPersistStream methods ***

HRESULT CToolBand::IsDirty(void)
{
    return S_FALSE;     // never be dirty
}

HRESULT CToolBand::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

CToolBand::CToolBand() : _cRef(1)
{
    _dwBandID = (DWORD)-1;
    DllAddRef();
}

CToolBand::~CToolBand()
{
    ASSERT(_hwnd == NULL);      // CloseDW was called
    ASSERT(_punkSite == NULL);  // SetSite(NULL) was called

    DllRelease();
}

HRESULT CToolBand::CloseDW(DWORD dw)
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    
    return S_OK;
}


//=================================================================
// Implementation of CToolbarBand
//=================================================================
// Class for bands whose _hwnd is a toolbar control.  Implements
// functionality generic to all such bands (e.g. hottracking 
// behavior).
//=================================================================

HRESULT CToolbarBand::_PushChevron(BOOL bLast)
{
    if (_dwBandID == (DWORD)-1)
        return E_UNEXPECTED;

    VARIANTARG v;
    v.vt = VT_I4;
    v.lVal = bLast ? DBPC_SELECTLAST : DBPC_SELECTFIRST;

    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
}

LRESULT CToolbarBand::_OnHotItemChange(LPNMTBHOTITEM pnmtb)
{
    LRESULT lres = 0;

    if (!(pnmtb->dwFlags & (HICF_LEAVING | HICF_MOUSE)))
    {
        // check to see if new hot button is clipped.  if it is,
        // then we pop down the chevron menu.
        RECT rc;
        GetClientRect(_hwnd, &rc);

        int iButton = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, pnmtb->idNew, 0);
        DWORD dwEdge = SHIsButtonObscured(_hwnd, &rc, iButton);
        if (dwEdge)
        {
            //
            // Only pop down the menu if the button is obscured
            // along the axis of the toolbar
            //
            BOOL fVertical = (ToolBar_GetStyle(_hwnd) & CCS_VERT);

            if ((fVertical && (dwEdge & (EDGE_TOP | EDGE_BOTTOM)))
                || (!fVertical && (dwEdge & (EDGE_LEFT | EDGE_RIGHT))))
            {
                // clear hot item
                SendMessage(_hwnd, TB_SETHOTITEM, -1, 0);

                // figure out whether to highlight first or last button in dd menu
                int cButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
                BOOL bLast = (iButton == cButtons - 1);
                _PushChevron(bLast);
                lres = 1;
            }
        }
    }

    return lres;
}

LRESULT CToolbarBand::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;

    switch (pnmh->code)
    {
    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnmh);
        break;
    }

    return lres;
}

// *** IWinEventHandler methods ***

HRESULT CToolbarBand::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_OK;

    switch (dwMsg)
    {
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_WININICHANGE:
        InvalidateRect(_hwnd, NULL, TRUE);
        _BandInfoChanged();
        break;
    }

    return hres;
}

HRESULT CToolbarBand::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    else
        return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\brfcasep.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: brfcasep.h
//
//  Internal header shared between SHELL232 and SYNCUI
//
// History:
//  01-27-94 ScottH     Copied from brfcase.h
//
//---------------------------------------------------------------------------

#ifndef _BRFCASEP_H_
#define _BRFCASEP_H_

//===========================================================================
//
// IBriefcaseStg Interface
//
//  This is a private interface for use between the shell and the briefcase.
//
//  This interface is used by the Shell's IShellFolder implementation
// when it is bound to a folder that is (in) a briefcase.  The IShellView
// of the particular folder binds to this interface to open the briefcase
// database storage and optionally make modifications.  File-objects that
// are added to a folder in a briefcase are not added to the storage
// database until IBriefcaseStg::AddObject is called.  Keep in mind the
// difference between IBriefcaseStg and IShellFolder.  IBriefcaseStg
// simply provides access to the briefcase storage database--the file-system
// objects are only affected upon subsequent reconciliation using
// IBriefcaseStg::UpdateObject, unless otherwise noted.
//
//
// [Member functions]
//
//
// IBriefcaseStg::Initialize(pszFolder, hwndOwner)
//
//   Initializes the interface by specifying the folder for this storage
//   instance.  If the folder does not exist somewhere in a briefcase
//   storage hierarchy, then a briefcase database is created for this
//   folder.
//
// IBriefcaseStg::AddObject(pdtobj, pszFolderEx, uFlags, hwndOwner)
//
//   Adds a file-object(s) to the briefcase storage.  This function also
//   performs an update of the specific files to immediately make them
//   up-to-date.
//
//   Typically pdtobj refers to a file-object(s) outside the
//   briefcase.  Calling this function implies adding the object(s) to
//   the briefcase storage database in the folder that was specified by
//   IBriefcaseStg::Initialize().  This rule holds unless pszFolderEx is
//   non-NULL, in which case pdtobj is sync-associated to pszFolderEx
//   instead.
//
//   AddObject() returns NOERROR if the object(s) were added.  S_FALSE
//   is returned if the caller should handle the action (eg, moving
//   files from folder-to-folder within the briefcase).
//
// IBriefcaseStg::ReleaseObject(pdtobj, hwndOwner)
//
//   Releases a file-object(s) from the briefcase storage database.  This
//   does not delete the file from the file-system.
//
// IBriefcaseStg::UpdateObject(pdtobj, hwndOwner)
//
//   Performs a file-synchronization update to pdtobj.  If pdtobj refers to
//   the root of a briefcase storage hierarchy, the entire storage is updated.
//
// IBriefcaseStg::UpdateOnEvent(uEvent, hwndOwner)
//
//   Performs a complete update of the briefcase storage based on the
//   indicated event.  The event ordinals may be:
//
//      UOE_CONFIGCHANGED       Indicates a PnP DBT_CONFIGCHANGED message wants
//                              to be processed.  This occurs when a machine
//                              hot-docks.
//
//      UOE_QUERYCHANGECONFIG   Indicates a PnP DBT_QUERYCHANGECONFIG message
//                              wants to be processed.  This occurs when a
//                              machine is about to hot-undock.
//
// IBriefcaseStg::GetExtraInfo(pszName, uInfo, wParam, lParam)
//
//   Gets some specified extra info from the briefcase storage.  The
//   info is determined by uInfo, which is one of GEI_* values.
//
// IBriefcaseStg::Notify(pszPath, lEvent, puFlags, hwndOwner)
//
//   Sends a notify event to the briefcase storage, so it can mark
//   cached items stale.  If lEvent is NOE_RENAME, pszPath must be a double
//   null-terminated string, where the first is the old pathname, and the
//   second is the new pathname.  *puFlags is filled with flags pertaining
//   to what the member function did.  NF_REDRAWWINDOW means the window
//   needs to be redrawn.  NF_ITEMMARKED means the cached item in the
//   briefcase storage associated with pszPath was marked stale.
//
// IBriefcaseStg::GetRootOf(pszBuffer, cbBuffer)
//
//   Queries the briefcase storage for the root of the briefcase storage
//   hierarchy.
//
// IBriefcaseStg::FindFirst(pszBuffer, cbBuffer)
//
//   Finds the root of the first briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
// IBriefcaseStg::FindNext(pszBuffer, cbBuffer)
//
//   Finds the root of the next briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IBriefcaseStg

DECLARE_INTERFACE_(IBriefcaseStg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBriefcaseStg methods ***
    STDMETHOD(Initialize) (THIS_ LPCTSTR pszFolder, HWND hwnd) PURE;
    STDMETHOD(AddObject) (THIS_ LPDATAOBJECT lpdobj, LPCTSTR pszFolderEx, UINT uFlags, HWND hwnd) PURE;
    STDMETHOD(ReleaseObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateOnEvent) (THIS_ UINT uEvent, HWND hwnd) PURE;
    STDMETHOD(GetExtraInfo) (THIS_ LPCTSTR pszName, UINT uInfo, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Notify) (THIS_ LPCTSTR pszPath, LONG lEvent, UINT * puFlags, HWND hwndOwner) PURE;
    STDMETHOD(FindFirst) (THIS_ LPTSTR pszPath, int cchMax) PURE;
    STDMETHOD(FindNext) (THIS_ LPTSTR pszPath, int cchMax) PURE;
};

// Events for UpdateOnEvent member function
#define UOE_CONFIGCHANGED       1
#define UOE_QUERYCHANGECONFIG   2

// Flags for AddObject
#define AOF_DEFAULT             0x0000
#define AOF_UPDATEONREPLACE     0x0001
#define AOF_FILTERPROMPT        0x0002

// Notify events
#define NOE_RENAME              1L
#define NOE_RENAMEFOLDER        2L
#define NOE_CREATE              3L
#define NOE_CREATEFOLDER        4L
#define NOE_DELETE              5L
#define NOE_DELETEFOLDER        6L
#define NOE_DIRTY               7L
#define NOE_DIRTYFOLDER         8L
#define NOE_DIRTYALL            9L

// Flags that are returned by Notify member function
#define NF_REDRAWWINDOW     0x0001
#define NF_ITEMMARKED       0x0002

// Flags for GetExtraInfo                wParam        lParam
#define GEI_ROOT            1       //   cchBuf         pszBuf
#define GEI_ORIGIN          2       //   cchBuf         pszBuf
#define GEI_STATUS          3       //   cchBuf         pszBuf
#define GEI_DELAYHANDLE     4       //     --           phandle
#define GEI_DATABASENAME    5       //   cchBuf         pszBuf

typedef IBriefcaseStg *   LPBRIEFCASESTG;

// Special briefcase object struct
//
typedef struct _BriefObj
    {
    UINT    cbSize;             // size of allocated struct
    UINT    ibFileList;         // offset of file list in struct
    UINT    ibBriefPath;        // offset of briefcase path in struct
    UINT    cItems;             // count of file-system objects
    UINT    cbListSize;         // size of file list
    TCHAR   data[1];            // data
    } BriefObj, * PBRIEFOBJ;

// Helper macros for briefcase object struct
#define BOBriefcasePath(pbo)    ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibBriefPath))
#define BOFileList(pbo)         ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibFileList))
#define BOFileCount(pbo)        ((pbo)->cItems)
#define BOFileListSize(pbo)     ((pbo)->cbListSize)

// Clipboard format for above struct
//
#define CFSTR_BRIEFOBJECT  TEXT("Briefcase File Object")

#endif // _BRFCASEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\brutil.cpp ===
/*
NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 

This file is #include'd in browseui\ and shdocvw\ util.cpp. these are too small
to add an extra dependency, so they're just shared. ideally, these should move
to shlwapi or comctl32 or some lib or ...

NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
*/

#include "ccstock2.h"
#include "mluisupp.h"
#include "richedit.h" //for charformat2

STDAPI_(BOOL) IsBrowseNewProcess()
{
    return SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess"), TEXT("BrowseNewProcess"), FALSE, FALSE);
}

// Should we run browser in a new process?
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer()
{
    if (GetModuleHandle(TEXT("EXPLORER.EXE")))
        return IsBrowseNewProcess();

    return FALSE;   // Not in shell process so ignore browse new process flag
}

HRESULT _NavigateFrame(IUnknown *punkFrame, LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    HRESULT hr = E_OUTOFMEMORY;
    BSTR bstr = SysAllocStringT(pszPath);

    if (bstr)
    {
        if (fIsInternetShortcut)
        {
            IOleCommandTarget *pcmdt;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hr))
            {
                VARIANT varShortCutPath = {0};
                VARIANT varFlag = {0};

                varFlag.vt = VT_BOOL;
                varFlag.boolVal = VARIANT_TRUE;

                varShortCutPath.vt = VT_BSTR;
                varShortCutPath.bstrVal = bstr;

                hr = pcmdt->Exec(&CGID_Explorer, SBCMDID_IESHORTCUT, 0, &varShortCutPath, &varFlag);                
                pcmdt->Release();
            }
        }
        else
        {
            IWebBrowser2 *pwb;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser2, &pwb));
            if (SUCCEEDED(hr))
            {
                hr = pwb->Navigate(bstr, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                hr = pwb->put_Visible(VARIANT_TRUE);
                pwb->Release();
            }
        }
        SysFreeString(bstr);
    }
    return hr;
}

//
// Take a path or an URL and create a shorcut to navigare to it
//
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        hr = _NavigateFrame(punk, pszPath, fIsInternetShortcut);
        punk->Release();
    }
    
    return hr;
}
        


// If this is an internet shortcut (.url file), we want it to
// navigate using using the file name so the frame frame
// can read data beyond out of that file. this includes frame set
// navigation and data that script on the page may have stored.

/*
    Purpose : This function takes a path to a file. if that file is a .URL we try
    to navigate with that file name. this is because .URL files have extra data stored
    in them that we want to let script on the page get to. the exec we send here
    lets the frame know the .URL file that this came from

    Parameters : file name of .URL file (maybe) : In param
    pUnk :       Pointer to Object from which you can get the IOleCommandTarget

  returns:
    TRUE    handled
    FALSE   not handled, file might not be a .URL
*/

STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszExt = PathFindExtension(pszPath);
    // HACK: we hard code .URL. this should be a property of the file type
    if (0 == StrCmpI(pszExt, TEXT(".url")))
    {
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
        if (IsBrowseNewProcessAndExplorer())
            hr = IENavigateIEProcess(pszPath, TRUE);
        else
#endif
            hr = _NavigateFrame(punk, pszPath, TRUE);
    }

    return hr;
}

// get the win32 file system name (path) for the item
// and optional attributes
//
// pdwAttrib may be NULL
// in/out:
//      pdwAttrib   may be NULL, attributes to query on the item

STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib)
{
    HRESULT hres = E_FAIL;
    DWORD dwAttrib;

    if (pdwAttrib == NULL)
    {
        pdwAttrib = &dwAttrib;
        dwAttrib = SFGAO_FILESYSTEM;
    }
    else
        *pdwAttrib |= SFGAO_FILESYSTEM;

    if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, pdwAttrib)) &&
        (*pdwAttrib & SFGAO_FILESYSTEM))
    {
        STRRET str;
        hres = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str);
        if (SUCCEEDED(hres))
            StrRetToBuf(&str, pidl, pszPath, MAX_PATH);
    }
    return hres;
}

STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg)
{

    switch (lpmsg->message) {
    case WM_KEYUP:      // eat these (if we process corresponding WM_KEYDOWN)
    case WM_KEYDOWN:    // process these
        if (lpmsg->wParam != VK_TAB)
        {
            // all keydown messages except for the tab key should go straight to
            // the edit control -- unless the Ctrl key is down, in which case there
            // are 9 messages that should go straight to the edit control
#ifdef DEBUG
            if (lpmsg->wParam == VK_CONTROL)
                return S_FALSE;
#endif

            if (GetKeyState(VK_CONTROL) & 0x80000000)
            {
                switch (lpmsg->wParam)
                {
                case VK_RIGHT:
                case VK_LEFT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
                case VK_END:
                case VK_F4:
                case VK_INSERT:
                case VK_DELETE:
                case 'C':
                case 'X':
                case 'V':
                case 'A':
                case 'Z':
                    // these Ctrl+key messages are used by the edit control
                    // send 'em straight there
                    break;

                default:
                    return(S_FALSE);
                }
            }
            else
            {
                switch(lpmsg->wParam)
                {
                case VK_F5: // for refresh
                case VK_F6: // for cycle focus
                    return(S_FALSE);
                }
            }

            // Note that we return S_OK.
            goto TranslateDispatch;
        }
        break;


    case WM_CHAR:
TranslateDispatch:
        TranslateMessage(lpmsg);
        DispatchMessage(lpmsg);
        return(S_OK);
    }

    return S_FALSE;
}

// NOTE: dupe with shell32 util.cpp function
// like OLE GetClassFile(), but it only works on ProgID\CLSID type registration
// not real doc files or pattern matched files
//
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid)
{
    TCHAR szProgID[80];
    DWORD cb = SIZEOF(szProgID);
    if (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];

        StrCatBuff(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID));
        cb = SIZEOF(szCLSID);

        if (SHGetValue(HKEY_CLASSES_ROOT, szProgID, NULL, NULL, szCLSID, &cb) == ERROR_SUCCESS)
        {
            return GUIDFromString(szCLSID, pclsid) ? S_OK : E_FAIL;
        }
    }
    return E_FAIL;
}

#if 0 // not used yet
// IShellLink is #defined to IShellLinkA or IShellLinkW depending on compile flags,
// bug Win95 did not support IShellLinkW.  So call this function instead and you
// get the correct results regardless of what platform you are running on.
// REVIEW: In fact, we probably want these for ALL IShellLink functions...
//
LWSTDAPI IShellLink_GetPathA(IUnknown *punk, LPSTR pszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, char, cchBuf), "IShellLink_GetPathA: callre passed bad pszBuf/cchBuf");
    DEBUGWhackPathBufferA(pszBuf, cchBuf);

    if (cchBuf && pszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pszBuf = 0;

        IShellLinkA * pslA;
        hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
        if (SUCCEEDED(hres))
        {
            hres = pslA->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslA->Release();
        }
        else if (FAILED(hres))
        {
#ifdef UNICODE
            IShellLinkW *pslW;
            hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
            if (SUCCEEDED(hres))
            {
                WCHAR wszPath[MAX_BUF];
                LPWSTR pwszBuf = wszPath;
                UINT cch = ARRAYSIZE(wszPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPWSTR pwsz = LocalAlloc(LPTR, cchBuf * sizeof(WCHAR));
                    if (pwsz)
                    {
                        pwszBuf = pwsz;
                        cch = cchBuf;
                    }
                }

                hres = pslW->GetPath(pwszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHUnicodeToAnsi(pwszBuf, pszBuf, cchBuf);
                }

                pslW->Release();
            }
#endif
        }
    }

    return hres;
}

LWSTDAPI IShellLink_GetPathW(IUnknown *punk, LPWSTR pwszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pwszBuf && IS_VALID_WRITE_BUFFER(pwszBuf, WCHAR, cchBuf), "IShellLink_GetPathW: caller passed bad pwszBuf/cchBuf");
    DEBUGWhackPathBufferW(pwszBuf, cchBuf);

    if (cchBuf && pwszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pwszBuf = 0;

#ifdef UNICODE
        IShellLinkW * pslW;
        hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
        if (SUCCEEDED(hres))
        {
            hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslW->Release();
        }
        else if (FAILED(hres))
#endif
        {
            IShellLinkA *pslA;
            hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
            if (SUCCEEDED(hres))
            {
                char szPath[MAX_BUF];
                LPSTR pszBuf = szPath;
                UINT cch = ARRAYSIZE(szPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPSTR psz = LocalAlloc(LPTR, cchBuf * sizeof(char));
                    if (psz)
                    {
                        pszBuf = psz;
                        cch = cchBuf;
                    }
                }

                hres = pslA->GetPath(pszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHAnsiToUnicode(pszBuf, pwszBuf, cchBuf);
                }

                pslA->Release();
            }
        }
    }

    return hres;
}
#endif // 0

HRESULT IShellLinkAorW_GetPath(IShellLinkA *pslA, LPTSTR pszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;

// If we store the string unicode, we could be losing file information by asking
// through A version. Be unicode friendly and use the W version if it exists
//
#ifdef UNICODE
    IShellLinkW *pslW;
    hres = pslA->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
        pslW->Release();
    }
#endif

    if (FAILED(hres))
    {
        char szBuf[MAX_URL_STRING];  // BOGUS, but this is a common size used, perhaps we should LocalAlloc...

        cchBuf = ARRAYSIZE(szBuf);

        hres = pslA->GetPath(szBuf, cchBuf, NULL, dwFlags);

        SHAnsiToTChar(szBuf, pszBuf, cchBuf);
    }

    return hres;
}

STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl)
{
    IShellLinkA *psl;
    CLSID clsid;
    HRESULT hres;

    *ppidl = NULL;  // assume failure

    // WARNING: we really should call GetClassFile() but this could
    // slow this down a lot... so chicken out and just look in the registry

    if (FAILED(_CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;
        hres = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hres))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
            hres = ppf->Load(wszPath, 0);
            if (SUCCEEDED(hres))
            {
                psl->GetIDList(ppidl);

                if (*ppidl == NULL)
                    hres = E_FAIL;  // NULL pidl is valid, but
                                    // lets not return that to clients
                if (pszTarget)
                {
                    IShellLinkAorW_GetPath(psl, pszTarget, cchTarget, 0);
                }
            }
            ppf->Release();
        }
        psl->Release();
    }

    // pszPath might == pszTarget so don't null out on entry always
    if (FAILED(hres) && pszTarget)
        *pszTarget = 0;
    return hres;
}


STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName)
{
    SHFILEINFO sfi;
    if (SHGetFileInfo(pszPath, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyN(pszDisplayName, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        StrCpyN(pszDisplayName, PathFindFileName(pszPath), cchDisplayName);
        PathRemoveExtension(pszDisplayName);
    }
}


STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName)
{
    SHFILEINFOA sfi;
    if (SHGetFileInfoA(pszPathA, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyNA(pszDisplayNameA, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        pszPathA = PathFindFileNameA(pszPathA);
        StrCpyNA(pszDisplayNameA, pszPathA, cchDisplayName);
        PathRemoveExtensionA(pszDisplayNameA);
    }
}

void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg)
{
    void * pret = NULL;
    FORMATETC fmte = {(CLIPFORMAT)cfType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pdtobj->GetData(&fmte, pstg) == S_OK)
    {
        pret = GlobalLock(pstg->hGlobal);
        if (!pret)
            ReleaseStgMedium(pstg);
    }
    return pret;
}

void ReleaseStgMediumHGLOBAL(STGMEDIUM *pstg)
{
    ASSERT(pstg->tymed == TYMED_HGLOBAL);

    GlobalUnlock(pstg->hGlobal);
    ReleaseStgMedium(pstg);
}


// this looks for the file descriptor format to get the display name of a data object
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM mediumFGD;

    InitClipboardFormats();
    FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)DataObj_GetDataOfType(pdtobj, g_cfFileDescW, &mediumFGD);
    if (pfgd)
    {
        if (pfgd->cItems > 0)
        {
            LPFILEDESCRIPTORW pfd = &(pfgd->fgd[0]);
            SHUnicodeToTChar(pfd->cFileName, pszDisplayName, cch);
            hres = S_OK;
        }
        ReleaseStgMediumHGLOBAL(&mediumFGD);
    }
    else
    {
        FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)DataObj_GetDataOfType(pdtobj, g_cfFileDescA, &mediumFGD);
        if (pfgd)
        {
            if (pfgd->cItems > 0)
            {
                LPFILEDESCRIPTORA pfd = &(pfgd->fgd[0]);
                SHAnsiToTChar(pfd->cFileName, pszDisplayName, cch);
                hres = S_OK;
            }
            ReleaseStgMediumHGLOBAL(&mediumFGD);
        }
    }
    return hres;
}

STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM medium;

    InitClipboardFormats();
    void *pdata = DataObj_GetDataOfType(pdtobj, g_cfHIDA, &medium);
    if (pdata)
    {
        *ppidl = IDA_ILClone((LPIDA)pdata, 0);
        if (*ppidl)
            hres = S_OK;
        else
            hres = E_OUTOFMEMORY;
        ReleaseStgMediumHGLOBAL(&medium);
    }

    return hres;
}

STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl,
                           LPWSTR pszDisplayNameW, DWORD cchDisplayName)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    *ppidl = NULL;

    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        // This string is also used to store an URL in case it's an URL file
        TCHAR szPath[MAX_URL_STRING];
        hres = E_FAIL;
        if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)))
        {
            SHFILEINFO sfi;
            SHGetFileInfo(szPath, 0, &sfi, SIZEOF(sfi), SHGFI_ATTRIBUTES | SHGFI_DISPLAYNAME);

            if (pszDisplayNameW)
                SHTCharToUnicode(sfi.szDisplayName, pszDisplayNameW, MAX_PATH);

            if (sfi.dwAttributes & SFGAO_LINK)
                hres = GetLinkTargetIDList(szPath, szPath, ARRAYSIZE(szPath), ppidl);

            if (FAILED(hres))
                hres = IECreateFromPath(szPath, ppidl);
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        hres = SHPidlFromDataObject2(pdtobj, ppidl);
        if (FAILED(hres))
        {
            void *pdata = DataObj_GetDataOfType(pdtobj, g_cfURL, &medium);
            if (pdata)
            {
                LPSTR pszPath = (LPSTR)pdata;
                if (pszDisplayNameW) 
                {
                    if (FAILED(DataObj_GetNameFromFileDescriptor(pdtobj, pszDisplayNameW, cchDisplayName))) 
                    {
                        CHAR szDisplayNameA[MAX_URL_STRING];
                        ASSERT(cchDisplayName < MAX_URL_STRING);
                        SHUnicodeToAnsi(pszDisplayNameW, szDisplayNameA, cchDisplayName);
                        PathToDisplayNameA(pszPath, szDisplayNameA, cchDisplayName);
                    }
                }
                hres = IECreateFromPathA(pszPath, ppidl);
                ReleaseStgMediumHGLOBAL(&medium);
            }
        }
    }
    return hres;
}


// BharatS - Perhaps all the stuff below here should be moved to shlwapi after beta 2 ?

typedef struct _broadcastmsgparams
{
    BOOL fSendMessage; // If true - we call SendMessageTimeout
    UINT uTimeout; // Only Matters if fSendMessage is set
    UINT uMsg;
    WPARAM wParam;
    LPARAM lParam;
} BROADCAST_MSG_PARAMS;

BOOL CALLBACK EnumShellIEWindowsProc(  
    HWND hwnd,      // handle to parent window
    LPARAM lParam   // application-defined value - this has the info needed for posting/sending the message 
)
{
    BROADCAST_MSG_PARAMS *pParams = (BROADCAST_MSG_PARAMS *)lParam;
    BOOL fRet = TRUE;

    if(IsExplorerWindow(hwnd) || IsFolderWindow(hwnd))
    {
        if(pParams->fSendMessage)
        {
            UINT  uTimeout = (pParams->uTimeout < 4000) ? pParams->uTimeout : 4000;
            LRESULT lResult;
            DWORD_PTR dwpResult;
            if (g_fRunningOnNT)
            {
                lResult = SendMessageTimeout(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            else
            {           
                lResult = SendMessageTimeoutA(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            fRet = BOOLIFY(lResult);
        }
        else
        {
            fRet = PostMessage(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam);

        }
    }
    return fRet;

}

// PostShellIEBroadcastMessage is commented out since it is not used currentl
/*

STDAPI_(LRESULT)  PostShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;
    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = FALSE;
    
    return EnumWindows(EnumShellIEWindowsProc, (LPARAM)&MsgParam);
}
*/

//
// We can be hung if we use sendMessage, and you can not use pointers with asynchronous
// calls such as PostMessage or SendNotifyMessage.  So we resort to using a timeout.
// This function should be used to broadcast notification messages, such as WM_SETTINGCHANGE, 
// that pass pointers. (stevepro)
//
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout)
{
    // Note that each this timeout is applied to each window that we broadcast to 

    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;

#ifdef UNICODE
    CHAR szSection[MAX_PATH];
    
    if (!g_fRunningOnNT && (uMsg == WM_WININICHANGE) && (0 != lParam))
    {
        SHUnicodeToAnsi((LPCWSTR)lParam, szSection, ARRAYSIZE(szSection));
        lParam = (LPARAM)szSection;
    }
#endif

    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = TRUE;
    MsgParam.uTimeout = uTimeout;

    return EnumWindows(EnumShellIEWindowsProc, (LPARAM)&MsgParam);
}

// Return the parent psf and relative pidl given a pidl.
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild)
{
    HRESULT hres;

    //
    //  if this is a rooted pidl and it is just the root
    //  then we can bind to the target pidl of the root instead
    //
    if (ILIsRooted(pidl) && ILIsEmpty(_ILNext(pidl)))
        pidl = ILRootedFindIDList(pidl);
        
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    
    if (pidlParent)
    {
        hres = IEBindToObject(pidlParent, ppsfParent);
        ILFree(pidlParent);
    }
    else
        hres = E_OUTOFMEMORY;

    if (ppidlChild)
        *ppidlChild = ILFindLastID(pidl);

    return hres;
}

STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj)
{
    HRESULT hres = E_FAIL;
    if (pidl)
    {
        IShellFolder *psfParent;
        LPCITEMIDLIST pidlChild;
        hres = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
        if (SUCCEEDED(hres))
        {
            hres = psfParent->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IDataObject, ppdtobj));
            psfParent->Release();
        }
    }
    return hres;
}

// Is this pidl a Folder/Directory in the File System?
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl)
{
    if (!pidl)
        return FALSE;

    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);
    return SUCCEEDED(hr) && ((dwAttributes & (SFGAO_FOLDER | SFGAO_FILESYSTEM)) == (SFGAO_FOLDER | SFGAO_FILESYSTEM));
}


// HACKHACK HACKHACK
// the following functions are to work around the menu
// munging that happens in the shlwapi wrappers... when we're
// manipulating menus which are tracked by the system, the
// menu munging code in our shlwapi wrappers (necessary
// for xcp plugUI) trashes them since the system doesn't
// understand munged menus... hence the work arounds below.
// note that many of these functions are copies of the shlwapi
// *WrapW functions (minus the munging).

#undef LoadMenuW

// from winuser.h
EXTERN_C WINUSERAPI HMENU WINAPI LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);

STDAPI_(HMENU)
LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    ASSERT(HIWORD64(lpMenuName) == 0);

    if (g_fRunningOnNT)
    {
        return LoadMenuW(hInstance, lpMenuName);
    }

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */
#undef InsertMenuW

// from winuser.h
EXTERN_C WINUSERAPI BOOL WINAPI InsertMenuW(IN HMENU hMenu, IN UINT uPosition, IN UINT uFlags, IN UINT_PTR uIDNewItem, IN LPCWSTR lpNewItem);

STDAPI_(BOOL) InsertMenu_PrivateNoMungeW(HMENU       hMenu,
                           UINT        uPosition,
                           UINT        uFlags,
                           UINT_PTR    uIDNewItem,
                           LPCWSTR     lpNewItem)
{
    if (g_fRunningOnNT)
    {
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    char szMenuItem[CCH_MENUMAX];

    SHUnicodeToAnsiCP((uFlags & MFT_NONSTRING) ? CP_ATOM : CP_ACP,
                      lpNewItem,
                      szMenuItem,
                      ARRAYSIZE(szMenuItem));

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, szMenuItem);
}

#ifndef NO_MLUI_IN_SHELL32
STDAPI_(HMENU) LoadMenuPopup_PrivateNoMungeW(UINT id)
{
    HINSTANCE hinst = MLLoadShellLangResources();

    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenu_PrivateNoMungeW(hinst, MAKEINTRESOURCEW(id));
    if (hMenu)
    {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub)
        {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }

        // note this calls the shlwapi wrapper (that handles
        // destroying munged menus) but it looks like
        // it's safe to do so.
        DestroyMenu(hMenu);
    }

    MLFreeLibrary(hinst);

    return hMenuSub;
}
#endif // NO_MLUI_IN_SHELL32

// determine if a path is just a filespec (contains no path parts)
//
// REVIEW: we may want to count the # of elements, and make sure
// there are no illegal chars, but that is probably another routing
// PathIsValid()
//
// in:
//      lpszPath    path to look at
// returns:
//      TRUE        no ":" or "\" chars in this path
//      FALSE       there are path chars in there
//
//

BOOL PathIsFilePathA(LPCSTR lpszPath)
{
#ifdef UNIX
    if (lpszPath[0] == '/')
#else
    if ((lpszPath[0] == '\\') || (lpszPath[1] == ':'))
#endif
        return TRUE;

    return IsFileUrl(lpszPath);
}

//
// PrepareURLForDisplay
//
//     Decodes without stripping file:// prefix
//
STDAPI_(BOOL) PrepareURLForDisplayA(LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut)
{
    if (PathIsFilePathA(psz))
    {
        if (IsFileUrl(psz))
            return SUCCEEDED(PathCreateFromUrlA(psz, pszOut, pcchOut, 0));

        StrCpyNA(pszOut, psz, *pcchOut);
        *pcchOut = lstrlenA(pszOut);
        return TRUE;
    }
    return SUCCEEDED(UrlUnescapeA((LPSTR)psz, pszOut, pcchOut, 0));
}

#undef InsertMenuW
#undef LoadMenuW

// from w95wraps.h
#define InsertMenuW                 InsertMenuWrapW
#define LoadMenuW                   LoadMenuWrapW

STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath)
{
    // Tries to get a system-displayable string from a pidl.
    // (On Win9x and NT4, User32 doesn't support font-linking,
    // so we can't display non-system language strings as window
    // titles or menu items.  In those cases, we call this function
    // to grab the path/URL instead, which will likely be system-
    // displayable).

    UINT uType;

    *psz = NULL;
    TCHAR szName[MAX_URL_STRING];

    if (fFullPath)
        uType = SHGDN_FORPARSING;
    else
        uType = SHGDN_NORMAL;

    uType |= SHGDN_FORADDRESSBAR; 
    DWORD dwAttrib = SFGAO_LINK;

    HRESULT hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), &dwAttrib);
    if (SUCCEEDED(hr))
    {
        if ((uType & SHGDN_FORPARSING) && (dwAttrib & SFGAO_LINK))
        {
            // folder shortcut special case
            IShellLinkA *psl;  // Use A version for W95.
            if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLinkA, &psl))))
            {
                LPITEMIDLIST pidlTarget;
                if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
                {
                    hr = IEGetNameAndFlags(pidlTarget, uType, szName, SIZECHARS(szName), NULL);
                    ILFree(pidlTarget);
                }
            }
        }
    }
    else
    {
        // didn't work, try the reverse
        uType ^= SHGDN_FORPARSING;  // flip the for parsing bit
        hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), NULL);

        // some old namespaces get confused by all our funny bits...
        if (FAILED(hr))
        {
            hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        SHRemoveURLTurd(szName);
        SHCleanupUrlForDisplay(szName);
 
        // HTTP URLs are not escaped because they come from the
        // user or web page which is required to create correctly
        // escaped URLs.  FTP creates then via results from the
        // FTP session, so their pieces (username, password, path)
        // need to be escaped when put in URL form.  However,
        // we are going to put that URL into the Caption Bar, and
        // and we want to unescape it because it's assumed to be
        // a DBCS name.  All of this is done because unescaped URLs
        // are pretty. (NT #1272882)
        if (URL_SCHEME_FTP == GetUrlScheme(szName))
        {
            CHAR szUrlTemp[MAX_BROWSER_WINDOW_TITLE];
            CHAR szUnEscaped[MAX_BROWSER_WINDOW_TITLE];
            DWORD cchSizeTemp = ARRAYSIZE(szUnEscaped);

            // This thunking stuff is necessary.  Unescaping won't
            // gell into DBCS chars unless it's in ansi.
            SHTCharToAnsi(szName, szUrlTemp, ARRAYSIZE(szUrlTemp));
            PrepareURLForDisplayA(szUrlTemp, szUnEscaped, &cchSizeTemp);
            SHAnsiToTChar(szUnEscaped, psz, cch);
        }
        else
        {
            StrCpyN(psz, szName, cch);
        }
    }

    return hr;
}

BOOL IsSpecialUrl(LPCWSTR pchURL)
{
    UINT uProt = GetUrlSchemeW(pchURL);
    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT == uProt ||
            URL_SCHEME_ABOUT == uProt);
}

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchSafeUrl = NULL;
    TCHAR      *pch;
    TCHAR       achUrl[4096];
    DWORD       dwSize;
    BSTR        bstrURL = *pbstrUrl;
    int         cSize;

    if (IsSpecialUrl(bstrURL))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(bstrURL, L"%00"))
        {
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        // Copy the URL so we can munge it.
        //
        cSize = SysStringLen(bstrURL) + 1;
        pchSafeUrl = new TCHAR[cSize];
        if (!pchSafeUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        } 
        StrCpyN(pchSafeUrl, bstrURL, cSize);

        // someone could put in a string like this:
        //     %2501 OR %252501 OR %25252501
        // which, depending on the number of decoding steps, will bypass security
        // so, just keep decoding while there are %s and the string is getting shorter
        int nPreviousLen = 0;
        while ( (nPreviousLen != lstrlen(pchSafeUrl)) && (StrChrW(pchSafeUrl, L'%')))
        {
            nPreviousLen = lstrlen(pchSafeUrl);
            int nNumPercents;
            int nNumPrevPercents = 0;

            // Reduce the URL
            //
            for (;;)
            {
                // Count the % signs.
                //
                nNumPercents = 0;

                pch = pchSafeUrl;
                while (pch = StrChrW(pch, L'%'))
                {
                    pch++;
                    nNumPercents++;
                }

                // If the number of % signs has changed, we've reduced the URL one iteration.
                //
                if (nNumPercents != nNumPrevPercents)
                {
                    // Encode the URL 
                    hr = THR(CoInternetParseUrl(pchSafeUrl, 
                        PARSE_ENCODE, 
                        0, 
                        achUrl, 
                        ARRAYSIZE(achUrl), 
                        &dwSize,
                        0));

                    StrCpyN(pchSafeUrl, achUrl, cSize);

                    nNumPrevPercents = nNumPercents;
                }
                else
                {
                    // The URL is fully reduced.  Break out of loop.
                    //
                    break;
                }
            }
        }

        // Now scan for '\1' characters.
        //
        if (StrChrW(pchSafeUrl, L'\1'))
        {
            // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
            //
            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

        SysFreeString(*pbstrUrl);
        *pbstrUrl = SysAllocString(pchSafeUrl);
        if (!*pbstrUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

Cleanup:
    delete [] pchSafeUrl;
    return hr;
}

HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl)
{
    HRESULT     hr = S_OK;

    if (IsSpecialUrl(pszUrl))
    {
        //
        // If this is javascript:, vbscript: or about:, append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //

        // QFE 2735 (Georgi XDomain): [alanau]
        //
        // If the special URL contains an %00 sequence, then it will be converted to a Null char when
        // encoded.  This will effectively truncate the Security ID.  For now, simply disallow this
        // sequence, and display a "Permission Denied" script error.
        //
        if (StrStrW(pszUrl, L"%00"))
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            // munge the url in place
            //

            // someone could put in a string like this:
            //     %2501 OR %252501 OR %25252501
            // which, depending on the number of decoding steps, will bypass security
            // so, just keep decoding while there are %s and the string is getting shorter
            int nPreviousLen = 0;
            while ( (nPreviousLen != lstrlen(pszUrl)) && (StrChrW(pszUrl, L'%')))
            {
                nPreviousLen = lstrlen(pszUrl);
                int nNumPercents;
                int nNumPrevPercents = 0;

                // Reduce the URL
                //
                for (;;)
                {
                    // Count the % signs.
                    //
                    nNumPercents = 0;

                    WCHAR *pch = pszUrl;
                    while (pch = StrChrW(pch, L'%'))
                    {
                        pch++;
                        nNumPercents++;
                    }

                    // If the number of % signs has changed, we've reduced the URL one iteration.
                    //
                    if (nNumPercents != nNumPrevPercents)
                    {
                        WCHAR szBuf[MAX_URL_STRING];
                        DWORD dwSize;

                        // Encode the URL 
                        hr = THR(CoInternetParseUrl(pszUrl, 
                            PARSE_ENCODE, 
                            0,
                            szBuf,
                            ARRAYSIZE(szBuf),
                            &dwSize,
                            0));

                        StrCpyN(pszUrl, szBuf, cchUrl);

                        nNumPrevPercents = nNumPercents;
                    }
                    else
                    {
                        // The URL is fully reduced.  Break out of loop.
                        //
                        break;
                    }
                }
            }

            // Now scan for '\1' characters.
            //
            if (StrChrW(pszUrl, L'\1'))
            {
                // If there are '\1' characters, we can't guarantee the safety.  Put up "Permission Denied".
                //
                hr = E_ACCESSDENIED;
            }
        }
    }

    return hr;
}

STDAPI GetBrowserFrameOptions(IUnknown *punkFolder, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (punkFolder)
    {
        IBrowserFrameOptions *pbfo;
        hr = punkFolder->QueryInterface(IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (pidl)
    {
        IBrowserFrameOptions *pbfo;
        hr = IEBindToObjectEx(pidl, NULL, IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr) && pbfo)
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptions(psf, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptionsPidl(pidl, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf)
{
    BOOL fIsFTPFolder = FALSE;
    CLSID clsid;

    if (psf && SUCCEEDED(IUnknown_GetClassID(psf, &clsid)))
    {
        // Is this an FTP Folder?
        if (IsEqualIID(clsid, CLSID_FtpFolder))
            fIsFTPFolder = TRUE;
        else
        {
            // Not directly, but let's see if it is an Folder Shortcut to
            // an FTP Folder
            if (IsEqualIID(clsid, CLSID_FolderShortcut))
            {
                IShellLinkA * psl;
                HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));

                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;

                    hr = psl->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        IShellFolder * psfTarget;

                        hr = IEBindToObject(pidl, &psfTarget);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(IUnknown_GetClassID(psfTarget, &clsid)) &&
                                IsEqualIID(clsid, CLSID_FtpFolder))
                            {
                                fIsFTPFolder = TRUE;
                            }

                            psfTarget->Release();
                        }

                        ILFree(pidl);
                    }

                    psl->Release();
                }
            }
        }
    }

    return fIsFTPFolder;
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawFocusRectangle
//
//  Synopsis:   draws the focus rectangle for the edit control
//
//----------------------------------------------------------------------------
void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    BOOL        fReleaseDC = FALSE;

    if ( hdc == NULL )
    {
        hdc = GetDC(hwnd);
        if ( hdc == NULL )
        {
            return;
        }
        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}

typedef struct {
    LPSTR   psz;
    LPCWSTR pwsz;
    LONG    byteoffset;
    BOOL    fStreamIn;
} STREAMIN_HELPER_STRUCT;

DWORD CALLBACK SetRicheditTextWCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    STREAMIN_HELPER_STRUCT *pHelpStruct = (STREAMIN_HELPER_STRUCT *) dwCookie;
    LONG  lRemain = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);

    if (pHelpStruct->fStreamIn)
    {
        //
        // The whole string can be copied first time
        //
        if ((cb >= (LONG) (wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) && (pHelpStruct->byteoffset == 0))
        {
            memcpy(pbBuff, pHelpStruct->pwsz, wcslen(pHelpStruct->pwsz) * sizeof(WCHAR));
            *pcb = wcslen(pHelpStruct->pwsz) * sizeof(WCHAR);
            pHelpStruct->byteoffset = *pcb;
        }
        //
        // The whole string has been copied, so terminate the streamin callbacks
        // by setting the num bytes copied to 0
        //
        else if (((LONG)(wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) <= pHelpStruct->byteoffset)
        {
            *pcb = 0;
        }
        //
        // The rest of the string will fit in this buffer
        //
        else if (cb >= (LONG) ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset))
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset));
            *pcb = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
            pHelpStruct->byteoffset += ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
        }
        //
        // copy as much as possible
        //
        else
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                cb);
            *pcb = cb;
            pHelpStruct->byteoffset += cb;
        }
    }
    else
    {
        //
        // This is the EM_STREAMOUT which is only used during the testing of
        // the richedit2.0 functionality.  (we know our buffer is 32 bytes)
        //
        if (cb <= 32)
        {
            memcpy(pHelpStruct->psz, pbBuff, cb);
        }
        *pcb = cb;
    }

    return 0;
}

void SetRicheditIMFOption(HWND hWndRichEdit)
{
    DWORD dwOptions;

    dwOptions = (DWORD)SendMessageW(hWndRichEdit, EM_GETLANGOPTIONS, 0, 0);
    dwOptions |= IMF_UIFONTS;
    SendMessageW(hWndRichEdit, EM_SETLANGOPTIONS, 0, dwOptions);
}

DWORD SetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;

    SetRicheditIMFOption(GetDlgItem(hwndDlg, id));

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendDlgItemMessageW(hwndDlg, id, EM_STREAMIN, SF_TEXT | SF_UNICODE, (LPARAM) &editStream);

    return editStream.dwError;
}

//+---------------------------------------------------------------------------
//
//  Function:   RenderStringToEditControlW
//
//  Synopsis:   renders a string to the control given and if requested, gives
//              it a link look and feel, subclassed to the wndproc given
//
//  Arguments:  [hwndDlg]       -- dialog window handle
//              [pwsz]           -- string
//              [wndproc]       -- wndproc
//              [uID]           -- ID of control
//
//
//  Notes:
//
//----------------------------------------------------------------------------
void RenderStringToEditControlW (
                  HWND                      hwndDlg,
                  LPCWSTR                   pwsz,
                  WNDPROC                   wndproc,
                  UINT                      uID)
{
    HWND hControl;
    //
    // Get the control and set the text on it, make sure the background is right
    //

    hControl = GetDlgItem(hwndDlg, uID);
    SetRicheditIMFOption(GetDlgItem(hwndDlg, uID));
    SetRicheditTextW(hwndDlg, uID, L"");
    SetRicheditTextW(hwndDlg, uID, pwsz);

    SendMessage(
        hControl,
        EM_SETBKGNDCOLOR,
        0,
        (LPARAM)GetSysColor(COLOR_3DFACE)
        );

    //
    // Update for the link look
    //

    CHARFORMAT cf;

    memset(&cf, 0, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_LINK;
    cf.crTextColor = RGB(0, 0, 255);
    cf.dwEffects |= CFE_UNDERLINE | CFE_LINK;

    SendMessage(hControl, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    

    //subclass the window proc so we can handle the link specially
    LONG_PTR PrevWndProc = GetWindowLongPtr(hControl, GWLP_WNDPROC);
    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)PrevWndProc);
    SetWindowLongPtr(hControl, GWLP_WNDPROC, (LONG_PTR)wndproc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\caggunk.h ===
#ifndef _CAGGUNK_H
#define _CAGGUNK_H

class CAggregatedUnknown  : public IUnknown
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
protected:
    virtual ~CAggregatedUnknown(); // so that subclasses get deleted right
    CAggregatedUnknown(IUnknown *punkAgg);

    // This is the IUnknown that subclasses returns from their CreateInstance func
    IUnknown* _GetInner() { return &_unkInner; }

    // A couple helper functions for subclasses to cache their aggregator's
    // (or their own) interfaces.
    void _ReleaseOuterInterface(IUnknown** ppunk);
    HRESULT _QueryOuterInterface(REFIID riid, void ** ppvOut);

    // Do non-cached QIs off this IUnknown
    IUnknown* _GetOuter() { return _punkAgg; }

    // Allow "delayed aggregation"
    void _SetOuter(IUnknown* punk) { _punkAgg = punk; }

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj) = 0;

    virtual BOOL v_HandleDelete(PLONG pcRef) { return FALSE; };
    
private:

    // Get a non-refcounted pointer to the canonical IUnknown of the
    // controlling unknown.  Used by _QueryOuterInterface and
    // _ReleaseOuterInterface.
    IUnknown *_GetCanonicalOuter(void);

    // Embed default IUnknown handler
    class CUnkInner : public IUnknown
    {
    public:
        virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        CUnkInner() { _cRef = 1; }
    private:
        LONG _cRef;
    };
    friend class CUnkInner;
    CUnkInner _unkInner;
    IUnknown* _punkAgg; // points to _unkInner or aggregating IUnknown

};

#define RELEASEOUTERINTERFACE(p) _ReleaseOuterInterface((IUnknown**)((void **)&p))

#endif // _CAGGUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\ccstock2.h ===
//
// addendum to ccstock.h:
//   this file has function prototypes that require shlobj.h.
//   ccstock.h does not have that requirement (and can not,
//   since comctl32 includes ccstock but not shlobj).
//
#ifndef __CCSTOCK2_H__
#define __CCSTOCK2_H__

STDAPI_(LPIDA) DataObj_GetHIDAEx(IDataObject *pdtobj, CLIPFORMAT cf, STGMEDIUM *pmedium);
STDAPI_(LPIDA) DataObj_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium);
STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i);
STDAPI_(void) HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM * pmedium);
STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i);


#endif __CCSTOCK2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#include <malloc.h> // for _alloca

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

#define ZeroInit(pv, cb)            (memset((pv), 0, (cb)))

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#   ifdef __cplusplus
#       define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#   else
#       define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#   endif

// doing this as a function instead of inline seems to be a size win.
//
#   ifdef NOATOMICRELESEFUNC
#       define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#   else
#       ifdef __cplusplus
#           define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#       else
#           define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#       endif
#   endif
#endif //ATOMICRELEASE

//
//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
//
//
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

#define PPUNK_SET(ppunkDst, punkSrc)    \
    {   ATOMICRELEASE(*ppunkDst);       \
        if (punkSrc)                    \
        {   punkSrc->AddRef();          \
            *ppunkDst = punkSrc;        \
        }                               \
    }

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (void **) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(void **)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.
// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;

//  a three state boolean for bools that need initialization
typedef enum 
{
    TRIBIT_UNDEFINED = 0,
    TRIBIT_TRUE,
    TRIBIT_FALSE,
} TRIBIT;

//
// DESTROY_OBJ_WITH_HANDLE(h, fn)
//
// Kind of like ATOMICRELEASE for handles.  Checks for NULL and assigns
// NULL when it's done.  You supply the destructor function.
//
#define DESTROY_OBJ_WITH_HANDLE(h, fn) { if (h) { fn(h); (h) = NULL; } }


// STOCKLIB util functions

// staticIsOS(): returns TRUE/FALSE if the platform is the indicated OS. 
// This function exists for those who cannot link to shlwapi.dll
STDAPI_(BOOL) staticIsOS(DWORD dwOS);

#include <pshpack2.h>
typedef struct tagDLGTEMPLATEEX
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
}   DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// macro that rounds cbSize fields to the nearest pointer size (for alignment)
//
#define ROUND_TO_POINTER(cbSize) (((cbSize + sizeof(void*) - 1) / (sizeof(void*))) * sizeof(void*))

//
// macro that sees if a give char is an number
//
#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif

//
//  FILETIME helpers
//
__inline unsigned __int64 _FILETIMEtoInt64(const FILETIME* pft)
{
    return ((unsigned __int64)pft->dwHighDateTime << 32) + pft->dwLowDateTime;
}

#define FILETIMEtoInt64(ft) _FILETIMEtoInt64(&(ft))

__inline void SetFILETIMEfromInt64(FILETIME *pft, unsigned __int64 i64)
{
    pft->dwLowDateTime = (DWORD)i64;
    pft->dwHighDateTime = (DWORD)(i64 >> 32);
}

__inline void IncrementFILETIME(FILETIME *pft, unsigned __int64 iAdjust)
{
    SetFILETIMEfromInt64(pft, _FILETIMEtoInt64(pft) + iAdjust);
}

__inline void DecrementFILETIME(FILETIME *pft, unsigned __int64 iAdjust)
{
    SetFILETIMEfromInt64(pft, _FILETIMEtoInt64(pft) - iAdjust);
}

//
//  FAT and NTFS use different values for "unknown date".
//
//  The FAT "unknown date" is January 1 1980 LOCAL TIME.
//  The NTFS "unknown date" is January 1 1601 GMT.
//
//  This LOCAL/GMT discrepancy is annoying.
//
#define FT_FAT_UNKNOWNLOCAL    ((unsigned __int64)0x01A8E79FE1D58000)
#define FT_NTFS_UNKNOWNGMT     ((unsigned __int64)0x0000000000000000)

//
//  FT_ONEHOUR is the number of FILETIME units in an hour.
//  FT_ONEDAY is the number of FILETIME units in a day.
//
//      10,000,000 FILETIME units per second *
//      3600 seconds per hour *
//      24 hours per day.
//
#define FT_ONESECOND           ((unsigned __int64)10000000)
#define FT_ONEHOUR             ((unsigned __int64)10000000 * 3600)
#define FT_ONEDAY              ((unsigned __int64)10000000 * 3600 * 24)


//
//
//  WindowLong accessor macros and other Win64 niceness
//

__inline void * GetWindowPtr(HWND hWnd, int nIndex) {
    return (void *)GetWindowLongPtr(hWnd, nIndex);
}

__inline void * SetWindowPtr(HWND hWnd, int nIndex, void * p) {
    return (void *)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

//***   GetWindowLong0 -- 'fast' GetWindowLong (and GetWindowLongPtr)
// DESCRIPTION
//  what's up w/ this?  it's all about perf.  GetWindowLong has 'A' and 'W'
//  versions.  however 99% of the time they do the same thing (the other
//  0.1% has to do w/ setting the WndProc and having to go thru a thunk).
//  but we still need wrappers for the general case.  but most of the time
//  we're just doing a GWL(0), e.g. on entry to a wndproc to get our private
//  data.  so by having a special version of that, we save going thru the
//  wrapper (which was costing us 1-3% of our profile).
// NOTES
//  note that we call the 'A' version since that's guaranteed to exist on
// all platforms.
__inline LONG GetWindowLong0(HWND hWnd) {
    return GetWindowLongA(hWnd, 0);
}
__inline LONG SetWindowLong0(HWND hWnd, LONG l) {
    return SetWindowLongA(hWnd, 0, l);
}
__inline void * GetWindowPtr0(HWND hWnd) {
    return (void *)GetWindowLongPtrA(hWnd, 0);
}
__inline void * SetWindowPtr0(HWND hWnd, void * p) {
    return (void *)SetWindowLongPtrA(hWnd, 0, (LONG_PTR)p);
}


#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(int c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(int c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

//
//  CharLowerChar - Convert a single character to lowercase
//
__inline WCHAR CharLowerCharW(int c)
{
    return (WCHAR)(DWORD_PTR)CharLowerW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharLowerCharA(int c)
{
    return (CHAR)(DWORD_PTR)CharLowerA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#define CharLowerChar       CharLowerCharW
#else
#define CharUpperChar       CharUpperCharA
#define CharLowerChar       CharLowerCharA
#endif

//
//  ShrinkProcessWorkingSet - Use this to stay Sundown-happy.
//
#define ShrinkWorkingSet() \
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1)

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()

#include <shtypes.h>

//
//  Name Parsing generic across the shell
//
//  Usage:
//
//      HRESULT SHGetNameAndFlags()
//          wrapper to bind to the folder and do a GetDisplayName()
//
STDAPI SHGetNameAndFlagsA(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlagsW(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);

STDAPI SHBindToObject(struct IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppv);
STDAPI SHBindToObjectEx(struct IShellFolder *psf, LPCITEMIDLIST pidl, struct IBindCtx *pbc, REFIID riid, void **ppv);
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv);
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl);
STDAPI SHGetTargetFolderPathW(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchBuf);
STDAPI SHGetTargetFolderPathA(LPCITEMIDLIST pidlFolder, LPSTR pszPath, UINT cchBuf);
STDAPI_(DWORD) SHGetAttributes(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttributes);

#define SHGetAttributesOf(pidl, prgfInOut) SHGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut)

#ifdef __IShellFolder2_FWD_DEFINED__
STDAPI GetDateProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, FILETIME *pft);
STDAPI GetLongProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, ULONGLONG *pdw);
STDAPI GetStringProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, LPTSTR pszVal, int cchMax);
#endif // __IShellFolder2_FWD_DEFINED__

STDAPI LoadFromFileW(REFCLSID clsid, LPCWSTR pszFile, REFIID riid, void **ppv);
STDAPI LoadFromIDList(REFCLSID clsid, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

STDAPI_(DWORD) GetUrlSchemeW(LPCWSTR pszUrl);
STDAPI_(DWORD) GetUrlSchemeA(LPCSTR pszUrl);
STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl);
STDAPI_(void) SHCleanupUrlForDisplay(LPTSTR pszUrl);
 
#ifdef UNICODE
#define SHGetNameAndFlags       SHGetNameAndFlagsW
#define GetUrlScheme            GetUrlSchemeW
#define SHGetTargetFolderPath   SHGetTargetFolderPathW
#define LoadFromFile            LoadFromFileW
#else
#define SHGetNameAndFlags       SHGetNameAndFlagsA
#define GetUrlScheme            GetUrlSchemeA
#define SHGetTargetFolderPath   SHGetTargetFolderPathA
#endif

//
//  BindCtx helpers
//
STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc);
STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault);
STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR sz);
STDAPI BindCtx_RegisterObjectParam(IBindCtx *pbcIn, LPCOLESTR pszRegister, IUnknown *punkRegister, IBindCtx **ppbcOut);
STDAPI BindCtx_CreateWithTimeoutDelta(DWORD dwTicksToAllow, IBindCtx **ppbc);
STDAPI BindCtx_GetTimeoutDelta(IBindCtx *pbc, DWORD *pdwTicksToAllow);
STDAPI BindCtx_RegisterUIWindow(IBindCtx *pbcIn, HWND hwnd, IBindCtx **ppbcOut);
STDAPI_(HWND) BindCtx_GetUIWindow(IBindCtx *pbc);

typedef struct _BINDCTX_PARAM
{
    LPCWSTR pszName;
    IBindCtx *pbcParam;
} BINDCTX_PARAM;
STDAPI BindCtx_RegisterObjectParams(IBindCtx *pbcIn, BINDCTX_PARAM *rgParams, UINT cParams, IBindCtx **ppbcOut);

// SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//
// SHBindToFolderIDListParent
//
//  Same as SHBindToIDListParent, except you also specify which root to use.
//
STDAPI SHBindToFolderIDListParent(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);


//
// context menu and dataobject helpers. 
//
STDAPI_(void) ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium);
#define FAILED_AND_NOT_CANCELED(hr) (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
STDAPI SHInvokeCommandOnPidl(HWND hwnd, IUnknown* punk, LPCITEMIDLIST pidl, UINT uFlags, LPCSTR lpVerb);
STDAPI SHInvokeCommandOnPidlArray(HWND hwnd, IUnknown* punk, struct IShellFolder* psf, LPCITEMIDLIST *ppidlItem, UINT cItems, UINT uFlags, LPCSTR lpVerb);
STDAPI SHInvokeCommandOnDataObject(HWND hwnd, IUnknown* punk, IDataObject* pdo, UINT uFlags, LPCSTR lpVerb);


STDAPI DisplayNameOf(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch);
STDAPI DisplayNameOfAsOLESTR(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPWSTR *ppsz);

//  clones the parent of the pidl
STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl);

STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl);

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl);
STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl);
STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *clsid);
STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl);
STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
#define ILIsEqualRoot(pidl1, pidl2) (0 == ILRootedCompare(pidl1, pidl2))
STDAPI ILRootedBindToRoot(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
STDAPI ILRootedBindToObject(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
STDAPI ILRootedBindToParentFolder(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlChild);

typedef HGLOBAL HIDA;

STDAPI_(HIDA) HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl);
STDAPI_(void) HIDA_Free(HIDA hida);
STDAPI_(HIDA) HIDA_Clone(HIDA hida);
STDAPI_(UINT) HIDA_GetCount(HIDA hida);
STDAPI_(UINT) HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax);

STDAPI StgMakeUniqueName(IStorage *pStorageParent, LPCTSTR pszFileSpec, REFIID riid, void **ppv);

STDAPI_(BOOL) PathIsImage(LPCTSTR pszFile);
STDAPI_(BOOL) SHChangeMenuWasSentByMe(LPVOID self, LPCITEMIDLIST pidlNotify);
STDAPI_(void) SHSendChangeMenuNotify(LPVOID self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2);

STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl);

STDAPI GetHTMLDoc2(IUnknown *punk, struct IHTMLDocument2 **ppHtmlDoc);
STDAPI LocalZoneCheck(IUnknown *punkSite);
STDAPI LocalZoneCheckPath(LPCWSTR pszUrl, IUnknown *punkSite);
STDAPI GetZoneFromUrl(LPCWSTR pszUrl, IUnknown * punkSite, DWORD * pdwZoneID);
STDAPI GetZoneFromSite(IUnknown *punkSite, DWORD * pdwZoneID);

STDAPI SHGetDefaultClientOpenCommandW(LPCWSTR pwszClientType,
        LPWSTR pwszClientCommand, DWORD dwCch,
        OPTIONAL LPWSTR pwszClientParams, DWORD dwCchParams);
STDAPI SHGetDefaultClientNameW(LPCWSTR pwszClientType, LPWSTR pwszBuf, DWORD dwCch);

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
STDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize);
STDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
STDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)  SHFree(pidl)

//
//  DLL version helper macros
//
//  To add DllGetVersion support to your DLL, do this:
//
//  1. foo.c
//
//      DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  or
//
//      DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  depending on whether you are a single-binary or dual-binary component.
//
//  2. foo.src:
//
//      DllGetVersion = CCDllGetVersion             ULTRAPRIVATE
//
//  3. sources:
//
//      LINKLIBS = $(LINKLIBS) $(CCSHELL_DIR)\lib\$(O)\stocklib.lib
//

#define PRODUCTVER_GETMAJOR(ver)    (((ver) & 0xFF000000) >> 24)
#define PRODUCTVER_GETMINOR(ver)    (((ver) & 0x00FF0000) >> 16)
#define PRODUCTVER_GETBUILD(ver)    (((ver) & 0x0000FFFF) >>  0)

#define MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe)               \
        MAKEDLLVERULL(PRODUCTVER_GETMAJOR(ver),             \
                      PRODUCTVER_GETMINOR(ver),             \
                      PRODUCTVER_GETBUILD(ver), qfe)

#define MAKE_DLLVER_STRUCT(ver, plat, qfe)                  \
EXTERN_C const DLLVERSIONINFO2 c_dllver = {                 \
  {                                 /* DLLVERSIONINFO    */ \
    0,                              /* cbSize            */ \
    PRODUCTVER_GETMAJOR(ver),       /* dwMajorVersion    */ \
    PRODUCTVER_GETMINOR(ver),       /* dwMinorVersion    */ \
    PRODUCTVER_GETBUILD(ver),       /* dwBuildNumber     */ \
    plat,                           /* dwPlatformID      */ \
  },                                                        \
    0,                              /* dwFlags           */ \
    MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe), /* ullVersion */ \
}

#define DLLVER_9xBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_WINDOWS, qfe)

#define DLLVER_NTBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_NT, qfe)

#define DLLVER_SINGLEBINARY     DLLVER_9xBINARY

#ifdef WINNT
#define DLLVER_DUALBINARY       DLLVER_NTBINARY
#else
#define DLLVER_DUALBINARY       DLLVER_9xBINARY
#endif

STDAPI CCDllGetVersion(struct _DLLVERSIONINFO * pinfo);

//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL g_bMirroredOS;

void EditBiDiDLGTemplate(LPDLGTEMPLATE pdt, DWORD dwFlags, PWORD pwIgnoreList, int cIgnore);
#define   EBDT_NOMIRROR        0x00000001
#define   EBDT_FLIP            0x00000002

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  IsBiDiLocalizedSystemEx( LANGID *pLangID );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL Mirror_IsUILanguageInstalled( LANGID langId );
BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam);
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_GetLayout( HDC hdc );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwExStyleNoInheritLayout;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        IsBiDiLocalizedSystemEx(pLangID)
#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define GET_DC_LAYOUT(hdc)              Mirror_GetLayout(hdc) 
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define RTL_NOINHERITLAYOUT             dwExStyleNoInheritLayout
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        FALSE
#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT() 
#define GET_DC_LAYOUT(hdc)              0L

#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L
#define RTL_NOINHERITLAYOUT             0L

#endif  // USE_MIRRROING

BOOL IsBiDiLocalizedWin95( BOOL bArabicOnly );

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

STDAPI DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
#define EDGE_LEFT       0x00000001
#define EDGE_RIGHT      0x00000002
#define EDGE_TOP        0x00000004
#define EDGE_BOTTOM     0x00000008

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i);
STDAPI_(void) _SHPrettyMenu(HMENU hm);
STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i);
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed);
STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState);
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5);

#define SHProcessMessagesUntilEvent(hwnd, hEvent, dwTimeout)        SHProcessMessagesUntilEventEx(hwnd, hEvent, dwTimeout, QS_ALLINPUT)
#define SHProcessSentMessagesUntilEvent(hwnd, hEvent, dwTimeout)    SHProcessMessagesUntilEventEx(hwnd, hEvent, dwTimeout, QS_SENDMESSAGE)
STDAPI_(DWORD) SHProcessMessagesUntilEventEx(HWND hwnd, HANDLE hEvent, DWORD dwTimeout, DWORD dwWakeMask);

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter);
STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter);

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText);
STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id);

STDAPI_(void) SHAdjustLOGFONTA(IN OUT LOGFONTA *plf);
STDAPI_(void) SHAdjustLOGFONTW(IN OUT LOGFONTW *plf);
#ifdef UNICODE
#define SHAdjustLOGFONT         SHAdjustLOGFONTW
#else
#define SHAdjustLOGFONT         SHAdjustLOGFONTA
#endif

STDAPI SHLoadLegacyRegUIStringA(HKEY hk, LPCSTR pszSubkey, LPSTR pszOutBuf, UINT cchOutBuf);
STDAPI SHLoadLegacyRegUIStringW(HKEY hk, LPCWSTR pszSubkey, LPWSTR pszOutBuf, UINT cchOutBuf);
#ifdef UNICODE
#define SHLoadLegacyRegUIString SHLoadLegacyRegUIStringW
#else
#define SHLoadLegacyRegUIString SHLoadLegacyRegUIStringA
#endif

STDAPI_(CHAR) SHFindMnemonicA(LPCSTR psz);
STDAPI_(WCHAR) SHFindMnemonicW(LPCWSTR psz);
#ifdef UNICODE
#define SHFindMnemonic SHFindMnemonicW
#else
#define SHFindMnemonic SHFindMnemonicA
#endif

typedef struct tagINSTALL_INFO
{
    LPTSTR szSource;
    LPTSTR szDest;
    DWORD dwDestAttrib;
} INSTALL_INFO;

//
//  Special attributes in INSTALL_INFO.dwDestAttrib.  We use attributes
//  that we would never otherwise use.
//
#define FILE_ATTRIBUTE_INSTALL_NTONLY    FILE_ATTRIBUTE_DEVICE
#define FILE_ATTRIBUTE_INSTALL_9XONLY    FILE_ATTRIBUTE_TEMPORARY

// superhidden files are attrib'ed +h +s
#define FILE_ATTRIBUTE_SUPERHIDDEN (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN) 
#define IS_SYSTEM_HIDDEN(dw) ((dw & FILE_ATTRIBUTE_SUPERHIDDEN) == FILE_ATTRIBUTE_SUPERHIDDEN) 

STDAPI GetInstallInfoFromResource(HINSTANCE hResourceInst, UINT uID, INSTALL_INFO *piiFile);
STDAPI InstallInfoFreeMembers(INSTALL_INFO *piiFile);
STDAPI InstallFileFromResource(HINSTANCE hInstResource, INSTALL_INFO *piiFile, LPCTSTR pszDestDir);

#ifndef OBJCOMPATFLAGS
typedef DWORD OBJCOMPATFLAGS;
#endif

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl);

#define ROUS_DEFAULTALLOW       0x0000
#define ROUS_DEFAULTRESTRICT    0x0001
#define ROUS_KEYALLOWS          0x0000
#define ROUS_KEYRESTRICTS       0x0002

STDAPI_(BOOL) IsRestrictedOrUserSettingA(HKEY hkeyRoot, enum RESTRICTIONS rest, LPCSTR pszSubKey, LPCSTR pszValue, UINT flags);
STDAPI_(BOOL) IsRestrictedOrUserSettingW(HKEY hkeyRoot, enum RESTRICTIONS rest, LPCWSTR pszSubKey, LPCWSTR pszValue, UINT flags);
STDAPI_(BOOL) GetExplorerUserSettingA(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue);
STDAPI_(BOOL) GetExplorerUserSettingW(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue);

#ifdef UNICODE
#define IsRestrictedOrUserSetting   IsRestrictedOrUserSettingW
#define GetExplorerUserSetting      GetExplorerUserSettingW
#else
#define IsRestrictedOrUserSetting   IsRestrictedOrUserSettingA
#define GetExplorerUserSetting      GetExplorerUserSettingA
#endif

//
// PropertBag helpers

STDAPI_(void) SHPropertyBag_ReadStrDef(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch, LPCWSTR pszDef);
STDAPI_(void) SHPropertyBag_ReadIntDef(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult, int iDef);
STDAPI_(void) SHPropertyBag_ReadSHORTDef(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh, SHORT shDef);
STDAPI_(void) SHPropertyBag_ReadLONGDef(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl, LONG lDef);
STDAPI_(void) SHPropertyBag_ReadDWORDDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef);
STDAPI_(void) SHPropertyBag_ReadBOOLDef(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pf, BOOL fDef);
STDAPI_(void) SHPropertyBag_ReadGUIDDef(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid, const GUID* pguidDef);
STDAPI_(void) SHPropertyBag_ReadPOINTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt, const POINTL* pptDef);
STDAPI_(void) SHPropertyBag_ReadPOINTSDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt, const POINTS* pptDef);
STDAPI_(void) SHPropertyBag_ReadRECTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc, const RECTL* prcDef);
STDAPI_(BOOL) SHPropertyBag_ReadBOOLDefRet(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fDef);
STDAPI SHPropertyBag_ReadStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm);
STDAPI SHPropertyBag_WriteStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm);
STDAPI SHPropertyBag_ReadPOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt);
STDAPI SHPropertyBag_WritePOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt);
STDAPI_(void) SHPropertyBag_ReadDWORDScreenResDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef);
STDAPI SHPropertyBag_WriteDWORDScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD dw);
STDAPI SHPropertyBag_ReadPOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt);
STDAPI SHPropertyBag_WritePOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt);
STDAPI SHPropertyBag_ReadRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc);
STDAPI SHPropertyBag_WriteRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc);
STDAPI SHPropertyBag_DeleteScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName);


#define VS_BAGSTR_EXPLORER      L"Shell"
#define VS_BAGSTR_DESKTOP       L"Desktop"
#define VS_BAGSTR_COMCLG        L"ComDlg"

#define VS_PROPSTR_MINPOS       L"MinPos"
#define VS_PROPSTR_MAXPOS       L"MaxPos"
#define VS_PROPSTR_POS          L"WinPos"
#define VS_PROPSTR_MODE         L"Mode"
#define VS_PROPSTR_REV          L"Rev"
#define VS_PROPSTR_WPFLAGS      L"WFlags"
#define VS_PROPSTR_SHOW         L"ShowCmd"
#define VS_PROPSTR_FFLAGS       L"FFlags"
#define VS_PROPSTR_HOTKEY       L"HotKey"
#define VS_PROPSTR_BUTTONS      L"Buttons"
#define VS_PROPSTR_STATUS       L"Status"
#define VS_PROPSTR_LINKS        L"Links"
#define VS_PROPSTR_ADDRESS      L"Address"
#define VS_PROPSTR_VID          L"Vid"
#define VS_PROPSTR_SCROLL       L"ScrollPos"
#define VS_PROPSTR_SORT         L"Sort"
#define VS_PROPSTR_SORTDIR      L"SortDir"
#define VS_PROPSTR_COL          L"Col"
#define VS_PROPSTR_COLINFO      L"ColInfo"
#define VS_PROPSTR_ITEMPOS      L"ItemPos"





//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG

////////////////
//
//  computer display name support
//
//   Display name: A formatted name that NetFldr uses. It is currently constructed out of the computer name,
//                 and, if available, the computer comment (description).
//   DSheldon
STDAPI SHBuildDisplayMachineName(LPCWSTR pszMachineName, LPCWSTR pszComment, LPWSTR pszDisplayName, DWORD cchDisplayName);
STDAPI CreateFromRegKey(LPCWSTR pszKey, LPCWSTR pszValue, REFIID riid, void **ppv);

STDAPI_(LPCTSTR) SkipServerSlashes(LPCTSTR pszName);

//
// A couple of inline functions that create an HRESULT from
// a Win32 error code without the double-evaluation side effect of
// the HRESULT_FROM_WIN32 macro.  
//
// Use ResultFromWin32 in place of HRESULT_FROM_WIN32 if 
// the side effects of that macro are unwanted.  
// ResultFromLastError was created as a convenience for a 
// common idiom.  
// You could simply call ResultFromWin32(GetLastError()) yourself.
//
__inline HRESULT ResultFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}

__inline HRESULT ResultFromLastError(void)
{
    return ResultFromWin32(GetLastError());
}

STDAPI_(void) IEPlaySound(LPCTSTR pszSound, BOOL fSysSound);

STDAPI IUnknown_DragEnter(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
STDAPI IUnknown_DragOver(IUnknown* punk, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
STDAPI IUnknown_DragLeave(IUnknown* punk);
STDAPI IUnknown_Drop(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

STDAPI_(BOOL) IsTypeInList(LPCTSTR pszType, const LPCTSTR *arszList, UINT cList);

//----------------------------------------------------------------------
//  Msg:    WM_MSIME_MODEBIAS
//  Desc:   input mode bias
//  Owner:  YutakaN
//  Usage:  SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, MODEBIASMODE_xxxx );
//  wParam: operation of bias
//  lParam: bias mode
//  return: If wParam is MODEBIAS_GETVERSION,returns version number of interface.
//          If wParam is MODEBIAS_SETVALUE : return non-zero value if succeeded. Returns 0 if fail.
//          If wParam is MODEBIAS_GETVALUE : returns current bias mode.

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS            TEXT("MSIMEModeBias")

// Current version
#define VERSION_MODEBIAS        1

// Set or Get (wParam)
#define MODEBIAS_GETVERSION     0
#define MODEBIAS_SETVALUE       1
#define MODEBIAS_GETVALUE       2

// Bias (lParam)
#define MODEBIASMODE_DEFAULT                0x00000000	// reset all of bias setting
#define MODEBIASMODE_FILENAME               0x00000001	// filename
#define MODEBIASMODE_READING                0x00000002	// reading recommended
#define MODEBIASMODE_DIGIT                  0x00000004	// ANSI-Digit Recommended Mode
#define MODEBIASMODE_URLHISTORY             0x00010000  // URL history

STDAPI_(void) SetModeBias(DWORD dwMode);

STDAPI GetVersionFromString64(LPCWSTR psz, __int64 *pVer);

#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\chanmgrp.h ===
//
// Private channel manager include file.
//

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv

DECLARE_INTERFACE_(IChannelMgrPriv, IUnknown)
{
    typedef enum _tagCHANNELFOLDERLOCATION { CF_CHANNEL, CF_SOFTWAREUPDATE } CHANNELFOLDERLOCATION;

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;
};

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv2
DECLARE_INTERFACE_(IChannelMgrPriv2, IChannelMgrPriv)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;

    // *** IChannelMgrPriv2 ***
    STDMETHOD(WriteScreenSaverURL) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszScreenSaverURL) PURE;
    STDMETHOD(RefreshScreenSaverURLs) (THIS) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cnctnpt.h ===
#ifndef __CNCTNPT_H__
#define __CNCTNPT_H__

//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
//  This class is shared between DLLs, and DLLs that use it have already
//  shipped as part of IE4 (specifically, shell32).  This means that
//  any changes you make must be done EXTREMELY CAREFULLY and TESTED
//  FOR INTEROPERABILITY WITH IE4!  For one thing, you have to make sure
//  that none of your changes alter the vtbl used by IE4's shell32.
//
//  If you change CIE4ConnectionPoint, you must build SHDOC401 and
//  test it on IE4!
//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//

//
//  First, the class as it was defined in IE4.  All virtual functions
//  must be be listed in exactly the same order as they were in IE4.
//  Fortunately, no cross-component users mucked with the member
//  variables.
//
//  Change any of these at your own risk.
//
class CIE4ConnectionPoint : public IConnectionPoint {

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID FAR* pIID) PURE;
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer FAR* FAR* ppCPC) PURE;
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie) PURE;
    virtual STDMETHODIMP Unadvise(DWORD dwCookie) PURE;
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS FAR* ppEnum) PURE;

    // This is how you actually fire the events
    // Those called by shell32 are virtual
    // (Renamed to DoInvokeIE4)
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams) PURE;

    // This helper function does work that callers of DoInvoke often need done
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel) PURE;

};

//
// CConnectionPoint is an implementation of a conection point.
// To get the rest of the implementation, you also have to include
// lib\cnctnpt.cpp in your project.
//
// Embed an instance of CConnectionPoint in an object that needs to
// implement a connectionpoint and call SetOwner to initialize it.
//
// Fire events to anyone connected to this connectionpoint via DoInvoke
// or DoOnChanged.  External clients should use the shlwapi functions
// like IConnectionPoint_Invoke or IConnectionPoint_OnChanged.
//

class CConnectionPoint : public CIE4ConnectionPoint {
    friend class CConnectionPointEnum;

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return m_punk->AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return m_punk->Release(); }

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID * pIID);
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer ** ppCPC);
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    virtual STDMETHODIMP Unadvise(DWORD dwCookie);
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS * ppEnum);

    // CIE4ConnectionPoint methods - called by IE4's shell32
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams);

    // DoInvokePidlIE4 is strange in that shell32 linked to it but never
    // actually called it.  This makes the implementation particularly simple.
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel)
    { return E_NOTIMPL; }

public:
    // Additional helper methods

    // Performs a basic DISPID Invoke on the object
    inline HRESULT InvokeDispid(DISPID dispid) {
        return IConnectionPoint_SimpleInvoke(this, dispid, NULL);
    }

    // Performs an OnChanged on the object
    inline HRESULT OnChanged(DISPID dispid) {
        return IConnectionPoint_OnChanged(this, dispid);
    }

    // A couple functions to setup and destroy this subclass object
    ~CConnectionPoint(); // not virtual: nobody inherits from this class

    //
    //  The containing object must call SetOwner to initialize the
    //  connection point.
    //
    //  punk - The IUnknown of the object this ConnectionPoint is
    //         embedded in; it will be treated as the connection
    //         point container.
    //
    //  piid - The IID that the sinks are expected to support.
    //         If you call DoInvoke, then it must be derived from
    //         IID_IDispatch.  If you call DoOnChanged, then it must
    //         be exactly &IID_IPropertyNotifySink.
    //
    void SetOwner(IUnknown* punk, const IID* piid)
        {
            // Validate the special requirement on the piid parameter.
            if (*piid == IID_IPropertyNotifySink)
            {
                ASSERT(piid == &IID_IPropertyNotifySink);
            }

            // don't AddRef -- we're a member variable of the object punk points to
            m_punk = punk;
            m_piid = piid;
        }

    // The underline version is inline
    BOOL _HasSinks() { return (BOOL)m_cSinks; }

    // We are empty if there are no sinks
    BOOL IsEmpty() { return !_HasSinks(); }

    HRESULT UnadviseAll(void);

    // A lot of people need to convert a CConnectionPoint into an
    // IConnectionPoint.  We used to be multiply inherited, hence the
    // need for this member, but that's gone now.
    IConnectionPoint *CastToIConnectionPoint()
        { return SAFECAST(this, IConnectionPoint*); }

private:
    IUnknown **m_rgSinks;
    int m_cSinks;
    int m_cSinksAlloc;

    IUnknown *m_punk;   // IUnknown of object containing us
    const IID *m_piid;  // IID of this connection point
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cobjsafe.h ===
#ifndef _COBJSAFE_H_
#define _COBJSAFE_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    CObjectSafety() : _dwSafetyOptions(0) { }

    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif // _COBJSAFE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

//
//  use this when you dont have a good Destroy site chain event - ZekeL - 20-DEC-2000
//  if you need to call SetSite(NULL) on your children, and 
//  would prefer to do this cleanup in your destructor.
//  your object should be implemented like this
//
/******
class CMyObject : public IMyInterface
{
private:
    CSafeServiceSite *_psss;
    IKid _pkid;

    CMyObject() 
    {
        _psss = new CSafeServiceSite();
        if (_psss)
            _psss->SetProviderWeakRef(this);
    }

    ~CMyObject() 
    {
        if (_psss)
        {
            _psss->SetProviderWeakRef(NULL);
            _psss->Release();
        }

        if (_pkid)
        {
            IUnknown_SetSite(_pkid, _psss);
            _pkid->Release();
        }
    }

public:
    //  IMyInterface
    HRESULT Init()
    {
        CoCreate(CLSID_Kid, &_pkid);
        IUnknown_SetSite(_pkid, _psss);
    }
    // NOTE - there is no Uninit()
    //  so it's hard to know when to release _pkid
    //  and you dont want to _pkid->SetSite(NULL)
    //  unless you are sure you are done
};
******/
        
class CSafeServiceSite : public IServiceProvider
{
public:
    CSafeServiceSite() : _cRef(1), _psp(NULL) {}
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // our personal weak ref
    HRESULT SetProviderWeakRef(IServiceProvider *psp);

private:    //  methods
    ~CSafeServiceSite()
        { ASSERT(_psp == NULL); }

private:    //  members
    LONG _cRef;
    IServiceProvider *_psp;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cfdefs.h ===
#ifndef _STATIC_CLASS_FACTORY_
#define _STATIC_CLASS_FACTORY_

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

/*
 * Class Factory Implementation for C++ without CTRStartup required.
 */

#ifdef __cplusplus

#ifdef UNIX

#define STDMETHODX  STDMETHOD
#define STDMETHODX_ STDMETHOD_

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf: public IClassFactory                                \
   {                                                             \
     public:                                                     \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \


#else  // UNIX

#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf                                                      \
   {                                                             \
     public:                                                     \
       IClassFactory *vtable;                                    \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \

#endif // UNIX


DECLARE_CLASS_FACTORY( CClassFactory );


struct IClassFactoryVtbl
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE CClassFactory::*QueryInterface)(REFIID riid, void ** ppvObj);
    ULONG (STDMETHODCALLTYPE CClassFactory::*AddRef)();
    ULONG (STDMETHODCALLTYPE CClassFactory::*Release)();
    
    // IClassFactory
    HRESULT (STDMETHODCALLTYPE CClassFactory::*CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    HRESULT (STDMETHODCALLTYPE CClassFactory::*LockServer)(BOOL);
};

typedef struct IClassFactoryVtbl IClassFactoryVtbl;

//
// class CObjectInfo
//

class CObjectInfo;
typedef CObjectInfo* LPOBJECTINFO;
typedef CObjectInfo const* LPCOBJECTINFO;
typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CObjectInfo : public CClassFactory                               
{                                                                      
public:                                                                
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;

    CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein,  IID const* piidIn, IID const* piidEventsIn, long lVersionIn,  DWORD dwOleMiscFlagsIn,  DWORD dwClassFactFlagsIn);

};
#ifndef NO_CFVTBL
const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory::QueryInterface,  
    CClassFactory::AddRef, 
    CClassFactory::Release,
    CClassFactory::CreateInstance,
    CClassFactory::LockServer
};
#endif
//
// CLASS FACTORY TABLE STUFF
//

typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;


#ifdef UNIX


#define CF_TABLE_BEGIN(cfTable) const CObjectInfo cfTable[] = { 
#define CF_TABLE_ENTRY         CObjectInfo
#define CF_TABLE_ENTRY_NOFLAGS CObjectInfo
#define CF_TABLE_ENTRY_ALL     CObjectInfo
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) };
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)ptr)

#else // UNIX

#define CF_TABLE_BEGIN(cfTable) const OBJECTINFO cfTable##_tble[] = { 
#define CF_TABLE_ENTRY(p1, p2, p3) { (void *)&c_CFVtbl, p1, p2, p3 }
#define CF_TABLE_ENTRY_NOFLAGS(p1, p2, p3, p4) { (void *)&c_CFVtbl, p1, p2, p3, p4 }
#define CF_TABLE_ENTRY_ALL(p1, p2, p3, p4, p5, p6, p7) { (void *)&c_CFVtbl, p1, p2, p3, p4 , p5, p6, p7}
#define CF_TABLE_END(cfTable)                                         \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) }; \
    const CObjectInfo *cfTable = (const CObjectInfo *)cfTable##_tble;
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)&ptr->vtable)

#endif // UNIX

#define DECLARE_CF_TABLE(cfTable) extern const CObjectInfo *cfTable;

#endif // __cplusplus


#endif // _STATIC_CLASS_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define DECL_CRTFREE.
// (CPP_FUNCTIONS is the old name.)
//

#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

#ifndef UNIX

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (LPVOID)LocalAlloc(LPTR, nSize);
}

void  __cdecl operator delete(void *pv)
{
    //delete and LocalFree both handle NULL, others don't
    //If changed to GlobalFree or HeapFree - must check for NULL here
    LocalFree((HLOCAL)pv);
}
#endif

extern "C" int __cdecl _purecall(void) 
{
#ifdef ASSERT_MSG
    ASSERT_MSG(0, "purecall() hit");
#endif

#ifdef DEBUG
    DebugBreak();
#endif // DEBUG
    return 0;
}

#endif  // DECL_CRTFREE


#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cstrinout.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:       cstrinout.h
//
//  Contents:   shell-wide string thunkers, for use by unicode wrappers
//
//----------------------------------------------------------------------------

#ifndef _CSTRINOUT_HXX_
#define _CSTRINOUT_HXX_

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStr (CStr)
//
//  Purpose:    Base class for conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStr
{
public:
    operator char *();
    inline BOOL IsAtom() { return _uCP == CP_ATOM; }

protected:
    CConvertStr(UINT uCP);
    ~CConvertStr();
    void Free();

    UINT    _uCP;
    LPSTR   _pstr;
    char    _ach[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::CConvertStr
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::CConvertStr(UINT uCP)
{
    _uCP = uCP;
    _pstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::~CConvertStr
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::~CConvertStr()
{
    Free();
}





//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CConvertStr::operator char *()
{
    return _pstr;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrIn (CStrI)
//
//  Purpose:    Converts string function arguments which are passed into
//              a Windows API.
//
//----------------------------------------------------------------------------

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr);
    CStrIn(LPCWSTR pwstr, int cwch);
    CStrIn(UINT uCP, LPCWSTR pwstr);
    CStrIn(UINT uCP, LPCWSTR pwstr, int cwch);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch);

    int _cchLen;
};




//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class with a given length
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn(LPCWSTR pwstr, int cwch) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwch);
}

inline
CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr, int cwch) : CConvertStr(uCP)
{
    Init(pwstr, cwch);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn() : CConvertStr(CP_ACP)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrIn::strlen()
{
    return _cchLen;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIM)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr);
};


//+---------------------------------------------------------------------------
//
//  Class:      CPPFIn
//
//  Purpose:    Converts string function arguments which are passed into
//              a Win9x PrivateProfile API.  Win9x DBCS has a bug where
//              passing a string longer than MAX_PATH will fault kernel.
//
//              PPF = Private Profile Filename
//
//----------------------------------------------------------------------------

class CPPFIn
{
public:
    operator char *();
    CPPFIn(LPCWSTR pwstr);

private:
    char _ach[MAX_PATH];
};

//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CPPFIn::operator char *()
{
    return _ach;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOut (CStrO)
//
//  Purpose:    Converts string function arguments which are passed out
//              from a Windows API.
//
//----------------------------------------------------------------------------

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();
protected:
    void Init(LPWSTR pwstr, int cwchBuf);
private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOut::BufSize()
{
    return _cwchBuf * sizeof(WCHAR);
}

//
//	Multi-Byte ---> Unicode conversion
//

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStrW (CStr)
//
//  Purpose:    Base class for multibyte conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::CConvertStrW
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::~CConvertStrW
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::~CConvertStrW()
{
    Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::operator WCHAR *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline 
CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}


//+---------------------------------------------------------------------------
//
//  Class:      CStrInW (CStrI)
//
//  Purpose:    Converts multibyte strings into UNICODE
//
//----------------------------------------------------------------------------

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr) { Init(pstr, -1); }
    CStrInW(LPCSTR pstr, int cch) { Init(pstr, cch); }
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch);

    int _cwchLen;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrInW::CStrInW()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrInW::strlen()
{
    return _cwchLen;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOutW (CStrO)
//
//  Purpose:    Converts returned unicode strings into ANSI.  Used for [out]
//              params (so we initialize with a buffer that should later be
//              filled with the correct ansi data)
//
//
//----------------------------------------------------------------------------

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf);
    ~CStrOutW();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPSTR  	_pstr;
    int     _cchBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOutW::BufSize()
{
    return _cchBuf;
}



#endif // _CSTRINOUT_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cwndproc.h ===
#ifndef _CWNDPROC_H_
#define _CWNDPROC_H_

// CImpWndProc
//
// Use this class when you want to associate a window with
// an object using a virtual wndproc.
// 
// NOTE: The window's lifetime must be encompassed by the object.
//       I.E. NO REFCOUNT IS HELD ON THE OBJECT!
//
// Messages after WM_NCCREATE up to and including WM_DESTROY
// are forwarded to v_WndProc.
//
// _hwnd is non-NULL from WM_NCCREATE up to but not during WM_DESTROY.
// (Not during because the final release may be tied to WM_DESTROY
// so we cannot reference member variables after forwarding thie message.)
//
class CImpWndProc
{
public:
    virtual ULONG __stdcall AddRef() = 0;
    virtual ULONG __stdcall Release() = 0;

protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND _hwnd;

} ;


// CNotifySubclassWndProc
//
// This class subclasses an HWND, registers for SHChangeNotify events,
// and forwards them to the inheritor's IShellChangeNotify implementation.
//
// You need one instance of this class per window you want to subclass
// and register for events against. (So if you need >1 window hooked up
// in this matter, you need to have member implementations that inherit
// from this class.)
//
class CNotifySubclassWndProc
{
public:
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;

protected:
    BOOL _SubclassWindow(HWND hwnd);
    void _UnsubclassWindow(HWND hwnd);
    void _RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                         UINT uFlags = (SHCNRF_ShellLevel | SHCNRF_InterruptLevel));
    void _UnregisterWindow(HWND hwnd);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    void _FlushNotifyMessages(HWND hwnd);

private:
    static LRESULT CALLBACK _SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    UINT        _uRegister;         // SHChangeNotify id

#ifdef DEBUG
    HWND        _hwndSubclassed;
#endif
} ;

#endif _CWNDPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\cwndproc.cpp ===
#include "cwndproc.h"

#define ID_NOTIFY_SUBCLASS (DWORD)'CHN'     // CHN change notify
//
// CImpWndProc
//
LRESULT CALLBACK CImpWndProc::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (WM_NCCREATE == uMsg)
    {
        CImpWndProc* pThis = (CImpWndProc*)(((LPCREATESTRUCT)lParam)->lpCreateParams);
        if (EVAL(pThis))
        {
            pThis->_hwnd = hwnd;
            SetWindowPtr(hwnd, 0, pThis);

            // Even if pThis->vWndProc fails the create, USER will always
            // send us a WM_NCDESTROY so we always get a chance to clean up
            return pThis->v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        return FALSE;
    }
    else
    {
        CImpWndProc* pThis = (CImpWndProc*)GetWindowPtr0(hwnd);    // GetWindowLong(hwnd, 0);
        LRESULT lres;

        if (pThis)
        {
            // Always retain a ref across the v_WndProc in case
            // the window destroys itself during the callback.
            pThis->AddRef();

            lres = pThis->v_WndProc(hwnd, uMsg, wParam, lParam);

            if (uMsg == WM_NCDESTROY)
            {
                SetWindowPtr(hwnd, 0, NULL);
                pThis->_hwnd = NULL;
            }
            pThis->Release();
        }
        else
        {
            //
            // The only way this should happen is if we haven't actually
            // gotten a WM_NCCREATE yet.  User sends a WM_GETMINMAXINFO
            // to some windows before WM_NCCREATE (for legacy compat).
            // Assert that we're hitting that case.
            //
            ASSERT(uMsg == WM_GETMINMAXINFO);

            lres = SHDefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        return lres;
    }
}

#ifndef NO_NOTIFYSUBCLASSWNDPROC

//
// CNotifySubclassWndProc
//
UINT g_idFSNotify;        // the message SHChangeNotify sends

BOOL CNotifySubclassWndProc::_SubclassWindow(HWND hwnd)
{
    if (0 == g_idFSNotify)
    {
        g_idFSNotify = RegisterWindowMessage(TEXT("SubclassedFSNotify"));
    }

    DEBUG_CODE( _hwndSubclassed = hwnd; );

    return SetWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS, (DWORD_PTR)this);
}

void CNotifySubclassWndProc::_UnsubclassWindow(HWND hwnd)
{
    RemoveWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS);
}

LRESULT CNotifySubclassWndProc::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    return DefSubclassProc(hwnd, uMessage, wParam, lParam);
}

LRESULT CALLBACK CNotifySubclassWndProc::_SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CNotifySubclassWndProc* pObj = (CNotifySubclassWndProc*)dwRefData;

    if (pObj)
    {
        if (uMessage == g_idFSNotify)
        {
            LPSHChangeNotificationLock pshcnl;
            LPITEMIDLIST *ppidl;
            LONG lEvent;

            if (g_fNewNotify && (wParam || lParam))
            {
                // New style of notifications need to lock and unlock in order to free the memory...
                pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD) lParam, &ppidl, &lEvent);
                if (pshcnl)
                {
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
                }
            }
            else
            {
                lEvent = (DWORD) lParam; // process id's are 32bits even in WIN64
                ppidl = (LPITEMIDLIST*)wParam;
                pshcnl = NULL;
                if (ppidl)
                {
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
                }
            }

            if (pshcnl)
            {
                SHChangeNotification_Unlock(pshcnl);
            }

            return 0;
        }
        else
        {
            return pObj->_DefWindowProc(hwnd, uMessage, wParam, lParam);
        }
    }
    else
    {
        return DefSubclassProc(hwnd, uMessage, wParam, lParam);
    }
}

void CNotifySubclassWndProc::_FlushNotifyMessages(HWND hwnd)
{
    MSG msg;

    ASSERT(hwnd == _hwndSubclassed);

    // This SHChangeNotify calls flushes notifications
    // via PostMessage, so I need to remove them
    // myself and process them immediately...
    //
    SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL);

    while (PeekMessage(&msg, hwnd, g_idFSNotify, g_idFSNotify, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void CNotifySubclassWndProc::_RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                                             UINT uFlags/* = SHCNRF_ShellLevel | SHCNRF_InterruptLevel*/)
{
    ASSERT(0 != g_idFSNotify);

    // We only register if there's something to listen to
    //
    if (0==_uRegister)
    {
        // Since we don't know what this pidl actually points to,
        // we have to register to listen to everything that might affect it...
        //
        _uRegister = RegisterNotify(hwnd, g_idFSNotify, pidl, lEvents, uFlags, TRUE);

        ASSERT(hwnd == _hwndSubclassed);
    }
}

void CNotifySubclassWndProc::_UnregisterWindow(HWND hwnd)
{
    if (_uRegister)
    {
        ASSERT(hwnd == _hwndSubclassed);

        // Avoid getting reentered...
        UINT uRegister = _uRegister;
        _uRegister = 0;
        SHChangeNotifyDeregister(uRegister);
    }
}

#endif  // NO_NOTIFYSUBCLASSWNDPROC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dbgmem.cpp ===
#ifdef DEBUG

#include <dbgmem.h>

//EXTERN_C BOOL g_bUseNewLeakDetection;
BOOL          g_bRegistered = FALSE;

HINSTANCE g_hinstDBG;
#define   SHELLDBG    "ShellDBG.DLL"

STDAPI_(void) _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc);
// the following are in olestuff.cpp
STDAPI_(void) _DebugMemLeak(UINT flag, LPCTSTR pszFile, UINT iLine);
STDAPI_(void) _add_to_memlist(HMODULE hmod, void *pv, UINT nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine);
STDAPI_(void) _remove_from_memlist(void *pv);
STDAPI_(void) _remove_from_thread_memlist(DWORD dwThreadId, LPVOID pv);
STDAPI_(void) _transfer_to_thread_memlist(DWORD dwThread, LPVOID pv);
STDAPI_(UINT) _mem_thread_message(void);
STDAPI_(void) _received_for_thread_memlist(DWORD dwFlags, void * pData);
STDAPI_(void) _register_intelli_dump(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns);

STDAPI_(void) MemLeakInit(UINT wFlags, LPCTSTR pszFile, UINT iLine);
STDAPI_(void) MemLeakTerminate(DWORD dwFlags);

// should be in olestuff.cpp of each dll
STDAPI_(void) DumpLeakedMemory(PLEAKMEMINFO pmeminfo);
STDAPI_(LPWSTR) GetLeakSymbolicName(PLEAKMEMINFO pmeminfo, LPWSTR pwszBuf, int cchBuf);

static const INTELLILEAKDUMPCBFUNCTIONS c_ildcbf = {
    DumpLeakedMemory,
    GetLeakSymbolicName
};

#define DELAY_LOAD_LEAK_VOID(_fn, _ord, _args, _nargs)  \
void __stdcall _fn _args                                \
{                                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;    \
    if (g_bUseNewLeakDetection)                         \
    {                                                   \
        if (!g_bRegistered)                             \
        {                                               \
            register_intelli_dump(HINST_THISDLL, &c_ildcbf); \
            g_bRegistered = TRUE;                       \
        }                                               \
        _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    }                           \
    else                         \
        _pfn##_fn = _##_fn;       \
    if (_pfn##_fn)               \
        _pfn##_fn _nargs;        \
    return;                      \
}

#define DELAY_LOAD_LEAK_FN(_ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                            \
{                                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;    \
    if (g_bUseNewLeakDetection)                         \
    {                                                   \
        if (!g_bRegistered)                             \
        {                                               \
            register_intelli_dump(HINST_THISDLL, &c_ildcbf); \
            g_bRegistered = TRUE;                       \
        }                                               \
        _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    }                            \
    else                         \
        _pfn##_fn = _##_fn;       \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs;        \
    return (_ret)_err;                      \
}

#define _MemLeakInit _DebugMemLeak // for delay load macro to work
DELAY_LOAD_LEAK_VOID(MemLeakInit, 2, 
                     (UINT wFlags, LPCTSTR pszFile, UINT iLine), 
                     (wFlags, pszFile, iLine))

// does nothing for now because MemLeakInit is called to terminate leak detection as well
STDAPI_(void) MemLeakTerminate(DWORD dwFlags)
{
}

DELAY_LOAD_LEAK_VOID(add_to_memlist, 3, 
                     (HMODULE hmod, void *pv, UINT nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine),
                     (hmod, pv, nSize, nType, pszFile, iLine))
DELAY_LOAD_LEAK_FN(UINT, mem_thread_message, 4, (void), (), 0)
DELAY_LOAD_LEAK_VOID(received_for_thread_memlist, 5, (DWORD dwFlags, void *pData), (dwFlags, pData))
DELAY_LOAD_LEAK_VOID(remove_from_memlist, 6, (void *pv), (pv))
DELAY_LOAD_LEAK_VOID(remove_from_thread_memlist, 7, (DWORD dwThreadId, LPVOID pv), (dwThreadId, pv))
DELAY_LOAD_LEAK_VOID(transfer_to_thread_memlist, 8, (DWORD dwThreadId, LPVOID pv), (dwThreadId, pv))

//DELAY_LOAD_LEAK_VOID(register_intelli_dump, 9, (HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns), (hmod, pfns))
void register_intelli_dump(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns)
{
    static void (__stdcall *pfnregister_intelli_dump)(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS *pfns) = NULL;

    if (!pfnregister_intelli_dump)
    {
        if (g_bUseNewLeakDetection)
            _GetProcFromDLL(&g_hinstDBG, SHELLDBG, (FARPROC*)&pfnregister_intelli_dump, (LPCSTR)9);
        else
            pfnregister_intelli_dump = _register_intelli_dump;
    }

    if (pfnregister_intelli_dump)
        pfnregister_intelli_dump(hmod, pfns);
}

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\deballoc.c ===
//====================================================================
// Debugging memory problems.
//====================================================================

#undef LocalAlloc
#undef LocalReAlloc	
#undef LocalFree

#define CBALLOCEXTRA		(sizeof(LPARAM)+sizeof(UINT))
#define HMEM2PTR(hMem,i)	(((BYTE*)hMem)+i)

void _StoreSigniture(HLOCAL hMem, UINT uByte, LPARAM lParam)
{
    if (hMem)
    {
        SIZE_T uSize = LocalSize(hMem);
        ASSERT(uSize>=uByte+CBALLOCEXTRA);
        *(UINT*)HMEM2PTR(hMem, uSize-sizeof(UINT)) = uByte;
        *(LPARAM*)HMEM2PTR(hMem, uByte) = lParam;
    }
}

UINT _ValidateLocalMem(HLOCAL hMem, LPARAM lParam, LPCSTR pszText)
{
    UINT uByte = 0;
    if (hMem)
    {
        SIZE_T uSize = LocalSize(hMem);
        if (uSize)
        {
            LPARAM lParamStored;
            uByte = *(UINT*)HMEM2PTR(hMem, uSize-sizeof(UINT));
            AssertMsg(uByte+CBALLOCEXTRA <= uSize,
                      TEXT("cm ASSERT! Bogus uByte %d (%s for %x)"),
                      uByte, pszText, hMem);
            lParamStored = *(LPARAM*)HMEM2PTR(hMem, uByte);
            AssertMsg(lParamStored==lParam, TEXT("cm ASSERT! Bad Signiture %x (%s for %x)"),
                      lParamStored, pszText, hMem);
        }
        else
        {
            AssertMsg(0, TEXT("cm ASSERT! LocalSize is zero (%s for %x)"),
                      pszText, hMem);
        }
    }
    return uByte;
}

HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes)
{
    HLOCAL hMem = LocalAlloc(uFlags, uBytes+CBALLOCEXTRA);
    _StoreSigniture(hMem, uBytes, (LPARAM)hMem);
    return hMem;
}

HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags)
{
    HLOCAL hNew;
    _ValidateLocalMem(hMem, (LPARAM)hMem, "LocalReAlloc");
    hNew = LocalReAlloc(hMem, uBytes+CBALLOCEXTRA, uFlags);
    _StoreSigniture(hNew, uBytes, (LPARAM)hNew);
    return hNew;
}

HLOCAL WINAPI DebugLocalFree( HLOCAL hMem )
{
    UINT uBytes = _ValidateLocalMem(hMem, (LPARAM)hMem, "LocalFree");
    if (uBytes)
    {
        _StoreSigniture(hMem, uBytes, (LPARAM)0xDDDDDDDDL);
    }
    else
    {
        AssertMsg(0, TEXT("cm ASSERT! LocalFree _ValidateLocalMem returned 0 for %x"), hMem);
    }
    return LocalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dbutil.cpp ===
//***   dbutil.cpp -- debug helpers
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/dbutil.cpp"

#ifdef DEBUG // {

#if ( _X86_)

// warning: these macros assume we have an ebp-linked chain.  for debug we do.
#define BP_GETOLDBP(pbp)    (*((int *)(pbp) + 0))
#define BP_GETRET(pbp)      (*((int *)(pbp) + 1))

//***   DBGetStackBack -- walk stack frame
// #if 0 w/ sanity checks #endif
// ENTRY/EXIT
//  pfp         INOUT ptr to frame ptr (IN:starting, OUT:ending)
//  pstkback    OUT:fp/ret pairs, IN:optional size/addr pairs for sanity check
//  nstkback    ARRAYSIZE(pstckback)
//  #if 0
//  ncheck      # of IN pstkback size/addr sanity-check pairs
//  #endif
//  n           (return) # of frames successfully walked
// DESCRIPTION
//  fills in OUT pstckback w/ backtrace info for nstckback frames.
//  #if 0
//  if ncheck > 0, makes sure that initial backtrace entries are in the
//  range of the function specified by the IN size/addr pairs in pstkback.
//  #endif
// NOTES
//  not sure if we return the right pfp' value (untested)
int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback /*,int nchk*/)
{
    int fp = *pfp;
    int ret;
    int i = 0;

    __try {
        for (; i < nstkback; i++, pstkback++) {
            ret = BP_GETRET(fp);
#if 0
            if (i < ncheck && pstkback->ret != 0) {
                ASSERT(pstkback->fp == 0 || pstkback->fp == -1 || pstkback->fp <= 512);
                if (!(pstkback->ret <= ret && ret <= pstkback->ret + pstkback->fp)) {
                    // constraint violated
                    break;
                }
            }
#endif
            fp = BP_GETOLDBP(fp);
            pstkback->ret = ret;
            pstkback->fp = fp;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        TraceMsg(TF_ALWAYS, "atm: GPF");
        // just use last 'ret' we had
    }

    *pfp = fp;
    return i;
}

#endif
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dbutil.h ===
#ifndef _DBUTIL_H_
//***   dbutil.h -- debug helper routines
//

// dbutil.cpp
struct DBstkback {
    int fp;     // frame ptr
    int ret;    // return addr
};

int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback);

// dump.c
// ...

#define _DBUTIL_H_
#endif // _DBUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\deballoc.h ===
#if 0
#pragma message("### Building FULL_DEBUG version ###")
#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree
#define LocalAlloc      DebugLocalAlloc
#define LocalReAlloc    DebugLocalReAlloc
#define LocalFree       DebugLocalFree

#ifdef __cplusplus
extern "C" {
#endif

HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes);
HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags);
HLOCAL WINAPI DebugLocalFree( HLOCAL hMem );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dbgmem.h ===
/* Copyright 1996 Microsoft */

#ifndef _DBGMEMORY_
#define _DBGMEMORY_

#ifdef DEBUG

#define DBGMEM_MEMORY   0x00
#define DBGMEM_STRDUP   0x01
#define DBGMEM_OBJECT   0x02
#define DBGMEM_TRACED   0x04
#define DBGMEM_UNKNOBJ  0x08

#endif // DEBUG


#define     DML_TYPE_MAIN            0
#define     DML_TYPE_THREAD          1
#define     DML_TYPE_FRAME           2
#define     DML_TYPE_DOWNLOAD        3
#define     DML_TYPE_NAVIGATE        4
#define     DML_TYPE_MASK   0x0000000f
#define     DML_BEGIN       0x00000000
#define     DML_END         0x80000000

#ifdef DEBUG

EXTERN_C BOOL g_bUseNewLeakDetection;

STDAPI_(void) MemLeakInit(UINT wFlags, LPCTSTR pszFile, UINT iLine);
#define DebugMemLeak(wFlags)  MemLeakInit(wFlags, TEXT(__FILE__), __LINE__)

// shdocvw memory leak tracker...
// void _DumpMemLeak( DWORD dwFlags ); // call DebugMemLeak instead!

// stuff used to move memory ownership from one thread to another
STDAPI_(void) remove_from_thread_memlist( DWORD dwThreadId, LPVOID pv );
STDAPI_(void) transfer_to_thread_memlist( DWORD dwThread, LPVOID pv );
STDAPI_(UINT) mem_thread_message( void );
STDAPI_(void) received_for_thread_memlist( DWORD dwFlags, void * pData );
#else
#define DebugMemLeak(wFlags)  (0)
#endif

typedef struct _leakmeminfo {
    HMODULE hmod;               // which dll was it allocated from...
    void*   pv;
    UINT    cb;
    UINT    nType;
    // DWORD   adwCaller[4];   // for future
    LPCSTR  pszFile;            // file where memory block was allocced
    INT_PTR iLine;              // line where memory block was allocced
} LEAKMEMINFO, *PLEAKMEMINFO;

typedef struct _IntelliLeakDumpCBFunctions
{
    void (STDMETHODCALLTYPE *pfnDumpLeakedMemory)(PLEAKMEMINFO pmeminfo);
    LPWSTR (STDMETHODCALLTYPE *pfnGetLeakSymbolicName)(PLEAKMEMINFO pmeminfo, LPWSTR pwszBuf, int cchBuf);
} INTELLILEAKDUMPCBFUNCTIONS;

typedef struct _LeakDetectFunctions
{

    HLOCAL (STDMETHODCALLTYPE * pfnTrcLocalAlloc)(UINT uFlags,
                               UINT uBytes,  
                               LPCSTR pszFile,  
                               const int iLine );

    HLOCAL (STDMETHODCALLTYPE * pfnTrcLocalFree )(HLOCAL hMem );

    LPTSTR (STDMETHODCALLTYPE * pfnTrcStrDup )(LPTSTR lpSrch,
                            LPCSTR pszFile,
                            const int iLine);

    void  (STDMETHODCALLTYPE * pfnDumpMemLeak )(DWORD wFlags);
    void  (STDMETHODCALLTYPE * pfnDebugMemLeak)(UINT wFlags, LPCTSTR pszFile, UINT iLine);
    void  (STDMETHODCALLTYPE * pfnreceived_for_thread_memlist)( DWORD dwFlags, void * pData );
    void  (STDMETHODCALLTYPE * pfnremove_from_thread_memlist )( DWORD dwThreadId, LPVOID pv );
    UINT  (STDMETHODCALLTYPE * pfnmem_thread_message )();
    void  (STDMETHODCALLTYPE * pfnremove_from_memlist )(void *pv);
    void  (STDMETHODCALLTYPE * pfnadd_to_memlist )(HMODULE hmod, void *pv, unsigned int nSize, UINT nType, LPCSTR pszFile, const INT_PTR iLine );
    void  (STDMETHODCALLTYPE * pfnregister_hmod_intelli_dump)(HMODULE hmod, const INTELLILEAKDUMPCBFUNCTIONS*pildf);

} LEAKDETECTFUNCS;

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

STDAPI_(BOOL) GetLeakDetectionFunctionTable(LEAKDETECTFUNCS *pTable);
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifdef DEBUG

// use the macros below
STDAPI_(HLOCAL) _TrcLocalAlloc(
    UINT uFlags,                            // flags used in LocalAlloc
    UINT uBytes,                            // number of bytes to be allocated
    LPCSTR pszFile,                         // file which allocced memory
    const int iLine                         // line which allocced memory
    );

STDAPI_(LPTSTR)  _TrcStrDup(
    LPTSTR lpSrch,                          // pointer to string to StrDup
    LPCSTR pszFile,                         // file which allocced memory
    const int   iLine                       // line which allocced memory
    );

STDAPI_(HLOCAL) _TrcLocalFree(
    HLOCAL hMem                             // memory to be freed
    );

STDAPI_(void) add_to_memlist(
    HMODULE hmod,                           // for secondary memory allocators...
    void *pv,                               // pointer to memory block
    unsigned int nSize,                     // size of memory block
    unsigned int nType,                     // what the possible use of the memory is
    LPCSTR pszFile,                         // file name
    const INT_PTR iLine                     // line number
    );

STDAPI_(void) remove_from_memlist(
    void *pv                                // pointer to memory block
    );

STDAPI_(void) register_intelli_dump(
    HMODULE hmod, 
    const INTELLILEAKDUMPCBFUNCTIONS *pfns
    );

#ifndef _NO_DBGMEMORY_REDEFINITION_

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCSTR pszFile, const int iLine );
#define new new( __FILE__, __LINE__ )
#endif

#endif // _NO_DBGMEMORY_REDEFINITIONS

// use these macros
#define TrcLocalAlloc( _uFlags, _uBytes )   \
    _TrcLocalAlloc( _uFlags, _uBytes, __FILE__, __LINE__ )

#define TrcStrDup( _pSrc )   \
    _TrcStrDup( (LPTSTR)_pSrc, (LPCSTR)__FILE__, (const int)__LINE__ )

#define TrcLocalFree( _hMem )   \
    _TrcLocalFree( _hMem )

#define DbgAddToMemList( _pv ) \
{                              \
    if ( _pv )                 \
        add_to_memlist( 0, _pv, (UINT)LocalSize( _pv ), DBGMEM_TRACED, __FILE__, __LINE__ ); \
}

#define DbgRemoveFromMemList( _pv ) \
    remove_from_memlist( _pv )

#else // DEBUG

#define add_to_memlist(p)       (0)
#define remove_from_memlist(p)  (0)
#define remove_from_thread_memlist(p,v) (0)

#define TrcLocalAlloc( _uFlags, _uBytes )   \
    LocalAlloc( _uFlags, _uBytes )

#define TrcStrDup( _pSrc )   \
    StrDup( _pSrc )

#define TrcLocalFree( _hMem )   \
    LocalFree( _hMem )

#define DbgAddToMemList( _pv )      // NOP
#define DbgRemoveFromMemList( _pv ) // NOP

#endif // DEBUG

#endif // _DBGMEMORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#pragma warning (disable:4096)      // '__cdecl' must be used with '...'
#pragma warning (disable:4201)      // nonstandard extension used : nameless struct/union
#pragma warning (disable:4115)      // named type definition in parentheses

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_qwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern ULONGLONG g_qwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_LEAKS            0x80000000      // Break on detecting a leak

// Trace flags for g_qwTraceFlags
#define TF_ALWAYS           0xFFFFFFFFFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_MEMUSAGE                       0x0000000100000000      
#define TF_KEEP_ALLOCATION_STACKS         0x0000000200000000      
// (Upper 28 bits reserved for custom use per-module)

#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

// Old, archaic debug flags.  
// APPCOMPAT (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

void    AttachUserModeDebugger (void);

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                _asm int 3                              \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
        } while (gAlwaysAssert);                        \
    }
#else
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                DebugBreak();                           \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
            __endexcept                                 \
        } while (gAlwaysAssert);                        \
    }
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);


void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_qwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_qwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

UINT GetStack(UINT nDepth, CHAR *szBuffer, UINT nBufferLength);
void CDECL CcshellDebugMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(ULONGLONG flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(ULONGLONG flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg

#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#define ATLTRACE2           1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// APPCOMPAT (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\desktray.h ===
#ifndef _DESKTRAY_H_
#define _DESKTRAY_H_

#undef  INTERFACE
#define INTERFACE   IDeskTray

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLARE_INTERFACE_(IDeskTray, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDeskTray methods ***
    STDMETHOD_(UINT, AppBarGetState)(THIS) PURE;
    STDMETHOD(GetTrayWindow)(THIS_ HWND* phwndTray) PURE;
    STDMETHOD(SetDesktopWindow)(THIS_ HWND hwndDesktop) PURE;

    // WARNING!  BEFORE CALLING THE SetVar METHOD YOU MUST DETECT
    // THE EXPLORER VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    STDMETHOD(SetVar)(THIS_ int var, DWORD value) PURE;
};

#define SVTRAY_EXITEXPLORER     0   // g_fExitExplorer

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _DESKTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dldecl.h ===
#ifndef _DLDECL_H_
#define _DLDECL_H_

// Delay load declarations

// The following are defined to get the DECLSPEC_IMPORT stuff right.
// Since we have identically-named local functions that thunk to the
// real function, we need to correct the dll linkage.

#ifdef DL_OLEAUT32
#define _OLEAUT32_
#endif

#ifdef DL_OLE32
#define _OLE32_
#endif

#endif // _DLDECL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\desktopp.h ===
#ifndef _desktop_h
#define _desktop_h

#include <desktray.h>

// REVIEW: does not seem to be used...
// #define DTM_SIZEDESKTOP             (WM_USER + 75)
// #define DTM_EXITWINDOWS             (WM_USER + 78)


#define DTM_THREADEXIT              (WM_USER + 76)
#define DTM_SAVESTATE               (WM_USER + 77)
#define DTM_SHELLSERVICEOBJECTS     (WM_USER + 79)
#define DTM_STARTWAIT               (WM_USER + 80)
#define DTM_ENDWAIT                 (WM_USER + 81)

#define DTM_RELEASEPROXYDESKTOP     (WM_USER + 82)

#define DTM_RAISE                       (WM_USER + 83)
#define DTRF_RAISE      0
#define DTRF_LOWER      1
#define DTRF_QUERY      2    // to avoid sending a message to a hung desktop, query passes hwndTray in wParam, and desktop send TRAY a TM_DESKTOPSTATE message

#define DTM_ADDREFPROXYDESKTOP      (WM_USER + 84)
#define DTM_CREATESAVEDWINDOWS      (WM_USER + 85)
#define DTM_ENUMBANDS               (WM_USER + 86)

#ifdef DEBUG
#define DTM_NEXTCTL                 (WM_USER + 87)
#endif
#define DTM_UIACTIVATEIO            (WM_USER + 88)
#define DTM_ONFOCUSCHANGEIS         (WM_USER + 89)

#define DTM_SETUPAPPRAN             (WM_USER + 90)  // NT 5 USER posts this message to us

// END OF IE 4.00 / 4.01 MESSAGES

// BEGINNING OF IE 5.00 MESSAGES

#define DTM_GETVIEWAREAS            (WM_USER + 91)  // View area is WorkArea minus toolbar areas.
#define DTM_DESKTOPCONTEXTMENU      (WM_USER + 92)
#define DTM_UPDATENOW               (WM_USER + 93)

#define DTM_QUERYHKCRCHANGED        (WM_USER + 94)  // ask the desktop if HKCR has changed

#define DTM_MAKEHTMLCHANGES         (WM_USER + 95)  // Make changes to desktop html using dynamic HTML

#define DTM_STARTPAGEONOFF          (WM_USER + 96)  // Turn on/off the StartPage.

#define DTM_REFRESHACTIVEDESKTOP    (WM_USER + 97)  // Refresh the active desktop.

#define DTM_SETAPPSTARTCUR          (WM_USER + 98)  // UI feedback that we are starting an explorer window.

#define COF_NORMAL              0x00000000
#define COF_CREATENEWWINDOW     0x00000001      // "/N"
#define COF_USEOPENSETTINGS     0x00000002      // "/A"
#define COF_WAITFORPENDING      0x00000004      // Should wait for Pending
#define COF_EXPLORE             0x00000008      // "/E"
#define COF_NEWROOT             0x00000010      // "/ROOT"
#define COF_ROOTCLASS           0x00000020      // "/ROOT,<GUID>"
#define COF_SELECT              0x00000040      // "/SELECT"
#define COF_AUTOMATION          0x00000080      // The user is trying to use automation
#define COF_OPENMASK            0x000000FF
#define COF_NOTUSERDRIVEN       0x00000100      // Not user driven
#define COF_NOTRANSLATE         0x00000200      // Don't ILCombine(pidlRoot, pidl)
#define COF_INPROC              0x00000400      // not used
#define COF_CHANGEROOTOK        0x00000800      // Try Desktop root if not in our root
#define COF_NOUI                0x00001000      // Start background desktop only (no folder/explorer)
#define COF_SHDOCVWFORMAT       0x00002000      // indicates this struct has been converted to abide by shdocvw format. 
                                                // this flag is temporary until we rip out all the 
#define COF_NOFINDWINDOW        0x00004000      // Don't try to find the window
#define COF_HASHMONITOR         0x00008000      // pidlRoot in IETHREADPARAM struct contains an HMONITOR
#ifdef UNIX
#define COF_HELPMODE            0x00010000      // grabbed from IETHREAD.H (for completeness)
#endif
#define COF_SEPARATEPROCESS     0x00020000      // Start in a new process
#define COF_SHELLFOLDERWINDOW   0x01000000      // This is a folder window, don't append - Microsoft Internet... when no pidl...
#define COF_PARSEPATHW          0x02000000      // the NFI.pszPath needs to be parsed but it is UNICODE
#define COF_FIREEVENTONDDEREG   0x20000000      // Fire an event when DDE server is registered
#define COF_FIREEVENTONCLOSE    0x40000000      // Fire an event when browser window closes
#define COF_IEXPLORE            0x80000000

//  this is used by DTM_QUERYHKCRCHANGED and the OpenAs Dialog
//  because the OpenAs Dialog is always in a separate process,
//  and it needs to cache a cookie in the desktop for the DTM
//  the QHKCRID is passed as the wParam in the message.
typedef enum 
{
    QHKCRID_NONE = 0,
    QHKCRID_MIN = 1, 
    QHKCRID_OPENAS = QHKCRID_MIN,
    QHKCRID_VIEWMENUPOPUP,
    QHKCRID_MAX
} QHKCRID;

//  didnt add PARSEPATHA because only browseui adds it, and it is UNICODE
//  but might need it later...
#define COF_PARSEPATH      COF_PARSEPATHW

typedef struct
{
    LPSTR pszPath;
    LPITEMIDLIST pidl;

    UINT uFlags;                // COF_ bits, (shared with IETHREADPARAM.uFlags
    int nShow;
    HWND hwndCaller;
    DWORD dwHotKey;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPSTR pszRoot;              // Only used for Parse_CmdLine
    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
    CLSID clsid;                // Only used if COF_NEWROOT

    CLSID clsidInProc;          // Only used if COF_INPROC
} NEWFOLDERINFO, *PNEWFOLDERINFO;

STDAPI_(HANDLE) SHCreateDesktop(IDeskTray* pdtray);
STDAPI_(BOOL) CreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHDesktopMessageLoop(HANDLE hDesktop);
STDAPI_(BOOL) SHExplorerParseCmdLine(PNEWFOLDERINFO pfi);

#define IDT_DDETIMEOUT      1
#define IDT_ENUMHKCR        2

// for the desktop to handle DDE
STDAPI_(LRESULT) DDEHandleMsgs(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
STDAPI_(void) DDEHandleTimeout(HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\desktop2.h ===
#ifndef _DESKTOP2_H
#define _DESKTOP2_H

#include "uxtheme.h"
#include "tmschema.h"

#define WC_USERPANE     TEXT("Desktop User Pane")
#define WC_LOGOFF       TEXT("DesktopLogoffPane")
#define WC_SFTBARHOST   TEXT("DesktopSFTBarHost")
#define WC_MOREPROGRAMS TEXT("Desktop More Programs Pane")

/*
 
   This is the new Start Panel layout model.  
   Each pane in the following diagram will contain a 9Grid and a control offset w/in 9grid.

   STARTPANELMETRICS structure should be able to be initialized from a static.
   in the non-theme case, that static is what we'll use, otherwise we'll over-ride it with theme settings

 *************************
 *                       *
 *    User               *
 *************************
 *           *           *
 *           *           *
 *   MFU     *    Places *
 *           *           *
 *           *           *
 *           *           *
 *************           *
 * MoreProg  *           *
 *************************
 *                       *
 *      Logoff           *
 *************************

*/

#define SMPANETYPE_USER     0
#define SMPANETYPE_MFU      1
#define SMPANETYPE_MOREPROG 2
#define SMPANETYPE_PLACES   3
#define SMPANETYPE_LOGOFF   4
#define SMPANE_MAX SMPANETYPE_LOGOFF+1

// Common data which every pane will specify
typedef struct {
    LPCTSTR pszClassName;           // (const) window class name
    DWORD   dwStyle;                // (const) window style
    int     iPartId;                // (const) theme part id
    SIZE    size;                   // (default) initial size of this pane
    HTHEME  hTheme;                 // (runtime) theme to pass to the control
    HWND    hwnd;                   // (runtime) filled in at runtime
} SMPANEDATA;

typedef struct {
    SIZE sizPanel;    // Initial size of panel
    SMPANEDATA  panes[SMPANE_MAX];
} STARTPANELMETRICS;



//
//  For communication between the New Start Menu and the controls it hosts.
//  Note that these are positive numbers (app-specific).
//
//  Some of these notifications go from child to parent; others from parent
//  to child.  They will be indicated (c2p) or (p2c) accordingly.

#define SMN_FIRST           200         // 200 - 299
#define SMN_INITIALUPDATE   (SMN_FIRST+0) // p2c - Start Menu is being built
#define SMN_APPLYREGION     (SMN_FIRST+1) // p2c - make the window regional again
#define SMN_HAVENEWITEMS    (SMN_FIRST+2) // c2p - new items are here
                                          //       lParam -> SMNMBOOL (fNewInstall)
#define SMN_MODIFYSMINFO    (SMN_FIRST+3) // p2c - allow flags to be set (psminfo->dwFlags)
#define SMN_COMMANDINVOKED  (SMN_FIRST+4) // c2p - user executed a command
#define SMN_FILTEROPTIONS   (SMN_FIRST+5) // c2p - turn off options not supported
#define SMN_GETMINSIZE      (SMN_FIRST+6) // p2c - allow client to specify minimum size
#define SMN_SEENNEWITEMS    (SMN_FIRST+7) // p2c - user has seen new items; don't need balloon tip
#define SMN_POSTPOPUP       (SMN_FIRST+8) // p2c - Start Menu is has just popped up
#define SMN_NEEDREPAINT     (SMN_FIRST+9) // c2p - There was a change in a list, we need to repaint 
                                          //         This used to keep the cached bitmap up to date

//
//  SMN_FINDITEM - find/select an item (used in dialog navigation)
//
//      SMNDIALOGMESSAGE.flags member describes what type of search
//      is requested.  If SMNDM_SELECT is set, then the found item is
//      also selected.
//
//      If a match was found, set SMNDIALOGMESSAGE.itemID to a
//      value that uniquely identifies the item within the control,
//      and return TRUE.
//
//      If no match was found, set pt = coordinates of current selection,
//      set one of the orientation flags SMNDM_VERTICAL/SMNDM_HORIZONTAL,
//      and return FALSE.
//
#define SMN_FINDITEM        (SMN_FIRST+7) // p2c - find/select an item
#define SMN_TRACKSHELLMENU  (SMN_FIRST+8) // c2p - display a popup menu
#define SMN_SHOWNEWAPPSTIP  (SMN_FIRST+9) // p2c - show the "More Programs" tip
                                          //       lParam -> SMNMBOOL (fShow)
#define SMN_DISMISS         (SMN_FIRST+10)// p2c - Start Menu is being dismissed
#define SMN_CANCELSHELLMENU (SMN_FIRST+11)// c2p - cancel the popup menu
#define SMN_BLOCKMENUMODE   (SMN_FIRST+12)// c2p - lParam -> SMNMBOOL (fBlock)

#define SMN_REFRESHLOGOFF   (SMN_FIRST+13)// p2c - indicates a WM_DEVICECHANGE or a session change
#define SMN_SHELLMENUDISMISSED (SMN_FIRST+14)// p2c - notification that the menu has dismissed

// Formerly used by SMN_LINKCOMMAND to specify which command we want
#define SMNLC_LOGOFF        0
#define SMNLC_TURNOFF       1
#define SMNLC_DISCONNECT    2
// REUSE ME                 3
#define SMNLC_EJECT         4
#define SMNLC_MAX           5

typedef struct SMNMMODIFYSMINFO {
    NMHDR hdr;
    struct tagSMDATA *psmd; // IN
    struct tagSMINFO *psminfo; // IN OUT
} SMNMMODIFYSMINFO, *PSMNMMODIFYSMINFO;

typedef struct SMNMBOOL {
    NMHDR hdr;
    BOOL  f;
} SMNMBOOL, *PSMNMBOOL;

typedef struct SMNMAPPLYREGION {
    NMHDR hdr;
    HRGN hrgn;
} SMNMAPPLYREGION, *PSMNMAPPLYREGION;

typedef struct SMNHAVENEWITEMS {
    NMHDR hdr;
    FILETIME ftNewestApp;
} SMNMHAVENEWITEMS, *PSMNMHAVENEWITEMS;

typedef struct SMNMCOMMANDINVOKED {
    NMHDR hdr;
    RECT rcItem;
} SMNMCOMMANDINVOKED, *PSMNMCOMMANDINVOKED;

//
//  Options for SMN_FILTEROPTIONS.
//
#define SMNOP_LOGOFF        (1 << SMNLC_LOGOFF)       // 0x01
#define SMNOP_TURNOFF       (1 << SMNLC_TURNOFF)      // 0x02
#define SMNOP_DISCONNECT    (1 << SMNLC_DISCONNECT)   // 0x04
// REUSE ME                 (1 << SMNLC_????????????) // 0x08
#define SMNOP_EJECT         (1 << SMNLC_EJECT)        // 0x10

typedef struct SMNFILTEROPTIONS {
    NMHDR hdr;
    UINT  smnop;                // IN OUT
} SMNFILTEROPTIONS, *PSMNFILTEROPTIONS;

typedef struct SMNGETMINSIZE {
    NMHDR hdr;
    SIZE  siz;                  // IN OUT
} SMNGETMINSIZE, *PSMNGETMINSIZE;

typedef struct SMNDIALOGMESSAGE {
    NMHDR hdr;
    MSG *pmsg;                  // IN
    LPARAM itemID;              // IN OUT
    POINT pt;                   // IN OUT
    UINT flags;                 // IN
} SMNDIALOGMESSAGE, *PSMNDIALOGMESSAGE;

// Values for "flags" in SMNDIALOGMESSAGE

#define SMNDM_FINDFIRSTMATCH    0x0000  // Find first matching item (char)
#define SMNDM_FINDNEXTMATCH     0x0001  // Find next matching item (char)
#define SMNDM_FINDNEAREST       0x0002  // Find item nearest point
#define SMNDM_FINDFIRST         0x0003  // Find the first item
#define SMNDM_FINDLAST          0x0004  // Find the last item
#define SMNDM_FINDNEXTARROW     0x0005  // Find next in direction of arrow
#define SMNDM_INVOKECURRENTITEM 0x0006  // Invoke the current item
#define SMNDM_HITTEST           0x0007  // Find item under point
#define SMNDM_OPENCASCADE       0x0008  // Invoke current item if it cascade
#define SMNDM_FINDITEMID        0x0009  // Find the specied item (itemID)
#define SMNDM_FINDMASK          0x000F  // What type of search?

#define SMNDM_SELECT            0x0100  // Select found item?
#define SMNDM_TRYCASCADE        0x0200  // Attempt to open cascading menu before navigatin
#define SMNDM_KEYBOARD          0x0400  // Initiated from keyboard

// Output flags
#define SMNDM_VERTICAL          0x4000  // Client is vertically-oriented
#define SMNDM_HORIZONTAL        0x8000  // Client is horizontally-oriented

typedef struct SMNTRACKSHELLMENU {
    NMHDR hdr;
    struct IShellMenu *psm;
    RECT rcExclude;
    LPARAM itemID;                  // Which item is being tracked?
    DWORD dwFlags;                  // MPPF_* values
} SMNTRACKSHELLMENU, *PSMNTRACKSHELLMENU;

#define REGSTR_PATH_STARTPANE \
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")

#define REGSTR_PATH_STARTPANE_SETTINGS \
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

#define REGSTR_VAL_DV2_SHOWMC      TEXT("Start_ShowMyComputer")
#define REGSTR_VAL_DV2_SHOWNETPL   TEXT("Start_ShowNetPlaces")
#define REGSTR_VAL_DV2_SHOWNETCONN TEXT("Start_ShowNetConn")
#define REGSTR_VAL_DV2_SHOWRUN     TEXT("Start_ShowRun")
#define REGSTR_VAL_DV2_SHOWRECDOCS TEXT("Start_ShowRecentDocs")
#define REGSTR_VAL_DV2_SHOWMYDOCS  TEXT("Start_ShowMyDocs")
#define REGSTR_VAL_DV2_SHOWMYPICS  TEXT("Start_ShowMyPics")
#define REGSTR_VAL_DV2_SHOWMYMUSIC TEXT("Start_ShowMyMusic")
#define REGSTR_VAL_DV2_SHOWCPL     TEXT("Start_ShowControlPanel")
#define REGSTR_VAL_DV2_SHOWPRINTERS TEXT("Start_ShowPrinters")
#define REGSTR_VAL_DV2_SHOWHELP    TEXT("Start_ShowHelp")
#define REGSTR_VAL_DV2_SHOWSEARCH  TEXT("Start_ShowSearch")
#define REGSTR_VAL_DV2_FAVORITES   TEXT("StartMenuFavorites")   // shared with classic SM
#define REGSTR_VAL_DV2_LARGEICONS  TEXT("Start_LargeMFUIcons")
#define REGSTR_VAL_DV2_MINMFU      TEXT("Start_MinMFU")
#define REGSTR_VAL_DV2_SHOWOEM     TEXT("Start_ShowOEMLink")
#define REGSTR_VAL_DV2_AUTOCASCADE TEXT("Start_AutoCascade")
#define REGSTR_VAL_DV2_NOTIFYNEW   TEXT("Start_NotifyNewApps")
#define REGSTR_VAL_DV2_ADMINTOOLSROOT TEXT("Start_AdminToolsRoot")
#define REGSTR_VAL_DV2_MINMFU_DEFAULT   6

#define DV2_REGPATH TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")
#define DV2_SYSTEM_START_TIME    TEXT("StartMenu_Start_Time")
#define DV2_NEWAPP_BALLOON_TIME  TEXT("StartMenu_Balloon_Time")

#define STARTPANELTHEME            L"StartPanel"
#define PROP_DV2_BALLOONTIP        L"StartMenuBalloonTip"

#define DV2_BALLOONTIP_MOREPROG     LongToHandle(1)
#define DV2_BALLOONTIP_CLIP         LongToHandle(2)
#define DV2_BALLOONTIP_STARTBUTTON  LongToHandle(3)

// protypes of functions which live in specfldr.cpp but trayprop needs access too
BOOL ShouldShowNetPlaces();
BOOL ShouldShowConnectTo();


#endif // _DESKTOP2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dobjutil.h ===
STDAPI          DataObj_GetBlob(IDataObject *pdtobj, UINT cf, LPVOID pvBlob, UINT cbBlob);
STDAPI          DataObj_SetBlob(IDataObject *pdtobj, UINT cf, LPCVOID pvBlob, UINT cbBlob);
STDAPI          DataObj_SetGlobal(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal);
STDAPI          DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw);
STDAPI_(DWORD)  DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD dwDefault);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dllreghelper.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      DllRegHelper.h
//
//  Contents:  helper classes to register COM components in DLLs
//
//------------------------------------------------------------------------

#ifndef _DLL_REG_HELPER_H
#define _DLL_REG_HELPER_H

#include <comcat.h>

//------------------------------------------------------------------------
enum DRH_REG_MODE
{
    CCR_REG = 1,
    CCR_UNREG = 0,
    CCR_UNREGIMP = -1
};

//------------------------------------------------------------------------
//***   RegisterOneCategory -- [un]register ComCat implementor(s) and category
// ENTRY/EXIT
//  eRegister   CCR_REG, CCR_UNREG, CCR_UNREGIMP
//      CCR_REG, UNREG      reg/unreg implementor(s) and category
//      CCR_UNREGIMP        unreg implementor(s) only
//  pcatidCat   e.g. CATID_DeskBand
//  idResCat    e.g. IDS_CATDESKBAND
//  pcatidImpl  e.g. c_DeskBandClasses
HRESULT DRH_RegisterOneCategory(const CATID *pcatidCat, UINT idResCat, const CATID * const *pcatidImpl, enum DRH_REG_MODE eRegister);


// Calls the ADVPACK entry-point which executes an inf file section.
HRESULT DRH_CallRegInstall(LPSTR pszSection, BOOL bUninstall);


#endif // _DLL_REG_HELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dllload.c ===
// You are expected to #include this file from your private dllload.c.

// WARNING!   Failure to observe these rules will result in really subtle
// (and horrible) runtime/build problems.
//
// WARNING!  If you choose to delay-load a DLL, you **must** disable
// import thunks for that DLL when you include its header file.  For example,
// you must #define _OLE32_ before you #include <ole32.h>.  Otherwise,
// what happens is that the linker ends up exporting your delayload thunk
// (because it thinks it's an exported function because the header file
// said so) and then everybody who links to your DLL will accidentally
// use the delayload thunk instead of the original function.  This is
// particularly gruesome because this problem hoses every DLL in the system
// **except for you**.
//
// WARNING!  But if you are delay-loading an optional function and
// you are statically linking to the target DLL for required functions
// (e.g., you are delayloading an NT5-only function), then you should not
// disable import thunks since you really do want import thunks for the
// regular functions.  The way do handle this is to delayload the function
// with an alternate name (e.g., prepend an underscore) and use the MAP
// version of the delay-load macros.  Then in your global header file,
// #define the function to its mapped name.
//
// End of warnings.

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_VOID_ORD
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID
//
//
// Use DELAY_LOAD_IE_* for APIs that come from BrowseUI.  This used
// to be important when BrowseUI was in the IEXPLORE directory, but
// now it's in the System directory so the difference is pretty
// meaningless.
//
// Use DELAY_LOAD_OCX_* for APIs that come from OCXs and not DLLs.
//

/**********************************************************************/

#ifdef DEBUG

void _DumpLoading(LPTSTR pszDLL, LPTSTR pszFunc)
{
#ifdef DF_DELAYLOADDLL
    if (g_dwDumpFlags & DF_DELAYLOADDLL)
    {
        TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, pszFunc);
    }
#endif
}

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_DumpLoading(TEXT(#_dll) TEXT(".") TEXT(#_ext), pszfn), \
                        _hmod = LoadLibraryA(#_dll "." #_ext)))

#else

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_hmod = LoadLibraryA(#_dll "." #_ext)))

#endif  // DEBUG


/**********************************************************************/

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (!IS_INTRESOURCE(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wsprintfA(szProcD, "(ordinal %d)", LOWORD((DWORD_PTR)pszProc));
    }
#endif
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL) {
#ifdef DEBUG
#ifdef DF_DELAYLOADDLL
        if (g_dwDumpFlags & DF_DELAYLOADDLL)
        {
            TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, szProcD);
        }
#endif
        if (g_dwBreakFlags & 0x00000080)
        {
            DebugBreak();
        }
#endif
        *phmod = LoadLibraryA(pszDLL);
#ifdef UNIX
        if (*phmod == NULL) {
           if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
               *phmod = LoadLibraryA("inetcpl.cpl");
           }
        }
#endif
        if (*phmod == NULL) {
            return;
        }
    }

#if defined(DEBUG) && defined(DF_DELAYLOADDLL)
    if (g_dwDumpFlags & DF_DELAYLOADDLL) {
        TraceMsg(TF_ALWAYS, "DLLLOAD: GetProc'ing %s from %s for the first time",
             pszDLL, szProcD);
    }
#endif
    *ppfn = GetProcAddress(*phmod, pszProc);
}

#if defined(DEBUG) && defined(BROWSEUI_IN_IEXPLORE_DIRECTORY)
void _GetProcFromSystemDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{

#ifdef UNIX
    if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
        _GetProcFromDLL(phmod, "inetcpl.cpl", ppfn, pszProc);
        return;
    }
#endif

    // You must use DELAY_LOAD_IE for BROWSEUI since BROWSEUI lives in the
    // IE directory, not the System directory.
    if (lstrcmpiA(pszDLL, "BROWSEUI.DLL") == 0) {
        ASSERT(!"Somebody used DELAY_LOAD instead of DELAY_LOAD_IE on BROWSEUI");
    }
    _GetProcFromDLL(phmod, pszDLL, ppfn, pszProc);
}
#else
#define _GetProcFromSystemDLL           _GetProcFromDLL
#endif

// NOTE: this takes two parameters that are the function name. the First (_fn) is the name that
// NOTE: the function will be called in this DLL and the other (_fni) is the
// NOTE: name of the function we will GetProcAddress. This helps get around functions that
// NOTE: are defined in the header files with _declspec...

//
//  HMODULE _hmod - where we cache the HMODULE (aka HINSTANCE)
//           _dll - Basename of the target DLL, not quoted
//           _ext - Extension of the target DLL, not quoted (usually DLL)
//           _ret - Data type of return value
//        _fnpriv - Local name for the function
//            _fn - Exported name for the function
//          _args - Argument list in the form (TYPE1 arg1, TYPE2 arg2, ...)
//         _nargs - Argument list in the form (arg1, arg2, ...)
//           _err - Return value if we can't call the actual function
//
#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define     DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
   DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_LRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LRESULT, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)
#define DELAY_LOAD_LPVOID(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LPVOID, _fn, _args, _nargs, 0)

// the NAME variants allow the local function to be called something different from the imported
// function to avoid dll linkage problems.
#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)
#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)
#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)
#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fni, _args, _nargs)                               \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (__stdcall *_pfn##_fni) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hmod, _dll, DLL, TEXT(#_fni)))                                       \
    {                                                                                   \
        AssertMsg(BOOLFROMPTR(_hmod), TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fni == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fni) = GetProcAddress(_hmod, #_fni);                         \
        AssertMsg(BOOLFROMPTR(_pfn##_fni), TEXT("GetProcAddress failed on ") ## TEXT(#_fni));    \
        if (_pfn##_fni == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fni _nargs;                                                                   \
}

#define DELAY_LOAD_VOID(_hmod, _dll, _fn, _args, _nargs)   DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fn, _args, _nargs)



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_EXT_ORD(_hmod, _dll, _ext, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, #_dll "." #_ext, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs)                     \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}
#define DELAY_LOAD_VOID_ORD DELAY_LOAD_ORD_VOID // cuz people mess this up all the time

#define DELAY_LOAD_ORD_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) \
    DELAY_LOAD_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, 0)

#define DELAY_LOAD_EXT(_hmod, _dll, _ext, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fn, _fn, _args, _nargs, 0)

#define DELAY_LOAD_EXT_WRAP(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs, 0)

#if defined(BROWSEUI_IN_IEXPLORE_DIRECTORY) || defined(UNIX)
/*----------------------------------------------------------
Purpose: Loads the DLL via a CLSID it is known to be registered for
*/
void _GetProcFromCLSID(HMODULE* phmod, const CLSID *pclsid, FARPROC* ppfn, LPCSTR pszProc)
{
    if (*phmod == NULL) {
        //
        //  SHPinDLLOfCLSID does all the annoying work of opening the
        //  appropriate registry key, doing REG_EXPAND_SZ, etc.
        //  It also loads the DLL with exactly the same name that OLE does,
        //  which is important because NT4 SP3 didn't like it when you loaded
        //  a DLL sometimes via SFN and sometimes via LFN.  (It would
        //  think they were different DLLs, and two copies of it got loaded
        //  into memory.  Aigh!)
        //
        *phmod = (HMODULE)SHPinDllOfCLSID(pclsid);
        if (!*phmod) 
            return;
    }

    // We don't know the name of the DLL, but fortunately _GetProcFromDLL
    // doesn't need it if *phmod is already filled in.
    ASSERT(*phmod);
    _GetProcFromDLL(phmod, "", ppfn, pszProc);
}

//
//  Private exports by ordinal for browseui.  loads from the browseui in apppath dir
//

#ifndef UNIX

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif
    
#ifndef UNIX

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif

#else // BrowseUI is in the System directory

#define DELAY_LOAD_IE_ORD_ERR       DELAY_LOAD_ORD_ERR
#define DELAY_LOAD_IE_ORD_VOID      DELAY_LOAD_ORD_VOID

#endif

#define DELAY_LOAD_IE(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_IE_HRESULT(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)
#define DELAY_LOAD_IE_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, FALSE)

#define DELAY_LOAD_IE_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)

#ifndef NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    if (PLATFORM_INTEGRATED == WhichPlatform())
        _GetProcFromSystemDLL(phinst, pszDLL, ppfn, pszProc);
    else
        TraceMsg(TF_ERROR, "Could not load integrated shell version of %s for %d", pszDLL, pszProc);
}

#endif // NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs ) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL )


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

// Following Macros are functionally  same as above only that they are
// using function name on UNIX rather than ordinals. The above macros 
// are left untouched because other dlls like shdocvw/shdoc401 still use
// them.

#ifndef UNIX

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif

#define DELAY_LOAD_SHELL_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0, _realfn)
#define DELAY_LOAD_SHELL_HRESULT_FN(_hinst, _dll, _fn, _ord, _args, _nargs, realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL, _realfn)


#ifndef UNIX

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dpa.h ===
#ifndef GUARD_D70787804D9C11d28784F6E920524153
#define GUARD_D70787804D9C11d28784F6E920524153

#include "comctrlp.h"

//  The Ex versions of EnumCallback, DestroyCallback, Sort, Search, etc.
//  do stricter type checking to make sure that the reference data /
//  parameter matches both on the calling side and the callback side.


template <class T> class CDPA
{

public:
    // Typedefs
    typedef int (CALLBACK *_PFNDPAENUMCALLBACK)(T *p, void *pData);
    typedef int (CALLBACK *_PFNDPACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDPA(HDPA hdpa = NULL) {m_hdpa = hdpa;}

    BOOL IsDPASet() {return m_hdpa != NULL; }

    void Attach(const HDPA hdpa) {m_hdpa = hdpa;}
    HDPA Detach() {HDPA hdpa = m_hdpa; m_hdpa = NULL; return hdpa;}

    operator HDPA () { return m_hdpa; }

    BOOL    Create(int cItemGrow)
    {return (m_hdpa = DPA_Create(cItemGrow)) != NULL;}

    BOOL    CreateEx(int cpGrow, HANDLE hheap)
    {return (m_hdpa = DPA_CreateEx(cpGrow, hheap)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DPA_Destroy(m_hdpa); m_hdpa = NULL; return fRet;}

    HDPA    Clone(HDPA hdpaNew)
    {return DPA_Clone(m_hdpa, hdpaNew);}

    T*      GetPtr(INT_PTR i)
    {return (T*) DPA_GetPtr(m_hdpa, i);}

    int     GetPtrIndex(T* p)
    {return DPA_GetPtrIndex(m_hdpa, (void *) p);}

    BOOL    Grow(int cp)
    {return DPA_Grow(m_hdpa, cp);}

    BOOL    SetPtr(int i, T* p)
    {return DPA_SetPtr(m_hdpa, i, (void *) p);}

    int     InsertPtr(int i, T* p)
    {return DPA_InsertPtr(m_hdpa, i, (void *) p);}

    T*      DeletePtr(int i)
    {return (T*) DPA_DeletePtr(m_hdpa, i);}

    BOOL    DeleteAllPtrs()
    {return DPA_DeleteAllPtrs(m_hdpa);}

    void    EnumCallback(_PFNDPAENUMCALLBACK pfnCB, void *pData)
    {DPA_EnumCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {EnumCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    void    DestroyCallback(_PFNDPAENUMCALLBACK pfnCB, void *pData)
    {DPA_DestroyCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData); m_hdpa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    int     GetPtrCount()
    {return DPA_GetPtrCount(m_hdpa);}

    T*      GetPtrPtr()
    {return (T*)DPA_GetPtrPtr(m_hdpa);}

    T*&     FastGetPtr(int i)
    {return (T*&)DPA_FastGetPtr(m_hdpa, i);}
    
    int     AppendPtr(T* pitem)
    {return DPA_AppendPtr(m_hdpa, (void *) pitem);}

#ifdef __IStream_INTERFACE_DEFINED__
    HRESULT LoadStream(PFNDPASTREAM pfn, IStream * pstream, void *pvInstData)
    {return DPA_LoadStream(&m_hdpa, pfn, pstream, pvInstData);}

    HRESULT SaveStream(PFNDPASTREAM pfn, IStream * pstream, void *pvInstData)
    {return DPA_SaveStream(m_hdpa, pfn, pstream, pvInstData);}
#endif

    BOOL    Sort(_PFNDPACOMPARE pfnCompare, LPARAM lParam)
    {return DPA_Sort(m_hdpa, (PFNDPACOMPARE)pfnCompare, lParam);}

    template<class T2>
    BOOL    SortEx(int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam), T2 lParam)
    {return Sort((_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam));}

    // Merge not supported through this object; use DPA_Merge

    int     Search(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options)
    {return DPA_Search(m_hdpa, (void *) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options);}

    template<class T2>
    int     SearchEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options)
    {return Search(pFind, iStart, (_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam), options);}
    
    int     SortedInsertPtr(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options, T* pitem)
    {return DPA_SortedInsertPtr(m_hdpa, (void *) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options, (void *) pitem);}

    template<class T2>
    int     SortedInsertPtrEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options, T* pitem)
    {return SortedInsertPtr(pFind, iStart, (_PFNDPACOMPARE)pfnCompare,
                    reinterpret_cast<LPARAM>(lParam), options, pitem);}

private:
    HDPA m_hdpa;
};

template <class T> class CDSA
{
public:
    // Typedefs
    typedef int (CALLBACK *_PFNDSAENUMCALLBACK)(T *p, void *pData);
    typedef int (CALLBACK *_PFNDSACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDSA(HDSA hdsa = NULL) {m_hdsa = hdsa;}

    void Attach(const HDSA hdsa) {m_hdsa = hdsa;}
    HDSA Detach() { HDSA hdsa = m_hdsa; m_hdsa = NULL; return hdsa; }

    operator HDSA () { return m_hdsa; }

    BOOL    Create(int cItemGrow)
    {return (m_hdsa = DSA_Create(sizeof(T), cItemGrow)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DSA_Destroy(m_hdsa); m_hdsa = NULL; return fRet;}

    BOOL    GetItem(int i, T* pitem)
    {return DSA_GetItem(m_hdsa, i, (void *)pitem);}

    T*      GetItemPtr(int i)
    {return (T*)DSA_GetItemPtr(m_hdsa, i);}

    BOOL    SetItem(int i, T* pitem)
    {return DSA_SetItem(m_hdsa, i, (void *)pitem);}

    int     InsertItem(int i, T* pitem)
    {return DSA_InsertItem(m_hdsa, i, (void *)pitem);}

    virtual BOOL    DeleteItem(int i)
    {return DSA_DeleteItem(m_hdsa, i);}

    virtual BOOL    DeleteAllItems()
    {return DSA_DeleteAllItems(m_hdsa);}

    void    EnumCallback(_PFNDSAENUMCALLBACK pfnCB, void *pData)
    {DSA_EnumCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {EnumCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    void    DestroyCallback(_PFNDSAENUMCALLBACK pfnCB, void *pData)
    {DSA_DestroyCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData); m_hdsa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    int     GetItemCount()
    {return DSA_GetItemCount(m_hdsa);}

    int     AppendItem(T* pitem)
    {return DSA_AppendItem(m_hdsa, (void *)pitem);}

private:
    HDSA m_hdsa;
};

template <class T>
CDSA<T>* CDSA_Create(int cItemGrow)
{
    CDSA<T> *pdsa = new CDSA<T>();
    if (pdsa)
    {
        if (!pdsa->Create(cItemGrow))
        {
            delete pdsa;
            pdsa = NULL;
        }
    }
    return pdsa;
}


#endif // !GUARD_D70787804D9C11d28784F6E920524153
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\doshelp.h ===
// Help ids

/* NOTE!  Any changes to this file must be cleared with UE! */

//#define IDH_NO_HELP                             28440   // if you don't know...

/* The following symbols are defined in core\inc\help.h, which we dup here */

#ifndef IDH_OK
#define IDH_OK                                  28443   // From Help.h
#endif

#ifndef IDH_CANCEL
#define IDH_CANCEL                              28444   // From Help.h
#endif

#ifndef IDH_COMM_GROUPBOX
#define IDH_COMM_GROUPBOX                       28548   // From Help.h
#endif


#define IDH_DOS_ADV_AUTOEXEC                    5200
#define IDH_DOS_ADV_CONFIG                      5201
#define IDH_NOMSDOSWARNING                      5202
#define IDH_DOS_ADV_PIFNAME                     5203
#define IDH_DOS_AVAIL_FONTS                     5204
#define IDH_DOS_DISPLAY_ROM                     5205
#define IDH_DOS_DISPLAY_SCREEN_SETTINGS         5206

#define IDH_DOS_ADV_CONFIG_BTN                  5208
#define IDH_DOS_ADV_PRG_SUGGEST                 5209
#define IDH_DOS_MEMORY_NOEMS_DETAILS            5211
#define IDH_DOS_FONT_FONT_PREVIEW               5212
#define IDH_DOS_FONT_SIZE                       5213
#define IDH_DOS_FONT_WINDOW_PREVIEW             5214
#define IDH_DOS_KEYBOARD_FASTPASTE              5215
#define IDH_DOS_KEYBOARD_SHORTCUTS              5216
#define IDH_DOS_MEMORY_CONV                     5217
#define IDH_DOS_MEMORY_CONV_GLOBAL              5218
#define IDH_DOS_MEMORY_DPMI                     5219
#define IDH_DOS_MEMORY_EXP                      5220
#define IDH_DOS_SCREEN_USAGE_FULL               5221
#define IDH_DOS_MEMORY_EXT                      5222
#define IDH_DOS_MEMORY_EXT_HMA                  5223
#define IDH_DOS_SCREEN_USAGE_WINDOW             5224
#define IDH_DOS_SCREEN_USAGE_AUTO               5225
#define IDH_DOS_PROGRAM_ADV_BUTTON              5226
#define IDH_DOS_PROGRAM_BATCH                   5227
#define IDH_DOS_PROGRAM_CHANGEICON              5228
#define IDH_DOS_PROGRAM_CMD_LINE                5229
#define IDH_DOS_PROGRAM_DESCRIPTION             5230
#define IDH_DOS_PROGRAM_ENVIRSZ                 5231
#define IDH_DOS_PROGRAM_ICON                    5232
#define IDH_DOS_PROGRAM_ICON_NAME               5233
#define IDH_DOS_PROGRAM_RUN                     5234
#define IDH_DOS_PROGRAM_SHORTCUT                5235
#define IDH_DOS_PROGRAM_WORKDIR                 5236
#define IDH_DOS_REALMODEPROPS                   5237
#define IDH_DOS_SCREEN_RESTORE                  5238
#define IDH_DOS_TASKING_ALLOW_SCREENSAVER       5239
#define IDH_DOS_TASKING_IDLE_SLIDER             5241
#define IDH_DOS_TASKING_SINGLE                  5242
#define IDH_DOS_TASKING_SUSPEND                 5243
#define IDH_DOS_WINDOWS_MOUSE_EXCLUSIVE         5246
#define IDH_DOS_WINDOWS_MOUSE_QUICKEDIT         5247
#define IDH_DOS_WINDOWS_QUIT_CLOSE              5248
#define IDH_DOS_WINDOWS_RESTORE                 5249
#define IDH_DOS_WINDOWS_TOOLBAR                 5250
#define IDH_DOS_WINDOWS_WARN                    5251
#define IDH_DOS_ADV_HIDEWINDOWS                 5252
#define IDH_DOS_SCREEN_DMA                      5253
#define IDH_DOS_ADV_CLEANCFG                    5254
#define IDH_DOS_ADV_CURCFG                      5255

#define IDH_CONSOLE_FONT_FONT                   5256
#define IDH_CONSOLE_FONT_BOLD_FONTS             5257

#define IDH_DOS_PROGRAM_PIF_TIMER_EMULATE       5262

#define IDH_CONSOLE_SIZE_BUFF_WIDTH             5263
#define IDH_CONSOLE_SIZE_BUFF_HEIGHT            5264
#define IDH_CONSOLE_SIZE_WIN_WIDTH              5265
#define IDH_CONSOLE_SIZE_WIN_HEIGHT             5266
#define IDH_CONSOLE_SIZE_POS_LEFT               5267
#define IDH_CONSOLE_SIZE_POS_TOP                5268
#define IDH_CONSOLE_SIZE_LET_SYS                5269
#define IDH_CONSOLE_COLOR_SCR_TEXT              5270
#define IDH_CONSOLE_COLOR_SCR_BACK              5271
#define IDH_CONSOLE_COLOR_POPUP_TEXT            5272
#define IDH_CONSOLE_COLOR_POPUP_BACK            5273
#define IDH_CONSOLE_COLOR_RED                   5274
#define IDH_CONSOLE_COLOR_GREEN                 5275
#define IDH_CONSOLE_COLOR_BLUE                  5276
#define IDH_CONSOLE_COLOR_SCR_COLORS            5277
#define IDH_CONSOLE_COLOR_WIN_COLORS            5278
#define IDH_CONSOLE_COLOR_COLOR_BAR             5279

#define IDH_CONSOLE_OPTIONS_BUFF_NUM            5280
#define IDH_CONSOLE_OPTIONS_BUFF_SIZE           5281
#define IDH_CONSOLE_OPTIONS_CURSOR              5282
#define IDH_CONSOLE_OPTIONS_CURSOR_LARGE        5283
#define IDH_CONSOLE_OPTIONS_CURSOR_MED          5284
#define IDH_CONSOLE_OPTIONS_DISCARD_DUPS        5285
#define IDH_CONSOLE_OPTIONS_INSERT              5286
#define IDH_CONSOLE_OPTIONS_QUICK_EDIT          5287
#define IDH_CONSOLE_OPTIONS_LANGUAGE            5288
#define IDH_CONSOLE_OPTIONS_AUTOCOMPLETE        5289
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dpastuff.cpp ===
#include "dpastuff.h"

//
//  The ORDERITEM structure is exposed via the IOrderList interface.
//  ORDERITEM2 contains our private hidden fields.
//
//  The extra fields contain information about the cached icon location.
//
//  ftModified is the modify-time on the pidl, which is used to detect
//  whether the cache needs to be refreshed.
//
//  If ftModified is nonzero, then { pwszIcon, iIconIndex, pidlTarget }
//  describe the icon that should be displayed for the item.
//
//  If pwszIcon is nonzero, then the item is a shortcut with a custom
//  icon.  pwszIcon points to the file name for the icon, iIconIndex
//  is the icon index within the pwszIcon file.
//
//  If pidlTarget is nonzero, then the item is a shortcut with a default
//  icon.  pidlTarget is the target pidl, whose icon we should use.
//

typedef struct ORDERITEM2 {
    ORDERITEM oi;               // part that clients see - must come first
    DWORD  dwFlags;             // User defined flags.
    LPWSTR pwszIcon;            // for cacheing the icon location
    int iIconIndex;             // for cacheing the icon location
    LPITEMIDLIST pidlTarget;    // use the icon for this pidl
} ORDERITEM2, *PORDERITEM2;

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    PORDERITEM  poi1 = (PORDERITEM)pv1;
    PORDERITEM  poi2 = (PORDERITEM)pv2;
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    int nRet;

    if (!poinfo)
    {   
        ASSERT(FALSE);
        return 0;
    }
    switch (poinfo->dwSortBy)
    {
    case OI_SORTBYNAME:
    {
        // Make sure they're both non-null
        //
        if ( poi1->pidl && poi2->pidl )
        {
            HRESULT hres = poinfo->psf->CompareIDs(0, poi1->pidl, poi2->pidl);
            nRet = (short)HRESULT_CODE(hres);
        }
        else
        {
            if ( poi1->pidl == poi2->pidl )
                nRet = 0;
            else
                nRet = ((UINT_PTR)poi1->pidl < (UINT_PTR)poi2->pidl ? -1 : 1);
        }

        break;
    }

    case OI_SORTBYORDINAL:
        if (poi1->nOrder == poi2->nOrder)
            nRet = 0;
        else
            // do unsigned compare so -1 goes to end of list
            nRet = ((UINT)poi1->nOrder < (UINT)poi2->nOrder ? -1 : 1);
        break;

    default:
        ASSERT_MSG(0, "Bad dwSortBy passed to OrderItem_Compare");
        nRet = 0;
        break;
    }

    return nRet;
}

void OrderItem_FreeIconInfo(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    if (poi2->pwszIcon)
    {
        LPWSTR pwszIcon = poi2->pwszIcon;
        poi2->pwszIcon = NULL;
        LocalFree(pwszIcon);
    }

    if (poi2->pidlTarget)
    {
        LPITEMIDLIST pidl = poi2->pidlTarget;
        poi2->pidlTarget = NULL;
        ILFree(pidl);
    }
}


LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDst, LPVOID pvSrc, LPARAM lParam)
{
    PORDERITEM2 poi2Dst = CONTAINING_RECORD(pvDst, ORDERITEM2, oi);
    PORDERITEM2 poi2Src = CONTAINING_RECORD(pvSrc, ORDERITEM2, oi);
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    LPVOID pvRet = pvDst;

    switch (uMsg)
    {
    case DPAMM_MERGE:
        // Transfer the order field
        poi2Dst->oi.nOrder = poi2Src->oi.nOrder;

        // Propagate any cached icon information too...
        if (poi2Src->pwszIcon || poi2Src->pidlTarget)
        {
            // To avoid useless allocation, we transfer the cache across
            // instead of copying it.
            if (poinfo->psf2 &&
                poinfo->psf2->CompareIDs(SHCIDS_ALLFIELDS, poi2Dst->oi.pidl, poi2Src->oi.pidl) == S_OK)
            {
                OrderItem_FreeIconInfo(&poi2Dst->oi);
                CopyMemory((LPBYTE)poi2Dst + sizeof(ORDERITEM),
                           (LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
                ZeroMemory((LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
            }
        }
        break;

    case DPAMM_DELETE:
    case DPAMM_INSERT:
        // Don't need to implement this
        ASSERT(0);
        pvRet = NULL;
        break;
    }
    
    return pvRet;
}

int OrderItem_UpdatePos(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    if (-1 == poi->nOrder)
    {
        poi->nOrder = (int)(INT_PTR)pData;
    }
    else if ((int)(INT_PTR)pData >= poi->nOrder)
    {
        poi->nOrder++;
    }

    return 1;
}

// OrderList_Merge sorts hdpaNew to match hdpaOld order,
// putting any items in hdpaNew that were not in hdpaOld
// at position iInsertPos (-1 means end of list).
//
// Assumes hdpaOld is already sorted by sort order in lParam (OI_SORTBYNAME by default)
// (if hdpaOld is specified)
//
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam,
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam)
{
    PORDERINFO poinfo = (PORDERINFO)lParam;

    BOOL fMergeOnly = FALSE;
    if (poinfo->dwSortBy == OI_MERGEBYNAME)
    {
        poinfo->dwSortBy = OI_SORTBYNAME;
        fMergeOnly = TRUE;
    }

    // hdpaNew has not been sorted, sort by name
    DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
    BOOL fForceNoMatch = FALSE;

    if (FAILED(poinfo->psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&poinfo->psf2))) {
        // 239390: Network Connections folder doesn't implement QI correctly.  Its psf 
        // fails QI for IID_IShellFolder2, but doesn't null out ppvObj.  So do it for them.
        poinfo->psf2 = NULL;
    }

    // Copy order preferences over from old list to new list
    if (hdpaOld)
    {
        DPA_Merge(hdpaNew, hdpaOld, DPAM_SORTED | DPAM_NORMAL, OrderItem_Compare, OrderItem_Merge, lParam);

        // If we're waiting for the notify from a drag&drop operation,
        // update the new items (they will have a -1) to the insert position.
        if (-1 != iInsertPos)
        {
            DPA_EnumCallback(hdpaNew, OrderItem_UpdatePos, (LPVOID)(INT_PTR)iInsertPos);
        }

        if (poinfo->dwSortBy != OI_SORTBYORDINAL && !fMergeOnly)
        {
            poinfo->dwSortBy = OI_SORTBYORDINAL;
            DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
        }
    }
    else
        fForceNoMatch = TRUE;

    // If the caller passed a NoMatch callback, then call it with
    // each item that is not matched.
    if (pfn)
    {
        for (int i = DPA_GetPtrCount(hdpaNew)-1 ; i >= 0 ; i--)
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpaNew, i);

            // Does this item have order information?
            if (iInsertPos == poi->nOrder ||
                -1 == poi->nOrder ||
                fForceNoMatch)
            {
                // No; Then pass to the "No Match" callback
                pfn(pvParam, poi->pidl);
            }
        }
    }

    ATOMICRELEASE(poinfo->psf2);

    OrderList_Reorder(hdpaNew);
}

// OrderList_Reorder refreshes the order info
void OrderList_Reorder(HDPA hdpa)
{
    int i;

    for (i = DPA_GetPtrCount(hdpa)-1 ; i >= 0 ; i--)
    {
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);

        poi->nOrder = i;
    }
}

BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        if (-1 != DPA_AppendPtr(hdpa, poi))
            return TRUE;

        OrderItem_Free(poi, FALSE); //don't free pidl because caller will do it
    }
    return FALSE;
}

// This differes from DPA_Clone in that it allocates new items!
HDPA OrderList_Clone(HDPA hdpa)
{
    HDPA hdpaNew = NULL;

    if (EVAL(hdpa))
    {
        hdpaNew = DPA_Create(DPA_GetPtrCount(hdpa));
    
        if (hdpaNew)
        {
            int i;
    
            for (i = 0 ; i < DPA_GetPtrCount(hdpa) ; i++)
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);
                LPITEMIDLIST pidl = ILClone(poi->pidl);
                if (pidl)
                {
                    if (!OrderList_Append(hdpaNew, pidl, poi->nOrder))
                    {
                        ILFree(pidl);
                    }
                }
            }
        }
    }

    return hdpaNew;
}

// Does not clone the pidl but will free it.
// Does not addref the psf nor release it.
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM2 poi = (PORDERITEM2)LocalAlloc(LPTR, SIZEOF(ORDERITEM2));

    if (poi)
    {
        poi->oi.pidl = pidl;
        poi->oi.nOrder = nOrder;
        return &poi->oi;
    }

    return NULL;
}

void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls /* = TRUE */)
{
    if (fKillPidls)
        ILFree(poi->pidl);
    OrderItem_FreeIconInfo(poi);
    LocalFree(poi);
}

int OrderItem_FreeItem(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    OrderItem_Free(poi, (BOOL)(INT_PTR)pData);

    return 1;
}

void OrderList_Destroy(HDPA* phdpa, BOOL fKillPidls /* = fTrue */)
{
    if (*phdpa) {
        DPA_DestroyCallback(*phdpa, OrderItem_FreeItem, (LPVOID) (INT_PTR)fKillPidls);
        *phdpa = NULL;
    }
}

//
//  Return values:
//
//  S_OK    - icon obtained successfully
//  S_FALSE - icon not obtained, don't waste time trying
//  E_FAIL  - no cached icon, need to do more work
//
HRESULT OrderItem_GetSystemImageListIndexFromCache(PORDERITEM poi,
                                        IShellFolder *psf, int *piOut)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    IShellFolder *psfT;
    LPCITEMIDLIST pidlItem;
    HRESULT hr;

    // Do we have a cached icon location?
    if (poi2->pwszIcon)
    {
        *piOut = 0;
        // Validate Path existance.
        if (PathFileExistsW(poi2->pwszIcon))
        {
            *piOut = Shell_GetCachedImageIndex(poi2->pwszIcon, poi2->iIconIndex, GIL_PERINSTANCE);
        }

        return (*piOut > 0)? S_OK : E_FAIL;
    }

    // Do we have a cached pidlTarget?
    if (poi2->pidlTarget)
    {
        hr = SHBindToIDListParent(poi2->pidlTarget, IID_IShellFolder, (void**)&psfT, &pidlItem);
        if (SUCCEEDED(hr))
        {
            // Make sure the pidl exsists before binding. because the bind does succeed if it does not exist.
            DWORD dwAttrib = SFGAO_VALIDATE;
            hr = psfT->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib);
            if (SUCCEEDED(hr))
            {
                *piOut = SHMapPIDLToSystemImageListIndex(psfT, pidlItem, NULL);
            }
            psfT->Release();
            return hr;
        }

        // Bind failed - shortcut target was deleted
        // Keep the cache valid because we don't want to whack the disk
        // all the time only to discover it's busted.
        return E_FAIL;
    }

    return E_FAIL;
}

DWORD OrderItem_GetFlags(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    return poi2->dwFlags;
}

void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    poi2->dwFlags = dwFlags;
}


int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    HRESULT hr;
    int iBitmap;
    DWORD dwAttr;

    if (fUseCache)
    {
        hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
        if (SUCCEEDED(hr))
        {
            return iBitmap;
        }
        else
        {
            goto Fallback;
        }
    }
    else
    {
        //
        // Free any pointers we cached previously
        //
        if (poi2->pidlTarget)
        {
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;
        }

        Str_SetPtr(&poi2->pwszIcon, NULL);
    }

    //
    //  Go find the icon.
    //
    ASSERT(poi2->pidlTarget == NULL);
    ASSERT(poi2->pwszIcon == NULL);

    //
    //  Is this item shortcutlike at all?
    //
    dwAttr = SFGAO_LINK;
    hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&poi->pidl, &dwAttr);
    if (FAILED(hr) || !(dwAttr & SFGAO_LINK))
        goto Fallback;                  // not a shortcut; use the fallback

    //
    // Must go for ANSI version first because client might not support
    // UNICODE.
    //
    // FEATURE - should QI for IExtractIcon to see if we get GIL_DONTCACHE
    // back.

    IShellLinkA *pslA;
    hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&poi->pidl,
                            IID_IShellLinkA, 0, (LPVOID *)&pslA);

    if (FAILED(hr))
        goto Fallback;

    //
    //  If there's a UNICODE version, that's even better.
    //
    IShellLinkW *pslW;
    WCHAR wszIconPath[MAX_PATH];

    hr = pslA->QueryInterface(IID_IShellLinkW, (LPVOID *)&pslW);
    if (SUCCEEDED(hr))
    {
        hr = pslW->GetIconLocation(wszIconPath, ARRAYSIZE(wszIconPath), &poi2->iIconIndex);
        pslW->Release();
    }
    else
    {
        // Only IShellLinkA supported.  Thunk to UNICODE manually.
        CHAR szIconPath[ARRAYSIZE(wszIconPath)];
        hr = pslA->GetIconLocation(szIconPath, ARRAYSIZE(szIconPath), &poi2->iIconIndex);
        if (SUCCEEDED(hr))
            SHAnsiToUnicode(szIconPath, wszIconPath, ARRAYSIZE(wszIconPath));
    }

    // If we have a custom icon path, then save that
    if (SUCCEEDED(hr) && wszIconPath[0])
    {
        Str_SetPtr(&poi2->pwszIcon, wszIconPath);
    }
    else
    {
        // No icon path, get the target instead
        pslA->GetIDList(&poi2->pidlTarget);

        if (IsURLChild(poi2->pidlTarget, TRUE))
        {
            // If this is a url, we want to go to the "Fallback" case. The reason for this
            // is that the fallback case will go through 
            // where we will end up with the generic icon for .url files
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;

            pslA->Release();
            goto Fallback;
        }
    }

    pslA->Release();

    //
    //  Aw-right, the cache is all loaded up.  Let's try that again.
    //
    hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
    if (hr == S_OK)
    {
        return iBitmap;
    }

Fallback:
    return SHMapPIDLToSystemImageListIndex(psf, poi->pidl, NULL);
}


// Header for file menu streams
//
// The file menu stream consists of an IOSTREAMHEADER followed by
// a DPA_SaveStream of the order DPA.  Each item in the DPA consists
// of an OISTREAMITEM.
//
// To keep roaming profiles working between NT4 (IE4) and NT5 (IE5),
// the dwVersion used by NT5 must be the same as that used by NT4.
// I.e., it must be 2.

typedef struct tagOISTREAMHEADER
{
    DWORD cbSize;           // Size of header
    DWORD dwVersion;        // Version of header
} OISTREAMHEADER;

#define OISTREAMHEADER_VERSION  2

//
//  Each item in a persisted order DPA consists of an OISTREAMITEM
//  followed by additional goo.  All pidls stored include the
//  terminating (USHORT)0.
//
//  IE4:
//      OISTREAMITEM
//      pidl                    - the item itself
//
//  IE5 - shortcut has custom icon
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      dwStringLen             - Length of the icon path 
//      UNICODEZ iconpath       - icon path
//      iIconIndex              - icon index
//
//  IE5 - shortcut takes its icon from another pidl
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      (DWORD)0                - null string indicates "no custom icon"
//      pidlTarget              - use the icon for this pidl
//

typedef struct tagOISTREAMITEM
{
    DWORD cbSize;           // Size including trailing goo
    int   nOrder;           // User-specified order

    // variable-sized trailing goo comes here.
    //
    // See above for description of trailing goo.

} OISTREAMITEM;

#define CB_OISTREAMITEM     (sizeof(OISTREAMITEM))

//
//  Save a component of the orderitem to the stream.  If an error has
//  already occurred on the stream, *phrRc contains the old error code,
//  and we write nothing.
//
//  If pstm == NULL, then we are not actually writing anything.  We are
//  merely doing a dry run.
//
//  Otherwise, *phrRc accumulates the number of bytes actually written,
//  or receives an error code on failure.
//

void
OrderItem_SaveSubitemToStream(IStream *pstm, LPCVOID pvData, ULONG cb, HRESULT* phrRc)
{
    HRESULT hres;

    if (SUCCEEDED(*phrRc))
    {
        if (pstm)
        {
            hres = IStream_Write(pstm, (LPVOID)pvData, cb);
            if (SUCCEEDED(hres))
            {
                *phrRc += cb;           // successful write - accumulate
            }
            else
            {
                *phrRc = hres;          // error - return error code
            }
        }
        else
        {
            *phrRc += cb;               // no output stream - accumulate
        }
    }
}

//
//  This worker function (1) computes the numer of bytes we will actually
//  write out, and (2) actually writes it if pstm != NULL.
//
//  Return value is the number of bytes written (or would have been
//  written), or a COM error code on failure.
//

const BYTE c_Zeros[2] = { 0 };    // a bunch of zeros

HRESULT
OrderItem_SaveToStreamWorker(PORDERITEM2 poi2, OISTREAMITEM *posi,
                             IStream *pstm, IShellFolder2 *psf2)
{
    HRESULT hrRc = 0;           // no bytes, no error

    ASSERT(poi2->oi.pidl);

    //
    //  First comes the header.
    //
    OrderItem_SaveSubitemToStream(pstm, posi, CB_OISTREAMITEM, &hrRc);

    //
    //  Then the pidl.
    //

    // We're assuming this is an immediate child pidl.  If it's not,
    // the pidl is being truncated!
    ASSERT(0 == _ILNext(poi2->oi.pidl)->mkid.cb);

    OrderItem_SaveSubitemToStream(pstm, poi2->oi.pidl,
                                  poi2->oi.pidl->mkid.cb + sizeof(USHORT),
                                  &hrRc);
    // Insert padding to get back to WCHAR alignment.
    if (hrRc % sizeof(WCHAR)) 
    {
        OrderItem_SaveSubitemToStream(pstm, &c_Zeros, 1, &hrRc);
    }

    OrderItem_SaveSubitemToStream(pstm, &poi2->dwFlags, sizeof(DWORD), &hrRc);

    //
    //  If we haven't barfed yet and the IShellFolder supports identity
    //  and there is icon information, then save it.
    //
    if (SUCCEEDED(hrRc) && psf2 && (poi2->pwszIcon || poi2->pidlTarget))
    {
        // Optional icon is present. 

        if (poi2->pwszIcon)
        {
            // UNICODEZ path
            DWORD cbString = (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR);

            // Save the String len
            OrderItem_SaveSubitemToStream(pstm, &cbString,
                      sizeof(DWORD) , &hrRc);

            OrderItem_SaveSubitemToStream(pstm, poi2->pwszIcon,
                      (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR), &hrRc);

            // icon index
            OrderItem_SaveSubitemToStream(pstm, &poi2->iIconIndex,
                      sizeof(poi2->iIconIndex), &hrRc);
        }
        else
        {
            DWORD cbString = 0;
            OrderItem_SaveSubitemToStream(pstm, &cbString, sizeof(DWORD), &hrRc);

            // pidlTarget
            OrderItem_SaveSubitemToStream(pstm, poi2->pidlTarget,
                      ILGetSize(poi2->pidlTarget), &hrRc);
        }
    }
    return hrRc;
}

HRESULT 
CALLBACK 
OrderItem_SaveToStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    PORDERITEM2 poi2 = (PORDERITEM2)pinfo->pvItem;
    HRESULT hres = S_FALSE;
    IShellFolder2 *psf2 = (IShellFolder2 *)pvData;

    if (poi2->oi.pidl)
    {
        OISTREAMITEM osi;

        // First a dry run to compute the size of this item.
        hres = OrderItem_SaveToStreamWorker(poi2, NULL, NULL, psf2);

        // Nothing actually got written, so this should always succeed.
        ASSERT(SUCCEEDED(hres));

        osi.cbSize = hres;
        osi.nOrder = poi2->oi.nOrder;

        // Now write it out for real
        hres = OrderItem_SaveToStreamWorker(poi2, &osi, pstm, psf2);

        // On success, we must return exactly S_OK or DPA will blow us off
        if (SUCCEEDED(hres))
            hres = S_OK;
    }

    return hres;
}   

//
//  Check if a pidl we read out of a stream is a simple child pidl.
//  The pidl must be exactly cb bytes in length.
//  The pointer is known to be valid;
//  we just want to check that the contents are good, too.
//
BOOL
IsValidPersistedChildPidl(LPCITEMIDLIST pidl, UINT cb)
{
    // Must have at least room for one byte of pidl plus the terminating
    // zero.
    if (cb < 1 + sizeof(USHORT))
        return FALSE;

    // Make sure size is at least what it's supposed to be.
    if (pidl->mkid.cb + sizeof(USHORT) > cb)
        return FALSE;

    // Make sure there's a zero right after it.
    pidl = _ILNext(pidl);
    return pidl->mkid.cb == 0;
}

//
//  Just like ILGetSize, but returns (UINT)-1 if the pidl is corrupt.
//  We use (UINT)-1 as the return value because it will be bigger than
//  the buffer size we eventually compare it against.
UINT SafeILGetSize(LPCITEMIDLIST pidl)
{
    __try 
    {
        return ILGetSize(pidl);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
    }
    return (UINT)-1;
}

HRESULT
CALLBACK 
OrderItem_LoadFromStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID /*pvData*/)
{
    HRESULT hres;
    OISTREAMITEM osi;

    hres = IStream_Read(pstm, &osi, CB_OISTREAMITEM);
    if (SUCCEEDED(hres))
    {
        ASSERT(CB_OISTREAMITEM < osi.cbSize);
        if (CB_OISTREAMITEM < osi.cbSize)
        {
            UINT cb = osi.cbSize - CB_OISTREAMITEM;
            LPITEMIDLIST pidl = IEILCreate(cb);
            if ( !pidl )
                hres = E_OUTOFMEMORY;
            else
            {
                hres = IStream_Read(pstm, pidl, cb);
                if (SUCCEEDED(hres) && IsValidPersistedChildPidl(pidl, cb))
                {
                    PORDERITEM poi = OrderItem_Create(pidl, osi.nOrder);

                    if (poi)
                    {
                        PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
                        pinfo->pvItem = poi;
                        // cbPos = offset to trailing gunk after pidl
                        UINT cbPos = pidl->mkid.cb + sizeof(USHORT);
                        cbPos = ROUNDUP(cbPos, sizeof(WCHAR));

                        // Do we have a DWORD hanging off the end of the pidl? This should be the flags.
                        if (cb >= cbPos + sizeof(DWORD))
                        {
                            poi2->dwFlags = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos);
                        }

                        // Make sure there's at least a WCHAR to test against.
                        if (cb >= cbPos + sizeof(WCHAR) + 2 * sizeof(DWORD))
                        {
                            DWORD cbString = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos + sizeof(DWORD));
                            LPWSTR pwszIcon = (LPWSTR)((LPBYTE)pidl + cbPos + 2 * sizeof(DWORD));

                            // Do we have a string lenght?
                            if (pwszIcon && cbString != 0)
                            {
                                // Yes, then this is a string not a pidl. We want to make sure this is a
                                // fully qualified path.
                                if (IS_VALID_STRING_PTRW(pwszIcon, cbString) &&
                                    !PathIsRelative(pwszIcon))
                                {
                                    poi2->pwszIcon = StrDup(pwszIcon);
                                    pwszIcon += lstrlenW(pwszIcon) + 1;
                                    poi2->iIconIndex = *(UNALIGNED int *)pwszIcon;
                                }
                            }
                            else
                            {
                                // A string length of zero is 
                                LPITEMIDLIST pidlTarget = (LPITEMIDLIST)(pwszIcon);
                                // We want to write
                                // cbPos + sizeof(WCHAR) + SafeILGetSize(pidlTarget) <= cb
                                // but SafeILGetSize returns (UINT)-1 on error, so we need
                                // to do some algebra to avoid overflows
                                if (SafeILGetSize(pidlTarget) <= cb - cbPos - 2 * sizeof(DWORD))
                                {
                                    poi2->pidlTarget = ILClone(pidlTarget);
                                }
                            }
                        }

                        hres = E_OUTOFMEMORY;

                        // pidl Contains extranious information. Take the hit of stripping it so that
                        // our working set doesn't bloat.
                        LPITEMIDLIST pidlNew = ILClone(poi2->oi.pidl);
                        if (pidlNew)
                        {
                            ILFree(poi2->oi.pidl);
                            poi2->oi.pidl = pidlNew;
                            hres = S_OK;
                        }
                    }
                    else
                        hres = E_OUTOFMEMORY;
                }
                else
                    hres = E_FAIL;

                // Cleanup
                if (FAILED(hres))
                    ILFree(pidl);
            }
        }
        else
            hres = E_FAIL;

    }

    ASSERT((S_OK == hres && pinfo->pvItem) || FAILED(hres));
    return hres;
}    

HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent)
{
    HDPA hdpa = NULL;
    OISTREAMHEADER oish;

    ASSERT(phdpa);
    ASSERT(pstm);

    // Read the header for more info
    if (SUCCEEDED(IStream_Read(pstm, &oish, sizeof(oish))) &&
        sizeof(oish) == oish.cbSize)
    {
        // Load the stream.  (Should be ordered by name.)
        DPA_LoadStream(&hdpa, OrderItem_LoadFromStream, pstm, psfParent);
        
        // if this is the wrong version, throw away the pidls.
        // we go through the load anyways to make suret he read pointer is set right
        if (OISTREAMHEADER_VERSION != oish.dwVersion)
            OrderList_Destroy(&hdpa, TRUE);
        
    }

    *phdpa = hdpa;

    return (NULL != hdpa) ? S_OK : E_FAIL;
}

HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpaSave, IShellFolder *psf)
{
    HRESULT hres = E_OUTOFMEMORY;
    OISTREAMHEADER oish;
    HDPA hdpa;

    // Clone the array and sort by name for the purpose of persisting it
    hdpa = DPA_Clone(hdpaSave, NULL);
    if (hdpa)
    {
        ORDERINFO   oinfo = {0};
#ifdef DEBUG
        // use QI to help track down leaks
        if (psf)
            EVAL(SUCCEEDED(psf->QueryInterface(IID_IShellFolder, (LPVOID *)&oinfo.psf)));
#else
        oinfo.psf = psf;
        if (psf)
            oinfo.psf->AddRef();
#endif
        oinfo.dwSortBy = OI_SORTBYNAME;
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

        // Save the header
        oish.cbSize = sizeof(oish);
        oish.dwVersion = OISTREAMHEADER_VERSION;

        hres = IStream_Write(pstm, &oish, sizeof(oish));
        if (SUCCEEDED(hres))
        {
            if (psf)
                oinfo.psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&oinfo.psf2);
            hres = DPA_SaveStream(hdpa, OrderItem_SaveToStream, pstm, oinfo.psf2);
            ATOMICRELEASE(oinfo.psf2);
        }
        ATOMICRELEASE(oinfo.psf);
        DPA_Destroy(hdpa);
    }

    return hres;
}    

/////////////
//
// COrderList impl for export to channel installer
//

class COrderList  : public IPersistFolder, 
                    public IOrderList2
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IPersistFolder
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IOrderList
    virtual STDMETHODIMP GetOrderList(HDPA * phdpa);
    virtual STDMETHODIMP SetOrderList(HDPA hdpa, IShellFolder *psf);
    virtual STDMETHODIMP FreeOrderList(HDPA hdpa);

    virtual STDMETHODIMP SortOrderList(HDPA hdpa, DWORD dw);

    virtual STDMETHODIMP AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP FreeOrderItem(PORDERITEM poi);

    // IOrderList 2
    virtual STDMETHODIMP LoadFromStream(IStream* pstm, HDPA* hdpa, IShellFolder* psf);
    virtual STDMETHODIMP SaveToStream(IStream* pstm, HDPA hdpa);

protected:
    COrderList(IUnknown* punkOuter, LPCOBJECTINFO poi);
    friend IUnknown * COrderList_Create();

    COrderList();
    ~COrderList();

    int _cRef;
    IShellFolder *_psf;
    LPITEMIDLIST  _pidl;
    LPITEMIDLIST  _pidlFavorites;
};

COrderList::COrderList()
{
    _cRef = 1;
    DllAddRef();
}

COrderList::~COrderList()
{
    ILFree(_pidl);
    ILFree(_pidlFavorites);
    ATOMICRELEASE(_psf);
    DllRelease();
}

IUnknown * COrderList_Create()
{
    COrderList * pcol = new COrderList;
    if (pcol)
    {
        return SAFECAST(pcol, IPersistFolder*);
    }
    return NULL;
}

STDAPI COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi)
{
    *punk = COrderList_Create();

    return *punk ? S_OK : E_OUTOFMEMORY;
}

ULONG COrderList::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG COrderList::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT COrderList::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(COrderList, IPersistFolder),
        QITABENT(COrderList, IOrderList),
        QITABENTMULTI(COrderList, IOrderList2, IOrderList),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT COrderList::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_OrderListExport;

    return S_OK;
}


// This is the directory setup wants to re-order
HRESULT COrderList::Initialize(LPCITEMIDLIST pidl)
{
    if (!_pidlFavorites)
    {
        SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &_pidlFavorites);
        if (!_pidlFavorites)
            return E_OUTOFMEMORY;
    }

    if (!pidl || !ILIsParent(_pidlFavorites, pidl, FALSE))
        return E_INVALIDARG;

    // Initialize can be called multiple times
    ATOMICRELEASE(_psf);

    Pidl_Set(&_pidl, pidl);

    if (_pidl)
        IEBindToObject(_pidl, &_psf);

    if (!_psf)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_READ);
    if (pstm)
    {
        HRESULT hres = OrderList_LoadFromStream(pstm, phdpa, psf);
        pstm->Release();
        return hres;
    }
    *phdpa = NULL;
    return E_OUTOFMEMORY;
}

HRESULT COrderList::GetOrderList(HDPA * phdpa)
{
    HRESULT hres = E_FAIL;

    *phdpa = NULL;

    if (_psf)
        hres = COrderList_GetOrderList(phdpa, _pidl, _psf);

    return hres;
}

HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_WRITE);
    if (EVAL(pstm))
    {
        HRESULT hres = OrderList_SaveToStream(pstm, hdpa, psf);
        pstm->Release();
        return hres;
    }
    return E_OUTOFMEMORY;
}

HRESULT COrderList::SetOrderList(HDPA hdpa, IShellFolder *psf)
{
    if (!_psf)
        return E_FAIL;

    return COrderList_SetOrderList(hdpa, _pidl, psf);
}

HRESULT COrderList::FreeOrderList(HDPA hdpa)
{
    OrderList_Destroy(&hdpa);
    return S_OK;
}

HRESULT COrderList::SortOrderList(HDPA hdpa, DWORD dw)
{
    if (OI_SORTBYNAME != dw && OI_SORTBYORDINAL != dw)
        return E_INVALIDARG;

    if (!_psf)
        return E_FAIL;

    ORDERINFO oinfo;
    oinfo.dwSortBy = dw;
    oinfo.psf = _psf;
#ifdef DEBUG
    oinfo.psf2 = (IShellFolder2 *)INVALID_HANDLE_VALUE; // force fault if someone uses it
#endif

    DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

    return S_OK;
}

HRESULT COrderList::AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlClone = ILClone(pidl);

    *ppoi = NULL;

    if (pidlClone)
    {
        *ppoi = OrderItem_Create(pidlClone, -1);
        if (*ppoi)
            return S_OK;

        ILFree(pidlClone);
    }

    return E_OUTOFMEMORY;
}



HRESULT COrderList::FreeOrderItem(PORDERITEM poi)
{
    OrderItem_Free(poi);

    return S_OK;
}

// IOrderList2::LoadFromStream
STDMETHODIMP COrderList::LoadFromStream(IStream* pstm, HDPA* phdpa, IShellFolder* psf)
{
    ASSERT(_psf == NULL);
    _psf = psf;
    if (_psf)
        _psf->AddRef();
    return OrderList_LoadFromStream(pstm, phdpa, _psf);
}

// IOrderList2::SaveToStream
STDMETHODIMP COrderList::SaveToStream(IStream* pstm, HDPA hdpa)
{
    return OrderList_SaveToStream(pstm, hdpa, _psf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\droptgt.h ===
#ifndef _DROPTGT_H_
#define _DROPTGT_H_

// There are two drag-drop support objects:
//
//  CDropTargetWrap -       This object takes a collection of drop-target
//                          objects and wraps them as one drop-target
//                          handler.  The first drop-target wins over the
//                          the last one if there is a conflict in who
//                          will take the drop.
//
//  CDelegateDropTarget -   This class implements IDropTarget given an 
//                          IDelegateDropTargetCB interface.  It handles 
//                          all hit testing, caching, and scrolling for you.
//                          Use this class by inheriting it in your derived
//                          class; it is not intended to be instantiated alone.
//

// Event notifications for HitTestDDT
#define HTDDT_ENTER     0
#define HTDDT_OVER      1
#define HTDDT_LEAVE     2

class CDelegateDropTarget : public IDropTarget
{        
public:
    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** Other methods to be implemented by derived class ***

    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) PURE;
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect) PURE;
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj) PURE;
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

    friend IDropTarget* DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, 
                                           IDropTarget* pdtSecondary,
                                           HWND hwnd, IDropTarget* pdt3 = NULL);
protected:
    CDelegateDropTarget();
    virtual ~CDelegateDropTarget();

    BOOL IsValid() { return (_hwndLock && _hwndScroll); }
    void SetCallback(IDelegateDropTargetCB* pdtcb);
    HRESULT Init(); // init lock + scroll windows
    friend IDropTarget* DelegateDropTarget_CreateInstance(IDelegateDropTargetCB* pdtcb);

private:
    void _ReleaseCurrentDropTarget();

    // the below are parameters we use to implement this IDropTarget
    HWND                    _hwndLock;
    HWND                    _hwndScroll;

    // the object we are dragging
    LPDATAOBJECT            _pDataObj;      // from DragEnter()/Drop()

    // the below indicate the current drag state
    BITBOOL                 _fPrime:1;      // TRUE iff _itemOver/_grfKeyState is valid
    DWORD_PTR               _itemOver;      // item we are visually dragging over
    IDropTarget*            _pdtCur;        // drop target for _itemOver
    DWORD                   _grfKeyState;   // cached key state
    DWORD                   _dwEffectOut;   // last *pdwEffect out
    POINT                   _ptLast;        // last dragged position

    // for scrolling
    RECT                    _rcLockWindow;  // WindowRect of hwnd for DAD_ENTER
    AUTO_SCROLL_DATA        _asd;           // for auto scrolling
    
} ;

// dummy drop target to only call DAD_DragEnterEx() on DragEnter();

class CDropDummy : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void)   
    { 
        DAD_DragLeave();  
        return(S_OK); 
    };
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)   
    { 
        DragLeave();
        return(S_OK); 
    };

    CDropDummy(HWND hwndLock) : _hwndLock(hwndLock), _cRef(1)  { return; };
protected:
    ~CDropDummy()    { return; };
private:
    HWND _hwndLock;         // window for dummy drop target.
    int  _cRef;

};


#endif // _DROPTGT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\droptgt.cpp ===
#include "droptgt.h"

#define TF_DRAGDROP TF_BAND


#define MAX_DROPTARGETS 3

class CDropTargetWrap : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CDropTargetWrap(IDropTarget** ppdtg, HWND hwnd);
protected:
    ~CDropTargetWrap();

private:
    int             _cRef;

    int             _count;
    IDropTarget*    _rgpdt[MAX_DROPTARGETS];
    DWORD           _rgdwEffect[MAX_DROPTARGETS];
    HWND            _hwnd;
};

CDropTargetWrap::CDropTargetWrap(IDropTarget** ppdt, HWND hwnd)
    : _hwnd(hwnd)
{
    _cRef = 1;

    for (int i = 0; i < MAX_DROPTARGETS; i++, ppdt++) {
        if (*ppdt) {
            _rgpdt[_count] = *ppdt;
            _rgpdt[_count]->AddRef();
            _count++;
        }
    }
}

CDropTargetWrap::~CDropTargetWrap()
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->Release();
    }
}

IDropTarget* DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, IDropTarget* pdtSecondary, HWND hwnd, IDropTarget* pdt3)
{
    // no point in wrapping nothing...
    if (pdtPrimary || pdtSecondary || pdt3)
    {
        IDropTarget* pdt[MAX_DROPTARGETS] = { pdtPrimary, pdtSecondary, pdt3 };
        
        CDropTargetWrap* pdtw = new CDropTargetWrap(pdt, hwnd);
        if (pdtw)
        {
            return SAFECAST(pdtw, IDropTarget*);
        }
    }
    return NULL;
}

HRESULT CDropTargetWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropTargetWrap, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropTargetWrap::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropTargetWrap::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         The *pdwEffect that is returned is the first valid value
         of all the drop targets' returned effects.

*/
HRESULT CDropTargetWrap::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;

    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragEnter(pdtobj, grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
            {
                dwEffectOut = _rgdwEffect[i];
            }
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }
    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDropTargetWrap::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
        
    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragOver(grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
                dwEffectOut = _rgdwEffect[i];
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDropTargetWrap::DragLeave(void)
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->DragLeave();
    }

    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDropTargetWrap::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
    int i;
    BOOL fDropTried = FALSE;

    for (i = 0 ; (DROPEFFECT_NONE == dwEffectOut) && i < _count ; i++)
    {
        if ((_rgdwEffect[i] && *pdwEffect) && !fDropTried)
        {
            dwEffectOut = *pdwEffect;
            _rgpdt[i]->Drop(pdtobj, grfKeyState, pt, &dwEffectOut);
            fDropTried = TRUE;
        }
        else
        {
            _rgpdt[i]->DragLeave();
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


//=============================================================================
// CDelegateDropTarget
//
// This class implements IDropTarget given an IDelegateDropTargetCB interface.
// It handles all hit testing, caching, and scrolling for you.
//
//=============================================================================
#undef  CDropTargetWrap

CDelegateDropTarget::CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "ctor CDelegateDropTarget %x", this);

}

CDelegateDropTarget::~CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "dtor CDelegateDropTarget %x", this);

    ASSERT(!_pDataObj);
    ATOMICRELEASE(_pDataObj);
    ASSERT(!_pdtCur);
    ATOMICRELEASE(_pdtCur);
}

HRESULT CDelegateDropTarget::Init()
{
    HRESULT hres = GetWindowsDDT(&_hwndLock, &_hwndScroll);
    // We lock _hwndLock and do scrolling against _hwndScroll.
    // These can be different hwnds, but certain restrictions apply:
    if (_hwndLock != _hwndScroll)
    {
        BOOL fValid = IsChild(_hwndLock, _hwndScroll);
        if (!fValid)
        {
            TraceMsg(TF_DRAGDROP, "ctor CDelegateDropTarget: invalid windows %x and %x!", _hwndLock, _hwndScroll);
            _hwndLock = _hwndScroll = NULL;
        }
    }
    return hres;
}

void CDelegateDropTarget::_ReleaseCurrentDropTarget()
{
    if (_pdtCur)
    {
        _pdtCur->DragLeave();
        ATOMICRELEASE(_pdtCur);
    }
}

/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

*/
HRESULT CDelegateDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    // We can be re-entered due to ui on thread
    if (_pDataObj != NULL)       
    {
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter called a second time!");
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter with *pdwEffect=%x", *pdwEffect);

    ASSERT(!_pDataObj);
    _pDataObj = pdtobj;
    _pDataObj->AddRef();

    // cache state
    //
    // wait until first DragOver to get valid info
    //
    _fPrime = FALSE;
    _dwEffectOut = DROPEFFECT_NONE;

    // set up auto-scroll info
    //
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);

    DAD_InitScrollData(&_asd);

    _ptLast.x = _ptLast.y = 0x7fffffff; // put bogus value to force redraw

    HitTestDDT(HTDDT_ENTER, NULL, NULL, NULL);

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDelegateDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    DWORD_PTR itemNew;
    POINT pt;
    DWORD dwEffectScroll = 0;
    DWORD dwEffectOut = 0;
    BOOL fSameImage = FALSE;
    DWORD   dwCustDropEffect = 0;

    if (_pDataObj == NULL)
    {
        ASSERT(0);      // DragEnter should be called before.
        return E_FAIL;
    }

    // convert to window coords
    pt.x = ptl.x;
    pt.y = ptl.y;
    ScreenToClient(_hwndScroll, &pt);

    if (DAD_AutoScroll(_hwndScroll, &_asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    //
    //  If we are dragging over on a different item, get its IDropTarget
    // interface or adjust itemNew to -1.
    //
    if (SUCCEEDED(HitTestDDT(HTDDT_OVER, &pt, &itemNew, &dwCustDropEffect)) &&
        (itemNew != _itemOver || !_fPrime))
    {
        _fPrime = TRUE;

        _ReleaseCurrentDropTarget();

        _itemOver = itemNew;
        GetObjectDDT(_itemOver, IID_IDropTarget, (LPVOID*)&_pdtCur);

        if (_pdtCur)
        {
            // There's an IDropTarget for this hit, use it
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragEnter(_pDataObj, grfKeyState, ptl, &dwEffectOut);
            if (FAILED(hres))
                dwEffectOut = DROPEFFECT_NONE;
        }
        else
        {
            // No IDropTarget, no effect
            dwEffectOut = DROPEFFECT_NONE;
        }
    }
    else
    {
        //
        // No change in the selection. We assume that *pdwEffect stays
        // the same during the same drag-loop as long as the key state doesn't change.
        //
        if ((_grfKeyState != grfKeyState) && _pdtCur)
        {
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragOver(grfKeyState, ptl, &dwEffectOut);

            TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver DragOver()d id:%d dwEffect:%4x hres:%d", _itemOver, dwEffectOut, hres);
        }
        else
        {
            // Same item and same key state. Use the previous dwEffectOut.
            dwEffectOut = _dwEffectOut;
            fSameImage = TRUE;
        }
    }

    _grfKeyState = grfKeyState;    // store these for the next Drop
    _dwEffectOut = dwEffectOut;    // and DragOver

    // Is the Custdrop effect valid ?
    if (dwCustDropEffect != DROPEFFECT_NONE)    
    {
        //Yes then set the effect to Custdrop effect along with scroll effect
        *pdwEffect = dwCustDropEffect | dwEffectScroll;
    }
    else 
    {
        //No , set the effect to dwEffectOut along with scroll effect
        *pdwEffect = dwEffectOut | dwEffectScroll;
    }
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver (*pdwEffect=%x)", *pdwEffect);


    if (!(fSameImage && pt.x==_ptLast.x && pt.y==_ptLast.y))
    {
        _DragMove(_hwndLock, ptl);
        _ptLast.x = ptl.x;
        _ptLast.y = ptl.y;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDelegateDropTarget::DragLeave()
{
    HitTestDDT(HTDDT_LEAVE, NULL, NULL, NULL);
    _ReleaseCurrentDropTarget();

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragLeave");
    ATOMICRELEASE(_pDataObj);

    DAD_DragLeave();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDelegateDropTarget::Drop(IDataObject *pdtobj,
                             DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    BOOL bDropHandled = FALSE;

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::Drop (*pdwEffect=%x)", *pdwEffect);

    //
    // According to AlexGo (OLE), this is by-design. We should make it sure
    // that we use pdtobj instead of pdtobj.
    //
    //ASSERT(pdtobj == _pDataObj);
    pdtobj->AddRef();
    _pDataObj->Release();
    _pDataObj = pdtobj;

    //
    // Note that we don't use the drop position intentionally,
    // so that it matches to the last destination feedback.
    //
    if (_pdtCur)
    {
        // use this local because if _pdtCur::Drop does a UnlockWindow
        // then hits an error and needs to put up a dialog,
        // we could get re-entered
        IDropTarget *pdtCur = _pdtCur;
        _pdtCur = NULL;

        // HACK ALERT!!!!
        //
        //  If we don't call LVUtil_DragEnd here, we'll be able to leave
        // dragged icons visible when the menu is displayed. However, because
        // we are calling IDropTarget::Drop() which may create some modeless
        // dialog box or something, we can not ensure the locked state of
        // the list view -- LockWindowUpdate() can lock only one window at
        // a time. Therefore, we skip this call only if the _pdtCur
        // is a subclass of CIDLDropTarget, assuming its Drop calls
        // CDefView::DragEnd (or CIDLDropTarget_DragDropMenu) appropriately.
        //
#if 0 // later
        if (!IsIDLDropTarget(pdtCur))
#endif
        {
            //
            // This will hide the dragged image.
            //
            DAD_DragLeave();

            //
            //  We need to reset the drag image list so that the user
            // can start another drag&drop while we are in this
            // Drop() member function call.
            //
            // NOTE: we don't have to worry about the DAD_DragLeave
            // (called from during the DragLeave call at the end of
            // this function) cancelling the potential above-mentioned
            // drag&drop loop. If such a beast is going on, it should
            // complete before pdtCur->Drop returns.
            //
            DAD_SetDragImage(NULL, NULL);
        }

        if (S_FALSE != OnDropDDT(pdtCur, _pDataObj, &grfKeyState, pt, pdwEffect))
            pdtCur->Drop(_pDataObj, grfKeyState, pt, pdwEffect);
        else
            pdtCur->DragLeave(); // should be okay even if OnDrop did this already

        pdtCur->Release();
    }
    else
    {
        //
        // We come here if Drop is called without DragMove (with DragEnter).
        //
        *pdwEffect = DROPEFFECT_NONE;
    }

    //
    // Clean up everything (OLE won't call DragLeave after Drop).
    //
    DragLeave();

    return hres;
}

// ******************************************************************
// dummy drop target to only call DAD_DragEnterEx() on DragEnter();
// ******************************************************************

HRESULT CDropDummy::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropDummy, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropDummy::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropDummy::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         simply call DAD_DragEnterEx2() to get custom drag cursor 
         drawing.

*/
HRESULT CDropDummy::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);
    *pdwEffect = DROPEFFECT_NONE;
    return(S_OK);
}

HRESULT CDropDummy::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _DragMove(_hwndLock, ptl);
    *pdwEffect = DROPEFFECT_NONE;
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of type library
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid,
    USHORT wVerMajor, USHORT wVerMinor, 
    REFGUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid);
        virtual ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        REFIID      m_riid;
        REFGUID     m_libid;
        USHORT      m_wVerMajor;
        USHORT      m_wVerMinor;

        ITypeInfo  *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dpastuff.h ===
#ifndef DPASTUFF_H_
#define DPASTUFF_H_

typedef struct
{
    DWORD           dwSortBy;           // the sort by flag.
    IShellFolder    *psf;               // shell folder to be ordered.

    // Caller of OrderList_Merge does *not* fill in this field.
    // This field is used internally by OrderList_Merge.
    IShellFolder2   *psf2;              // IShellFolder2 version of psf
    LPARAM          lParam;             // Other user data...

} ORDERINFO, * PORDERINFO;

// see shellp.h for ORDERITEM definition
typedef void (*LPFNORDERMERGENOMATCH)(LPVOID pvParam, LPCITEMIDLIST pidl);

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam);
LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam);
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam, 
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam);
void OrderList_Reorder(HDPA hdpa);
HDPA OrderList_Clone(HDPA hdpa);
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder);
void OrderList_Destroy(HDPA *hdpa, BOOL fKillPidls = TRUE);
int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache);
DWORD OrderItem_GetFlags(PORDERITEM poi);
void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags);
HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpa, IShellFolder * psf);
HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent);
void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls = TRUE);
BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder);

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf);
HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dump.c ===
//
// Debug dump functions for common ADTs
//
// This file should be #included by your DLL.  It is not part of
// stocklib.lib because it requires linking to certain guid libs,
// and DLLs like COMCTL32 do not do this.  (Therefore, COMCTL32
// doesn't #include this file, but still links to stocklib.)
//
//

#include <intshcut.h>       // For error values
#include <sherror.h>

#ifdef DEBUG

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


//
//  Debug value-to-string mapping functions
//


/*----------------------------------------------------------
Purpose: Return the string form of the clipboard format.

Returns: pointer to a static string
Cond:    --
*/
LPCTSTR 
Dbg_GetCFName(
    UINT ucf)
{
    LPCTSTR pcsz;
    static TCHAR s_szCFName[MAX_PATH];

    switch (ucf)
    {
        STRING_CASE(CF_TEXT);
        STRING_CASE(CF_BITMAP);
        STRING_CASE(CF_METAFILEPICT);
        STRING_CASE(CF_SYLK);
        STRING_CASE(CF_DIF);
        STRING_CASE(CF_TIFF);
        STRING_CASE(CF_OEMTEXT);
        STRING_CASE(CF_DIB);
        STRING_CASE(CF_PALETTE);
        STRING_CASE(CF_PENDATA);
        STRING_CASE(CF_RIFF);
        STRING_CASE(CF_WAVE);
        STRING_CASE(CF_UNICODETEXT);
        STRING_CASE(CF_ENHMETAFILE);
        STRING_CASE(CF_HDROP);
        STRING_CASE(CF_LOCALE);
        STRING_CASE(CF_MAX);
        STRING_CASE(CF_OWNERDISPLAY);
        STRING_CASE(CF_DSPTEXT);
        STRING_CASE(CF_DSPBITMAP);
        STRING_CASE(CF_DSPMETAFILEPICT);
        STRING_CASE(CF_DSPENHMETAFILE);

    default:
        if (! GetClipboardFormatName(ucf, s_szCFName, SIZECHARS(s_szCFName)))
            lstrcpy(s_szCFName, TEXT("UNKNOWN CLIPBOARD FORMAT"));
        pcsz = s_szCFName;
        break;
    }

    ASSERT(pcsz);

    return(pcsz);
}


LPCTSTR 
Dbg_GetHRESULTName(
    HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR s_rgchHRESULT[] = TEXT("0x12345678");

    switch (hr)
        {
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);

        STRING_CASE(DRAGDROP_S_CANCEL);
        STRING_CASE(DRAGDROP_S_DROP);
        STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

        STRING_CASE(CLASS_E_NOAGGREGATION);

        STRING_CASE(CO_E_NOTINITIALIZED);
        STRING_CASE(CO_E_ALREADYINITIALIZED);
        STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

        STRING_CASE(DV_E_DVASPECT);
        STRING_CASE(DV_E_LINDEX);
        STRING_CASE(DV_E_TYMED);
        STRING_CASE(DV_E_FORMATETC);

        STRING_CASE(E_FLAGS);

        STRING_CASE(URL_E_INVALID_SYNTAX);
        STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

        STRING_CASE(IS_E_EXEC_FAILED);

        STRING_CASE(E_FILE_NOT_FOUND);
        STRING_CASE(E_PATH_NOT_FOUND);

    default:
        wsprintf(s_rgchHRESULT, TEXT("%#lx"), hr);
        pcsz = s_rgchHRESULT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


/*----------------------------------------------------------
Purpose: Dump propvariant types

Returns: 
Cond:    --
*/
LPCTSTR 
Dbg_GetVTName(
    VARTYPE vt)
{
    LPCTSTR pcsz;
    static TCHAR s_szT[] = TEXT("0x12345678");

    switch (vt)
        {
        STRING_CASE(VT_EMPTY);
        STRING_CASE(VT_NULL);
        STRING_CASE(VT_I2);
        STRING_CASE(VT_I4);
        STRING_CASE(VT_R4);
        STRING_CASE(VT_R8);
        STRING_CASE(VT_CY);
        STRING_CASE(VT_DATE);
        STRING_CASE(VT_BSTR);
        STRING_CASE(VT_ERROR);
        STRING_CASE(VT_BOOL);
        STRING_CASE(VT_VARIANT);
        STRING_CASE(VT_UI1);
        STRING_CASE(VT_UI2);
        STRING_CASE(VT_UI4);
        STRING_CASE(VT_I8);
        STRING_CASE(VT_UI8);
        STRING_CASE(VT_LPSTR);
        STRING_CASE(VT_LPWSTR);
        STRING_CASE(VT_FILETIME);
        STRING_CASE(VT_BLOB);
        STRING_CASE(VT_STREAM);
        STRING_CASE(VT_STORAGE);
        STRING_CASE(VT_STREAMED_OBJECT);
        STRING_CASE(VT_STORED_OBJECT);
        STRING_CASE(VT_BLOB_OBJECT);
        STRING_CASE(VT_CLSID);
        STRING_CASE(VT_ILLEGAL);
        STRING_CASE(VT_CF);

    default:
        wsprintf(s_szT, TEXT("%#lx"), vt);
        pcsz = s_szT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


#define STRING_RIID(val)               { &val, TEXT(#val) }

//
//  Alphabetical order, please.
//

struct 
    {
    REFIID riid;
    LPCTSTR psz;
    } const c_mpriid[] = 
{
#ifdef __IAddressList_INTERFACE_DEFINED__
        STRING_RIID(IID_IAddressList),
#endif
        STRING_RIID(IID_IAdviseSink),
#ifdef __IAddressList_INTERFACE_DEFINED__
        STRING_RIID(IID_IAddressList),
#endif
#ifdef __IAugmentedShellFolder_INTERFACE_DEFINED__
        STRING_RIID(IID_IAugmentedShellFolder),
#endif
#ifdef __IAugmentedShellFolder2_INTERFACE_DEFINED__
        STRING_RIID(IID_IAugmentedShellFolder2),
#endif
#ifdef __IAuthenticate_INTERFACE_DEFINED__
        STRING_RIID(IID_IAuthenticate),
#endif
#ifdef __IBandSiteHelper_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandSiteHelper),
#endif
#ifdef __IBandProxy_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandProxy),
#endif
#ifdef __IBindStatusCallback_INTERFACE_DEFINED__
        STRING_RIID(IID_IBindStatusCallback),
#endif
#ifdef __IBrowserBand_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserBand),
#endif
#ifdef __IBrowserService_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserService),
#endif
#ifdef __IBrowserService2_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserService2),
#endif
        STRING_RIID(IID_IConnectionPoint),
#ifdef __IConnectionPointCB_INTERFACE_DEFINED__
        STRING_RIID(IID_IConnectionPointCB),
#endif
        STRING_RIID(IID_IConnectionPointContainer),
        STRING_RIID(IID_IContextMenu),
        STRING_RIID(IID_IContextMenu2),
#ifdef __IContextMenuCB_INTERFACE_DEFINED__
        STRING_RIID(IID_IContextMenuCB),
#endif
#ifdef __IContextMenuSire_INTERFACE_DEFINED__
        STRING_RIID(IID_IContextMenuSite),
#endif
        STRING_RIID(IID_IDataObject),
        STRING_RIID(IID_IDeskBand),
        STRING_RIID(IID_IDispatch),
#ifdef __IDocHostUIHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocHostUIHandler),
#endif
        STRING_RIID(IID_IDockingWindowFrame),
        STRING_RIID(IID_IDockingWindow),
        STRING_RIID(IID_IDockingWindowSite),
#ifdef __IDocNavigate_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocNavigate),
#endif
        STRING_RIID(IID_IDocViewSite),
        STRING_RIID(IID_IDropTarget),
#ifdef __IDropTargetBackground_INTERFACE_DEFINED__
        STRING_RIID(IID_IDropTargetBackground),
#endif
#ifdef __IEFrameAuto_INTERFACE_DEFINED__
        STRING_RIID(IID_IEFrameAuto),
#endif        
        STRING_RIID(IID_IEnumUnknown),
        STRING_RIID(IID_IErrorInfo),
#ifdef __IExpDispSupport_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupport),
#endif
#ifdef __IExpDispSupportOC_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupportOC),
#endif
#ifdef __IExplorerToolbar_INTERFACE_DEFINED__
        STRING_RIID(IID_IExplorerToolbar),
#endif
        STRING_RIID(IID_IExtractIcon),
        STRING_RIID(IID_IExternalConnection),
#ifdef __FavoriteMenu_INTERFACE_DEFINED__
        STRING_RIID(IID_FavoriteMenu),
#endif
#ifdef __IHistSFPrivate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHistSFPrivate),
#endif
#ifdef __IHlink_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlink),
#endif
#ifdef __IHlinkFrame_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkFrame),
#endif
#ifdef __IHlinkSite_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkSite),
#endif
#ifdef __IHlinkTarget_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkTarget),
#endif
#ifdef __IHttpNegotiate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpNegotiate),
#endif
#ifdef __IHttpSecurity_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpSecurity),
#endif
        STRING_RIID(IID_IInputObject),
        STRING_RIID(IID_IInputObjectSite),
#ifdef __IIsWebBrowserSB_INTERFACE_DEFINED__
        STRING_RIID(IID_IIsWebBrowserSB),
#endif
        STRING_RIID(IID_IMenuBand),
#ifdef __IMRU_INTERFACE_DEFINED__
        STRING_RIID(IID_IMRU),
#endif
#ifdef __INavigationStack_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStack),
#endif
#ifdef __INavigationStackItem_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStackItem),
#endif
        STRING_RIID(IID_INewShortcutHook),
#ifdef __IObjectCache_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectCache),
#endif
#ifdef __IObjectSafety_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectSafety),
#endif
        STRING_RIID(IID_IOleClientSite),
        STRING_RIID(IID_IOleCommandTarget),
        STRING_RIID(IID_IOleContainer),
        STRING_RIID(IID_IOleControl),
        STRING_RIID(IID_IOleControlSite),
        STRING_RIID(IID_IOleDocument),
        STRING_RIID(IID_IOleDocumentSite),
        STRING_RIID(IID_IOleDocumentView),
        STRING_RIID(IID_IOleInPlaceActiveObject),
        STRING_RIID(IID_IOleInPlaceFrame),
        STRING_RIID(IID_IOleInPlaceSite),
        STRING_RIID(IID_IOleInPlaceObject),
        STRING_RIID(IID_IOleInPlaceUIWindow),
        STRING_RIID(IID_IOleObject),
        STRING_RIID(IID_IOleWindow),
        STRING_RIID(IID_IPersist),
        STRING_RIID(IID_IPersistFolder),
#ifdef __IPersistMoniker_INTERFACE_DEFINED__
        STRING_RIID(IID_IPersistMoniker),
#endif
        STRING_RIID(IID_IPersistPropertyBag),
        STRING_RIID(IID_IPersistStorage),
        STRING_RIID(IID_IPersistStream),
        STRING_RIID(IID_IPersistStreamInit),
#ifdef __IPersistString_INTERFACE_DEFINED__
        STRING_RIID(IID_IPersistString),
#endif
        STRING_RIID(IID_IProvideClassInfo),
        STRING_RIID(IID_IPropertyNotifySink),
        STRING_RIID(IID_IPropertySetStorage),
        STRING_RIID(IID_IPropertyStorage),
#ifdef __IProxyShellFolder_INTERFACE_DEFINED__
        STRING_RIID(IID_IProxyShellFolder),
#endif
        STRING_RIID(IID_IServiceProvider),
#ifdef __ISetWinHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_ISetWinHandler),
#endif
        STRING_RIID(IID_IShellBrowser),
        STRING_RIID(IID_IShellChangeNotify),
        STRING_RIID(IID_IShellDetails),
#ifdef __IShellDetails2_INTERFACE_DEFINED__
        STRING_RIID(IID_IShellDetails2),
#endif
        STRING_RIID(IID_IShellExtInit),
        STRING_RIID(IID_IShellFolder),
        STRING_RIID(IID_IShellIcon),
        STRING_RIID(IID_IShellLink),
        STRING_RIID(IID_IShellLinkDataList),
        STRING_RIID(IID_IShellMenu),
        STRING_RIID(IID_IShellMenuCallback),
        STRING_RIID(IID_IShellPropSheetExt),
#ifdef __IShellService_INTERFACE_DEFINED__
        STRING_RIID(IID_IShellService),
#endif
        STRING_RIID(IID_IShellView),
        STRING_RIID(IID_IShellView2),
#ifdef __ITargetEmbedding_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetEmbedding),
#endif
#ifdef __ITargetFrame2_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFrame2),
#endif
#ifdef __ITargetFramePriv_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFramePriv),
#endif
        STRING_RIID(IID_ITravelEntry),
        STRING_RIID(IID_ITravelLog),
        STRING_RIID(IID_IUniformResourceLocator),
        STRING_RIID(IID_IUnknown),
        STRING_RIID(IID_IViewObject),
        STRING_RIID(IID_IViewObject2),
        STRING_RIID(IID_IWebBrowser),
        STRING_RIID(IID_IWebBrowser2),
        STRING_RIID(IID_IWebBrowserApp),
#ifdef __IWinEventHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_IWinEventHandler),
#endif
};

struct 
{
    IID iid;
    TCHAR szGuid[GUIDSTR_MAX];
} s_guid[50] = {0};

LPCTSTR
Dbg_GetREFIIDName(
    REFIID riid)
{
    int i;

    // search the known list
    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return c_mpriid[i].psz;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return s_guid[i].szGuid;
            }
        else
            {
            s_guid[i].iid = *riid;
            SHStringFromGUID(riid, s_guid[i].szGuid, ARRAYSIZE(s_guid[0].szGuid));
            return s_guid[i].szGuid;
            }
        }

    return TEXT("Unknown REFIID");
}

//***
// NOTE
//  must be called *after* Dbg_GetREFIIDName (since that is what creates entry)
void *
Dbg_GetREFIIDAtom(
    REFIID riid)
{
    int i;

    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return (void *) c_mpriid[i].riid;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return (void *) &s_guid[i].iid;
            }
        else
            {
            return NULL;
            }
        }

    return NULL;
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\dvocx.h ===
/*
** dvocx.h
**
** Private interface which DefView supports so OCs can get special information.
*/

#ifndef _DVOCX_H_
#define _DVOCX_H_


#endif // _DVOCX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\filelist.h ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

typedef struct
{
    DWORD dwAttribs;
    LPITEMIDLIST pidl;
    PSTR pszName;
} FILELIST_ITEM;
typedef FILELIST_ITEM *PFILELIST_ITEM;

typedef BOOL (*PFN_FOLDER_ENUM_CALLBACK)(LPSHELLFOLDER psf, LPITEMIDLIST pidlFolder, LPITEMIDLIST pidlItem, LPVOID pv);
BOOL Folder_Enum(LPITEMIDLIST pidlFolder, PFN_FOLDER_ENUM_CALLBACK pfn, PVOID pv);

void FileList_Destroy(HDPA hdpa);
BOOL FileList_Create(LPITEMIDLIST pidlFolder, HDPA *phdpa, PINT pcItems);
BOOL FileList_Sort(HDPA hdpaFLI);

BOOL FileList_CreateItem(IShellFolder *psf, LPITEMIDLIST pidl, PFILELIST_ITEM *ppfli);
void FileList_DestroyItem(PFILELIST_ITEM pfli);
BOOL Sz_AllocCopy(LPCTSTR pszSrc, LPSTR *ppszDst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\expdsprt.h ===
#ifndef __EXPDSPRT_H__
#define __EXPDSPRT_H__

#include "cnctnpt.h"

#ifdef TF_SHDLIFE
#undef TF_SHDLIFE
#endif

#define TF_SHDLIFE       TF_CUSTOM1

//
// Helper C++ class used to share code for the IExpDispSupport...
//
// 
class CImpIExpDispSupport : public IExpDispSupport
{
    public:
        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
        virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
        virtual STDMETHODIMP_(ULONG) Release(void) PURE;

        // *** IExpDispSupport specific methods ***
        virtual STDMETHODIMP FindCIE4ConnectionPoint(REFIID riid, CIE4ConnectionPoint **ppccp);
        virtual STDMETHODIMP OnTranslateAccelerator(MSG __RPC_FAR *pMsg,DWORD grfModifiers);
        virtual STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                            VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    protected:
        virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID riid) PURE;

        CImpIExpDispSupport() { TraceMsg(TF_SHDLIFE, "ctor CImpIExpDispSupport %x", this); }
        ~CImpIExpDispSupport() { TraceMsg(TF_SHDLIFE, "dtor CImpIExpDispSupport %x", this); }
};

// CImpIExpDispSupport implements half of IConnectionPoint
// 
class CImpIConnectionPointContainer : public IConnectionPointContainer
{
    public:
        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
        virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
        virtual STDMETHODIMP_(ULONG) Release(void) PURE;

        // *** IConnectionPointContainer ***
        virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum) PURE;
        virtual STDMETHODIMP FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    protected:
        virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid) PURE;

        CImpIConnectionPointContainer() { TraceMsg(TF_SHDLIFE, "ctor CImpIExpDispSupport %x", this); }
        ~CImpIConnectionPointContainer() { TraceMsg(TF_SHDLIFE, "dtor CImpIExpDispSupport %x", this); }
};

#endif // __EXPDSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\findhlp.h ===
// Help id's for Find File dialog box (shell.dll)

#define NO_HELP                        ((DWORD) -1) // Disables Help for a control

#define IDH_FINDFILENAME_NAME           2200
#define IDH_FINDFILENAME_LOOKIN         2201
#define IDH_FINDFILENAME_BROWSE         2202
#define IDH_FINDFILENAME_TOPLEVEL       2203
#define IDH_FINDFILENAME_FINDNOW        2204
#define IDH_FINDFILENAME_STOP           2205
#define IDH_FINDFILENAME_NEWSEARCH      2206
#define IDH_FINDFILECRIT_OFTYPE         2207
#define IDH_FINDFILECRIT_CONTTEXT       2208
#define IDH_FINDFILECRIT_SIZEIS         2209
#define IDH_FINDFILECRIT_K              2210
#define IDH_FINDFILEDATE_ALLFILES       2211
#define IDH_FINDFILEDATE_CREATEORMOD    2212
#define IDH_FINDFILEDATE_DAYS           2213
#define IDH_FINDFILEDATE_FROM           2214
#define IDH_FINDFILEDATE_MONTHS         2215
#define IDH_FINDFILEDATE_RANGE          2216
#define IDH_FINDFILEDATE_TO             2217
#define IDH_FINDCOMP_NAME               2218
#define IDH_FINDCOMP_LOOKIN             2220
#define IDH_FINDCOMP_BROWSE             2221
#define IDH_FINDFILENAME_STATUSSCREEN   2223
#define IDH_BROWSELIST                  2224
#define IDH_DISPLAY_FOLDER              2225
#define IDH_CREATE_NEW_FOLDER           2226
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\enumt.h ===
#ifndef __ENUMERATORTEMPLATES_H__
#define __ENUMERATORTEMPLATES_H__

template <class TIMPL, class TELT>
class CEnumAny : public TIMPL
{
public:
    CEnumAny() : _cRef(1), _cNext(0) {}
    virtual ~CEnumAny() {}
    
    // IUnknown methods
    // STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IEnumXXXX methods
    STDMETHODIMP Next(ULONG celt, TELT *rgelt, ULONG *pcelt)
    {
        UINT cNum = 0;
        ZeroMemory(rgelt, sizeof(rgelt[0])*celt);
        while (cNum < celt 
        && _Next(&rgelt[cNum]))
        {
            _cNext++;
            cNum++;
        }

        if (pcelt)
           *pcelt = cNum;

        return (celt == cNum) ? S_OK: S_FALSE;
    }
        
    STDMETHODIMP Skip(ULONG celt)
        { return E_NOTIMPL; }
    STDMETHODIMP Reset()
        { return E_NOTIMPL; }
    STDMETHODIMP Clone(TIMPL **ppenum)
        { return E_NOTIMPL; }

protected:
    virtual BOOL _Next(TELT *pelt) = 0;
protected:
    LONG _cRef;
    ULONG _cNext;
};

class CEnumAssociationElements : public CEnumAny<IEnumAssociationElements, IAssociationElement *>
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CEnumAssociationElements, IEnumAssociationElements),
            { 0 }
        };
        return QISearch(this, qit, riid, ppv);
    }
};

#endif // __ENUMERATORTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\filetype.h ===
#ifndef _INC_FILETYPE_
#define _INC_FILETYPE_


// File Type Attributes key's bitmap values (HKEY_CLASSES_ROOT\filetype,Attributes)
#define FTA_Exclude             0x00000001 //  1. used to exclude types like drvfile
#define FTA_Show                0x00000002 //  2. used to show types like folder that don't have associations
#define FTA_HasExtension        0x00000004 //  3. type has assoc extension
#define FTA_NoEdit              0x00000008 //  4. no editing of file type
#define FTA_NoRemove            0x00000010 //  5. no deling of the file type
#define FTA_NoNewVerb           0x00000020 //  6. no adding of verbs
#define FTA_NoEditVerb          0x00000040 //  7. no editing of predefined verbs
#define FTA_NoRemoveVerb        0x00000080 //  8. no deling of predefined verbs
#define FTA_NoEditDesc          0x00000100 //  9. no editing of file type description
#define FTA_NoEditIcon          0x00000200 // 10. no editing of doc icon
#define FTA_NoEditDflt          0x00000400 // 11. no changing of default verb
#define FTA_NoEditVerbCmd       0x00000800 // 12. no editing of the verbs command
#define FTA_NoEditVerbExe       0x00001000 // 13. no editing of the verbs exe
#define FTA_NoDDE               0x00002000 // 14. no editing of the DDE fields
#define FTA_ExtShellOpen        0x00004000 // 15. old style type: HKCR/.ext/shell/open/command
#define FTA_NoEditMIME          0x00008000 // 16. no editing of the Content Type or Default Extension fields
#define FTA_OpenIsSafe          0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#define FTA_AlwaysUnsafe        0x00020000 // 18. don't allow the "Never ask me" checkbox to be enabled; File Type dialog still allows user to turn this off
#define FTA_AlwaysShowExt       0x00040000 // 19. always show the extension (even if the user has "hide extensions" displayed)
#define FTA_MigratedShowExt     0x00080000 // 20. has the old AlwaysShowExt reg key been migrated into the class flags yet?
#define FTA_NoRecentDocs        0x00100000 // 21. dont add this file type to the Recent Documents folder

#define FTAV_UserDefVerb        0x00000001 // 1. identifies verb as being user defined (!predefined)


//================================================================
// typedef's
//================================================================

typedef enum mimeflags
{

    MIME_FL_CONTENT_TYPES_ADDED   = 0x0001, // The Content Type combo box drop down has been filled with MIME types.

    /* flag combinations */

    ALL_MIME_FLAGS                = MIME_FL_CONTENT_TYPES_ADDED
} MIMEFLAGS;


#endif // _INC_FILETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\fldset.h ===
#ifndef FLDSET_H_
#define FLDSET_H_


//
// view priority values
//
// NOTE: left gaps so that we can add more later
//
#define VIEW_PRIORITY_RESTRICTED    0x00000070  // a shell restriction is in place that forces this view to be the one we use
#define VIEW_PRIORITY_CACHEHIT      0x00000050  // we have registry info for the view, so the user has been there before
#define VIEW_PRIORITY_STALECACHEHIT 0x00000045  // we have stale registry info for the view, so we fall back to the "all folders like this" default
#define VIEW_PRIORITY_USEASDEFAULT  0x00000043  // "Use As Default" is more important than shellext, but less than a stale cache
#define VIEW_PRIORITY_SHELLEXT      0x00000040  // next we let the shell extension have its say
#define VIEW_PRIORITY_CACHEMISS     0x00000030  // if we have a cache miss, then we fall back to the "all folders like this" default
#define VIEW_PRIORITY_INHERIT       0x00000020  // then try to inherit the view from the previous window
#define VIEW_PRIORITY_SHELLEXT_ASBACKUP 0x0015  // If classic view state is enabled we want the shell to default to an inheritted view
#define VIEW_PRIORITY_DESPERATE     0x00000010  // just pick the last view that the window supports
#define VIEW_PRIORITY_NONE          0x00000000  // dont have a view yet

typedef struct CShellViews
{
    HDPA _dpaViews;
} CShellViews;

void CShellViews_Delete(CShellViews*);

typedef struct tagFolderSetData {
    FOLDERSETTINGS  _fs;
    SHELLVIEWID     _vidRestore;
    DWORD           _dwViewPriority; // one of the VIEW_PRIORITY_* from above
} FOLDERSETDATA, *LPFOLDERSETDATA;

typedef struct tagFolderSetDataBase {
    FOLDERSETDATA   _fld;
    CShellViews     _cViews;
    UINT            _iViewSet;
} FOLDERSETDATABASE, *LPFOLDERSETDATABASE;    
    

HRESULT FileCabinet_CreateViewWindow2(IShellBrowser* psb, FOLDERSETDATABASE* that, IShellView *psvNew,
    IShellView *psvOld, RECT *prcView, HWND *phWnd);
BOOL FileCabinet_GetDefaultViewID2(FOLDERSETDATABASE* that, SHELLVIEWID* pvid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\err.h ===
/***********************************************************************
//
// ERR.H
//
//		Copyright (c) 1992-1998 Microsoft Corp.
//		All rights reserved.
//		Microsoft Confidential
//
// Error values for file engine functions.
//
// johnhe - 03-13-92
***********************************************************************/

//**********************************************************************
//	Parsing errors
//**********************************************************************

#define	ERR_UNKNOWN					-1		// Unknown error
#define	ERR_UNKNOWN_SWITCH		-2		// Unknown criteria switch was specified
#define	ERR_NO_END_SEARCHSTR		-3		// No end search string delimiter
#define	ERR_DATE_FORMAT			-4		// Invalid date format
#define	ERR_TIME_FORMAT			-5		// Invalid time format
#define	ERR_DATE_COMBO				-6		// Invalid date combination
#define	ERR_SIZE_FORMAT			-7		// Invalid size format
#define	ERR_SIZE_COMBO				-8		// Invalid size combination
#define	ERR_ATTR_FORMAT			-9		// Invalid attribute format
#define	ERR_ATTR_COMBO				-10	// Invalid attribute combination
#define	ERR_MULT_SRCHSTR			-11	// Multiple search strings specified
#define	ERR_STRLST_LEN				-12	// Search string length is too long
#define	ERR_SRCH_EXPRESSION		-13	// Invalid search expression

#define	ERR_DUP_DESTINATION		-14	// Duplicate destination file specs
#define	ERR_SWITCH_COMBO			-15	// Invalid switch combination
#define	ERR_NO_SOURCE				-16	// No source filespec given
#define	ERR_NOT_ON_NAME			-17	// /NOT was applied to single filename

#define	ERR_FILESPEC_LEN			-18	// More than 1K of filespec strings
#define	ERR_NOT_FILE_LEN			-19	// More than 1K of !filespec strings

#define	ERR_INVALID_SRC_PATH		-20	// Invalid source path (not found)

#define	ERR_SOURCE_ISDEVICE		-21	// Source filespec is reserved device
#define	ERR_DEST_ISDEVICE			-22	// Dest. filespec is reserved device
#define	ERR_NO_DESTINATION		-23	// No destination was specified
#define	ERR_INVALID_PARAMETR		-24	// Extra parameter on cmd line

//**********************************************************************
//	System errors
//**********************************************************************

#define	ERR_NOMEMORY				-25	// Insuffient memory error
#define	ERR_MEM_CORRUPT			-26	// Error returned on MemFree()
#define	ERR_USER_ABORT				-27	// User aborted (CTRL+C)
#define	ERR_NOT_SUPPORTED			-28	// Unsupported callback request
#define	ERR_COLLATE_TABLE			-29	// Error on DOS call get collate table

//**********************************************************************
//	File or disk errors
//**********************************************************************

#define	ERR_BAD_FILESPEC			-50	// Bad file specification
#define	ERR_DIR_CREATE				-51	// Error creating a subdirectory entry
#define	ERR_FILE_READ				-52	// Error reading a file
#define	ERR_INVALID_DRIVE			-53	// Invalid drive specification
#define	ERR_INVALID_DESTINATION	-54	// Invalid destination filespec

//**********************************************************************
//	Copy errors
//**********************************************************************

#define	ERR_CPY_OVER_SELF			-75	// File cannot be copied over itself
#define	ERR_CLEAR_ARCHIVE			-76	// Error clearing file's archive bit
#define	ERR_RDONLY_DESTINATION	-77	// Destination file is readonly
#define	ERR_CYLINDRIC_COPY		-79	// Destination path is child of source

//**********************************************************************
//	Errors accessing a specified list file
//**********************************************************************

#define	ERR_FILELIST				-80	// Unknown error accessing the file list
#define	ERR_BAD_LISTFILE			-81	// File list was not found
#define	ERR_FILELIST_ACCESS		-82	// Sharing error accessing file list

//**********************************************************************
//	Resource load errors
//**********************************************************************

#define	ERR_READING_MSG			-100	// Error reading string resource
#define	ERR_MSG_LOADED				-101	// Strings have already been loaded

//**********************************************************************
//	Misc error values
//**********************************************************************

#define	ERR_DO_HELP					ERR_NO_SOURCE	// Display help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\fsmenu.cpp ===
//---------------------------------------------------------------------------
// Helper routines for an owner draw menu showing the contents of a directory.
//---------------------------------------------------------------------------

// FEATURE (scotth): note this file is #included by SHELL32 and SHDOC401.
//                  We really want the bits in one place, but right now
//                  SHDOC401 needs some changes which SHELL32 on win95
//                  does not provide.
//
//                  The second best solution is to place this code in
//                  a static lib (stocklib).  However, shell32's default
//                  data segment is still shared, and since this file
//                  contains some globals, we'd have problems with that.
//                  If shell32 is fixed, we can add this file to stocklib.
//
//                  Our third best solution is to #include this file.
//                  That's better than maintaining two different source
//                  codes.
//

#include <limits.h>

#ifdef IN_SHDOCVW
extern "C" LPITEMIDLIST IEILCreate(UINT cbSize);
#define _ILCreate   IEILCreate
#endif
STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone

#define CXIMAGEGAP      6
// #define SRCSTENCIL           0x00B8074AL


typedef enum
{
    FMII_DEFAULT =      0x0000,
    FMII_BREAK =        0x0001
} FMIIFLAGS;


#define FMI_NULL            0x00000000
#define FMI_MARKER          0x00000001
#define FMI_FOLDER          0x00000002
#define FMI_EXPAND          0x00000004
#define FMI_EMPTY           0x00000008
#define FMI_SEPARATOR       0x00000010
#define FMI_DISABLED        0x00000020     // Enablingly Challenged ???
#define FMI_ON_MENU         0x00000040
#define FMI_IGNORE_PIDL     0x00000080     // Ignore the pidl as the display string
#define FMI_FILESYSTEM      0x00000100
#define FMI_MARGIN          0x00000200
#define FMI_MAXTIPWIDTH     0x00000400
#define FMI_TABSTOP         0x00000800
#define FMI_DRAWFLAGS       0x00001000
#define FMI_ALTITEM         0x00002000     // Item came from alternate pidl
#define FMI_CXMAX           0x00004000
#define FMI_CYMAX           0x00008000
#define FMI_CYSPACING       0x00010000
#define FMI_ASKEDFORTOOLTIP 0x00020000
#define FMI_USESTRING       0x00040000     // Use psz before pidl as display string


// One of these per file menu.
typedef struct
{
    IShellFolder *  psf;                // Shell Folder.
    IStream *       pstm;               // Optional stream
    HMENU           hmenu;              // Menu.
    LPITEMIDLIST    pidlFolder;         // Pidl for the folder.
    HDPA            hdpa;               // List of items (see below).
    UINT            idCmd;              // Command.
    DWORD           fmf;                // Header flags.
    UINT            fFSFilter;          // file system enum filter
    HBITMAP         hbmp;               // Background bitmap.
    UINT            cxBmp;              // Width of bitmap.
    UINT            cyBmp;              // Height of bitmap.
    UINT            cxBmpGap;           // Gap for bitmap.
    UINT            yBmp;               // Cached Y coord.
    COLORREF        clrBkg;             // Background color.
    UINT            cySel;              // Prefered height of selection.
    PFNFMCALLBACK   pfncb;              // Callback function.
    LPARAM          lParam;             // Parameter passed for callback handler
    IShellFolder *  psfAlt;             // Alternate Shell Folder.
    LPITEMIDLIST    pidlAltFolder;      // Pidl for the alternate folder.
    HDPA            hdpaAlt;            // Alternate dpa
    int             cyMenuSizeSinceLastBreak;  // Size of menu (cy)
    UINT            cyMax;              // Max allowable height of entire menu in pixels
    UINT            cxMax;              // Max allowable width in pixels
    UINT            cySpacing;          // Spacing b/t menu items in pixels
    LPTSTR          pszFilterTypes;     // Multi-string list of extensions (e.g., "doc\0xls\0")
} FILEMENUHEADER, *PFILEMENUHEADER;


// One of these for each file menu item.
//
//  !!! Note: the testers have a test utility which grabs
//      the first 7 fields of this structure.  If you change
//      the order or meaning of these fields, make sure they
//      are notified so they can update their automated tests.
//
typedef struct
{
    PFILEMENUHEADER pfmh;               // The header.
    int             iImage;             // Image index to use.
    DWORD           Flags;              // Misc flags above.
    LPITEMIDLIST    pidl;               // IDlist for item.
    LPTSTR          psz;                // Text when not using pidls.
    UINT            cyItem;             // Custom height.
    LPTSTR          pszTooltip;         // Item tooltip.
    RECT            rcMargin;           // Margin around tooltip
    DWORD           dwMaxTipWidth;      // Maximum tooltip width
    DWORD           dwTabstop;
    UINT            uDrawFlags;
    LPARAM          lParam;             // Application data
    int             nOrder;             // Ordinal indicating user preference
    DWORD           dwEffect;           // Acceptable drop effects
} FILEMENUITEM, *PFILEMENUITEM;


#define X_TIPOFFSET         130      // an arbitrary number of pixels

class CFSMenuAgent
{
private:
    DWORD   _dwState;           // MAS_*
    HHOOK   _hhookMsg;

    PFILEMENUITEM _pfmiCur;     // Current item selected
    PFILEMENUITEM _pfmiDrag;    // Item being dragged
    PFILEMENUITEM _pfmiDrop;    // Target of drop

    DWORD   _dwStateSav;        // Saved state once menu goes away

    HWND    _hwndMenu;       
    HDC     _hdc;
    RECT    _rcCur;          // rect of current selection
    RECT    _rcCurScr;       // rect of current selection in screen coords
    RECT    _rcMenu;         // rect of whole menu in screen coords
    int     _yCenter;        // center of item (in screen coords)

    HCURSOR _hcurSav;
    HBRUSH  _hbr;

public:
    CFSMenuAgent(void);

    void    Init(void);
    void    Reset(void);
    void    EndMenu(void);

    void    UpdateInsertionCaret(void);

    void    SetEditMode(BOOL bEdit, DWORD dwEffect);
    void    SetCaretPos(LPPOINT ppt);
    HCURSOR SetCursor(DWORD dwEffect);
    void    SetCurrentRect(HDC hdc, LPRECT prcItem);

    void    SetItem(PFILEMENUITEM pfmi) { _pfmiCur = pfmi; }
    void    SetDragItem(void) { _pfmiDrag = _pfmiCur; }
    void    SetDropItem(void);

    DWORD   GetDragEffect(void);

    BOOL    ProcessCommand(HWND hwnd, HMENU hmenuBar, UINT idMenu, HMENU hmenu, UINT idCmd);

    friend  LRESULT CALLBACK CFSMenuAgent_MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    friend  LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi);
};


// Menu agent state
#define MAS_EDITMODE            0x00000001
#define MAS_LBUTTONDOWN         0x00000002
#define MAS_LBUTTONUP           0x00000004
#define MAS_INSERTABOVE         0x00000008

// Edit mode states

#define MenuDD_IsButtonDown()   (g_fsmenuagent._dwState & MAS_LBUTTONDOWN)
#define MenuDD_InEditMode()     (g_fsmenuagent._dwState & MAS_EDITMODE)
#define MenuDD_InsertAbove()    (g_fsmenuagent._dwState & MAS_INSERTABOVE)
#define MenuDD_GetBrush()       (g_fsmenuagent._hbr)


//---------------------------------------------------------------------------

CFSMenuAgent g_fsmenuagent;

PFILEMENUITEM g_pfmiLastSel = NULL;
PFILEMENUITEM g_pfmiLastSelNonFolder = NULL;
// This saves us creating DC's all the time for the blits.
HDC g_hdcMem = NULL;
HFONT g_hfont = NULL;
BOOL g_fAbortInitMenu = FALSE;
// Tooltip stuff.
HWND g_hwndTip = NULL;
RECT g_rcItem = {0, 0, 0, 0};
HIMAGELIST g_himlIconsSmall = NULL;
HIMAGELIST g_himlIcons = NULL;


//---------------------------------------------------------------------------
// Validation functions


// IEUNIX -- these functions don't appear to be defined anywhere else, as the
// other def'n would imply
#if defined(DEBUG) || defined(UNIX)

BOOL IsValidPFILEMENUHEADER(PFILEMENUHEADER pfmh)
{
    return (IS_VALID_WRITE_PTR(pfmh, FILEMENUHEADER) &&
            ((NULL == pfmh->psf && 
              NULL == pfmh->pidlFolder) || 
             (IS_VALID_CODE_PTR(pfmh->psf, IShellFolder) && 
              IS_VALID_PIDL(pfmh->pidlFolder))) &&
            IS_VALID_HANDLE(pfmh->hmenu, MENU) &&
            IS_VALID_HANDLE(pfmh->hdpa, DPA) &&
            ((NULL == pfmh->psfAlt && 
              NULL == pfmh->pidlAltFolder) || 
             (IS_VALID_CODE_PTR(pfmh->psfAlt, IShellFolder) &&
              IS_VALID_PIDL(pfmh->pidlAltFolder))) &&
            (NULL == pfmh->hdpaAlt || IS_VALID_HANDLE(pfmh->hdpaAlt, DPA)) &&
            (NULL == pfmh->pszFilterTypes || IS_VALID_STRING_PTR(pfmh->pszFilterTypes, -1)));
}    

BOOL IsValidPFILEMENUITEM(PFILEMENUITEM pfmi)
{
    return (IS_VALID_WRITE_PTR(pfmi, FILEMENUITEM) &&
            IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER) &&
            (NULL == pfmi->pidl || IS_VALID_PIDL(pfmi->pidl)) &&
            (NULL == pfmi->psz || IS_VALID_STRING_PTR(pfmi->psz, -1)) &&
            (NULL == pfmi->pszTooltip || IS_VALID_STRING_PTR(pfmi->pszTooltip, -1)));
}    
#else

BOOL IsValidPFILEMENUHEADER(PFILEMENUHEADER pfmh);
BOOL IsValidPFILEMENUITEM(PFILEMENUITEM pfmi);

#endif


//---------------------------------------------------------------------------
// Helper functions


void FileList_Reorder(PFILEMENUHEADER pfmh);
BOOL FileMenuHeader_InsertItem(PFILEMENUHEADER pfmh, UINT iItem, FMIIFLAGS fFlags);
BOOL FileMenuItem_Destroy(PFILEMENUITEM pfmi);
BOOL FileMenuItem_Move(HWND hwnd, PFILEMENUITEM pfmiFrom, PFILEMENUHEADER pfmhTo, int iPosTo);
BOOL Tooltip_Create(HWND *phwndTip);


__inline static BOOL LAlloc(UINT cb, PVOID *ppv)
{
    ASSERT(ppv);

    *ppv = (PVOID*)LocalAlloc(LPTR, cb);
    return *ppv ? TRUE : FALSE;
}

__inline static BOOL LFree(PVOID pv)
{
    return LocalFree(pv) ? FALSE : TRUE;
}


/*----------------------------------------------------------
Purpose: Allocate a multi-string (double-null terminated)

Returns:
Cond:    --
*/
BOOL
MultiSz_AllocCopy(
    IN  LPCTSTR  pszSrc,
    OUT LPTSTR * ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;
    UINT cchMac = 0;
    LPCTSTR psz;
    LPTSTR pszDst;

    ASSERT(pszSrc && ppszDst);

    psz = pszSrc;
    while (*psz)
    {
        cch = lstrlen(psz) + 1;
        cchMac += cch;
        psz += cch;
    }
    cchMac++;       // extra null

    if (LAlloc(CbFromCch(cchMac), (PVOID *)ppszDst))
    {
        psz = pszSrc;
        pszDst = *ppszDst;
        while (*psz)
        {
            lstrcpy(pszDst, psz);
            cch = lstrlen(psz) + 1;
            psz += cch;
            pszDst += cch;
        }
        fRet = TRUE;
    }

    return fRet;
}


/*----------------------------------------------------------
Purpose: Allocate a string

Returns:
Cond:    --
*/
BOOL
Sz_AllocCopyA(
    IN  LPCSTR  pszSrc,
    OUT LPTSTR *ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;

    ASSERT(pszSrc && ppszDst);

    // NB We allocate an extra char in case we need to add an '&'.
    cch = lstrlenA(pszSrc) + 2;
    if (LAlloc(CbFromCchA(cch), (PVOID *)ppszDst))
    {
#ifdef UNICODE
        MultiByteToWideChar(CP_ACP, 0, pszSrc, -1, *ppszDst, cch);
#else
        lstrcpy(*ppszDst, pszSrc);
#endif
        fRet = TRUE;
    }

    return fRet;
}


/*----------------------------------------------------------
Purpose: Allocate a string

Returns:
Cond:    --
*/
BOOL
Sz_AllocCopyW(
    IN  LPCWSTR pszSrc,
    OUT LPTSTR *ppszDst)
{
    BOOL fRet = FALSE;
    UINT cch;

    ASSERT(pszSrc && ppszDst);

    // NB We allocate an extra char in case we need to add an '&'.
    cch = lstrlenW(pszSrc) + 2;
    if (LAlloc(CbFromCchW(cch), (PVOID *)ppszDst))
    {
#ifdef UNICODE
        lstrcpy(*ppszDst, pszSrc);
#else
        WideCharToMultiByte(CP_ACP, 0, pszSrc, -1, *ppszDst, CbFromCchW(cch), NULL, NULL);
#endif
        fRet = TRUE;
    }

    return fRet;
}

#ifdef UNICODE
#define Sz_AllocCopy    Sz_AllocCopyW
#else
#define Sz_AllocCopy    Sz_AllocCopyA
#endif


HCURSOR LoadMenuCursor(UINT idCur)
{
#ifdef IN_SHDOCVW
    return LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(idCur));
#else
    HINSTANCE hinst = GetModuleHandle(TEXT("shdocvw.dll"));

    if (hinst)
        return LoadCursor(hinst, MAKEINTRESOURCE(idCur));

    return LoadCursor(NULL, IDC_ARROW);
#endif
}    


//---------------------------------------------------------------------------
//---------------------------------------------------------------------------


#ifdef DEBUG
static void DumpMsg(MSG * pmsg)
{
    ASSERT(pmsg);

    switch (pmsg->message)
    {
    case WM_LBUTTONDOWN:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_LBUTTONDOWN hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, GET_X_LPARAM(pmsg->lParam), GET_Y_LPARAM(pmsg->lParam));
        break;

    case WM_LBUTTONUP:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_LBUTTONUP   hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              keys = %#04lx  x = %d  y = %d",
                 pmsg->wParam, GET_X_LPARAM(pmsg->lParam), GET_Y_LPARAM(pmsg->lParam));
        break;

    case WM_MOUSEMOVE:
        break;

    case WM_TIMER:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_TIMER       hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              id = %#08lx",
                 pmsg->wParam);
        break;

    case WM_MENUSELECT:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = WM_MENUSELECT  hwnd = %#08lx  x = %d  y = %d",
                 pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        TraceMsg(TF_ALWAYS, "                              uItem = %#04lx  flags = %#04lx  hmenu = %#08lx",
                 GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam),
                 GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam));
        break;

    default:
        TraceMsg(TF_ALWAYS, "MsgHook: msg = %#04lx        hwnd = %#04lx  x = %d  y = %d",
                 pmsg->message, pmsg->hwnd, pmsg->pt.x, pmsg->pt.y);
        break;
    }
}    
#endif


/*----------------------------------------------------------
Purpose: Message hook used to track drag and drop within the menu.

*/
LRESULT CALLBACK CFSMenuAgent_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
#ifdef DEBUG
        if (IsFlagSet(g_dwDumpFlags, DF_HOOK))
            DumpMsg(pmsg);
#endif

        switch (pmsg->message)
        {
        case WM_LBUTTONUP:
            // We record the mouse up IFF it happened in the menu
            // and we had previously recorded the mouse down.
            if (IsFlagSet(g_fsmenuagent._dwState, MAS_EDITMODE | MAS_LBUTTONDOWN))
            {
                POINT pt;
                
                TraceMsg(TF_MENU, "MenuDD: getting mouse up");
                
                pt.x = GET_X_LPARAM(pmsg->lParam);
                pt.y = GET_Y_LPARAM(pmsg->lParam);

                if (PtInRect(&g_fsmenuagent._rcMenu, pt))
                {
                    SetFlag(g_fsmenuagent._dwState, MAS_LBUTTONUP);
                    g_fsmenuagent.EndMenu();
                }
            }
            ClearFlag(g_fsmenuagent._dwState, MAS_LBUTTONDOWN);
            break;

        case WM_LBUTTONDOWN:
            if (g_fsmenuagent._pfmiCur && 
                (g_fsmenuagent._pfmiCur->dwEffect & DROPEFFECT_MOVE))
            {
                TraceMsg(TF_MENU, "MenuDD: getting mouse down");
                
                SetFlag(g_fsmenuagent._dwState, MAS_LBUTTONDOWN);
                g_fsmenuagent.SetDragItem();
            }
            break;

        case WM_MOUSEMOVE:
            if (g_fsmenuagent._dwState & MAS_EDITMODE)
            {
                POINT pt;
                BOOL bInMenu;

                pt.x = GET_X_LPARAM(pmsg->lParam);
                pt.y = GET_Y_LPARAM(pmsg->lParam);

                g_fsmenuagent.SetCaretPos(&pt);

                bInMenu = PtInRect(&g_fsmenuagent._rcMenu, pt);
#if 0
                TraceMsg(TF_MENU, "MenuDD: %s (%d,%d) in [%d,%d,%d,%d]", 
                         bInMenu ? TEXT("in menu") : TEXT("not in menu"),
                         pt.x, pt.y, g_fsmenuagent._rcMenu.left, g_fsmenuagent._rcMenu.top,
                         g_fsmenuagent._rcMenu.right, g_fsmenuagent._rcMenu.bottom);
#endif

                // Determine which cursor to show
                if ( !bInMenu )
                    g_fsmenuagent.SetItem(NULL);

                g_fsmenuagent.SetCursor(g_fsmenuagent.GetDragEffect());
            }
            break;

        case WM_MENUSELECT:
            BLOCK
            {
                UINT uItem = GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam);
                HMENU hmenu = GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam);

                // Is the menu going away?
                if (0 == uItem && NULL == hmenu)
                {
                    // Yes; release menu drag/drop
                    TraceMsg(TF_MENU, "MenuDD: menu being cancelled");

                    // Since we're in the middle of the hook chain, call
                    // the next hook first, then remove ourselves
                    lRet = CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);

                    // Was an item dropped?
                    if (g_fsmenuagent._dwState & MAS_LBUTTONUP)
                    {
                        // Yes; remember it
                        g_fsmenuagent.SetDropItem();
                    }
                    g_fsmenuagent.Reset();
                    return lRet;
                }
            }
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_fsmenuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    


CFSMenuAgent::CFSMenuAgent(void)
{
    // This object is global, and not allocated.  We must explicitly
    // initialize the variables.

    _dwState = 0;
    _hhookMsg = 0;
    _dwStateSav = 0;

    _pfmiCur = NULL;
    _pfmiDrag = NULL;
    _pfmiDrop = NULL;

    _hwndMenu = NULL;
    _hdc = NULL;
    _hcurSav = NULL;
    _hbr = NULL;
}    


/*----------------------------------------------------------
Purpose: Initialize the menu drag/drop structure.  This must
         anticipate being called when it is already initialized.
         Also, this will get called whenever a cascaded menu 
         is opened.  Be sure to maintain state across these
         junctures.

*/
void CFSMenuAgent::Init(void)
{
    TraceMsg(TF_MENU, "Initialize menu drag/drop");

    // Do not init _pfmiDrag, since this function is called for every
    // cascaded menu, and _pfmiDrag must be remembered across these
    // menus.

    _pfmiDrop = NULL;
    _dwStateSav = 0;

    if (NULL == _hhookMsg)
    {
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, CFSMenuAgent_MsgHook, HINST_THISDLL, 0);
    }

    if (NULL == _hbr)
    {
        // Don't need to release this
        _hbr = GetSysColorBrush(COLOR_3DFACE);
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CFSMenuAgent::EndMenu(void)
{
    ASSERT(IsWindow(_hwndMenu));

    SendMessage(_hwndMenu, WM_CANCELMODE, 0, 0);
}    


/*----------------------------------------------------------
Purpose: Decides whether to position the caret above or below the
         menu item, based upon the given point (cursor position).

*/
void CFSMenuAgent::SetCaretPos(LPPOINT ppt)
{
    ASSERT(ppt);

    if (ppt->y < _yCenter)
    {
        // Change the caret position?
        if (IsFlagClear(_dwState, MAS_INSERTABOVE))
        {
            // Yes
            SetFlag(_dwState, MAS_INSERTABOVE);
            UpdateInsertionCaret();
        }
    }
    else
    {
        // Change the caret position?
        if (IsFlagSet(_dwState, MAS_INSERTABOVE))
        {
            // Yes
            ClearFlag(_dwState, MAS_INSERTABOVE);
            UpdateInsertionCaret();
        }
    }
}    


void CFSMenuAgent::UpdateInsertionCaret(void)
{
    if (_dwState & MAS_EDITMODE)    
    {
        InvalidateRect(_hwndMenu, &_rcCur, FALSE);
        UpdateWindow(_hwndMenu);
    }
}    


void CFSMenuAgent::SetDropItem(void) 
{ 
    // Only set the drop item if the drop effect is supported.
    ASSERT(_pfmiDrag);

    if (_pfmiCur && (_pfmiCur->dwEffect & _pfmiDrag->dwEffect))
        _pfmiDrop = _pfmiCur; 
    else
        _pfmiDrop = NULL;
}


/*----------------------------------------------------------
Purpose: Set the cursor based on the given flags

*/
HCURSOR CFSMenuAgent::SetCursor(DWORD dwEffect)
{
    HCURSOR hcur = NULL;

    ASSERT(_dwState & MAS_EDITMODE);

    // Does this item support the requested drop effect?
    if (_pfmiCur && (dwEffect & _pfmiCur->dwEffect))
    {
        // Yes
        UINT idCur;

        if (dwEffect & DROPEFFECT_MOVE)
            idCur = IDC_MENUMOVE;
        else if (dwEffect & DROPEFFECT_COPY)
            idCur = IDC_MENUCOPY;
        else
        {
            ASSERT_MSG(0, "Unknown drop effect!");
            idCur = IDC_MENUDENY;
        }

        hcur = ::SetCursor(LoadMenuCursor(idCur));
    }
    else
    {
        // No
        hcur = ::SetCursor(LoadMenuCursor(IDC_MENUDENY));
    }

    return hcur;
}    


DWORD CFSMenuAgent::GetDragEffect(void)
{
    if (_pfmiDrag)
        return _pfmiDrag->dwEffect;
    else
        return DROPEFFECT_NONE;
}    


void CFSMenuAgent::SetEditMode(BOOL bEdit, DWORD dwEffect)
{
    // Only update if the state has changed
    if (bEdit && IsFlagClear(_dwState, MAS_EDITMODE))
    {
        TraceMsg(TF_MENU, "MenuDD: entering edit mode");

        SetFlag(_dwState, MAS_EDITMODE);

        _hcurSav = SetCursor(dwEffect);
    }
    else if (!bEdit && IsFlagSet(_dwState, MAS_EDITMODE))
    {
        TraceMsg(TF_MENU, "MenuDD: leaving edit mode");

        ClearFlag(_dwState, MAS_EDITMODE);

        ASSERT(_hcurSav);

        if (_hcurSav)
        {
            ::SetCursor(_hcurSav);
            _hcurSav = NULL;
        }
    }
}    


void CFSMenuAgent::SetCurrentRect(HDC hdc, LPRECT prcItem)
{
    HWND hwnd = WindowFromDC(hdc);

    ASSERT(hdc);
    ASSERT(prcItem);

    _hwndMenu = hwnd;
    _hdc = hdc;
    _rcCur = *prcItem;
    _rcCurScr = *prcItem;
    GetWindowRect(hwnd, &_rcMenu);

    MapWindowPoints(hwnd, NULL, (LPPOINT)&_rcCurScr, 2);

    _yCenter = _rcCurScr.top + (_rcCurScr.bottom - _rcCurScr.top) / 2;
}


/*----------------------------------------------------------
Purpose: Reset the menu agent.  This is called when the menu goes
         away.  The ProcessCommand method still needs some state
         information so it knows what action had taken place.
         This info is moved to a post-action field.

*/
void CFSMenuAgent::Reset(void)
{
    TraceMsg(TF_MENU, "MenuDD: releasing edit mode resources");

    // Remember the state for FileMenu_ProcessCommand
    _dwStateSav = _dwState;

    SetEditMode(FALSE, DROPEFFECT_NONE);

    TraceMsg(TF_MENU, "MenuDD: Hook removed for menu drag/drop");

    if (_hhookMsg)
    {
        UnhookWindowsHookEx(_hhookMsg);
        _hhookMsg = NULL;
    }

    // Reset
    _pfmiCur = NULL;
    _hwndMenu = NULL;
    _hdc = NULL;
    _dwState = 0;
    _hbr = NULL;

    ASSERT(NULL == _hcurSav);
}    


/*----------------------------------------------------------
Purpose: Have a whack at the WM_COMMAND, in case it is the result
         of drag and drop within the menu.

Returns: TRUE if this function handled the command
*/
BOOL CFSMenuAgent::ProcessCommand(HWND hwnd, HMENU hmenuBar, UINT idMenu, HMENU hmenu, UINT idCmd)
{
    BOOL bRet = FALSE;

    if (hmenu && _pfmiDrag && (_dwStateSav & MAS_EDITMODE))
    {
        ASSERT(IS_VALID_STRUCT_PTR(_pfmiDrag, FILEMENUITEM));

        // Did the user move an item within the menu?
        if (_pfmiDrop)
        {
            // Yes
            ASSERT(IS_VALID_STRUCT_PTR(_pfmiDrop, FILEMENUITEM));

            int iPosTo = DPA_GetPtrIndex(_pfmiDrop->pfmh->hdpa, _pfmiDrop);

            if (IsFlagClear(_dwStateSav, MAS_INSERTABOVE))
                iPosTo++;

            IEPlaySound(TEXT("MoveMenuItem"), FALSE);

            bRet = FileMenuItem_Move(hwnd, _pfmiDrag, _pfmiDrop->pfmh, iPosTo);

            // Re-order the items
            FileList_Reorder(_pfmiDrop->pfmh);
        }

        _pfmiDrag = NULL;
        _pfmiDrop = NULL;

#if 0
        // Did we successfully handle this?
        if (bRet)
        {
            // Yes; bring the menu back up so the user can continue
            // editting.
            HiliteMenuItem(hwnd, hmenuBar, idMenu, MF_BYCOMMAND | MF_HILITE);
            DrawMenuBar(hwnd);
            
            TrackPopupMenu(hmenu, TPM_LEFTALIGN, _rcMenu.left,
                           _rcMenu.top, 0, hwnd, NULL);

            HiliteMenuItem(hwnd, hmenuBar, idMenu, MF_BYCOMMAND | MF_UNHILITE);
            DrawMenuBar(hwnd);
        }
#endif
        
        // Always return true because we handled it
        bRet = TRUE;        
    }

    return bRet;
}



//---------------------------------------------------------------------------
//---------------------------------------------------------------------------



//---------------------------------------------------------------------------
void DeleteGlobalMemDCAndFont(void)
{
    if (g_hdcMem)
    {
        DeleteDC(g_hdcMem);
        g_hdcMem = NULL;
    }
    if (g_hfont)
    {
        DeleteObject(g_hfont);
        g_hfont = NULL;
    }
}




DWORD
GetItemTextExtent(
    IN HDC     hdc,
    IN LPCTSTR lpsz)
{
    SIZE sz;

    GetTextExtentPoint(hdc, lpsz, lstrlen(lpsz), &sz);
    // NB This is OK as long as an item's extend doesn't get very big.
    return MAKELONG((WORD)sz.cx, (WORD)sz.cy);
}


/*----------------------------------------------------------
Purpose: Validates pfmitem.  This also initializes pfmitemOut 
         given the mask and flags set in pfmitem.  This helper 
         function is useful for APIs to "cleanse" incoming 
         FMITEM structures.

Returns: TRUE if pfmitem is a valid structure
Cond:    --
*/
BOOL
IsValidFMItem(
    IN  FMITEM const * pfmitem,
    OUT PFMITEM        pfmitemOut)
{
    BOOL bRet = FALSE;

    ASSERT(pfmitem);
    ASSERT(pfmitemOut);

    if (IS_VALID_READ_PTR(pfmitem, FMITEM) &&
        SIZEOF(*pfmitem) == pfmitem->cbSize)
    {   
        ZeroInit(pfmitemOut, SIZEOF(*pfmitemOut));

        pfmitemOut->cbSize = SIZEOF(*pfmitemOut);
        pfmitemOut->dwMask = pfmitem->dwMask;

        if (pfmitemOut->dwMask & FMI_TYPE)
            pfmitemOut->dwType = pfmitem->dwType;

        if (pfmitemOut->dwMask & FMI_ID)
            pfmitemOut->uID = pfmitem->uID;

        if (pfmitemOut->dwMask & FMI_ITEM)
            pfmitemOut->uItem = pfmitem->uItem;

        if (pfmitemOut->dwMask & FMI_IMAGE)
            pfmitemOut->iImage = pfmitem->iImage;
        else
            pfmitemOut->iImage = -1;

        if (pfmitemOut->dwMask & FMI_DATA)
            pfmitemOut->pvData = pfmitem->pvData;

        if (pfmitemOut->dwMask & FMI_HMENU)
            pfmitemOut->hmenuSub = pfmitem->hmenuSub;

        if (pfmitemOut->dwMask & FMI_METRICS)
            pfmitemOut->cyItem = pfmitem->cyItem;

        if (pfmitemOut->dwMask & FMI_LPARAM)
            pfmitemOut->lParam = pfmitem->lParam;

        // The FMIT_STRING and FMIT_SEPARATOR are exclusive
        if (IsFlagSet(pfmitemOut->dwType, FMIT_STRING) &&
            IsFlagSet(pfmitemOut->dwType, FMIT_SEPARATOR))
        {
            bRet = FALSE;
        }
        else
            bRet = TRUE;
    }
    return bRet;
}


void
FileMenuItem_GetDisplayName(
    IN PFILEMENUITEM pfmi,
    IN LPTSTR        pszName,
    IN UINT          cchName)
{
    STRRET str;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, TCHAR, cchName));

    // Is this a special empty item?
    if (pfmi->Flags & FMI_EMPTY)
    {
        // Yep, load the string from a resource.
        LoadString(HINST_THISDLL, IDS_NONE, pszName, cchName);
    }
    else
    {
        // Nope, ask the folder for the name of the item.
        PFILEMENUHEADER pfmh = pfmi->pfmh;
        LPSHELLFOLDER psfTemp;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        if (pfmi->Flags & FMI_ALTITEM) {
            psfTemp = pfmh->psfAlt;
        } else {
            psfTemp = pfmh->psf;
        }

        // If it's got a pidl use that, else just use the normal menu string.
        if (psfTemp && pfmi->pidl && 
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            if (SUCCEEDED(psfTemp->GetDisplayNameOf(pfmi->pidl, SHGDN_NORMAL, &str)))
            {
                StrRetToBuf(&str, pfmi->pidl, pszName, cchName);
            }
            else
            {
                *pszName = TEXT('\0');
            }
        }
        else if (pfmi->psz)
        {
            lstrcpyn(pszName, pfmi->psz, cchName);
        }
        else
        {
            *pszName = TEXT('\0');
        }
    }
}

#define FileMenuHeader_AllowAbort(pfmh) (!(pfmh->fmf & FMF_NOABORT))


/*----------------------------------------------------------
Purpose: Create a menu item structure to be stored in the hdpa

Returns: TRUE on success
Cond:    --
*/
BOOL
FileMenuItem_Create(
    IN  PFILEMENUHEADER pfmh,
    IN  LPCITEMIDLIST   pidl,       OPTIONAL
    IN  int             iImage,
    IN  DWORD           dwFlags,    // FMI_*
    OUT PFILEMENUITEM * ppfmi)
{
    PFILEMENUITEM pfmi = (PFILEMENUITEM)LocalAlloc(LPTR, SIZEOF(FILEMENUITEM));

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(ppfmi);
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (pfmi)
    {
        DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM;
        IShellFolder * psfTemp;
        BOOL bUseAlt = IsFlagSet(dwFlags, FMI_ALTITEM);

        pfmi->pfmh = pfmh;
        pfmi->pidl = (LPITEMIDLIST)pidl;
        pfmi->iImage = iImage;
        pfmi->Flags = dwFlags;
        pfmi->nOrder = INT_MAX;     // New items go to the bottom

        if (bUseAlt)
            psfTemp = pfmh->psfAlt;
        else 
            psfTemp = pfmh->psf;

        if (pidl &&
            SUCCEEDED(psfTemp->GetAttributesOf(1, &pidl, &dwAttribs)))
        {
            if (dwAttribs & SFGAO_FOLDER)
                pfmi->Flags |= FMI_FOLDER;

            if (dwAttribs & SFGAO_FILESYSTEM)
                pfmi->Flags |= FMI_FILESYSTEM;
        }
    }

    *ppfmi = pfmi;

    return (NULL != pfmi);
}


/*----------------------------------------------------------
Purpose: Move an item within the same menu or across menus

*/
BOOL FileMenuItem_Move(
    HWND            hwnd,
    PFILEMENUITEM   pfmiFrom, 
    PFILEMENUHEADER pfmhTo, 
    int             iPosTo)
{
    BOOL bRet = FALSE;
    TCHAR szFrom[MAX_PATH + 1];     // +1 for double null

    ASSERT(IS_VALID_STRUCT_PTR(pfmiFrom, FILEMENUITEM));
    ASSERT(IS_VALID_STRUCT_PTR(pfmhTo, FILEMENUHEADER));

    PFILEMENUHEADER pfmhFrom = pfmiFrom->pfmh;
    HDPA hdpaFrom = pfmhFrom->hdpa;
    HDPA hdpaTo = pfmhTo->hdpa;
    BOOL bSameMenu = (pfmhFrom == pfmhTo);

    ASSERT(IsFlagSet(pfmhFrom->fmf, FMF_CANORDER));

    // Is this item being moved within the same menu?
    if (bSameMenu)
    {
        // Yes; simply change the order of the menu below
        bRet = TRUE;
    }
    else
    {
        // No; need to move the actual file to the menu's associated
        // folder.  Also note the placement of the item in the menu.
        TCHAR szTo[MAX_PATH + 1];       // +1 for double null
        IShellFolder * psf = pfmhFrom->psf;
        STRRET str;

        SHGetPathFromIDList(pfmhTo->pidlFolder, szTo);
        szTo[lstrlen(szTo) + 1] = 0;   // double null

        if (SUCCEEDED(psf->GetDisplayNameOf(pfmiFrom->pidl, SHGDN_FORPARSING, &str)))
        {
            StrRetToBuf(&str, pfmiFrom->pidl, szFrom, SIZECHARS(szFrom));
            szFrom[lstrlen(szFrom) + 1] = 0;   // double null

            // WARNING: if you change this code to perform rename on
            // collision, be sure to update the pfmiFrom contents to
            // reflect that name change!

            SHFILEOPSTRUCT shop = {hwnd, FO_MOVE, szFrom, szTo, 0, };
            bRet = (NO_ERROR == SHFileOperation(&shop));

            if (bRet)
            {
                // Flush the notification so the menu is updated immediately.
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH | SHCNF_FLUSH, szFrom, NULL);
            }

            // The move operation will send a notification to the 
            // window, which will eventually invalidate this menu 
            // to have it rebuilt.  However, before that happens
            // we want to record the position of this dragged item
            // in the destination menu.  So change the order of 
            // the menu anyway.
        }
    }

    if (bRet)
    {
        // Change the order of the menu
        int iPosFrom = DPA_GetPtrIndex(hdpaFrom, pfmiFrom);

        bRet = FALSE;

        // Account for the fact we delete before we insert within the
        // same menu
        if (bSameMenu && iPosTo > iPosFrom)
            iPosTo--;

        DPA_DeletePtr(hdpaFrom, iPosFrom);
        iPosTo = DPA_InsertPtr(hdpaTo, iPosTo, pfmiFrom);
        if (-1 != iPosTo)
        {
            // Update the header of the item
            pfmiFrom->pfmh = pfmhTo;

            // Move the menu items
            MENUITEMINFO mii;

            mii.cbSize = SIZEOF(mii);
            mii.fMask = MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
            
            if (GetMenuItemInfo(pfmhFrom->hmenu, iPosFrom, TRUE, &mii))
            {
                // Remove a submenu first so it doesn't get nuked
                if (GetSubMenu(pfmhFrom->hmenu, iPosFrom))
                    RemoveMenu(pfmhFrom->hmenu, iPosFrom, MF_BYPOSITION);

                DeleteMenu(pfmhFrom->hmenu, iPosFrom, MF_BYPOSITION);
                if ( !InsertMenuItem(pfmhTo->hmenu, iPosTo, TRUE, &mii) )
                {
                    TraceMsg(TF_ERROR, "Failed to move menu item");
                    DPA_DeletePtr(hdpaTo, iPosTo);
                }
                else
                {
                    SetFlag(pfmhFrom->fmf, FMF_DIRTY);
                    SetFlag(pfmhTo->fmf, FMF_DIRTY);
                    bRet = TRUE;
                }
            }
        }
        else
        {
            // Punt
            TraceMsg(TF_ERROR, "Menu: could not insert moved item in the DPA");
        }
    }
    return bRet;
}    


/*----------------------------------------------------------
Purpose: Enumerates the folder and adds the files to the DPA.

Returns: count of items in the list
*/
int
FileList_Build(
    IN PFILEMENUHEADER pfmh,
    IN int             cItems,
    IN BOOL            bUseAlt)
    {
    HDPA hdpaTemp;
    HRESULT hres;
    LPITEMIDLIST pidlSkip = NULL;
    LPITEMIDLIST pidlProgs = NULL;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
        return -1;

    if (bUseAlt) {
        hdpaTemp = pfmh->hdpaAlt;
    } else {
        hdpaTemp = pfmh->hdpa;
    }


    if (hdpaTemp && pfmh->psf)
    {
        LPENUMIDLIST penum;
        LPSHELLFOLDER psfTemp;

        // Take care with Programs folder.
        // If this is the parent of the programs folder set pidlSkip to
        // the last bit of the programs pidl.
        if (pfmh->fmf & FMF_NOPROGRAMS)
            {
            pidlProgs = SHCloneSpecialIDList(NULL,
                                            (bUseAlt ? CSIDL_COMMON_PROGRAMS : CSIDL_PROGRAMS),
                                             TRUE);

            if (ILIsParent((bUseAlt ? pfmh->pidlAltFolder : pfmh->pidlFolder),
                           pidlProgs, TRUE))
                {
                TraceMsg(TF_MENU, "FileList_Build: Programs parent.");
                pidlSkip = ILFindLastID(pidlProgs);
                }
            }

        // Decide which shell folder to enumerate.

        if (bUseAlt) {
            psfTemp = pfmh->psfAlt;
        } else {
            psfTemp = pfmh->psf;
        }

        // We now need to iterate over the children under this guy...
        hres = psfTemp->EnumObjects(NULL, pfmh->fFSFilter, &penum);
        if (SUCCEEDED(hres))
        {
            ULONG celt;
            LPITEMIDLIST pidl = NULL;

            // The pidl is stored away into the pfmi structure, so
            // don't free it here
            while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
            {
                PFILEMENUITEM pfmi;

                // Abort.
                if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
                    break;

                if (pidlSkip && psfTemp->CompareIDs(0, pidlSkip, pidl) == 0)
                {
                   ILFree(pidl);    // Don't leak this one...
                   TraceMsg(DM_TRACE, "FileList_Build: Skipping Programs.");
                   continue;
                }

                // Is there a list of extensions on which we need to
                // filter?
                if (pfmh->pszFilterTypes)
                {
                    STRRET str;
                    DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM;

                    psfTemp->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &dwAttribs);

                    // only apply the filter to file system objects

                    if ((dwAttribs & SFGAO_FILESYSTEM) &&
                        SUCCEEDED(psfTemp->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
                    {
                        TCHAR szFile[MAX_PATH];
                        StrRetToBuf(&str, pidl, szFile, SIZECHARS(szFile));

                        if (!(dwAttribs & SFGAO_FOLDER))
                        {
                            LPTSTR psz = pfmh->pszFilterTypes;
                            LPTSTR pszExt = PathFindExtension(szFile);

                            if (TEXT('.') == *pszExt)
                                pszExt++;

                            while (*psz)
                            {
                                // Skip this file?
                                if (0 == lstrcmpi(pszExt, psz))
                                    break;          // No

                                psz += lstrlen(psz) + 1;
                            }

                            if ( !*psz )
                            {
                                ILFree(pidl);       // don't leak this
                                continue;
                            }
                        }
                    }
                }

                if (FileMenuItem_Create(pfmh, pidl, -1, bUseAlt ? FMI_ALTITEM : 0, &pfmi))
                {
                    if (!bUseAlt)
                    {
                        // Set the allowable drop effects (as a target).
                        // We don't allow common user items to be moved.
                        pfmi->dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY;
                    }

                    int idpa = DPA_AppendPtr(hdpaTemp, pfmi);
                    ASSERTMSG(idpa != -1, "DPA_AppendPtr failed when adding file menu item");

                    if (idpa != -1)
                    {
                        // NB We only callback for non-folders at the moment
                        //
                        // HACK don't callback for non file system things
                        // this callback is used to set hotkeys, and that tries
                        // to load the PIDL passed back as a file, and that doesn't
                        // work for non FS pidls
                        if (pfmh->pfncb && (pfmi->Flags & FMI_FILESYSTEM))
                        {
                            FMCBDATA fmcbdata = { 0 };

                            fmcbdata.lParam = pfmh->lParam;  
                            fmcbdata.hmenu = pfmh->hmenu;
                            fmcbdata.iPos = idpa;
                            // Don't know the id because it hasn't been 
                            // added to the menu yet
                            fmcbdata.idCmd = (UINT)-1;
                            if (bUseAlt) 
                            {
                                fmcbdata.pidlFolder = pfmh->pidlAltFolder;
                            } 
                            else 
                            {
                                fmcbdata.pidlFolder = pfmh->pidlFolder;
                            }
                            fmcbdata.pidl = pidl;
                            fmcbdata.psf = psfTemp;
                            fmcbdata.pvHeader = pfmh;

                            // if the caller returns S_FALSE then we will remove the item from the
                            // menu, otherwise we behave as before.
                            if (pfmh->pfncb(FMM_ADD, &fmcbdata, 0) == S_FALSE)
                            {
                                FileMenuItem_Destroy(pfmi);
                                DPA_DeletePtr(pfmh->hdpa, idpa);
                            }
                            else
                            {
                                cItems++;
                            }
                        }
                        else
                        {
                            cItems++;
                        }
                    }
                }
            }
            penum->Release();
        }
        else
        {
            TraceMsg(TF_ERROR, "FileList_Build: Enumeration failed - leaving folder empty.");
        }

        ILFree(pidlProgs);
    }

    // Insert a special Empty item (unless the header flag says
    // not to).
    if (!cItems && hdpaTemp && !(pfmh->fmf & FMF_NOEMPTYITEM) && !bUseAlt)
    {
        PFILEMENUITEM pfmi;

        if (FileMenuItem_Create(pfmh, NULL, -1, FMI_EMPTY, &pfmi))
            {
            DPA_SetPtr(hdpaTemp, cItems, pfmi);
            cItems++;
            }
        }
    return cItems;
    }


#define FS_SORTBYNAME       0
#define FS_SORTBYORDINAL    1

//---------------------------------------------------------------------------
// Simplified version of the file info comparison function.
int CALLBACK FileMenuItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    PFILEMENUITEM pfmi1 = (PFILEMENUITEM)pv1;
    PFILEMENUITEM pfmi2 = (PFILEMENUITEM)pv2;
    int nRet;
    TCHAR szName1[MAX_PATH];
    TCHAR szName2[MAX_PATH];

    switch (lParam)
    {
    case FS_SORTBYNAME:
        // Directories come first, then files
        if ((pfmi1->Flags & FMI_FOLDER) > (pfmi2->Flags & FMI_FOLDER))
            return -1;
        else if ((pfmi1->Flags & FMI_FOLDER) < (pfmi2->Flags & FMI_FOLDER))
            return 1;

        FileMenuItem_GetDisplayName(pfmi1, szName1, ARRAYSIZE(szName1));
        FileMenuItem_GetDisplayName(pfmi2, szName2, ARRAYSIZE(szName2));
        nRet = lstrcmpi(szName1, szName2);
        break;

    case FS_SORTBYORDINAL:
        if (pfmi1->nOrder == pfmi2->nOrder)
            nRet = 0;
        else
            nRet = (pfmi1->nOrder < pfmi2->nOrder ? -1 : 1);
        break;

    default:
        ASSERT_MSG(0, "Bad lParam passed to FileMenuItem_Compare");
        nRet = 0;
        break;
    }

    return nRet;
}


LPVOID CALLBACK FileMenuItem_Merge(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam)
{
    PFILEMENUITEM pfmiDest = (PFILEMENUITEM)pvDest;
    PFILEMENUITEM pfmiSrc = (PFILEMENUITEM)pvSrc;
    LPVOID pvRet = pfmiDest;

    switch (uMsg)
    {
    case DPAMM_MERGE:
        // We just care about the order field
        pfmiDest->nOrder = pfmiSrc->nOrder;
        break;

    case DPAMM_DELETE:
    case DPAMM_INSERT:
        // Don't need to implement this
        ASSERT(0);
        pvRet = NULL;
        break;
    }
    
    return pvRet;
}


// Header for file menu streams
typedef struct tagFMSTREAMHEADER
{
    DWORD cbSize;           // Size of header
    DWORD dwVersion;        // Version of header
} FMSTREAMHEADER;

#define FMSTREAMHEADER_VERSION  1

typedef struct tagFMSTREAMITEM
{
    DWORD cbSize;           // Size including pidl (not for versioning)
    int   nOrder;           // User-specified order
} FMSTREAMITEM;

#define CB_FMSTREAMITEM     (sizeof(FMSTREAMITEM))

HRESULT 
CALLBACK 
FileMenuItem_SaveStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    // We only write menu items with pidls
    PFILEMENUITEM pfmi = (PFILEMENUITEM)pinfo->pvItem;
    HRESULT hres = S_FALSE;

    if (pfmi->pidl)
    {
        FMSTREAMITEM fmsi;
        ULONG cbWrite;
        ULONG cbWritePidl;

        // Size of header, pidl, and ushort for pidl size.
        fmsi.cbSize = CB_FMSTREAMITEM + pfmi->pidl->mkid.cb + sizeof(USHORT);
        fmsi.nOrder = pfmi->nOrder;

        hres = pstm->Write(&fmsi, CB_FMSTREAMITEM, &cbWrite);
        if (SUCCEEDED(hres))
        {
            hres = pstm->Write(pfmi->pidl, pfmi->pidl->mkid.cb + sizeof(USHORT), &cbWritePidl);
            ASSERT(fmsi.cbSize == cbWrite + cbWritePidl);
        }
    }

    return hres;
}   

 
HRESULT 
CALLBACK 
FileMenuItem_LoadStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    HRESULT hres;
    FMSTREAMITEM fmsi;
    ULONG cbRead;
    PFILEMENUHEADER pfmh = (PFILEMENUHEADER)pvData;

    ASSERT(pfmh);

    hres = pstm->Read(&fmsi, CB_FMSTREAMITEM, &cbRead);
    if (SUCCEEDED(hres))
    {
        if (CB_FMSTREAMITEM != cbRead)
            hres = E_FAIL;
        else
        {
            ASSERT(CB_FMSTREAMITEM < fmsi.cbSize);
            if (CB_FMSTREAMITEM < fmsi.cbSize)
            {
                UINT cb = fmsi.cbSize - CB_FMSTREAMITEM;
                LPITEMIDLIST pidl = _ILCreate(cb);
                if ( !pidl )
                    hres = E_OUTOFMEMORY;
                else
                {
                    hres = pstm->Read(pidl, cb, &cbRead);
                    if (SUCCEEDED(hres) && cb == cbRead && 
                        IS_VALID_PIDL(pidl))
                    {
                        PFILEMENUITEM pfmi;

                        if (FileMenuItem_Create(pfmh, pidl, -1, 0, &pfmi))
                        {
                            pfmi->nOrder = fmsi.nOrder;
                            pinfo->pvItem = pfmi;
                            hres = S_OK;
                        }
                        else
                            hres = E_OUTOFMEMORY;
                    }
                    else
                        hres = E_FAIL;

                    // Cleanup
                    if (FAILED(hres))
                        ILFree(pidl);
                }
            }
            else
                hres = E_FAIL;
        }
    }

    ASSERT((S_OK == hres && pinfo->pvItem) || FAILED(hres));
    return hres;
}    


int
CALLBACK
FileMenuItem_DestroyCB(LPVOID pv, LPVOID pvData)
{
    return FileMenuItem_Destroy((PFILEMENUITEM)pv);
}    


BOOL 
FileList_Load(
    IN  PFILEMENUHEADER pfmh,
    OUT HDPA *    phdpa,
    IN  IStream * pstm)
{
    HDPA hdpa = NULL;
    FMSTREAMHEADER fmsh;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(phdpa);
    ASSERT(pstm);

    // Read the header for more info
    if (SUCCEEDED(pstm->Read(&fmsh, sizeof(fmsh), NULL)) &&
        sizeof(fmsh) == fmsh.cbSize &&
        FMSTREAMHEADER_VERSION == fmsh.dwVersion)
    {
        // Load the stream.  (Should be ordered by name.)
        DPA_LoadStream(&hdpa, FileMenuItem_LoadStream, pstm, pfmh);
    }

    *phdpa = hdpa;

    return (NULL != hdpa);
}    


HRESULT 
FileList_Save(
    IN  PFILEMENUHEADER pfmh,
    IN  IStream * pstm)
{
    HRESULT hres = E_OUTOFMEMORY;
    FMSTREAMHEADER fmsh;
    HDPA hdpa;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(pstm);

    // Clone the array and sort by name for the purpose of persisting it
    hdpa = DPA_Clone(pfmh->hdpa, NULL);
    if (hdpa)
    {
        DPA_Sort(hdpa, FileMenuItem_Compare, FS_SORTBYNAME);

        // Save the header
        fmsh.cbSize = sizeof(fmsh);
        fmsh.dwVersion = FMSTREAMHEADER_VERSION;

        hres = pstm->Write(&fmsh, sizeof(fmsh), NULL);
        if (SUCCEEDED(hres))
        {
            hres = DPA_SaveStream(hdpa, FileMenuItem_SaveStream, pstm, pfmh);
        }

        DPA_Destroy(hdpa);
    }

    return hres;
}    


void FileList_Reorder(PFILEMENUHEADER pfmh)
{
    int i;
    int cel;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    BOOL bCantOrder = (NULL == pfmh->pstm);

    // Update the order fields.  While we're at it, massage the 
    // dwEffect field so it reflects whether something can be
    // ordered based on the stream (no stream means no reorder).

    cel = DPA_GetPtrCount(pfmh->hdpa);
    for (i = 0; i < cel; i++)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_FastGetPtr(pfmh->hdpa, i);
        pfmi->nOrder = i;

        if (bCantOrder)
            pfmi->dwEffect = DROPEFFECT_NONE;
    }
}    


// Caller should release the stream after using it
BOOL FileList_GetStream(PFILEMENUHEADER pfmh, IStream ** ppstm)
{
    if (NULL == pfmh->pstm)
    {
        if (pfmh->pfncb)
        {
            FMGETSTREAM fmgs = { 0 };
            FMCBDATA fmcbdata;

            fmcbdata.lParam = pfmh->lParam;  
            fmcbdata.hmenu = pfmh->hmenu;
            fmcbdata.idCmd = pfmh->idCmd;
            fmcbdata.iPos = -1;
            fmcbdata.pidlFolder = pfmh->pidlFolder;
            fmcbdata.pidl = NULL;
            fmcbdata.psf = pfmh->psf;
            fmcbdata.pvHeader = pfmh;

            if (S_OK == pfmh->pfncb(FMM_GETSTREAM, &fmcbdata, (LPARAM)&fmgs) &&
                fmgs.pstm)
            {
                // Cache this stream away
                pfmh->pstm = fmgs.pstm;
            }
        }
    }
    else
    {
        // Reset the seek pointer to beginning
        LARGE_INTEGER dlibMove = { 0 };
        pfmh->pstm->Seek(dlibMove, STREAM_SEEK_SET, NULL);
    }

    if (pfmh->pstm)
        pfmh->pstm->AddRef();
        
    *ppstm = pfmh->pstm;

    return (NULL != *ppstm);
}    


void  
FileList_Sort(
    PFILEMENUHEADER pfmh)
{
    IStream * pstm;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // First sort by name
    DPA_Sort(pfmh->hdpa, FileMenuItem_Compare, FS_SORTBYNAME);

    // Can this menu be sorted by the user?
    if ((pfmh->fmf & FMF_CANORDER) && FileList_GetStream(pfmh, &pstm))
    {
        // Yes; get the stream and try to load the order info
        HDPA hdpaOrder;

        // Read the order from the stream
        if (FileList_Load(pfmh, &hdpaOrder, pstm))
        {
            // Sort the menu according to this stream's order.

            // The persisted order is by name.  This reduces the number of
            // sorts to two at load-time, and 1 at save-time.  (Persisting
            // by ordinal number means we sort three times at load-time, and
            // none at save-time.  We want to speed up the initial menu
            // creation as much as possible.)

            // (Already sorted by name above)
            DPA_Merge(pfmh->hdpa, hdpaOrder, DPAM_SORTED, FileMenuItem_Compare, 
                      FileMenuItem_Merge, FS_SORTBYNAME);
            DPA_Sort(pfmh->hdpa, FileMenuItem_Compare, FS_SORTBYORDINAL);

            DPA_DestroyCallback(hdpaOrder, FileMenuItem_DestroyCB, NULL);
        }

        pstm->Release();
    }

    FileList_Reorder(pfmh);
}


//---------------------------------------------------------------------------
// Use the text extent of the given item and the size of the image to work
// what the full extent of the item will be.
DWORD GetItemExtent(HDC hdc, PFILEMENUITEM pfmi)
{
    TCHAR szName[MAX_PATH];

    szName[0] = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

    PFILEMENUHEADER pfmh = pfmi->pfmh;
    ASSERT(pfmh);

    // Limit the width of the text?
    if (0 < pfmh->cxMax)
    {
        // Yes
        PathCompactPath(hdc, szName, pfmh->cxMax);
    }

    DWORD dwExtent = GetItemTextExtent(hdc, szName);

    WORD wHeight = HIWORD(dwExtent);

    // If no custom height - calc it.
    if (!pfmi->cyItem)
    {
        if (pfmh->fmf & FMF_LARGEICONS)
            wHeight = max(wHeight, ((WORD)g_cyIcon)) + 2;
        else
            wHeight = max(wHeight, ((WORD)g_cySmIcon)) + pfmh->cySpacing;
    }
    else
    {
        wHeight = max(wHeight, pfmi->cyItem);
    }

    ASSERT(pfmi->pfmh);

    //    string, image, gap on either side of image, popup triangle
    //    and background bitmap if there is one.
    // FEATURE: popup triangle size needs to be real
    WORD wWidth = LOWORD(dwExtent) + GetSystemMetrics(SM_CXMENUCHECK);

    // Keep track of the width and height of the bitmap.
    if (pfmh->hbmp && !pfmh->cxBmp && !pfmh->cyBmp)
    {
        BITMAP bmp;
        GetObject(pfmh->hbmp, SIZEOF(bmp), &bmp);
        pfmh->cxBmp = bmp.bmWidth;
        pfmh->cyBmp = bmp.bmHeight;
    }

    // Gap for bitmap.
    wWidth += (WORD) pfmh->cxBmpGap;

    // Space for image if there is one.
    // NB We currently always allow room for the image even if there
    // isn't one so that imageless items line up properly.
    if (pfmh->fmf & FMF_LARGEICONS)
        wWidth += g_cxIcon + (2 * CXIMAGEGAP);
    else
        wWidth += g_cxSmIcon + (2 * CXIMAGEGAP);

    return MAKELONG(wWidth, wHeight);
}


/*----------------------------------------------------------
Purpose: Get the PFILEMENUITEM of this menu item

Returns: 
Cond:    --
*/
PFILEMENUITEM  
FileMenu_GetItemData(
    IN HMENU hmenu, 
    IN UINT iItem,
    IN BOOL bByPos)
{
    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(MENUITEMINFO);
    mii.fMask = MIIM_DATA | MIIM_STATE;
    mii.cch = 0;     // just in case

    if (GetMenuItemInfo(hmenu, iItem, bByPos, &mii))
        return (PFILEMENUITEM)mii.dwItemData;

    return NULL;
}


PFILEMENUHEADER FileMenu_GetHeader(HMENU hmenu)
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (pfmi && 
        EVAL(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM)) &&
        EVAL(IS_VALID_STRUCT_PTR(pfmi->pfmh, FILEMENUHEADER)))
    {
        return pfmi->pfmh;
    }

    return NULL;
}


/*----------------------------------------------------------
Purpose: Create a file menu header.  This header is to be associated 
         with the given menu handle.

         If the menu handle already has header, simply return the
         existing header.

Returns: pointer to header
         NULL on failure
*/
PFILEMENUHEADER
FileMenuHeader_Create(
    IN HMENU        hmenu,
    IN HBITMAP      hbmp,
    IN int          cxBmpGap,
    IN COLORREF     clrBkg,
    IN int          cySel,
    IN const FMCOMPOSE * pfmc)      OPTIONAL
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    PFILEMENUHEADER pfmh;

    // Does this guy already have a header?
    if (pfmi)
    {
        // Yes; use it
        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    }
    else
    {
        // Nope, create one now.
        pfmh = (PFILEMENUHEADER)LocalAlloc(LPTR, SIZEOF(FILEMENUHEADER));
        if (pfmh)
        {
            // Keep track of the header.
            TraceMsg(TF_MENU, "Creating filemenu header for %#08x (%x)", hmenu, pfmh);

            pfmh->hdpa = DPA_Create(0);
            if (pfmh->hdpa == NULL)
            {
                LocalFree((HLOCAL)pfmh);
                pfmh = NULL;
            }
            else
            {
                pfmh->hmenu = hmenu;
                pfmh->hbmp = hbmp;
                pfmh->cxBmpGap = cxBmpGap;
                pfmh->clrBkg = clrBkg;
                pfmh->cySel = cySel;
                pfmh->cySpacing = 6;        // default for small icons
            }
        }
    }

    if (pfmc && pfmh)
    {
        // Set additional values
        if (IsFlagSet(pfmc->dwMask, FMC_CALLBACK))
        {
            pfmh->pfncb = pfmc->pfnCallback;
            pfmh->lParam = pfmc->lParam;
        }

        if (IsFlagSet(pfmc->dwMask, FMC_CYMAX))
            pfmh->cyMax = pfmc->cyMax;

        if (IsFlagSet(pfmc->dwMask, FMC_CXMAX))
            pfmh->cxMax = pfmc->cxMax;

        if (IsFlagSet(pfmc->dwMask, FMC_CYSPACING))
            pfmh->cySpacing = pfmc->cySpacing;

        if (IsFlagSet(pfmc->dwMask, FMC_FILTERTYPES))
        {
            // This is a double-null terminated string
            MultiSz_AllocCopy(pfmc->pszFilterTypes, &pfmh->pszFilterTypes);
        }
    }

    return pfmh;
}


/*----------------------------------------------------------
Purpose: Set info specific to a folder.

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_SetFolderInfo(
    IN PFILEMENUHEADER pfmh,
    IN const FMCOMPOSE * pfmc)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(pfmc);

    // Keep track of the header.
    pfmh->idCmd = pfmc->id;

    if (IsFlagSet(pfmc->dwMask, FMC_FILTER))
        pfmh->fFSFilter = pfmc->dwFSFilter;

    if (IsFlagSet(pfmc->dwMask, FMC_CYMAX))
        pfmh->cyMax = pfmc->cyMax;

    if (IsFlagSet(pfmc->dwMask, FMC_CXMAX))
        pfmh->cxMax = pfmc->cxMax;

    if (IsFlagSet(pfmc->dwMask, FMC_CYSPACING))
        pfmh->cySpacing = pfmc->cySpacing;

    if (IsFlagSet(pfmc->dwMask, FMC_FILTERTYPES))
        MultiSz_AllocCopy(pfmc->pszFilterTypes, &pfmh->pszFilterTypes);

    if (pfmc->pidlFolder)
    {
        pfmh->pidlFolder = ILClone(pfmc->pidlFolder);
        if (pfmh->pidlFolder)
        {
            LPSHELLFOLDER psfDesktop;
            if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pfmh->pidlFolder, 
                    NULL, IID_IShellFolder, (PVOID *)&pfmh->psf)))
                {
                    return TRUE;
                }
            }
            ILFree(pfmh->pidlFolder);
        }
    }
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Create the tooltip window

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_CreateTooltipWindow(
    IN  PFILEMENUHEADER pfmh)
    {
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Check if we need to create the main tooltip window
    if (g_hwndTip)
    {
        if (IsWindow(g_hwndTip))
        {
            TCHAR szClass[MAX_PATH];
            GetClassName(g_hwndTip, szClass, ARRAYSIZE(szClass));
            if (lstrcmpi(szClass, TOOLTIPS_CLASS) != 0)
                g_hwndTip = NULL;
        }
        else
            g_hwndTip = NULL;
    }

    if (!g_hwndTip)
        Tooltip_Create(&g_hwndTip);

    ASSERT(IS_VALID_HANDLE(g_hwndTip, WND));

    return NULL != g_hwndTip;
    }


//---------------------------------------------------------------------------
// Give the submenu a marker item so we can check it's a filemenu item
// at initpopupmenu time.
BOOL FileMenuHeader_InsertMarkerItem(PFILEMENUHEADER pfmh)
{
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (FileMenuItem_Create(pfmh, NULL, -1, FMI_MARKER | FMI_EXPAND, &pfmi))
    {
        DPA_SetPtr(pfmh->hdpa, 0, pfmi);
        FileMenuHeader_InsertItem(pfmh, 0, FMII_DEFAULT);
        return TRUE;
    }
    TraceMsg(TF_ERROR, "FileMenuHeader_InsertMarkerItem: Can't create marker item.");
    return FALSE;
}


/*----------------------------------------------------------
Purpose: This functions adds the given item (index into DPA)
         into the actual menu.

Returns:
Cond:    --
*/
BOOL
FileMenuHeader_InsertItem(
    IN PFILEMENUHEADER pfmh,
    IN UINT            iItem,
    IN FMIIFLAGS       fFlags)
{
    PFILEMENUITEM pfmi;
    UINT fMenu;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // Normal item.
    pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem);
    if (!pfmi)
        return FALSE;

    if (pfmi->Flags & FMI_ON_MENU)
        return FALSE;
    else
        pfmi->Flags |= FMI_ON_MENU;

    // The normal stuff.
    fMenu = MF_BYPOSITION|MF_OWNERDRAW;
    // Keep track of where it's going in the menu.

    // The special stuff...
    if (fFlags & FMII_BREAK)
    {
        fMenu |= MF_MENUBARBREAK;
    }

    // Is it a folder (that's not open yet)?
    if (pfmi->Flags & FMI_FOLDER)
    {
        // Yep. Create a submenu item.
        HMENU hmenuSub = CreatePopupMenu();
        if (hmenuSub)
        {
            MENUITEMINFO mii;
            LPITEMIDLIST pidlSub;
            PFILEMENUHEADER pfmhSub;
            FMCOMPOSE fmc;

            // Set the callback now so it can be called when adding items
            fmc.cbSize = SIZEOF(fmc);
            fmc.dwMask = FMC_CALLBACK; 
            fmc.lParam = pfmh->lParam;  
            fmc.pfnCallback = pfmh->pfncb;

            // Insert it into the parent menu.
            fMenu |= MF_POPUP;
            InsertMenu(pfmh->hmenu, iItem, fMenu, (UINT_PTR)hmenuSub, (LPTSTR)pfmi);
            // Set it's ID.
            mii.cbSize = SIZEOF(mii);
            mii.fMask = MIIM_ID;
            mii.wID = pfmh->idCmd;
            SetMenuItemInfo(pfmh->hmenu, iItem, TRUE, &mii);
            pidlSub = ILCombine((pfmi->Flags & FMI_ALTITEM) ? pfmh->pidlAltFolder : pfmh->pidlFolder, pfmi->pidl);
            pfmhSub = FileMenuHeader_Create(hmenuSub, NULL, 0, (COLORREF)-1, 0, &fmc);
            if (pfmhSub)
            {
                // Inherit settings from the parent filemenu
                fmc.dwMask     = FMC_PIDL | FMC_FILTER | FMC_CYMAX |
                                 FMC_CXMAX | FMC_CYSPACING;
                fmc.id         = pfmh->idCmd;
                fmc.pidlFolder = pidlSub;
                fmc.dwFSFilter = pfmh->fFSFilter;
                fmc.cyMax      = pfmh->cyMax;
                fmc.cxMax      = pfmh->cxMax;
                fmc.cySpacing  = pfmh->cySpacing;

                if (pfmh->pszFilterTypes)
                {
                    fmc.dwMask |= FMC_FILTERTYPES;
                    fmc.pszFilterTypes = pfmh->pszFilterTypes;
                }

                FileMenuHeader_SetFolderInfo(pfmhSub, &fmc);

                // Magically inherit certain flags
                // FEATURE: (scotth): can we inherit all the bits?
                pfmhSub->fmf = pfmh->fmf & FMF_INHERITMASK;

                // Build it a bit at a time.
                FileMenuHeader_InsertMarkerItem(pfmhSub);
            }
            ILFree(pidlSub);
        }
    }
    else
    {
        // Nope.
        if (pfmi->Flags & FMI_EMPTY)
            fMenu |= MF_DISABLED | MF_GRAYED;

        InsertMenu(pfmh->hmenu, iItem, fMenu, pfmh->idCmd, (LPTSTR)pfmi);
    }

    return TRUE;
}


/*----------------------------------------------------------
Purpose: Remove the rest of the items from the main list starting
         at the given index.

Returns: --
Cond:    --
*/
void
FileList_StripLeftOvers(
    IN PFILEMENUHEADER pfmh,
    IN int             idpaStart,
    IN BOOL            bUseAlt)
{
    int cItems;
    int i;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    cItems = DPA_GetPtrCount(pfmh->hdpa);

    // Do this backwards to stop things moving around as
    // we delete them.
    for (i = cItems - 1; i >= idpaStart; i--)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
        if (pfmi)
        {
            // Tell the callback we're removing this
            if (pfmh->pfncb && pfmi->pidl && 
                IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
            {
                FMCBDATA fmcbdata;

                fmcbdata.lParam = pfmh->lParam;  
                fmcbdata.hmenu = pfmh->hmenu;
                fmcbdata.iPos = i;
                fmcbdata.idCmd = GetMenuItemID(pfmh->hmenu, i);
                if (bUseAlt)
                {
                    fmcbdata.pidlFolder = pfmh->pidlAltFolder;
                    fmcbdata.psf = pfmh->psfAlt;
                }
                else
                {
                    fmcbdata.pidlFolder = pfmh->pidlFolder;
                    fmcbdata.psf = pfmh->psf;
                }
                fmcbdata.pidl = pfmi->pidl;
                fmcbdata.pvHeader = pfmh;

                pfmh->pfncb(FMM_REMOVE, &fmcbdata, 0);
            }

            // (We don't need to worry about recursively deleting
            // subfolders because their contents haven't been added yet.)

            // Delete the item itself (note there is no menu item
            // to delete)
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
        }
    }
}


/*----------------------------------------------------------
Purpose: This function adds a "More Items..." menu item
         at the bottom of the menu.  It calls the callback
         to get the string.

Returns: 
Cond:    --
*/
void
FileMenuHeader_AddMoreItemsItem(
    IN PFILEMENUHEADER pfmh,
    IN UINT            iPos)
{
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (NULL == pfmh->pfncb)
    {
        // (scotth): this shouldn't be required, but we don't
        // have a default resource ID for this right now.

        TraceMsg(TF_ERROR, "Need a callback in order to add a More item.");
        ASSERT(0);
    }
    else if (FileMenuItem_Create(pfmh, NULL, -1, 0, &pfmi))
    {
        FMCBDATA fmcbdata;
        FMMORESTRING fmms = {0};

        // Make the pidl be the whole path to the folder
        pfmi->pidl = ILClone(pfmh->pidlFolder);
        pfmi->Flags |= FMI_IGNORE_PIDL;

        fmcbdata.hmenu = pfmh->hmenu;
        fmcbdata.iPos = -1;
        fmcbdata.idCmd = (UINT)-1;

        // (scotth): we don't ask for string for alternate lists
        fmcbdata.pidlFolder = NULL;
        fmcbdata.pidl = pfmi->pidl;
        fmcbdata.psf = pfmh->psf;

        // Was a string set?
        if (S_OK == pfmh->pfncb(FMM_GETMORESTRING, &fmcbdata, (LPARAM)&fmms))
        {
            Sz_AllocCopy(fmms.szMoreString, &(pfmi->psz));

            if (DPA_SetPtr(pfmh->hdpa, iPos, pfmi))
            {
                MENUITEMINFO mii;

                // Set the command ID
                mii.cbSize = SIZEOF(mii);
                mii.fMask  = MIIM_ID | MIIM_TYPE | MIIM_DATA;
                mii.wID    = fmms.uID;
                mii.fType  = MFT_OWNERDRAW;
                mii.dwItemData = (DWORD_PTR)pfmi;

                EVAL(InsertMenuItem(pfmh->hmenu, iPos, TRUE, &mii));
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Enumerates the DPA and adds each item into the
         menu.  Inserts vertical breaks if the menu becomes
         too long.

Returns: count of items added to menu
Cond:    --
*/
int
FileList_AddToMenu(
    IN PFILEMENUHEADER pfmh,
    IN BOOL            bUseAlt,
    IN BOOL            bAddSeparatorSpace)
{
    UINT i, cItems;
    int cItemMac = 0;
    PFILEMENUITEM pfmi;
    int cyMenu, cyItem, cyMenuMax;
    HDC hdc;
    HFONT hfont, hfontOld;
    NONCLIENTMETRICS ncm;
    int idpa;
    HDPA hdpaT;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (bUseAlt)
        hdpaT = pfmh->hdpaAlt;
    else
        hdpaT = pfmh->hdpa;

    if (hdpaT)
    {
        cyItem = 0;
        cyMenu = pfmh->cyMenuSizeSinceLastBreak;

        if (0 < pfmh->cyMax)
            cyMenuMax = pfmh->cyMax;
        else
            cyMenuMax = GetSystemMetrics(SM_CYSCREEN);

        // Get the rough height of an item so we can work out when to break the
        // menu. User should really do this for us but that would be useful.
        hdc = GetDC(NULL);
        if (hdc)
        {
            ncm.cbSize = SIZEOF(NONCLIENTMETRICS);
            if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, SIZEOF(ncm), &ncm, FALSE))
            {
                hfont = CreateFontIndirect(&ncm.lfMenuFont);
                if (hfont)
                {
                    hfontOld = SelectFont(hdc, hfont);
                    cyItem = HIWORD(GetItemExtent(hdc, (PFILEMENUITEM)DPA_GetPtr(hdpaT, 0)));
                    SelectObject(hdc, hfontOld);
                    DeleteObject(hfont);
                }
            }
            ReleaseDC(NULL, hdc);
        }

        // If we are appending items to a menu, we need to account
        // for the separator.

        if (bAddSeparatorSpace) {
            cyMenu += cyItem;
        }

        cItems = DPA_GetPtrCount(hdpaT);

        for (i = 0; i < cItems; i++)
        {
            if (bUseAlt) {
                // Move the items from the alternate list to the main
                // list and use the new index.
                pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpaAlt, i);
                if (!pfmi)
                    continue;

                idpa = DPA_AppendPtr(pfmh->hdpa, pfmi);

            } else {
                idpa = i;
            }

            // Keep a rough count of the height of the menu.
            cyMenu += cyItem;
            if (cyMenu > cyMenuMax)
            {
                // Add a vertical break?
                if ( !(pfmh->fmf & (FMF_NOBREAK | FMF_RESTRICTHEIGHT)) )
                {
                    // Yes
                    FileMenuHeader_InsertItem(pfmh, idpa, FMII_BREAK);
                    cyMenu = cyItem;
                }
                // Restrict height?
                else if (IsFlagSet(pfmh->fmf, FMF_RESTRICTHEIGHT))
                {
                    // Yes; remove the remaining items from the list
                    FileList_StripLeftOvers(pfmh, idpa, bUseAlt);

                    // (so cyMenuSizeSinceLastBreak is accurate)
                    cyMenu -= cyItem;

                    // Add a "more..." item at the end?
                    if (pfmh->fmf & FMF_MOREITEMS)
                    {
                        // Yes
                        FileMenuHeader_AddMoreItemsItem(pfmh, idpa);
                    }

                    // We won't go any further
                    break;
                }
            }
            else
            {
                FileMenuHeader_InsertItem(pfmh, idpa, FMII_DEFAULT);
                cItemMac++;
            }
        }

        // Save the current cy size so we can use this again
        // if more items are appended to this menu.

        pfmh->cyMenuSizeSinceLastBreak = cyMenu;
    }

    return cItemMac;
}


BOOL
FileList_AddImages(
    IN PFILEMENUHEADER pfmh,
    IN BOOL            bUseAlt)
{
    PFILEMENUITEM pfmi;
    int i, cItems;
    HDPA hdpaTemp;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (bUseAlt) {
        hdpaTemp = pfmh->hdpaAlt;
    } else {
        hdpaTemp = pfmh->hdpa;
    }

    cItems = DPA_GetPtrCount(hdpaTemp);
    for (i = 0; i < cItems; i++)
    {
        if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
        {
            TraceMsg(TF_MENU, "FileList_AddImages: Abort: Defering images till later.");
            break;
        }

        pfmi = (PFILEMENUITEM)DPA_GetPtr(hdpaTemp, i);
        if (pfmi && pfmi->pidl && (pfmi->iImage == -1) &&
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(
                                (bUseAlt ? pfmh->psfAlt : pfmh->psf),
                                pfmi->pidl, NULL);
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
BOOL FileMenuItem_Destroy(PFILEMENUITEM pfmi)
{
    BOOL fRet = FALSE;

    ASSERT(NULL == pfmi || IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    if (pfmi)
    {
        if (pfmi->pidl)
            ILFree(pfmi->pidl);
        if (pfmi->psz)
            LFree(pfmi->psz);
        if (pfmi->pszTooltip)
            LFree(pfmi->pszTooltip);
        LocalFree(pfmi);
        fRet = TRUE;
    }

    return fRet;
}

//---------------------------------------------------------------------------
// Clean up the items created by FileList_Build;
void FileList_UnBuild(PFILEMENUHEADER pfmh)
{
    int cItems;
    int i;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    cItems = DPA_GetPtrCount(pfmh->hdpa);
    for (i=cItems-1; i>=0; i--)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
        if (FileMenuItem_Destroy(pfmi))
            DPA_DeletePtr(pfmh->hdpa, i);
    }
}


// Flags for FileMenuHeader_AddFiles
#define FMHAF_USEALT            0x0001
#define FMHAF_SEPARATOR         0x0002


//---------------------------------------------------------------------------
// Add menu items from an IContextMenu handler.

HRESULT FileMenuHeader_AddFromContextMenu(PFILEMENUHEADER pfmh, HKEY hk)
{
    // enumerate the key and create each of the context menu handlers, for that
    // we can then add the entries.
    return S_OK;
}

/*----------------------------------------------------------
Purpose: Add files to a file menu header. This function goes thru
         the following steps:

         - enumerates the folder and fills the hdpa list with items
           (files and subfolders)
         - sorts the list
         - gets the images for the items in the list
         - adds the items from list into actual menu

         The last step also (optionally) caps the length of the
         menu to the specified height.  Ideally, this should
         happen at the enumeration time, except the required sort
         prevents this from happening.  So we end up adding a
         bunch of items to the list and then removing them if
         there are too many.

Returns: count of items added
         -1 if aborted
Cond:    --
*/
HRESULT
FileMenuHeader_AddFiles(
    IN  PFILEMENUHEADER pfmh,
    IN  int             iPos,
    IN  UINT            uFlags,                 // FMHAF_*
    OUT int *           pcItems)
{
    HRESULT hres;
    BOOL bUseAlt = IsFlagSet(uFlags, FMHAF_USEALT);

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    int cItems = FileList_Build(pfmh, iPos, bUseAlt);

    // If the build was aborted cleanup and early out.
    if (FileMenuHeader_AllowAbort(pfmh) && g_fAbortInitMenu)
    {
        // Cleanup.
        TraceMsg(TF_MENU, "FileList_Build aborted.");
        FileList_UnBuild(pfmh);
        hres = E_ABORT;
        *pcItems = -1;
    }
    else
    {
        *pcItems = cItems;

        if (cItems > 1)
            FileList_Sort(pfmh);

        if (cItems != 0)
        {
            BOOL bSeparator = IsFlagSet(uFlags, FMHAF_SEPARATOR);
            if (bSeparator)
            {
                // insert a line
                FileMenu_AppendItem(pfmh->hmenu, (LPTSTR)FMAI_SEPARATOR, 0, -1, NULL, 0);
            }

            // Add the images *after* adding to the menu, since the menu
            // may be capped to a maximum height, and we can then prevent
            // adding images we won't need.
            *pcItems = FileList_AddToMenu(pfmh, bUseAlt, bSeparator);
            FileList_AddImages(pfmh, bUseAlt);
        }

        hres = (*pcItems < cItems) ? S_FALSE : S_OK;
    }

    if (g_fAbortInitMenu)
        g_fAbortInitMenu = FALSE;

    TraceMsg(TF_MENU, "FileMenuHeader_AddFiles: Added %d filemenu items.", cItems);
    return hres;
}


//----------------------------------------------------------------------------
// Free up a header (you should delete all the items first).
void FileMenuHeader_Destroy(PFILEMENUHEADER pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    TraceMsg(TF_MENU, "Destroy filemenu for (%x)", pfmh);

    // Clean up the header.
    DPA_Destroy(pfmh->hdpa);
    if (pfmh->pidlFolder)
    {
        ILFree(pfmh->pidlFolder);
        pfmh->pidlFolder = NULL;
    }
    if (pfmh->psf)
    {
        pfmh->psf->Release();
        pfmh->psf = NULL;
    }

    if (pfmh->pstm)
    {
        pfmh->pstm->Release();
        pfmh->pstm = NULL;
    }

    if (pfmh->pidlAltFolder)
    {
        ILFree(pfmh->pidlAltFolder);
        pfmh->pidlAltFolder = NULL;
    }
    if (pfmh->psfAlt)
    {
        pfmh->psfAlt->Release();
        pfmh->psfAlt = NULL;
    }
    if (pfmh->pszFilterTypes)
    {
        LFree(pfmh->pszFilterTypes);
        pfmh->pszFilterTypes = NULL;
    }

    LocalFree((HLOCAL)pfmh);    // needed?
}

//---------------------------------------------------------------------------
// We create subemnu's with one marker item so we can check it's a file menu
// at init popup time but we need to delete it before adding new items.
BOOL FileMenuHeader_DeleteMarkerItem(PFILEMENUHEADER pfmh)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    // It should just be the only one in the menu.
    if (GetMenuItemCount(pfmh->hmenu) == 1)
    {
        // It should have the right id.
        if (GetMenuItemID(pfmh->hmenu, 0) == pfmh->idCmd)
        {
            // With item data and the marker flag set.
            PFILEMENUITEM pfmi = FileMenu_GetItemData(pfmh->hmenu, 0, TRUE);
            if (pfmi && (pfmi->Flags & FMI_MARKER))
            {
                // Delete it.
                ASSERT(pfmh->hdpa);
                ASSERT(DPA_GetPtrCount(pfmh->hdpa) == 1);
                // NB The marker shouldn't have a pidl.
                ASSERT(!pfmi->pidl);

                LocalFree((HLOCAL)pfmi);

                DPA_DeletePtr(pfmh->hdpa, 0);
                DeleteMenu(pfmh->hmenu, 0, MF_BYPOSITION);
                // Cleanup OK.
                return TRUE;
            }
        }
    }

    TraceMsg(TF_MENU, "Can't find marker item.");
    return FALSE;
}


/*----------------------------------------------------------
Purpose: Add files to this menu.

Returns: number of items added
Cond:    --
*/
HRESULT
FileMenu_AddFiles(
    IN     HMENU       hmenu,
    IN     UINT        iPos,
    IN OUT FMCOMPOSE * pfmc)
{
    HRESULT hres = E_OUTOFMEMORY;
    BOOL fMarker = FALSE;
    PFILEMENUHEADER pfmh;

    // NOTE:  this function takes in FMCOMPOSE, which can be A or W
    //        version depending on the platform.  Since the function 
    //        is internal, wrapped by FileMenu_ComposeA/W, it expects 
    //        the pidl to be valid, and will not use the pszFolder field.

    if (IsFlagClear(pfmc->dwMask, FMC_FILTER))
        pfmc->dwFSFilter = 0;

    if (IsFlagClear(pfmc->dwMask, FMC_FLAGS))
        pfmc->dwFlags = 0;

    // (FileMenuHeader_Create might return an existing header)
    pfmh = FileMenuHeader_Create(hmenu, NULL, 0, (COLORREF)-1, 0, pfmc);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            // Clean up marker item if there is one.
            if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
            {
                // Nope, do it now.
                TraceMsg(TF_MENU, "Removing marker item.");
                FileMenuHeader_DeleteMarkerItem(pfmh);
                fMarker = TRUE;
                if (iPos)
                    iPos--;
            }
        }

        // Add the new stuff
        FileMenuHeader_SetFolderInfo(pfmh, pfmc);

        // Tack on more flags
        pfmh->fmf |= pfmc->dwFlags;

        SetFlag(pfmh->fmf, FMF_NOABORT);
        hres = FileMenuHeader_AddFiles(pfmh, iPos, 0, &pfmc->cItems);
        ClearFlag(pfmh->fmf, FMF_NOABORT);

        if ((E_ABORT == hres || 0 == pfmc->cItems) && fMarker)
        {
            // Aborted or no items. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh);
        }
    }

    return hres;
}


//---------------------------------------------------------------------------
// Returns the number of items added.
STDAPI_(UINT)
FileMenu_AppendFilesForPidl(
    HMENU hmenu,
    LPITEMIDLIST pidl,
    BOOL bInsertSeparator)
{
    int cItems = 0;
    BOOL fMarker = FALSE;
    PFILEMENUHEADER pfmh;
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    ASSERT(IS_VALID_PIDL(pidl));

    //
    // Get the filemenu header from the first filemenu item
    //

    if (!pfmi)
        return 0;

    pfmh = pfmi->pfmh;


    if (pfmh)
    {
        // Clean up marker item if there is one.
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            // Nope, do it now.
            // TraceMsg(DM_TRACE, "t.fm_ii: Removing marker item.");
            FileMenuHeader_DeleteMarkerItem(pfmh);
            fMarker = TRUE;
        }

        // Add the new stuff.
        if (pidl)
        {
            LPSHELLFOLDER psfDesktop;
            if (SUCCEEDED(SHGetDesktopFolder(&psfDesktop)))
            {
                pfmh->pidlAltFolder = ILClone(pidl);

                if (pfmh->pidlAltFolder) {

                    pfmh->hdpaAlt = DPA_Create(0);

                    if (pfmh->hdpaAlt) {

                        if (SUCCEEDED(psfDesktop->BindToObject(pfmh->pidlAltFolder, 
                            NULL, IID_IShellFolder, (LPVOID *)&pfmh->psfAlt)))
                        {
                            UINT uFlags = FMHAF_USEALT;

                            if (bInsertSeparator)
                                uFlags |= FMHAF_SEPARATOR;

                            pfmh->fmf |= FMF_NOABORT;
                            FileMenuHeader_AddFiles(pfmh, 0, uFlags, &cItems);
                            pfmh->fmf = pfmh->fmf & ~FMF_NOABORT;
                        }

                        DPA_Destroy (pfmh->hdpaAlt);
                        pfmh->hdpaAlt = NULL;
                    }
                }
                // we assume this is a static object... which it is.
                // psfDesktop->Release();
            }
        }

        if (cItems <= 0 && fMarker)
        {
            // Aborted or no item  s. Put the marker back (if there used
            // to be one).
            FileMenuHeader_InsertMarkerItem(pfmh);
        }
    }

    return cItems;
}


//---------------------------------------------------------------------------
// Delete all the menu items listed in the given header.
UINT
FileMenuHeader_DeleteAllItems(
    IN PFILEMENUHEADER pfmh)
{
    int i;
    int cItems = 0;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER))
    {
        // Notify.
        if (pfmh->pfncb)
            {
            FMCBDATA fmcbdata;

            fmcbdata.lParam = pfmh->lParam;  
            fmcbdata.hmenu = pfmh->hmenu;
            fmcbdata.iPos = 0;
            fmcbdata.idCmd = (UINT)-1;
            fmcbdata.pidlFolder = pfmh->pidlFolder;
            fmcbdata.pidl = NULL;
            fmcbdata.psf = pfmh->psf;
            fmcbdata.pvHeader = pfmh;

            pfmh->pfncb(FMM_DELETEALL, &fmcbdata, 0);
            }

        // Clean up the items.
        cItems = DPA_GetPtrCount(pfmh->hdpa);
        // Do this backwards to stop things moving around as
        // we delete them.
        for (i = cItems - 1; i >= 0; i--)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Does this item have a subfolder?
                if (pfmi->Flags & FMI_FOLDER)
                {
                    // Yep.
                    // Get the submenu for this item.
                    // Delete all it's items.
                    FileMenu_DeleteAllItems(GetSubMenu(pfmh->hmenu, i));
                }
                // Delete the item itself.
                DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
                FileMenuItem_Destroy(pfmi);
                DPA_DeletePtr(pfmh->hdpa, i);
            }
        }
    }
    return cItems;
}

//---------------------------------------------------------------------------
// NB The creator of the filemenu has to explicitly call FileMenu_DAI to free
// up FileMenu items because USER doesn't send WM_DELETEITEM for ownerdraw
// menu. Great eh?
// Returns the number of items deleted.
UINT  FileMenu_DeleteAllItems(HMENU hmenu)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return 0;

    // need to set this guy back to NULL, since it's no longer valid after
    // we delete the menu items.
    g_pfmiLastSelNonFolder = NULL;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
        
        // Save the order if necessary
        if (IsFlagSet(pfmh->fmf, FMF_DIRTY | FMF_CANORDER))
        {
            FileMenu_SaveOrder(pfmh->hmenu);
            ClearFlag(pfmh->fmf, FMF_DIRTY);
        }

        UINT cItems = FileMenuHeader_DeleteAllItems(pfmh);
        FileMenuHeader_Destroy(pfmh);
        return cItems;
    }

    return 0;
}

//---------------------------------------------------------------------------
STDAPI_(void)
FileMenu_Destroy(HMENU hmenu)
{
    TraceMsg(TF_MENU, "Destroying filemenu for %#08x", hmenu);

    FileMenu_DeleteAllItems(hmenu);
    DestroyMenu(hmenu);

    // Reset the menu tracking agent
    g_fsmenuagent.Reset();

    //
    // Delete current global g_hdcMem and g_hfont so they'll be
    // refreshed with current font metrics next time the menu size
    // is calculated.  This is needed in case the menu is being destroyed
    // as part of a system metrics change.
    //
    DeleteGlobalMemDCAndFont();
}


//---------------------------------------------------------------------------
// Cause the given filemenu to be rebuilt.
STDAPI_(void)
FileMenu_Invalidate(HMENU hmenu)
{
    ASSERT(IS_VALID_HANDLE(hmenu, MENU));

    // Is this a filemenu?
    // NB First menu item must be a FileMenuItem.
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

        // Yep, Is there already a marker here?
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            TraceMsg(TF_MENU, "Menu is already invalid.");
        }
        else if (pfmi->pfmh)
        {
            PFILEMENUHEADER pfmhSave = pfmi->pfmh;

            FileMenuHeader_DeleteAllItems(pfmi->pfmh);

            ASSERT(IS_VALID_STRUCT_PTR(pfmhSave, FILEMENUHEADER));

            // above call freed pfmi
            FileMenuHeader_InsertMarkerItem(pfmhSave);
        }
    }
}


//---------------------------------------------------------------------------
// Cause the given filemenu to be marked invalid but don't delete any items
// yet.
void  FileMenu_DelayedInvalidate(HMENU hmenu)
{
    // Is this a filemenu?
    // NB First menu item must be a FileMenuItem.
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi && pfmi->pfmh)
        SetFlag(pfmi->pfmh->fmf, FMF_DELAY_INVALID);
}


BOOL  FileMenu_IsDelayedInvalid(HMENU hmenu)
{
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    return (pfmi && pfmi->pfmh &&
            IsFlagSet(pfmi->pfmh->fmf, FMF_DELAY_INVALID));
}


/*----------------------------------------------------------
Purpose: Compose a file menu.

         Ansi version

Returns: S_OK if all the files were added
         S_FALSE if some did not get added (reached cyMax)
         error on something bad
Cond:    --
*/
STDAPI
FileMenu_ComposeA(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEA * pfmc)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmc, FMCOMPOSEA) &&
        SIZEOF(*pfmc) == pfmc->cbSize)
    {
        FMCOMPOSEA fmc;

        fmc = *pfmc;

        if (IsFlagSet(fmc.dwMask, FMC_STRING))
        {
            // Convert string to pidl
            TCHAR szFolder[MAX_PATH];

#ifdef UNICODE
            MultiByteToWideChar(CP_ACP, 0, fmc.pszFolder, -1, szFolder,
                                SIZECHARS(szFolder));
#else
            lstrcpy(szFolder, fmc.pszFolder);
#endif
            fmc.pidlFolder = ILCreateFromPath(szFolder);
            if (NULL == fmc.pidlFolder)
            {
                hres = E_OUTOFMEMORY;
                goto Bail;
            }
        }
        else if (IsFlagClear(fmc.dwMask, FMC_PIDL))
        {
            // Either FMC_PIDL or FMC_STRING must be set
            hres = E_INVALIDARG;
            goto Bail;
        }

        switch (nMethod)
        {
        case FMCM_INSERT:
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        case FMCM_APPEND:
            hres = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu),
                                     (FMCOMPOSE *)&fmc);
            break;

        case FMCM_REPLACE:
            FileMenu_DeleteAllItems(hmenu);
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        default:
            ASSERT(0);
            goto Bail;
        }

        pfmc->cItems = fmc.cItems;

Bail:
        // Cleanup
        if (IsFlagSet(fmc.dwMask, FMC_STRING) && fmc.pidlFolder)
            ILFree(fmc.pidlFolder);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Compose a file menu.

         Unicode version

Returns:
Cond:    --
*/
STDAPI
FileMenu_ComposeW(
    IN HMENU        hmenu,
    IN UINT         nMethod,
    IN FMCOMPOSEW * pfmc)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmc, FMCOMPOSEW) &&
        SIZEOF(*pfmc) == pfmc->cbSize)
    {
        FMCOMPOSEW fmc;

        fmc = *pfmc;

        if (IsFlagSet(fmc.dwMask, FMC_STRING))
        {
            // Convert string to pidl
            TCHAR szFolder[MAX_PATH];

#ifdef UNICODE
            lstrcpy(szFolder, fmc.pszFolder);
#else
            WideCharToMultiByte(CP_ACP, 0, fmc.pszFolder, -1, szFolder,
                                SIZECHARS(szFolder), NULL, NULL);
#endif
            fmc.pidlFolder = ILCreateFromPath(szFolder);
            if (NULL == fmc.pidlFolder)
            {
                hres = E_OUTOFMEMORY;
                goto Bail;
            }
        }
        else if (IsFlagClear(fmc.dwMask, FMC_PIDL))
        {
            // Either FMC_PIDL or FMC_STRING must be set
            hres = E_INVALIDARG;
            goto Bail;
        }

        switch (nMethod)
        {
        case FMCM_INSERT:
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        case FMCM_APPEND:
            hres = FileMenu_AddFiles(hmenu, GetMenuItemCount(hmenu),
                                     (FMCOMPOSE *)&fmc);
            break;

        case FMCM_REPLACE:
            FileMenu_DeleteAllItems(hmenu);
            hres = FileMenu_AddFiles(hmenu, 0, (FMCOMPOSE *)&fmc);
            break;

        default:
            ASSERT(0);
            goto Bail;
        }

        pfmc->cItems = fmc.cItems;

Bail:
        // Cleanup
        if (IsFlagSet(fmc.dwMask, FMC_STRING) && fmc.pidlFolder)
            ILFree(fmc.pidlFolder);
    }

    return hres;
}


LRESULT FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT *pdi)
{
    int y, x;
    TCHAR szName[MAX_PATH];
    DWORD dwExtent;
    int cxIcon, cyIcon;
    RECT rcBkg;
    HBRUSH hbrOld = NULL;
    UINT cyItem, dyItem;
    HIMAGELIST himl;
    RECT rcClip;

    if ((pdi->itemAction & ODA_SELECT) || (pdi->itemAction & ODA_DRAWENTIRE))
    {
        PFILEMENUHEADER pfmh;
        PFILEMENUITEM pfmi = (PFILEMENUITEM)pdi->itemData;
        IShellFolder * psf;

#ifndef UNIX
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));
#endif
        
        if (!pfmi)
        {
            TraceMsg(TF_ERROR, "FileMenu_DrawItem: Filemenu is invalid (no item data).");
            return FALSE;
        }

        pfmh = pfmi->pfmh;
        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        if (pfmi->Flags & FMI_ALTITEM)
            psf = pfmh->psfAlt;
        else
            psf = pfmh->psf;

        // Adjust for large/small icons.
        if (pfmh->fmf & FMF_LARGEICONS)
        {
            cxIcon = g_cxIcon;
            cyIcon = g_cyIcon;
        }
        else
        {
            cxIcon = g_cxSmIcon;
            cyIcon = g_cxSmIcon;
        }

        // Is the menu just starting to get drawn?
        if (pdi->itemAction & ODA_DRAWENTIRE)
        {
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0))
            {
                // Yes; reset the last selection item
                g_pfmiLastSelNonFolder = NULL;
                g_pfmiLastSel = NULL;

                // Initialize to handle drag and drop?
                if (pfmh->fmf & FMF_CANORDER)
                {
                    // Yes
                    g_fsmenuagent.Init();
                }
            }
        }


        if (pdi->itemState & ODS_SELECTED)
        {
            if (pfmh->fmf & FMF_CANORDER)
            {
                // Pass on the current hDC and selection rect so the 
                // drag/drop hook can actively draw

                RECT rc = pdi->rcItem;
                
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));

                // With no background image, the caret goes all the way 
                // across; otherwise it stops in line with the bitmap.
                if (pfmh->hbmp)
                    rc.left += pfmh->cxBmpGap;

                g_fsmenuagent.SetCurrentRect(pdi->hDC, &rc);
                g_fsmenuagent.SetItem(pfmi);

                // Are we in edit mode?
                if (MenuDD_IsButtonDown())
                {
                    // Yes
                    g_fsmenuagent.SetEditMode(TRUE, DROPEFFECT_MOVE);
                }
            }

            // Determine the selection colors
            //
            // Normal menu colors apply until we are in edit mode, in which
            // case the menu item is drawn unselected and an insertion caret 
            // is drawn above or below the current item.  The exception is 
            // if the item is a cascaded menu item, then we draw it 
            // normally, but also show the insertion caret.  (We do this
            // because Office does this, and also, USER draws the arrow
            // in the selected color always, so it looks kind of funny 
            // if we don't select the menu item.)
            //

            // Is the user dragging and dropping and we're not over
            // a cascaded menu item?
            if ((pfmh->fmf & FMF_CANORDER) && MenuDD_InEditMode() &&
                !(pfmi->Flags & FMI_FOLDER))
            {
                // Yes; show the item in the unselected colors
                // (dwRop = SRCAND)
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
            }
            else
            {
                // No
                SetBkColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
                SetTextColor(pdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
                hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_HIGHLIGHTTEXT));
            }

            // REVIEW HACK NB - keep track of the last selected item.
            // NB The keyboard handler needs to know about all selections
            // but the WM_COMMAND stuff only cares about non-folders.
            g_pfmiLastSel = pfmi;
            if (!(pfmi->Flags & FMI_FOLDER))
                g_pfmiLastSelNonFolder = pfmi;
            // Get the rect of the item in screen coords.
            g_rcItem = pdi->rcItem;
            MapWindowPoints(WindowFromDC(pdi->hDC), NULL, (LPPOINT)&g_rcItem, 2);
        }
        else
        {
            // dwRop = SRCAND;
            hbrOld = SelectBrush(pdi->hDC, GetSysColorBrush(COLOR_MENUTEXT));
        }

        // Initial start pos.
        x = pdi->rcItem.left+CXIMAGEGAP;

        // Draw the background image.
        if (pfmh->hbmp)
        {
            // Draw it the first time the first item paints.
            if (pfmi == DPA_GetPtr(pfmh->hdpa, 0) &&
                (pdi->itemAction & ODA_DRAWENTIRE))
            {
                if (!g_hdcMem)
                {
                    g_hdcMem = CreateCompatibleDC(pdi->hDC);
                    ASSERT(g_hdcMem);
                }
                if (g_hdcMem)
                {
                    HBITMAP hbmOld;

                    if (!pfmh->yBmp)
                    {
                        GetClipBox(pdi->hDC, &rcClip);
                        pfmh->yBmp = rcClip.bottom;
                    }
                    hbmOld = SelectBitmap(g_hdcMem, pfmh->hbmp);
                    BitBlt(pdi->hDC, 0, pfmh->yBmp-pfmh->cyBmp, pfmh->cxBmp, pfmh->cyBmp, g_hdcMem, 0, 0, SRCCOPY);
                    SelectBitmap(g_hdcMem, hbmOld);
                }
            }
            x += pfmh->cxBmpGap;
        }

        // Background color for when the bitmap runs out.
        if ((pfmh->clrBkg != (COLORREF)-1) &&
            (pfmi == DPA_GetPtr(pfmh->hdpa, 0)) &&
            (pdi->itemAction & ODA_DRAWENTIRE))
        {
            HBRUSH hbr;

            if (!pfmh->yBmp)
            {
                GetClipBox(pdi->hDC, &rcClip);
                pfmh->yBmp = rcClip.bottom;
            }
            rcBkg.top = 0;
            rcBkg.left = 0;
            rcBkg.bottom = pfmh->yBmp - pfmh->cyBmp;
            rcBkg.right = max(pfmh->cxBmp, pfmh->cxBmpGap);
            hbr = CreateSolidBrush(pfmh->clrBkg);
            if (hbr)
            {
                FillRect(pdi->hDC, &rcBkg, hbr);
                DeleteObject(hbr);
            }
        }

        // Special case the separator.
        if (pfmi->Flags & FMI_SEPARATOR)
        {
            // With no background image it goes all the way across otherwise
            // it stops in line with the bitmap.
            if (pfmh->hbmp)
                pdi->rcItem.left += pfmh->cxBmpGap;
            pdi->rcItem.bottom = (pdi->rcItem.top+pdi->rcItem.bottom)/2;
            DrawEdge(pdi->hDC, &pdi->rcItem, EDGE_ETCHED, BF_BOTTOM);
            // Early out.
            goto ExitProc;
        }

        // Have the selection not include the icon to speed up drawing while
        // tracking.
        pdi->rcItem.left += pfmh->cxBmpGap;

        // Get the name.
        FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));

        // Limit the width of the text?
        if (0 < pfmh->cxMax)
        {
            // Yes
            PathCompactPath(pdi->hDC, szName, pfmh->cxMax);
        }

        // NB Keep a plain copy of the name for testing and accessibility.
        if (!pfmi->psz)
            Sz_AllocCopy(szName, &(pfmi->psz));

        dwExtent = GetItemTextExtent(pdi->hDC, szName);
        y = (pdi->rcItem.bottom+pdi->rcItem.top-HIWORD(dwExtent))/2;
        // Support custom heights for the selection rectangle.
        if (pfmh->cySel)
        {
            cyItem = pdi->rcItem.bottom-pdi->rcItem.top;
            // Is there room?
            if ((cyItem > pfmh->cySel) && (pfmh->cySel > HIWORD(dwExtent)))
            {
                dyItem = (cyItem-pfmh->cySel)/2;
                pdi->rcItem.top += dyItem ;
                pdi->rcItem.bottom -= dyItem;
            }
        }
        else if(!(pfmh->fmf & FMF_LARGEICONS))
        {
            // Shrink the selection rect for small icons a bit.
            pdi->rcItem.top += 1;
            pdi->rcItem.bottom -= 1;
        }


        // Draw the text.

        int fDSFlags;

        if (pfmi->Flags & FMI_IGNORE_PIDL)
        {
            //
            // If the string is not coming from a pidl,
            // we can format the menu text.
            //
            fDSFlags = DST_PREFIXTEXT;
        }
        else if ((pfmi->Flags & FMI_ON_MENU) == 0)
        {
            //
            // Norton Desktop Navigator 95 replaces the Start->&Run
            // menu item with a &Run pidl.  Even though the text is
            // from a pidl, we still want to format the "&R" correctly.
            //
            fDSFlags = DST_PREFIXTEXT;
        }
        else
        {
            //
            // All other strings coming from pidls are displayed
            // as is to preserve any & in their display name.
            //
            fDSFlags = DST_TEXT;
        }

        if ((pfmi->Flags & FMI_EMPTY) || (pfmi->Flags & FMI_DISABLED))
        {
            if (pdi->itemState & ODS_SELECTED)
            {
                if (GetSysColor(COLOR_GRAYTEXT) == GetSysColor(COLOR_HIGHLIGHTTEXT))
                {
                    fDSFlags |= DSS_UNION;
                }
                else
                {
                    SetTextColor(pdi->hDC, GetSysColor(COLOR_GRAYTEXT));
                }
            }
            else
            {
                fDSFlags |= DSS_DISABLED;
            }

            ExtTextOut(pdi->hDC, 0, 0, ETO_OPAQUE, &pdi->rcItem, NULL, 0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x+cxIcon+CXIMAGEGAP,
                y, 0, 0, fDSFlags);
        }
        else
        {
            ExtTextOut(pdi->hDC, x+cxIcon+CXIMAGEGAP, y, ETO_OPAQUE, &pdi->rcItem, NULL,
                0, NULL);
            DrawState(pdi->hDC, NULL, NULL, (LONG_PTR)szName, lstrlen(szName), x+cxIcon+CXIMAGEGAP,
                y, 0, 0, fDSFlags);
        }

        // Get the image if it needs it,
        if ((pfmi->iImage == -1) && pfmi->pidl && psf &&
            IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
        {
            pfmi->iImage = SHMapPIDLToSystemImageListIndex(psf, pfmi->pidl, NULL);
        }

        // Draw the image (if there is one).
        if (pfmi->iImage != -1)
        {
            int nDC = 0;

            // Try to center image.
            y = (pdi->rcItem.bottom+pdi->rcItem.top-cyIcon)/2;

            if (pfmh->fmf & FMF_LARGEICONS)
            {
                himl = g_himlIcons;
                // Handle minor drawing glitches that can occur with large icons.
                if ((pdi->itemState & ODS_SELECTED) && (y < pdi->rcItem.top))
                {
                    nDC = SaveDC(pdi->hDC);
                    IntersectClipRect(pdi->hDC, pdi->rcItem.left, pdi->rcItem.top,
                        pdi->rcItem.right, pdi->rcItem.bottom);
                }
            }
            else
            {
                himl = g_himlIconsSmall;
            }

            ImageList_DrawEx(himl, pfmi->iImage, pdi->hDC, x, y, 0, 0,
                GetBkColor(pdi->hDC), CLR_NONE, ILD_NORMAL);

            // Restore the clip rect if we were doing custom clipping.
            if (nDC)
                RestoreDC(pdi->hDC, nDC);
        }

        // Is the user dragging and dropping onto an item that accepts
        // a drop?
        if ((pfmh->fmf & FMF_CANORDER) && 
            (pdi->itemState & ODS_SELECTED) &&
            MenuDD_InEditMode() && 
            (pfmi->dwEffect & g_fsmenuagent.GetDragEffect()))
        {
            // Yes; draw the insertion caret 
            RECT rc = pdi->rcItem;
            POINT pt;

            // We actively draw the insertion caret on mouse moves.
            // When the cursor moves between menu items, the msg hook
            // does not get a mouse move until after this paint.  But
            // we need to update the caret position correctly, so do
            // it here too.
            GetCursorPos(&pt);
            g_fsmenuagent.SetCaretPos(&pt);

            rc.left += 4;
            rc.right -= 8;

            TraceMsg(TF_MENU, "MenuDD:  showing caret %s", MenuDD_InsertAbove() ? TEXT("above") : TEXT("below"));

            if (MenuDD_InsertAbove())
            {
                // Hide any existing caret
                HBRUSH hbrSav = SelectBrush(pdi->hDC, MenuDD_GetBrush());
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.bottom - 2, (rc.right - rc.left), 2, PATCOPY);
                SelectBrush(pdi->hDC, hbrSav);
                
                // Show caret in new position
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.top, (rc.right - rc.left), 2, BLACKNESS);
            }
            else
            {
                // Hide any existing caret
                HBRUSH hbrSav = SelectBrush(pdi->hDC, MenuDD_GetBrush());
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.top, (rc.right - rc.left), 2, PATCOPY);
                SelectBrush(pdi->hDC, hbrSav);
                
                // Show caret in new position
                PatBlt(pdi->hDC, rc.left, pdi->rcItem.bottom - 2, (rc.right - rc.left), 2, BLACKNESS);
            }
        }
    }

ExitProc:
    // Cleanup.
    if (hbrOld)
        SelectObject(pdi->hDC, hbrOld);

    return TRUE;
}


DWORD FileMenuItem_GetExtent(PFILEMENUITEM pfmi)
{
    DWORD dwExtent = 0;

    if (pfmi)
    {
        if (pfmi->Flags & FMI_SEPARATOR)
        {
            dwExtent = MAKELONG(0, GetSystemMetrics(SM_CYMENUSIZE)/2);
        }
        else
        {
            PFILEMENUHEADER pfmh = pfmi->pfmh;

            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

            if (!g_hdcMem)
            {
                g_hdcMem = CreateCompatibleDC(NULL);
                ASSERT(g_hdcMem);
            }
            if (g_hdcMem)
            {
                // Get the rough height of an item so we can work out when to break the
                // menu. User should really do this for us but that would be useful.
                if (!g_hfont)
                {
                    NONCLIENTMETRICS ncm;
                    ncm.cbSize = SIZEOF(ncm);
                    if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, SIZEOF(ncm), &ncm, FALSE))
                    {
                        g_hfont = CreateFontIndirect(&ncm.lfMenuFont);
                        ASSERT(g_hfont);
                    }
                }

                if (g_hfont)
                {
                    HFONT hfontOld = SelectFont(g_hdcMem, g_hfont);
                    dwExtent = GetItemExtent(g_hdcMem, pfmi);
                    SelectFont(g_hdcMem, hfontOld);
                    // NB We hang on to the font, it'll get stomped by
                    // FM_TPME on the way out.
                }
                // NB We hang on to the DC, it'll get stomped by FM_TPME on the way out.
            }
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "FileMenu_GetExtent: Filemenu is invalid.");
    }

    return dwExtent;
}


LRESULT FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT *lpmi)
{
    DWORD dwExtent = FileMenuItem_GetExtent((PFILEMENUITEM)lpmi->itemData);
    lpmi->itemHeight = HIWORD(dwExtent);
    lpmi->itemWidth = LOWORD(dwExtent);

    return TRUE;
}


STDAPI_(DWORD)
FileMenu_GetItemExtent(HMENU hmenu, UINT iItem)
{
    DWORD dwRet = 0;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

    if (pfmh)
        dwRet = FileMenuItem_GetExtent((PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem));

    return dwRet;
}

//----------------------------------------------------------------------------
STDAPI_(HMENU)
FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidlFS)
{
    PFILEMENUHEADER pfmh;
    int i;

    if (!pidlFS)
    {
        ASSERT(0);
        return NULL;
    }
    if (ILIsEmpty(pidlFS))
        return hmenu;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        int cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = cItems - 1 ; i >= 0; i--)
        {
            // HACK: We directly call this FS function to compare two pidls.
            // For all items, see if it's the one we're looking for.
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);

            if (pfmi && pfmi->pidl && IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL) &&
                0 == pfmh->psf->CompareIDs(0, pidlFS, pfmi->pidl))
            {
                HMENU hmenuSub;

                if ((pfmi->Flags & FMI_FOLDER) &&
                    (NULL != (hmenuSub = GetSubMenu(hmenu, i))))
                {
                    // recurse to find the next sub menu
                    return FileMenu_FindSubMenuByPidl(hmenuSub, (LPITEMIDLIST)ILGetNext(pidlFS));

                }
                else
                {
                    ASSERT(0); // we're in trouble.
                    break;
                }
            }
        }
    }
    return NULL;
}


/*----------------------------------------------------------
Purpose: Fills the given filemenu with contents of the appropriate
         directory.

Returns: S_OK if all the files were added
         S_FALSE if some did not get added (reached cyMax)
         error on something bad
Cond:    --
*/
STDAPI
FileMenu_InitMenuPopupEx(
    IN     HMENU   hmenu,
    IN OUT PFMDATA pfmdata)
{
    HRESULT hres = E_INVALIDARG;
    PFILEMENUITEM pfmi;
    PFILEMENUHEADER pfmh;

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));

    if (IS_VALID_WRITE_PTR(pfmdata, FMDATA) &&
        SIZEOF(*pfmdata) == pfmdata->cbSize)
    {
        hres = E_FAIL;      // assume error

        g_fAbortInitMenu = FALSE;

        // Is this a filemenu?
        pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
        if (pfmi)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

            pfmh = pfmi->pfmh;
            if (pfmh)
            {
                // Yes
                if (IsFlagSet(pfmh->fmf, FMF_DELAY_INVALID))
                {
                    FileMenu_Invalidate(hmenu);
                    ClearFlag(pfmh->fmf, FMF_DELAY_INVALID);
                }
                
                // (scotth): this can return S_OK but not
                // set the cItems field if this menu has already
                // been filled out.

                hres = S_OK;

                // Have we already filled this thing out?
                if (IsFlagSet(pfmi->Flags, FMI_MARKER | FMI_EXPAND))
                {
                    // No, do it now.  Get the previously init'ed header.
                    FileMenuHeader_DeleteMarkerItem(pfmh);

                    // Fill it full of stuff.
                    hres = FileMenuHeader_AddFiles(pfmh, 0, 0, &pfmdata->cItems);
                    if (E_ABORT == hres)
                    {
                        // Aborted - put the marker back.
                        FileMenuHeader_InsertMarkerItem(pfmh);
                    }
                    else if (pfmh->pidlAltFolder) 
                    {
                        pfmh->hdpaAlt = DPA_Create(0);

                        if (pfmh->hdpaAlt) 
                        {
                            int cItems;

                            if (E_ABORT == FileMenuHeader_AddFiles(pfmh, 0,
                                           FMHAF_SEPARATOR | FMHAF_USEALT,
                                           &cItems))
                            {
                               // Aborted - put the marker back.
                               FileMenuHeader_InsertMarkerItem(pfmh);
                            }

                            DPA_Destroy (pfmh->hdpaAlt);
                            pfmh->hdpaAlt = NULL;
                        }
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Fills the given filemenu with contents of the appropriate
         directory.

Returns: FALSE if the given menu isn't a filemenu
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_InitMenuPopup(
    IN HMENU hmenu)
{
    FMDATA fmdata = {SIZEOF(fmdata)};   // zero init everything else
    return SUCCEEDED(FileMenu_InitMenuPopupEx(hmenu, &fmdata));
}


BOOL FileMenu_IsUnexpanded(HMENU hmenu)
{
    BOOL fRet = FALSE;
    PFILEMENUITEM pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    if (pfmi)
    {
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            fRet = TRUE;
        }
    }

    return fRet;
}


//---------------------------------------------------------------------------
// This sets whether to load all the images while creating the menu or to
// defer it until the menu is actually being drawn.
STDAPI_(void)
FileMenu_AbortInitMenu(void)
{
    g_fAbortInitMenu = TRUE;
}


/*----------------------------------------------------------
Purpose: Returns a clone of the last selected pidl

Returns: 
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_GetLastSelectedItemPidls(
    IN  HMENU          hmenu, 
    OUT LPITEMIDLIST * ppidlFolder,         OPTIONAL
    OUT LPITEMIDLIST * ppidlItem)           OPTIONAL
{
    BOOL bRet    = FALSE;
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlItem = NULL;

    // FEATURE (scotth): this global should be moved into the 
    //  instance data of the header.
    if (g_pfmiLastSelNonFolder)
    {
        // Get to the header.
        PFILEMENUHEADER pfmh = g_pfmiLastSelNonFolder->pfmh;
        if (pfmh)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
            
            bRet = TRUE;

            if (ppidlFolder)
            {
                if (g_pfmiLastSelNonFolder->Flags & FMI_ALTITEM)
                    pidlFolder = ILClone(pfmh->pidlAltFolder);
                else
                    pidlFolder = ILClone(pfmh->pidlFolder);
                bRet = (NULL != pidlFolder);
            }

            if (bRet && ppidlItem)
            {
                if (g_pfmiLastSelNonFolder->pidl)
                {
                    pidlItem = ILClone(g_pfmiLastSelNonFolder->pidl);
                    bRet = (NULL != pidlItem);
                }
                else
                    bRet = FALSE;
            }

            if (!bRet)
            {
                if (pidlFolder)
                {
                    // Failed; free the pidl we just allocated
                    ILFree(pidlFolder);
                    pidlFolder = NULL;
                }
            }
        }
    }

    // Init because callers get lazy and don't pay attention to the return
    // value.
    if (ppidlFolder)
        *ppidlFolder = pidlFolder;
    if (ppidlItem)
        *ppidlItem = pidlItem;
    
    if (!bRet)
        TraceMsg(TF_WARNING, "No previously selected item.");

    return bRet;
}


/*----------------------------------------------------------
Purpose: Returns the command ID and hmenu of the last selected
         menu item.  The given hmenuRoot is the parent hmenu
         that must be a FileMenu.

Returns: S_OK 
         S_FALSE if there was no last selected item
Cond:    --
*/
STDAPI
FileMenu_GetLastSelectedItem(
    IN  HMENU   hmenu, 
    OUT HMENU * phmenu,         OPTIONAL
    OUT UINT *  puItem)         OPTIONAL
{
    HRESULT hres = S_FALSE;

    if (phmenu)
        *phmenu = NULL;
    if (puItem)
        *puItem = 0;

    if (g_pfmiLastSelNonFolder)
    {
        // Get to the header.
        PFILEMENUHEADER pfmh = g_pfmiLastSelNonFolder->pfmh;
        if (pfmh)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

            if (phmenu)
                *phmenu = pfmh->hmenu;

            if (puItem)
            {
                // (scotth): this isn't stored right now
                ASSERT(0);
            }
            hres = S_OK;
        }
    }

    return hres;
}


int FileMenuHeader_LastSelIndex(PFILEMENUHEADER pfmh)
{
    int i;
    PFILEMENUITEM pfmi;

    for (i = GetMenuItemCount(pfmh->hmenu)-1;i >= 0; i--)
    {
        pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi && (pfmi == g_pfmiLastSel))
            return i;
    }
    return -1;
}


//---------------------------------------------------------------------------
// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    LPTSTR pchAS;

    // Find the first ampersand.
    pchAS = StrChr(lpsz, TEXT('&'));
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (CharUpperChar(*CharNext(pchAS)) == CharUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (CharUpperChar(*lpsz) == CharUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}


STDAPI_(LRESULT)
FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch)
{
    UINT iItem, cItems, iStep;
    PFILEMENUITEM pfmi;
    int iFoundOne;
    TCHAR szName[MAX_PATH];
    PFILEMENUHEADER pfmh;

    iFoundOne = -1;
    iStep = 0;
    iItem = 0;
    cItems = GetMenuItemCount(hmenu);

    // Start from the last place we looked from.
    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        iItem = FileMenuHeader_LastSelIndex(pfmh) + 1;
        if (iItem >= cItems)
            iItem = 0;
    }

    while (iStep < cItems)
    {
        pfmi = FileMenu_GetItemData(hmenu, iItem, TRUE);
        if (pfmi)
        {
            BOOL bIgnoreAmpersand = (pfmi->pidl && IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL));

            FileMenuItem_GetDisplayName(pfmi, szName, ARRAYSIZE(szName));
            if (_MenuCharMatch(szName, ch, bIgnoreAmpersand))
            {
                // Found (another) match.
                if (iFoundOne != -1)
                {
                    // More than one, select the first.
                    return MAKELRESULT(iFoundOne, MNC_SELECT);
                }
                else
                {
                    // Found at least one.
                    iFoundOne = iItem;
                }
            }

        }
        iItem++;
        iStep++;
        // Wrap.
        if (iItem >= cItems)
            iItem = 0;
    }

    // Did we find one?
    if (iFoundOne != -1)
    {
        // Just in case the user types ahead without the selection being drawn.
        pfmi = FileMenu_GetItemData(hmenu, iFoundOne, TRUE);
        if (!(pfmi->Flags & FMI_FOLDER))
            g_pfmiLastSelNonFolder = pfmi;

        return MAKELRESULT(iFoundOne, MNC_EXECUTE);
    }
    else
    {
        // Didn't find it.
        return MAKELRESULT(0, MNC_IGNORE);
    }
}


/*----------------------------------------------------------
Purpose: Create a filemenu from a given normal menu

Returns:
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_CreateFromMenu(
    IN HMENU    hmenu,
    IN COLORREF clr,
    IN int      cxBmpGap,
    IN HBITMAP  hbmp,
    IN int      cySel,
    IN DWORD    fmf)
{
    BOOL fRet = FALSE;

    if (hmenu)
    {
        PFILEMENUHEADER pfmh = FileMenuHeader_Create(hmenu, hbmp, cxBmpGap, clr, cySel, NULL);

        if (!g_himlIcons || !g_himlIconsSmall)
            Shell_GetImageLists(&g_himlIcons, &g_himlIconsSmall);

        if (pfmh)
        {
            // Default flags.
            pfmh->fmf = fmf;
            if (FileMenuHeader_InsertMarkerItem(pfmh))
                fRet = TRUE;
            else
            {
                // REARCHITECT: (scotth): FileMenuHeader_Create can return a pointer
                //  that is already stored in a filemenu item, in which case this
                //  destroy will stomp a data structure.
                TraceMsg(TF_ERROR, "Can't create file menu.");
                FileMenuHeader_Destroy(pfmh);
            }
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "Menu is null.");
    }

    return fRet;
}


HMENU  FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, DWORD fmf)
{
    HMENU hmenuRet = NULL;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        if (FileMenu_CreateFromMenu(hmenu, clr, cxBmpGap, hbmp, cySel, fmf))
            hmenuRet = hmenu;
        else
            DestroyMenu(hmenu);
    }

    return hmenuRet;
}


/*----------------------------------------------------------
Purpose: Insert a generic item into a filemenu

Returns:
Cond:    --
*/
STDAPI
FileMenu_InsertItemEx(
    IN HMENU          hmenu,
    IN UINT           iPos,
    IN FMITEM const * pfmitem)
{
    HRESULT hres = E_INVALIDARG;
    PFILEMENUITEM pfmi;
    FMITEM fmitem;

    // Is this a filemenu?
    pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);

    if (IsValidFMItem(pfmitem, &fmitem) && pfmi)
    {
        // Yes
        PFILEMENUHEADER pfmh = pfmi->pfmh;

        ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));

        // Have we cleaned up the marker item?
        if ((pfmi->Flags & FMI_MARKER) && (pfmi->Flags & FMI_EXPAND))
        {
            // Nope, do it now.
            FileMenuHeader_DeleteMarkerItem(pfmh);
        }

        hres = E_OUTOFMEMORY;

        // Add the new item.
        if (FileMenuItem_Create(pfmh, NULL, fmitem.iImage, 0, &pfmi))
        {
            if (fmitem.pvData && IsFlagSet(fmitem.dwType, FMIT_STRING))
            {
                if (!Sz_AllocCopy((LPTSTR)fmitem.pvData, &(pfmi->psz)))
                    TraceMsg(TF_ERROR, "Unable to allocate menu item text.");
                pfmi->Flags |= FMI_IGNORE_PIDL;
            }
            pfmi->cyItem = fmitem.cyItem;
            pfmi->lParam = fmitem.lParam;
            DPA_InsertPtr(pfmh->hdpa, iPos, pfmi);

            if (IsFlagSet(fmitem.dwType, FMIT_SEPARATOR))
            {
                // Override the setting made above, since separator and
                // text are mutually exclusive
                pfmi->Flags = FMI_SEPARATOR;
                InsertMenu(hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW|MF_DISABLED|MF_SEPARATOR, 
                           fmitem.uID, (LPTSTR)pfmi);
            }
            else if (fmitem.hmenuSub)
            {
                MENUITEMINFO mii;

                pfmi->Flags |= FMI_FOLDER;
                if ((iPos == 0xffff) || (iPos == 0xffffffff))
                    iPos = GetMenuItemCount(pfmh->hmenu);

                InsertMenu(pfmh->hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW|MF_POPUP, 
                           (UINT_PTR)fmitem.hmenuSub, (LPTSTR)pfmi);
                // Set it's ID.
                mii.cbSize = SIZEOF(mii);
                mii.fMask = MIIM_ID;
                // mii.wID = pfmh->idCmd;
                mii.wID = fmitem.uID;
                SetMenuItemInfo(pfmh->hmenu, iPos, TRUE, &mii);
            }
            else
            {
                InsertMenu(hmenu, iPos, MF_BYPOSITION|MF_OWNERDRAW, 
                           fmitem.uID, (LPTSTR)pfmi);
            }

            hres = S_OK;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Old function to insert a generic item onto a filemenu

Returns:
Cond:    --
*/
STDAPI_(BOOL)
FileMenu_InsertItem(
    IN HMENU  hmenu,
    IN LPTSTR psz,
    IN UINT   id,
    IN int    iImage,
    IN HMENU  hmenuSub,
    IN UINT   cyItem,
    IN UINT   iPos)
{
    FMITEM fmitem;

    fmitem.cbSize = SIZEOF(fmitem);
    fmitem.dwMask = FMI_TYPE | FMI_ID | FMI_IMAGE | FMI_HMENU |
                    FMI_METRICS;

    if ((LPTSTR)FMAI_SEPARATOR == psz)
    {
        fmitem.dwType = FMIT_SEPARATOR;
    }
    else if (NULL == psz)
    {
        fmitem.dwType = 0;
    }
    else
    {
        fmitem.dwType = FMIT_STRING;
#ifdef UNICODE
        fmitem.dwType |= FMIT_UNICODE;
#endif

        fmitem.dwMask |= FMI_DATA;
        fmitem.pvData = psz;
    }

    fmitem.uID = id;
    fmitem.iImage = iImage;
    fmitem.hmenuSub = hmenuSub;
    fmitem.cyItem = cyItem;

    return SUCCEEDED(FileMenu_InsertItemEx(hmenu, iPos, &fmitem));
}


/*----------------------------------------------------------
Purpose: Get info about this filemenu item.

*/
STDAPI
FileMenu_GetItemInfo(
    IN  HMENU   hmenu,
    IN  UINT    uItem,
    IN  BOOL    bByPos,
    OUT PFMITEM pfmitem)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(pfmitem, FMITEM) &&
        SIZEOF(*pfmitem) == pfmitem->cbSize)
    {
        PFILEMENUITEM pfmi;

        hres = E_FAIL;

        pfmi = FileMenu_GetItemData(hmenu, uItem, bByPos);
        if (pfmi)
        {
            // (scotth): we don't fill in all the fields
            
            if (IsFlagSet(pfmitem->dwMask, FMI_LPARAM))
                pfmitem->lParam = pfmi->lParam;
            
            hres = S_OK;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Save the order of the menu to the given stream.

*/
STDAPI
FileMenu_SaveOrder(HMENU hmenu)
{
    HRESULT hres = E_FAIL;
    PFILEMENUITEM pfmi;
    IStream * pstm;

    pfmi = FileMenu_GetItemData(hmenu, 0, TRUE);
    if (pfmi && FileList_GetStream(pfmi->pfmh, &pstm))
    {
        hres = FileList_Save(pfmi->pfmh, pstm);
        pstm->Release();
    }

    return hres;
}


STDAPI_(BOOL)
FileMenu_AppendItem(HMENU hmenu, LPTSTR psz, UINT id, int iImage,
    HMENU hmenuSub, UINT cyItem)
{
    return FileMenu_InsertItem(hmenu, psz, id, iImage, hmenuSub, cyItem, 0xffff);
}


STDAPI_(BOOL)
FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y,
    HWND hwndOwner, LPTPMPARAMS lpTpm)
{
    BOOL fRet = TrackPopupMenuEx(hmenu, Flags, x, y, hwndOwner, lpTpm);
    // Cleanup.

    DeleteGlobalMemDCAndFont();

    return fRet;
}


//----------------------------------------------------------------------------
// Like Users only this works on submenu's too.
// NB Returns 0 for seperators.
UINT FileMenu_GetMenuItemID(HMENU hmenu, UINT iItem)
{
    MENUITEMINFO mii;

    mii.cbSize = SIZEOF(MENUITEMINFO);
    mii.fMask = MIIM_ID;
    mii.cch = 0;     // just in case

    if (GetMenuItemInfo(hmenu, iItem, TRUE, &mii))
        return mii.wID;

    return 0;
}


PFILEMENUITEM  _FindItemByCmd(PFILEMENUHEADER pfmh, UINT id, int *piPos)
{
    if (pfmh)
    {
        int cItems, i;

        cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = 0; i < cItems; i++)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Is this the right item?
                // NB This ignores menu items.
                if (id == GetMenuItemID(pfmh->hmenu, i))
                {
                    // Yep.
                    if (piPos)
                        *piPos = i;
                    return pfmi;
                }
            }
        }
    }
    return NULL;
}


PFILEMENUITEM  _FindMenuOrItemByCmd(PFILEMENUHEADER pfmh, UINT id, int *piPos)
{
    if (pfmh)
    {
        int cItems, i;

        cItems = DPA_GetPtrCount(pfmh->hdpa);
        for (i = 0; i < cItems; i++)
        {
            PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, i);
            if (pfmi)
            {
                // Is this the right item?
                // NB This includes menu items.
                if (id == FileMenu_GetMenuItemID(pfmh->hmenu, i))
                {
                    // Yep.
                    if (piPos)
                        *piPos = i;
                    return pfmi;
                }
            }
        }
    }
    return NULL;
}


//----------------------------------------------------------------------------
// NB This deletes regular items or submenus.
STDAPI_(BOOL)
FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        int i;
        PFILEMENUITEM pfmi = _FindMenuOrItemByCmd(pfmh, id, &i);
        if (pfmi)
        {
            // If it's a submenu, delete it's items first.
            HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);
            if (hmenuSub)
                FileMenu_DeleteAllItems(hmenuSub);
            // Delete the item itself.
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iItem);
        if (pfmi)
        {
            // Delete the item itself.
            DeleteMenu(pfmh->hmenu, iItem, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, iItem);
            return TRUE;
        }
    }
    return FALSE;
}


//---------------------------------------------------------------------------
// Search for the first sub menu of the given menu, who's first item's ID
// is id. Returns NULL, if nothing is found.
HMENU _FindMenuItemByFirstID(HMENU hmenu, UINT id, int *pi)
{
    int cMax, c;
    MENUITEMINFO mii;

    ASSERT(hmenu);

    // Search all items.
    mii.cbSize = SIZEOF(mii);
    mii.fMask = MIIM_ID;
    mii.cch = 0;     // just in case

    cMax = GetMenuItemCount(hmenu);
    for (c=0; c<cMax; c++)
    {
        // Is this item a submenu?
        HMENU hmenuSub = GetSubMenu(hmenu, c);
        if (hmenuSub && GetMenuItemInfo(hmenuSub, 0, TRUE, &mii))
        {
            if (mii.wID == id)
            {
                // Found it!
                if (pi)
                    *pi = c;
                return hmenuSub;
            }
        }
    }

    return NULL;
}


STDAPI_(BOOL)
FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id)
{
    int i;
    PFILEMENUITEM pfmi;
    PFILEMENUHEADER pfmh;
    HMENU hmenuSub;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        hmenuSub = _FindMenuItemByFirstID(hmenu, id, &i);
        if (hmenuSub && i)
        {
            // Delete the submenu.
            FileMenu_DeleteAllItems(hmenuSub);
            // Delete the item itself.
            pfmi = FileMenu_GetItemData(hmenu, i, TRUE);
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            FileMenuItem_Destroy(pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_DeleteSeparator(HMENU hmenu)
{
    int i;
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = _FindItemByCmd(pfmh, 0, &i);
        if (pfmi)
        {
            // Yep.
            DeleteMenu(pfmh->hmenu, i, MF_BYPOSITION);
            if (pfmi->pidl)
                ILFree(pfmi->pidl);
            LocalFree((HLOCAL)pfmi);
            DPA_DeletePtr(pfmh->hdpa, i);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(BOOL)
FileMenu_InsertSeparator(HMENU hmenu, UINT iPos)
{
    return FileMenu_InsertItem(hmenu, (LPTSTR)FMAI_SEPARATOR, 0, -1, NULL, 0, iPos);
}


STDAPI_(BOOL)
FileMenu_IsFileMenu(HMENU hmenu)
{
    return FileMenu_GetHeader(hmenu) ? TRUE : FALSE;
}


STDAPI_(BOOL)
FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable)
{
    PFILEMENUHEADER pfmh;

    if (!IsMenu(hmenu))
        return FALSE;

    if (!id)
        return FALSE;

    pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = _FindItemByCmd(pfmh, id, NULL);
        if (pfmi)
        {
            if (fEnable)
            {
                pfmi->Flags &= ~FMI_DISABLED;
                EnableMenuItem(pfmh->hmenu, id, MF_BYCOMMAND | MF_ENABLED);
            }
            else
            {
                pfmi->Flags |= FMI_DISABLED;
                EnableMenuItem(pfmh->hmenu, id, MF_BYCOMMAND | MF_GRAYED);
            }
            return TRUE;
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "Menu is not a filemenu.");
    }

    return FALSE;
}


STDAPI_(BOOL)
FileMenu_GetPidl(HMENU hmenu, UINT iPos, LPITEMIDLIST *ppidl)
{
    BOOL fRet = FALSE;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);
    if (pfmh)
    {
        PFILEMENUITEM pfmi = (PFILEMENUITEM)DPA_GetPtr(pfmh->hdpa, iPos);
        if (pfmi)
        {
            if (pfmh->pidlFolder && pfmi->pidl && 
                IsFlagClear(pfmi->Flags, FMI_IGNORE_PIDL))
            {
                *ppidl = ILCombine(pfmh->pidlFolder, pfmi->pidl);
                fRet = TRUE;
            }
        }
    }

    return fRet;
}


BOOL Tooltip_Create(HWND *phwndTip)
{
    BOOL fRet = FALSE;

    *phwndTip = CreateWindow(TOOLTIPS_CLASS, NULL, WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, HINST_THISDLL, NULL);
    if (*phwndTip)
    {
        TOOLINFO ti;

        ti.cbSize = SIZEOF(ti);
        ti.uFlags = TTF_TRACK;
        ti.hwnd = NULL;
        ti.uId = 0;
        ti.lpszText = NULL;
        ti.hinst = HINST_THISDLL;
        SetRectEmpty(&ti.rect);
        SendMessage(*phwndTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
        fRet = TRUE;
    }

    return fRet;
}


void Tooltip_SetText(HWND hwndTip, LPCTSTR pszText)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.uFlags = 0;
        ti.hwnd = NULL;
        ti.uId = 0;
        ti.lpszText = (LPTSTR)pszText;
        ti.hinst = HINST_THISDLL;
        SendMessage(hwndTip, TTM_UPDATETIPTEXT, 0, (LPARAM)(LPTOOLINFO)&ti);
    }
}


void Tooltip_Hide(HWND hwndTip)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.hwnd = NULL;
        ti.uId = 0;
        SendMessage(hwndTip, TTM_TRACKACTIVATE, FALSE, (LPARAM)&ti);
    }
}


void Tooltip_Show(HWND hwndTip)
{
    if (hwndTip)
    {
        TOOLINFO ti;
        ti.cbSize = SIZEOF(ti);
        ti.hwnd = NULL;
        ti.uId = 0;
        SendMessage(hwndTip, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);
        SetWindowPos(hwndTip, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE);
    }
}


void Tooltip_SetPos(HWND hwndTip, int x, int y)
{
    ASSERT(IsWindow(hwndTip));

    SendMessage(hwndTip, TTM_TRACKPOSITION, 0, MAKELPARAM(x, y));
}


/*----------------------------------------------------------
Purpose: Ask the callback for a tooltip.

Returns:
Cond:    --
*/
void
FileMenuItem_GetTooltip(
    IN PFILEMENUITEM pfmi)
{
    ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

    PFILEMENUHEADER pfmh = pfmi->pfmh;

    if (pfmh->pfncb)
    {
        FMCBDATA fmcbdata;
        FMTOOLTIP fmtt = {0};

        if (pfmi->pszTooltip)
        {
            // Free the previous tooltip
            LocalFree(pfmi->pszTooltip);
            pfmi->pszTooltip = NULL;
        }

        fmcbdata.lParam = pfmh->lParam;  
        fmcbdata.hmenu = pfmh->hmenu;
        fmcbdata.iPos = -1;
        fmcbdata.idCmd = (UINT)-1;

        // (scotth): we don't ask for tooltips for alternate lists
        fmcbdata.pidlFolder = pfmh->pidlFolder;
        fmcbdata.pidl = pfmi->pidl;
        fmcbdata.psf = pfmh->psf;

        // Was a tooltip set?
        if (S_OK == pfmh->pfncb(FMM_GETTOOLTIP, &fmcbdata, (LPARAM)&fmtt))
        {
            Sz_AllocCopyW(fmtt.pszTip, &(pfmi->pszTooltip));
            SHFree(fmtt.pszTip);

            if (pfmi->pszTooltip)
            {
                // Set the other settings
                if (IsFlagSet(fmtt.dwMask, FMTT_MARGIN))
                {
                    pfmi->rcMargin = fmtt.rcMargin;
                    SetFlag(pfmi->Flags, FMI_MARGIN);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_MAXWIDTH))
                {
                    pfmi->dwMaxTipWidth = fmtt.dwMaxWidth;
                    SetFlag(pfmi->Flags, FMI_MAXTIPWIDTH);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_DRAWFLAGS))
                {
                    pfmi->uDrawFlags = fmtt.uDrawFlags;
                    SetFlag(pfmi->Flags, FMI_DRAWFLAGS);
                }

                if (IsFlagSet(fmtt.dwMask, FMTT_TABSTOP))
                {
                    pfmi->dwTabstop = fmtt.dwTabstop;
                    SetFlag(pfmi->Flags, FMI_TABSTOP);
                }
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Called on WM_MENUSELECT

*/
STDAPI_(BOOL)
FileMenu_HandleMenuSelect(
    IN HMENU  hmenu,
    IN WPARAM wparam,
    IN LPARAM lparam)
{
    UINT id = LOWORD(wparam);
    BOOL fTip = FALSE;
    BOOL fRet = FALSE;
    PFILEMENUITEM pfmi = g_pfmiLastSelNonFolder;

    if (hmenu && pfmi)
    {
        ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

        PFILEMENUHEADER pfmh = pfmi->pfmh;

        if (pfmh && IsFlagSet(pfmh->fmf, FMF_TOOLTIPS) &&
            FileMenuHeader_CreateTooltipWindow(pfmh))
        {
            // Have we asked for the tooltip?
            if (IsFlagClear(pfmi->Flags, FMI_ASKEDFORTOOLTIP))
            {
                // No; do it now
                FileMenuItem_GetTooltip(pfmi);

                SetFlag(pfmi->Flags, FMI_ASKEDFORTOOLTIP);
            }

            // Does this have a tooltip?
            if (pfmi->pszTooltip && FileMenu_GetHeader(hmenu) == pfmh)
            {
                // Yes
                Tooltip_Hide(g_hwndTip);
                Tooltip_SetPos(g_hwndTip, g_rcItem.left + X_TIPOFFSET, g_rcItem.bottom);
                Tooltip_SetText(g_hwndTip, pfmi->pszTooltip);

                if (IsFlagSet(pfmi->Flags, FMI_MAXTIPWIDTH))
                    SendMessage(g_hwndTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)pfmi->dwMaxTipWidth);

                if (IsFlagSet(pfmi->Flags, FMI_MARGIN))
                    SendMessage(g_hwndTip, TTM_SETMARGIN, 0, (LPARAM)&pfmi->rcMargin);

                Tooltip_Show(g_hwndTip);
                fTip = TRUE;
            }
        }
        fRet = TRUE;
    }

    if (!fTip && IsWindow(g_hwndTip))
        Tooltip_Hide(g_hwndTip);

    return fRet;
}


STDAPI_(void)
FileMenu_EditMode(BOOL bEdit)
{
    g_fsmenuagent.SetEditMode(bEdit, DROPEFFECT_MOVE);
}    


/*----------------------------------------------------------
Purpose: 

*/
STDAPI_(BOOL)
FileMenu_ProcessCommand(
    IN HWND   hwnd,
    IN HMENU  hmenuBar,
    IN UINT   idMenu,
    IN HMENU  hmenu,
    IN UINT   idCmd)
{
    return g_fsmenuagent.ProcessCommand(hwnd, hmenuBar, idMenu, hmenu, idCmd);
}


void FileMenuHeader_HandleUpdateImage(PFILEMENUHEADER pfmh, int iImage)
{
    int i;
    PFILEMENUITEM pfmi;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    ASSERT(-1 != iImage);

    // Look for any image indexes that are being changed
    
    for (i = GetMenuItemCount(pfmh->hmenu) - 1; i >= 0; i--)
    {
        pfmi = FileMenu_GetItemData(pfmh->hmenu, i, TRUE);
        if (pfmi)
        {
            ASSERT(IS_VALID_STRUCT_PTR(pfmi, FILEMENUITEM));

            if (pfmi->iImage == iImage)
            {
                // Invalidate this image.  It will be recalculated when
                // the menu item is redrawn.
                pfmi->iImage = -1;
            }

            HMENU hmenuSub = GetSubMenu(pfmh->hmenu, i);
            if (hmenuSub)
            {
                PFILEMENUHEADER pfmhT = FileMenu_GetHeader(hmenuSub);
                if (pfmhT)
                    FileMenuHeader_HandleUpdateImage(pfmhT, iImage);
            }    
        }
    }
}    


BOOL FileMenuHeader_HandleNotify(PFILEMENUHEADER pfmh, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    BOOL bRet;
    int iImage;

    ASSERT(IS_VALID_STRUCT_PTR(pfmh, FILEMENUHEADER));
    
    switch (lEvent)
    {
    case SHCNE_UPDATEIMAGE:
        if (EVAL(ppidl && ppidl[0]))
        {
            iImage = *(int UNALIGNED *)((BYTE *)ppidl[0] + 2);

            if (-1 != iImage)
                FileMenuHeader_HandleUpdateImage(pfmh, iImage);
        }
        bRet = TRUE;
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}    


STDAPI_(BOOL)
FileMenu_HandleNotify(HMENU hmenu, LPCITEMIDLIST * ppidl, LONG lEvent)
{
    BOOL bRet = FALSE;
    PFILEMENUHEADER pfmh = FileMenu_GetHeader(hmenu);

    if (hmenu && pfmh)
    {
        bRet = FileMenuHeader_HandleNotify(pfmh, ppidl, lEvent);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\hwtab.h ===
/*****************************************************************************
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  hwtab.h
 *
 *      Hardware tab
 *
 *****************************************************************************/

//  Hardware Tab Resources
//
//  The version of the template in the rc file is the
//  most compact form the dialog will take.
//  When inserted into a container, we will expand the dialog to
//  fill the available space.
//
//  Layout diagram.  All units are in dlu.
//
//       7 dlu                                             7 dlu
//       v                                                 v
//      +---------------------------------------------------+
//      |                                                   | <  7 dlu gap
//      | Devices:                                          | < 10 dlu tall
//      | +-----------------------------------------------+ | < 30 dlu tall
//      | | (listview contents)                           | |
//      | +-----------------------------------------------+ |
//      |                                                   | < 10 dlu gap
//      | +- Device Properties ---------------------------+ | < 12 dlu tall
//      | | Manufacturer                                  | | < 12 dlu tall
//      | | Hardware Revision                             | | < 12 dlu tall
//      | | Location                                      | | < 12 dlu tall
//      | | Device Status                                 | | < 36 dlu tall
//      | |                                               | |
//      | |^                                              | |
//      | |7 dlu                                          | |
//      | |                               4 dlu          4| |
//      | |                               v              v| |
//      | |               [ Troubleshoot ] [ Properties ] | | < 14 dlu tall
//      | |                                               | | <  7 dlu gap
//      | +-----------------------------------------------+ |
//      |                                                   | <  7 dlu gap
//      +---------------------------------------------------+
//                                         |            |
//                                         |<- 50 dlu ->|
//
//      Extra horizontal space is added to the listview and groupbox.
//      Extra vertical space is split between the listview and groupbox
//      in a ratio determined by the _dwViewMode.
//      The groupbox space is all given to the "Device Status" section.
//
//      The device property text remains pinned to the upper left corner
//      of the groupbox.
//
//      The troubleshoot and propeties buttons remain pinned to the
//      lower right corner of the groupbox.


// Relative size of TreeView in Hardware Tab
//
#define HWTAB_LARGELIST 1
#define HWTAB_MEDLIST   2
#define HWTAB_SMALLLIST 3

//
// Controls on the Hardware Tab that you might want to change the text of.
//
#define IDC_HWTAB_LVSTATIC              1411    // "Devices:"
#define IDC_HWTAB_GROUPBOX              1413    // "Device Properties"

// Functions to create your hardware tab page based on DEVCLASS guids
//
STDAPI_(HWND) DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);
STDAPI_(HWND) DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode);

// This notification is used for listview filtering
//
// We use the non-typedef'd names of these so callers aren't required to
// have included <setupapi.h> first.
//
typedef struct NMHWTAB 
{
    NMHDR nm;               // Notify info
    PVOID hdev;		    // Device information handle (HDEVINFO)
    struct _SP_DEVINFO_DATA *pdinf; // Device information
    BOOL    fHidden;        // OnNotify true if device is to be hidden, Can be changed to hide/show individual devices
} NMHWTAB, *LPNMHWTAB;

// ListView Device Filtering Messages
//
#define HWN_FIRST		        100		        
#define HWN_FILTERITEM	        HWN_FIRST
#define HWN_SELECTIONCHANGED    (HWN_FIRST + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\idhidden.h ===
#ifndef _IDHIDDEN_H_
#define _IDHIDDEN_H_

//
//  internal APIs for adding Hidden IDs to pidls
//      we use this to add data that we dont want
//      to be noticed by normal namespace handlers
//

typedef enum
{
    IDLHID_EMPTY            = 0xBEEF0000,   //  where's the BEEF?!
    IDLHID_URLFRAGMENT,                     //  Fragment IDs on URLs (#anchors)
    IDLHID_URLQUERY,                        //  Query strings on URLs (?query+info)
    IDLHID_JUNCTION,                        //  Junction point data
    IDLHID_IDFOLDEREX,                      //  IDFOLDEREX, extended data for CFSFolder
    IDLHID_DOCFINDDATA,                     //  DocFind's private attached data (not persisted)
    IDLHID_PERSONALIZED,                    //  personalized like (My Docs/Zeke's Docs)
    IDLHID_recycle2,                        //  recycle
    IDLHID_RECYCLEBINDATA,                  //  RecycleBin private data (not persisted)
    IDLHID_RECYCLEBINORIGINAL,              //  the original unthunked path for RecycleBin items
    IDLHID_PARENTFOLDER,                    //  merged folder uses this to encode the source folder.
    IDLHID_STARTPANEDATA,                   //  Start Pane's private attached data
    IDLHID_NAVIGATEMARKER                   //  Used by Control Panel's 'Category view'               
};
typedef DWORD IDLHID;

#pragma pack(1)
typedef struct _HIDDENITEMID
{
    WORD    cb;     //  hidden item size
    WORD    wVersion;
    IDLHID  id;     //  hidden item ID
} HIDDENITEMID;
#pragma pack()

typedef HIDDENITEMID UNALIGNED *PIDHIDDEN;
typedef const HIDDENITEMID UNALIGNED *PCIDHIDDEN;

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid);
STDAPI ILCloneWithHiddenID(LPCITEMIDLIST pidl, PCIDHIDDEN pidhid, LPITEMIDLIST *ppidl);
STDAPI_(PCIDHIDDEN) ILFindHiddenIDOn(LPCITEMIDLIST pidl, IDLHID id, BOOL fOnLast);
#define ILFindHiddenID(p, i)    ILFindHiddenIDOn((p), (i), TRUE)
STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id);
STDAPI_(void) ILExpungeRemovedHiddenIDs(LPITEMIDLIST pidl);
STDAPI_(LPITEMIDLIST) ILCreateWithHidden(UINT cbNonHidden, UINT cbHidden);

//  helpers for common data types.
STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz);
STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch);
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch);
STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id);

#ifdef UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringW
#define ILGetHiddenString               ILGetHiddenStringW
#else //!UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringA
#define ILGetHiddenString               ILGetHiddenStringA
#endif //UNICODE

#endif // _IDHIDDEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\imgprop.h ===
// {56616500-C154-11CE-8553-00AA00A1F95B}
DEFINE_GUID(FMTID_FlashPix,       0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B);
#define PSGUID_FlashPix         { 0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B }

#define PID_File_source                         0x21000000 // VT_UI4: File source
#define PID_Scene_type                          0x21000001 // VT_UI4: Scene type
#define PID_Creation_path_vector                0x21000002 // VT_UI4 | VT_VECTOR: Creation path vector
#define PID_Software_Name_Manufacturer_Release  0x21000003 // VT_LPWSTR: Software Name/Manufacturer/Release
#define PID_User_defined_ID                     0x21000004 // VT_LPWSTR: User defined ID
#define PID_Sharpness_approximation             0x21000005 // VT_R4: Sharpness approximation

#define PID_Copyright_message                   0x22000000 // VT_LPWSTR: Copyright message
#define PID_Legal_broker_for_the_original_image 0x22000001 // VT_LPWSTR: Legal broker for the original image
#define PID_Legal_broker_for_the_digital_image  0x22000002 // VT_LPWSTR: Legal broker for the digital image
#define PID_Authorship                          0x22000003 // VT_LPWSTR: Authorship
#define PID_Intellectual_property_notes         0x22000004 // VT_LPWSTR: Intellectual property notes

#define PID_Test_target_in_the_image            0x23000000 // VT_UI4: Test target in the image
#define PID_Group_caption                       0x23000002 // VT_LPWSTR: Group caption
#define PID_Caption_text                        0x23000003 // VT_LPWSTR: Caption text
#define PID_People_in_the_image                 0x23000004 // VT_LPWSTR | VT_VECTOR
#define PID_Things_in_the_image                 0x23000007 // VT_LPWSTR | VT_VECTOR
#define PID_Date_of_the_original_image          0x2300000A // VT_FILETIME
#define PID_Events_in_the_image                 0x2300000B // VT_LPWSTR | VT_VECTOR
#define PID_Places_in_the_image                 0x2300000C // VT_LPWSTR | VT_VECTOR
#define PID_Content_description_notes           0x2300000F // VT_LPWSTR: Content description notes

#define PID_Camera_manufacturer_name            0x24000000 // VT_LPWSTR: Camera manufacturer name
#define PID_Camera_model_name                   0x24000001 // VT_LPWSTR: Camera model name
#define PID_Camera_serial_number                0x24000002 // VT_LPWSTR: Camera serial number

#define PID_Capture_date                        0x25000000  // VT_FILETIME: Capture date
#define PID_Exposure_time                       0x25000001  // VT_R4: Exposure time
#define PID_F_number                            0x25000002  // VT_R4: F-number
#define PID_Exposure_program                    0x25000003  // VT_UI4: Exposure program
#define PID_Brightness_value                    0x25000004  // VT_R4 | VT_VECTOR
#define PID_Exposure_bias_value                 0x25000005  // VT_R4: Exposure bias value
#define PID_Subject_distance                    0x25000006  // VT_R4 | VT_VECTOR
#define PID_Metering_mode                       0x25000007  // VT_UI4: Metering mode
#define PID_Scene_illuminant                    0x25000008  // VT_UI4: Scene illuminant
#define PID_Focal_length                        0x25000009  // VT_R4: Focal length
#define PID_Maximum_aperture_value              0x2500000A  // VT_R4: Maximum aperture value
#define PID_Flash                               0x2500000B  // VT_UI4: Flash
#define PID_Flash_energy                        0x2500000C  // VT_R4: Flash energy
#define PID_Flash_return                        0x2500000D  // VT_UI4: Flash return
#define PID_Back_light                          0x2500000E  // VT_UI4: Back light
#define PID_Subject_location                    0x2500000F  // VT_R4 | VT_VECTOR
#define PID_Exposure_index                      0x25000010  // VT_R4: Exposure index
#define PID_Special_effects_optical_filter      0x25000011  // VT_UI4 | VT_VECTOR
#define PID_Per_picture_notes                   0x25000012  // VT_LPWSTR: Per picture notes

#define PID_Sensing_method                      0x26000000 // VT_UI4: Sensing method
#define PID_Focal_plane_X_resolution            0x26000001 // VT_R4: Focal plane X resolution
#define PID_Focal_plane_Y_resolution            0x26000002 // VT_R4: Focal plane Y resolution
#define PID_Focal_plane_resolution_unit         0x26000003 // VT_UI4: Focal plane resolution unit
#define PID_Spatial_frequency_response          0x26000004 // VT_VARIANT | VT_VECTOR
#define PID_CFA_pattern                         0x26000005 // VT_VARIANT | VT_VECTOR
#define PID_Spectral_sensitivity                0x26000006 // VT_LPWSTR: Spectral sensitivity
#define PID_ISO_speed_ratings                   0x26000007 // VT_UI2 | VT_VECTOR
#define PID_OECF                                0x26000008 // VT_VARIANT | VT_VECTOR: OECF

#define PID_Film_brand                          0x27000000 // VT_LPWSTR: Film brand
#define PID_Film_category                       0x27000001 // VT_UI4: Film category
#define PID_Film_size                           0x27000002 // VT_VARIANT | VT_VECTOR: Film size
#define PID_Film_roll_number                    0x27000003 // VT_UI4: Film roll number
#define PID_Film_frame_number                   0x27000004 // VT_UI4: Film frame number

#define PID_Original_scanned_image_size         0x29000000 // VT_VARIANT | VT_VECTOR: Original scanned image size
#define PID_Original_document_size              0x29000001 // VT_VARIANT | VT_VECTOR: Original document size
#define PID_Original_medium                     0x29000002 // VT_UI4: Original medium
#define PID_Type_of_original                    0x29000003 // VT_UI4: Type of original

#define PID_Scanner_manufacturer_name           0x28000000 // VT_LPWSTR: Scanner manufacturer name
#define PID_Scanner_model_name                  0x28000001 // VT_LPWSTR: Scanner model name
#define PID_Scanner_serial_number               0x28000002 // VT_LPWSTR: Scanner serial number
#define PID_Scan_software                       0x28000003 // VT_LPWSTR: Scan software
#define PID_Scan_software_revision_date         0x28000004 // VT_DATE: Scan software revision date
#define PID_Service_bureau_organization_name    0x28000005 // VT_LPWSTR: Service bureau/organization name
#define PID_Scan_operator_ID                    0x28000006 // VT_LPWSTR: Scan operator ID
#define PID_Scan_date                           0x28000008 // VT_FILETIME: Scan date
#define PID_Last_modified_date                  0x28000009 // VT_FILETIME: Last modified date
#define PID_Scanner_pixel_size                  0x2800000A // VT_R4: Scanner pixel size


// these properties are independent of the file type, values are generated by GDI+ API calls not from embedded tags
//  FMTID_ImageSummaryInfo - Property IDs

#define PIDISI_FILETYPE                 0x00000002L  // VT_LPWSTR
#define PIDISI_CX                       0x00000003L  // VT_UI4
#define PIDISI_CY                       0x00000004L  // VT_UI4
#define PIDISI_RESOLUTIONX              0x00000005L  // VT_UI4
#define PIDISI_RESOLUTIONY              0x00000006L  // VT_UI4
#define PIDISI_BITDEPTH                 0x00000007L  // VT_UI4
#define PIDISI_COLORSPACE               0x00000008L  // VT_LPWSTR
#define PIDISI_COMPRESSION              0x00000009L  // VT_LPWSTR
#define PIDISI_TRANSPARENCY             0x0000000AL  // VT_UI4
#define PIDISI_GAMMAVALUE               0x0000000BL  // VT_UI4
#define PIDISI_FRAMECOUNT               0x0000000CL  // VT_UI4
#define PIDISI_DIMENSIONS               0x0000000DL  // VT_LPWSTR

//
// Define some tags that map to new tags in the EXIF/TIFF header for saving UNICODE properties
//
#define PropertyTagUnicodeDescription   40091
#define PropertyTagUnicodeComment       40092
#define PropertyTagUnicodeArtist        40093
#define PropertyTagUnicodeKeywords      40094
#define PropertyTagUnicodeSubject       40095
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\heapaloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       heapaloc.h
//
//  Contents:   Macros which wrap the standard memory API calls, redirecting
//              them to HeapAlloc.
//
//  Functions:  __inline HLOCAL  HeapLocalAlloc   (fuFlags, cbBytes)
//              __inline HLOCAL  HeapLocalReAlloc (hMem, cbBytes, fuFlags)
//              __inline HLOCAL  HeapLocalFree    (HLOCAL hMem)
//
//  History:    2-01-95   davepl   Created
//              12-15-97  t-saml   changed to be used only for leak tracking
//
//--------------------------------------------------------------------------

#ifndef _HEAPALOC_H
#define _HEAPALOC_H 1

#ifndef DEBUG
#define IMSAddToList(bAdd, pv, cb)
#else

// Function to add/remove from leak detection list
// In stocklib (shell\lib\debug.c)
STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, SIZE_T cb);
#ifdef _SHELLP_H_
// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *PFNGSMS) (IShellMallocSpy **ppout);
#endif


#ifndef ASSERT
#define ASSERT Assert
#endif

#ifdef LocalAlloc
#error "HEAPALOC.H(42): LocalAlloc shouldn't be defined"
#endif

//
// These are functions normally in comctl32, but there's no good reason to call
// that dll, so handle them here.  Since Chicago may still want to use these
// shared memory routines, only "forward" them under NT.
//

#if defined(WINNT) && defined(_COMCTL32_)
#define Alloc(cb)                             HeapLocalAlloc(LMEM_ZEROINIT | LMEM_FIXED, cb)
#define ReAlloc(pb, cb)                       HeapLocalReAlloc(pb, cb, LMEM_ZEROINIT | LMEM_FIXED)
//
// Free() in comctl32 is just HeapFree(), so the return code reversing
// in HeapLocalFree is the opposite of what we want.  Reverse it
// again here for now, and consider redefining Free() as just
// HeapFree(g_hProcessHeap) if the compiler isn't smart enough
// to generate the same code already. 
// REVIEW: who checks the return value from a free?  What do you do if it fails?
//
#define Free(pb)                              (!HeapLocalFree(pb))
#define GetSize(pb)                           HeapLocalSize(pb)
#endif


#if 0

// GlobalAllocs cannot be trivially replaced since they are used for DDE, OLE,
// and GDI operations.  However, on a case-by-case version we can switch them
// over to HeapGlobalAlloc as we identify instances that don't _really_ require
// GlobalAllocs.

#define GlobalAlloc(fuFlags, cbBytes)         HeapGlobalAlloc(fuFlags, cbBytes)
#define GlobalReAlloc(hMem, cbBytes, fuFlags) HeapGlobalReAlloc(hMem, cbBytes, fuFlags)
#define GlobalSize(hMem)                      HeapGlobalSize(hMem)
#define GlobalFree(hMem)                      HeapGlobalFree(hMem)
#define GlobalCompact                         InvalidMemoryCall
#define GlobalDiscard                         InvalidMemoryCall
#define GlobalFlags                           InvalidMemoryCall
#define GlobalHandle                          InvalidMemoryCall
#define GlobalLock                            InvalidMemoryCall
#define GlobalUnlock                          InvalidMemoryCall

#endif


__inline HLOCAL HeapLocalAlloc(IN UINT fuFlags, IN SIZE_T cbBytes)
{
    void * pv;

    pv = LocalAlloc(fuFlags, cbBytes);

    IMSAddToList(TRUE, pv, cbBytes); // Add to leak tracking

    return (HLOCAL) pv;
}

__inline HLOCAL HeapLocalFree(HLOCAL hMem)
{
    IMSAddToList(FALSE, hMem, 0); // Free leak tracking

    return LocalFree(hMem);
}

__inline HLOCAL HeapLocalReAlloc(IN HGLOBAL hMem,
                                 IN SIZE_T  cbBytes,
                                 IN UINT    fuFlags)
{
    void * pv;

    // (DavePl) Why can we realloc on a null ptr?

    if (NULL == hMem)
    {
        return LocalAlloc(fuFlags, cbBytes);
    }

    pv = LocalReAlloc((void *) hMem, cbBytes, fuFlags);

    IMSAddToList(FALSE, hMem, 0);    // Take out the old
    IMSAddToList(TRUE, pv, cbBytes);  // And bring in the new

    return (HGLOBAL) pv;
}

// Redefine the standard memory APIs to thunk over to our Heap-based funcs


#define LocalAlloc(fuFlags, cbBytes)          HeapLocalAlloc(fuFlags, cbBytes)
#define LocalReAlloc(hMem, cbBytes, fuFlags)  HeapLocalReAlloc(hMem, cbBytes, fuFlags)
#define LocalFree(hMem)                       HeapLocalFree(hMem)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\iethread.h ===
//
// Defines IETHREADPARAM for shdocvw.dll and explorer.exe
//

#ifndef __IETHREAD_H__
#define __IETHREAD_H__

#include <desktopp.h>

typedef struct
{
    DWORD   dwSize;
    UINT    uFlags;
    int     nShow;
    DWORD   dwHwndCaller;       // Must be DWORD for 32/64 interop
    DWORD   dwHotKey;
    CLSID   clsid;
    CLSID   clsidInProc;
    UINT    oidl;               // Offset to pidl or 0
    UINT    oidlSelect;         // Offset to pidl or 0
    UINT    oidlRoot;           // Offset to pidl or 0
    UINT    opszPath;           // Offset to path or 0
} NEWFOLDERBLOCK, *PNEWFOLDERBLOCK;

typedef struct _WINVIEW
{
    BOOL UNUSED:1;      // unused
    BOOL bStdButtons:1; // Win95 called this bToolbar
    BOOL bStatusBar:1;  // Win95
    BOOL bLinks:1;      // IE3 called this bITBar
    BOOL bAddress:1;    // IE4
} WINVIEW;


// the size in characters of the name of the Event used to signal IEXPLORE
#define MAX_IEEVENTNAME (2+1+8+1+8+1)

#undef  INTERFACE
#define INTERFACE   IEFreeThreadedHandShake
DECLARE_INTERFACE_(IEFreeThreadedHandShake, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IIEFreeThreadedHandShake methods ***
    STDMETHOD_(void,   PutHevent) (THIS_ HANDLE hevent) PURE;
    STDMETHOD_(HANDLE, GetHevent) (THIS) PURE;
    STDMETHOD_(void,    PutHresult) (THIS_ HRESULT hres) PURE;
    STDMETHOD_(HRESULT, GetHresult) (THIS) PURE;
    STDMETHOD_(IStream*, GetStream) (THIS) PURE;
};


#ifdef NO_MARSHALLING

#undef  INTERFACE
#define INTERFACE IWindowStatus
DECLARE_INTERFACE_(IWindowStatus, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWindowStatus methods ***
    STDMETHOD(IsWindowActivated)() PURE;
};

#endif


// NOTE: The IETHREADPARAM structure is used between shdocvw, shell32,
// and browseui, so it cannot be modified after we ship, only extended.
typedef struct
{
    LPCWSTR pszCmdLine;
    UINT    uFlags;             // COF_ bits
    int     nCmdShow;

    //  these will always be set together
    ITravelLog *ptl;
    DWORD dwBrowserIndex;

    IEFreeThreadedHandShake* piehs;   // caller (thread) owns it

    // these come from explorer's NEWFOLDERINFO
    LPITEMIDLIST pidl;

    WCHAR szDdeRegEvent[MAX_IEEVENTNAME];
    WCHAR szCloseEvent[MAX_IEEVENTNAME];
    
    IShellBrowser* psbCaller;
    HWND hwndCaller;
    ISplashScreen *pSplash;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
                                // 99/04/07 #141049 vtan: Overload pidlRoot with
                                // HMONITOR information on Windows 2000. Check the
                                // uFlags for COF_HASHMONITOR before using this.

    CLSID clsid;                // Only used if COF_NEWROOT
    CLSID clsidInProc;          // Only used if COF_INPROC
    
    // these come from explorer.exe's cabview struct
    WINDOWPLACEMENT wp;
    FOLDERSETTINGS fs;
    UINT wHotkey;

    WINVIEW wv;

    SHELLVIEWID m_vidRestore;
    DWORD m_dwViewPriority;
    
    long dwRegister;            // The register that was gotten from RegisterPending
    IUnknown *punkRefProcess;

    BOOL fNoLocalFileWarning : 1;
    BOOL fDontUseHomePage : 1;
    BOOL fFullScreen : 1;
    BOOL fNoDragDrop : 1;
    BOOL fAutomation : 1;
    BOOL fCheckFirstOpen : 1;
    BOOL fDesktopChannel : 1;

#ifdef UNIX
    BOOL fShouldStart : 1;
#endif

#ifdef NO_MARSHALLING
    BOOL fOnIEThread : 1;
#endif //NO_MARSHALLING
} IETHREADPARAM;

#ifdef UNIX
#define COF_HELPMODE            0x00010000      // Special mode for help display
#endif

#endif // __IETHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\inetutil.h ===
/*****************************************************************************\
    FILE: inetutil.h

    DESCRIPTION:
        These are wininet wrappers that fix the error values and wrap functionality.

    BryanSt 10/12/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _INETUTIL_H
#define _INETUTIL_H


////////////////////////////////
//  Wininet/URL Helpers
////////////////////////////////
STDAPI DownloadUrl(LPCTSTR pszUrl, BSTR * pbstrXML);
STDAPI InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
STDAPI InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
STDAPI InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);
STDAPI InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);




#endif // _INETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\inetsmgr.h ===
#if !defined(_INETSMGR_H_)
#define _INETSMGR_H_

// whoever inherits this class must implement _IsSafeSite
class CInternetSecurityMgrImpl : public IInternetSecurityManager
{
public:
    // *** IUnknown ***
    // (client must provide!)
    
    // *** IInternetSecurityManager methods ***
    virtual STDMETHODIMP MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecurityId(LPCWSTR pwszUrl, BYTE* pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
    {
        HRESULT hres = INET_E_DEFAULT_ACTION;

        if (_IsSafeUrl(pwszUrl))
        {
            if (cbPolicy >= SIZEOF(DWORD))
            {
                *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                hres = S_OK;
            }
            else
                hres = S_FALSE;
        }

        return hres;
    }
    virtual STDMETHODIMP QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy,
                                   BYTE *pContext, DWORD cbContext, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetSecuritySite(IInternetSecurityMgrSite *pSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecuritySite(IInternetSecurityMgrSite **ppSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetZoneMappings(DWORD dwZone, IEnumString **ppEnumString, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }

protected:
    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\linklistt.h ===
template <class Type> class CLinkedList;

template <class Type> struct CLinkedNode    
{
public:
    CLinkedNode <Type> *pNext; 
    Type that;
};

template <class Type> class CLinkedWalk
{
public:
    CLinkedWalk(CLinkedList<Type> *plist) : _plist(plist), _pCurr(NULL), _pLast(NULL) {}
    CLinkedWalk() : _plist(NULL), _pCurr(NULL), _pLast(NULL) {}
    void Init(CLinkedList<Type> *plist) {_plist = plist; _pCurr = _pLast = NULL;}
    inline BOOL IsFirst(void) { return _pLast == NULL;}
    inline Type *That(void) {return _pCurr ? &_pCurr->that : NULL;}
    inline CLinkedNode<Type> *Node(void) {return _pCurr;}
    inline BOOL Step(void)
    {
        _pLast = _pCurr;

        if (_pCurr)
            _pCurr = _pCurr->pNext;
        else if (_plist)
            _pCurr = _plist->_pFirst;

        return (_pCurr != NULL);
    }

    inline CLinkedNode<Type> *Remove(void)
    {
        CLinkedNode<Type> *pRet = _pCurr;
        if (pRet)
        {
            _pCurr = _pCurr->pNext;

            //  update the list
            if (_pLast)
                _pLast->pNext = _pCurr;
            else
                _plist->_pFirst = _pCurr;
        }
        return pRet;
    }

    inline void Delete(void)
    {
        CLinkedNode<Type> *p = Remove();
        if (p)
            delete p;
    }

protected:
    CLinkedList<Type> *_plist;
    CLinkedNode<Type> *_pCurr;
    CLinkedNode<Type> *_pLast;
};

template <class Type> class CLinkedList
{
public: //methods
    CLinkedList() :_pFirst(NULL) {}
    ~CLinkedList()
    {
        CLinkedWalk<Type> lw(this);

        while (lw.Step())
        {
            lw.Delete();
        }
    }
    inline BOOL IsEmpty(void) {return _pFirst == NULL;}
    inline BOOL Insert(CLinkedNode<Type> *p)
    {
        p->pNext = _pFirst;
        _pFirst = p;
        return TRUE;
    }

    inline void Remove(CLinkedNode<Type> *pRemove)
    {
        CLinkedWalk<Type> lw(this);

        while (lw.Step())
        {
            if (lw.Node() == pRemove)
            {
                lw.Remove();
                break;
            }
        }
    }

protected:
    CLinkedNode <Type> *_pFirst;

    friend class CLinkedWalk<Type>;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\mediahlpr.h ===
// mediahlpr.h: Media Bar helper objects that need to be shared between shdocvw & browseui

#ifndef _MEDIAHLPR_H_
#define _MEDIAHLPR_H_

//+----------------------------------------------------------------------------------------
// CMediaBarHelper - Helper object for disabling autoplay per navigation
//-----------------------------------------------------------------------------------------

class
CMediaBarHelper :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IServiceProvider,
    public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>
{
public:
    CMediaBarHelper() : 
        _dwCPCookie(0),
        _dwServiceCookie(0),
        _fDisableOnce(false)
    {
    }

    ~CMediaBarHelper()
    {
        // for putting break points
        return;
    }

    BEGIN_COM_MAP(CMediaBarHelper)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
    END_COM_MAP();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
    {
        HRESULT hres = E_UNEXPECTED;

        if (IsEqualIID(guidService, CLSID_MediaBand))
        {
            hres = QueryInterface(riid, ppvObj);

            // If we are supposed to disable only the first autoplay, then 
            // we need to revoke the service after it has been queried for once. 
            if (_fDisableOnce && _spCP.p)
            {
                CComPtr<IConnectionPointContainer> spCPC;

                // Revoke the service
                HRESULT hr = _spCP->GetConnectionPointContainer(&spCPC);
                if (SUCCEEDED(hr))
                {
                    hr = ProfferService(spCPC, 
                                        CLSID_MediaBand, 
                                        NULL,
                                        &_dwServiceCookie);
            
                    ASSERT(SUCCEEDED(hr));

                    _dwServiceCookie = 0;

                    // unhook the web oc events so that we are destroyed
                    UnHookWebOCEvents();
                }
            }
        }
        return hres;
    }

    static HRESULT ProfferService(IUnknown         *punkSite, 
                                  REFGUID           sidWhat, 
                                  IServiceProvider *pService, 
                                  DWORD            *pdwCookie)
    {
        IProfferService *pps;
        HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
        if (SUCCEEDED(hr))
        {
            if (pService)
                hr = pps->ProfferService(sidWhat, pService, pdwCookie);
            else
            {
                hr = pps->RevokeService(*pdwCookie);
                *pdwCookie = 0;
            }
            pps->Release();
        }
        return hr;
    }

    static HRESULT DisableFirstAutoPlay(IUnknown * pUnk, bool fDisableAll = false)
    {
        CComObject<CMediaBarHelper> * pMediaBarHelper = NULL;
    
        HRESULT hr = CComObject<CMediaBarHelper>::CreateInstance(&pMediaBarHelper);
        if (SUCCEEDED(hr) && pMediaBarHelper)
        {
            pMediaBarHelper->AddRef();

            hr = ProfferService(pUnk, 
                                CLSID_MediaBand, 
                                SAFECAST(pMediaBarHelper, IServiceProvider *),
                                &(pMediaBarHelper->_dwServiceCookie));

            if (SUCCEEDED(hr) && !fDisableAll)
            {
                pMediaBarHelper->_fDisableOnce = true;

                // ISSUE: need to unhook events
                hr = pMediaBarHelper->HookWebOCEvents(pUnk);
            }
            else if(FAILED(hr) && pMediaBarHelper->_dwServiceCookie)
            {
                // Revoke the service
                hr = ProfferService(pUnk, 
                                    CLSID_MediaBand, 
                                    NULL,
                                    &(pMediaBarHelper->_dwServiceCookie));
            }

            pMediaBarHelper->Release();
        }

        return hr;
    }   

    // Hook Content Pane WebOC Events
    HRESULT HookWebOCEvents(IUnknown * pUnk)
    {
        HRESULT hr = E_FAIL;

        CComPtr<IConnectionPointContainer> spDocCPC; 
        CComPtr<IDispatch> spDocDispatch;
        CComPtr<IWebBrowser2> spWebBrowser;

        if (!pUnk)
        {
            goto done;
        }

        hr = IUnknown_QueryService(pUnk, SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&spWebBrowser);
        if (FAILED(hr))
        {
            goto done;
        }

        // Get a connection point to the container
        hr = spWebBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDocCPC->FindConnectionPoint( DIID_DWebBrowserEvents2, &_spCP );
        if (FAILED(hr))
        {
            goto done;
        }

        hr = _spCP->Advise(static_cast<IUnknown*>(static_cast<DWebBrowserEvents2*>(this)), &_dwCPCookie);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = S_OK;
    done:
        return hr;
    }

    HRESULT UnHookWebOCEvents()
    {
        HRESULT hr = E_FAIL;

        if (_spCP)
        {
            CComPtr<IConnectionPointContainer> spCPC;

            // Revoke the service
            hr = _spCP->GetConnectionPointContainer(&spCPC);
            if (SUCCEEDED(hr) && _dwServiceCookie)
            {
                hr = ProfferService(spCPC, 
                                    CLSID_MediaBand, 
                                    NULL,
                                    &_dwServiceCookie);
                
                _dwServiceCookie = 0;
            }

            // unhook the events
            if (_dwCPCookie != 0)
            {
                hr = _spCP->Unadvise(_dwCPCookie);
                _dwCPCookie = 0;
            }
            _spCP.Release();
        }

        _dwCPCookie = 0;

        return hr;
    }

    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID /*riid*/,
        /* [in] */ LCID /*lcid*/,
        /* [in] */ WORD /*wFlags*/,
        /* [out][in] */ DISPPARAMS* pDispParams,
        /* [out] */ VARIANT* pVarResult,
        /* [out] */ EXCEPINFO* /*pExcepInfo*/,
        /* [out] */ UINT* puArgErr)
    {
        HRESULT hr = E_FAIL;

        switch (dispIdMember)
        {
            case DISPID_ONQUIT:           // 253 (see exdispid.h)
            case DISPID_NAVIGATEERROR:    // 271
            // These events sometimes comes before the QS, so we ignore them
            // case DISPID_DOCUMENTCOMPLETE: // 259 
            // case DISPID_NAVIGATECOMPLETE2:// 252
            {
                hr = UnHookWebOCEvents();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            break;
        }

        hr = S_OK;
      done:
        return hr;
    }

public:
    CComPtr<IConnectionPoint> _spCP;
    DWORD _dwCPCookie;
    DWORD _dwServiceCookie;
    bool  _fDisableOnce;
};

#endif // _MEDIAHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\maguids.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MAGUIDS.H
//
//	Declares the GUIDS for the Music Activity Center index
//
//	Copyright (c) Microsoft Corporation	1999
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MAGUIDS_HEADER_
#define _MAGUIDS_HEADER_

#ifdef __cplusplus
extern "C" {
#endif

//GUIDS for Player and Playlist

DEFINE_GUID(CLSID_MCPlayer, 
            0xFAB42950,0x3EFF,0x11D3,0xA2,0x07,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

DEFINE_GUID(IID_IMCPlayer,
            0x4DB04CC0,0x3F8B,0x11D3,0xA2,0x07,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

DEFINE_GUID(IID_IMCPList,
            0xEBC54B0C,0x4091,0x11D3,0xA2,0x08,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

//GUIDs for objects and property sets

DEFINE_GUID(IID_MusicActivity_Genre, 
            0x28EA7E1C, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_GenreProperties, 
            0x4180DD29, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_GenreUserProperties, 
            0x4180DD2A, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Artist, 
            0x4CC5C8BB, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_ArtistProperties, 
            0x53FD9046, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_ArtistUserProperties, 
            0x29F445CF, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollection, 
            0xC576D561, 0x38B1, 0x11d3, 0xA2, 0x04, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollectionProperties, 
            0x134E3665, 0x452F, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollectionUserProperties, 
            0xE5F3EB13, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Album, 
            0x3FB37412, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumProperties, 
            0x3C29F2EF, 0x2FDF, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumDownloadProperties, 
            0x3FB37413, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumUserProperties, 
            0x3FB37414, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrack, 
            0x20E88E93, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrackProperties, 
            0x20E88E94, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrackUserProperties, 
            0x27AB8251, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylist, 
            0x33DC77DA, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylistProperties, 
            0x33DC77DB, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylistUserProperties, 
            0x33DC77DC, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Playlist, 
            0xC23C63E7, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistProperties, 
            0xC65B1A73, 0x4869, 0x11d3, 0xA2, 0x0A, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistUserProperties, 
            0xF4A89EB2, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Track, 
            0x5C07A8AF, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackProperties, 
            0x5C07A8B0, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackDynamicProperties, 
            0x7F155F3F, 0x3C93, 0x11d3, 0xA2, 0x06, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackUserProperties, 
            0x5C07A8B1, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Batch, 
            0xCCE3C6ED, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_BatchProperties, 
            0xCCE3C6EE, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Link, 
            0xE398889B, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_LinkProperties, 
            0xE398889C, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Pictures, 
            0x7B2D2D4E, 0x453B, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PictureProperties, 
            0x7B2D2D4F, 0x453B, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbum, 
            0xF3CCA94D, 0x004A, 0x4cef, 0xBA, 0x6E, 0x64, 0x4D, 0xEC, 0x03, 0x7D, 0x6F);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbumProperties, 
            0x2159AF87, 0x8258, 0x4a6c, 0x85, 0x81, 0xDE, 0xF6, 0x8C, 0xA6, 0xBF, 0x4F);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbumUserProperties, 
            0x1F821027, 0xE8AC, 0x4cf7, 0xB5, 0x66, 0x69, 0xC7, 0xC0, 0x18, 0x56, 0x2C);

//Property Numbers
#define MA_PROPERTY_GENRE_NAME                  1

#define MA_PROPERTY_ARTIST_NAME                 1
#define MA_PROPERTY_ARTIST_ROLE                 2

#define MA_PROPERTY_USERCOLLECTION_NAME         1

#define MA_PROPERTY_ALBUM_TITLE                 1
#define MA_PROPERTY_ALBUM_COPYRIGHT             2
#define MA_PROPERTY_ALBUM_LABEL                 3
#define MA_PROPERTY_ALBUM_RELEASEDATE           4
#define MA_PROPERTY_ALBUM_RATING                5
#define MA_PROPERTY_ALBUM_RATINGORG             6
#define MA_PROPERTY_ALBUM_CDID                  7
#define MA_PROPERTY_ALBUM_TOC                   8
#define MA_PROPERTY_ALBUM_LASTPLAYED            9

#define MA_PROPERTY_ALBUMDLD_PREMIUMMETA        1
#define MA_PROPERTY_ALBUMDLD_PREMIUMMETACACHE   2
#define MA_PROPERTY_ALBUMDLD_DOWNLOADDATE       3
#define MA_PROPERTY_ALBUMDLD_PROVIDER           4

#define MA_PROPERTY_ALBUMTRACK_TITLE            1
#define MA_PROPERTY_ALBUMTRACK_LYRICS           2
#define MA_PROPERTY_ALBUMTRACK_LENGTH           3
#define MA_PROPERTY_ALBUMTRACK_LASTPLAYED       4

#define MA_PROPERTY_ALBUMPLAYLIST_NAME          1

#define MA_PROPERTY_PLAYLIST_NAME               1

#define MA_PROPERTY_PLAYLISTFROMALBUM_NAME      1

#define MA_PROPERTY_TRACK_FILENAME              1
#define MA_PROPERTY_TRACK_TITLE                 2
#define MA_PROPERTY_TRACK_SUBTITLE              3
#define MA_PROPERTY_TRACK_COPYRIGHT             4
#define MA_PROPERTY_TRACK_FILETYPE              5
#define MA_PROPERTY_TRACK_TIME                  6
#define MA_PROPERTY_TRACK_DATE                  7
#define MA_PROPERTY_TRACK_LANGUAGE              8
#define MA_PROPERTY_TRACK_MEDIATYPE             9
#define MA_PROPERTY_TRACK_PARTINSET             10
#define MA_PROPERTY_TRACK_ENCODEDBY             11
#define MA_PROPERTY_TRACK_PUBLISHER             12
#define MA_PROPERTY_TRACK_TRACKNUMBER           13
#define MA_PROPERTY_TRACK_RECORDINGDATES        14
#define MA_PROPERTY_TRACK_NETRADIOSTATION       15
#define MA_PROPERTY_TRACK_NETRADIOOWNER         16
#define MA_PROPERTY_TRACK_YEAR                  17
#define MA_PROPERTY_TRACK_BEATSPERMINUTE        18
#define MA_PROPERTY_TRACK_MUSICALKEY            19
#define MA_PROPERTY_TRACK_LENGTHINMILLISECONDS  20
#define MA_PROPERTY_TRACK_ALBUM                 21
#define MA_PROPERTY_TRACK_ORIGINALALBUM         22
#define MA_PROPERTY_TRACK_ORIGINALFILENAME      23
#define MA_PROPERTY_TRACK_ORIGINALRELEASEYEAR   24
#define MA_PROPERTY_TRACK_FILEOWNER             25
#define MA_PROPERTY_TRACK_SIZE                  26
#define MA_PROPERTY_TRACK_ISRC                  27
#define MA_PROPERTY_TRACK_SOFTWARE              28
#define MA_PROPERTY_TRACK_RATING                29
#define MA_PROPERTY_TRACK_COMMENT               30

#define MA_PROPERTY_TRACKDYNA_TRACKEDLINK       1

#define MA_PROPERTY_BATCH_CDID                  1
#define MA_PROPERTY_BATCH_NUMTRACKS             2
#define MA_PROPERTY_BATCH_TOC                   3

#define MA_PROPERTY_LINK_NAME                   1
#define MA_PROPERTY_LINK_URL                    2

#define MA_PROPERTY_PICTURE_CAPTION             1
#define MA_PROPERTY_PICTURE_URL                 2
#define MA_PROPERTY_PICTURE_TRACKEDLINK         3
#define MA_PROPERTY_PICTURE_THUMBNAIL           4

//Property Names
#define MA_PROPERTYNAME_GENRE_NAME                  L"Name"

#define MA_PROPERTYNAME_ARTIST_NAME                 L"Name"
#define MA_PROPERTYNAME_ARTIST_ROLE                 L"Role"

#define MA_PROPERTYNAME_USERCOLLECTION_NAME         L"Name"

#define MA_PROPERTYNAME_ALBUM_TITLE                 L"Title"
#define MA_PROPERTYNAME_ALBUM_COPYRIGHT             L"Copyright"
#define MA_PROPERTYNAME_ALBUM_LABEL                 L"Label"
#define MA_PROPERTYNAME_ALBUM_RELEASEDATE           L"ReleaseDate"
#define MA_PROPERTYNAME_ALBUM_RATING                L"Rating"
#define MA_PROPERTYNAME_ALBUM_RATINGORG             L"RatingOrg"
#define MA_PROPERTYNAME_ALBUM_CDID                  L"CDID"
#define MA_PROPERTYNAME_ALBUM_TOC                   L"TOC"
#define MA_PROPERTYNAME_ALBUM_LASTPLAYED            L"LastPlayed"

#define MA_PROPERTYNAME_ALBUMDLD_PREMIUMMETA        L"PremiumMeta"
#define MA_PROPERTYNAME_ALBUMDLD_PREMIUMMETACACHE   L"PremiumMetaCache"
#define MA_PROPERTYNAME_ALBUMDLD_DOWNLOADDATE       L"DownloadDate"
#define MA_PROPERTYNAME_ALBUMDLD_PROVIDER           L"Provider"

#define MA_PROPERTYNAME_ALBUMTRACK_TITLE            L"Title"
#define MA_PROPERTYNAME_ALBUMTRACK_LYRICS           L"Lyrics"
#define MA_PROPERTYNAME_ALBUMTRACK_LENGTH           L"Length"
#define MA_PROPERTYNAME_ALBUMTRACK_LASTPLAYED       L"LastPlayed"

#define MA_PROPERTYNAME_ALBUMPLAYLIST_NAME          L"Name"

#define MA_PROPERTYNAME_PLAYLIST_NAME               L"Name"

#define MA_PROPERTYNAME_PLAYLISTFROMALBUM_NAME      L"Name"

#define MA_PROPERTYNAME_TRACK_FILENAME              L"Filename"
#define MA_PROPERTYNAME_TRACK_TITLE                 L"Title"
#define MA_PROPERTYNAME_TRACK_SUBTITLE              L"Subtitle"
#define MA_PROPERTYNAME_TRACK_COPYRIGHT             L"Copyright"
#define MA_PROPERTYNAME_TRACK_FILETYPE              L"Filetype"
#define MA_PROPERTYNAME_TRACK_TIME                  L"Time"
#define MA_PROPERTYNAME_TRACK_DATE                  L"Date"
#define MA_PROPERTYNAME_TRACK_LANGUAGE              L"Language"
#define MA_PROPERTYNAME_TRACK_MEDIATYPE             L"MediaType"
#define MA_PROPERTYNAME_TRACK_PARTINSET             L"PartInSet"
#define MA_PROPERTYNAME_TRACK_ENCODEDBY             L"EncodedBy"
#define MA_PROPERTYNAME_TRACK_PUBLISHER             L"Publisher"
#define MA_PROPERTYNAME_TRACK_TRACKNUMBER           L"TrackNumber"
#define MA_PROPERTYNAME_TRACK_RECORDINGDATES        L"RecordingDates"
#define MA_PROPERTYNAME_TRACK_NETRADIOSTATION       L"NetRadioStation"
#define MA_PROPERTYNAME_TRACK_NETRADIOOWNER         L"NetRadioOwner"
#define MA_PROPERTYNAME_TRACK_YEAR                  L"Year"
#define MA_PROPERTYNAME_TRACK_BEATSPERMINUTE        L"BeatsPerMinute"
#define MA_PROPERTYNAME_TRACK_MUSICALKEY            L"MusicalKey"
#define MA_PROPERTYNAME_TRACK_LENGTHINMILLISECONDS  L"LengthInMilliseconds"
#define MA_PROPERTYNAME_TRACK_ALBUM                 L"Album"
#define MA_PROPERTYNAME_TRACK_ORIGINALALBUM         L"OriginalAlbum"
#define MA_PROPERTYNAME_TRACK_ORIGINALFILENAME      L"OriginalFilename"
#define MA_PROPERTYNAME_TRACK_ORIGINALRELEASEYEAR   L"OriginalReleaseYear"
#define MA_PROPERTYNAME_TRACK_FILEOWNER             L"FileOwner"
#define MA_PROPERTYNAME_TRACK_SIZE                  L"Size"
#define MA_PROPERTYNAME_TRACK_ISRC                  L"ISRC"
#define MA_PROPERTYNAME_TRACK_SOFTWARE              L"Software"
#define MA_PROPERTYNAME_TRACK_RATING                L"Rating"
#define MA_PROPERTYNAME_TRACK_COMMENT               L"Comment"

#define MA_PROPERTYNAME_TRACKDYNA_TRACKEDLINK       L"TrackedLink"

#define MA_PROPERTYNAME_BATCH_CDID                  L"CDID"
#define MA_PROPERTYNAME_BATCH_NUMTRACKS             L"NumTracks"
#define MA_PROPERTYNAME_BATCH_TOC                   L"TOC"

#define MA_PROPERTYNAME_LINK_NAME                   L"Name"
#define MA_PROPERTYNAME_LINK_URL                    L"URL"

#define MA_PROPERTYNAME_PICTURE_CAPTION             L"Caption"
#define MA_PROPERTYNAME_PICTURE_URL                 L"URL"
#define MA_PROPERTYNAME_PICTURE_TRACKEDLINK         L"TrackedLink"
#define MA_PROPERTYNAME_PICTURE_THUMBNAIL           L"Thumbnail"

//Property Types
#define MA_PROPERTYTYPE_GENRE_NAME                  1

#define MA_PROPERTYTYPE_ARTIST_NAME                 1
#define MA_PROPERTYTYPE_ARTIST_ROLE                 1

#define MA_PROPERTYTYPE_USERCOLLECTION_NAME         1

#define MA_PROPERTYTYPE_ALBUM_TITLE                 1
#define MA_PROPERTYTYPE_ALBUM_COPYRIGHT             1
#define MA_PROPERTYTYPE_ALBUM_LABEL                 1
#define MA_PROPERTYTYPE_ALBUM_RELEASEDATE           2
#define MA_PROPERTYTYPE_ALBUM_RATING                1
#define MA_PROPERTYTYPE_ALBUM_RATINGORG             1
#define MA_PROPERTYTYPE_ALBUM_CDID                  0
#define MA_PROPERTYTYPE_ALBUM_TOC                   3
#define MA_PROPERTYTYPE_ALBUM_LASTPLAYED            2

#define MA_PROPERTYTYPE_ALBUMDLD_PREMIUMMETA        3
#define MA_PROPERTYTYPE_ALBUMDLD_PREMIUMMETACACHE   3
#define MA_PROPERTYTYPE_ALBUMDLD_DOWNLOADDATE       2
#define MA_PROPERTYTYPE_ALBUMDLD_PROVIDER           1

#define MA_PROPERTYTYPE_ALBUMTRACK_TITLE            1
#define MA_PROPERTYTYPE_ALBUMTRACK_LYRICS           4
#define MA_PROPERTYTYPE_ALBUMTRACK_LENGTH           0
#define MA_PROPERTYTYPE_ALBUMTRACK_LASTPLAYED       2

#define MA_PROPERTYTYPE_ALBUMPLAYLIST_NAME          1

#define MA_PROPERTYTYPE_PLAYLIST_NAME               1

#define MA_PROPERTYTYPE_PLAYLISTFROMALBUM_NAME      1

#define MA_PROPERTYTYPE_TRACK_FILENAME              1
#define MA_PROPERTYTYPE_TRACK_TITLE                 1
#define MA_PROPERTYTYPE_TRACK_SUBTITLE              1
#define MA_PROPERTYTYPE_TRACK_COPYRIGHT             1
#define MA_PROPERTYTYPE_TRACK_FILETYPE              1
#define MA_PROPERTYTYPE_TRACK_TIME                  1
#define MA_PROPERTYTYPE_TRACK_DATE                  1
#define MA_PROPERTYTYPE_TRACK_LANGUAGE              1
#define MA_PROPERTYTYPE_TRACK_MEDIATYPE             1
#define MA_PROPERTYTYPE_TRACK_PARTINSET             1
#define MA_PROPERTYTYPE_TRACK_ENCODEDBY             1
#define MA_PROPERTYTYPE_TRACK_PUBLISHER             1
#define MA_PROPERTYTYPE_TRACK_TRACKNUMBER           1
#define MA_PROPERTYTYPE_TRACK_RECORDINGDATES        1
#define MA_PROPERTYTYPE_TRACK_NETRADIOSTATION       1
#define MA_PROPERTYTYPE_TRACK_NETRADIOOWNER         1
#define MA_PROPERTYTYPE_TRACK_YEAR                  1
#define MA_PROPERTYTYPE_TRACK_BEATSPERMINUTE        1
#define MA_PROPERTYTYPE_TRACK_MUSICALKEY            1
#define MA_PROPERTYTYPE_TRACK_LENGTHINMILLISECONDS  1
#define MA_PROPERTYTYPE_TRACK_ALBUM                 1
#define MA_PROPERTYTYPE_TRACK_ORIGINALALBUM         1
#define MA_PROPERTYTYPE_TRACK_ORIGINALFILENAME      1
#define MA_PROPERTYTYPE_TRACK_ORIGINALRELEASEYEAR   1
#define MA_PROPERTYTYPE_TRACK_FILEOWNER             1
#define MA_PROPERTYTYPE_TRACK_SIZE                  1
#define MA_PROPERTYTYPE_TRACK_ISRC                  1
#define MA_PROPERTYTYPE_TRACK_SOFTWARE              1
#define MA_PROPERTYTYPE_TRACK_RATING                1
#define MA_PROPERTYTYPE_TRACK_COMMENT               1

#define MA_PROPERTYTYPE_TRACKDYNA_TRACKEDLINK       6

#define MA_PROPERTYTYPE_BATCH_CDID                  0
#define MA_PROPERTYTYPE_BATCH_NUMTRACKS             0
#define MA_PROPERTYTYPE_BATCH_TOC                   3

#define MA_PROPERTYTYPE_LINK_NAME                   1
#define MA_PROPERTYTYPE_LINK_URL                    3

#define MA_PROPERTYTYPE_PICTURE_CAPTION             1
#define MA_PROPERTYTYPE_PICTURE_URL                 3
#define MA_PROPERTYTYPE_PICTURE_TRACKEDLINK         6
#define MA_PROPERTYTYPE_PICTURE_THUMBNAIL           4

#ifdef __cplusplus
};
#endif

#endif  //_MAGUIDS_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\intlid.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    intlid.h

Abstract:

    This module contains the resource ids for the Regional Options applet.

Revision History:

--*/


//
//  Text String Constants.
//

//
//  Make sure the next two definitions are not redefined.
//     (This file included by main.cpl)
//
#ifndef IDS_NAME
  #define IDS_NAME                     1
#endif
#ifndef IDS_INFO
  #define IDS_INFO                     2
#endif

#define IDS_NAME_CUSTOM                3
#define IDS_LOCALE_GET_ERROR           4
#define IDS_INVALID_USE_OF_NUM         5
#define IDS_INVALID_TIME_STYLE         6
#define IDS_INVALID_DATE_STYLE         7
#define IDS_NO_LZERO                   8
#define IDS_LZERO                      9
#define IDS_METRIC                     10
#define IDS_US                         11
#define IDS_LOCALE_SET_ERROR           12
#define IDS_LOCALE_NO_NUMS_IN          13
#define IDS_LOCALE_DECIMAL_SYM         14
#define IDS_LOCALE_NEG_SIGN            15
#define IDS_LOCALE_GROUP_SYM           16
#define IDS_LOCALE_TIME_SEP            17
#define IDS_LOCALE_AM_SYM              18
#define IDS_LOCALE_PM_SYM              19
#define IDS_LOCALE_DATE_SEP            20
#define IDS_LOCALE_CURR_SYM            21
#define IDS_LOCALE_CDECIMAL_SYM        22
#define IDS_LOCALE_CGROUP_SYM          23
#define IDS_LOCALE_STYLE_ERR           24
#define IDS_LOCALE_TIME                25
#define IDS_LOCALE_SDATE               26
#define IDS_LOCALE_LDATE               27
#define IDS_LOCALE_YEAR_ERROR          28
#define IDS_LOCALE_SUP_LANG            29

#define IDS_STYLEUH                    55
#define IDS_STYLELH                    56
#define IDS_STYLEUM                    57
#define IDS_STYLELM                    58
#define IDS_STYLELS                    59
#define IDS_STYLELT                    60
#define IDS_STYLELD                    61
#define IDS_STYLELY                    62
#define IDS_TIMECHARS                  63
#define IDS_TCASESWAP                  64
#define IDS_SDATECHARS                 65
#define IDS_SDCASESWAP                 66
#define IDS_LDATECHARS                 67
#define IDS_LDCASESWAP                 68
#define IDS_REBOOT_STRING              69
#define IDS_TITLE_STRING               70
#define IDS_SETUP_STRING               71

#define IDS_ML_PERMANENT               72
#define IDS_ML_CANNOT_MODIFY           73
#define IDS_ML_COPY_FAILED             74
#define IDS_ML_INSTALL_FAILED          75
#define IDS_ML_SETUP_FAILED            76

#define IDS_KBD_LOAD_KBD_FAILED        83

#define IDS_TEXT_INPUT_METHODS         84

#define IDS_SUP_LANG_SUP_INST_TITLE    85
#define IDS_SUP_LANG_SUP_REM_TITLE     86
#define IDS_SUP_LANG_SUP_COMPLEX_INST  87
#define IDS_SUP_LANG_SUP_CJK_INST      88
#define IDS_SUP_LANG_SUP_COMPLEX_INST64  104
#define IDS_SUP_LANG_SUP_CJK_INST64    105
#define IDS_SUP_LANG_SUP_COMPLEX_REM   89
#define IDS_SUP_LANG_SUP_CJK_REM       90

#define IDS_DEF_USER_CONF_TITLE        91
#define IDS_DEF_USER_CONF              92

#define IDS_LOG_FONT_SUBSTITUTE        93

#define IDS_SPANISH_NAME               96
#define IDS_DEFAULT                    97

#define IDS_DEFAULT_USER_ERROR         99
#define IDS_CHANGE_UI_LANG_NOT_ADMIN   100

#define IDS_LOCALE_UNKNOWN             103

#ifndef IDS_UNKNOWN
  #define IDS_UNKNOWN                  198
#endif



//
//  Dialogs.
//

#define DLG_GENERAL                              101
#define DLG_LANGUAGES                            102
#define DLG_ADVANCED                             104
#define DLG_NUMBER                               105
#define DLG_CURRENCY                             106
#define DLG_TIME                                 107
#define DLG_DATE                                 108
#define DLG_SORTING                              109
#define DLG_SETUP_INFORMATION                    200
#define DLG_INPUT_LOCALES                        500

//
//  Icons.
//

#define IDI_ICON                       200


//
//  Digit Substitution Strings.
//

#define IDS_DIGIT_SUBST_CONTEXT        900
#define IDS_DIGIT_SUBST_NONE           (IDS_DIGIT_SUBST_CONTEXT + 1)
#define IDS_DIGIT_SUBST_NATIONAL       (IDS_DIGIT_SUBST_CONTEXT + 2)



//
//  Misc. Controls.
//

#define IDC_STATIC                     -1
#define IDC_GROUPBOX1                  1001
#define IDC_GROUPBOX2                  1002
#define IDC_GROUPBOX3                  1003
#define IDC_GROUPBOX4                  1004
#define IDC_SAMPLE1                    1005
#define IDC_SAMPLE2                    1006
#define IDC_SAMPLELBL1                 1007
#define IDC_SAMPLELBL2                 1008
#define IDC_SAMPLELBL3                 1009
#define IDC_SAMPLE1A                   1010
#define IDC_SAMPLE2A                   1011
#define IDC_SAMPLELBL1A                1012
#define IDC_SAMPLELBL2A                1013



//
//  General Page Controls.
//

#define IDC_USER_LOCALE_TEXT           1020
#define IDC_USER_LOCALE                1021
#define IDC_USER_REGION_TEXT           1022
#define IDC_USER_REGION                1023
#define IDC_CUSTOMIZE                  1024
#define IDC_SAMPLE_TEXT                1025
#define IDC_TEXT1                      1026
#define IDC_TEXT2                      1027
#define IDC_TEXT3                      1028
#define IDC_TEXT4                      1029
#define IDC_TEXT5                      1030
#define IDC_TEXT6                      1031
#define IDC_NUMBER_SAMPLE              1032
#define IDC_CURRENCY_SAMPLE            1033
#define IDC_TIME_SAMPLE                1034
#define IDC_SHRTDATE_SAMPLE            1035
#define IDC_LONGDATE_SAMPLE            1036


//
// Languages Dialog Controls
//

#define IDC_LANGUAGE_LIST_TEXT         1171
#define IDC_LANGUAGE_CHANGE            1172
#define IDC_LANGUAGE_COMPLEX           1173
#define IDC_LANGUAGE_CJK               1174
#define IDC_LANGUAGE_SUPPL_TEXT        1175
#define IDC_UI_LANGUAGE_TEXT           1177
#define IDC_UI_LANGUAGE                1178


//
//  Advanced Page Controls.
//

#define IDC_SYSTEM_LOCALE_TEXT1        1050
#define IDC_SYSTEM_LOCALE_TEXT2        1051
#define IDC_SYSTEM_LOCALE              1052
#define IDC_CODEPAGES                  1053
#define IDC_DEFAULT_USER               1054
#ifdef TEMP_UI
#define IDC_LANGUAGE_GROUPS            1056
#define IDC_CODEPAGE_CONVERSIONS       1057
#endif // TEMP_UI


//
//  Number and Currency Page Controls.
//

#define IDC_DECIMAL_SYMBOL             1070
#define IDC_CURRENCY_SYMBOL            1071
#define IDC_NUM_DECIMAL_DIGITS         1072
#define IDC_DIGIT_GROUP_SYMBOL         1073
#define IDC_NUM_DIGITS_GROUP           1074
#define IDC_POS_SIGN                   1075
#define IDC_NEG_SIGN                   1076
#define IDC_POS_CURRENCY_SYM           1077
#define IDC_NEG_NUM_FORMAT             1078
#define IDC_SEPARATOR                  1079
#define IDC_DISPLAY_LEAD_0             1080
#define IDC_MEASURE_SYS                1081
#define IDC_NATIVE_DIGITS_TEXT         1082
#define IDC_NATIVE_DIGITS              1083
#define IDC_DIGIT_SUBST_TEXT           1084
#define IDC_DIGIT_SUBST                1085



//
//  Time Page Controls.
//

#define IDC_TIME_STYLE                 1090
#define IDC_AM_SYMBOL                  1091
#define IDC_PM_SYMBOL                  1092



//
//  Date Page Controls.
//

#define IDC_CALENDAR_TYPE_TEXT         1100
#define IDC_CALENDAR_TYPE              1101
#define IDC_TWO_DIGIT_YEAR_LOW         1102
#define IDC_TWO_DIGIT_YEAR_HIGH        1103
#define IDC_TWO_DIGIT_YEAR_ARROW       1104
#define IDC_ADD_HIJRI_DATE             1105
#define IDC_SHORT_DATE_STYLE           1106
#define IDC_LONG_DATE_STYLE            1107
#define IDC_ADD_HIJRI_DATE_TEXT        1108


//
//  Sorting Page Controls.
//

#define IDC_SORTING                    1120
#define IDC_SORTING_TEXT1              1121
#define IDC_SORTING_TEXT2              1122

//
//  Unattended Log string
//

#define IDS_LOG_HEAD                   2330
#define IDS_LOG_FILE_ERROR             2331
#define IDS_LOG_INTL_ERROR             2332
#define IDS_LOG_SETUP_ERROR            2333
#define IDS_LOG_UPGRADE_SCENARIO       2334
#define IDS_LOG_SETUP_MODE             2335
#define IDS_LOG_SWITCH_G               2336
#define IDS_LOG_SWITCH_R               2337
#define IDS_LOG_SWITCH_I               2338
#define IDS_LOG_SWITCH_S               2339
#define IDS_LOG_SWITCH_F               2340
#define IDS_LOG_SWITCH_M               2341
#define IDS_LOG_SWITCH_U               2342
#define IDS_LOG_SWITCH_DEFAULT         2343
#define IDS_LOG_LANG_GROUP             2344
#define IDS_LOG_LANG                   2345
#define IDS_LOG_SYS_LOCALE             2346
#define IDS_LOG_SYS_LOCALE_DEF         2347
#define IDS_LOG_USER_LOCALE            2348
#define IDS_LOG_USER_LOCALE_DEF        2349
#define IDS_LOG_MUI_LANG               2350
#define IDS_LOG_MUI_LANG_DEF           2351
#define IDS_LOG_INPUT                  2352
#define IDS_LOG_INPUT_DEF              2353
#define IDS_LOG_LAYOUT                 2354
#define IDS_LOG_LAYOUT_INSTALLED       2355
#define IDS_LOG_INV_BLOCK              2356
#define IDS_LOG_NO_ADMIN               2357
#define IDS_LOG_SYS_LOCALE_CHG         2358
#define IDS_LOG_USER_LOCALE_CHG        2359
#define IDS_LOG_UNI_BLOCK              2360
#define IDS_LOG_SYS_DEF_LAYOUT         2361
#define IDS_LOG_USER_DEF_LAYOUT        2362
#define IDS_LOG_NO_VALID_FOUND         2363
#define IDS_LOG_EXT_LANG_FAIL          2364
#define IDS_LOG_EXT_LANG_CANCEL        2365
#define IDS_LOG_LOCALE_ACP_FAIL        2366
#define IDS_LOG_LOCALE_KBD_FAIL        2367
#define IDS_LOG_INVALID_LOCALE         2368
#define IDS_LOG_UNAT_HEADER            2369
#define IDS_LOG_UNAT_FOOTER            2370
#define IDS_LOG_UI_BLOCK               2371
#define IDS_LOG_UNAT_LOCATED           2372
#define IDS_LOG_LOCALE_LG_FAIL         2373
#define IDS_LOG_LOCALE_LG_REM          2374

//
//  Ordinal for Text Services functions.
//
#define ORD_INPUT_DLG_PROC            101
#define ORD_INPUT_INST_LAYOUT         102
#define ORD_INPUT_UNINST_LAYOUT       103
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\locbstr.h ===
// Local BSTR derived from WTL3.1 CString Class

#ifndef __LOCAL_BSTR__
#define __LOCAL_BSTR__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlmisc.h requires atlapp.h to be included first
#endif

namespace LBSTR
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

#ifndef _WTL_NO_LOCAL_BSTR
class CString;
#endif //!_WTL_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// CString - String class

#ifdef DEBUG
#define VERIFY_LOCAL_BSTR
#endif

#ifdef VERIFY_LOCAL_BSTR

#ifdef DEBUG

#define VERIFY_ASSERT(expr) ASSERT(expr)

#else

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtRetailBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtRetailBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtRetailBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtRetailBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtRetailBreak(
        void
        );
#endif

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RETAIL_ASSERT_BASE(expr) \
        (void) ((expr) || \
                (_CrtRetailBreak(), 0))
#else
#define _RETAIL_ASSERT_BASE(expr) \
        do { if (!(expr)) \
             _CrtRetailBreak(); } while (0)
#endif

#define VERIFY_ASSERT(expr) _RETAIL_ASSERT_BASE(expr)

#endif  // DEBUG

#endif  // VERIFY_LOCAL_BSTR

#ifndef _WTL_NO_LOCAL_BSTR

class CStringData
{
public:

#ifdef VERIFY_LOCAL_BSTR
    int nStartTag;
#endif

    long nRefs;     // reference count
    int nDataLength;
    int nAllocLength;

#ifdef VERIFY_LOCAL_BSTR
    int nMiddleTag;
#endif

    ULONG cbDataLength;

    void SetDataLength( int p_nDataLength )
    {
        ASSERT( p_nDataLength >= 0 );
        nDataLength = p_nDataLength;
        cbDataLength = p_nDataLength * sizeof(TCHAR);
    }

	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this + 1); }

#ifdef VERIFY_LOCAL_BSTR
    BYTE * GetTagPtr(void)
    {
        TCHAR *     pzEndTag;

        pzEndTag = data() + ( nAllocLength + 1 );

        return (BYTE *) pzEndTag;
    }

    int GetEndTag(void)
    {
        int         nEnd;

        memcpy( &nEnd, GetTagPtr(), sizeof(int) );

        return nEnd;
    }

    void SetEndTag( int nEnd )
    {
        memcpy( GetTagPtr(), &nEnd, sizeof(int) );
    }
#endif
};

// Globals

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)

#ifdef VERIFY_LOCAL_BSTR

const int START_TAG = 0x01234567;
const int MIDDLE_TAG = 0x89abcdef;
const int END_TAG = 0xfedcba98;

_declspec(selectany) int rgInitData[] = { START_TAG, -1, 0, 0, MIDDLE_TAG, 0, 0, END_TAG };

#else

_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0, 0 };

#endif

_declspec(selectany) CStringData* _atltmpDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR _atltmpPchNil = (LPCTSTR)(((BYTE*)&rgInitData) + sizeof(CStringData));


class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

#ifdef VERIFY_LOCAL_BSTR
    void VerifyInitData( void )
    {
        VerifyBlankData();

        CStringData *   pData = GetData();

        VerifyTagData( pData );
    }
#endif

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string
    operator BSTR() const;              // as a BSTR string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// advanced manipulation
	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Concatentation for non strings
	const CString& Append(int n)
	{
		TCHAR szBuffer[10];
		wsprintf(szBuffer,_T("%d"),n);
		ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
		return *this;
	}

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

	static BOOL __stdcall _IsValidString(LPCWSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrW(lpsz, nLength);
	}

	static BOOL __stdcall _IsValidString(LPCSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrA(lpsz, nLength);
	}

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	BOOL ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);

	static int __stdcall _LoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
	{
#ifdef _DEBUG
		// LoadString without annoying warning from the Debug kernel if the
		//  segment containing the string is not present
		if (::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE((nID>>4) + 1), RT_STRING) == NULL)
		{
			lpszBuf[0] = '\0';
			return 0; // not found
		}
#endif //_DEBUG
		int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
		if (nLen == 0)
			lpszBuf[0] = '\0';
		return nLen;
	}

#ifdef VERIFY_LOCAL_BSTR
    static void VerifyBlankData( void )
    {
        VERIFY_ASSERT( rgInitData[0] == START_TAG );
        VERIFY_ASSERT( rgInitData[1] == -1 );
        VERIFY_ASSERT( rgInitData[2] == 0 );
        VERIFY_ASSERT( rgInitData[3] == 0 );
        VERIFY_ASSERT( rgInitData[4] == MIDDLE_TAG );
        VERIFY_ASSERT( rgInitData[5] == 0 );
        VERIFY_ASSERT( rgInitData[6] == 0 );
        VERIFY_ASSERT( rgInitData[7] == END_TAG );
    }

    static void VerifyTagData( CStringData * pData )
    {
        if ( pData && pData != _atltmpDataNil )
        {
            VERIFY_ASSERT( pData->nStartTag == START_TAG );
            VERIFY_ASSERT( pData->nMiddleTag == MIDDLE_TAG );
            VERIFY_ASSERT( pData->GetEndTag() == END_TAG );
        }
    }
#endif

	static const CString& __stdcall _GetEmptyString()
	{
#ifdef VERIFY_LOCAL_BSTR
        VerifyBlankData();
#endif

		return *(CString*)&_atltmpPchNil;
	}

// CString conversion helpers
	static int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
	{
		if (count == 0 && mbstr != NULL)
			return 0;

		int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, (int)count, NULL, NULL);
		ATLASSERT(mbstr == NULL || result <= (int)count);
		if (result > 0)
			mbstr[result - 1] = 0;
		return result;
	}

	static int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
	{
		if (count == 0 && wcstr != NULL)
			return 0;

		int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, (int)count);
		ATLASSERT(wcstr == NULL || result <= (int)count);
		if (result > 0)
			wcstr[result - 1] = 0;
		return result;
	}

// Helpers to avoid CRT startup code
	static TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = ::CharNext(p);
		}
		return (TCHAR*)((*p == ch) ? p : NULL);
	}
	static TCHAR* _cstrchr_db(const TCHAR* p, TCHAR ch1, TCHAR ch2)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch1 && *(p + 1) == ch2)
			{
				lpsz = p;
				break;
			}
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrchr(const TCHAR* p, TCHAR ch)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch)
				lpsz = p;
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrev(TCHAR* pStr)
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((pStr == NULL) || (pStr[0] == '\0') || (pStr[1] == '\0'))
			return pStr;

		TCHAR* p = pStr;

		while (p[1] != 0) 
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				char p1 = *(char*)p;
				*(char*)p = *(char*)(p + 1);
				*(char*)(p + 1) = p1;
			}
			p = pNext;
		}

		TCHAR* q = pStr;

		while (q < p)
		{
			TCHAR t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return (TCHAR*)pStr;
	}
	static TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nLen = lstrlen(pCharSet);
		if (nLen == 0)
			return (TCHAR*)pStr;

		const TCHAR* pRet = NULL;
		const TCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = ::CharNext(pCur);
		}
		return (TCHAR*) pRet;
	}
	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
	{
		while (*p != 0)
		{
			if (_cstrchr(lpszCharSet, *p) != NULL)
			{
				return (TCHAR*)p;
				break;
			}
			p = ::CharNext(p);
		}
		return NULL;
	}

	static int _cstrisdigit(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int _cstrisspace(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int _cstrcmp(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmp(pstrOne, pstrOther);
	}

	static int _cstrcmpi(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmpi(pstrOne, pstrOther);
	}

	static int _cstrcoll(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}

	static int _cstrcolli(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);


/////////////////////////////////////////////////////////////////////////////
// CString Implementation

inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData) - 1; }
inline void CString::Init()
	{ m_pchData = _GetEmptyString().m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline CString::operator BSTR() const
    { return (BSTR) m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _cstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _cstrcmpi(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _cstrcoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (nLen == 0)
	{
		Init();
	}
	else
	{
		CStringData* pData = NULL;
        int cbBufLen = sizeof(CStringData) + (nLen + 1) * sizeof(TCHAR);

#ifdef VERIFY_LOCAL_BSTR
        cbBufLen += sizeof(int);        // End Tag
#endif

		ATLTRY(pData = (CStringData*)new BYTE[ cbBufLen ]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
        pData->SetDataLength( nLen );
		pData->nAllocLength = nLen;
		m_pchData = pData->data();

#ifdef VERIFY_LOCAL_BSTR
        pData->nStartTag = START_TAG;
        pData->nMiddleTag = MIDDLE_TAG;
        pData->SetEndTag( END_TAG );
#endif
	}

	return TRUE;
}

inline void CString::Release()
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (GetData() != _atltmpDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyBlankData();
    VerifyTagData( pData );
#endif

	if (pData != _atltmpDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;

	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = _T("");

	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength + 1) * sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (GetData() != _atltmpDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData + nCopyIndex, nCopyLen * sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
			ATLTRACE2(atlTraceUI, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen * sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen * 2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->SetDataLength( nSrcLen );
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _atltmpDataNil) || stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen * 2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline BOOL CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	BOOL bRet = TRUE;
	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		bRet = AllocBuffer(nNewLen);
		if (bRet)
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len * sizeof(TCHAR));
			memcpy(m_pchData + nSrc1Len, lpszSrc2Data, nSrc2Len * sizeof(TCHAR));
		}
	}
	return bRet;
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData, CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		if (ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData))
		{
			ATLASSERT(pOldData != NULL);
			CString::Release(pOldData);
		}
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData + GetData()->nDataLength, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->SetDataLength( GetData()->nDataLength + nSrcLen );
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;

		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen + 1) * sizeof(TCHAR));
            GetData()->SetDataLength( nOldLen );
			CString::Release(pOldData);
		}
	}

	ATLASSERT(GetData()->nRefs <= 1);

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

    // return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
    GetData()->SetDataLength( nNewLength );
	m_pchData[nNewLength] = '\0';

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);

    if ( GetAllocLength() >= nNewLength )
    {
        GetData()->SetDataLength( nNewLength );
	    m_pchData[nNewLength] = '\0';
    }

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength * sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != _atltmpDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _cstrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _cstrpbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	CharUpper(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	CharLower(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_cstrrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength * sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrcspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _cstrrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(_IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _cstrstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	enum _FormatModifiers
	{
		FORCE_ANSI =	0x10000,
		FORCE_UNICODE =	0x20000,
		FORCE_INT64 =	0x40000
	};

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = ::CharNext(lpsz)) == '%')
		{
			nMaxLen += (int)lstrlen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' || *lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = ::CharNext(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = ::CharNext(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if(lpsz[0] == _T('I') && lpsz[1] == _T('6') && lpsz[2] == _T('4'))
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = ::CharNext(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = ::CharNext(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = ::CharNext(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR);
			break;
		case 'c' | FORCE_ANSI:
		case 'C' | FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, char);
			break;
		case 'c' | FORCE_UNICODE:
		case 'C' | FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6;  // "(null)"
			}
			else
			{
				nItemLen = lstrlen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6;  // "(null)"
			}
			else
			{
				nItemLen = (int)wcslen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's' | FORCE_ANSI:
		case 'S' | FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's' | FORCE_UNICODE:
		case 'S' | FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = (int)wcslen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

#ifndef _ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'f':
			case 'g':
			case 'G':
				ATLASSERT(!"Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class.");
#ifndef _DEBUG
				::OutputDebugString(_T("Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class."));
				::DebugBreak();
#endif //!_DEBUG
				break;
#else //_ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, double);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;
			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312 + nPrecision + 6));

					f = va_arg(argList, double);
					_stprintf(pszTemp, _T( "%*.*f" ), nWidth, nPrecision + 6, f);
					nItemLen = _tcslen(pszTemp);
				}
				break;
#endif //_ATL_USE_CSTRING_FLOAT

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
#ifndef _ATL_USE_CSTRING_FLOAT
	int nRet = wvsprintf(m_pchData, lpszFormat, argListSave);
#else //_ATL_USE_CSTRING_FLOAT
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
#endif //_ATL_USE_CSTRING_FLOAT
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_cstrisspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
		{
			lpszLast = NULL;
		}
		lpsz = ::CharNext(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
        GetData()->SetDataLength( (int)(DWORD_PTR)(lpszLast - m_pchData) );
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_cstrisspace(*lpsz))
		lpsz = ::CharNext(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength + 1) * sizeof(TCHAR));
    GetData()->SetDataLength( nDataLength );
}

inline int CString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memmove(m_pchData + nIndex, m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
        GetData()->SetDataLength( nNewLength - nCount );
	}

	return nNewLength;
}

inline int CString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		if(!AllocBuffer(nNewLength))
			return -1;
		memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
		CString::Release(pOldData);
	}

	// move existing bytes down
	memmove(m_pchData + nIndex + 1, m_pchData + nIndex, (nNewLength - nIndex) * sizeof(TCHAR));
	m_pchData[nIndex] = ch;
    GetData()->SetDataLength( nNewLength );

	return nNewLength;
}

inline int CString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
			CString::Release(pOldData);
		}

		// move existing bytes down
		memmove(m_pchData + nIndex + nInsertLength, m_pchData + nIndex, (nNewLength - nIndex - nInsertLength + 1) * sizeof(TCHAR));
		memcpy(m_pchData + nIndex, pstr, nInsertLength * sizeof(TCHAR));
        GetData()->SetDataLength( nNewLength );
	}

	return nNewLength;
}

inline int CString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = ::CharNext(psz);
		}
	}
	return nCount;
}

inline int CString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen - nSourceLen) * nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, pOldData->nDataLength * sizeof(TCHAR));
			CString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - ((int)(DWORD_PTR)(lpszTarget - m_pchData) + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen, nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen * sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ATLASSERT(m_pchData[nNewLength] == '\0');
        GetData()->SetDataLength( nNewLength );
	}

	return nCount;
}

inline int CString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = ::CharNext(pstrDest);
		}
		pstrSource = ::CharNext(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = (int)(DWORD_PTR)(pstrSource - pstrDest);
    GetData()->SetDataLength( GetData()->nDataLength - nCount );

    return nCount;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = _LoadString(nID, GetBuffer(nSize - 1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_WTL_NO_CSTRING

}; //namespace LBSTR

#endif // __LOCAL_BSTR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\isos.c ===
#include <shlwapi.h>

#if (_WIN32_WINNT >= 0x0500)
#include <lm.h> // for NetGetJoinInformation
#endif

// stolen from winuser
#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION        0x1000
#endif


BOOL IsWinlogonRegValueSet(HKEY hKey, LPSTR pszKeyName, LPSTR pszPolicyKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //  first check the per-machine location.
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }
    
    //  then let the policy value override
    if (RegOpenKeyExA(hKey, pszPolicyKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }

    return bRet;
}

BOOL IsWinlogonRegValuePresent(HKEY hKey, LPSTR pszKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //  first check the per-machine location.
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        char szValueData[MAX_PATH];

        dwSize = sizeof(szValueData);
        bRet = (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)szValueData, &dwSize) == ERROR_SUCCESS);
        RegCloseKey(hkey);
    }
    
    return bRet;
}

/*
BOOL IsTermsrvRunning()
{
    BOOL fResult = TRUE; // assume the service is running
    SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCManager)
    {
        SC_HANDLE hSCService = OpenService(hSCManager, TEXT("TermService"), SERVICE_QUERY_CONFIG);

        if (hSCService)
        {
            SERVICE_STATUS ServiceStatus;

            if (QueryServiceStatus(hSCService, &ServiceStatus))
            {
                if ((ServiceStatus.dwCurrentState == SERVICE_START_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_RUNNING)       ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING))
                {
                   fResult = FALSE;
                }
            }
        }

        CloseServiceHandle(hSCManager);
    }

    return fResult;
}
*/

#if (_WIN32_WINNT >= 0x0500)
// Have to use a LoadLibrary/GetProcAddress thunk since we are part of stock4.lib/stock.lib,
// and we can't require users of stocklib to delayload netapi32.dll
typedef NET_API_STATUS (* NETGETJOININFORMATION) (LPCWSTR, LPWSTR*, PNETSETUP_JOIN_STATUS);
NET_API_STATUS NT5_NetGetJoinInformation(LPCWSTR pszServer, LPWSTR* ppszNameBuffer, PNETSETUP_JOIN_STATUS BufferType)
{
    static NETGETJOININFORMATION s_pfn = (NETGETJOININFORMATION)-1;

    if (s_pfn == (NETGETJOININFORMATION)-1)
    {
        if (IsOS(OS_WIN2000ORGREATER))
        {
            s_pfn = (NETGETJOININFORMATION)GetProcAddress(LoadLibrary(TEXT("netapi32")), "NetGetJoinInformation");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        return s_pfn(pszServer, ppszNameBuffer, BufferType);
    }
    else
    {
        return ERROR_PROC_NOT_FOUND;
    }
}

typedef NET_API_STATUS (* NETAPIBUFFERFREE) (void*);
NET_API_STATUS NT5_NetApiBufferFree(LPVOID pv)
{
    static NETAPIBUFFERFREE s_pfn = (NETAPIBUFFERFREE)-1;

    if (s_pfn == (NETAPIBUFFERFREE)-1)
    {
        if (IsOS(OS_WIN2000ORGREATER))
        {
            s_pfn = (NETAPIBUFFERFREE)GetProcAddress(GetModuleHandle(TEXT("netapi32")), "NetApiBufferFree");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        return s_pfn(pv);
    }
    else
    {
        return ERROR_PROC_NOT_FOUND;
    }
}
#endif  // (_WIN32_WINNT >= 0x0500)


// checks to see if this machine is a member of a domain or not 
// NOTE: this will always return FALSE on downlevel platforms (older than win2k)
BOOL IsMachineDomainMember()
{
// don't call NetGetJoinInformation if we are part of stock4.lib
#if (_WIN32_WINNT >= 0x0500)

    static BOOL s_bIsDomainMember = FALSE;
    static BOOL s_bDomainCached = FALSE;

    if (IsOS(OS_WIN2000ORGREATER) && !s_bDomainCached)
    {
        LPWSTR pwszDomain;
        NETSETUP_JOIN_STATUS njs;
        NET_API_STATUS nas;

        nas = NT5_NetGetJoinInformation(NULL, &pwszDomain, &njs);
        if (nas == NERR_Success)
        {
            if (pwszDomain)
            {
                NT5_NetApiBufferFree(pwszDomain);
            }

            if (njs == NetSetupDomainName)
            {
                // we are joined to a domain!
                s_bIsDomainMember = TRUE;
            }
        }
        
        s_bDomainCached = TRUE;
    }
    
    return s_bIsDomainMember;
#else
    return FALSE;
#endif
}


typedef LONG (WINAPI *PFNTQUERYINFORMATIONPROCESS) (HANDLE ProcessHandle, int ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

// this function checks to see if we are a 32-bit process running on a 64-bit platform
BOOL RunningOnWow64()
{
    static BOOL bRunningOnWow64 = (BOOL)-1;

    if (bRunningOnWow64 == (BOOL)-1)
    {
        PFNTQUERYINFORMATIONPROCESS pfn = (PFNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtQueryInformationProcess");

        if (pfn)
        {
            LONG lStatus;
            ULONG_PTR Wow64Info;

            #define ProcessWow64Information 26  // stolen from ntpsapi.h

            lStatus = pfn(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL); 
            if ((lStatus >= 0) && Wow64Info)
            {
                bRunningOnWow64 = TRUE;
            }
            else
            {
                bRunningOnWow64 = FALSE;
            }
        }
        else
        {
            bRunningOnWow64 = FALSE;
        }
    }

    return bRunningOnWow64;
}


/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) IsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
    case OS_TERMINALCLIENT:
        // WARNING: this will only return TRUE for REMOTE TS sessions (eg you are comming in via tsclient).
        // If you want to see if TS is enabled or if the user is on the TS console, the use one of the other flags.
        bRet = GetSystemMetrics(SM_REMOTESESSION);
        break;

    case OS_WIN2000TERMINAL:
        // WARNING: this flag is VERY ambiguous... you probably want to use one of 
        // OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or  OS_PERSONALTERMINALSERVER instead.
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use one of OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER instead !");
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                s_osvi.dwMajorVersion >= 5);
        break;

    case OS_TERMINALSERVER:
        // NOTE: be careful about using OS_TERMINALSERVER. It will only return true for nt server boxes
        // configured in what used to be called "Applications Server" mode in the win2k days. It is now simply called
        // "Terminal Server" (hence the name of this flag).
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
#ifdef DEBUG
        if (bRet)
        {
            // all "Terminal Server" machines have to be server (cannot be per/pro)
            ASSERT(VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType);
        }
#endif
        break;

    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case OS_PERSONALTERMINALSERVER:
        bRet = ((VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask) &&
                !(VER_SUITE_TERMINAL & s_osvi.wSuiteMask));
        break;

    case OS_FASTUSERSWITCHING:
        bRet = (((VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS) & s_osvi.wSuiteMask) &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "AllowMultipleTSSessions"));
        break;

    case OS_FRIENDLYLOGONUI:
        bRet = (!IsMachineDomainMember() &&
                !IsWinlogonRegValuePresent(HKEY_LOCAL_MACHINE,
                                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                           "GinaDLL") &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "LogonType"));
        break;

    case OS_DOMAINMEMBER:
        bRet = IsMachineDomainMember();
        ASSERT(VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId); // has to be a NT machine to be on a domain!
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED 
    //       (but the ie4 shell32 uses them, so don't RIP on downlevel platforms)
    case OS_WIN2000PRO:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WIN95GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 0 &&
                LOWORD(s_osvi.dwBuildNumber) == 950);
        break;

    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;


    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;

    case OS_PROFESSIONAL:
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) && 
                (VER_NT_WORKSTATION == s_osvi.wProductType));
        break;

    case OS_DATACENTER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_ADVSERVER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_SERVER:
        // NOTE: be careful! this specifically means Server -- will return false for Avanced Server and Datacenter machines
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask));
        break;

    case OS_ANYSERVER:
        // this is for people who want to know if this is ANY type of NT server machine (eg dtc, ads, or srv)
        bRet = ((VER_NT_SERVER == s_osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType));
        break;

    case OS_WOW6432:
        bRet = RunningOnWow64();
        break;

#if (_WIN32_WINNT >= 0x0501)
    case OS_TABLETPC:
        bRet = GetSystemMetrics(SM_TABLETPC);
        break;

    case OS_MEDIACENTER:
        // eHome Freestyle Project
        bRet = GetSystemMetrics(SM_MEDIACENTER);
        break;
#endif

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\krnlcmn.h ===
//---------------------------------------------------------------------------
//
//  KrnlCmn.h
//
//  Include file for common private krnl386/kernel32 APIs.
//
//---------------------------------------------------------------------------

//
//  idProcess can be one of:
//      0L                      --  for current process
//      MAKELONG(hTask, 0)      --  for process with task handle hTask
//      idProcess               --  for real PID
//
//  iIndex is:
//      extra DWORD if >= 0
//      kernel thing if negative
//

#define GPD_PPI                 0       // Going away
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12     // Can be changed
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define	GPD_CURR_PROCESS_ID     -36
#define	GPD_CURR_THREAD_ID      -40
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		-52
#define GPD_COMPATFLAGS         -56

#define CW_USEDEFAULT_32    0x80000000
#define CW_USEDEFAULT_16    0x00008000

#ifdef WIN32
#define INDEX   LONG
#define OURAPI  APIENTRY
#else
#define INDEX   int
#define OURAPI  API

#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  // ;4.0
#define STARTF_HASSHELLDATA     0x00000400  // ;Internal
#endif

#ifndef WINNT
DWORD OURAPI GetProcessDword(DWORD idProcess, INDEX iIndex);
#endif

// 
// For GPD_FLAGS
//
#define GPF_DEBUG_PROCESS   0x00000001
#define GPF_WIN16_PROCESS   0x00000008
#define GPF_DOS_PROCESS     0x00000010
#define GPF_CONSOLE_PROCESS 0x00000020
#define GPF_SERVICE_PROCESS 0x00000100


#undef OURAPI
#undef INDEX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\inststub.h ===
#ifndef __cplusplus
#error Install stub code must be C++!
#endif

#ifndef HINST_THISDLL
#error HINST_THISDLL must be defined!
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

#include <ccstock.h>
#include <stubres.h>
#include <trayp.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <runonce.c>    // shared runonce code for ShellExecuteRegApp()
#ifdef __cplusplus
};
#endif

BOOL CheckWebViewShell();

/* This code runs the install/uninstall stubs recorded in the local-machine
 * part of the registry, iff the current user has not had them run in his
 * context yet.  Used for populating the user's profile with things like
 * links to applications.
 */
//---------------------------------------------------------------------------


BOOL ProfilesEnabled(void)
{
    BOOL fEnabled = FALSE;

    if (staticIsOS(OS_NT)) {
        fEnabled = TRUE;
    }
    else {
        HKEY hkeyLogon;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Network\\Logon"), 0,
                         KEY_QUERY_VALUE, &hkeyLogon) == ERROR_SUCCESS) {
            DWORD fProfiles, cbData = sizeof(fProfiles), dwType;
            if (RegQueryValueEx(hkeyLogon, TEXT("UserProfiles"), NULL, &dwType,
                                (LPBYTE)&fProfiles, &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD || (dwType == REG_BINARY && cbData == sizeof(DWORD)))
                    fEnabled = fProfiles;
            }
            RegCloseKey(hkeyLogon);
        }
    }
    return fEnabled;
}

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//  Snarfed from urlmon\download\helpers.cxx.
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
GetVersionFromString(LPCTSTR szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    LPCTSTR pch = szBuf;
    TCHAR ch;
    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (lstrcmp(pch, TEXT("-1,-1,-1,-1")) == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
    }


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == ',') || (ch == '\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}


// Reg keys and values for install/uninstall stub list.  Each subkey under
// HKLM\Software\InstalledComponents is a component identifier (GUID).
// Each subkey has values "Path" for the EXE to run to install or uninstall;
// IsInstalled (dword) indicating whether the component has been installed
// or uninstalled;  and an optional Revision (dword) used to refresh a
// component without changing its GUID.  Locale (string) is used to describe
// the language/locale for the component;  this string is not interpreted by
// the install stub code, it is just compared between the HKLM and HKCU keys.
// If it's different between the two, the stub is re-run.
//
// HKCU\Software\InstalledComponents contains similar GUID subkeys, but the
// only values under each subkey are the optional Revision and Locale values,
// and an optional DontAsk value (also DWORD).  Presence of the subkey indicates
// that the component is installed for that user.
//
// If the DontAsk value is present under an HKCU subkey and is non-zero, that
// means that the user has decided to keep their settings for that component
// on all machines, even those that have had the component uninstalled, and
// that they don't want to be asked if they want to run the uninstall stub
// every time they log on.  This implies that for that user, the uninstall
// stub will never be run for that component unless the user somehow clears
// the flag.
//
// NOTE: mslocusr.dll also knows these registry paths.

const TCHAR c_szRegInstalledComponentsKey[] = TEXT("Software\\Microsoft\\Active Setup\\Installed Components");
const TCHAR c_szRegInstallStubValue[] = TEXT("StubPath");
const TCHAR c_szRegIsInstalledValue[] = TEXT("IsInstalled");
const TCHAR c_szRegInstallSequenceValue[] = TEXT("Version");
const TCHAR c_szRegDontAskValue[] = TEXT("DontAsk");
const TCHAR c_szRegLocaleValue[] = TEXT("Locale");


UINT ConfirmUninstall(LPCTSTR pszDescription)
{
    /* The only case where the user wouldn't want settings cleaned up on
     * uninstall would be if they'd roamed to a machine that had had this
     * component uninstalled.  If user profiles aren't enabled (which is
     * the case on a fair number of customers' machines), they're certainly
     * not roaming, so there's not much point in asking them.  Just pretend
     * they said YES, they want to clean up the settings.
     */
    if (!ProfilesEnabled())
        return IDYES;

    /* FEATURE - change to a dialog with a checkbox for
     * the don't-ask value.
     */

    TCHAR szTitle[MAX_PATH];
#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#else
    MLLoadString(IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#endif

    TCHAR szMessageTemplate[MAX_PATH];
    LPTSTR pszMessage = NULL;
    int   cchMessage;

#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#else
    MLLoadString(IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#endif


    cchMessage = (lstrlen(szMessageTemplate)+lstrlen(pszDescription)+4)*sizeof(TCHAR);
    pszMessage = (LPTSTR)LocalAlloc(LPTR, cchMessage);
    if (pszMessage)
    {
#ifdef USERSTUB
        wsprintf(pszMessage, szMessageTemplate, pszDescription);
#else
        wnsprintf(pszMessage, cchMessage, szMessageTemplate, pszDescription);
#endif
    }
    else
    {
        pszMessage = szMessageTemplate;
    }

    // due to build in UNICODE the following call is broken under win95, user wsprintf above
    //if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
    //                   FORMAT_MESSAGE_ARGUMENT_ARRAY,
    //                   (LPVOID)szMessageTemplate,
    //                   0,
    //                   0,
    //                   (LPTSTR)&pszMessage,
    //                   0,        /* min chars to allocate */
    //                   (va_list *)&pszDescription)) {
    //    pszMessage = szMessageTemplate;
    //}


    UINT idRet = MessageBox(NULL, pszMessage, szTitle,
                            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND | MB_TOPMOST);

    if (pszMessage != szMessageTemplate)
        LocalFree(pszMessage);

    return idRet;
}


HWND hwndProgress = NULL;
BOOL fTriedProgressDialog = FALSE;

INT_PTR ProgressDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
    case WM_INITDIALOG:
        return TRUE;

    case WM_SETCURSOR:
        SetCursor(LoadCursor(NULL, IDC_WAIT));
        return TRUE;


    default:
        return FALSE;
    }

    return TRUE;
}


void SetProgressInfo(HWND hwndProgress, LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    HWND hwndInstalling = GetDlgItem(hwndProgress, IDC_RUNNING_INSTALL_STUB);
    HWND hwndUninstalling = GetDlgItem(hwndProgress, IDC_RUNNING_UNINSTALL_STUB);

    ShowWindow(hwndInstalling, fInstalling ? SW_SHOW : SW_HIDE);
    EnableWindow(hwndInstalling, fInstalling);
    ShowWindow(hwndUninstalling, fInstalling ? SW_HIDE : SW_SHOW);
    EnableWindow(hwndUninstalling, !fInstalling);
    SetDlgItemText(hwndProgress, IDC_INSTALL_STUB_NAME, pszFriendlyName);
}


void IndicateProgress(LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    if (hwndProgress == NULL && !fTriedProgressDialog) {
        hwndProgress = CreateDialog(HINST_THISDLL, MAKEINTRESOURCE(IDD_InstallStubProgress),
                                    NULL, ProgressDialogProc);
    }

    if (hwndProgress != NULL) {
        SetProgressInfo(hwndProgress, pszFriendlyName, fInstalling);
        if (!fTriedProgressDialog) {
            ShowWindow(hwndProgress, SW_RESTORE);
            SetForegroundWindow(hwndProgress);
        }
    }
    fTriedProgressDialog = TRUE;
}


void CleanupProgressDialog(void)
{
    if (hwndProgress != NULL) {
        DestroyWindow(hwndProgress);
        hwndProgress = NULL;
    }
}


BOOL RunOneInstallStub( HKEY hklmList, HKEY hkcuList, LPCTSTR pszKeyName,
                        LPCTSTR pszCurrentUsername, int iPass )
{
     BOOL bNextPassNeeded = FALSE;
     /* See if this component is installed or an uninstall tombstone. */
     HKEY hkeyComponent;

     DWORD err = RegOpenKeyEx(hklmList, pszKeyName, 0, KEY_QUERY_VALUE,
                               &hkeyComponent);
     if (err == ERROR_SUCCESS) {
        TCHAR szCmdLine[MAX_PATH];
        DWORD fIsInstalled;
        DWORD dwType;
        DWORD cbData = sizeof(fIsInstalled);
        HKEY hkeyUser = NULL;

        /* Must have the stub path;  if not there, skip this entry. */
        cbData = sizeof(szCmdLine);
        if (SHQueryValueEx(hkeyComponent, c_szRegInstallStubValue,
                           NULL, &dwType, (LPBYTE)szCmdLine,
                           &cbData) != ERROR_SUCCESS || ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) ) {
            RegCloseKey(hkeyComponent);
            return bNextPassNeeded;
        }

        TCHAR szDescription[MAX_PATH];
        LPTSTR pszDescription = szDescription;
        cbData = sizeof(szDescription);
        if (SHQueryValueEx(hkeyComponent, TEXT(""),
                           NULL, &dwType, (LPBYTE)szDescription,
                           &cbData) != ERROR_SUCCESS || dwType != REG_SZ) {
            pszDescription = szCmdLine;
        }


        if (RegQueryValueEx(hkeyComponent, c_szRegIsInstalledValue,
                            NULL, &dwType, (LPBYTE)&fIsInstalled,
                            &cbData) != ERROR_SUCCESS ||
            (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
            fIsInstalled = TRUE;

        /* If it's installed, check the user's profile, and if the
         * component (or its current revision) isn't installed there,
         * run it.
         */
        if (fIsInstalled) {
            DWORD dwRevisionHi, dwRevisionLo;
            DWORD dwUserRevisionHi = 0;
            DWORD dwUserRevisionLo = 0;
            BOOL fSetRevision;
            TCHAR szRevision[24], szUserRevision[24];   /* 65535,65535,65535,65535\0 */
            TCHAR szLocale[10], szUserLocale[10];       /* usually not very big strings */
            TCHAR szInstallUsername[128+1];  /* 128 is the win95 system username limit */

            DWORD fIsCloneUser;
            cbData = sizeof(fIsCloneUser);
            if (RegQueryValueEx(hkeyComponent, TEXT("CloneUser"),
                                NULL, &dwType, (LPBYTE)&fIsCloneUser,
                                &cbData) != ERROR_SUCCESS ||
                (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
                fIsCloneUser = FALSE;

            cbData = sizeof(szRevision);
            if (RegQueryValueEx(hkeyComponent, c_szRegInstallSequenceValue,
                                NULL, &dwType, (LPBYTE)szRevision,
                                &cbData) != ERROR_SUCCESS ||
                dwType != REG_SZ ||
                FAILED(GetVersionFromString(szRevision, &dwRevisionHi, &dwRevisionLo))) {
                fSetRevision = FALSE;
                dwRevisionHi = 0;
                dwRevisionLo = 0;
            }
            else {
                fSetRevision = TRUE;
            }

            cbData = sizeof(szLocale);
            err = RegQueryValueEx(hkeyComponent, c_szRegLocaleValue,
                                  NULL, &dwType, (LPBYTE)szLocale,
                                  &cbData);
            if (err != ERROR_SUCCESS || dwType != REG_SZ) {
                szLocale[0] = '\0';
            }

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                               KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                cbData = sizeof(szUserRevision);
                if (RegQueryValueEx(hkeyUser, c_szRegInstallSequenceValue,
                                    NULL, &dwType, (LPBYTE)szUserRevision,
                                    &cbData) != ERROR_SUCCESS ||
                    dwType != REG_SZ ||
                    FAILED(GetVersionFromString(szUserRevision, &dwUserRevisionHi, &dwUserRevisionLo))) {
                    dwUserRevisionHi = 0;
                    dwUserRevisionLo = 0;
                }

                if (szLocale[0] != '\0') {
                    cbData = sizeof(szUserLocale);
                    err = RegQueryValueEx(hkeyUser, c_szRegLocaleValue,
                                          NULL, &dwType, (LPBYTE)szUserLocale,
                                          &cbData);
                    /* If there's a locale string under the user key
                     * and it's the same as the machine one, then we
                     * blank out the machine one so we won't consider
                     * that when running the stub.
                     */
                    if (err == ERROR_SUCCESS && dwType == REG_SZ &&
                        !lstrcmp(szLocale, szUserLocale)) {
                        szLocale[0] = '\0';
                    }
                }
                if (fIsCloneUser) {
                    /* Clone-user install stub.  We need to re-run it if the
                     * username we used when we last installed to this profile,
                     * or the one it was copied from, is different from the
                     * current username.
                     */
                    cbData = sizeof(szInstallUsername);
                    if (RegQueryValueEx(hkeyUser, TEXT("Username"),
                                        NULL, &dwType, (LPBYTE)szInstallUsername,
                                        &cbData) != ERROR_SUCCESS ||
                        dwType != REG_SZ) {
                        szInstallUsername[0] = '\0';
                    }
                }
            }
            else {
                hkeyUser = NULL;
            }

            /* Install if:
             *
             * - User doesn't have component installed, OR
             *   - Component installed on machine has a revision AND
             *   - Machine component revision greater than user's
             * - OR
             *   - Component installed on machine has a locale AND
             *   - Machine component locale different than user's
             *     (this is actually checked above)
             * - OR
             *   - Component is a clone-user install stub and the username
             *     recorded for the stub is different from the current username
             */
            if ((hkeyUser == NULL) ||
                (fSetRevision &&
                 ((dwRevisionHi > dwUserRevisionHi) ||
                  ((dwRevisionHi == dwUserRevisionHi) &&
                   (dwRevisionLo > dwUserRevisionLo)
                  )
                 )
                ) ||
                (szLocale[0] != '\0') ||
#ifdef UNICODE
                (fIsCloneUser && StrCmpI(szInstallUsername, pszCurrentUsername))
#else
                (fIsCloneUser && lstrcmpi(szInstallUsername, pszCurrentUsername))
#endif
                ) {

                if ( (iPass == -1 ) ||
                     ((iPass == 0) && (*pszKeyName == '<')) ||
                     ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                     ((iPass == 2) && (*pszKeyName == '>')) )
                {
                    // the condition meets, run it now.
#ifdef TraceMsg
                    TraceMsg(TF_WARNING, "Running install stub ( %s )", szCmdLine);
#endif
                    IndicateProgress(pszDescription, TRUE);
                    ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);
                    if (hkeyUser == NULL) {
                        RegCreateKey(hkcuList, pszKeyName, &hkeyUser);
                    }
                    if (hkeyUser != NULL) {
                        if (fSetRevision) {
                            RegSetValueEx(hkeyUser, c_szRegInstallSequenceValue,
                                          0, REG_SZ,
                                          (LPBYTE)szRevision,
                                          (lstrlen(szRevision)+1)*sizeof(TCHAR));
                        }
                        if (szLocale[0]) {
                            RegSetValueEx(hkeyUser, c_szRegLocaleValue,
                                          0, REG_SZ,
                                          (LPBYTE)szLocale,
                                          (lstrlen(szLocale)+1)*sizeof(TCHAR));
                        }
                        if (fIsCloneUser) {
                            RegSetValueEx(hkeyUser, TEXT("Username"),
                                          0, REG_SZ,
                                          (LPBYTE)pszCurrentUsername,
                                          (lstrlen(pszCurrentUsername)+1)*sizeof(TCHAR));
                        }
                    }
                }
                else
                {
                    // decide if this belong to the next pass
                    // if it is in Pass 2, should never get here
                    if ( iPass == 0 )
                        bNextPassNeeded = TRUE;
                    else if ( (iPass == 1 ) && (*pszKeyName == '>') )
                        bNextPassNeeded = TRUE;
                }
            }
        }
        else {
            /* Component is an uninstall stub. */

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                               KEY_QUERY_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                DWORD fDontAsk = 0;

                /* Check the "Don't Ask" value.  If it's present, its value
                 * is interpreted as follows:
                 *
                 * 0 --> ask the user
                 * 1 --> do not run the stub
                 * 2 --> always run the stub
                 */
                cbData = sizeof(fDontAsk);
                if (RegQueryValueEx(hkeyComponent, c_szRegDontAskValue,
                                    NULL, &dwType, (LPBYTE)&fDontAsk,
                                    &cbData) != ERROR_SUCCESS ||
                    (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))) ||
                    fDontAsk != 1) 
                {

                    if ( (iPass == -1 ) ||
                         ((iPass == 0) && (*pszKeyName == '>')) ||
                         ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                         ((iPass == 2) && (*pszKeyName == '<')) )
                    {
                        // uninstall stub has the reversed order comparing with install stub
                        if (fDontAsk == 2 || ConfirmUninstall(pszDescription) == IDYES) {

#ifdef TraceMsg
                            TraceMsg(TF_WARNING, "Running uninstall stub ( %s )", szCmdLine);
#endif
                            IndicateProgress(pszDescription, FALSE);
                            ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);
    
                            /* Component has been uninstalled.  Forget that the
                             * user ever had it installed.
                             */
                            RegCloseKey(hkeyUser);
                            hkeyUser = NULL;
                            RegDeleteKey(hkcuList, pszKeyName);
                        }

                    }
                    else
                    {
                        // decide if this belong to the next pass
                        // if it is in Pass 2, should never get here
                        if ( iPass == 0 )
                            bNextPassNeeded = TRUE;
                        else if ( (iPass == 1 ) && (*pszKeyName == '<') )
                            bNextPassNeeded = TRUE;
                    }
                }
            }
        }

        if (hkeyUser != NULL) {
            RegCloseKey(hkeyUser);
        }
        RegCloseKey(hkeyComponent);
    }

    return bNextPassNeeded;
}


const TCHAR  c_szIE40GUID_STUB[] = TEXT("{89820200-ECBD-11cf-8B85-00AA005B4383}");
const TCHAR  c_szBlockIE4Stub[]  = TEXT("NoIE4StubProcessing");

extern "C" void RunInstallUninstallStubs2(LPCTSTR pszStubToRun)
{
    HKEY hklmList = NULL, hkcuList = NULL;
    LONG err;

    TCHAR szUsername[128+1];        /* 128 is the win95 limit, good default */
    LPTSTR pszCurrentUser = szUsername;

    /* As far as clone-user install stubs are concerned, we only want profile
     * usernames.
     */
    if (!ProfilesEnabled()) {
        *pszCurrentUser = '\0';
    }
    else {
        DWORD cbData = sizeof(szUsername);
        if (!GetUserName(szUsername, &cbData)) {
            if (cbData > sizeof(szUsername)) {
                cbData++;   /* allow for null char just in case */
                pszCurrentUser = (LPTSTR)LocalAlloc(LPTR, cbData+1);
                if (pszCurrentUser == NULL || !GetUserName(pszCurrentUser, &cbData)) {
                    if (pszCurrentUser != NULL)
                        LocalFree(pszCurrentUser);
                    pszCurrentUser = szUsername;
                    *pszCurrentUser = '\0';
                }
            }
            else {
                szUsername[0] = '\0';
            }
        }
    }

#ifdef TraceMsg
    TraceMsg(TF_WARNING, "Running install/uninstall stubs.");
#endif

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegInstalledComponentsKey, 0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hklmList);

    if (err == ERROR_SUCCESS) {
        DWORD dwDisp;
        err = RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegInstalledComponentsKey, 0,
                             TEXT(""), REG_OPTION_NON_VOLATILE,
                             KEY_READ | KEY_WRITE, NULL, &hkcuList, &dwDisp);
    }

    if (err == ERROR_SUCCESS) {
        if (pszStubToRun != NULL) {
            // here we call with pass number -1 means no pass order enforced
            RunOneInstallStub(hklmList, hkcuList, pszStubToRun, pszCurrentUser, -1);
        }
        else {
            DWORD cbKeyName, iKey, iPass;
            TCHAR szKeyName[80];
            BOOL  bNextPassNeeded = TRUE;
            HANDLE hMutex;

            // This mutex check is to ensure if explore restarted due abnormal active desktop shutdown, and setup resume
            // per-user stubs should not be processed till setup is done.
            if (CheckWebViewShell())
            {
                hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("Ie4Setup.Mutext"));
                if (hMutex)
                {
                    CloseHandle(hMutex);                
                    goto done;
                }
            }

	        // check if we want to block the stub processing
            cbKeyName = sizeof(szKeyName);
            if ((RegQueryValueEx(hklmList, c_szBlockIE4Stub, NULL, NULL, 
                                (LPBYTE)szKeyName, &cbKeyName) == ERROR_SUCCESS) && 
                (*CharUpper(szKeyName) == 'Y') )
	        {
                 goto done;
            }                       

            /* we will do TWO passes to meet the ordering requirement when run component stubs.
               Any KeyName with '*' as the first char, get run in the 1st Pass.  the rest run 2nd pass */
            for ( iPass = 0; ((iPass<3) && bNextPassNeeded); iPass++ )
            {
                bNextPassNeeded = FALSE;
                
                // APPCOMPAT: in 2nd pass, we do want to special case of IE4.0 base browser stub
                // to run first.  The reason we did not use '<' for this is to 1) reserve < stuff
                // for pre-ie4 stubs and this whole thing should redo in sorted fashion.  For now,
                // we hard code this IE4.0 base browser GUID
                if ( iPass == 1 )
                {
                    if ( RunOneInstallStub(hklmList, hkcuList, c_szIE40GUID_STUB, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }                    

                /* Enumerate components that are installed on the local machine. */
                for (iKey = 0; ; iKey++)
                {
                    LONG lEnum;

                    cbKeyName = ARRAYSIZE(szKeyName);

                    // WARNING (Unicode, Davepl) I'm assuming that the data is UNICODE,
                    // but I'm not sure who put it there yet... double check.

                    if ((lEnum = RegEnumKey(hklmList, iKey, szKeyName, cbKeyName)) == ERROR_MORE_DATA)
                    {
                        // ERROR_MORE_DATA means the value name or data was too large
                        // skip to the next item
#ifdef TraceMsg
                        TraceMsg( DM_ERROR, "Cannot run oversize entry in InstalledComponents");
#endif
                        continue;
                    }
                    else if( lEnum != ERROR_SUCCESS )
                    {
                        // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
                        // we can't recover from any other registry problem, anyway
                        break;
                    }

                    // in case the user say NO when we try to run the IE4 stub first time,
                    // we should not re-process this stub again.
		    if ( (iPass == 1) && (!lstrcmpi(szKeyName, c_szIE40GUID_STUB)) )
                        continue;
                    
                    if ( RunOneInstallStub(hklmList, hkcuList, szKeyName, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }
            }
        }
    }

done:

    if (hklmList != NULL)
        RegCloseKey(hklmList);
    if (hkcuList != NULL)
        RegCloseKey(hkcuList);

    if (pszCurrentUser != szUsername)
        LocalFree(pszCurrentUser);

    CleanupProgressDialog();
}

// Check shell32.dll's version and see if it is the one which supports the integrated WebView
BOOL CheckWebViewShell()
{
    HINSTANCE           hInstShell32;
    DLLGETVERSIONPROC   fpGetDllVersion;    
    BOOL                pWebViewShell = FALSE;
           
    hInstShell32 = LoadLibrary(TEXT("Shell32.dll"));
    if (hInstShell32)
    {
        fpGetDllVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstShell32, "DllGetVersion");
        pWebViewShell = (fpGetDllVersion != NULL);
        FreeLibrary(hInstShell32);
    }
    return pWebViewShell;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\memt.h ===
#ifndef __MEMORYTEMPLATES_H__
#define __MEMORYTEMPLATES_H__

template <class T>
inline HRESULT SHLocalAlloc(ULONG cb, T **ppv)
{
    *ppv = (T *) LocalAlloc(LPTR, cb);
    return *ppv ? S_OK : E_OUTOFMEMORY;
}

template <class T>
inline HRESULT SHCoAlloc(ULONG cb, T **ppv)
{
    *ppv = (T *) CoTaskMemAlloc(cb);
    return *ppv ? S_OK : E_OUTOFMEMORY;
}

template <class T>
class CSmartCoTaskMem
{
protected:
    T *p;

public:
    CSmartCoTaskMem() { p = NULL; }
    ~CSmartCoTaskMem() { if (p) CoTaskMemFree(p); }

    T** operator&()
    {
        ASSERT(p==NULL);
        return &p;
    }
    
    operator T*() { return p; }
};

#endif // __MEMORYTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\mirstyls.h ===
#ifndef _MIRSTYLS_H_
#define _MIRSTYLS_H_

#define PrivateWS_EX_LAYOUTRTL         0x00400000
#define PrivateWS_EX_NOINHERITLAYOUT   0x00100000

#if (WINVER >= 0x0500)
#if WS_EX_LAYOUTRTL != PrivateWS_EX_LAYOUTRTL
#error inconsistant WS_EX_LAYOUTRTL in winuser.h
#endif
#if WS_EX_NOINHERITLAYOUT != PrivateWS_EX_NOINHERITLAYOUT
#error inconsistant WS_EX_NOINHERITLAYOUT in winuser.h
#endif
#else
#define WS_EX_LAYOUTRTL          PrivateWS_EX_LAYOUTRTL
#define WS_EX_NOINHERITLAYOUT    PrivateWS_EX_NOINHERITLAYOUT
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\objwindow.h ===
#ifndef _OBJWINDOW_H_
#define _OBJWINDOW_H_

#pragma warning(disable:4100)   // disable 'unreferenced formal parameter' because this params are needed for interface compat.

class CObjectWindow : public IOleWindow
{
public:
    CObjectWindow(void) {}
    virtual ~CObjectWindow() {}

    //*** IUnknown ****
    // (client must provide!)

    //*** IOleWindow ***
    STDMETHOD(ContextSensitiveHelp)(IN BOOL fEnterMode) {return E_NOTIMPL;}
    STDMETHOD(GetWindow)(IN HWND * phwnd)
    {
        HRESULT hr = E_INVALIDARG;

        if (phwnd)
        {
            *phwnd = _hwnd;
            hr = S_OK;
        }

        return hr;
    }

protected:
    HWND _hwnd;
};

#endif // _OBJWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\mluisupp.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString            MLLoadStringW
#define MLLoadShellLangString   MLLoadShellLangStringW
#define MLBuildResURLWrap       MLBuildResURLWrapW
#define MLLoadResources         MLLoadResourcesW
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapW
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapW
#else
#define MLLoadString            MLLoadStringA
#define MLLoadShellLangString   MLLoadShellLangStringA
#define MLBuildResURLWrap       MLBuildResURLWrapA
#define MLLoadResources         MLLoadResourcesA
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapA
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapA
#endif

void        MLFreeResources(HINSTANCE hinstParent);
HINSTANCE   MLGetHinst();
HINSTANCE   MLLoadShellLangResources();

#ifdef MLUI_MESSAGEBOX
int         MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...);
#endif

//
// The following should be both A and W suffixed
//

int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);

int         MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax);

HRESULT     MLBuildResURLWrapA(LPSTR    pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPSTR    pszResName,
                               LPSTR    pszResURL,
                               int      nBufSize,
                               LPSTR    pszParentDll);

HRESULT     MLBuildResURLWrapW(LPWSTR   pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPWSTR   pszResName,
                               LPWSTR   pszResURL,
                               int      nBufSize,
                               LPWSTR   pszParentDll);

void        MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll);
void        MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll);

HWND        SHHtmlHelpOnDemandWrapA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
HWND        SHHtmlHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

BOOL        SHWinHelpOnDemandWrapA(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
BOOL        SHWinHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);

//
// End of: The following should be both A and W suffixed
//

#ifdef MLUI_INIT

// WARNING: do not attempt to access any of these members directly
// these members may not be initialized until appropriate accessors
// are called, for example hinstLocRes won't be intialized until
// you call MLGetHinst()... so just call the accessor.
struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstParent;
    WCHAR       szLocResDll[MAX_PATH];
    DWORD       dwCrossCodePage;
} g_mluiInfo;


// REARCHITECT: These aren't thread safe... Do they need to be?
//
void MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        SHAnsiToUnicode(pszLocResDll, g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        StrCpyNW(g_mluiInfo.szLocResDll, pszLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent)
    {
        MLClearMLHInstance(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

// this is a private internal helper.
// don't you dare call it from anywhere except at
// the beginning of new ML* functions in this file
__inline void
_MLResAssure()
{
#ifdef MLUI_SUPPORT
    if(g_mluiInfo.hinstLocRes == NULL)
    {
        g_mluiInfo.hinstLocRes = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                                               g_mluiInfo.hinstParent,
                                               g_mluiInfo.dwCrossCodePage);

        // we're guaranteed to at least have resources in the install language
        ASSERT(g_mluiInfo.hinstLocRes != NULL);
    }
#endif
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringA(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

int
MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringWrapW(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

HINSTANCE
MLGetHinst()
{
    _MLResAssure();
    return g_mluiInfo.hinstLocRes;
}

HINSTANCE
MLLoadShellLangResources()
{
    HINSTANCE hinst;
    
    hinst = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                           g_mluiInfo.hinstParent,
                           ML_SHELL_LANGUAGE);

    // we're guaranteed to at least have resources in the install language
    // unless we're 100% toasted

    return hinst;
}

#ifdef MLUI_MESSAGEBOX
int MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...)
{
    va_list     vaList;
    int         nRet            = 0;
    LPTSTR      pszFormattedMsg = NULL;
    TCHAR       szTitleBuf[256];
    TCHAR       szBuffer[1024];

    //
    // prepare the message
    //

    if (IS_INTRESOURCE(pszMsg))
    {
        if (MLLoadShellLangString(LOWORD((DWORD_PTR)pszMsg), szBuffer, ARRAYSIZE(szBuffer)))
        {
            pszMsg = szBuffer;
        }
    }

    if (!IS_INTRESOURCE(pszMsg) &&  // the string load might have failed
        pszMsg != NULL)
    {
        va_start(vaList, fuStyle);

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                          pszMsg, 0, 0, (LPTSTR)&pszFormattedMsg, 0, &vaList))
        {
            pszMsg = pszFormattedMsg;
        }

        va_end(vaList);
    }

    //
    // prepare the title
    //

    if (!IS_INTRESOURCE(pszTitle) && pszTitle != NULL)
    {
        // do nothing
    }
    else if (pszTitle != NULL && MLLoadShellLangString(LOWORD((DWORD_PTR)pszTitle), szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else if (hWnd && GetWindowText(hWnd, szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else
    {
        pszTitle = TEXT("");
    }

    //
    // launch a MessageBox
    //
#ifdef SHFUSION_H
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
#endif

    nRet = MessageBox(hWnd, pszFormattedMsg, pszTitle, fuStyle | MB_SETFOREGROUND);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif

    if (pszFormattedMsg != NULL)
    {
        LocalFree(pszFormattedMsg);
    }

    return nRet;
}
#endif // MLUI_MESSAGEBOX

#include "htmlhelp.h"

HWND 
SHHtmlHelpOnDemandWrapA(HWND hwndCaller, 
                       LPCSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;
    ULONG_PTR uCookie = 0;
    HWND hwnd = NULL;
    
#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif
    hwnd = SHHtmlHelpOnDemandA(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

HWND 
SHHtmlHelpOnDemandWrapW(HWND hwndCaller, 
                       LPCWSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;
    ULONG_PTR uCookie = 0;
    HWND hwnd = NULL;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif
    hwnd = SHHtmlHelpOnDemandW(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

HWND
MLHtmlHelpWrap(HWND hwndCaller,
               LPCTSTR pszFile,
               UINT uCommand,
               DWORD dwData,
               DWORD dwCrossCodePage)
{
    HWND    hwnd;

    ULONG_PTR uCookie = 0;
#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif

#ifdef MLUI_SUPPORT
    hwnd = MLHtmlHelp(hwndCaller,
                      pszFile,
                      uCommand,
                      dwData,
                      dwCrossCodePage);
#else
    hwnd = HtmlHelp(hwndCaller,
                    pszFile,
                    uCommand,
                    dwData);
#endif

#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

BOOL
SHWinHelpOnDemandWrapA(HWND hwndCaller,
                      LPCSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandA(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
SHWinHelpOnDemandWrapW(HWND hwndCaller,
                      LPCWSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandW(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
MLWinHelpWrap(HWND hwndCaller,
                   LPCTSTR lpszHelp,
                   UINT uCommand,
                   DWORD dwData)
{
    BOOL    fRet;

#ifdef MLUI_SUPPORT
    fRet = MLWinHelp(hwndCaller,
                     lpszHelp,
                     uCommand,
                     dwData);
#else
    fRet = WinHelp(hwndCaller,
                   lpszHelp,
                   uCommand,
                   dwData);
#endif

    return fRet;
}

HRESULT
MLBuildResURLWrapA(LPSTR    pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPSTR    pszResName,
                   LPSTR    pszResURL,
                   int      nBufSize,
                   LPSTR    pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLA(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    wnsprintfA(pszResURL, nBufSize, "res://%s/%s", pszParentDll, pszResName);
    hr = S_OK;
#endif

    return hr;
}

HRESULT
MLBuildResURLWrapW(LPWSTR   pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPWSTR   pszResName,
                   LPWSTR   pszResURL,
                   int      nBufSize,
                   LPWSTR   pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLW(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    wnsprintfW(pszResURL, nBufSize, L"res://%s/%s", pszParentDll, pszResName);
    hr = S_OK;
#endif

    return hr;
}

#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\objclsid.h ===
#ifndef _OBJCLSID_H_
#define _OBJCLSID_H_

class CObjectCLSID : public IPersist
{
public:
    CObjectCLSID(const CLSID * pClsid)  {_clsid = *pClsid;};
    virtual ~CObjectCLSID() {}

    //*** IUnknown ****
    // (client must provide!)

    //*** IPersist ***
    STDMETHOD(GetClassID)(IN CLSID *pClassID)
    {
        HRESULT hr = E_INVALIDARG;

        if (pClassID)
        {
            *pClassID = _clsid;
            hr = S_OK;
        }

        return hr;
    }

protected:
    CLSID _clsid;
};

#endif // _OBJCLSID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\mindex.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  mindex.h
//
//	Declares the interface to the Media Content Index
//
//	Copyright (c) Microsoft Corporation	1999
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MINDEX_HEADER_
#define _MINDEX_HEADER_

#ifdef __cplusplus
extern "C" {
#endif

// Media Index class identifier
// {4B1CFD76-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(CLSID_MediaIndex, 
0x4b1cfd76, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

// Media Index "Multimedia" class ID
// {4C58C22D-4440-11d3-A208-00C04FA3B60C}
DEFINE_GUID(CLSID_MediaIndexMusicActivity, 
0x4c58c22d, 0x4440, 0x11d3, 0xa2, 0x8, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

typedef struct IMediaIndexManager           *LPMEDIAINDEXMANAGER;
typedef struct IMediaIndexScheme            *LPMEDIAINDEXSCHEME;
typedef struct IMediaIndexSchemeDebug       *LPMEDIAINDEXSCHEMEDEBUG;
typedef struct IMediaIndexRoot              *LPMEDIAINDEXROOT;
typedef struct IMediaIndexObject            *LPMEDIAINDEXOBJECT;
typedef struct IMediaIndexNotificationSink  *LPMEDIAINDEXNOTIFICATIONSINK;
typedef struct IMediaIndexMusicActivityRoot *LPMEDIAINDEXMUSICACTIVITYROOT;

//property types
#define PROPERTY_TYPE_NUMERIC        0
#define PROPERTY_TYPE_TEXT           1
#define PROPERTY_TYPE_DATE           2
#define PROPERTY_TYPE_URL            3
#define PROPERTY_TYPE_BINARY         4
#define PROPERTY_TYPE_UNICODE_TEXT   5
#define PROPERTY_TYPE_FILEPATH       6

//object change notification types
#define CHANGE_TYPE_ADDED           0
#define CHANGE_TYPE_REMOVED         1
#define CHANGE_TYPE_RELATIONSHIP    2
#define CHANGE_TYPE_PROPERTY        3

typedef struct _MEDIAINDEXOBJECTDESCRIPTION
{
    const CLSID*    Clsid;                      //Class id of a database object
    wchar_t         wszDesc[255];                //Its description
} MEDIAINDEXOBJECTDESCRIPTION, *LPMEDIAINDEXOBJECTDESCRIPTION;

typedef struct _MEDIAINDEX_PROPERTYDESCRIPTION
{
    const CLSID*    Clsid;                      //Class id of a database property
    DWORD           dwPropNumber;               //Known ID of property
    DWORD           dwDataType;                 //Data type (int, text, binary, etc.)
    wchar_t         wszDesc[255];               //Its description
} MEDIAINDEXPROPERTYDESCRIPTION, *LPMEDIAINDEXPROPERTYDESCRIPTION;

//
// IMediaIndexManager
//
// {5BC8AEBF-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexManager, 
0x5bc8aebf, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexManager

DECLARE_INTERFACE_(IMediaIndexManager, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    // IMediaIndexManager methods
    STDMETHOD(OpenScheme)                   (THIS_ LPCWSTR wszName, LPMEDIAINDEXNOTIFICATIONSINK pSink, LPMEDIAINDEXSCHEME* ppScheme) PURE;
    STDMETHOD(RegisterSchemeFromXMLObject)  (THIS_ LPCWSTR wszName, IXMLDOMDocument* pXMLDoc) PURE;
    STDMETHOD(RegisterSchemeFromXMLScript)  (THIS_ LPCWSTR wszName, LPCWSTR wszXMLScript) PURE;
    STDMETHOD(BeginSchemeEnumeration)       (THIS) PURE;
    STDMETHOD(EnumerateScheme)              (THIS_ LPWSTR wszName, DWORD cchName) PURE;
    STDMETHOD(EndSchemeEnumeration)         (THIS) PURE;
};

//
// IMediaIndexScheme
//
// {6292C109-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexScheme, 
0x6292c109, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexScheme

DECLARE_INTERFACE_(IMediaIndexScheme, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)           (THIS) PURE;
    STDMETHOD_(DWORD, Release)          (THIS) PURE;

    STDMETHOD(GetSchemeInfo)            (THIS_ LPWSTR wszSchemeName, IXMLDOMDocument** ppXMLDoc) PURE;
    STDMETHOD(OpenIndex)                (THIS) PURE;
    STDMETHOD(CloseIndex)               (THIS) PURE;
    STDMETHOD(BeginUserEnumeration)     (THIS) PURE;
    STDMETHOD(EnumerateUser)            (THIS_ LPWSTR wszUserName) PURE;
    STDMETHOD(EndUserEnumeration)       (THIS) PURE;
    STDMETHOD(SetCurrentUser)           (THIS_ LPCWSTR wszUserName) PURE;
    STDMETHOD(BeginTransaction)         (THIS) PURE;
    STDMETHOD(EndTransaction)           (THIS_ BOOL fCommit) PURE;
    STDMETHOD(GetRoot)                  (THIS_ LPMEDIAINDEXROOT* ppObject) PURE;
};

//
// IMediaIndexSchemeDebug (Can QI from IMediaIndexScheme when running a debug build)
//
// {6B88573D-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexSchemeDebug, 
0x6b88573d, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexSchemeDebug

DECLARE_INTERFACE_(IMediaIndexSchemeDebug, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)   (THIS) PURE;
    STDMETHOD_(DWORD, Release)  (THIS) PURE;

    // IMediaIndexSchemeDebug methods
    STDMETHOD(DumpIndexToFile)  (THIS_ LPCWSTR wszFilename) PURE;
};

//
// IMediaIndexRoot
//
// {7C82B623-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexRoot, 
0x7c82b623, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexRoot

DECLARE_INTERFACE_(IMediaIndexRoot, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexRoot methods
    STDMETHOD(BeginObjectEnumeration)       (THIS_ LPCGUID        pguidObjectType,
                                            DWORD                 dwStartingIndex, 
                                            BOOL                  fRestrictToCurrentUser,
                                            LPCGUID               pguidPropertySetID,
                                            DWORD                 dwPropertyID,
                                            void*                 pPropertyFilterValue,
                                            BOOL                  fThreaded,
                                            LPDWORD               dwThreadID,
                                            LPDWORD               pdwCount) PURE;
    STDMETHOD(EnumerateObjects)             (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndObjectEnumeration)         (THIS) PURE;
    STDMETHOD(Search)                       (THIS) PURE;
    STDMETHOD(CreateObject)                 (THIS_ REFGUID guidObjectType, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObject)                  (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByNumericProperty) (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, DWORD dwValue, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByTextProperty)    (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR szSearch, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(RemoveObject)                 (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
};

//
// IMediaIndexObject
//
// {7666AF83-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexObject, 
0x7666af83, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexObject

DECLARE_INTERFACE_(IMediaIndexObject, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexObject methods
    STDMETHOD(GetObjectInfo)                (THIS_ REFGUID guidObjectType, LPDWORD pdwInstanceID) PURE;
    STDMETHOD(BeginConnectionEnumeration)   (THIS_ BOOL     fChildren,
                                             DWORD          dwStartingIndex, 
                                             LPCGUID        pguidObjectType,
                                             BOOL           fRestrictToCurrentUser,
                                             LPCGUID        pguidPropertySetID,
                                             DWORD          dwPropertyID,
                                             void*          pPropertyFilterValue,
                                             BOOL           fThreaded,
                                             LPDWORD        dwThreadID,
                                             LPDWORD        pdwCount) PURE;
    STDMETHOD(EnumerateConnection)          (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndConnectionEnumeration)     (THIS) PURE;
    STDMETHOD(AddChild)                     (THIS_ LPMEDIAINDEXOBJECT pAddObject, LPMEDIAINDEXOBJECT pNextObject) PURE;
    STDMETHOD(RemoveChild)                  (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
    STDMETHOD(GetProperty)                  (THIS_ REFGUID guidPropertySetID, DWORD dwPropertyID, LPWSTR wszPropertyName, LPDWORD pdwDataType, LPVOID pvDataBuffer, DWORD dwBufferSize, LPDWORD pdwRequiredSize) PURE;
    STDMETHOD(SetProperty)                  (THIS_ REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR wszPropertyName, DWORD dwDataType, LPCVOID pvBuffer, DWORD dwBufferSize) PURE;
    STDMETHOD(BeginPropertyEnumeration)     (THIS_ LPCGUID  pguidPropertySetID, LPDWORD pdwCount) PURE;
    STDMETHOD(EnumerateProperty)            (THIS_ REFGUID guidPropertySetID, LPDWORD pdwPropertyID, LPWSTR wszPropertyName, LPDWORD pdwDataType, LPVOID pvDataBuffer, DWORD dwBufferSize, LPDWORD pdwRequiredSize) PURE;
    STDMETHOD(EndPropertyEnumeration)       (THIS) PURE;
    STDMETHOD_(BOOL, IsParentOf)            (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
    STDMETHOD_(BOOL, IsChildOf)             (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
};

//
// IMediaIndexNotificationSink
//
// {892D3443-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexNotificationSink, 
0x892d3443, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexNotificationSink

DECLARE_INTERFACE_(IMediaIndexNotificationSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)       (THIS) PURE;
    STDMETHOD_(DWORD, Release)      (THIS) PURE;

    // IMediaIndexNotificationSink methods
    STDMETHOD(ObjectChanged)        (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, DWORD dwChangeType, REFGUID guidPropertySetID, DWORD dwPropertyID);
    STDMETHOD(EnumerationCallback)  (THIS_ LPMEDIAINDEXOBJECT pObject, DWORD dwThreadID, HANDLE hCancelEvent);
};

//
// IMediaIndexMusicActivityRoot
//
// {AD27169C-443F-11d3-A208-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexMusicActivityRoot,
0xAD27169C, 0x443F, 0x11d3, 0xa2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexMusicActivityRoot

DECLARE_INTERFACE_(IMediaIndexMusicActivityRoot, IMediaIndexRoot)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexRoot methods
    STDMETHOD(BeginObjectEnumeration)       (THIS_ LPCGUID        pguidObjectType,
                                            DWORD                 dwStartingIndex, 
                                            BOOL                  fRestrictToCurrentUser,
                                            LPCGUID               pguidPropertySetID,
                                            DWORD                 dwPropertyID,
                                            void*                 pPropertyFilterValue,
                                            BOOL                  fThreaded,
                                            LPDWORD               dwThreadID,
                                            LPDWORD               pdwCount) PURE;
    STDMETHOD(EnumerateObjects)             (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndObjectEnumeration)         (THIS) PURE;
    STDMETHOD(Search)                       (THIS) PURE;
    STDMETHOD(CreateObject)                 (THIS_ REFGUID guidObjectType, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObject)                  (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByNumericProperty) (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, DWORD dwValue, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByTextProperty)    (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR szSearch, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(RemoveObject)                 (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;

    //IMediaIndexMusicActivityRoot methods
    STDMETHOD(OpenIndex)                    (THIS_ LPMEDIAINDEXNOTIFICATIONSINK pSink) PURE;
    STDMETHOD(CloseIndex)                   (THIS) PURE;
    STDMETHOD(GetSchemeInfo)                (THIS_ LPWSTR wszSchemeName, IXMLDOMDocument** ppXMLDoc) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MINDEX_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\mediautil.h ===
// mediautil.h: media bar utility routines that need to be shared between shdocvw & browseui

#ifndef _MEDIAUTIL_H_
#define _MEDIAUTIL_H_

//+----------------------------------------------------------------------------------------
// CMediaBarUtil
//-----------------------------------------------------------------------------------------

class CMediaBarUtil
{
public:
    CMediaBarUtil() {}
    ~CMediaBarUtil() {}

    // Reg helpers
    static HRESULT SetMediaRegValue(LPWSTR pstrName, DWORD dwRegDataType, void *pvData, DWORD cbData, BOOL fMime = FALSE); 
    static HUSKEY  GetMediaRegKey();
    static HUSKEY  GetMimeRegKey();
    static HUSKEY  OpenRegKey(TCHAR * pchName);
    static HRESULT CloseRegKey(HUSKEY hUSKey);
    static HRESULT IsRegValueTrue(HUSKEY hUSKey, TCHAR * pchName, BOOL * pfValue);
    static BOOL    GetImplicitMediaRegValue(TCHAR * pchName);
    static BOOL    GetAutoplay();
    static BOOL    GetAutoplayPrompt();
    static HRESULT ToggleAutoplay(BOOL fOn);
    static HRESULT ToggleAutoplayPrompting(BOOL fOn);
    static BOOL    IsRecognizedMime(BSTR bstrMime);
    static HRESULT ShouldPlay(TCHAR * szMime, BOOL * pfShouldPlay);
    static BOOL IsWMP7OrGreaterCapable();
    static BOOL IsWMP7OrGreaterInstalled();
};


#endif // _MEDIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((WPARAM)(x))
#define OFFSETOF(x)     ((WPARAM)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) BOOLFROMPTR(hinst)

// HIWORD is typically used to detect whether a pointer parameter
// is a real pointer or is a MAKEINTATOM.  HIWORD64 is the Win64-compatible
// version of this usage.  It does *NOT* return the top word of a 64-bit value.
// Rather, it returns the top 48 bits of the 64-bit value.
//
// Yes, the name isn't very good.  Any better ideas?
//
// BOOLFROMPTR is used when you have a pointer or a ULONG_PTR
// and you want to turn it into a BOOL.  In Win32,
// sizeof(BOOL) == sizeof(LPVOID) so a straight cast works.
// In Win64, you have to do it the slow way because pointers are 64-bit.
//
#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#define BOOLFROMPTR(p)  ((p) != 0)
#define SPRINTF_PTR		"%016I64x"
#else
#define HIWORD64        HIWORD
#define BOOLFROMPTR(p)  ((BOOL)(p))
#define SPRINTF_PTR		"%08x"
#endif

#define IntToPtr_(T, i) ((T)IntToPtr(i))

#define DATASEG_READONLY    ".text"	        // don't use this, compiler does this for you
#define DATASEG_PERINSTANCE "INSTDATA"      // per instance data (per process)
#ifdef WINNT
#define DATASEG_SHARED
#else
#define DATASEG_SHARED      "SHARED"        // global global data (shared across process)
#endif
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLongPtr
#define SetWindowInt        SetWindowLongPtr
#define SetWindowID(hwnd,id)    SetWindowLongPtr(hwnd, GWLP_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLongPtr(hwnd, GCLP_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLongPtr(hwnd, GCLP_HICON))
#define BOOL_PTR                INT_PTR

#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)      	(SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT 	    "_INIT"

#define GetWindowInt    	GetWindowWord
#define SetWindowInt    	SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\powercfp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWERCFP.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Public declarations for PowerCfg notification interface. Systray uses
*   this interface to notify PowerCfg that the user has changed something.
*
*******************************************************************************/

//  Private PowerCfg notification message.
#define PCWM_NOTIFYPOWER                (WM_USER + 201)

#define IDS_POWERPOLICIESTITLE 400

/*******************************************************************************
*
*  PowerCfg_Notify
*
*  DESCRIPTION:
*   Called by Systray to notify PowerCfg that something has changed.
*
*  PARAMETERS:
*
*******************************************************************************/

_inline BOOL PowerCfg_Notify(void)
{
    HINSTANCE hInst;
    static  LPTSTR lpszWndName;
    TCHAR   szBuf[128];
    HWND    hwnd, hwndPC;
    int     iLen;

    // first time initialization of the PowerCfg top level property sheet title.
    if (!lpszWndName) {
        if (hInst = LoadLibrary(TEXT("powercfg.cpl"))) {
            iLen = LoadString(hInst, IDS_POWERPOLICIESTITLE, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            if (iLen) {
                if (lpszWndName = LocalAlloc(0, (iLen + 1) * sizeof(TCHAR))) {
                    lstrcpy(lpszWndName, szBuf);
                }
            }
        }
    }

    // Notify the child of the top level window.
    if (lpszWndName) {
        hwndPC = FindWindow(WC_DIALOG, lpszWndName);
        if (hwndPC) {
            hwnd = GetWindow(hwndPC, GW_CHILD);
            if (hwnd) {
                return (BOOL)SendMessage(hwnd, PCWM_NOTIFYPOWER, 0, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\profsvc.h ===
#ifndef _PROFSVC_H_
#define _PROFSVC_H_

class IProfferServiceImpl : public IProfferService
{
public:
    // IProfferService
    STDMETHODIMP ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie);
    STDMETHODIMP RevokeService(DWORD dwCookie);

    // delegate unrecognized QS's here
    HRESULT QueryService(REFGUID guidService, REFIID riid, void **ppv);

protected:
    IProfferServiceImpl();
    ~IProfferServiceImpl();

    HDSA _hdsa;             // list of services held
    DWORD _dwNextCookie;    // unique cookie index
};

#endif  // _PROFSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\propset.h ===
#ifndef _PROPSET_H_
#define _PROPSET_H_

// NOTE (scotth): this is a placeholder header so we can
//  use this according to the spec \\ole\specs\release\properties.doc

// Don't define if OLE definitions are in place!
#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

#include <ole2.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

typedef struct tagPROPVARIANT PROPVARIANT;

#define TYPEDEF_CA(type, name) \
	typedef struct tag ## name {\
		ULONG cElems;\
		type *pElems;\
		} name
TYPEDEF_CA(unsigned char,		CAUI1);
TYPEDEF_CA(short,			CAI2);
TYPEDEF_CA(USHORT,		CAUI2);
TYPEDEF_CA(long,				CAI4);
TYPEDEF_CA(ULONG,			CAUI4);
TYPEDEF_CA(LARGE_INTEGER,	CAI8);
TYPEDEF_CA(ULARGE_INTEGER,CAUI8);
TYPEDEF_CA(float,				CAR4);
TYPEDEF_CA(double,			CAR8);
TYPEDEF_CA(CURRENCY,		CACY);
TYPEDEF_CA(DATE,			CADATE);
TYPEDEF_CA(BSTR,			CABSTR);
TYPEDEF_CA(VARIANT_BOOL,	CABOOL);
TYPEDEF_CA(SCODE,			CASCODE);
TYPEDEF_CA(FILETIME,		CAFILETIME);
TYPEDEF_CA(LPSTR,			CALPSTR);
TYPEDEF_CA(LPWSTR,		CALPWSTR);
TYPEDEF_CA(CLSID,			CACLSID);
TYPEDEF_CA(CLIPDATA,		CACLIPDATA);
TYPEDEF_CA(PROPVARIANT,	CAPROPVARIANT);

typedef struct tagPROPVARIANT{
	VARTYPE	vt;				// value type tag
	WORD 		wReserved1;		// padding to achieve 4-byte alignment
	WORD 		wReserved2;
	WORD 		wReserved3;
    union {							
	// none						// VT_EMPTY, VT_NULL, VT_ILLEGAL
	unsigned char 		bVal;		// VT_UI1
	short         		iVal;           	// VT_I2
	USHORT			uiVal;		// VT_UI2
	long          		lVal;			// VT_I4
	ULONG			ulVal;		// VT_UI4
	LARGE_INTEGER	hVal;		// VT_I8
	ULARGE_INTEGER  uhVal;		// VT_UI8
	float				fltVal;		// VT_R4
	double			dblVal;		// VT_R8
	CY				cyVal;		// VT_CY
	DATE			date;			// VT_DATE
	BSTR			bstrVal;		// VT_BSTR			// string in the current Ansi code page
	VARIANT_BOOL	bool;			// VT_BOOL
	SCODE         		scode;          	// VT_ERROR
	FILETIME			filetime;	// VT_FILETIME
	LPSTR			pszVal;		// VT_LPSTR			// string in the current Ansi code page
	LPWSTR        		pwszVal;		// VT_LPWSTR		// string in Unicode
	CLSID*			puuid;		// VT_CLSID
	CLIPDATA*		pclipdata;		// VT_CF

	BLOB			blob;			// VT_BLOB, VT_BLOBOBJECT
	IStream*		pStream;		// VT_STREAM, VT_STREAMED_OBJECT
	IStorage*		pStorage;		// VT_STORAGE, VT_STORED_OBJECT

	CAUI1			cab;		// VT_VECTOR | VT_UI1
	CAI2           		cai;            	// VT_VECTOR | VT_I2
	CAUI2			caui;			// VT_VECTOR | VT_UI2
	CAI4           		cal;            	// VT_VECTOR | VT_I4
	CAUI4			caul;			// VT_VECTOR | VT_UI4
	CAI8				cah;			// VT_VECTOR | VT_I8
	CAUI8			cauh;		// VT_VECTOR | VT_UI8
	CAR4         		caflt;			// VT_VECTOR | VT_R4
	CAR8         		cadbl;		// VT_VECTOR | VT_R8
	CACY          		cacy;           	// VT_VECTOR | VT_CY
	CADATE        		cadate;         	// VT_VECTOR | VT_DATE
	CABSTR        		cabstr;         	// VT_VECTOR | VT_BSTR
	CABOOL			cabool;		// VT_VECTOR | VT_BOOL
	CASCODE		cascode;		// VT_VECTOR | VT_ERROR
	CALPSTR       		calpstr;        	// VT_VECTOR | VT_LPSTR
	CALPWSTR      	calpwstr;       	// VT_VECTOR | VT_LPWSTR
	CAFILETIME    	cafiletime;     	// VT_VECTOR | VT_FILETIME
	CACLSID       		cauuid;         	// VT_VECTOR | VT_CLSID
	CACLIPDATA		caclipdata;	// VT_VECTOR | VT_CF
	CAPROPVARIANT 	capropvar;	     	// VT_VECTOR | VT_VARIANT
	}DUMMYUNIONNAME;
} PROPVARIANT;

#if 0
typedef enum {
	VT_EMPTY=0,		VT_NULL=1,		VT_I2=2,			VT_I4=3,			VT_R4=4
	VT_R8=5,		VT_CY=6,		VT_DATE=7,		VT_BSTR=8,		VT_ERROR=10,	VT_BOOL=11,
	VT_VARIANT=12,	VT_UI1=17, 		VT_UI2=18,		VT_UI4=19,
	VT_I8=20,		VT_UI8=21,		VT_LPSTR=30,	VT_LPWSTR=31,
	VT_FILETIME=64,	VT_BLOB=65,		VT_STREAM=66,	VT_STORAGE=67,	VT_STREAMED_OBJECT=68
	VT_STORED_OBJECT=69,			VT_BLOB_OBJECT=70,				VT_CF=71
	VT_CLSID=72,		VT_VECTOR=0x1000,
	VT_ILLEGAL=0xFFFFFFFF,
	VT_TYPEMASK=0xFFF,		// a mask for masking VT_VECTOR and other modifiers to get the raw VT_ value.
	} PROPVARENUM;
#endif // VT_EMPTY

#define	VT_ILLEGAL 0xFFFF

typedef enum
    {
    PRSPEC_LPWSTR   = 0,
    PRSPEC_PROPID   = 1,
    } PRSPEC;

// typedef LONG	PROPID;

typedef struct tagPROPSPEC {
	ULONG ulKind;		// PRSPEC_LPWSTR or PRSPEC_PROPID
	union {
		LPWSTR	lpwstr;
        		PROPID	propid;
	}DUMMYUNIONNAME;
} PROPSPEC;

typedef GUID		FMTID;

typedef struct tagSTATPROPSETSTG {	// used in IPropertySetStorage::Enum and IPropertyStorage::Stat
	FMTID		fmtid;		// The fmtid name of this property set.
	CLSID		clsid;		// The class id of this property set.
	DWORD		grfFlags;		// The flag values of this property set as specified in IPropertySetStorage::Create.
	FILETIME		mtime;		// The time in UTC at which this property set was last modified
	FILETIME		ctime;		// The time in UTC at which this property set was created.
	FILETIME		atime;		// The time in UTC at which this property set was last accessed.
	} STATPROPSETSTG;

typedef struct  tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    }	STATPROPSTG;

#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSTG

DECLARE_INTERFACE_(IEnumSTATPROPSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSETSTG

DECLARE_INTERFACE_(IEnumSTATPROPSETSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPropertyStorage

DECLARE_INTERFACE_(IPropertyStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(ReadMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]) PURE;
    STDMETHOD(WriteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst) PURE;
    STDMETHOD(DeleteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[]) PURE;
    STDMETHOD(ReadPropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(WritePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(DeletePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[]) PURE;
    STDMETHOD(SetClass)(THIS_ REFCLSID clsid) PURE;
    STDMETHOD(Commit)(THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert)(THIS) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSTG** ppenm) PURE;
    STDMETHOD(Stat)(THIS_ STATPROPSETSTG* pstatpsstg) PURE;
    STDMETHOD(SetTimes)(THIS_ const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime) PURE;
};

typedef REFGUID	REFFMTID;

#undef  INTERFACE
#define INTERFACE   IPropertySetStorage

DECLARE_INTERFACE_(IPropertySetStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Create)(THIS_ REFFMTID fmtid, const CLSID* pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg)PURE;
    STDMETHOD(Open)(THIS_ REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg) PURE;
    STDMETHOD(Delete)(THIS_ REFFMTID fmtid) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSETSTG** ppenum) PURE;
};

typedef enum PROPSETFLAG {
    PROPSETFLAG_NONSIMPLE	= 1,
    PROPSETFLAG_ANSI			= 2,
    } PROPSETFLAG;

extern  const IID IID_IPropertyStorage;
extern  const IID IID_IEnumSTATPROPSTG;
extern  const IID IID_IPropertySetStorage;
extern  const IID IID_IEnumSTATPROPSETSTG;


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // __IPropertyStorage_INTERFACE_DEFINED__

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\qistub.cpp ===
//***   qistub.cpp -- QI helpers (retail and debug)
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/qistub.cpp"

#include "qistub.h"

#define DM_MISC2            0       // misc stuff (verbose)

// hack-o-rama: shlwapi/qistub.cpp does #undef DEBUG but its PCH was
// built DEBUG, so lots of bad stuff happens.  work-around it here.
#undef DBEXEC
#ifdef DEBUG
#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)
#else
#define DBEXEC(flg, expr)    /*NOTHING*/
#endif

#ifdef DEBUG // {
//***   CUniqueTab {
// DESCRIPTION
//  key/data table insert and lookup, w/ interlock.
class CUniqueTab
{
public:
    void * Add(int val);
    void * Find(int val, int delta);
    void Reset(void);

    // n.b. *not* protected
    CUniqueTab(int cbElt);
    virtual ~CUniqueTab();

protected:

private:
    void _Lock(void) { EnterCriticalSection(&_hLock); }
    void _Unlock(void) { LeaveCriticalSection(&_hLock); }

    CRITICAL_SECTION    _hLock;
// key + (arbitrary) limit of 4 int's of client data
#define CUT_CBELTMAX    (SIZEOF(int) + 4 * SIZEOF(int))
    int     _cbElt;                 // size of an entry (key + data)
// (arbitrary) limit to catch clients running amuck
#define CUT_CVALMAX 256         // actually, a LIM not a MAX
    HDSA    _hValTab;
};

CUniqueTab::CUniqueTab(int cbElt)
{
    InitializeCriticalSection(&_hLock);
    ASSERT(cbElt >= SIZEOF(DWORD));     // need at least a key; data optional
    _cbElt = cbElt;
    _hValTab = DSA_Create(_cbElt, 4);
    return;
}

CUniqueTab::~CUniqueTab()
{
    DSA_Destroy(_hValTab);
    DeleteCriticalSection(&_hLock);
    return;
}

struct cutent {
    int iKey;
    char bData[CUT_CBELTMAX - SIZEOF(int)];
};
struct cfinddata {
    int iKey;
    int dRange;
    void *pEntry;
};

int _UTFindCallback(void *pEnt, void *pData)
{
#define INFUNC(base, p, range) ((base) <= (p) && (p) <= (base) + (range))
    struct cfinddata *pcd = (struct cfinddata *)pData;
    if (INFUNC(*(int *)pEnt, pcd->iKey, pcd->dRange)) {
        pcd->pEntry = pEnt;
        return 0;
    }
    return 1;
#undef  INFUNC
}

//***   CUniqueTab::Add -- add entry if not already there
//
void * CUniqueTab::Add(int val)
{
    struct cfinddata cd = { val, 0, NULL };

    _Lock();

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (!cd.pEntry) {
        int i;
        // lazy,lazy,lazy: alloc max size and let DSA_AppendItem sort it out
        struct cutent elt = { val, 0 /*,0,...,0*/ };

        TraceMsg(DM_MISC2, "cut.add: add %x", val);
        if (DSA_GetItemCount(_hValTab) <= CUT_CVALMAX) {
            i = DSA_AppendItem(_hValTab, &elt);
            cd.pEntry = DSA_GetItemPtr(_hValTab, i);
        }
    }

    _Unlock();

    return cd.pEntry;
}

//***   CUniqueTab::Find -- find entry
//
void * CUniqueTab::Find(int val, int delta)
{
    struct cfinddata cd = { val, delta, NULL };

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (cd.pEntry) {
        // TODO: add p->data[0] dump
        TraceMsg(DM_MISC2, "cut.find: found %x+%d", val, delta);
    }
    return cd.pEntry;
}

//***   _UTResetCallback -- helper for CUniqueTab::Reset
int _UTResetCallback(void *pEnt, void *pData)
{
    struct cutent *pce = (struct cutent *)pEnt;
    int cbEnt = *(int *)pData;
    // perf: could move the SIZEOF(int) into caller, but seems safer here
    memset(pce->bData, 0, cbEnt - SIZEOF(int));
    return 1;
}

//***   Reset -- clear 'data' part of all entries
//
void CUniqueTab::Reset(void)
{
    if (EVAL(_cbElt > SIZEOF(int))) {
        _Lock();
        DSA_EnumCallback(_hValTab, _UTResetCallback, &_cbElt);
        _Unlock();
    }
    return;
}
// }
#endif // }

//***   QueryInterface helpers {

//***   FAST_IsEqualIID -- fast compare
// (cast to 'LONG_PTR' so don't get overloaded ==)
#define FAST_IsEqualIID(piid1, piid2)   ((LONG_PTR)(piid1) == (LONG_PTR)(piid2))

#ifdef DEBUG // {
//***   DBNoOp -- do nothing (but suppress compiler optimizations)
// NOTES
//  this won't fool compiler when it gets smarter, oh well...
void DBNoOp()
{
    return;
}

void DBBrkpt()
{
    DBNoOp();
    return;
}

//***   DBBreakGUID -- debug hook (gets readable name, allows brkpt on IID)
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBQIiid' to brkpt on a specific iface
//  patch 'DBQIiSeq' to brkpt on Nth QI of specific iface
//  brkpt on interesting events noted below
// NOTES
//  warning: returns ptr to *static* buffer!

typedef enum {
    DBBRK_NIL   = 0,
    DBBRK_ENTER = 0x01,
    DBBRK_TRACE = 0x02,
    DBBRK_S_XXX = 0x04,
    DBBRK_E_XXX = 0x08,
    DBBRK_BRKPT = 0x10,
} DBBRK;

DBBRK DBQIuTrace = DBBRK_NIL;   // BRKPT patch to enable brkpt'ing
GUID *DBQIiid = NULL;           // BRKPT patch to brkpt on iface
int DBQIiSeq = -1;              // BRKPT patch to brkpt on Nth QI of DBQIiid
long DBQIfReset = FALSE;        // BRKPT patch to reset counters

TCHAR *DBBreakGUID(const GUID *piid, DBBRK brkCmd)
{
    static TCHAR szClass[GUIDSTR_MAX];

    SHStringFromGUID(*piid, szClass, ARRAYSIZE(szClass));

    // FEATURE: fold these 2 if's together
    if ((DBQIuTrace & brkCmd) &&
      (DBQIiid == NULL || IsEqualIID(*piid, *DBQIiid))) {
        TraceMsg(DM_TRACE, "util: DBBreakGUID brkCmd=%x clsid=%s (%s)", brkCmd, szClass, Dbg_GetREFIIDName(*piid));
        // BRKPT put brkpt here to brkpt on 'brkCmd' event
        DBBrkpt();
    }

    if (DBQIiid != NULL && IsEqualIID(*piid, *DBQIiid)) {
        //TraceMsg(DM_TRACE, "util: DBBreakGUID clsid=%s (%s)", szClass, Dbg_GetREFIIDName(*piid));
        if (brkCmd != DBBRK_TRACE) {
            // BRKPT put brkpt here to brkpt on 'DBQIiid' iface
            DBNoOp();
        }
    }

    // BRKPT put your brkpt(s) here for various events
    switch (brkCmd) {
    case DBBRK_ENTER:
        // QI called w/ this iface
        DBNoOp();
        break;
    case DBBRK_TRACE:
        // looped over this iface
        DBNoOp();
        break;
    case DBBRK_S_XXX:
        // successful QI for this iface
        DBNoOp();
        break;
    case DBBRK_E_XXX:
        // failed QI for this iface
        DBNoOp();
        break;
    case DBBRK_BRKPT:
        // various brkpt events, see backtrace to figure out which one
        DBNoOp();
        break;
    }

    return szClass;
}
#endif // }

#ifdef DEBUG
CUniqueTab *DBpQIFuncTab;

STDAPI_(BOOL) DBIsQIFunc(int ret, int delta)
{
    BOOL fRet = FALSE;

    if (DBpQIFuncTab)
        fRet = BOOLFROMPTR(DBpQIFuncTab->Find(ret, delta));

    return fRet;
}
#endif

//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
#define QI_EASY     0       // w/ shell split, seems to be too rare

#ifdef DEBUG // {
int DBcQITot, DBcQIUnk, DBcQIErr, DBcQIEasy, DBcQIHard;

LPCQITAB DBpqitStats;           // BRKPT: patch to enable QITABENT profiling
#define DBSTAT_CNT      20
int DBcStats[DBSTAT_CNT + 3];   // 0..n, overflow, IUnknown, E_FAIL

#define DBSI_FAIL       (-1)
#define DBSI_IUNKNOWN   (-2)
#define DBSI_OVERFLOW   (-3)

#define DBSI_SPEC(i)    (DBSTAT_CNT - 1 + (-(i)))

//***
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBpqitStats' to gather stats on that QITAB
//  then break into debugger (ctrl+C) and dumpa 'DBcStats l 24'
//  then sort high count guys to the front, and 0 count guys to the end
//
void DBQIStats(LPCQITAB pqitab, INT_PTR i)
{
    if (pqitab != DBpqitStats)
        return;

    if (i >= DBSTAT_CNT)
        i = DBSI_OVERFLOW;
    if (i < 0)
        i = DBSTAT_CNT - 1 + (-i);
    DBcStats[i]++;
    return;
}

void DBDumpQIStats()
{
    int i;
    TCHAR *p;
    TCHAR buf[256];

    TraceMsg(TF_QISTUB, "qi stats: tot=%d unk=%d err=%d easy(%d)=%d hard=%d",
        DBcQITot, DBcQIUnk, DBcQIErr, QI_EASY, DBcQIEasy, DBcQIHard);

    if (DBpqitStats == NULL)
        return;
    
    p = buf;
    for (i = 0; i < DBSTAT_CNT; i++) {
        p += wsprintf(p, TEXT(" %d"), DBcStats[i]);
    }
    p += wsprintf(p, TEXT(" o=%d u=%d e=%d"),
        DBcStats[DBSI_SPEC(DBSI_OVERFLOW)],
        DBcStats[DBSI_SPEC(DBSI_IUNKNOWN)],
        DBcStats[DBSI_SPEC(DBSI_FAIL)]);

    TraceMsg(TF_QISTUB, "qi stats: %s", buf);
    return;
}

#endif // }


//***   QISearch -- table-driven QI
// ENTRY/EXIT
//  this        IUnknown* of calling QI
//  pqit        QI table of IID,cast_offset pairs
//  ppv         the usual
//  hr          the usual S_OK/E_NOINTERFACE, plus other E_* for errors
// NOTES
//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
//  perf: IUnknown v. rare, so goes last.
//  PERF: explicit 'E_NOIFACE' entry in qitab for common miss(es)?
STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid);	// qistub.cpp

STDAPI QISearch(void* that, LPCQITAB pqitab, REFIID riid, LPVOID* ppv)
{
    // do *not* move this!!! (must be 1st on frame)
#ifdef DEBUG
#if (_X86_)
    int var0;       // *must* be 1st on frame
#endif
#endif

    LPCQITAB pqit;
#ifdef DEBUG
    TCHAR *pst;

    DBEXEC(TRUE, DBcQITot++);
#if ( _X86_) // QIStub only works for X86
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
        if (DBpQIFuncTab == NULL)
            DBpQIFuncTab = new CUniqueTab(SIZEOF(DWORD));   // LONG_PTR?
        if (DBpQIFuncTab) {
            int n;
            int fp = (int) (1 + (int *)&var0);
            struct DBstkback sbtab[1] = { 0 };
            n = DBGetStackBack(&fp, sbtab, ARRAYSIZE(sbtab));
            DBpQIFuncTab->Add(sbtab[n - 1].ret);
        }
    }
#endif

    if (DBQIuTrace)
        pst = DBBreakGUID(&riid, DBBRK_ENTER);
#endif

    if (ppv == NULL)
        return E_POINTER;

#if QI_EASY
    // 1st try the fast way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (FAST_IsEqualIID(&riid, pqit->piid)) {
            DBEXEC(TRUE, DBcQIEasy++);
            goto Lhit;
        }
    }
#endif

    // no luck, try the hard way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (IsEqualIID(riid, *(pqit->piid))) {
            DBEXEC(TRUE, DBcQIHard++);
#if QI_EASY
    Lhit:
#else
        // keep 'easy' stats anyway
        DBEXEC(FAST_IsEqualIID(&riid, pqit->piid), DBcQIEasy++);
#endif
#ifdef DEBUG
            DBEXEC(TRUE, DBQIStats(pqitab, pqit - pqitab));
#if ( _X86_) // QIStub only works for X86
            if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
                IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
                *ppv = QIStub_CreateInstance(that, punk, riid);
                if (*ppv) {
                    pst = DBBreakGUID(&riid, DBBRK_S_XXX);
                    return S_OK;
                }
            }
#endif
#endif
        Lcast:
            IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
            DBEXEC(TRUE, (pst = DBBreakGUID(&riid, DBBRK_S_XXX)));
            punk->AddRef();
            *ppv = punk;
            return S_OK;
        }
    }

    // no luck, try IUnknown (which is implicit in the table)
    // we try IUnknown last not 1st since stats show it's rare
    if (IsEqualIID(riid, IID_IUnknown)) {
        // just use 1st table entry
        pqit = pqitab;
        DBEXEC(TRUE, DBcQIUnk++);
        DBEXEC(TRUE, DBQIStats(pqitab, DBSI_IUNKNOWN));

        goto Lcast;
    }

    DBEXEC(DBQIuTrace, (pst = DBBreakGUID(&riid, DBBRK_E_XXX)));
    DBEXEC(TRUE, DBcQIErr++);
    DBEXEC(TRUE, DBQIStats(pqitab, DBSI_FAIL));
    *ppv = NULL;
    return E_NOINTERFACE;
}

// }

#ifdef DEBUG // {
#if ( _X86_) // { QIStub only works for X86

//***   QIStub helpers {

class CQIStub
{
public:
    virtual void thunk0();
    // FEATURE: should AddRef/Release up _iSeq? don't recommend it.
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { _cRef++; return _cRef; }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { _cRef--; if (_cRef>0) return _cRef; delete this; return 0; }
    virtual void thunk3();
    virtual void thunk4();
    virtual void thunk5();
    virtual void thunk6();
    virtual void thunk7();
    virtual void thunk8();
    virtual void thunk9();
    virtual void thunk10();
    virtual void thunk11();
    virtual void thunk12();
    virtual void thunk13();
    virtual void thunk14();
    virtual void thunk15();
    virtual void thunk16();
    virtual void thunk17();
    virtual void thunk18();
    virtual void thunk19();
    virtual void thunk20();
    virtual void thunk21();
    virtual void thunk22();
    virtual void thunk23();
    virtual void thunk24();
    virtual void thunk25();
    virtual void thunk26();
    virtual void thunk27();
    virtual void thunk28();
    virtual void thunk29();
    virtual void thunk30();
    virtual void thunk31();
    virtual void thunk32();
    virtual void thunk33();
    virtual void thunk34();
    virtual void thunk35();
    virtual void thunk36();
    virtual void thunk37();
    virtual void thunk38();
    virtual void thunk39();
    virtual void thunk40();
    virtual void thunk41();
    virtual void thunk42();
    virtual void thunk43();
    virtual void thunk44();
    virtual void thunk45();
    virtual void thunk46();
    virtual void thunk47();
    virtual void thunk48();
    virtual void thunk49();
    virtual void thunk50();
    virtual void thunk51();
    virtual void thunk52();
    virtual void thunk53();
    virtual void thunk54();
    virtual void thunk55();
    virtual void thunk56();
    virtual void thunk57();
    virtual void thunk58();
    virtual void thunk59();
    virtual void thunk60();
    virtual void thunk61();
    virtual void thunk62();
    virtual void thunk63();
    virtual void thunk64();
    virtual void thunk65();
    virtual void thunk66();
    virtual void thunk67();
    virtual void thunk68();
    virtual void thunk69();
    virtual void thunk70();
    virtual void thunk71();
    virtual void thunk72();
    virtual void thunk73();
    virtual void thunk74();
    virtual void thunk75();
    virtual void thunk76();
    virtual void thunk77();
    virtual void thunk78();
    virtual void thunk79();
    virtual void thunk80();
    virtual void thunk81();
    virtual void thunk82();
    virtual void thunk83();
    virtual void thunk84();
    virtual void thunk85();
    virtual void thunk86();
    virtual void thunk87();
    virtual void thunk88();
    virtual void thunk89();
    virtual void thunk90();
    virtual void thunk91();
    virtual void thunk92();
    virtual void thunk93();
    virtual void thunk94();
    virtual void thunk95();
    virtual void thunk96();
    virtual void thunk97();
    virtual void thunk98();
    virtual void thunk99();

protected:
    CQIStub(void *that, IUnknown* punk, REFIID riid);
    friend void* QIStub_CreateInstance(void *that, IUnknown* punk, REFIID riid);
    friend BOOL __stdcall DBIsQIStub(void *that);
    friend void __stdcall DBDumpQIStub(void *that);
    friend TCHAR *DBGetQIStubSymbolic(void *that);

private:
    ~CQIStub();

    static void *_sar;              // C (not C++) ptr to CQIStub::AddRef

    int       _cRef;
    IUnknown* _punk;                // vtable we hand off to
    void*     _that;                // "this" pointer of object we stub (for reference)
    IUnknown* _punkRef;             // "punk" (for reference)
    REFIID    _riid;                // iid of interface (for reference)
    int       _iSeq;                // sequence #
    TCHAR     _szName[GUIDSTR_MAX]; // legible name of interface (for reference)
};

struct DBQISeq
{
    GUID *  pIid;
    int     iSeq;
};
//CASSERT(SIZEOF(GUID *) == SIZEOF(DWORD));   // CUniqueTab uses DWORD's

// FEATURE: todo: _declspec(thread)
CUniqueTab * DBpQISeqTab = NULL;

extern "C" void *Dbg_GetREFIIDAtom(REFIID riid);    // lib/dump.c (priv.h?)

//***
// NOTES
//  there's actually a race condition here -- another thread can come in
// and do seq++, then we do the reset, etc. -- but the assumption is that
// the developer has set the flag in a scenario where this isn't an issue.
void DBQIReset(void)
{
    ASSERT(!DBQIfReset);    // caller should do test-and-clear
    if (DBpQISeqTab)
        DBpQISeqTab->Reset();

    return;
}

void *DBGetVtblEnt(void *that, int i);
#define VFUNC_ADDREF  1     // AddRef is vtbl[1]

void * CQIStub::_sar = NULL;

CQIStub::CQIStub(void* that, IUnknown* punk, REFIID riid) : _cRef(1), _riid(riid)
{
    _that = that;

    _punk = punk;
    if (_punk)
        _punk->AddRef();

    _punkRef = _punk; // for reference, so don't AddRef it!

    // c++ won't let me get &CQIStub::AddRef as a 'real' ptr (!@#$),
    // so we need to get it the hard way, viz. new'ing an object which
    // we know inherits it.
    if (_sar == NULL) {
        _sar = DBGetVtblEnt((void *)this, VFUNC_ADDREF);
        ASSERT(_sar != NULL);
    }

    StrCpyN(_szName, Dbg_GetREFIIDName(riid), ARRAYSIZE(_szName));

    // generate sequence #
    if (DBpQISeqTab == NULL)
        DBpQISeqTab = new CUniqueTab(SIZEOF(struct DBQISeq));
    if (DBpQISeqTab) {
        struct DBQISeq *pqiseq;

        if (InterlockedExchange(&DBQIfReset, FALSE))
            DBQIReset();

        pqiseq = (struct DBQISeq *) DBpQISeqTab->Add((DWORD) Dbg_GetREFIIDAtom(riid));
        if (EVAL(pqiseq))       // (might fail on table overflow)
            _iSeq = pqiseq->iSeq++;
    }

    TraceMsg(TF_QISTUB, "ctor QIStub %s seq=%d (that=%x punk=%x) %x", _szName, _iSeq, _that, _punk, this);
}

CQIStub::~CQIStub()
{
    TraceMsg(TF_QISTUB, "dtor QIStub %s (that=%x punk=%x) %x", _szName, _that, _punk, this);

    ATOMICRELEASE(_punk);
}

STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid)
{
    CQIStub* pThis = new CQIStub(that, punk, riid);

    if (DBQIiSeq == pThis->_iSeq && IsEqualIID(riid, *DBQIiid)) {
        TCHAR *pst;
        // BRKPT put brkpt here to brkpt on seq#'th call to 'DBQIiid' iface
        pst = DBBreakGUID(&riid, DBBRK_BRKPT);
    }

    return(pThis);
}

//***   DBGetVtblEnt -- get vtable entry
// NOTES
//  always uses 1st vtbl (so MI won't work...).
void *DBGetVtblEnt(void *that, int i)
{
    void **vptr;
    void *pfunc;

    __try {
        vptr = (void **) *(void **) that;
        pfunc = (vptr == 0) ? 0 : vptr[i];
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        // since we're called from the DebMemLeak, we're only *guessing*
        // that we have a vptr etc., so we might fault.
        TraceMsg(TF_ALWAYS, "gve: GPF");
        pfunc = 0;
    }

    return pfunc;
}

//***   DBIsQIStub -- is 'this' a ptr to a 'CQIStub' object?
// DESCRIPTION
//  we look at the vtbl and assume that if we have a ptr to CQIStub::AddRef,
// then it's us.
// NOTES
//  M00BUG we do a 'new' in here, which can cause pblms if we're in the middle
// of intelli-leak and we end up doing a ReAlloc which moves the heap (raymondc
// found such a case).
//  M00BUG in a release build (w/ identical COMDAT folding) we'll get false
// hits since most/all AddRefs are identical and folded.  if we ever need to
// be more exact we can add a signature and key off that.
//  M00BUG hack hack we actually return a void *, just in case you want to
// know the 'real' object.  if that turns out to be useful, we should change
// to return a void * instead of a BOOL.

BOOL DBIsQIStub(void* that)
{
    void *par;

#if 0
    if (_sar == NULL)
        TraceMsg(DM_TRACE, "qis: _sar == NULL");
#endif

    par = DBGetVtblEnt(that, VFUNC_ADDREF);

#if 0
    TraceMsg(TF_ALWAYS, "IsQIStub(%x): par=%x _sar=%x", that, _sar, par);
#endif

    return (CQIStub::_sar == par && CQIStub::_sar != NULL) ? (BOOL)((CQIStub *)that)->_punk : 0;
#undef  VFUNC_ADDREF
}

TCHAR *DBGetQIStubSymbolic(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    return pqis->_szName;
}

//***   DBDumpQIStub -- pretty-print a 'CQIStub'
//
STDAPI_(void) DBDumpQIStub(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    TraceMsg(TF_ALWAYS, "\tqistub(%x): cRef=0x%x iSeq=%x iid=%s", that, pqis->_cRef, pqis->_iSeq, pqis->_szName);
}

// Memory layout of CQIStub is:
//    lpVtbl  // offset 0
//    _cRef   // offset 4
//    _punk   // offset 8
//
// "this" pointer stored in stack
//
// mov eax, ss:4[esp]          ; get pThis
// mov ecx, 8[eax]             ; get real object (_punk)
// mov eax, [ecx]              ; load the real vtable (_punk->lpVtbl)
//                             ; the above will fault if referenced after we're freed
// mov ss:4[esp], ecx          ; fix up stack object (_punk)
// jmp dword ptr cs:(4*i)[eax] ; jump to the real function
//
#define QIStubThunk(i) \
void _declspec(naked) CQIStub::thunk##i() \
{ \
    _asm mov eax, ss:4[esp]          \
    _asm mov ecx, 8[eax]             \
    _asm mov eax, [ecx]              \
    _asm mov ss:4[esp], ecx          \
    _asm jmp dword ptr cs:(4*i)[eax] \
}

QIStubThunk(0);
QIStubThunk(3);
QIStubThunk(4);
QIStubThunk(5);
QIStubThunk(6);
QIStubThunk(7);
QIStubThunk(8);
QIStubThunk(9);
QIStubThunk(10);
QIStubThunk(11);
QIStubThunk(12);
QIStubThunk(13);
QIStubThunk(14);
QIStubThunk(15);
QIStubThunk(16);
QIStubThunk(17);
QIStubThunk(18);
QIStubThunk(19);
QIStubThunk(20);
QIStubThunk(21);
QIStubThunk(22);
QIStubThunk(23);
QIStubThunk(24);
QIStubThunk(25);
QIStubThunk(26);
QIStubThunk(27);
QIStubThunk(28);
QIStubThunk(29);
QIStubThunk(30);
QIStubThunk(31);
QIStubThunk(32);
QIStubThunk(33);
QIStubThunk(34);
QIStubThunk(35);
QIStubThunk(36);
QIStubThunk(37);
QIStubThunk(38);
QIStubThunk(39);
QIStubThunk(40);
QIStubThunk(41);
QIStubThunk(42);
QIStubThunk(43);
QIStubThunk(44);
QIStubThunk(45);
QIStubThunk(46);
QIStubThunk(47);
QIStubThunk(48);
QIStubThunk(49);
QIStubThunk(50);
QIStubThunk(51);
QIStubThunk(52);
QIStubThunk(53);
QIStubThunk(54);
QIStubThunk(55);
QIStubThunk(56);
QIStubThunk(57);
QIStubThunk(58);
QIStubThunk(59);
QIStubThunk(60);
QIStubThunk(61);
QIStubThunk(62);
QIStubThunk(63);
QIStubThunk(64);
QIStubThunk(65);
QIStubThunk(66);
QIStubThunk(67);
QIStubThunk(68);
QIStubThunk(69);
QIStubThunk(70);
QIStubThunk(71);
QIStubThunk(72);
QIStubThunk(73);
QIStubThunk(74);
QIStubThunk(75);
QIStubThunk(76);
QIStubThunk(77);
QIStubThunk(78);
QIStubThunk(79);
QIStubThunk(80);
QIStubThunk(81);
QIStubThunk(82);
QIStubThunk(83);
QIStubThunk(84);
QIStubThunk(85);
QIStubThunk(86);
QIStubThunk(87);
QIStubThunk(88);
QIStubThunk(89);
QIStubThunk(90);
QIStubThunk(91);
QIStubThunk(92);
QIStubThunk(93);
QIStubThunk(94);
QIStubThunk(95);
QIStubThunk(96);
QIStubThunk(97);
QIStubThunk(98);
QIStubThunk(99);

// }

#endif // }
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\qistub.h ===
#ifndef _QISTUB_H_
#define _QISTUB_H_

#ifdef DEBUG
STDAPI_(BOOL) DBIsQIStub(void *);
STDAPI_(void) DBDumpQIStub(void *);
STDAPI_(BOOL) DBIsQIFunc(int ret, int delta);
#endif

#endif // _QISTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\regitemp.h ===
//
//  RegItemP.h  - header for regitem IDLists
//  
//  NOTE - these structures cannot be changed for any reason.
//

#ifndef _REGITEMP_H_
#define _REGITEMP_H_

#ifndef NOPRAGMAS
#pragma pack(1)
#endif

typedef struct _IDREGITEM
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    CLSID   clsid;
} IDREGITEM;
typedef UNALIGNED IDREGITEM *LPIDREGITEM;
typedef const UNALIGNED IDREGITEM *LPCIDREGITEM;


typedef struct
{
    IDREGITEM       idri;
    USHORT          cbNext;
} IDLREGITEM;           // "RegItem" IDList
typedef const UNALIGNED IDLREGITEM *LPCIDLREGITEM;

#ifndef NOPRAGMAS
#pragma pack()
#endif


// stolen from shell32\shitemid.h
#ifndef SHID_ROOTEDREGITEM
#define SHID_ROOTEDREGITEM       0x1e    //
#endif //SHID_ROOTEDREGITEM

// stolen from shell32\shitemid.h
#ifndef SHID_ROOT_REGITEM
#define SHID_ROOT_REGITEM        0x1f    //
#endif //SHID_ROOT_REGITEM

#endif // _REGITEMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\profileutil.h ===
//  --------------------------------------------------------------------------
//  Module Name: ProfileUtil.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to handle profile loading and unloading without a token.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ProfileUtil_
#define     _ProfileUtil_

//  --------------------------------------------------------------------------
//  CUserProfile
//
//  Purpose:    This class handles loading and unloading of a profile based
//              on object scope.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

class   CUserProfile
{
    private:
                                CUserProfile (void);
    public:
                                CUserProfile (const TCHAR *pszUsername, const TCHAR *pszDomain);
                                ~CUserProfile (void);

                                operator HKEY (void)    const;
    private:
        static  PSID            UsernameToSID (const TCHAR *pszUsername, const TCHAR *pszDomain);
        static  bool            SIDStringToProfilePath (const TCHAR *pszSIDString, TCHAR *pszProfilePath);
    private:
                HKEY            _hKeyProfile;
                TCHAR*          _pszSID;
                bool            _fLoaded;

        static  const TCHAR     s_szUserHiveFilename[];
};

#endif  /*  _ProfileUtil_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\qsort.h ===
// template qsort adapted from  msdev\crt\src\qsort.c
// created 7/96  bobp

// template<class T>
// void QSort (T *base, unsigned nEl, BOOL fSortUp)
// 
// quicksort array of T
//
// Uses class T member functions:
//    operator =
//  operator <=

#ifndef __TQSORT_INCL
#define __TQSORT_INCL

template<class T>
inline void Swap(T &a, T &b)
{
    T x = a; a = b; b = x;
}

template<class T>
static void __cdecl ShortSort (T *lo, T *hi, BOOL fUp)
{
    T *p, *max;

    while (hi > lo) {
        max = lo;
        if (fUp) {
            for (p = lo+1; p <= hi; p++) {
                if ( !(*p <= *max) )
                    max = p;
            }
        } else {
            for (p = lo+1; p <= hi; p++) {
                if ( !(*max <= *p) )
                    max = p;
            }
        }

        Swap (*max, *hi);

        hi --;
    }
}

#define CUTOFF 8            /* testing shows that this is good value */

template<class T>
void QSort (T *base, unsigned nEl, BOOL fUp)
{
    T *lo, *hi;              /* ends of sub-array currently sorting */
    T *mid;                  /* points to middle of subarray */
    T *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;           /* size of the sub-array */
    T *lostk[30], *histk[30];
    int stkptr;              /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (nEl < 2)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = base;
    hi = base + (nEl-1);        /* initialize limits */

recurse:

    size = (int)(hi - lo) + 1;   /* number of el's to sort */

    if (size <= CUTOFF) {
         ShortSort(lo, hi, fUp);
    }
    else {
        mid = lo + (size / 2);   /* find middle element */
        Swap(*mid, *lo);         /* swap it to beginning of array */
        loguy = lo;
        higuy = hi + 1;

        for (;;) {
            if (fUp) {
                do  {
                    loguy ++;
                } while (loguy <= hi && *loguy <= *lo);

                do  {
                    higuy --;
                } while (higuy > lo && *lo <= *higuy);
            } else {
                do  {
                    loguy ++;
                } while (loguy <= hi && *lo <= *loguy);

                do  {
                    higuy --;
                } while (higuy > lo && *higuy <= *lo);
            }

            if (higuy < loguy)
                break;

            Swap(*loguy, *higuy);
        }

        Swap(*lo, *higuy);     /* put partition element in place */

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + 1 < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - 1;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + 1 < higuy) {
                hi = higuy - 1;
                goto recurse;           /* do small recursion */
            }
        }
    }

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\rpctimeout.h ===
#ifndef _RPCTIMEOUT_H_
#define _RPCTIMEOUT_H_

////////////////
//
//  Timing out remote calls - Use this if you are using an out-of-proc
//  object (e.g., a clipboard data object) that may belong to an app
//  that is hung.
//
//  If any individual method takes more than dwTimeout milliseconds, the
//  call will be aborted and you will get an error code back.
//
//  Usage:
//
//  Typical usage...
//
//      CRPCTimeout timeout;            // optional timeout in milliseconds
//      hr = pdto->GetData(...);        // make some remote call
//      hr = pdto->GetData(...);        // make another remote call
//
//  If either of the GetData calls takes more than TIMEOUT_DEFAULT
//  milliseconds, it will be cancelled and return an error.
//
//  Timed-out-ness is sticky.  Once a single call has timed out, all
//  subsequent calls will be timed out immediately (to avoid hanging
//  on the same server over and over again) until the timeout object
//  is re-armed.
//
//  When the CRPCTimeout goes out of scope, it will disarm itself.
//  Or you can explicitly call the Disarm() method.
//
//  Fancier usage...
//
//      CRPCTimeout timeout(5000);      // five seconds
//      hr = pdto->GetData();           // this one times out after 5 seconds
//      timeout.Disarm();               // disable the timeout
//      hr = pdto->GetData();           // this one runs as long as necesary
//      timeout.Arm(2000);              // rearm the timer with a new timeout
//      hr = pdto->GetData();           // this one times out after 2 seconds
//      hr = pdto->GetData();           // this one times out after 2 seconds
//      if (timeout.TimedOut()) ...     // handle the timeout scenario
//
//
//
//  If you create multiple CRPCTimeout objects, you MUST disarm them in
//  reverse order or the timeout chain will be corrupted.  (Debug-only
//  code will attempt to catch this bug.)
//
//  Instead of creating multiple timeout objects at the same scope, you
//  should create just one object and rearm it.
//
//

class CRPCTimeout {
public:
    CRPCTimeout() { Init(); Arm(); }
    CRPCTimeout(DWORD dwTimeout) { Init(); Arm(dwTimeout); }
    ~CRPCTimeout() { Disarm(); }

    void Init();
    void Arm(DWORD dwTimeout = 0);
    void Disarm();
    BOOL TimedOut() const { return _fTimedOut; }

private:
    static void CALLBACK _Callback(PVOID lpParameter, BOOLEAN);

    DWORD   _dwThreadId;
    BOOL    _fTimedOut;
    HRESULT _hrCancelEnabled;
    HANDLE  _hTimer;
};

#endif // _RPCTIMEOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\runonce.h ===
//
// runonce.h
//

#ifndef _RUNONCE_INC
#define _RUNONCE_INC

// Cabinet_EnumRegApps flags 
#define RRA_DEFAULT               0x0000
#define RRA_DELETE                0x0001        // delete each reg value when we're done with it
#define RRA_WAIT                  0x0002        // Wait for current item to finish before launching next item
// was RRA_SHELLSERVICEOBJECTS    0x0004 -- do not reuse
#define RRA_NOUI                  0x0008        // prevents ShellExecuteEx from displaying error dialogs
#if (_WIN32_WINNT >= 0x0500)
#define RRA_USEJOBOBJECTS         0x0020        // wait on job objects instead of process handles
#endif

typedef UINT RRA_FLAGS;

typedef struct {
    TCHAR szSubkey[MAX_PATH];
    TCHAR szValueName[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
} REGAPP_INFO;

// legacy from ripping this code out of explorer\initcab.cpp
extern BOOL g_fCleanBoot;   // are we running in SAFE-MODE?
extern BOOL g_fEndSession;  // did we process a WM_ENDSESSION?

typedef BOOL (WINAPI* PFNREGAPPSCALLBACK)(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam);


STDAPI_(BOOL) ShellExecuteRegApp(LPCTSTR pszCmdLine, RRA_FLAGS fFlags);
STDAPI_(BOOL) Cabinet_EnumRegApps(HKEY hkeyParent, LPCTSTR pszSubkey, RRA_FLAGS fFlags, PFNREGAPPSCALLBACK pfnCallback, LPARAM lParam);
STDAPI_(BOOL) ExecuteRegAppEnumProc(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam);


#endif // _RUNONCE_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\sfview.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */



#ifdef __cplusplus
}       /* End of extern "C" { */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\runtask.h ===
#ifndef _RUNTASK_H_
#define _RUNTASK_H_

class CRunnableTask : public IRunnableTask
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IRunnableTask ***
    virtual STDMETHODIMP Run(void);
    virtual STDMETHODIMP Kill(BOOL bWait);
    virtual STDMETHODIMP Suspend(void);
    virtual STDMETHODIMP Resume(void);
    virtual STDMETHODIMP_(ULONG) IsRunning(void);

    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void) PURE;
    virtual STDMETHODIMP KillRT(BOOL bWait)     { return S_OK; };
    virtual STDMETHODIMP SuspendRT(void)        { return S_OK; };
    virtual STDMETHODIMP ResumeRT(void)         { return InternalResumeRT(); };
    virtual STDMETHODIMP InternalResumeRT(void) { _lState = IRTIR_TASK_FINISHED; return S_OK; };
    
protected:
    CRunnableTask(DWORD dwFlags);
    virtual ~CRunnableTask();
    
    LONG            _cRef;
    LONG            _lState;
    DWORD           _dwFlags;       // RTF_*
    HANDLE          _hDone;

#ifdef DEBUG
    DWORD           _dwTaskID;
#endif
};

// CRunnableTask flags
#define RTF_DEFAULT             0x00000000
#define RTF_SUPPORTKILLSUSPEND  0x00000001

#endif  // _RUNTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shalias.h ===
#ifndef _SHALIAS_H_
#define _SHALIAS_H_

// Editing modes
#define ADD_ALIAS   0x01
#define EDIT_ALIAS  0x02

#define LocalRealloc(a, b) LocalReAlloc(a, b, LMEM_MOVEABLE)

class CAlias;

typedef struct tagALIASINFO
{
    HWND hDlg;
    int  mode;
    HDPA aliasList;
    HDPA aliasDelList;
    BOOL fInternalChange;
    BOOL fChanged;
} ALIASINFO, * LPALIASINFO;

#define ALIASLIST_COLUMNS 2  

typedef struct tagALIASITEM 
{ 
	LPSTR aCols[ALIASLIST_COLUMNS]; 
} ALIASITEM; 

typedef struct tagALIASEDITINFO
{
    HDPA aliasList;
    CAlias * alias;
    HWND   hWnd;
    DWORD  dwFlags;
} ALIASEDITINFO, *LPALIASEDITINFO;

#define ALIASINFO_FROM_HDLG( hDlg ) \
    ((LPALIASINFO)GetWindowLong(hDlg, DWL_USER)) \

TCHAR *  EatSpaces( TCHAR * str );
TCHAR *  ChopSpaces( TCHAR * str );
TCHAR *  DuplicateString( TCHAR * str );

// CAlias - object representing one alias.
class CAlias
{
public:
    LPTSTR  m_alias;
    LPTSTR  m_szurl;
    BOOL    m_fDirty;
    CAlias( LPTSTR name );
   ~CAlias();
    
    // Operations defined for Asscociation

    Load();
    Save(); 
    Delete();

#ifdef DEBUG
    Print();
#endif
};

// Some Helper Function Prototypes
BOOL     FAR PASCAL InitAliasDialog(HWND hDlg, CAlias * current, BOOL fFullInit );
CAlias * GetCurrentAlias( HWND hDlg );

#define MAX_ALIAS_LENGTH 256

STDAPI_(BOOL) LoadAliases( HDPA aliasListIn );
STDAPI_(BOOL) SaveAliases( HDPA aliasListIn );
STDAPI_(BOOL) FreeAliases( HDPA aliasListIn );

STDAPI_(LPCTSTR) GetAliasName( CAlias * ptr );
STDAPI_(LPCTSTR) GetAliasUrl( CAlias * ptr );
STDAPI_(LPVOID)  CreateAlias( LPTSTR str );
STDAPI_(VOID)    DestroyAlias( CAlias * ptr );
STDAPI_(BOOL)    SetAliasInfo( CAlias * ptr, TCHAR * alias, TCHAR * url );

#ifdef UNICODE
// TODO :
#define FindAliasIndex FindAliasIndexW
#define FindAliasByURL FindAliasByURLW
#define AddAliasToList AddAliasToListW
#define GetURLForAlias GetURLForAliasW
#else
#define FindAliasIndex FindAliasIndexA
#define FindAliasByURL FindAliasByURLA
#define AddAliasToList AddAliasToListA
#define GetURLForAlias GetURLForAliasA
#endif

STDAPI_(BOOL)  GetURLForAliasW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLW(HDPA  aliasListIn, LPWSTR szurl, LPWSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexW(HDPA  aliasListIn, LPWSTR alias);

STDAPI_(BOOL)  GetURLForAliasA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLA(HDPA  aliasListIn, LPSTR szurl, LPSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexA(HDPA  aliasListIn, LPSTR alias);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\runonce.c ===
//
// runonce.c (shared runonce code between explorer.exe and runonce.exe)
//
#include <runonce.h>

#if (_WIN32_WINNT >= 0x0500)

// stolen from <tsappcmp.h>
#define TERMSRV_COMPAT_WAIT_USING_JOB_OBJECTS 0x00008000
#define CompatibilityApp 1
typedef LONG TERMSRV_COMPATIBILITY_CLASS;
typedef BOOL (* PFNGSETTERMSRVAPPINSTALLMODE)(BOOL bState);
typedef BOOL (* PFNGETTERMSRVCOMPATFLAGSEX)(LPWSTR pwszApp, DWORD* pdwFlags, TERMSRV_COMPATIBILITY_CLASS tscc);

// even though this function is in kernel32.lib, we need to have a LoadLibrary/GetProcAddress 
// thunk for downlevel components who include this
STDAPI_(BOOL) SHSetTermsrvAppInstallMode(BOOL bState)
{
    static PFNGSETTERMSRVAPPINSTALLMODE pfn = NULL;
    
    if (pfn == NULL)
    {
        // kernel32 should already be loaded
        HMODULE hmod = GetModuleHandle(TEXT("kernel32.dll"));

        if (hmod)
        {
            pfn = (PFNGSETTERMSRVAPPINSTALLMODE)GetProcAddress(hmod, "SetTermsrvAppInstallMode");
        }
        else
        {
            pfn = (PFNGSETTERMSRVAPPINSTALLMODE)-1;
        }
    }

    if (pfn && (pfn != (PFNGSETTERMSRVAPPINSTALLMODE)-1))
    {
        return pfn(bState);
    }
    else
    {
        return FALSE;
    }
}


STDAPI_(ULONG) SHGetTermsrCompatFlagsEx(LPWSTR pwszApp, DWORD* pdwFlags, TERMSRV_COMPATIBILITY_CLASS tscc)
{
    static PFNGETTERMSRVCOMPATFLAGSEX pfn = NULL;
    
    if (pfn == NULL)
    {
        HMODULE hmod = LoadLibrary(TEXT("TSAppCMP.DLL"));

        if (hmod)
        {
            pfn = (PFNGETTERMSRVCOMPATFLAGSEX)GetProcAddress(hmod, "GetTermsrCompatFlagsEx");
        }
        else
        {
            pfn = (PFNGETTERMSRVCOMPATFLAGSEX)-1;
        }
    }

    if (pfn && (pfn != (PFNGETTERMSRVCOMPATFLAGSEX)-1))
    {
        return pfn(pwszApp, pdwFlags, tscc);
    }
    else
    {
        *pdwFlags = 0;
        return 0;
    }
}


HANDLE SetJobCompletionPort(HANDLE hJob)
{
    HANDLE hRet = NULL;
    HANDLE hIOPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);

    if (hIOPort != NULL)
    {
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT CompletionPort;

        CompletionPort.CompletionKey = hJob ;
        CompletionPort.CompletionPort = hIOPort;

        if (SetInformationJobObject(hJob,
                                    JobObjectAssociateCompletionPortInformation,
                                    &CompletionPort,
                                    sizeof(CompletionPort)))
        {   
            hRet = hIOPort;
        }
        else
        {
            CloseHandle(hIOPort);
        }
    }

    return hRet;

}


STDAPI_(DWORD) WaitingThreadProc(void *pv)
{
    HANDLE hIOPort = (HANDLE)pv;

    if (hIOPort)
    {
        while (TRUE) 
        {
            DWORD dwCompletionCode;
            ULONG_PTR pCompletionKey;
            LPOVERLAPPED pOverlapped;
            
            if (!GetQueuedCompletionStatus(hIOPort, &dwCompletionCode, &pCompletionKey, &pOverlapped, INFINITE) ||
                (dwCompletionCode == JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO))
            {
                break;
            }
        }
    }

    return 0;
}


//
// The following handles running an application and optionally waiting for it
// to all the child procs to terminate. This is accomplished thru Kernel Job Objects
// which is only available in NT5
//
BOOL _CreateRegJob(LPCTSTR pszCmd, BOOL bWait)
{
    BOOL bRet = FALSE;
    HANDLE hJobObject = CreateJobObjectW(NULL, NULL);

    if (hJobObject)
    {
        HANDLE hIOPort = SetJobCompletionPort(hJobObject);

        if (hIOPort)
        {
            DWORD dwID;
            HANDLE hThread = CreateThread(NULL,
                                          0,
                                          WaitingThreadProc,
                                          (void*)hIOPort,
                                          CREATE_SUSPENDED,
                                          &dwID);

            if (hThread)
            {
                PROCESS_INFORMATION pi = {0};
                STARTUPINFO si = {0};
                UINT fMask = SEE_MASK_FLAG_NO_UI;
                DWORD dwCreationFlags = CREATE_SUSPENDED;
                TCHAR sz[MAX_PATH * 2];

                wnsprintf(sz, ARRAYSIZE(sz), TEXT("RunDLL32.EXE Shell32.DLL,ShellExec_RunDLL ?0x%X?%s"), fMask, pszCmd);
                
                si.cb = sizeof(si);

                if (CreateProcess(NULL,
                                  sz,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  dwCreationFlags,
                                  NULL,
                                  NULL,
                                  &si,
                                  &pi))
                {
                    if (AssignProcessToJobObject(hJobObject, pi.hProcess))
                    {
                        // success!
                        bRet = TRUE;

                        ResumeThread(pi.hThread);
                        ResumeThread(hThread);

                        if (bWait)
                        {
                            SHProcessMessagesUntilEvent(NULL, hThread, INFINITE);
                        }
                    }
                    else
                    {
                        TerminateProcess(pi.hProcess, ERROR_ACCESS_DENIED);    
                    }
            
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
               
                if (!bRet)
                {
                    TerminateThread(hThread, ERROR_ACCESS_DENIED);
                }

                CloseHandle(hThread);
            }

            CloseHandle(hIOPort);
        }
        
        CloseHandle(hJobObject);
    }

    return bRet;
}


BOOL _TryHydra(LPCTSTR pszCmd, RRA_FLAGS *pflags)
{
    // See if the terminal-services is enabled in "Application Server" mode
    if (IsOS(OS_TERMINALSERVER) && SHSetTermsrvAppInstallMode(TRUE))
    {
        WCHAR   sz[MAX_PATH];
        
        *pflags |= RRA_WAIT; 
        // Changing timing blows up IE 4.0, but IE5 is ok!
        // we are on a TS machine, NT version 4 or 5, with admin priv

        // see if the app-compatability flag is set for this executable
        // to use the special job-objects for executing module

        // get the module name, without the arguments
        if (0 < PathProcessCommand(pszCmd, sz, ARRAYSIZE(sz), PPCF_NODIRECTORIES))
        {
            ULONG   ulCompat;
            SHGetTermsrCompatFlagsEx(sz, &ulCompat, CompatibilityApp);

            // if the special flag for this module-name is set...
            if (ulCompat & TERMSRV_COMPAT_WAIT_USING_JOB_OBJECTS)
            {
                *pflags |= RRA_USEJOBOBJECTS;
            }
        }

        return TRUE;
    }

    return FALSE;
}
#endif // (_WIN32_WINNT >= 0x0500)

//
//  On success: returns process handle or INVALID_HANDLE_VALUE if no process
//              was launched (i.e., launched via DDE).
//  On failure: returns INVALID_HANDLE_VALUE.
//
BOOL _ShellExecRegApp(LPCTSTR pszCmd, BOOL fNoUI, BOOL fWait)
{
    TCHAR szQuotedCmdLine[MAX_PATH+2];
    LPTSTR pszArgs;
    SHELLEXECUTEINFO ei = {0};
    
    // Gross, but if the process command fails, copy the command line to let
    // shell execute report the errors
    if (PathProcessCommand((LPWSTR)pszCmd,
                           (LPWSTR)szQuotedCmdLine,
                           ARRAYSIZE(szQuotedCmdLine),
                           PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) == -1)
    {
        lstrcpy(szQuotedCmdLine, pszCmd);
    }

    pszArgs= PathGetArgs(szQuotedCmdLine);
    if (*pszArgs)
    {
        // Strip args
        *(pszArgs - 1) = 0;
    }

    PathUnquoteSpaces(szQuotedCmdLine);

    ei.cbSize          = sizeof(SHELLEXECUTEINFO);
    ei.lpFile          = szQuotedCmdLine;
    ei.lpParameters    = pszArgs;
    ei.nShow           = SW_SHOWNORMAL;
    ei.fMask           = SEE_MASK_NOCLOSEPROCESS;
    
    if (fNoUI)
    {
        ei.fMask |= SEE_MASK_FLAG_NO_UI;
    }

    if (ShellExecuteEx(&ei))
    {
        if (ei.hProcess)
        {
            if (fWait)
            {
                SHProcessMessagesUntilEvent(NULL, ei.hProcess, INFINITE);
            }

            CloseHandle(ei.hProcess);
        }

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


// The following handles running an application and optionally waiting for it
// to terminate.
STDAPI_(BOOL) ShellExecuteRegApp(LPCTSTR pszCmdLine, RRA_FLAGS fFlags)
{
    BOOL bRet = FALSE;

    if (!pszCmdLine || !*pszCmdLine)
    {
        // Don't let empty strings through, they will endup doing something dumb
        // like opening a command prompt or the like
        return bRet;
    }

#if (_WIN32_WINNT >= 0x0500)
    if (fFlags & RRA_USEJOBOBJECTS)
    {
        bRet = _CreateRegJob(pszCmdLine, fFlags & RRA_WAIT);
    }
#endif

    if (!bRet)
    {
        //  fallback if necessary.
        bRet = _ShellExecRegApp(pszCmdLine, fFlags & RRA_NOUI, fFlags & RRA_WAIT);
    }

    return bRet;
}


STDAPI_(BOOL) Cabinet_EnumRegApps(HKEY hkeyParent, LPCTSTR pszSubkey, RRA_FLAGS fFlags, PFNREGAPPSCALLBACK pfnCallback, LPARAM lParam)
{
    HKEY hkey;
    BOOL bRet = TRUE;

    // With the addition of the ACL controlled "policy" run keys RegOpenKey
    // might fail on the pszSubkey.  Use RegOpenKeyEx with MAXIMIM_ALLOWED
    // to ensure that we successfully open the subkey.
    if (RegOpenKeyEx(hkeyParent, pszSubkey, 0, MAXIMUM_ALLOWED, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbValue;
        DWORD dwType;
        DWORD i;
        TCHAR szValueName[80];
        TCHAR szCmdLine[MAX_PATH];
        HDPA hdpaEntries = NULL;

#ifdef DEBUG
        //
        // we only support named values so explicitly purge default values
        //
        LONG cbData = sizeof(szCmdLine);
        if (RegQueryValue(hkey, NULL, szCmdLine, &cbData) == ERROR_SUCCESS)
        {
            ASSERTMSG((cbData <= 2), "Cabinet_EnumRegApps: BOGUS default entry in <%s> '%s'", pszSubkey, szCmdLine);
            RegDeleteValue(hkey, NULL);
        }
#endif
        // now enumerate all of the values.
        for (i = 0; !g_fEndSession ; i++)
        {
            LONG lEnum;
            DWORD cbData;

            cbValue = ARRAYSIZE(szValueName);
            cbData = sizeof(szCmdLine);

            lEnum = RegEnumValue(hkey, i, szValueName, &cbValue, NULL, &dwType, (LPBYTE)szCmdLine, &cbData);

            if (ERROR_MORE_DATA == lEnum)
            {
                // ERROR_MORE_DATA means the value name or data was too large
                // skip to the next item
                TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: cannot run oversize entry '%s' in <%s>", szValueName, pszSubkey);
                continue;
            }
            else if (lEnum != ERROR_SUCCESS)
            {
                if (lEnum != ERROR_NO_MORE_ITEMS)
                {
                    // we hit some kind of registry failure
                    bRet = FALSE;
                }
                break;
            }

            if ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))
            {
                REGAPP_INFO * prai;

                if (dwType == REG_EXPAND_SZ)
                {
                    DWORD dwChars;
                    TCHAR szCmdLineT[MAX_PATH];

                    lstrcpy(szCmdLineT, szCmdLine);
                    dwChars = SHExpandEnvironmentStrings(szCmdLineT, 
                                                         szCmdLine,
                                                         ARRAYSIZE(szCmdLine));
                    if ((dwChars == 0) || (dwChars > ARRAYSIZE(szCmdLine)))
                    {
                        // bail on this value if we failed the expansion, or if the string is > MAX_PATH
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: expansion of '%s' in <%s> failed or is too long", szCmdLineT, pszSubkey);
                        continue;
                    }
                }
                
                TraceMsg(TF_GENERAL, "Cabinet_EnumRegApps: subkey = %s cmdline = %s", pszSubkey, szCmdLine);

                if (g_fCleanBoot && (szValueName[0] != TEXT('*')))
                {
                    // only run things marked with a "*" in when in SafeMode
                    continue;
                }

                // We used to execute each entry, wait for it to finish, and then make the next call to 
                // RegEnumValue(). The problem with this is that some apps add themselves back to the runonce
                // after they are finished (test harnesses that reboot machines and want to be restarted) and
                // we dont want to delete them, so we snapshot the registry keys and execute them after we
                // have finished the enum.
                prai = (REGAPP_INFO *)LocalAlloc(LPTR, sizeof(REGAPP_INFO));
                if (prai)
                {
                    lstrcpy(prai->szSubkey, pszSubkey);
                    lstrcpy(prai->szValueName, szValueName);
                    lstrcpy(prai->szCmdLine, szCmdLine);

                    if (!hdpaEntries)
                    {
                        hdpaEntries = DPA_Create(5);
                    }

                    if (!hdpaEntries || (DPA_AppendPtr(hdpaEntries, prai) == -1))
                    {
                        LocalFree(prai);
                    }
                }
            }
        }

        if (hdpaEntries)
        {
            int iIndex;
            int iTotal = DPA_GetPtrCount(hdpaEntries);

            for (iIndex = 0; iIndex < iTotal; iIndex++)
            {
                REGAPP_INFO* prai = (REGAPP_INFO*)DPA_GetPtr(hdpaEntries, iIndex);
                ASSERT(prai);
    
                // NB Things marked with a '!' mean delete after
                // the CreateProcess not before. This is to allow
                // certain apps (runonce.exe) to be allowed to rerun
                // to if the machine goes down in the middle of execing
                // them. Be very afraid of this switch.
                if ((fFlags & RRA_DELETE) && (prai->szValueName[0] != TEXT('!')))
                {
                    // This delete can fail if the user doesn't have the privilege
                    if (RegDeleteValue(hkey, prai->szValueName) != ERROR_SUCCESS)
                    {
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: skipping entry %s (cannot delete the value)", prai->szValueName);
                        LocalFree(prai);
                        continue;
                    }
                }

                pfnCallback(prai->szSubkey, prai->szCmdLine, fFlags, lParam);

                // Post delete '!' things.
                if ((fFlags & RRA_DELETE) && (prai->szValueName[0] == TEXT('!')))
                {
                    // This delete can fail if the user doesn't have the privilege
                    if (RegDeleteValue(hkey, prai->szValueName) != ERROR_SUCCESS)
                    {
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: cannot delete the value %s ", prai->szValueName);
                    }
                }

                LocalFree(prai);
            }

            DPA_Destroy(hdpaEntries);
            hdpaEntries = NULL;
        }

        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: failed to open subkey %s !", pszSubkey);
        bRet = FALSE;
    }


    if (g_fEndSession)
    {
        // NOTE: this is for explorer only, other consumers of runonce.c must declare g_fEndSession but leave
        // it set to FALSE always.

        // if we rx'd a WM_ENDSESSION whilst running any of these keys we must exit the process.
        ExitProcess(0);
    }

    return bRet;
}

STDAPI_(BOOL) ExecuteRegAppEnumProc(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam)
{
    BOOL bRet;
    RRA_FLAGS flagsTemp = fFlags;
    BOOL fInTSInstallMode = FALSE;

#if (_WIN32_WINNT >= 0x0500)
    // In here, We only attempt TS specific in app-install-mode 
    // if RunOnce entries are being processed 
    if (0 == lstrcmpi(szSubkey, REGSTR_PATH_RUNONCE)) 
    {
        fInTSInstallMode = _TryHydra(szCmdLine, &flagsTemp);
    }
#endif

    bRet = ShellExecuteRegApp(szCmdLine, flagsTemp);

#if (_WIN32_WINNT >= 0x0500)
    if (fInTSInstallMode)
    {
        SHSetTermsrvAppInstallMode(FALSE);
    }
#endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\sfstorage.cpp ===
#include "sfstorage.h"

class CSFStorageEnum : public IEnumSTATSTG
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumSTATSTG
    STDMETHOD(Skip)(ULONG celt)
        { return E_NOTIMPL; };
    STDMETHOD(Clone)(IEnumSTATSTG **ppenum)
        { return E_NOTIMPL; };

    STDMETHOD(Next)(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

protected:
    CSFStorageEnum(CSFStorage* psfstg);
    ~CSFStorageEnum();

private:
    LONG         _cRef;
    CSFStorage  *_psfstg;
    IEnumIDList *_peidl;

    HRESULT _PidlToSTATSTG(LPCITEMIDLIST pidl, STATSTG *pstatstg);

    friend CSFStorage;
};


CSFStorageEnum::CSFStorageEnum(CSFStorage *psfstg) :
    _cRef(1)
{
    _psfstg = psfstg;
    _psfstg->AddRef();

    DllAddRef();
}

CSFStorageEnum::~CSFStorageEnum()
{
    _psfstg->Release();
    ATOMICRELEASE(_peidl);

    DllRelease();
}

STDMETHODIMP_(ULONG) CSFStorageEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSFStorageEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSFStorageEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CSFStorageEnum, IEnumSTATSTG), // IEnumSTATSTG
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

HRESULT CSFStorageEnum::_PidlToSTATSTG(LPCITEMIDLIST pidl, STATSTG *pstatstg)
{
    ZeroMemory(pstatstg, sizeof(STATSTG));  // per COM conventions

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = _psfstg->GetDetailsEx(pidl, &SCID_FINDDATA, &var);
    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATAW wfd;
        if (VariantToBuffer(&var, &wfd, sizeof(wfd)))
        {
            pstatstg->atime = wfd.ftLastAccessTime;
            pstatstg->ctime = wfd.ftCreationTime;
            pstatstg->mtime = wfd.ftLastWriteTime;
            pstatstg->cbSize.HighPart = wfd.nFileSizeHigh;
            pstatstg->cbSize.LowPart = wfd.nFileSizeLow;
            pstatstg->type = (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? STGTY_STORAGE : STGTY_STREAM;
            hr = SHStrDupW(wfd.cFileName, &pstatstg->pwcsName);
        }
        VariantClear(&var);
    }
    return hr;
}

STDMETHODIMP CSFStorageEnum::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    ASSERT((celt != 1) ? (pceltFetched != NULL) : TRUE);

    HRESULT hr = S_OK;
    
    if (!_peidl)
    {
        hr = _psfstg->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &_peidl);
    }

    if (S_OK == hr)
    {
        hr = E_OUTOFMEMORY;
        LPITEMIDLIST *apidl = new LPITEMIDLIST[celt];
        if (apidl)
        {
            ULONG celtFetched;
            hr = _peidl->Next(celt, apidl, &celtFetched);
            if (SUCCEEDED(hr))
            {
                ULONG celtConverted = 0;

                ULONG i;
                for (i = 0; i < celtFetched; i++)
                {
                    if (SUCCEEDED(_PidlToSTATSTG(apidl[i], &rgelt[celtConverted])))
                    {
                        celtConverted++;
                    }
                }

                hr = (celtConverted == celt) ? S_OK : S_FALSE;
                if (pceltFetched)
                {
                    *pceltFetched = celtConverted;
                }

                for (i = 0; i < celtFetched; i++)
                {
                    ILFree(apidl[i]);
                }
            }
            delete apidl;
        }
    }
    return hr;
}

STDMETHODIMP CSFStorageEnum::Reset()
{
    HRESULT hr = S_OK;
    if (_peidl)
    {
        hr = _peidl->Reset();
    }
    return hr;
}

HRESULT CSFStorage::_ParseAndVerify(LPCWSTR pwszName, LPBC pbc, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = ParseDisplayName(NULL, pbc, (LPWSTR) pwszName, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        // must be single-level
        if (ILFindLastID(pidl) != pidl)
        {
            hr = E_FAIL;
            ILFree(pidl);
        }
        else
        {
            *ppidl = pidl;
        }
    }
    return hr;
}

HRESULT CSFStorage::_BindByName(LPCWSTR pwszName, LPBC pbcParse, DWORD grfMode, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pwszName, pbcParse, &pidl);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = BindToObject(pidl, pbc, riid, ppv);

            pbc->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::Commit(DWORD grfCommitFlags)
{
    return S_OK;
}

STDMETHODIMP CSFStorage::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // we can at least get the name to use in STATSTG.
    ZeroMemory(pstatstg, sizeof(STATSTG));

    LPITEMIDLIST pidl;
    HRESULT hr = SHGetIDListFromUnk(SAFECAST(this, IShellFolder2*), &pidl);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlLast;
        IShellFolder *psf;
        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                // don't know what mode we were bound with, STGM_READ is good enough.
                pstatstg->grfMode = STGM_READ;
                if (!(grfStatFlag & STATFLAG_NONAME))
                {
                    hr = SHStrDup(szName, &pstatstg->pwcsName);
                }
            }
            psf->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum)
{
    HRESULT hr;
    CSFStorageEnum *penum = new CSFStorageEnum(this);
    if (penum)
    {
        *ppenum = (IEnumSTATSTG *) penum;
        hr = S_OK;
    }
    else
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSFStorage::OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm)
{
    HRESULT hr = _BindByName(pszRel, NULL, grfMode, IID_PPV_ARG(IStream, ppstm));
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg)
{
    HRESULT hr = _BindByName(pszRel, NULL, grfMode, IID_PPV_ARG(IStorage, ppstg));
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::DestroyElement(LPCWSTR pszRel)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pszRel, NULL, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = _DeleteItemByIDList(pidl);
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pwcsOldName, NULL, &pidl);
    if (SUCCEEDED(hr))
    {
        // ISSUE: this might put up UI
        hr = SetNameOf(NULL, pidl, pwcsNewName, SHGDN_FORPARSING, NULL);
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
{
    // could have another virtual function here for the subclass to implement,
    // but nobody ever calls this function anyway.
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
{
    // TODO filefldr doesnt implement this so apparently nobody needs it yet
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    return StgMoveElementTo(SAFECAST(this, IShellFolder *), SAFECAST(this, IStorage *), pszRel, pstgDest, pwcsNewName, grfFlags);
}

HRESULT CSFStorage::_CreateHelper(LPCWSTR pwcsName, DWORD grfMode, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = S_OK;
    LPITEMIDLIST pidlTemp;
    if (!(grfMode & STGM_CREATE) && SUCCEEDED(_ParseAndVerify(pwcsName, NULL, &pidlTemp)))
    {
        ILFree(pidlTemp);
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
    }
    
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbcParse;
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbcParse);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = _ParseAndVerify(pwcsName, pbcParse, &pidl);
            if (SUCCEEDED(hr))
            {
                hr = _StgCreate(pidl, grfMode, riid, ppv);
                ILFree(pidl);
            }
            pbcParse->Release();
        }
    }
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    return _CreateHelper(pwcsName, grfMode, IID_PPV_ARG(IStream, ppstm));
}

STDMETHODIMP CSFStorage::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    return _CreateHelper(pwcsName, grfMode, IID_PPV_ARG(IStorage, ppstg));
}

// factored out of filefldr.cpp
HRESULT StgMoveElementTo(IShellFolder *psf, IStorage *pstgSrc, LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    if ((grfFlags != STGMOVE_MOVE) && (grfFlags != STGMOVE_COPY))
        return E_INVALIDARG;

    // Get the IDList for the source stream's file
    LPITEMIDLIST pidl;
    HRESULT hr = psf->ParseDisplayName(NULL, NULL, (LPWSTR) pwcsName, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        // Bind to the source file as an IStream
        IStream *pstmSrc;
        hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IStream, &pstmSrc));
        if (SUCCEEDED(hr))
        {
            // Create the destination stream
            IStream *pstmDst;
            hr = pstgDest->CreateStream(pwcsNewName, STGM_WRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, NULL, &pstmDst);
            if (SUCCEEDED(hr))
            {
                ULARGE_INTEGER ulMax = {-1, -1};    // whole thing
                hr = pstmSrc->CopyTo(pstmDst, ulMax, NULL, NULL);

                // If all went well this is a move (not a copy), remove the source
                if (SUCCEEDED(hr))
                {
                    hr = pstmDst->Commit(STGC_DEFAULT);
                    if (SUCCEEDED(hr) && (grfFlags == STGMOVE_MOVE))
                        hr = pstgSrc->DestroyElement(pwcsName);
                }
                pstmDst->Release();
            }
            pstmSrc->Release();
        }
        else
        {
            IStorage *pstgSrc;
            hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IStorage, &pstgSrc));
            if (SUCCEEDED(hr))
            {
                IStorage *pstgDst;
                hr = pstgDest->CreateStorage(pwcsNewName, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, NULL, &pstgDst);
                if (SUCCEEDED(hr))
                {
                    IEnumSTATSTG *penum;
                    if (S_OK == pstgSrc->EnumElements(0, NULL, 0, &penum))
                    {
                        STATSTG stat;
                        while (S_OK == penum->Next(1, &stat, NULL))
                        {
                            hr = pstgSrc->MoveElementTo(stat.pwcsName, pstgDst, stat.pwcsName, grfFlags);
                            if (SUCCEEDED(hr))
                                hr = pstgDst->Commit(STGC_DEFAULT);
                            CoTaskMemFree(stat.pwcsName);
                            if (FAILED(hr))
                                break;
                        }
                        penum->Release();
                    }

                    if (SUCCEEDED(hr))
                        hr = pstgDst->Commit(STGC_DEFAULT);

                    pstgDst->Release();
                }
                pstgSrc->Release();
            }
        }

        ILFree(pidl);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\sfstorage.h ===
#ifndef _SFSTORAGE_H_
#define _SFSTORAGE_H_

HRESULT StgMoveElementTo(IShellFolder *psf, IStorage *pstg, LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);


class CSFStorage : public IShellFolder2,
                   public IStorage
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void **) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList) PURE;
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut) PURE;
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj) PURE;
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut) PURE;
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut) PURE;
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut) PURE;

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(GUID *pGuid) PURE;
    STDMETHOD(EnumSearches)(IEnumExtraSearch **ppenum) PURE;
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) PURE;
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState) PURE;
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) PURE;
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails) PURE;
    STDMETHOD(MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid) PURE;

    // IStorage
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(SetClass)(REFCLSID clsid);
    STDMETHOD(SetStateBits)(DWORD grfStateBits, DWORD grfMask);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(EnumElements)(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);
    STDMETHOD(OpenStream)(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);
    STDMETHOD(OpenStorage)(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);
    STDMETHOD(DestroyElement)(LPCWSTR pszRel);
    STDMETHOD(RenameElement)(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName);
    STDMETHOD(SetElementTimes)(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime);
    STDMETHOD(CopyTo)(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest);
    STDMETHOD(MoveElementTo)(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);
    STDMETHOD(CreateStream)(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm);
    STDMETHOD(CreateStorage)(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg);

private:
    // must be implemented by subclass
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl) PURE;
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv) PURE;

    HRESULT _ParseAndVerify(LPCWSTR pwszName, LPBC pbc, LPITEMIDLIST *ppidl);
    HRESULT _BindByName(LPCWSTR pwszName, LPBC pbcParse, DWORD grfMode, REFIID riid, void **ppv);
    HRESULT _CreateHelper(LPCWSTR pwcsName, DWORD grfMode, REFIID riid, void **ppv);
};

#endif // _SFSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shdload.h ===
// Override the linkers default behaviour to DELAYLOAD failures.  Instead of throwing an exception
// try and return a function that simulates a failure in that API, therefore allowing the caller
// to correctly handle it.
//
// To use this functionality exactly one source must include this with COMPILE_DELAYLOAD_STUBS defined,
// and link to shlwapi.

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

#ifdef COMPILE_DELAYLOAD_STUBS

#include "delayimp.h"

// NOTE: The names __pfnDliNotifyHook / __pfnDliFailureHook must not be changed,
// NOTE: as they are referenced by the linker's DELAYLOAD handler so we can hook
// NOTE: and process failures during symbol import.  

FARPROC WINAPI ShellDelayLoadHelper(UINT unReason, PDelayLoadInfo pInfo);

PfnDliHook  __pfnDliNotifyHook = ShellDelayLoadHelper;
PfnDliHook  __pfnDliFailureHook = ShellDelayLoadHelper;

#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shdguid.h ===
#ifndef __shdguid_h__
#define __shdguid_h__

// GUIDs for COM objects that live in SHDOCVW.DLL. currently this is shared with SHELL32.DLL only

// this is the IE30 WebBrowser's CLSID
DEFINE_GUID(CLSID_WebBrowser_V1,0xEAB22AC3L,0x30C1,0x11CF,0xA7,0xEB,0x00,0x00,0xC0,0x5B,0xAE,0x0B);

// 7BA4C740-9E81-11CF-99D3-00AA004AE837
DEFINE_GUID(CLSID_SendToMenu, 0x7BA4C740L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {C2FBB630-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_CopyToMenu, 0xc2fbb630, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {C2FBB631-2971-11d1-A18C-00C04FD75D13}
DEFINE_GUID(CLSID_MoveToMenu, 0xc2fbb631, 0x2971, 0x11d1, 0xa1, 0x8c, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// 59FEBFE0-2ED3-11D1-83E5-00A0C90DC849
DEFINE_GUID(CLSID_NavigationBand, 0x59FEBFE0, 0x2ED3, 0x11D1, 0x83, 0xE5, 0x0, 0xA0, 0xC9, 0x0D, 0xC8, 0x49);

// {353ECE21-74CB-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_SNSList, 0x353ece21, 0x74cb, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {2466C261-78ED-11d0-80FB-00AA005B4383}
DEFINE_GUID(CLSID_ACPList, 0x2466c261, 0x78ed, 0x11d0, 0x80, 0xfb, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// 90A756E0-AFCF-11CE-927B-0800095AE340
DEFINE_GUID(CLSID_TargetMenu, 0x90A756E0L, 0xAFCF, 0x11CE, 0x92, 0x7B, 0x08, 0x00, 0x09, 0x5A, 0xE3, 0x40);

// 57D5ECC0-A23F-11CE-AE65-08002B2E1262
DEFINE_GUID(CLSID_ContentsMenu, 0x57D5ECC0L, 0xA23F, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);

// 26027EA0-3992-11D0-A271-00A0C90A90CE
DEFINE_GUID(CLSID_NewFileMenu, 0x26027EA0, 0x3992, 0x11D0, 0xA2, 0x71, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE);

// *** Really private (never move to even to semi-public header) ***

// 6667E240-0F9D-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjMenuExt,   0x6667E240L, 0x0F9D, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
// 131A6952-7F78-11D0-A979-00C04FD705A2
// 02BA3B52-0547-11D1-B833-00C04FC9B31F

// {D1F15BC1-D650-11d1-9839-006097DF5BD4}
DEFINE_GUID(IID_IFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(CLSID_CFtpLegacySupport, 0xd1f15bc1, 0xd650, 0x11d1, 0x98, 0x39, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 2D8ECD81-4A7B-11CF-A0B9-00AA002F954E
DEFINE_GUID(IID_INavigationStack,          0x2D8ECD81L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(IID_INavigationStackItem,      0x2D8ECD82L, 0x4A7B, 0x11CF, 0xA0, 0xB9, 0x00, 0xAA, 0x00, 0x2F, 0x95, 0x4E);
DEFINE_GUID(CLSID_CShellDataSource,        0xD4903360L, 0x44da, 0x11d0, 0x89, 0xe2, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);

//CLSID_CDeskHtmlProp  3FC0B520-68A9-11D0-8D77-00C04FD70822

// This is the property sheet extension for the desk.cpl
// 3FC0B520-68A9-11D0-8D77-00C04FD70822
DEFINE_GUID(CLSID_CDeskHtmlProp, 0x3FC0B520L, 0x68A9, 0x11D0, 0x8D, 0x77, 0x00, 0xC0, 0x4F, 0xD7, 0x08, 0x22);


// {F46EDB3B-BC2F-11d0-9412-00AA00A3EBD3}
DEFINE_GUID(IID_ITravelEntry,  0xf46edb3b, 0xbc2f, 0x11d0, 0x94, 0x12, 0x0, 0xaa, 0x0, 0xa3, 0xeb, 0xd3);

// (old: F46EDB3C-BC2F-11d0-9412-00AA00A3EBD3 until 980909)
// {66A9CB08-4802-11d2-A561-00A0C92DBFE8}
DEFINE_GUID(IID_ITravelLog, 0x66a9cb08, 0x4802, 0x11d2, 0xa5, 0x61, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {3050f679-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_ITravelLogEx, 0x3050f679, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {3050f67A-98b5-11cf-bb82-00aa00bdce0b}
DEFINE_GUID(IID_ITravelLogClient, 0x3050f67a, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {26fdc864-be88-46e7-9235-032d8ea5162e}
DEFINE_GUID(CLSID_MergedFolder,             0x26fdc864, 0xbe88, 0x46e7, 0x92, 0x35, 0x03, 0x2d, 0x8e, 0xa5, 0x16, 0x2e);
// {0d867ed2-247d-479b-9181-227d09c2e001}
DEFINE_GUID(IID_IAugmentedShellFolder3,     0x0d867ed2, 0x247d, 0x479b, 0x91, 0x81, 0x22, 0x7d, 0x09, 0xc2, 0xe0, 0x01);

// {568804CE-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(CLSID_FavoriteMenu,             0x568804ce, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {568804CF-CBD7-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_FavoriteMenu,               0x568804cf, 0xcbd7, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {C501AE8A-5A64-11d1-9838-00C04FD91972}
DEFINE_GUID(IID_IProxyShellFolder,          0xc501ae8a, 0x5a64, 0x11d1, 0x98, 0x38, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {70A77D84-D78C-11d0-9816-00C04FD91972}
DEFINE_GUID(IID_ISetWinHandler,             0x70a77d84, 0xd78c, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {A82A3FDE-ECE6-11d0-981C-00C04FD91972}
DEFINE_GUID(IID_IDropTargetBackground,      0xa82a3fde, 0xece6, 0x11d0, 0x98, 0x1c, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {e17d4fc0-5564-11d1-83f2-00a0c90dc849}
DEFINE_GUID(CLSID_DocFindFolder, 0xe17d4fc0, 0x5564, 0x11d1, 0x83, 0xf2, 0x0, 0xa0, 0xc9, 0x0d, 0xc8, 0x49);

// {1f4de370-d627-11d1-ba4f-00a0c91eedba}
DEFINE_GUID(CLSID_ComputerFindFolder, 0x1f4de370, 0xd627, 0x11d1, 0xba, 0x4f, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {B005E690-678D-11d1-B758-00A0C90564FE}
DEFINE_GUID(CLSID_DocFindCommand, 0xb005e690, 0x678d, 0x11d1, 0xb7, 0x58, 0x0, 0xa0, 0xc9, 0x5, 0x64, 0xfe);

// {3409E930-5A39-11d1-83FA-00A0C90DC849}
DEFINE_GUID(IID_IContextMenuCB, 0x3409e930, 0x5a39, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

// {50a7e9b0-70ef-11d1-b75a-00a0c90564fe}
DEFINE_GUID(LIBID_Shell32, 0x50a7e9b0, 0x70ef, 0x11d1, 0xb7, 0x5a, 0x0,
 0xa0, 0xc9, 0x5, 0x64, 0xfe);


// {A85C4BB0-5AEE-11d1-83FA-00A0C90DC849}
DEFINE_GUID(SID_DocFindFolder, 0xa85c4bb0, 0x5aee, 0x11d1, 0x83, 0xfa, 0x0, 0xa0, 0xc9, 0xd, 0xc8, 0x49);

#endif // __shdguid_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shconv.h ===
//
//  Wrapper for <atlconv.h> that redirects it to our C-callable
//  helper functions, and also creates the appropriate definitions
//  for C callers so everybody can use the A2W/W2A macros.
//

#ifndef _SHCONV_H
#define _SHCONV_H
//
//  Force these to EXTERN_C so we can use them from C code, too.
//
STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
STDAPI_(LPSTR)  SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);
#define ATLA2WHELPER SHA2WHelper
#define ATLW2AHELPER SHW2AHelper


#ifdef __cplusplus
#ifndef offsetof
#define offsetof(s,m)   ((size_t)&(((s *)0)->m))
#endif
#ifndef ATLASSERT
#define ATLASSERT(f) ASSERT(f)
#endif
#include <atlconv.h>
#else

#define USES_CONVERSION int _convert = 0

//
//  This macro assumes that lstrlenW(UNICODE) <= lstrlenA(ANSI)
//
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
            _convert = (lstrlenA(lpa)+1),\
            ATLA2WHELPER((LPWSTR) alloca(_convert*2), (LPCSTR)lpa, _convert)))

//
//  This macro assumes that lstrlenA(ANSI) <= lstrlenW(UNICODE) * 2
//

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
            _convert = (lstrlenW(lpw)+1)*2,\
            ATLW2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#ifdef UNICODE
        #define T2A W2A
        #define A2T A2W
        __inline LPWSTR T2W(LPTSTR lp) { return lp; }
        __inline LPTSTR W2T(LPWSTR lp) { return lp; }
        #define T2CA W2CA
        #define A2CT A2CW
        __inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
        __inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
        #define T2W A2W
        #define W2T W2A
        __inline LPSTR T2A(LPTSTR lp) { return lp; }
        __inline LPTSTR A2T(LPSTR lp) { return lp; }
        #define T2CW A2CW
        #define W2CT W2CA
        __inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
        __inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif

#include <crt/malloc.h>         // Get definition for alloca()

#endif // !C++

#endif // _SHCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\sherror.h ===
#ifndef _SHERROR_H_
#define _SHERROR_H_



#endif // _SHERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

#include <shldisp.h>

//
// shell private header
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)


#ifdef __cplusplus
}
#endif // __cplusplus


//
// Context menu helper functions
//
STDAPI_(UINT) GetMenuIndexForCanonicalVerb(HMENU hMenu, IContextMenu* pcm, UINT idCmdFirst, LPCWSTR pwszVerb);
STDAPI ContextMenu_GetCommandStringVerb(IContextMenu *pcm, UINT idCmd, LPWSTR pszVerb, int cchVerb);
STDAPI ContextMenu_DeleteCommandByName(IContextMenu *pcm, HMENU hpopup, UINT idFirst, LPCWSTR pszCommand);

//
// Info tip helper functions
//
BOOL GetInfoTipHelpA(IShellFolder* psf, LPCITEMIDLIST pidl, LPSTR pszText, int cchTextMax);
BOOL GetInfoTipHelpW(IShellFolder* psf, LPCITEMIDLIST pidl, LPWSTR pszText, int cchTextMax);

BOOL GetInfoTipHelpExA(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPSTR pszText, int cchTextMax);
BOOL GetInfoTipHelpExW(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPWSTR pszText, int cchTextMax);

#ifdef UNICODE
#define GetInfoTipHelp          GetInfoTipHelpW
#define GetInfoTipHelpEx        GetInfoTipHelpExW
#else // UNICODE
#define GetInfoTipHelp          GetInfoTipHelpA
#define GetInfoTipHelpEx        GetInfoTipHelpExA
#endif // UNICODE


#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shdocvw.h ===
#ifndef _SHDOCVW_H_
#define _SHDOCVW_H_

//
// Define used for unicode shodcvw.  When shdocvw is fully unicode and no longer
// builds an ansi version this should be removed.

#include <iethread.h>

//
// SHDOCVW private header
//

// #include <shlobj.h> or <shellapi.h> before this to get the right
// SHDOCAPI macro definitions.
//

// value under HKLM\software\microsoft\internet explorer where we cache the platform
#define REGVAL_INTEGRATEDBROWSER    TEXT("IntegratedBrowser")

SHDOCAPI_(int) IEWinMain(LPSTR pszCmdLine, int nCmdShow);

//
// Automation support.
//
SHDOCAPI CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);

SHDOCAPI SHGetIDispatchForFolder(LPCITEMIDLIST pidl, IWebBrowserApp **ppauto);


SHDOCAPI URLQualifyA(LPCSTR pszURL, DWORD dwFlags, LPSTR * ppszOut);
SHDOCAPI URLQualifyW(LPCWSTR pszURL, DWORD dwFlags, LPWSTR * ppszOut);

#ifdef UNICODE
#define URLQualify      URLQualifyW
#else
#define URLQualify      URLQualifyA
#endif

// Flags for URLQualify
#define UQF_GUESS_PROTOCOL          0x00000001  // Try to guess based upon given path ("www.msn.com")
#define UQF_USE_DEFAULT_PROTOCOL    0x00000002  // Resort to default protocol if guess fails
#define UQF_IGNORE_FILEPATHS        0x00000004  // Don't special case file paths
#define UQF_CANONICALIZE            0x00000008  // Canonicalize if a valid URL
#define UQF_AUTOCORRECT             0x00000010  // Try to correct typo's
#define UQF_DEFAULT                 (UQF_GUESS_PROTOCOL | UQF_USE_DEFAULT_PROTOCOL)

// Quick pass to show Splash screens for IE components
SHDOCAPI_(HWND) SHShowSplashScreen(DWORD dwMember); // Which member of family...
SHDOCAPI        SHDismissSplashScreen(HWND hwnd);

SHDOCAPI_(BOOL) GenerateHTMLForDesktop();

#define COMP_TYPE_MASK          0x0000000F  // apply to COMP_TYPE to get the type
#define COMP_UNCHECKED          0x00001000
#define COMP_CHECKED            0x00002000
#define COMP_SELECTED           0x00002000
#define COMP_NOSCROLL           0x00004000


// shared icons. 
// instead of duplicating the icons in a bunch of dll's, we have a few that are shared
#define IDI_HOMEPAGE                    100   // Index:   0

SHDOCAPI_(BOOL) IsFileUrl(LPCSTR psz);
SHDOCAPI_(BOOL) IsFileUrlW(LPCWSTR pcwzUrl);
SHDOCAPI_(BOOL) PathIsFilePath(LPCWSTR lpszPath);

SHDOCAPI_(BOOL) IsErrorUrl(LPCWSTR pwszDisplayName);


// For dwSubstitutions parameter in URLSubstitution() and RegURLSubstitution().
//#define URLSUB_CLSID      0x00000001  // UNUSED (buzzr)
#define URLSUB_PRD          0x00000002  // Product IE (Example: "ie")
#define URLSUB_PVER         0x00000004  // Product Version (Example: "4.0")
#define URLSUB_OS           0x00000008  // System OS, same as header
#define URLSUB_RFC1766      0x00000010  // Human readable LCID (Example: "en-us")
#define URLSUB_OVER         0x00000020  // System OS Version (Example: 3.1, 3.5.1, 4.0).  Do not use year numbers.
#define URLSUB_OLCID        0x00000040  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the operating system.
#define URLSUB_CLCID        0x00000080  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the current users Regional Setting (as in Control Panel).
#define URLSUB_ALL          0xFFFFFFFF

SHDOCAPI  URLSubLoadString(HINSTANCE hInst, UINT idRes, LPWSTR pszUrlOut, 
                                DWORD cchSizeOut, DWORD dwSubstitutions);

SHDOCAPI_(void) SHInitRoot(IETHREADPARAM* piei);

SHDOCAPI URLSubstitution(LPCWSTR pszUrlIn, LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);

SHDOCAPI_(IStream *) OpenPidlOrderStream(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidl, LPCSTR pszKey, DWORD grfMode);
SHDOCAPI DragDrop(HWND hwnd, IShellFolder * psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD *pdwEffect) ;
SHDOCAPI_(int) IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int *piSelectedImage);
SHDOCAPI_(void) IEInvalidateImageList(void);
SHDOCAPI_(BOOL) ILIsWeb(LPCITEMIDLIST pidl);
SHDOCAPI_(BOOL) IsURLChild(LPCITEMIDLIST pidl, BOOL fIncludeHome);
SHDOCAPI IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEParseDisplayName(UINT uiCP, LPCTSTR pszPath, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEBindToObjectEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
SHDOCAPI IEBindToObject(LPCITEMIDLIST pidl, IShellFolder **ppsfOut);
SHDOCAPI IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs);
SHDOCAPI IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags);
SHDOCAPI IEGetNameAndFlags(LPCITEMIDLIST pidl, UINT uFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs);

//  flags for IEGetNameAndFlagsEx() dwIEFlags
#define     IEGDN_NOFRAGMENT    0x0001
SHDOCAPI IEGetNameAndFlagsEx(LPCITEMIDLIST pidl, UINT uSHFlags, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs);
SHDOCAPI_(BOOL) IEILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fIgnoreHidden);
SHDOCAPI IECreateFromPathCPWithBCA(UINT uiCP, LPCSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);
SHDOCAPI IECreateFromPathCPWithBCW(UINT uiCP, LPCWSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);

#define IEParseDisplayNameW(uiCP, pwszPath, ppidlOut)       IEParseDisplayNameWithBCW(uiCP, pwszPath, NULL, ppidlOut)
#define IECreateFromPathA(pszPath, ppidlOut) IECreateFromPathCPWithBCA(CP_ACP, pszPath, NULL, ppidlOut)
#define IECreateFromPathW(pszPath, ppidlOut) IECreateFromPathCPWithBCW(CP_ACP, pszPath, NULL, ppidlOut)

#ifdef UNICODE
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCW
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#else // UNICODE 
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCA
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#endif // UNICODE



SHDOCAPI CreateShortcutInDirA(IN LPCITEMIDLIST pidlTarget, IN LPSTR pszTitle, IN LPCSTR pszDir, 
                    OUT LPSTR pszOut, IN BOOL bUpdateProperties);
SHDOCAPI CreateShortcutInDirW(IN LPCITEMIDLIST pidlTarget, IN LPWSTR pwzTitle, IN LPCWSTR pwzDir, 
                    OUT LPWSTR pwzOut, IN BOOL bUpdateProperties);

#ifndef UNICODE
#define CreateShortcutInDir         CreateShortcutInDirA
#else
#define CreateShortcutInDir         CreateShortcutInDirW
#endif

SHDOCAPI_(void) IECleanUpAutomationObject();
SHDOCAPI_(void) IEOnFirstBrowserCreation(IUnknown* punkAuto);
SHDOCAPI_(BOOL) IEDDE_WindowDestroyed(HWND hwnd);
SHDOCAPI_(BOOL) IEDDE_NewWindow(HWND hwnd);

SHDOCAPI _GetStdLocation(LPWSTR pszPath, DWORD cchPathSize, UINT id);

SHDOCAPI SHCreateStreamWrapperCP(IStream *aStreams[], UINT cStreams, DWORD grfMode, UINT uiCodePage, IStream **ppstm);

#define DVIDM_GOHOME         (FCIDM_SHVIEWFIRST + 0x10E)

/// Browser command ids
//---------------------------------------------------------------------------


/// pre-merged browser menu command ids
///--------------------------------------------------------------------------
#define DVIDM_FIRST          (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_OPEN           (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_SAVE           (FCIDM_SHVIEWFIRST + 0x101)
#define DVIDM_SAVEASFILE     (FCIDM_SHVIEWFIRST + 0x102)
#define DVIDM_PAGESETUP      (FCIDM_SHVIEWFIRST + 0x103)
#define DVIDM_PRINT          (FCIDM_SHVIEWFIRST + 0x104)
#define DVIDM_PROPERTIES     (FCIDM_SHVIEWFIRST + 0x106)
#define DVIDM_CUT            (FCIDM_SHVIEWFIRST + 0x107)
#define DVIDM_COPY           (FCIDM_SHVIEWFIRST + 0x108)
#define DVIDM_PASTE          (FCIDM_SHVIEWFIRST + 0x109)
#define DVIDM_REFRESH        (FCIDM_SHVIEWFIRST + 0x10A)
#define DVIDM_STOPDOWNLOAD   (FCIDM_SHVIEWFIRST + 0x10B)
#define DVIDM_ZOOMIN         (FCIDM_SHVIEWFIRST + 0x10C)
#define DVIDM_ZOOMOUT        (FCIDM_SHVIEWFIRST + 0x10D)
#define DVIDM_GOSEARCH       (FCIDM_SHVIEWFIRST + 0x10F)
#define DVIDM_GOFIRSTHOME    (FCIDM_SHVIEWFIRST + 0x110)
#define DVIDM_GOFIRSTHOMERO  (FCIDM_SHVIEWFIRST + 0x111)
#define DVIDM_GOLOCALPAGE    (FCIDM_SHVIEWFIRST + 0x112)
#define DVIDM_NEWWINDOW      (FCIDM_SHVIEWFIRST + 0x113)
#define DVIDM_DHFAVORITES    (FCIDM_SHVIEWFIRST + 0x114)
#define DVIDM_PRINTPREVIEW   (FCIDM_SHVIEWFIRST + 0x115)
#define DVIDM_PRINTFRAME     (FCIDM_SHVIEWFIRST + 0x116)
#define DVIDM_NEWMESSAGE     (FCIDM_SHVIEWFIRST + 0x117)
#define DVIDM_SEARCHBAR      (FCIDM_SHVIEWFIRST + 0x118)
#define DVIDM_SEND           (FCIDM_SHVIEWFIRST + 0x119)
#define DVIDM_SENDPAGE       (FCIDM_SHVIEWFIRST + 0x11A)
#define DVIDM_SENDSHORTCUT   (FCIDM_SHVIEWFIRST + 0x11B)
#define DVIDM_DESKTOPSHORTCUT (FCIDM_SHVIEWFIRST + 0x11C)
#define DVIDM_SENDTO         (FCIDM_SHVIEWFIRST + 0x140)
#define DVIDM_SENDTOFIRST    (FCIDM_SHVIEWFIRST + 0x141)
#define DVIDM_SENDTOLAST     (FCIDM_SHVIEWFIRST + 0x14f)
#define DVIDM_HELPABOUT      (FCIDM_SHVIEWFIRST + 0x150)
#define DVIDM_HELPSEARCH     (FCIDM_SHVIEWFIRST + 0x151)
#define DVIDM_HELPTUTORIAL   (FCIDM_SHVIEWFIRST + 0x152)
#define DVIDM_HELPREPAIR     (FCIDM_SHVIEWFIRST + 0x153)
#define DVIDM_HELPMSWEB      (FCIDM_SHVIEWFIRST + 0x154)
#define DVIDM_HELPMSWEBLAST  (FCIDM_SHVIEWFIRST + 0x16f)

#define DVIDM_SHOWTOOLS      (FCIDM_SHVIEWFIRST + 0x170)
#define DVIDM_MAILNEWS       (FCIDM_SHVIEWFIRST + 0x171)
#define DVIDM_FONTS          (FCIDM_SHVIEWFIRST + 0x172)
#define DVIDM_EDITPAGE       (FCIDM_SHVIEWFIRST + 0x173)
#define DVIDM_DISCUSSIONS    (FCIDM_SHVIEWFIRST + 0x174)
#define DVIDM_ENCODING       (FCIDM_SHVIEWFIRST + 0x175)

#define DVIDM_IMPORTEXPORT   (FCIDM_SHVIEWFIRST + 0x176)

#define DVIDM_SUITE_APP_FIRST  (FCIDM_SHVIEWFIRST + 0x180)
#define DVIDM_NEW            (DVIDM_SUITE_APP_FIRST + 0x002)
#define DVIDM_NEWPOST        (DVIDM_SUITE_APP_FIRST + 0x003)
#define DVIDM_NEWAPPOINTMENT (DVIDM_SUITE_APP_FIRST + 0x004)
#define DVIDM_NEWMEETING     (DVIDM_SUITE_APP_FIRST + 0x005)
#define DVIDM_NEWCONTACT     (DVIDM_SUITE_APP_FIRST + 0x006)
#define DVIDM_NEWTASK        (DVIDM_SUITE_APP_FIRST + 0x007)
#define DVIDM_NEWTASKREQUEST (DVIDM_SUITE_APP_FIRST + 0x008)
#define DVIDM_NEWJOURNAL     (DVIDM_SUITE_APP_FIRST + 0x009)
#define DVIDM_NEWNOTE        (DVIDM_SUITE_APP_FIRST + 0x00a)
#define DVIDM_CALL           (DVIDM_SUITE_APP_FIRST + 0x00b)
#define DVIDM_SUITE_APP_LAST (DVIDM_SUITE_APP_FIRST + 0x020)

#define DVIDM_NONSUITE_APP_FIRST (FCIDM_SHVIEWFIRST + 0x1B0)
#define DVIDM_NONSUITE_APP_LAST (DVIDM_NONSUITE_APP_FIRST + 0x20)

// large block must be reserved for pre-merged menu
#define DVIDM_MSHTML_FIRST   (FCIDM_SHVIEWFIRST + 0x0400)
#define DVIDM_MSHTML_LAST    (FCIDM_SHVIEWFIRST + 0x1fff)

// Reserve a Block for Tools Menu Extensions
#define DVIDM_MENUEXT_FIRST     (DVIDM_MSHTML_LAST + 1)
#define DVIDM_MENUEXT_LAST      (DVIDM_MENUEXT_FIRST + 0x200)

#define IDS_HELP_FIRST          0x4000
#define IDS_HELP_OF(id)         ((id - DVIDM_FIRST)+IDS_HELP_FIRST)
#define IDS_HELP_OPEN           IDS_HELP_OF(DVIDM_OPEN           )
#define IDS_HELP_SAVE           IDS_HELP_OF(DVIDM_SAVE           )
#define IDS_HELP_SAVEASFILE     IDS_HELP_OF(DVIDM_SAVEASFILE     )
#define IDS_HELP_PAGESETUP      IDS_HELP_OF(DVIDM_PAGESETUP      )
#define IDS_HELP_PRINT          IDS_HELP_OF(DVIDM_PRINT          )
#define IDS_HELP_PROPERTIES     IDS_HELP_OF(DVIDM_PROPERTIES     )
#define IDS_HELP_CUT            IDS_HELP_OF(DVIDM_CUT            )
#define IDS_HELP_COPY           IDS_HELP_OF(DVIDM_COPY           )
#define IDS_HELP_PASTE          IDS_HELP_OF(DVIDM_PASTE          )
#define IDS_HELP_STOPDOWNLOAD   IDS_HELP_OF(DVIDM_STOPDOWNLOAD   )
#define IDS_HELP_REFRESH        IDS_HELP_OF(DVIDM_REFRESH        )
#define IDS_HELP_GOHOME         IDS_HELP_OF(DVIDM_GOHOME         )
#define IDS_HELP_GOSEARCH       IDS_HELP_OF(DVIDM_GOSEARCH       )
#define IDS_HELP_NEWWINDOW      IDS_HELP_OF(DVIDM_NEWWINDOW      )
#define IDS_HELP_PRINTPREVIEW   IDS_HELP_OF(DVIDM_PRINTPREVIEW   )
#define IDS_HELP_PRINTFRAME     IDS_HELP_OF(DVIDM_PRINTFRAME     )
#define IDS_HELP_NEWMESSAGE     IDS_HELP_OF(DVIDM_NEWMESSAGE     )
#define IDS_HELP_DHFAVORITES    IDS_HELP_OF(DVIDM_DHFAVORITES    )
#define IDS_HELP_HELPABOUT      IDS_HELP_OF(DVIDM_HELPABOUT      )
#define IDS_HELP_HELPSEARCH     IDS_HELP_OF(DVIDM_HELPSEARCH     )
#define IDS_HELP_HELPTUTORIAL   IDS_HELP_OF(DVIDM_HELPTUTORIAL   )
#define IDS_HELP_HELPMSWEB      IDS_HELP_OF(DVIDM_HELPMSWEB      )
#ifndef POSTPOSTSPLIT
#define IDS_HELP_COPYTO         IDS_HELP_OF(DVIDM_COPYTO         )
#define IDS_HELP_MOVETO         IDS_HELP_OF(DVIDM_MOVETO         )
#endif

#define IDS_HELP_NEW            IDS_HELP_OF(DVIDM_NEW            )
#define IDS_HELP_NEWPOST        IDS_HELP_OF(DVIDM_NEWPOST        )
#define IDS_HELP_NEWAPPOINTMENT IDS_HELP_OF(DVIDM_NEWAPPOINTMENT )
#define IDS_HELP_NEWMEETING     IDS_HELP_OF(DVIDM_NEWMEETING     )
#define IDS_HELP_NEWCONTACT     IDS_HELP_OF(DVIDM_NEWCONTACT     )
#define IDS_HELP_NEWTASK        IDS_HELP_OF(DVIDM_NEWTASK        )
#define IDS_HELP_NEWTASKREQUEST IDS_HELP_OF(DVIDM_NEWTASKREQUEST )
#define IDS_HELP_NEWJOURNAL     IDS_HELP_OF(DVIDM_NEWJOURNAL     )
#define IDS_HELP_NEWNOTE        IDS_HELP_OF(DVIDM_NEWNOTE        )
#define IDS_HELP_CALL           IDS_HELP_OF(DVIDM_CALL           )

#define IDS_HELP_SENDTO         IDS_HELP_OF(DVIDM_SENDTO         )
#define IDS_HELP_SENDTOFIRST    IDS_HELP_OF(DVIDM_SENDTOFIRST    )


SHDOCAPI CShellUIHelper_CreateInstance2(IUnknown** ppunk, REFIID riid, 
                                      IUnknown *pSite, IDispatch *pExternalDisp);
SHDOCAPI_(IStream*) SHGetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pszName, LPCWSTR pszStreamMRU, LPCWSTR pszStreams);


// these two MUST be in order because we peek them together
#define WMC_PRIVATE_BASE        (WM_USER + 0x0300)
#define WMC_RESERVED_FIRST      (WMC_PRIVATE_BASE + 0x0000)
#define WMC_RESERVED_LAST       (WMC_PRIVATE_BASE + 0x0002)
#define WMC_FAV_CHANGE          (WMC_PRIVATE_BASE + 0x0003)
#define WMC_REMOTENAV           (WMC_PRIVATE_BASE + 0x0004)
#define WMC_DISPATCH            (WMC_PRIVATE_BASE + 0x0005)
#ifndef POSTPOSTSPLIT
#define WMC_GETTHISPTR          (WMC_PRIVATE_BASE + 0x0006)
#endif
#define WMC_ACTIVATE            (WMC_PRIVATE_BASE + 0x0007)
#define WMC_MARSHALIDISPATCH    (WMC_PRIVATE_BASE + 0x0008)
#define WMC_MARSHALIDISPATCHSLOW (WMC_PRIVATE_BASE + 0x0009)
#define WMC_ONREFRESHTIMER       (WMC_PRIVATE_BASE + 0x000A)
#define WMC_DELAYEDDDEEXEC       (WMC_PRIVATE_BASE + 0x000B)

// WMC_DISPATCH #defines
#define DSID_NAVIGATEIEBROWSER  1
#define DSID_GETLOCATIONURL     2
#define DSID_GETLOCATIONTITLE   3
#define DSID_GETHWND            4
#define DSID_CANCEL             5
#define DSID_EXIT               6
#define DSID_NOACTION           7

//Functions exported by shdocvw and used by browseui
SHDOCAPI_(BOOL) IsIEDefaultBrowser(void);
SHDOCAPI_(void) _DeletePidlDPA(HDPA hdpa);
SHDOCAPI IURLQualify(LPCWSTR pcszURL, DWORD  dwFlags,LPWSTR  pszTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);

SHDOCAPI_(BOOL) ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
#ifdef UNICODE
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceW 
#else
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceA 
#endif


//
// Packages both the url and transaction id into one parameter
// to pass as a message.
//
typedef struct tagDDENAVIGATESTRUCT
{
    LPWSTR wszUrl;
    long transID;
} DDENAVIGATESTRUCT;

SHDOCAPI WinList_NotifyNewLocation(IShellWindows* psw, long dwRegister, LPCITEMIDLIST pidl);
SHDOCAPI WinList_FindFolderWindow(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, HWND *phwnd, IWebBrowserApp** ppauto);
SHDOCAPI_(IShellWindows*) WinList_GetShellWindows(BOOL fForceNew);
SHDOCAPI WinList_RegisterPending(DWORD dwThread, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlRoot, long *pdwRegister);
SHDOCAPI WinList_Revoke(long dwRegister);
SHDOCAPI WinList_OnActivate(IShellWindows* psw, long dwRegister, BOOL fActivate, LPCITEMIDLIST pidl);
SHDOCAPI_(BOOL) WinList_Init(void);
SHDOCAPI_(void) WinList_Terminate(void);

SHDOCAPI SHMapNbspToSp(LPCWSTR lpwszIn, LPSTR lpszOut, int cbszOut);

SHDOCAPI_(BOOL) SHIsGlobalOffline(void);
SHDOCAPI_(DWORD) SHRestricted2A(BROWSER_RESTRICTIONS rest, LPCSTR pszUrl, DWORD dwReserved);
SHDOCAPI_(DWORD) SHRestricted2W(BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
#ifndef _SHELL32_   // shell32 has its own implementation of this function
SHDOCAPI_(BOOL) SHIsRestricted(HWND hwnd, RESTRICTIONS rest);
#endif // _SHELL32_
SHDOCAPI_(BOOL) SHIsRestricted2W(HWND hwnd, BROWSER_RESTRICTIONS rest, LPCWSTR pwzUrl, DWORD dwReserved);
SHDOCAPI_(void)    DetectAndFixAssociations();
SHDOCAPI_(void)    EnsureWebViewRegSettings();

#ifdef UNICODE
#define UrlHitsNet UrlHitsNetW
#endif

SHDOCAPI_(BOOL) UrlHitsNetW(LPCWSTR pszURL);
#ifdef UNICODE
#define SHRestricted2     SHRestricted2W
#else // UNICODE
#define SHRestricted2     SHRestricted2A
#endif // UNICODE


/// event firing helper functions
//
// FireEvent_XXX functions do a bunch of the work of firing an event.
// punk points to the object that contains the connection point
// that you want to fire the event from. The hwnd parameter is for DDE.
//


SHDOCAPI_(void) FireEvent_BeforeNavigate(IUnknown* punk, HWND hwnd, IWebBrowser2* pwb2,
        LPCITEMIDLIST pidl,LPCWSTR pwzLocation,
        DWORD dwFlags,LPCWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPCWSTR pszHeaders,BOOL * pfCancel);

SHDOCAPI_(void) FireEvent_NavigateError(IUnknown     * punk, 
                                        IWebBrowser2 * pwb2,
                                        LPCITEMIDLIST  pidl,
                                        BSTR           bstrTargetFrameName,
                                        DWORD          dwStatusCode,
                                        BOOL         * pfCancel);

SHDOCAPI_(void) FireEvent_NewWindow(IUnknown* punk, HWND hwnd,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPWSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPWSTR pszHeaders,BOOL * pfProcessed);

SHDOCAPI_(void) FireEvent_NewWindow2(IUnknown* punk, IUnknown ** ppunkNewWindow, BOOL* pfCancel);
SHDOCAPI_(void) FireEvent_NavigateComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl, HWND hwnd);
SHDOCAPI_(void) FireEvent_DocumentComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl);
SHDOCAPI_(void) FireEvent_PrintTemplateEvent(IUnknown* punk, IWebBrowser2* pwb2, DISPID dispidPrintEvent);
SHDOCAPI_(void) FireEvent_UpdatePageStatus(IUnknown* punk, IWebBrowser2* pwb2, DWORD nPage, BOOL fDone);
SHDOCAPI_(void) FireEvent_PrivacyImpactedStateChange(IUnknown* punk, BOOL);
SHDOCAPI_(void) FireEvent_DoInvokeString(IExpDispSupport* peds, DISPID dispid, LPSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeStringW(IExpDispSupport* peds, DISPID dispid, LPWSTR psz);
SHDOCAPI_(void) FireEvent_DoInvokeDispid(IUnknown* punk, DISPID dispid);
SHDOCAPI_(void) FireEvent_DoInvokeDwords(IExpDispSupport* peds, DISPID dispid,DWORD dw1,DWORD dw2);
SHDOCAPI_(void) FireEvent_DoInvokeBstr(IUnknown* punk, DISPID dispid, BSTR bstr);
SHDOCAPI_(void) FireEvent_Quit(IExpDispSupport* peds);
SHDOCAPI_(void) FireEvent_OnAdornment(IUnknown* punk, DISPID dispid, VARIANT_BOOL f);
SHDOCAPI_(void) FireEvent_FileDownload(IUnknown * punk, BOOL * pfCancel, VARIANT_BOOL bDocObject);


#define IDP_START       0
#define IDP_SEARCH      1
#define IDP_UPDATE      2
#define IDP_CHANNELGUIDE  3
SHDOCAPI SHDGetPageLocation(HWND hwndOwner, UINT idp, LPWSTR pszPath, UINT cchMax, LPITEMIDLIST *ppidlOut);

SHDOCAPI SHGetHistoryPIDL(LPITEMIDLIST *ppidlHistory);
SHDOCAPI_(UINT) SHIEErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCWSTR pszURLparam,
                    UINT idResource, UINT wFlags);

// pszClient values:
#define MAIL_DEF_KEY            L"Mail"
#define NEWS_DEF_KEY            L"News"
#define CONTACTS_DEF_KEY        L"Contacts"
#define CALENDAR_DEF_KEY        L"Calendar"
#define TASKS_DEF_KEY           L"Task"
#define JOURNAL_DEF_KEY         L"Journal"
#define NOTES_DEF_KEY           L"Note"
#define CALL_DEF_KEY            L"Internet Call"

SHDOCAPI_(BOOL) SHIsRegisteredClient(LPCWSTR pszClient);

// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI NavToUrlUsingIEW(LPCWSTR wszUrl, BOOL fNewWindow);
SHDOCAPI NavToUrlUsingIEA(LPCSTR szUrl, BOOL fNewWindow);
#ifdef UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEW
#else // UNICODE
#define NavToUrlUsingIE     NavToUrlUsingIEA
#endif // UNICODE

/// shared icons that browseUI grabs from shdocvw.
// we leave them in shdocvw instead of moving them for back compat.
// folks may have relied upon the icons in the dll for their shortcuts.
// (do we care?)
#define IDI_OFFLINE                     105   //          5
#define IDI_STATE_NORMAL                110
#define ICO_TREEUP                      204
#define ICO_GLEAM                       205



// stopgap export for shell32\unicpp\dcomp.cpp
SHDOCAPI UseDefaultAutoComplete(HWND hwndEdit,
                               IBrowserService * pbs,          IN  OPTIONAL
                               IAutoComplete ** ppac,          OUT OPTIONAL
                               IShellService ** ppssACLISF,    OUT OPTIONAL
                               BOOL fUseCMDMRU);

// stopgap export for shell32\unicpp\dcomp.cpp, deskstat.cpp


#define JITCOCREATEINSTANCE_ORD 209
SHDOCAPI JITCoCreateInstance(
    REFCLSID rclsid, 
    IUnknown *pUnkOuter,
    DWORD dwClsContext, 
    REFIID riid, 
    LPVOID FAR* ppv,
    HWND hwndParent,
    DWORD dwJitFlags
);


SHDOCAPI_(void) TLTransferToThreadMemlist(struct ITravelLog *, DWORD);

SHDOCAPI_(BOOL) DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir);
SHDOCAPI_(BOOL) DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir);

#define NAVCANCELLED_URL                 TEXT("about:NavigationCanceled")
#define OFFLINEINFO_URL                  TEXT("about:OfflineInformation")
#define FOLDERBROWSINGINFO_URL           TEXT("about:FolderBrowsing")

#define SEARCH_SETTINGS_CHANGEDW         L"SearchSettingsChanged"
#define SEARCH_SETTINGS_CHANGEDA         "SearchSettingsChanged"

#ifdef UNICODE
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDW
#else
#define SEARCH_SETTINGS_CHANGED          SEARCH_SETTINGS_CHANGEDA
#endif

SHDOCAPI_(VARIANT_BOOL) UseCustomInternetSearch();
SHDOCAPI_(BOOL) GetSearchAssistantUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlW(LPWSTR pwszUrl, int cchUrl, BOOL bSubstitute);
SHDOCAPI_(BOOL) GetSearchAssistantUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute, BOOL bCustomize);
SHDOCAPI_(BOOL) GetDefaultInternetSearchUrlA(LPSTR pszUrl, int cchUrl, BOOL bSubstitute);

#ifdef UNICODE
#define GetSearchAssistantUrl GetSearchAssistantUrlW
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlW
#else
#define GetSearchAssistantUrl GetSearchAssistantUrlA
#define GetDefaultInternetSearchUrl GetDefaultInternetSearchUrlA
#endif

typedef enum
{
    ILS_ADDTOFAV = 0,
    ILS_LINK     = 1,
    ILS_HOME     = 2,
    ILS_NAVIGATE = 3,
}ILS_ACTION;

SHDOCAPI_(BOOL) IEIsLinkSafe(HWND hwnd, LPCITEMIDLIST pidl, ILS_ACTION ilsFlag);
SHDOCAPI_(BOOL) SHUseClassicToolbarGlyphs (void);
SHDOCAPI_(BOOL) SafeOpenPromptForShellExec(HWND hwnd, PCWSTR pszFile);
#endif // _SHDOCVW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_NetworkRoot,          0x953d732d, 0xab45, 0x11d2, 0x84, 0xe0, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);// {953D732D-AB45-11d2-84E0-00C04FA31A86}

DEFINE_GUID(GUID_SystemPidlChange,      0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D

DEFINE_GUID(CLSID_ShellCopyHook,        0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,      0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,       0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit,  0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,            0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
DEFINE_GUID(CLSID_BriefcaseFolder,      0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
DEFINE_GUID(CLSID_ExeDropTarget,        0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops


DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
DEFINE_GUID(CLSID_CFonts,               0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
DEFINE_GUID(CLSID_CmdFileIcon,          0x57651662, 0xCE3E, 0x11D0, 0x8D,0x77,0x00,0xC0,0x4F,0xC9,0x9D,0x61);//57651662-CE3E-11D0-8D77-00C04FC99D61

DEFINE_GUID(CLSID_CSiteMapEmbedding,    0x438C0EA0, 0x5731, 0x11CF, 0x9A,0xF8,0x00,0x20,0xAF,0x73,0xAD,0x51);
DEFINE_GUID(CLSID_CSiteMapNode,         0xA61D5780, 0xBA29, 0x11CF, 0x95,0x2E,0x00,0xC0,0x4F,0xD7,0x05,0xB4);// A61D5780-BA29-11CF-952E-00C04FD705B4

DEFINE_GUID(IID_IDefViewBrowser,        0x9692C5C0, 0x7C21, 0x11CF, 0x95, 0x34, 0x00, 0x00, 0xC0, 0x5B, 0xAE, 0x0B);

DEFINE_GUID(CLSID_CShellHlinkFrame,     0x2C5A8FC0, 0x8401, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);// 2C5A8FC0-8401-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellFrameAuto,      0x20C46560, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);// 20C46560-8491-11CF-960C-0080C7F4EE85

// {E770AD23-7346-11d1-8AEE-00C04FC9E26E}
DEFINE_GUID(IID_IWebViewOCWinMan, 0xe770ad23, 0x7346, 0x11d1, 0x8a, 0xee, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

#if 0
// The old IMRU interface used by IE4.  This interface was not accessible
// to outside components, so I'm #if'ing it out completely, but I left it
// in the header so at least we'll recognize it if we see it again.
// {D095EB91-A7B2-11d0-8274-00AA005B4383}
DEFINE_GUID(IID_IMRU_IE4,               0xd095eb91, 0xa7b2, 0x11d0, 0x82, 0x74, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
#endif



// This is Semi-gross, but if the IShellFolder can be agregated, there are times we need to get
// back to the real inner class.  So we create an internal GUID which we use to QueryInterface for
// which hopefully the outer object will allow through...
// ABCB3A00-1B2B-11CF-A49F-444553540000
DEFINE_GUID(IID_INeedRealCFSFolder,     0xABCB3A00, 0x1B2B, 0x11CF, 0xA4, 0x9F, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);


//
// this interface is used by DefView when it wants to run a script in one
// of its extended views.  the actual script triggers currently live in shdisp
//
// 4706B500-09EF-11D0-99CB-00C04FD64497
DEFINE_GUID(IID_IDefViewScript,         0x4706B500L, 0x09EF, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);


DEFINE_GUID(IID_IObjectCache,           0xEA5F2D60L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);   // ;internal

DEFINE_GUID(SID_SDesktopExtMenu,        0x6F272F90L, 0x2380, 0x11D0, 0x89, 0xB9, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

DEFINE_GUID(IID_IDelegateDropTargetCB,  0xbefd347e, 0xc7ec, 0x11d0, 0xb9, 0x3b, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);


// The thumbnail view extension
// {8BEBB290-52D0-11d0-B7F4-00C04FD706EC}
DEFINE_GUID(CLSID_ThumbnailViewExt,     0x8bebb290, 0x52d0, 0x11d0, 0xb7, 0xf4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// The Favorites Shell extension
// for 1A9BA3A0-143A-11CF-8350-444553540000
DEFINE_GUID(CLSID_FavoritesFolder,      0x1A9BA3A0, 0x143A, 0x11CF, 0x83, 0x50, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 );

// the Task band (for the tray).
// n.b. while we have a CLSID, we can't actually CoCreateInst it
// we fake it in tray's IBandSiteHelper implementation.
// {68284FAA-6A48-11d0-8C78-00C04FD918B4}
DEFINE_GUID(CLSID_TaskBand,             0x68284faa, 0x6a48, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

// MIME-enabled File Types Hook for browser-only installs
DEFINE_GUID(CLSID_MIMEFileTypesHook,    0xFBF23B41L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

//  Cache Shellfolder Item private interface
DEFINE_GUID (IID_IHistCache,            0xF7FE8CA0L, 0xEC5A, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

//3531F060-22B3-11D0-969E-00AA00B60104

// {FFB4B000-9FAB-11d0-A3A4-00C04FD706EC}
DEFINE_GUID(VID_DefaultCustomWebView, 0xffb4b000, 0x9fab, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

//FB4A79C0-C808-11D0-8D57-00C04FC99D61
DEFINE_GUID(CGID_MenuISF, 0xFB4A79C0L, 0xC808, 0x11D0, 0x8D, 0x57, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {89820200-ECBD-11cf-8B85-00AA005B4383}
DEFINE_GUID(COMPID_IE4, 0x89820200, 0xecbd, 0x11cf, 0x8B, 0x85, 0x00, 0xAA, 0x00, 0x5B, 0x43, 0x83 );

// {4622AD10-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_ITrayPriv,0x4622ad10, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Whistler
// {9e83c057-6823-4f1f-bfa3-7461d40a8173}
DEFINE_GUID(IID_ITrayPriv2,0x9e83c057, 0x6823, 0x4f1f, 0xbf, 0xa3, 0x74, 0x61, 0xd4, 0x0a, 0x81, 0x73);

// {4622AD11-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(CLSID_StartMenu,0x4622ad11, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);
#define CLSID_StartMenuBar CLSID_StartMenu 

// Whistler
// {3f6953f0-5359-47fc-bd99-9f2cb95a62fd}
DEFINE_GUID(CLSID_PersonalStartMenu, 0x3f6953f0, 0x5359, 0x47fc, 0xbd, 0x99, 0x9f, 0x2c, 0xb9, 0x5a, 0x62, 0xfd);


// {733AC4CB-F1A4-11d0-B951-00A0C90312E1}
DEFINE_GUID(CLSID_CWebViewMimeFilter, 0x733ac4cb, 0xf1a4, 0x11d0, 0xb9, 0x51, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Disk cleaner for the recycle bin
/* 5ef4af3a-f726-11d0-b8a2-00c04fc309a4 */
DEFINE_GUID(CLSID_RecycleBinCleaner,  0x5ef4af3a, 0xf726, 0x11d0, 0xb8, 0xa2, 0x00, 0xc0, 0x4f, 0xc3, 0x09, 0xa4 );

// {1820FED0-473E-11D0-A96C-00C04FD705A2}
// WARNING: CLSID_CDefViewOC is also stored in shell\shdocvw\selfreg.inx and shell\ext\shwizard\finisha.cpp
//          and D:\nt\private\shell\ext\html\construc\*.htt
DEFINE_GUID(CLSID_CDefViewOC, 0x1820FED0, 0x473E, 0x11D0, 0xA9, 0x6C, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

// {1430A130-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(SID_SBandHandler, 0x1430a130, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {21090CB1-103F-11d1-8D45-00A0C90F2719}
DEFINE_GUID(CGID_BandHandler, 0x21090cb1, 0x103f, 0x11d1, 0x8d, 0x45, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {2E420C00-1361-11d1-8D49-00A0C90F2719}
DEFINE_GUID(CGID_Persist, 0x2e420c00, 0x1361, 0x11d1, 0x8d, 0x49, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {DDB008FE-048D-11d1-B9CD-00C04FC2C1D2}
DEFINE_GUID(CLSID_StartMenuTask,    0xddb008fe, 0x48d, 0x11d1, 0xb9, 0xcd, 0x0, 0xc0, 0x4f, 0xc2, 0xc1, 0xd2);

// {E7D3DB4E-199C-11d1-9828-00C04FD91972}
DEFINE_GUID(CLSID_DesktopTask,      0xe7d3db4e, 0x199c, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {80D4A420-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IShellFolderTask,   0x80d4a420, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {80D4A41F-3167-11d2-BE3C-3078302C2030}
DEFINE_GUID(IID_IStartMenuTask,     0x80d4a41f, 0x3167, 0x11d2, 0xbe, 0x3c, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {5EA35BC9-19B1-11d1-9828-00C04FD91972}
DEFINE_GUID(IID_IShellHotKey,       0x5ea35bc9, 0x19b1, 0x11d1, 0x98, 0x28, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {5c191fec-2d33-11d1-bd7e-0000f8753a75}
DEFINE_GUID(CGID_MenuBandItem,      0x5c191fec, 0x2d33, 0x11d1, 0xbd, 0x7e, 0x0, 0x00, 0xf8, 0x75, 0x3a, 0x75);

// {0563BC42-4418-11d1-8CB4-00C04FD918D0}
DEFINE_GUID(CGID_MenuBandRestriction, 0x563bc42, 0x4418, 0x11d1, 0x8c, 0xb4, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);
#define SID_SMenuBandRestriction CGID_MenuBandRestriction

// {B49C1CD0-5256-11d1-8CBB-00C04FD918D0}
DEFINE_GUID(NSID_Menu,             0xb49c1cd0, 0x5256, 0x11d1, 0x8c, 0xbb, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {CE422100-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(CLSID_ShellMallocSpy,   0xce422100, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// {CE422101-6CE1-11d1-838D-0000F80461CF}
DEFINE_GUID(IID_IShellMallocSpy,    0xce422101, 0x6ce1, 0x11d1, 0x83, 0x8d, 0x0, 0x0, 0xf8, 0x4, 0x61, 0xcf);

// Defview background task IDs
// {956B35B8-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVIconExtract,    0x956b35b8, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {76119F10-B9E3-11D1-A7F4-006008059382}
DEFINE_GUID(TOID_DVIconOverlay, 0x76119F10L, 0xB9E3, 0x11D1, 0xA7, 0xF4, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

// {956B35B9-6DCB-11d1-AD2F-00C04FB687DA}
DEFINE_GUID(TOID_DVBackgroundEnum, 0x956b35b9, 0x6dcb, 0x11d1, 0xad, 0x2f, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

// {77EDBB11-5E1B-41ed-B82E-A6211B0795DF}
DEFINE_GUID(TOID_DVBackgroundGroup, 0x77edbb11, 0x5e1b, 0x41ed, 0xb8, 0x2e, 0xa6, 0x21, 0x1b, 0x7, 0x95, 0xdf);

// {D6536934-9891-49a8-A137-B97FD8EDE243}
DEFINE_GUID(TOID_DVBackgroundStatusBar, 0xd6536934, 0x9891, 0x49a8, 0xa1, 0x37, 0xb9, 0x7f, 0xd8, 0xed, 0xe2, 0x43);

// {6FD71035-7E55-4aea-BBDE-C210FEF0301B}
DEFINE_GUID(TOID_DVBackgroundInfoTip, 0x6fd71035, 0x7e55, 0x4aea, 0xbb, 0xde, 0xc2, 0x10, 0xfe, 0xf0, 0x30, 0x1b);

// {A13E74D9-8A25-4b6e-AB43-0A6058AF18C5}
DEFINE_GUID(TOID_DVBackgroundDetailsSectionInfo, 0xa13e74d9, 0x8a25, 0x4b6e, 0xab, 0x43, 0xa, 0x60, 0x58, 0xaf, 0x18, 0xc5);

// {FCC504B5-92EC-4a72-B88E-358D72689233}
DEFINE_GUID(TOID_DVFileTypeProperties, 0xfcc504b5, 0x92ec, 0x4a72, 0xb8, 0x8e, 0x35, 0x8d, 0x72, 0x68, 0x92, 0x33);

// {F35C5BFB-C46F-4c35-ABE1-3605E9352152}
DEFINE_GUID(TOID_DVGetCommandState, 0xf35c5bfb, 0xc46f, 0x4c35, 0xab, 0xe1, 0x36, 0x5, 0xe9, 0x35, 0x21, 0x52);



// Offline Files property sheet extension.  Implemented in cscui.dll.
// {10CFC467-4392-11d2-8DB4-00C04FA31A66}
DEFINE_GUID(CLSID_OfflineFilesOptions, 0x10cfc467, 0x4392, 0x11d2, 0x8d, 0xb4, 0x0, 0xc0, 0x4f, 0xa3, 0x1a, 0x66);

// {169A0694-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(IID_ISearchProvider,   0x169a0694, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);


// 96a23e16-a1bc-11d1-b084-00c04fc33aa5
DEFINE_GUID(IID_ILVRange,          0x96a23e16L, 0xa1bc, 0x11d1, 0xb0, 0x84, 0x00, 0xc0, 0x4f, 0xc3, 0x3a, 0xa5);

// CLSID whose sole purpose is to let us locate BROWSEUI, wherever it happens to be installed
// ef8ad2d0-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_BROWSEUI,        0xef8ad2d0L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {09799AFB-AD67-11d1-ABCD-00C04FC30936}
DEFINE_GUID(CLSID_OpenWithMenu, 0x9799afb, 0xad67, 0x11d1, 0xab, 0xcd, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {7febaf7c-18cf-11d2-993f-00a0c91f3880}
DEFINE_GUID(CLSID_DefViewPersistHistory, 0x7febaf7c, 0x18cf, 0x11d2, 0x99, 0x3f, 0x00, 0xa0, 0xc9, 0x1f, 0x38, 0x80);

// {bab33640-1280-11d2-aa30-00a0c91eedba}
DEFINE_GUID(CLSID_DocFindPersistHistory, 0xbab33640, 0x1280, 0x11d2, 0xaa, 0x30, 0x00, 0xa0, 0xc9, 0x1e, 0xed, 0xba);

// {5CFCC662-1767-11d2-A222-0000F81FEDEE}
DEFINE_GUID(IID_IFolderShortcutConvert, 0x5cfcc662, 0x1767, 0x11d2, 0xa2, 0x22, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee);


// {C0C66348-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_FolderShortcutToShortcut, 0xc0c66348, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {C8B35474-C440-11d2-9F03-006097C686F6}
DEFINE_GUID(CLSID_ShortcutToFolderShortcut, 0xc8b35474, 0xc440, 0x11d2, 0x9f, 0x3, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

// {BDEADF00-C265-11d0-BCED-00A0C90AB50F}	IID_WebFolders
DEFINE_GUID(CLSID_WebFolders, 0xBDEADF00, 0xC265, 0x11d0, 0xbc, 0xed, 0x0, 0xa0, 0xc9, 0xa, 0xb5, 0x0f);

// map old names to nice names
#define CLSID_CControls         CLSID_ControlPanel
#define CLSID_ShellBitBucket    CLSID_RecycleBin
#define CLSID_ShellDrives       CLSID_MyComputer
#define CLSID_CPrinters         CLSID_Printers
#define CLSID_ShellNetwork      CLSID_NetworkPlaces
#define CLSID_ShellInetRoot     CLSID_Internet

#define CLSID_ShellNetworkDomain    CLSID_NetworkDomain
#define CLSID_ShellNetworkServer    CLSID_NetworkServer
#define CLSID_ShellNetworkShare     CLSID_NetworkShare

// {3F454F0E-42AE-4D7C-8EA3-328250D6E272}
DEFINE_GUID(CLSID_AutomationCM, 0x3f454f0e, 0x42ae, 0x4d7c, 0x8e, 0xa3, 0x32, 0x82, 0x50, 0xd6, 0xe2, 0x72 );

// B347B4F1-112D-4C31-A69F-F68B34A4F72E
DEFINE_GUID(CLSID_WebViewPluggableProtocol, 0xB347B4F1L, 0x112D, 0x4C31, 0xA6, 0x9F, 0xF6, 0x8B, 0x34, 0xA4, 0xF7, 0x2E);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shsemip.h ===
//***************************************************************************
//  --- SHELLAPI.W SHSEMIP.H SHLOBJ.W SHOBJIDL.IDL SHLDISP.IDL SHPRIV.IDL ---
//                Which header is best for my new API?
//
//  SHSEMIP     - *AVOID _ALL_ USAGE*, NO EXPORTS, SUPER PRIVATE
//              used for very private shell defines.
//
//  SHELLAPI    - ALL NEW SHELL32 EXPORTS public and private
//              used for both public and private exports from shell32
//
//  SHLOBJ      - *AVOID NEW USAGE*, PREFER OTHER HEADERS
//              used primarily for legacy compatibility
//
//  SHOBJIDL    - ALL NEW SHELL PUBLIC INTERFACES
//              primary file for public shell (shell32+) interfaces
//
//  SHLDISP     - ALL NEW SHELL AUTOMATION INTERFACES
//              automation interfaces are always public
//
//  SHPRIV      - ALL NEW SHELL PRIVATE INTERFACES
//              private interfaces used anywhere in the shell
//
//***************************************************************************

#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED

typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;

#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif

#endif // LPNTSTR_DEFINED

#ifndef DONT_WANT_SHELLDEBUG

#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif



//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef NOPRAGMAS
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#ifndef UNIX
#define MAXPATHLEN      MAX_PATH        // ;Internal
#endif

#ifdef UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##A
#else // !UNICODE
#define OTHER_TCHAR_NAME(sz)      sz##W
#endif

//===========================================================================
// ITEMIDLIST
//===========================================================================

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)


//===================================================================
// Smart tiling API's
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND *ahwnd);


/* Avoid multiple typedefs C warnings. Defined in shlapip.h as well. */
#ifndef RUNDLLPROC

typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
typedef void (WINAPI * RUNDLLPROCW)(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif
#endif

// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define MAX_PATH_URL    INTERNET_MAX_URL_LENGTH
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifndef SIZEOF
#define SIZEOF(a)       sizeof(a)
#endif

#define PathRemoveBlanksORD     33
#define PathFindFileNameORD     34
#define PathFindExtensionORD    31

#ifdef OVERRIDE_SHLWAPI_PATH_FUNCTIONS
// SHLWAPI provides the majority of the Path functions.  There are
// some cases where the shell code (shell32 and explorer) need to
// call a different variation of these calls.  Because of this, we
// have OVERRIDE_SHLWAPI_PATH_FUNCTIONS.  Components such as shdocvw
// should strive to *not* have this defined.
//
// Some reasons why something like shell32 would need this:
//   1)  Shell32 calls some WNet APIs due to the NT merge.  Shlwapi
//       cannot take these.
//   2)  Shell32 needs the unaligned version PathBuildRoot,
//       PathCombine, etc.
//

#undef PathIsDirectory
#undef PathMakePretty

WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCTSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMakePretty(LPTSTR lpszPath);

#endif // OVERRIDE_SHLWAPI_PATH_FUNCTIONS


WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI LogoffWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI DisconnectWindowsDialog(HWND hwnd);
WINSHELLAPI BOOL  WINAPI IsSuspendAllowed(void);

WINSHELLAPI void WINAPI SHRefreshSettings(void);



EXTERN_C WINSHELLAPI HRESULT STDAPICALLTYPE SHCopyMonikerToTemp(IMoniker *pmk, LPCWSTR pszIn, LPWSTR pszOut, int cchOut);

WINSHELLAPI BOOL WINAPI IsVolumeNTFS(LPCTSTR pszRootPath);

#ifdef WINNT
WINSHELLAPI LPWSTR WINAPI GetDownlevelCopyDataLossText(LPCWSTR pszSrcFile, LPCWSTR pszDestDir, BOOL bIsADir, BOOL * pbLossPossibleThisDir);
#endif

//-------- file engine stuff ----------

// "current directory" management routines.  used to set parameters
// that paths are qualfied against in MoveCopyDeleteRename()

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCTSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);
//
// NOTES: No reason to have this one here, but I don't want to break the build.
//
#ifndef WINCOMMCTRLAPI
int WINAPI StrToInt(LPCTSTR lpSrc);  // atoi()
#endif

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

/* timedate.c */

// **********************************************************************
//  DATE is a structure with a date packed into a WORD size value. It
//  is compatible with a file date in a directory entry structure.
// **********************************************************************

#ifndef DATE_DEFINED
typedef struct
{
    WORD    Day     :5; // Day number 1 - 31
    WORD    Month   :4; // Month number 1 - 12
    WORD    Year    :7; // Year subtracted from 1980, 0-127
} WORD_DATE;

typedef union
{
    WORD            wDate;
    WORD_DATE       sDate;
} WDATE;

#define DATE_DEFINED
#endif

// **********************************************************************
//  TIME is a structure with a 24 hour time packed into a WORD size value.
//  It is compatible with a file time in a directory entry structure.
// **********************************************************************

#ifndef TIME_DEFINED

typedef struct
{
        WORD    Sec     :5;     // Seconds divided by 2 (0 - 29).
        WORD    Min     :6;     // Minutes 0 - 59
        WORD    Hour    :5;     // Hours 0 - 24
} WORD_TIME;

typedef union
{
        WORD        wTime;
        WORD_TIME   sTime;
} WTIME;

#define TIME_DEFINED
#endif

WINSHELLAPI WORD WINAPI Shell_GetCurrentDate(void);
WINSHELLAPI WORD WINAPI Shell_GetCurrentTime(void);

//====== SEMI-PRIVATE API ===============================
#ifndef HPSXA_DEFINED
#define HPSXA_DEFINED
DECLARE_HANDLE( HPSXA );
#endif // HPSXA_DEFINED

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHObjectPropertiesORD                   178
#define SHCreateDefClassObjectORD                70
#define SHGetNetResourceORD                      69

#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#ifndef NOPRAGMAS
#pragma pack()
#endif /* NOPRAGMAS */
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shstyle.h ===
//
// Resource id header file for shellstyle.dll
//

#ifndef _SHSTYLE_H_
#define _SHSTYLE_H_

#define IDR_DUI_STYLESHEET            1
#define IDR_DUI_CPSTYLE               2


#define IDB_MUSIC_ICON_BMP            10
#define IDB_MUSIC_TASKS_BMP           11
#define IDB_MUSIC_LISTVIEW_BMP        12
#define IDB_PICTURES_ICON_BMP         13
#define IDB_PICTURES_TASKS_BMP        14
#define IDB_PICTURES_LISTVIEW_BMP     15
#define IDB_SEARCH_ICON_BMP           16
#define IDB_SEARCH_TASKS_BMP          17
#define IDB_SEARCH_LISTVIEW_BMP       18
#define IDB_VIDEO_ICON_BMP            19
#define IDB_VIDEO_TASKS_BMP           20
#define IDB_VIDEO_LISTVIEW_BMP        21
#define IDB_CPANEL_ICON_BMP           22


#define IDB_BLOCKADE_WATERMARK        25
#define IDB_CPANEL_WATERMARK          26


#define IDS_PREVIEW_BACKGROUND_COLOR  100

#endif //_SHSTYLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\startids.h ===
#ifndef _STARTIDS_H
#define _STARTIDS_H

#define IDM_FILERUN                 401
#define IDM_LOGOFF                  402
#define IDM_EJECTPC                 410
#define IDM_SETTINGSASSIST          411
#define IDM_TRAYPROPERTIES          413
#define IDM_UPDATEWIZARD            414
#define IDM_UPDATE_SEP              415

#ifdef WINNT // hydra specific ids
#define IDM_MU_DISCONNECT           5000
#define IDM_MU_SECURITY             5001
#endif

#define IDM_RECENT              501
#define IDM_FIND                502
#define IDM_HELPSEARCH          503
#define IDM_PROGRAMS            504
#define IDM_CONTROLS            505
#define IDM_EXITWIN             506
#define IDM_SETTINGS            508
#define IDM_PRINTERS            510
#define IDM_STARTMENU           511
#define IDM_MYCOMPUTER          512
#define IDM_PROGRAMSINIT        513
#define IDM_RECENTINIT          514
#define IDM_MYDOCUMENTS         516
#define IDM_MENU_FIND           520
#define TRAY_IDM_FINDFIRST      521  // this range
#define TRAY_IDM_FINDLAST       550  // is reserved for find command
#define IDM_NETCONNECT          557


// Orphans from IE401....
#ifdef FEATURE_BROWSEWEB
#define IDM_MENU_WEB            551
#endif

#define IDM_DESKTOPHTML_CUSTOMIZE   552
#define IDM_DESKTOPHTML_UPDATE      553
#define IDM_DESKTOPHTML_ONOFF       554
#define IDM_FOLDERPROPERTIES        555
#define IDM_ACTIVEDESKTOP_PROP      556
#define IDM_FAVORITES               507
#define IDM_SUSPEND                 409

#define IDM_CSC                 553

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shstr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name: Shell String Class

    shstr.h

Author:

    Zeke Lucas (zekel)  27-Oct-96

Environment:

    User Mode - Win32

Revision History:


Abstract:

    this allows automatic resizing and stuff

    NOTE: this class is specifically designed to be used as a stack variable


--*/

#ifndef _SHSTR_H_

//  default shstr to something small, so we don't waste too much stack space
//  MAX_PATH is used frequently, so we'd like to a factor of that - so that
//  if we do grow to MAX_PATH size, we don't waste any extra.
#define DEFAULT_SHSTR_LENGTH    (MAX_PATH/4)


#ifdef UNICODE
#define ShStr ShStrW
#define UrlStr UrlStrW
#else
#define ShStr ShStrA
#define UrlStr UrlStrA
#endif //UNICODE

class ShStrA
{
public:

    //
    //  Constructors
    //
    ShStrA();

    //
    //  Destructor
    //
    ~ShStrA()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrA &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrA& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrA& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrA& operator=(ShStrA &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPCSTR GetStr()
        {return _pszStr;}
    operator LPCSTR()
        {return _pszStr;}

    LPSTR GetInplaceStr(void)
        {return _pszStr;}

    // People want to play with the bytes in OUR internal buffer.  If they
    // call us correctly, and assume that the resulting pointer is only valid
    // as far as they want or as far as the current length, then let them.
    LPSTR GetModifyableStr(DWORD cchSizeToModify)
        {
         if (cchSizeToModify > _cchSize)
            if (FAILED(SetSize(cchSizeToModify)))
                return NULL;
          return _pszStr;
        }


    HRESULT Append(LPCSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(CHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrA *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPSTR CloneStr()
        {return CloneStrA();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    inline BOOL IsValid()
    {return _pszStr != NULL;}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenA(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    CHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPSTR _pszStr;
    DWORD _cchSize;


}; //ShStrA


class ShStrW
{
public:

    //
    //  Constructors
    //
    ShStrW();

    //
    //  Destructor
    //
    ~ShStrW()
        {Reset();}

    //
    // the first are the only ones that count
    //
    HRESULT SetStr(LPCSTR pszStr, DWORD cchStr);
    HRESULT SetStr(LPCSTR pszStr);
    HRESULT SetStr(LPCWSTR pwszStr, DWORD cchStr);

    // the rest just call into the first three
    HRESULT SetStr(LPCWSTR pwszStr)
        {return SetStr(pwszStr, (DWORD) -1);}
    HRESULT SetStr(ShStrW &shstr)
        {return SetStr(shstr._pszStr);}


    ShStrW& operator=(LPCSTR pszStr)
        {SetStr(pszStr); return *this;}
    ShStrW& operator=(LPCWSTR pwszStr)
        {SetStr(pwszStr); return *this;}
    ShStrW& operator=(ShStrW &shstr)
        {SetStr(shstr._pszStr); return *this;}


    LPCWSTR GetStr()
        {return _pszStr;}
    operator LPCWSTR()
        {return _pszStr;}

    LPWSTR GetInplaceStr(void)
        {return _pszStr;}

    // People want to play with the bytes in OUR internal buffer.  If they
    // call us correctly, and assume that the resulting pointer is only valid
    // as far as they want or as far as the current length, then let them.
    LPWSTR GetModifyableStr(DWORD cchSizeToModify)
        {
         if (cchSizeToModify > _cchSize)
            if (FAILED(SetSize(cchSizeToModify)))
                return NULL;
          return _pszStr;
        }

    HRESULT Append(LPCWSTR pszStr, DWORD cchStr);
    HRESULT Append(LPCWSTR pszStr)
        {return Append(pszStr, (DWORD) -1);}
    HRESULT Append(WCHAR ch)
        {return Append(&ch, 1);}

    //
    //  the Clone methods return memory that must be freed
    //
    ShStrW *Clone();
    LPSTR CloneStrA();
    LPWSTR CloneStrW();
    LPWSTR CloneStr()
        {return CloneStrW();}

    
    VOID Reset();
    VOID Trim();

#ifdef DEBUG
    BOOL IsValid();
#else
    BOOL IsValid() 
    {return (BOOL) (_pszStr ? TRUE : FALSE);}
#endif //DEBUG

    DWORD GetSize()
        {ASSERT(!(_cchSize % DEFAULT_SHSTR_LENGTH)); return (_pszStr ? _cchSize : 0);}

    HRESULT SetSize(DWORD cchSize);
    DWORD GetLen()
        {return lstrlenW(_pszStr);}



protected:
//    friend UrlStr;
/*
    TCHAR GetAt(DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] : TEXT('\0');}
    TCHAR SetAt(TCHAR ch, DWORD cch)
        {return cch < _cchSize ? _pszStr[cch] = ch : TEXT('\0');}
*/
private:

    HRESULT _SetStr(LPCSTR psz);
    HRESULT _SetStr(LPCSTR psz, DWORD cb);
    HRESULT _SetStr(LPCWSTR pwszStr, DWORD cchStr);

    WCHAR _szDefaultBuffer[DEFAULT_SHSTR_LENGTH];
    LPWSTR _pszStr;
    DWORD _cchSize;


}; //ShStrW

#ifdef UNICODE
typedef ShStrW  SHSTR;
typedef ShStrW  *PSHSTR;
#else
typedef ShStrA  SHSTR;
typedef ShStrA  *PSHSTR;
#endif //UNICODE

typedef ShStrW  SHSTRW;
typedef ShStrW  *PSHSTRW;

typedef ShStrA  SHSTRA;
typedef ShStrA  *PSHSTRA;



#if 0  //DISABLED until i have written the SHUrl* functions - zekel 7-Nov-96

class UrlStr 
{
public:
    UrlStr()
        {return;}

    operator LPCTSTR();
    operator SHSTR();

    UrlStr &SetUrl(LPCSTR pszUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl);
    UrlStr &SetUrl(LPCSTR pszUrl, DWORD cchUrl);
    UrlStr &SetUrl(LPCWSTR pwszUrl, DWORD cchUrl);

    DWORD GetScheme();
    VOID GetSchemeStr(PSHSTR pstrScheme);

    HRESULT Combine(LPCTSTR pszUrl, DWORD dwFlags);

/*
    ShStr &GetLocation();
    ShStr &GetAnchor();
    ShStr &GetQuery();

    HRESULT Canonicalize(DWORD dwFlags);
*/
protected:
    SHSTR  _strUrl;
};
#endif //DISABLED


#endif // _SHSTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shmenu.cpp ===
/*++

  shmenu.cpp

  this is for IShellMenu and related stuff.  eventually all
  of the fsmenu.c functionality should be in here

--*/




class CFMDropTarget : public IDropTarget 
{
public:

    CFMDropTarget();
    ~CFMDropTarget();

    HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags);

    // IUnknown methods

    virtual STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP DragEnter(
        IDataObject *pdata,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragEnter(pdata, grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragOver( 
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->DragOver(grfKeyState, pt, pdwEffect);}
    
    STDMETHODIMP DragLeave( void)
    {return _pdrop->DragLeave();}
    
    STDMETHODIMP  Drop( 
        IDataObject *pDataObj,
        DWORD grfKeyState,
        POINTL pt,
        DWORD *pdwEffect)
    {return _pdrop->Drop(pDataObj, grfKeyState, pt, pdwEffect);}

private:

    ULONG _cRef;
    IShellFolder *_psf;     //  the psf to use...
    LPITEMIDLIST _pidl;
    DWORD _dwFlags;
    IDropTarget *_pdrop;      //  the actual droptarget


}

CFMDropTarget :: CFMDropTarget ()
{
    _cRef = 1;
    DllAddRef();
}

CFMDropTarget :: ~CFMDropTarget ()
{
    SAFERELEASE(_psf);
    if(pidl)
        ILFree(pidl);
    SAFERELEASE(_pdrop);
    DllRelease();
}

HRESULT
CFMDropTarget :: QueryInterface(REFIID riid, PVOID *ppvObj)
{
    HRESULT hr = E_NOINTERFACE;


    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDropTarget))
    {
        AddRef();
        *ppvObj = (LPVOID) SAFECAST(this, IDropTarget*);
        hr = S_OK;

    }

    return hr;
}


ULONG
CFMDropTarget :: AddRef(void)
{

    _cRef++;

    return _cRef;

}

ULONG
CFMDropTarget :: Release(void)
{
    ASSERT (_cRef > 0);

    cRef--;

    if (!cRef)
    {
        //time to go bye bye
        delete this;
        return 0;
    }

    return cRef;

}

// FEATURE: ZEKEL we are just using the psf here...we need to support more
HRESULT Init (
        HWND hwnd, 
        IShellFolder *psf, 
        LPITEMIDLIST pidl,
        DWORD dwFlags)
{
    HRESULT hr = E_INVALIDARG;

    if(psf)
        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &_psf);

    _pidl = ILClone(pidl);
    _dwFlags = dwFlags;

    if(SUCCEEDED(hr) && _psf && _pidl)
    {
        hr = _psf->CreateViewObject(hwnd, IID_IDropTarget, (LPVOID*) &_pdrop);
    }

    return hr;
}

//FEATURE: ZEKEL right now this doesnt support ordering, and assumes that you 
//want to drop right onto the current menu.  this is just a start.
//pidl and dwFlags are just dummy params
HRESULT
CFMDropTarget_CreateAndInit(
                            HWND hwnd, 
                            IShellFolder *psf, 
                            LPITEMIDLIST pidl,
                            DWORD dwFlags,
                            LPVOID *ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFMDropTarget *pdt;

    ASSERT(ppvObj)
    if(ppvObj)
        *ppvObj = NULL;
    else
        return E_INVALIDARG;


    pdt = new CFMDropTargetNULL;

    if (pdt)
    {
        hr = pdt->Init(hwnd, psf, pidl, dwFlags);

        if (SUCCEEDED(hr))
            *ppvObj= SAFECAST(pdt, IDropTarget * );
        else
            pdt->Release();
    }
    
    return hr;
}

    if (psf)
    {


        hr = psf->QueryInterface(IID_IShellFolder, (LPVOID *) &psfMine);

        if(SUCCEEDED(hr) && psfMine)
        {


    }


#if 0  // ZEKEL
    {
        if(pmgoi->dwFlags & (MNGO_TOPGAP | MNGO_BOTTOMGAP))
        {
            //then we need to use the current psf as the droptarget
            // and the pidl is just a marker
        }
        else
        {
            //  we need to use the pidl's psf as the droptarget if possible
                DWORD dwAttr = SFGAO_DROPTARGET;
                hr = psf->lpVtbl->GetAttributesOf(1, (LPCITEMIDLIST*)&pfmi->pidl, &dwAttr);
                if (SUCCEEDED(hres) && (dwAttr & SFGAO_DROPTARGET))
                {
                    hr = psf->lpVtbl->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pfmi->pidl,
                                              IID_IDropTarget, NULL, (LPVOID*)&_pdropgtCur);
                }
        }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StandardEnum.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STANDARDENUM_H_

// A specific implementation of the Clone function
void WINAPI CopyAndAddRefObject(void *pDest, const void *pSource, DWORD dwSize);

// An IEnumConnectionPoints creation function
HRESULT CreateInstance_IEnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum, DWORD count, ...);

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public IEnumGeneric {

public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    virtual ~CStandardEnum();

private:
    int m_cRef;

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    BOOL m_fMembersAreInterfaces;   // Indicates that members of the enumerated array are
                                      // Interfaces and that we need to hold refs on them
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);

    const void *GetNthElement(int n)
    {   return (const BYTE *)m_rgElements + (m_cbElementSize * n);  }
};


STDAPI_(void*) CStandardEnum_CreateInstance(REFIID riid, BOOL fMembersAreInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));


#define _STANDARDENUM_H_
#endif // _STANDARDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\shui.h ===
#ifndef _SHUI_H_
#define _SHUI_H_

/* Declaration needed for shdocvw and browseui to work together and 
for whatever reason they cannot go into shdocvw.h or browseui.h
*/
#include <mshtml.h>

STDAPI SearchForElementInHead
(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface

);


typedef HRESULT (*PFNSEARCHFORELEMENTINHEAD)(
    IHTMLDocument2* pHTMLDocument,  // [in] document to search
    LPOLESTR        pszAttribName,  // [in] attribute to check for
    LPOLESTR        pszAttrib,      // [in] value the attribute must have
    REFIID          iidDesired,     // [in] element interface to return
    IUnknown**      ppunkDesired    // [out] returned interface
    );


#define SEARCHFORELEMENTINHEAD_ORD 208

typedef struct _internet_shortcut_params
{
    LPCITEMIDLIST pidlTarget;
    LPCTSTR  pszTitle;           
                              // when shdocvw is made unicode - then the use of this struct in browseui
                              // will have to be changed to reflect that these are TCHAR
    LPCTSTR pszDir;
    LPTSTR  pszOut;
    int     cchOut;
    BOOL    bUpdateProperties;
    BOOL    bUniqueName;
    BOOL    bUpdateIcon;
    IOleCommandTarget *pCommand;
    IHTMLDocument2 *pDoc;
} ISHCUT_PARAMS;


STDAPI
CreateShortcutInDirEx(ISHCUT_PARAMS *pIShCutParams);


typedef HRESULT (*PFNDOWNLOADICONFORSHORTCUT)(WCHAR *pwszFileName, WCHAR *pwszShortcutUrl, WCHAR *pwszIconUrl);
#define DOWNLOADICONFORSHORTCUT_ORD 207   
STDAPI
DownloadIconForShortcut(
    WCHAR *pwszFileName,            // [in] Optional, File name of shortcut - full path
    WCHAR *pwszShortcutUrl,         // [in] Url of Shortcut
    IHTMLDocument2* pHTMLDocument  // [in] document to search for icon URL 
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inststub.rc
//
/* IDD_InstallStubProgress and IDS_UNINSTALL should be defined by the including
 * component to not conflict with other resources.
 *
 * Control IDs can live here since they don't need to be unique across dialogs.
 */

#define IDC_RUNNING_INSTALL_STUB        1000
#define IDC_RUNNING_UNINSTALL_STUB      1001
#define IDC_INSTALL_STUB_NAME           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\tb_ids.h ===
#ifndef _TB_IDS_H_
#define _TB_IDS_H_


// IE toolbar strips

#define IDB_TB_IE_BASE          200
#define IDB_TB_IE_DEF_24        204
#define IDB_TB_IE_HOT_24        205
#define IDB_TB_IE_DEF_16        206
#define IDB_TB_IE_HOT_16        207


// Shell toolbar strips

#define IDB_TB_SH_BASE          210
#define IDB_TB_SH_DEF_24        214
#define IDB_TB_SH_HOT_24        215
#define IDB_TB_SH_DEF_16        216
#define IDB_TB_SH_HOT_16        217


// Extension strips

#define IDB_TB_EXT_DEF_16       225
#define IDB_TB_EXT_HOT_16       226
#define IDB_TB_EXT_DEF_24       227
#define IDB_TB_EXT_HOT_24       228

// "Go" toolbar strips

#define IDB_TB_GO_DEF_20        230
#define IDB_TB_GO_HOT_20        231

// Branding strips

#define IDB_BRAND_BITMAP_MICRO  240
#define IDB_BRAND_BITMAP_SMALL  241
#define IDB_BRAND_BITMAP_LARGE  242

#define IDB_BRAND256_BITMAP_MICRO  245
#define IDB_BRAND256_BITMAP_SMALL  246
#define IDB_BRAND256_BITMAP_LARGE  247


#endif //_TB_IDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\tokenutil.h ===
//  --------------------------------------------------------------------------
//  Module Name: TokenUtil.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class to handle privilege enabling and restoring across function calls.
//
//  History:    1999-08-18  vtan        created
//              1999-11-16  vtan        separate file
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

#ifndef     _TokenUtil_
#define     _TokenUtil_

STDAPI_(BOOL)   OpenEffectiveToken (IN DWORD dwDesiredAccess, OUT HANDLE *phToken);

//  --------------------------------------------------------------------------
//  CPrivilegeEnable
//
//  Purpose:    This class enables a privilege for the duration of its scope.
//              The privilege is restored to its original state on
//              destruction.
//
//  History:    1999-08-18  vtan        created
//              2000-02-01  vtan        moved from Neptune to Whistler
//              2000-03-31  vtan        duplicated from ds to shell
//  --------------------------------------------------------------------------

class   CPrivilegeEnable
{
    private:
                                    CPrivilegeEnable (void);
                                    CPrivilegeEnable (const CPrivilegeEnable& copyObject);
        const CPrivilegeEnable&     operator = (const CPrivilegeEnable& assignObject);
    public:
                                    CPrivilegeEnable (const TCHAR *pszName);
                                    CPrivilegeEnable (ULONG ulPrivilegeValue);
                                    ~CPrivilegeEnable (void);
    private:
        bool                        _fSet;
        HANDLE                      _hToken;
        TOKEN_PRIVILEGES            _tokenPrivilegePrevious;
};

#endif  /*  _TokenUtil_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\trayp.h ===
#ifndef _TRAYP_INC
#define _TRAYP_INC


#define TBC_SETACTIVEALT            (WM_USER + 50)      //  50=0x32
#define TBC_VERIFYBUTTONHEIGHT      (WM_USER + 51)
#define TBC_CANMINIMIZEALL          (WM_USER + 52)
#define TBC_MINIMIZEALL             (WM_USER + 53)
#define TBC_WARNNODROP              (WM_USER + 54)
#define TBC_SETPREVFOCUS            (WM_USER + 55)
#define TBC_FREEPOPUPMENUS          (WM_USER + 56)
#define TBC_SYSMENUCOUNT            (WM_USER + 57)
#define TBC_CHANGENOTIFY            (WM_USER + 58)
#define TBC_POSTEDRCLICK            (WM_USER + 59)
#define TBC_MARKFULLSCREEN          (WM_USER + 60)
#define TBC_TASKTAB                 (WM_USER + 61)
#define TBC_BUTTONHEIGHT            (WM_USER + 62)

#define WMTRAY_PROGCHANGE           (WM_USER + 200)     // 200=0xc8
#define WMTRAY_RECCHANGE            (WM_USER + 201)
#define WMTRAY_FASTCHANGE           (WM_USER + 202)
// was  WMTRAY_DESKTOPCHANGE        (WM_USER + 204)

#define WMTRAY_COMMONPROGCHANGE     (WM_USER + 205)
#define WMTRAY_COMMONFASTCHANGE     (WM_USER + 206)

#define WMTRAY_FAVORITESCHANGE      (WM_USER + 207)

#define WMTRAY_REGISTERHOTKEY       (WM_USER + 230)
#define WMTRAY_UNREGISTERHOTKEY     (WM_USER + 231)
#define WMTRAY_SETHOTKEYENABLE      (WM_USER + 232)
#define WMTRAY_SCREGISTERHOTKEY     (WM_USER + 233)
#define WMTRAY_SCUNREGISTERHOTKEY   (WM_USER + 234)
#define WMTRAY_QUERY_MENU           (WM_USER + 235)
#define WMTRAY_QUERY_VIEW           (WM_USER + 236)     // 236=0xec
#define WMTRAY_TOGGLEQL             (WM_USER + 237)

// #define TM_POSTEDRCLICK             (WM_USER+0x101)
#define TM_CONTEXTMENU              (WM_USER+0x102)
#define TM_FACTORY                  (WM_USER+0x103)     // OPK tools use this
#define TM_ACTASTASKSW              (WM_USER+0x104)
#define TM_LANGUAGEBAND             (WM_USER+0x105)

#define TM_RELAYPOSCHANGED          (WM_USER + 0x150)
#define TM_CHANGENOTIFY             (WM_USER + 0x151)
#define TM_BRINGTOTOP               (WM_USER + 0x152)
#define TM_WARNNOAUTOHIDE           (WM_USER + 0x153)
// #define TM_WARNNODROP               (WM_USER + 0x154)
// #define TM_NEXTCTL                  (WM_USER + 0x155)
#define TM_DOEXITWINDOWS            (WM_USER + 0x156)
#define TM_SHELLSERVICEOBJECTS      (WM_USER + 0x157)
#define TM_DESKTOPSTATE             (WM_USER + 0x158)
#define TM_HANDLEDELAYBOOTSTUFF     (WM_USER + 0x159)
#define TM_GETHMONITOR              (WM_USER + 0x15a)

#ifdef DEBUG
#define TM_NEXTCTL                  (WM_USER + 0x15b)
#endif
#define TM_UIACTIVATEIO             (WM_USER + 0x15c)
#define TM_ONFOCUSCHANGEIS          (WM_USER + 0x15d)

#define TM_MARSHALBS                (WM_USER + 0x15e)
// was TM_THEATERMODE, do not reuse (WM_USER + 0x15f)
#define TM_KILLTIMER                (WM_USER + 0x160)
#define TM_REFRESH                  (WM_USER + 0x161)
#define TM_SETTIMER                 (WM_USER + 0x162)
#define TM_DOTRAYPROPERTIES         (WM_USER + 0x163)

#define TM_PRIVATECOMMAND           (WM_USER + 0x175)
#define TM_HANDLESTARTUPFAILED      (WM_USER + 0x176)
// #define TM_CHANGENOTIFY             (WM_USER + 0x177)
#define TM_STARTUPAPPSLAUNCHED      (WM_USER + 0x178)
#define TM_RAISEDESKTOP             (WM_USER + 0x179)
#define TM_SETPUMPHOOK              (WM_USER + 0x180)

#define TM_WORKSTATIONLOCKED        (WM_USER + 0x181)
#define TM_STARTMENUDISMISSED       (WM_USER + 0x182)
#define TM_SHOWTRAYBALLOON          (WM_USER + 0x190)

#define Tray_GetHMonitor(hwndTray, phMon) \
        (DWORD)SendMessage((hwndTray), TM_GETHMONITOR, 0, (LPARAM)(HMONITOR *)phMon)

#endif // _TRAYP_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uihostipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: UIHostIPC.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Messages for communication between SHGINA and the UI host.
//
//  History:    2000-05-11  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _UIHostIPC_
#define     _UIHostIPC_

//  This comes in uMsg.

#define WM_UIHOSTMESSAGE                (WM_USER + 8517)

//  This comes in WPARAM.

#define HM_NOACTION                     (WPARAM)(-1)
#define HM_DISPLAYSTATUS                0
#define HM_DISPLAYREFRESH               1
#define HM_DISPLAYRESIZE                2
#define HM_SWITCHSTATE_STATUS          10
#define HM_SWITCHSTATE_LOGON           11
#define HM_SWITCHSTATE_LOGGEDON        12
#define HM_SWITCHSTATE_HIDE            13
#define HM_SWITCHSTATE_DONE            14
#define HM_NOTIFY_WAIT                 20
#define HM_SELECT_USER                 21
#define HM_SET_ANIMATIONS              22
#define HM_INTERACTIVE_LOGON_REQUEST   30

//  LPARAM depends on the WPARAM.

typedef struct _INTERACTIVE_LOGON_REQUEST
{
    WCHAR   szUsername[UNLEN + sizeof('\0')];
    WCHAR   szDomain[DNLEN + sizeof('\0')];
    WCHAR   szPassword[PWLEN + sizeof('\0')];
} INTERACTIVE_LOGON_REQUEST, *PINTERACTIVE_LOGON_REQUEST;

typedef struct _SELECT_USER
{
    WCHAR   szUsername[UNLEN + sizeof('\0')];
    WCHAR   szDomain[DNLEN + sizeof('\0')];
} SELECT_USER, *PSELECT_USER;

#endif  /*  _UIHostIPC_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uemevt.h ===
// {
//***   UEME_* -- events
// DESCRIPTION
//  UEME_UI*
//  UEME_RUN*
//  UEME_DONE*
//  UEME_ERROR*
//  UEME_DB*
// NOTES
//  since rulc.exe must process this, it can *only* contain #defines.

// UI (menu, shortcut, etc.)
#define UEME_UIMENU     1   // did a UI menu, wP=grp lParam=IDM_*
#define UEME_UIHOTKEY   2   // did a UI hotkey, lParam=GHID_*
#define UEME_UISCUT     3   // did a UI shortcut, lParam=???
#define UEME_UIQCUT     4   // did a UI qlink/isfband, lParam=???
#define UEME_UITOOLBAR  5   // did a UI toolbar button, wP=lParam=???
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
#define UEME_UIASSOC    6   // did a semi-UI association, wP=-1 lP=-1
#endif

// run (spawn, invoke, etc.)
#define UEME_RUNWMCMD   12  // ran a WM_COMMAND, lParam=UEMC_*
#define _UEME_RUNPIDL1  10  // (obsolete) ran a pidl, wP=csidl, lParam=pidl
#define UEME_RUNPIDL    18  // ran a pidl, wP=isf lP=pidlItem
#define UEME_RUNINVOKE  11  // ran an Ixxx::Invoke, lParam=???
#define UEME_RUNOLECMD  13  // ran an IOleCT::Exec wP=nCmdID lP=pguidCmdGrp
#define UEME_RUNPATHA   14  // ran a path, lParam=path
#define UEME_RUNPATHW   15  // ran a path, lParam=path
#define UEME_RUNCPLA    16  // ran a cpl path, wP=index lP=path
#define UEME_RUNCPLW    17  // ran a cpl path, wP=index lP=path

#ifdef UNICODE
#define UEME_RUNPATH    UEME_RUNPATHW
#define UEME_RUNCPL     UEME_RUNCPLW
#else
#define UEME_RUNPATH    UEME_RUNPATHA
#define UEME_RUNCPL     UEME_RUNCPLA
#endif

// exit status
#define UEME_DONECANCEL 32  // cancel
#define UEME_DONEOK     30  // (NYI) ok (==0)
#define UEME_DONEFAIL   31  // (NYI) fail (!=0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
#define UEME_ERRORA     20  // error (generic), lParam=szMsg
#define UEME_ERRORW     21  // error (generic), lParam=szMsg

#ifdef UNICODE
#define UEME_ERROR      UEME_ERRORW
#else
#define UEME_ERROR      UEME_ERRORA
#endif

// control
#define UEME_CTLSESSION 40  // do UASetSession

// instrumented browser
#define UEME_INSTRBROWSER 50

// debug
#define UEME_DBTRACEA   90  // just a midpoint trace..., lParam=szMsg
#define UEME_DBTRACEW   91  // just a midpoint trace..., lParam=szMsg

#ifdef UNICODE
#define UEME_DBTRACE    UEME_DBTRACEW
#else
#define UEME_DBTRACE    UEME_DBTRACEA
#endif

#define UEME_DBSLEEP    92  // sleep, lParam=mSec (per Sleep API)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// NOTE:FEATURE: NYI we don't support private messages for now
#define UEME_USER       256

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uemapp.h ===
#ifndef _UEMAPP_H_ // {
#define _UEMAPP_H_

//***   uemapp.h -- application (client) side of event monitor
//

#ifdef __cplusplus
extern "C" {
#endif

// {
//***   UEME_* -- events
#include "uemevt.h"         // separate #include so rulc.exe can use it

#define UEME_FBROWSER   0x80000000  // 0:shell 1:browser

//***   UEMF_* -- Flags used when calling FireEvent
#define UEMF_EVENTMON   0x00000001       // Traditional Event Monitor use of FireEvent
#define UEMF_INSTRUMENT 0x00000002       // These events are being instrumented
#define UEMF_MASK       (UEMF_EVENTMON | UEMF_INSTRUMENT)

//****  UEMF_ Meta Categories
#define UEMF_XEVENT     (UEMF_EVENTMON | UEMF_INSTRUMENT)

//***   UIG_* -- UI 'groups'
// NOTES
//  NOTE not sure if this is the right partitioning
#define UIG_NIL         (-1)
#define UIG_COMMON      1       // common UI elements (e.g. back/stop/refresh)
#define UIG_INET        2       // inet (html) elements (e.g. search/favs)
#define UIG_FILE        3       // file (defview) elements (e.g. up)
#define UIG_OTHER       4       // custom (isf, isv, docobj) elements

//***   UIM_* -- modules
// NOTES
//  used to separate namespaces.  e.g. IDMs for UEME_RUNWMCMD.
#define UIM_NIL         (-1)    // none (global)
#define UIM_EXPLORER    1       // explorer.exe
#define UIM_BROWSEUI    2       // browseui.dll
#define UIM_SHDOCVW     3       // shdocvw.dll
#define UIM_SHELL32     4       // shell32.dll

// Instrumented Browser wparams 
#define UIBW_ADDTOFAV   1
#define UIBW_404ERROR   2
#define UIBW_NAVIGATE   3       // navigation lP=how
    #define UIBL_NAVOTHER   0   // via other
    #define UIBL_NAVADDRESS 1   // via address bar
    #define UIBL_NAVGO      2   // (NYI) via 'go' button on address bar
    #define UIBL_NAVHIST    3   // via history pane
    #define UIBL_NAVFAVS    4   // via favorites pane
    #define UIBL_NAVFOLDERS 5   // (NYI) via all-folders pane
    #define UIBL_NAVSEARCH  6   // (NYI) via search pane
#define UIBW_RUNASSOC   4       // run lP=assoc
    #define UIBL_DOTOTHER   0   // other
    #define UIBL_DOTEXE     1   // .exe
    #define UIBL_DOTASSOC   2   // associated w/ some .exe
    #define UIBL_DOTNOASSOC 3   // not associated w/ some .exe (OpenWith)
    #define UIBL_DOTFOLDER  4   // folder
    #define UIBL_DOTLNK     5   // .lnk
#define UIBW_UICONTEXT  5       // context menu lP=where
    #define UIBL_CTXTOTHER      0   // (NYI) other
    #define UIBL_CTXTDEFBKGND   1   // defview background
    #define UIBL_CTXTDEFITEM    2   // defview item
    #define UIBL_CTXTDESKBKGND  3   // desktop background
    #define UIBL_CTXTDESKITEM   4   // desktop item
//  #define UIBL_CTXTQCUTBKGND  5   // (n/a) qlaunch background
    #define UIBL_CTXTQCUTITEM   6   // qlaunch/qlinks item
//  #define UIBL_CTXTISFBKGND   7   // (n/a) arb. isf background
    #define UIBL_CTXTISFITEM    8   // arb. isf item
    #define UIBL_CTXTITBBKGND   9   // (n/a) itbar background
    #define UIBL_CTXTITBITEM    10  // itbar item
// for input, however the menu is *1st* invoked is assumed to be representative
// of the *entire* menu action
#define UIBW_UIINPUT    6       // input method lP=source
    // n.b. no desktop/browser distinction
    #define UIBL_INPOTHER   0       // (NYI) other
    #define UIBL_INPMOUSE   1       // mouse
    #define UIBL_INPMENU    2       // menu key (alt or alt+letter)
    #define UIBL_INPACCEL   3       // (NYI) accelerator
    #define UIBL_INPWIN     4       // (NYI) 'windows' key

// Instrumented Browser lparams
#define UIBL_KEYBOARD   1
#define UIBL_MENU       2
#define UIBL_PANE       3


//***   UEM*_* -- app 'groups'
//
#define UEMIID_NIL      CLSID_NULL              // nil (office uses 0...)
#define UEMIID_SHELL    CLSID_ActiveDesktop     // FEATURE need better one
#define UEMIID_BROWSER  CLSID_InternetToolbar   // FEATURE need better one

#define UEMIND_NIL      (-1)
#define UEMIND_SHELL    0
#define UEMIND_BROWSER  1

#define UEMIND_NSTANDARD    2   // cardinality(UEMIND_*)

//***   UEM*Event -- helpers from ../lib/uassist.cpp
// NOTES
//  FEATURE rename to UA* (from UEM*)
BOOL UEMIsLoaded();
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam);
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);


typedef int (CALLBACK *UEMCallback)(void *param, const GUID *pguidGrp, int eCmd);

HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param);

#if 1 // {
//***   obsolete -- old exports, nuke after all callers fixed
//

STDAPI_(void) UEMEvalMsg(const GUID *pguidGrp, int uemCmd, WPARAM wParam, LPARAM lParam);

// obsolete! use UEMEvalMsg
//STDAPI_(void) UEMTrace(int uemCmd, LPARAM lParam);
#define UEMTrace(uemCmd, lParam)    UEMEvalMsg(&UEMIID_NIL, uemCmd, -1, lParam)

#define UEIA_RARE       0x01    // rare (demotion candidate)

STDAPI_(BOOL) UEMGetInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
#endif // }

// }

// {
//***   UEMC_* -- commands
//
#define TABDAT(uemc)   uemc,
enum {
    #include "uemcdat.h"
};
#undef  TABDAT
// }


// {
//***   misc helpers
//

//***   XMB_ICONERROR -- guys that look like an error (vs. idle chit-chat)
// error stop (question) exclamation hand (info) (aster) (warn)
// is this the right set? sounds good to me -justmann
#define XMB_ICONERROR   (MB_ICONERROR|MB_ICONSTOP|MB_ICONEXCLAMATION|MB_ICONHAND)
// }

#ifdef __cplusplus
}
#endif

#endif // } _UEMAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uemcdat.h ===
//***   uemcmddat.h -- generator file for UEMC_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  NOTE:FEATURE: many of these are NYI.
//

TABDAT(UEMC_NIL)
TABDAT(UEMC_FIRST)

TABDAT(UEMC_STARTMENU)      // (pseudo) start menu

//
TABDAT(UEMC_PROGS)          // (NYI) (pseudo) catchall for FS programs
TABDAT(UEMC_FAVS)           // (NYI) (pseudo) catchall for FS favorites
TABDAT(UEMC_DOCS)           // (NYI) (pseudo) catchall for FS documents

// settings...
TABDAT(UEMC_CONTROLS)
TABDAT(UEMC_PRINTERS)
TABDAT(UEMC_TASKBAR)
TABDAT(UEMC_FOLDERS)
TABDAT(UEMC_ACTDESK)

// find...
TABDAT(UEMC_FINDFILES)
TABDAT(UEMC_FINDCOMP)
TABDAT(UEMC_FINDINTER)      // (NYI?)
TABDAT(UEMC_FINDOTHERS)     // (NYI) (pseudo) catchall for installed extensions

TABDAT(UEMC_HELPSEARCH)
TABDAT(UEMC_FILERUN)
TABDAT(UEMC_LOGOFF)         // unused?
TABDAT(UEMC_SHUTDOWN)       // unused?

TABDAT(UEMC_LAST)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uemedat.h ===
//***   uemedat.h -- generator file for UEME_*
// NOTES
//  this file is included in numerous contexts w/ TABDAT #defined
//  to give the desired behavior.   see the individ files for details.
//
//  NOTE:FEATURE many of these are NYI.
//
//  e<n>    encode up to step <= n
//  f       fire event
//  l       log event
//  @       escape to custom code
//  !       ASSERT
//  x       NYI
//

// UI (menu, shortcut, etc.)
TABDAT(UEME_UIMENU     , "e2fl@" , 0, 0, 0, 0)
TABDAT(UEME_UIHOTKEY   , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UISCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UIQCUT     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_UITOOLBAR  , "e2fl"  , 0, 0, 0, 0)
#if 0 // 980825 uncomment in uemevt.h, uemedat.h if build breaks (tmp hack)
TABDAT(UEME_UIASSOC    , "e1fl"  , 0, 0, 0, 0)
#endif

// run (spawn, invoke, etc.)
TABDAT(UEME_RUNWMCMD   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNPIDL    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNINVOKE  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNOLECMD  , "xe1fl" , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHA   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNPATHW   , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLA    , "e2fl"  , 0, 0, 0, 0)
TABDAT(UEME_RUNCPLW    , "e2fl"  , 0, 0, 0, 0)

// exit status
TABDAT(UEME_DONECANCEL , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEOK     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_DONEFAIL   , "e1fl"  , 0, 0, 0, 0)

// error
// NOTES
//  for now lParam=szMsg, that's just temporary but not sure what we need yet
TABDAT(UEME_ERRORA     , "e1fl"  , 0, 0, 0, 0)
TABDAT(UEME_ERRORW     , "e1fl"  , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#else
TABDAT(UEME_ERROR      , "e1fl"  , 0, 0, 0, 0)
#endif

// control
TABDAT(UEME_CTLSESSION , "@"     , 0, 0, 0, 0)

// debug
TABDAT(UEME_DBTRACEA   , "@"     , 0, 0, 0, 0)
TABDAT(UEME_DBTRACEW   , "@"     , 0, 0, 0, 0)

#ifdef UNICODE
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#else
TABDAT(UEME_DBTRACE    , "@"     , 0, 0, 0, 0)
#endif
TABDAT(UEME_DBSLEEP    , "@"     , 0, 0, 0, 0)

// Instrumented Browser
TABDAT(UEME_INSTRBROWSER, "e2fl" , 0, 0, 0, 0)

// all events below here (msg < UEME_USER) are reserved
// private messages start here (at UEME_USER + 0)
// FEATURE: NYI we don't support private messages for now
TABDAT(UEME_USER       , "x"     , 0, 0, 0, 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uassist.cpp ===
//***   uassist.cpp -- User Assist helpers (retail and debug)
//
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.  NEEDED because of ENTERCRITICAL
// as stocklib.dll does not have a critical section in it.
//
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/uassist.cpp"
//
//  we cache the UAssist object and provide thunks for 'safe' access to it.

#include "uemapp.h"

#define DM_UASSIST             0

IUserAssist *g_uempUa;      // 0:uninit, -1:failed, o.w.:cached obj

//***   GetUserAssist -- get (and create) cached UAssist object
//
IUserAssist *GetUserAssist()
{
    HRESULT hr;
    IUserAssist * pua = NULL;

    if (g_uempUa == 0)
    {
        // re: CLSCTX_NO_CODE_DOWNLOAD
        // an ('impossible') failed CCI of UserAssist is horrendously slow.
        // e.g. click on the start menu, wait 10 seconds before it pops up.
        // we'd rather fail than hose perf like this, plus this class should
        // never be remote.
        // FEATURE: there must be a better way to tell if CLSCTX_NO_CODE_DOWNLOAD
        // is supported, i've sent mail to 'com' to find out...
        DWORD dwFlags = staticIsOS(OS_WIN2000ORGREATER) ? (CLSCTX_INPROC|CLSCTX_NO_CODE_DOWNLOAD) : CLSCTX_INPROC;
        hr = THR(CoCreateInstance(CLSID_UserAssist, NULL, dwFlags, IID_IUserAssist, (void**)&pua));
        ASSERT(SUCCEEDED(hr) || pua == NULL);  // follow COM rules

        if (pua)
        {
            HINSTANCE hInst;

            hInst = SHPinDllOfCLSID(&CLSID_UserAssist); // cached across threads
            // we're toast if this fails!!! (but happily, that's 'impossible')
            // e.g. during logon when grpconv.exe is ShellExec'ed, we do
            // a GetUserAssist, which caches a ptr to browseui's singleton
            // object.  then when the ShellExec returns, we do CoUninit,
            // which would free up the (non-pinned) browseui.dll.  then
            // a later use of the cache would go off into space.
        }

        ENTERCRITICAL;
        if (g_uempUa == 0) {
            g_uempUa = pua;     // xfer refcnt (if any)
            if (!pua) {
                // mark it failed so we won't try any more
                g_uempUa = (IUserAssist *)-1;
            }
            pua = NULL;
        }
        LEAVECRITICAL;
        if (pua)
            pua->Release();
        TraceMsg(DM_UASSIST, "sl.gua: pua=0x%x g_uempUa=%x", pua, g_uempUa);
    }

    return (g_uempUa == (IUserAssist *)-1) ? 0 : g_uempUa;
}

extern "C"
BOOL UEMIsLoaded()
{
    BOOL fRet;

    fRet = GetModuleHandle(TEXT("ole32.dll")) &&
        GetModuleHandle(TEXT("browseui.dll"));
    
    return fRet;
}

//***   UEMFireEvent, QueryEvent, SetEvent -- 'safe' thunks
// DESCRIPTION
//  call these so don't have to worry about cache or whether Uassist object
// even was successfully created.
extern "C"
HRESULT UEMFireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->FireEvent(pguidGrp, eCmd, dwFlags, wParam, lParam);
    }
    return hr;
}

extern "C"
HRESULT UEMQueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->QueryEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}

extern "C"
HRESULT UEMSetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr = E_FAIL;
    IUserAssist *pua;

    pua = GetUserAssist();
    if (pua) {
        hr = pua->SetEvent(pguidGrp, eCmd, wParam, lParam, pui);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\unimp.h ===
#ifdef DEBUG
#ifdef K32
const char UnimpMessage[] = "Unimplemented API %s";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack";

enum {DEB_FATAL, DEB_ERR, DEB_WARN, DEB_TRACE };
int apiLevel = DEB_WARN;
VOID    KERNENTRY   vDebugOut(int level, const char *pfmt, ...);

#define DebugOut(args) vDebugOut args
#define UNIMP_MESSAGE DebugOut((apiLevel, UnimpMessage, api_string));
#define DEBUG_OOPS    DebugOut((DEB_ERR, UnimpMessage, api_string)); \

#else

const char UnimpMessage[] = "Unimplemented API %s\r\n";
const char AttentionMessage[] = "ATTENTION !!! API stub might corrupt the stack\r\n";
#define UNIMP_MESSAGE DebugPrintf(UnimpMessage, api_string);
#define DEBUG_OOPS    DebugPrintf(UnimpMessage, api_string); _asm { int 3 };
#endif
#endif
/*
 * Macros for unimplemented APIs stubs.
 *
 */



#define API_name(api_name) api_name

#define API_decl(api_name) long APIENTRY API_name(api_name)

#ifdef DEBUG
#define API_body(api_name, return_value) \
    const char api_string[] = #api_name; \
    UNIMP_MESSAGE \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#else
#define API_body(api_name, return_value) \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value);
#endif

#ifdef DEBUG
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    const char api_string[] = #api_name; \
    DebugPrintf(AttentionMessage); \
    DEBUG_OOPS \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#else
#define APISTUB_(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED); \
    return(return_value); \
}
#endif

#define APISTUB_0(api_name, return_value) \
API_decl(api_name) (VOID) \
{ \
API_body(api_name, return_value) \
}

#define APISTUB_1(api_name, return_value) \
API_decl(api_name) ( \
    int p1 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
}

#define APISTUB_2(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
}

#define APISTUB_3(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
}

#define APISTUB_4(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
}

#define APISTUB_5(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
}

#define APISTUB_6(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
}

#define APISTUB_7(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
}

#define APISTUB_8(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
}

#define APISTUB_9(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
}

#define APISTUB_10(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
}

#define APISTUB_11(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
}

#define APISTUB_12(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
}

#define APISTUB_13(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
}

#define APISTUB_14(api_name, return_value) \
API_decl(api_name) ( \
    int p1, \
    int p2, \
    int p3, \
    int p4, \
    int p5, \
    int p6, \
    int p7, \
    int p8, \
    int p9, \
    int p10, \
    int p11, \
    int p12, \
    int p13, \
    int p14 \
    ) \
{ \
API_body(api_name, return_value) \
    p1; \
    p2; \
    p3; \
    p4; \
    p5; \
    p6; \
    p7; \
    p8; \
    p9; \
    p10; \
    p11; \
    p12; \
    p13; \
    p14; \
}

/*
 * Miscelaneous declarations needed for the APIs
 */
extern void _cdecl DebugPrintf();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\uxthemeserver.h ===
//---------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// File   : UxThemeServer.h
// Version: 1.0
//---------------------------------------------------------------------------
#ifndef _UXTHEMESERVER_H_                   
#define _UXTHEMESERVER_H_                   
//---------------------------------------------------------------------------
#include <uxtheme.h> 
//---------------------------------------------------------------------------
// These functions are used by the theme server
//---------------------------------------------------------------------------

THEMEAPI_(void *) SessionAllocate (HANDLE hProcess, DWORD dwServerChangeNumber, void *pfnRegister, 
                                   void *pfnUnregister, void *pfnClearStockObjects, DWORD dwStackSizeReserve, DWORD dwStackSizeCommit);
THEMEAPI_(void)   SessionFree (void *pvContext);
THEMEAPI_(int)    GetCurrentChangeNumber (void *pvContext);
THEMEAPI_(int)    GetNewChangeNumber (void *pvContext);
THEMEAPI_(void)   ThemeHooksInstall (void *pvContext);
THEMEAPI_(void)   ThemeHooksRemove (void *pvContext);
THEMEAPI_(void)   MarkSection (HANDLE hSection, DWORD dwAdd, DWORD dwRemove);
THEMEAPI_(BOOL)   AreThemeHooksActive (void *pvContext);

THEMEAPI ThemeHooksOn (void *pvContext);
THEMEAPI ThemeHooksOff (void *pvContext);
THEMEAPI SetGlobalTheme (void *pvContext, HANDLE hSection);
THEMEAPI GetGlobalTheme (void *pvContext, HANDLE *phSection);
THEMEAPI LoadTheme (void *pvContext, HANDLE hSection, HANDLE *phSection, LPCWSTR pszName, LPCWSTR pszColor, LPCWSTR pszSize);
THEMEAPI InitUserTheme (BOOL fPolicyCheckOnly);
THEMEAPI InitUserRegistry (void);
THEMEAPI ReestablishServerConnection (void);

//---------------------------------------------------------------------------
#endif // _UXTHEMESERVER_H_                               
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\varutil.h ===
#ifndef _VARUTIL_H_
#define _VARUTIL_H_

// -------------------------------------------------------------------
// ANSI/UNICODE-neutral prototypes

STDAPI VariantChangeTypeForRead(VARIANT *pvar, VARTYPE vtDesired);

STDAPI_(LPITEMIDLIST) VariantToIDList(const VARIANT *pv);
STDAPI_(BOOL) VariantToBuffer(const VARIANT* pvar, void *pv, UINT cb);
STDAPI_(BOOL) VariantToGUID(const VARIANT *pvar, GUID *pguid);
STDAPI_(LPCWSTR) VariantToStrCast(const VARIANT *pvar);
STDAPI InitVariantFromBuffer(VARIANT *pvar, const void *pv, UINT cb);
STDAPI InitVariantFromIDList(VARIANT* pvar, LPCITEMIDLIST pidl);
STDAPI InitVariantFromGUID(VARIANT *pvar, REFGUID guid);
STDAPI InitBSTRVariantFromGUID(VARIANT *pvar, REFGUID guid);
STDAPI InitVariantFromStrRet(STRRET *pstrret, LPCITEMIDLIST pidl, VARIANT *pv);
STDAPI InitVariantFromFileTime(const FILETIME *pft, VARIANT *pv);

STDAPI_(BOOL) VariantToBOOL(VARIANT varIn);
STDAPI_(int) VariantToInt(VARIANT varIn);
STDAPI_(UINT) VariantToUINT(VARIANT varIn);
STDAPI InitVariantFromUINT(VARIANT *pvar, UINT ulVal);
STDAPI InitVariantFromInt(VARIANT *pvar, int lVal);

// -------------------------------------------------------------------
// ANSI- and UNICODE-specific prototypes

STDAPI_(BSTR) SysAllocStringA(LPCSTR);

STDAPI StringToStrRetW(LPCWSTR pszName, STRRET *pStrRet);

STDAPI_(void) DosTimeToDateTimeString(WORD wDate, WORD wTime, LPWSTR pszText, UINT cchText, int fmt);

STDAPI_(LPTSTR) VariantToStr(const VARIANT *pvar, LPWSTR pszBuf, int cchBuf);

STDAPI InitVariantFromStr(VARIANT *pvar, LPCWSTR psz);

STDAPI QueryInterfaceVariant(VARIANT v, REFIID riid, void **ppv);

// -------------------------------------------------------------------
// TCHAR-version defines

#ifdef UNICODE

#define SysAllocStringT(psz)        SysAllocString(psz)

#else // UNICODE

#define SysAllocStringT(psz)        SysAllocStringA(psz)

#endif // UNICODE

#endif // _VARUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\wutilsp.h ===
#define MAX_PRN_PAGES 10

//
// This data structure is privately shared with 
// prtprop.c in SHELLDLL
// prt16.c in LIBRARY
//
typedef struct // apg
{
    DWORD cpages;
    HPROPSHEETPAGE ahpage[MAX_PRN_PAGES];
} PAGEARRAY, FAR * LPPAGEARRAY;

// thunk from shell232.dll -> shell.dll
VOID WINAPI CallAddPropSheetPages16(LPFNADDPROPSHEETPAGES lpfn16, LPVOID hdrop, LPPAGEARRAY papg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\validate.h ===
#ifndef _validate_h_
#define _validate_h_

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT_PTR)(cch))) ? \
    (TraceMsgA(TF_ERROR, "invalid LPWSTR pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs code pointer - %#08lx", (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs read buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (TraceMsgA(TF_ERROR, "invalid %hs write buffer pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (TraceMsgA(TF_ERROR, "invalid flags set - %#08lx", ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (TraceMsgA(TF_ERROR, "invalid PIDL pointer - %#08lx", (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (TraceMsgA(TF_ERROR, "invalid size - is %#08lx, expected %#08lx", (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT_PTR)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT_PTR)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid H" #type " - %#08lx", (hnd)), FALSE))

#else

#define IS_VALID_HANDLE(hnd, type) \
   (IsValidH##type(hnd))

#endif

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (TraceMsgA(TF_ERROR, "invalid %hs pointer - %#08lx", (LPCSTR)#type" *", (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)


#if !defined(NO_SHELL_VALIDATION)

BOOL IsValidPathA(LPCSTR pcszPath);
BOOL IsValidPathW(LPCWSTR pcszPath);

BOOL IsValidPathResultA(HRESULT hr, LPCSTR pcszPath, UINT cchPathBufLen);
BOOL IsValidPathResultW(HRESULT hr, LPCWSTR pcszPath, UINT cchPathBufLen);

BOOL IsValidExtensionA(LPCSTR pcszExt);
BOOL IsValidExtensionW(LPCWSTR pcszExt);

BOOL IsValidIconIndexA(HRESULT hr, LPCSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);
BOOL IsValidIconIndexW(HRESULT hr, LPCWSTR pcszIconFile, UINT cchIconFileBufLen, int niIcon);

BOOL IsFullPathA(LPCSTR pcszPath);
BOOL IsFullPathW(LPCWSTR pcszPath);

BOOL IsStringContainedA(LPCSTR pcszBigger, LPCSTR pcszSuffix);
BOOL IsStringContainedW(LPCWSTR pcszBigger, LPCWSTR pcszSuffix);

#ifdef UNICODE
#define IsValidPath         IsValidPathW
#define IsValidPathResult   IsValidPathResultW
#define IsValidExtension    IsValidExtensionW
#define IsValidIconIndex    IsValidIconIndexW
#define IsFullPath          IsFullPathW
#define IsStringContained   IsStringContainedW
#else
#define IsValidPath         IsValidPathA
#define IsValidPathResult   IsValidPathResultA
#define IsValidExtension    IsValidExtensionA
#define IsValidIconIndex    IsValidIconIndexA
#define IsFullPath          IsFullPathA
#define IsStringContained   IsStringContainedA
#endif

BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

#define IsValidHEVENT       IsValidHANDLE
#define IsValidHGLOBAL      IsValidHANDLE
#define IsValidHFILE        IsValidHANDLE
#define IsValidHINSTANCE    IsValidHANDLE
#define IsValidHICON        IsValidHANDLE
#define IsValidHKEY         IsValidHANDLE
#define IsValidHMODULE      IsValidHANDLE
#define IsValidHPROCESS     IsValidHANDLE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

// The next few functions must declare the structure types explicitly
// so we don't need to worry about whether <shlobj.h> and/or <comctrlp.h>
// was included before or after us.
#include <shtypes.h>

BOOL
IsValidPIDL(
    LPCITEMIDLIST pidl);

BOOL
IsValidHDPA(
    struct _DPA *hdpa);

BOOL
IsValidHDSA(
    struct _DSA *hdsa);

#endif // NO_SHELL_VALIDATION

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\windisk.h ===
/*
 * PLEASE NOTE: WINDISK is the file "WINDISK.CPL", this means
 *		you cannot implicit link to these APIs by simply
 *		linking with WINDISK.LIB. This is because KERNEL
 *		will only implicit link to module file names with
 *		the .DLL or .EXE extensions.
 *
 *		To use these APIs you need to LoadLibrary("WINDISK.CPL")
 *		and then use GetProcAddress.
 *
 *		  WDFMTDRVPROC lpfnFmtDrv;
 *		  HINSTANCE wdInst;
 *
 *		  wdInst = LoadLibrary("WINDISK.CPL");
 *		  if (wdInst) {
 *		    lpfnFmtDrv = (WDFMTDRVPROC)GetProcAddress(wdInst,"WinDisk_FormatDrive");
 *		    if (HIWORD(lpfnFmtDrv)) {
 *		      switch ((*lpfnFmtDrv)(hwnd, drive, WD_FMTID_DEFAULT, WD_FMT_OPT_FULL)) {
 *
 *			  case WD_FMT_ERROR:
 *
 *			  ...
 *
 *		      }
 *		      FreeLibrary(wdInst);
 *		    } else {
 *		      FreeLibrary(wdInst);
 *		      goto NoLib;
 *		    }
 *		  } else {
 *		NoLib:
 *
 *		WINDISK.LIB is provided for completeness only (and also
 *		allows you to figure out the ordinal, note that
 *		GetProcAddress "by name" is recommended however).
 */

/*
 * The WinDisk_FormatDrive API provides access to the WINDISK
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *		 NOTE: The special value WD_FMTID_DEFAULT means "use the
 *		       default format specified by the DMaint_FormatDrive
 *		       engine". If you want to FORCE a particular format
 *		       ID "up front" you will have to call
 *		       DMaint_GetFormatOptions yourself before calling
 *		       this to obtain the valid list of phys format IDs
 *		       (contents of the PhysFmtIDList array in the
 *		       FMTINFOSTRUCT).
 *     options = There is currently only one option bit defined
 *
 *		  WD_FMT_OPT_FULL
 *
 *		 The normal defualt in the WINDISK format dialog is
 *		 "Quick Format", setting this option bit indicates that
 *		 the caller wants to start with FULL format selected
 *		 (this is useful for folks detecting "unformatted" disks
 *		 and wanting to bring up the format dialog).
 *
 *		 All other bits are reserved for future expansion and
 *		 must be 0.
 *
 *		 Please note that this is a bit field and not a value
 *		 and treat it accordingly.
 *
 *   RETURN
 *	The return is either one of the WD_FMT_* values, or if the
 *	returned DWORD value is not == to one of these values, then
 *	the return is the physical format ID of the last succesful
 *	format. The LOWORD of this value can be passed on subsequent
 *	calls as the fmtID parameter to "format the same type you did
 *	last time".
 *
 */
DWORD WINAPI WinDisk_FormatDrive(HWND hwnd, WORD drive, WORD fmtID,
				 WORD options);

typedef DWORD (CALLBACK* WDFMTDRVPROC)(HWND,WORD,WORD,WORD);

//
// Special value of fmtID which means "use the default format"
//
#define WD_FMTID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define WD_FMT_OPT_FULL     0x0001

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_FMT_ERROR	0xFFFFFFFFL	// Error on last format, drive may be formatable
#define WD_FMT_CANCEL	0xFFFFFFFEL	// Last format was canceled
#define WD_FMT_NOFORMAT 0xFFFFFFFDL	// Drive is not formatable


/*
 * The WinDisk_CheckDrive API provides access to the WINDISK
 *   Check Disk dialog. This allows apps which want to check disks
 *   to bring up the same dialog that WINDISK does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FixDrive
 *   engine.
 *
 *   NOTE that the check will not start till the user pushes the
 *   start button in the dialog unless the CHKOPT_AUTO option is set.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *     options = These options basically coorespond to the check boxes
 *		 in the Advanced Options dialog. See CHKOPT_ defines
 *		 below.
 *     DrvList = This is a DWORD bit field which indicates the 0 based
 *		 drive numbers to check. Bit 0 = A, Bit 1 = B, ...
 *		 For use on this API at least one bit must be set (if
 *		 this argument is 0, the call will return WD_CHK_NOCHK).
 *
 *   RETURN
 *	The return is either one of the WD_CHK_* values.
 *
 */
DWORD WINAPI WinDisk_CheckDrive(HWND hwnd, WORD options, DWORD DrvList);


typedef DWORD (CALLBACK* WDCHKDRVPROC)(HWND,WORD,DWORD);

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define WD_CHK_ERROR	0xFFFFFFFFL	// Fatal Error on check
#define WD_CHK_CANCEL	0xFFFFFFFEL	// Check was canceled
#define WD_CHK_NOCHK	0xFFFFFFFDL	// At least one Drive is not "checkable"
#define WD_CHK_SMNOTFIX 0xFFFFFFFCL	// Some errors were not fixed

//
// Option bits
//
// IMPORTANT NOTE: These are set up so that the default setting is 0
//		   for all bits WITH ONE EXCEPTION. Currently the default
//		   setting has the CHKOPT_XLCPY bit set......
//
// Also note that specification of invalid combonations of bits (for example
// setting both CHKOPT_XLCPY and CHKOPT_XLDEL) will result in very random
// behavior.
//
#define CHKOPT_REP	       0x0001	// Generate detail report
#define CHKOPT_RO	       0x0002	// Run in preview mode
#define CHKOPT_NOSYS	       0x0004	// Surf Anal don't check system area
#define CHKOPT_NODATA	       0x0008	// Surf Anal don't check data area
#define CHKOPT_NOBAD	       0x0010	// Disable Surface Analysis
#define CHKOPT_LSTMF	       0x0020	// Convert lost clusters to files
#define CHKOPT_NOCHKNM	       0x0040	// Don't check file names
#define CHKOPT_NOCHKDT	       0x0080	// DOn't check date/time fields
#define CHKOPT_INTER	       0x0100	// Interactive mode
#define CHKOPT_XLCPY	       0x0200	// Def cross link resolution is COPY
#define CHKOPT_XLDEL	       0x0400	// Def cross link resolution is DELETE
#define CHKOPT_ALLHIDSYS       0x0800	// All HID SYS files are unmovable
#define CHKOPT_NOWRTTST        0x1000	// Surf Anal no write testing.
#define CHKOPT_DRVLISTONLY     0x4000	// Normaly all drives in the system
					// are shown in the drive list box
					// and those on the DrvList are selected
					// This option says put only the drives
					// in DrvList in the list box and
					// disable the control
#define CHKOPT_AUTO	       0x8000	// Auto push start button

/*
 * The WinDisk_GetBigDriveBM API provides access to the drive bitmaps
 *   WINDISK uses in its main drive dialogs.
 *
 *   These bitmaps are intended for dialogs, and are intended
 *   to have a "chart" drawn on top of them. WINDISK draws
 *   the Used/Free chart. This chart is intended to look like
 *   the disk inside the drive.
 *
 *   These bitmaps are placed on a background of COLOR_DIALOG. There
 *   is no way to change this mapping color.
 *
 *   The returned HBITMAP belongs to the calling app, it is up to the
 *   caller to call DeleteObject on it to free it.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to get
 *		 the drive bitmap of.
 *     lpChrt  -> an array of 9 words whose format and meaning
 *		  depends on the returned "chart style" type
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is 0 if the bitmap could not be loaded (memory or
 *	invalid drive).
 *
 *	If the return is non-zero, the LOWORD is an HBITMAP,
 *	and the HIWORD is a "chart style" ID which defines the
 *	format of the data placed at lpChrt and the style for
 *	the chart placed on top of the bitmap by WINDISK.
 *
 *	 USETYPE_NONE	is for never-writable drives (like CD-ROM).
 *			lpChrt data is not used.
 *	 USETYPE_ELLIPS is for circular type drives (Fixed,Floppy).
 *	 USETYPE_BARH	is a horizontal parallelogram (RAMDrive).
 *	 USETYPE_BARV	is a verticle parallelogram.
 *
 * lpChrt[0] word is the "3-D effect" height/width for the parallelogram or
 *   ellips. NOTE that the 3-D effect is disabled if the height/width
 *   is 0. Also note that with 3-D effect disabled, the parallelogram
 *   can be turned into a rectangle.
 *
 * For USETYPE_ELLIPS, the next four words (lpChrt[1],lpChrt[2],lpChrt[3]
 *   and lpChrt[4]) form a RECT structure which defines the bounding
 *   rect for the ellips (including the 3-D effect). This RECT is in
 *   coordinates of the returned bitmap (0,0 corresponds to the top
 *   leftmost pixel of the bitmap).
 *
 * For USETYPE_BARH or USETYPE_BARV the 8 words starting at lpChrt[1]
 *   are four POINT structures which define a parallelogram for the
 *   chart (NOT including the 3-D effect).
 *
 *    POINT 0 is at lpChrt[1]
 *    POINT 1 is at lpChrt[3]
 *    POINT 2 is at lpChrt[5]
 *    POINT 3 is at lpChrt[7]
 *
 *    the "3-D->" in the following indicate the sides that the 3-D effect
 *    is drawn on. And the numbers are the point array
 *    indexes.
 *
 *	 USETYPE_BARH (0.y)==(1.y) and (3.y)==(2.y)
 *
 *	       0 _____________ 1
 *		 \ 	      \
 *	    3-D-> \ 	       \
 *		   \ 		\
 *		  3 ------------- 2
 *			  ^
 *			 3-D
 *
 *	 USETYPE_BARV (0.x)==(3.x) and (1.x)==(2.x)
 *
 *		     1
 *		  /|
 *		 / |
 *		/  |
 *	     0 |   |
 *	       |   |
 *	       |   | <- 3-D
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   |
 *	       |   | 2
 *	       |  /
 *	       | / <- 3-D
 *	       |/
 *
 *	       3
 *
 */
DWORD WINAPI WinDisk_GetBigDriveBM(WORD drive, LPWORD lpChrt, WORD options);

typedef DWORD (CALLBACK* WDGETBDBMPROC)(WORD,LPWORD,WORD);

//
// HIWORD return "chart type" values
//
#define USETYPE_ELLIPS	0
#define USETYPE_BARV	1
#define USETYPE_BARH	2
#define USETYPE_NONE	3

/*
 * The WinDisk_PropSheet API provides access to the main drive
 *   dialog.
 *
 *   This API is intended for the SHELL so it can bring up a
 *   drive property sheet.
 *
 *   PARAMETERS
 *
 *     drive   = The 0 based (A: == 0) drive number of the drive to bring
 *		 up the property dialog for.
 *     hwnd    = The HWND which will own the dialog
 *     options = There are currently no options defined this param should
 *		 be zero. This field is reserved for future expansion.
 *
 *   RETURN
 *	The return is -2 if the drive number is invalid.
 *	Else the return is the return from a DialogBox call to bring
 *	up the dialog. NOTE that -1 means that the DialogBox failed.
 *
 */
int WINAPI WinDisk_PropSheet(int drive, HWND hwndpar, WORD options);

typedef int (CALLBACK* WDPROPSHEET)(int,HWND,WORD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\w4warn.h ===
/*----------------------------------------------------------------------------
*  Note that we don't want to use a single line comment before the warning is
*   disabled.
*
*   Microsoft Windows
*   Copyright (C) Microsoft Corporation, 1992 - 2000.
*
*   File:       w4warn.h
*
*   Contents:   #pragmas to adjust warning levels.
*
*---------------------------------------------------------------------------*/

/*
 *   Level 4 warnings to suppress.
 */

#pragma warning(disable:4001) /* nonstandard extension 'extension' was used                            */
#pragma warning(disable:4097) /* typedef name 'type' used as synonym for class 'class'                 */
#pragma warning(disable:4100) /* unreferenced formal parameter                                         */
#pragma warning(disable:4115) /* named type definition in parentheses                                  */
#pragma warning(disable:4134) /* conversion between pointers to members of same class                  */
#pragma warning(disable:4152) /* nonstandard extension, function/data pointer conversion in expression */
#pragma warning(disable:4200) /* nonstandard extension used : zero-sized array in struct/union         */
#pragma warning(disable:4201) /* nonstandard extension used : nameless struct/union                    */
#pragma warning(disable:4204) /* nonstandard extension used : non-constant aggregate initializer       */
#pragma warning(disable:4209) /* nonstandard extension used : benign typedef redefinition              */
#pragma warning(disable:4214) /* nonstandard extension used : bit field types other than int           */
#pragma warning(disable:4505) /* unreferenced local function has been removed                          */
#pragma warning(disable:4511) /* 'class' : copy constructor could not be generated                     */
#pragma warning(disable:4512) /* 'class': assignment operator could not be generated                   */
#pragma warning(disable:4514) /* 'function' : unreferenced inline function has been removed            */
#pragma warning(disable:4552) /* operator has no effect; expected operator with side-effect            */
#pragma warning(disable:4553) /* operator has no effect; did you intend '='?                           */
#pragma warning(disable:4705) /* statement has no effect                                               */
#pragma warning(disable:4710) /* function call not expanded                                            */
#pragma warning(disable:4711) /* function 'function' selected for inline expansion                     */
#pragma warning(disable:4068) /* unknown pragma */
/*
 * Warning 4244 is benign more often than not, so if you don't want it then
 * uncomment this to filter out those errors.
 *
 */
#pragma warning(disable:4244) /* conversion from 'type' to 'type', possible loss of data               */


/*
 * This helps to track down "Illegal attempt to instantiate abstract class" messages
 */
#pragma warning(error:4259) /* pure virtual function not defined                                       */

#pragma warning(error:4102) /* 'label' : unreferenced label                                            */

/*
 *   Level 4 warnings that we want treated as level 3 warnings.
 */
#ifndef DEBUG
#pragma warning(3:4127) /* conditional expression is constant                                          */
#else
// Too many places w/ ASSERT(FALSE); which will trigger this
#pragma warning(disable:4127) /* conditional expression is constant                                    */
#endif
#pragma warning(3:4702) /* unreachable code                                                            */
#pragma warning(3:4706) /* assignment within conditional expression                                    */

#pragma warning(disable:4041) /* compiler limit reached: terminating browser output                    */

#ifdef _MAC
#pragma warning(disable:4229) /* anachronism used : modifiers on data are ignored                      */
#pragma warning(disable:4798) /* pcode: constructors and destructors have native code generated        */
#endif

#ifdef _M_IA64
#pragma warning(disable:4268) /* 'variable' : 'const' static/global data initialized with compiler generated default constructor fills the object with zeros */
#endif

/*
 * VC6.0 temporary hack
 */

/*
#pragma warning(disable:4189) // local variable initialized but not used 
#pragma warning(disable:4701) // local variable used and may not have been initialized
#pragma warning(disable:4096) // __cdecl must be used with ...
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emocii.h ===
/*****************************************************************************
    emocii.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    OpCode Interpreter Instruction definition file

*****************************************************************************/

#ifndef EMOCII_H
#define EMOCII_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

// Define "Push Immediate" operations
#define ociiImmLong         (-1)                        // Push literal long
#define ociiImmULong        (-2)                        // Push literal ulong
#define ociiImmShort        (-3)                        // Push literal short
#define ociiImmUShort       (-4)                        // Push literal ushort
#define ociiImmChar         (-5)                        // Push literal char
#define ociiImmUChar        (-6)                        // Push literal uchar
#define ociiImmFloat        (-7)                        // Push literal float
#define ociiStackValue      (-8)                        // Push val from stack
#define ociiStackAddr       (-9)                        // Push addr from stack
#define ociiGlobalValue     (-10)                       // Push global value
#define ociiGlobalAddr      (-11)                       // Push addr of global
#define ociiEventValue      (-12)                       // Push event value
#define ociiEventAddr       (-13)                       // Push event address
#define ociiImmSz           (-14)                       // Push ptr to string
#define ociiImmRg           (-15)                       // Push ptr to array

#define ociiRulFirst        55                          // 1st emruloci.h fn

// Define builtin functions
#define ociiDelayGoToDirul  55                          // DelayGoToDirul()
#define ociiSignal          56                          // Signal a node
#define ociiSignalFrom      57                          // Signal node from 2nd
#define ociiRulParams       58                          // Set rulebase params
#define ociiDefEvent        59                          // Define an event
#define ociiDefRule         60                          // Define a rule
#define ociiMapEvalLevels   61                          // Map levels for oci


#define ociiUserFirst       62                          // 1st User-defined fn


// Define function argument "counts" that are not fixed
#define ocadNonEval         (-3)                        // Non-evaluating fn
#define ocadVarArgs         (-4)                        // Var-args function


/* M  S  O  O  C  I  I */
/*----------------------------------------------------------------------------
    %%Type: MSOOCII
    %%Contact: daleg

    Interpreter instruction definition.
----------------------------------------------------------------------------*/

typedef short MSOOCII;                                  // Interp instr

#define MSOOCV long                                     // Interp ret value
//typedef long MSOOCV;                                  // Interp ret value

typedef signed char MSOOCAD;                            // Arg descriptor


// Return whether the instruction pointer refers to a variable
#define FVarLpocii(pocii) \
            (*pocii == ociiEventValue)


// Define data types: these must have same order as access functions below
typedef enum
    {
    ocdtChar    =   0,  //  0
    ocdtUChar,          //  1
    ocdtShort,          //  2
    ocdtUShort,         //  3
    ocdtInt,            //  4
    ocdtUInt,           //  5
    ocdtLong,           //  6
    ocdtULong,          //  7
    ocdtFloat,          //  8
    ocdtDouble,         //  9
    ocdtLDouble,        //  10
    ocdtPointer,        //  11
    ocdtVoid,           //  12
    ocdtVarArg          //  13              (Take anything)
    } OCDT;


/*----------------------------------------------------------------------------
    Interpreter op-code value for functions.
    This must be maintained in the order that the functions will appear
    in the op-code v-table.
----------------------------------------------------------------------------*/

typedef enum
    {
    ipfnOcv_log_and = 0,                    //  0
    ipfnOcv_log_or,                         //  1
    ipfnOcv_log_not,                        //  2
    ipfnOcv_less_than,                      //  3
    ipfnOcv_less_eql,                       //  4
    ipfnOcv_eql,                            //  5
    ipfnOcv_gtr_eql,                        //  6
    ipfnOcv_gtr_than,                       //  7
    ipfnOcv_not_eql,                        //  8
    ipfnOcv_assign,                         //  9
    ipfnOcv_plus,                           //  10
    ipfnOcv_minus,                          //  11
    ipfnOcv_mult,                           //  12
    ipfnOcv_divide,                         //  13
    ipfnOcv_mod,                            //  14
    ipfnOcv_increment,                      //  15
    ipfnOcv_decrement,                      //  16
    ipfnOcv_unary_plus,                     //  17
    ipfnOcv_unary_minus,                    //  18
    ipfnOcv_bitwise_not,                    //  19
    ipfnOcv_bitwise_and,                    //  20
    ipfnOcv_bitwise_or,                     //  21
    ipfnOcv_bitwise_xor,                    //  22
    ipfnOcv_shift_l,                        //  23
    ipfnOcv_shift_r,                        //  24
    ipfnOcv_dereference,                    //  25
    ipfnOcv_addr_of,                        //  26
    ipfnOcv_cast_as,                        //  27
    ipfnOcv_if,                             //  28
    ipfnOcv_inline_if,                      //  29
    ipfnOcv_let,                            //  30
    ipfnOcv_progn,                          //  31
    ipfnOcv_compound_stmt,                  //  32
    ipfnOcv_get_char,                       //  33
    ipfnOcv_get_uchar,                      //  34
    ipfnOcv_get_short,                      //  35
    ipfnOcv_get_ushort,                     //  36
    ipfnOcv_get_int,                        //  37
    ipfnOcv_get_uint,                       //  38
    ipfnOcv_get_long,                       //  39
    ipfnOcv_get_ulong,                      //  40
    ipfnOcv_get_float,                      //  41
    ipfnOcv_get_double,                     //  42
    ipfnOcv_get_ldouble,                    //  43
    ipfnOcv_set_char,                       //  44
    ipfnOcv_set_uchar,                      //  45
    ipfnOcv_set_short,                      //  46
    ipfnOcv_set_ushort,                     //  47
    ipfnOcv_set_int,                        //  48
    ipfnOcv_set_uint,                       //  49
    ipfnOcv_set_long,                       //  50
    ipfnOcv_set_ulong,                      //  51
    ipfnOcv_set_float,                      //  52
    ipfnOcv_set_double,                     //  53
    ipfnOcv_set_ldouble,                    //  54
    } OCIT;

#define ipfnOcvGetTypeFirst         ipfnOcv_get_char
#define ipfnOcvSetTypeFirst         ipfnOcv_set_char

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMOCII_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\xml.h ===
/*****************************************************************************\
    FILE: xml.h

    DESCRIPTION:
        These are XML DOM wrappers that make it easy to pull information out
    of an XML file or object.

    BryanSt 10/12/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _XML_H
#define _XML_H



////////////////////////////////
//  XML Helpers
////////////////////////////////
STDAPI XMLDOMFromBStr(BSTR bstrXML, IXMLDOMDocument ** ppXMLDoc);
STDAPI XMLNode_GetChildTagTextValue(IN IXMLDOMNode * pXMLNode, IN BSTR bstrChildTag, OUT BSTR * pbstrValue);
STDAPI XMLElem_VerifyTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName);
STDAPI XMLNode_GetTagText(IN IXMLDOMNode * pXMLNode, OUT BSTR * pbstrValue);
STDAPI XMLNode_GetChildTag(IN IXMLDOMNode * pXMLNode, IN LPCWSTR pwszTagName, OUT IXMLDOMNode ** ppChildNode);
STDAPI XMLElem_GetElementsByTagName(IN IXMLDOMElement * pXMLElementMessage, IN LPCWSTR pwszTagName, OUT IXMLDOMNodeList ** ppNodeList);
STDAPI XMLNodeList_GetChild(IN IXMLDOMNodeList * pNodeList, IN DWORD dwIndex, OUT IXMLDOMNode ** ppXMLChildNode);




#endif // _XML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\vdate.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: vdate.h - Debug argument validation helpers
//
// History:
//  06-16-94    Davepl  Created
//
//---------------------------------------------------------------------------

#ifdef DEBUG

__inline void FUNC_VDATEINPUTBUF(void * pBuffer,
                                 size_t cElementSize,
                                 size_t cCount,
                                 int    iLine,
                                 char * pszFile)
{
    if (IsBadWritePtr(pBuffer, cElementSize * cCount))
    {
        char sazOutput[MAX_PATH * 2];
        wnsprintfA(sazOutput, SIZECHARS(sazOutput), "Buffer failed validation at line %d in %s\n", iLine, pszFile);
        OutputDebugStringA(sazOutput);
        RIP(FALSE);
    }
}

#define VDATEINPUTBUF(ptr, type, count) FUNC_VDATEINPUTBUF(ptr,                 \
                                                           sizeof(type),        \
                                                           count,               \
                                                           __LINE__,            \
                                                           __FILE__)

#else

#define VDATEINPUTBUF(ptr, type, const)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emrulini.h ===
/*****************************************************************************
    emrulini.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    General Rule-Network Propagation Engine initialization types.

*****************************************************************************/

#ifndef EMRULINI_H
#define EMRULINI_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

/*************************************************************************
    Types:

    rullims     Rule limits/sizes structure.
    ruldef      Rule node initial definition structure.
    rulinit     Rule initialization structure.

 *************************************************************************/


/* R  U  L  L  I  M  S */
/*----------------------------------------------------------------------------
    %%Structure: RULLIMS
    %%Contact: daleg

    Rule base limits structure.
----------------------------------------------------------------------------*/

typedef struct _RULLIMS
    {
    short               irulRulesMax;                   // Number of nodes
    short               irulVarsMax;                    // Number of var nds
    short               rulevtMax;                      // Num of event_types
    short               rulevlMax;                      // Num of eval levels
    short               rulgGroupMax;                   // Num dependency grps
    short               rulgRegularMax;                 // Num non-context grps
    short               clprulDependMax;                // Num forward depends
    short               clprulBackDependMax;            // Num backwrd depends
    short               ckwdMax;                        // Number of KWD recs
    short               cchKwdTextMax;                  // Len kwd text buffer
    unsigned short      cchNamesMax;                    // Name/string buf len
    } RULLIMS;



/* R  U  L  D  E  F */
/*----------------------------------------------------------------------------
    %%Structure: RULDEF
    %%Contact: daleg

    Rule base node initialization structure.
----------------------------------------------------------------------------*/

typedef struct _RULDEF
    {
    short               rulevl;                         // Event_type/Level
    short               bwDepend;                       // Fwd depend offset
    short               bwBackDepend;                   // Bkwd depend offset
    const XCHAR        *xstzKeywordName;                // Keyword string
    } RULDEF;



/* L  P  F  N  R  U  L  C  X  T */
/*----------------------------------------------------------------------------
    %%Structure: LPFNRULCXT
    %%Contact: daleg

    Rule base Context group callback function
----------------------------------------------------------------------------*/

typedef void (* LPFNRULCXT) (int irul, struct _RULCXT *lprulcxt);




/* R  U  L  I  N  I  T */
/*----------------------------------------------------------------------------
    %%Structure: RULINIT
    %%Contact: daleg

    Rule base global initialization structure.
----------------------------------------------------------------------------*/

typedef int (WIN_CALLBACK *PFNEVAL)(short irul);        // Rule Eval function

typedef struct _RULINIT
    {
    const RULLIMS      *lprullims;                      // Rulebase limits
    const RULDEF       *lprulinit;                      // Rulebase def
    const short        *rgrulevlRulevt;                 // Event_type eval lvls
    const short        *rgirultkRulevtHistoryMax;       // Evt history depths
    const short        *lprulgAppendTo;                 // Group linkages
    const short        *lprulgAppendedFrom;             // Group linkages
    const LPFNRULCXT   *lplpfnrulcxt;                   // Context grp callbks
    const short* const *lplpirulDependents;             // Dependent lists
    const short* const *lplpirulBackDependsOn;          // DependsOn lists
    PFNEVAL             lpfnEvalRule;                   // Evaluate rule code
    MSOKWTB           **rgpkwtbKeyTables;               // Keyword tables
    const char * const *lpszRulNames;                   // Node names
    } RULINIT;


typedef int (WIN_CALLBACK *LPFNRulinit)(struct _RULS *lpruls);


// Initialize pre-constructed rulebase of static nodes
MSOAPI_(int) MsoFInitStaticRuls(
    struct _RULS       *pruls,
    struct _RULS       *prulsInit
    );


// Create and initialize rulebase of static nodes from compressed rulebase
MSOAPI_(int) MsoFInitCompressedRulebase(
    struct _RULS       *lpruls,
    const RULINIT      *lprulinit
    );


#ifndef pNil
#define pNil    NULL
#endif /* !pNil */

#define IN_DATASEG
#define NOT_IN_DATASEG

// Rule node type flags: shared with rule.h
#define rultRule            0x00                        // Rule
#define rultEvent           0x01                        // Event/Variable
#define rultPrimaryRule     0x02                        // Rule auto-scheduled
#define rultActionRule      0x00                        // Not really a flag
///#define rultNonTermRule  0x08
///#define rultSeqRule      0x10

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* EMRULINI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emruloci.h ===
/*****************************************************************************
    emruloci.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    Header file of Interface of Op-Code Interpreter to Rulebase.

*****************************************************************************/

#ifndef EMRULOCI_H
#define EMRULOCI_H

#include "emoci.h"
#include "emkwd.h"
#include "emrule.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


MSOAPI_(MSOOCV) MsoOcvEvalIrul(IRUL irul);              // Eval dyn rule instrs

MSOAPI_(int) MsoFReadDynOciRules(                       // Load oci file
    char               *szFilePrefix,
    int                *pdocii                          // RETURN
    );

MSOAPI_(int) MsoFLoadDynRulesPocii(                     // Load dyn rulebase
    MSOOCII            *pocii,
    int                 docii,
    MSOPFNOCI const    *rgpfn,
    MSOOCAD const      *rgocadArgDesc,
    unsigned char const*rgcbImmedArg,
    int                 ipfnMax,
    char const * const *rgpchDynNames                   // DEBUG ONLY
    );

MSOAPI_(int) MsoFCopyBaseRulRgpfnoci(MSOPFNOCI *rgpfn); // Set 1st n oci fns

MSOAPIX_(MSOOCV *) PocvOfIrul(short irul);              // Return addr of node

MSOAPI_(MSOOCV) MsoOcv_DelayGoToDirul(MSOOCV *pocvSP);  // DelayGoToDirul()

MSOAPI_(MSOOCV) MsoOcv_Signal(MSOOCV *pocvSP);          // Signal a node

MSOAPI_(MSOOCV) MsoOcv_SignalFrom(MSOOCV *pocvSP);      // Signal node from

MSOAPI_(MSOOCV) MsoOcv_RulParams(                       // Set RB params
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_MapEvalLevels(                   // map static rule lvls
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_DefEvent(                        // Define an event
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV) MsoOcv_DefRule(                         // Define a rule
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMRULOCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emutil.h ===
/*****************************************************************************
    emutil.h

    Owner: SMueller
    Copyright (c) 1997 Microsoft Corporation

    Miscellaneous event monitor utilities
*****************************************************************************/

#ifndef _EMUTIL_H
#define _EMUTIL_H

#include "emrule.h"

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

MSOCDECLAPI_(int) MsoIMatchIrul(IRUL irul, ...);
MSOAPI_(MSORULTK *) MsoPrultkFromDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkFromTokenDtki(int dtki, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkiFromTokenDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoFTokenWas(int dtkStart, int irul, MSORULTKH* ptkh);
MSOAPI_(long) MsoCpLimOfDtk(int dtk, MSORULTKH* ptkh);
MSOAPI_(int) MsoDtkFindPrevToken(int dtkStart, int irul, MSORULTKH *ptkh);

// Get cpFirst of token from index to history
#define MsoCpFirstOfDtk(dtk, ptkh) \
        (MsoPrultkFromDtk(dtk, ptkh)->cpFirst)



#ifdef DEBUG

#if defined(OFFICE_BUILD)  ||  defined(STANDALONE_WORD)

#include "msosdm.h"

MSOAPI_(const char *) MsoSzFromDlmDebug(DLM dlm);

#endif /* OFFICE_BUILD  ||  STANDALONE_WORD */

MSOAPI_(const char *) MsoSzRulName(IRUL irul);

#endif // DEBUG

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif // !_EMUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emrultk.h ===
/*****************************************************************************
    emrultk.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    Rule and Lexer-token history recording header file.

*****************************************************************************/

#ifndef EMRULTK_H
#define EMRULTK_H

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef MSOCP_DEFINED
typedef long MSOCP;                                     // Character position
#define msocpNil ((MSOCP) -1)
#define msocp0 ((MSOCP) 0)
#define msocpMax ((MSOCP) 0x7FFFFFFF)
#define MSOCP_DEFINED
#endif /* !MSOCP_DEFINED */


/*************************************************************************
    Types:

    rultk       Rule/lexer-token history record.
    rultkh      Rule/lexer-token history cache.

 *************************************************************************/


/* M  S  O  R  U  L  T  K */
/*----------------------------------------------------------------------------
    %%Structure: MSORULTK
    %%Contact: daleg

    Rule/lexer-token history record.
----------------------------------------------------------------------------*/

typedef struct _MSORULTK
    {
    void               *pObject;                        // Object, e.g. doc
    MSOCP               cpFirst;                        // First CP of token
    MSOCP               dcp;                            // CP len of token
    int                 ich;                            // Char offset of tk
    long                dich;                           // Num of chars of tk
    long                wInterval;                      // Num intervals
    int                 tk;                             // Token number
    long                lValue;                         // Token value
    } MSORULTK;


#define irultkNil   (-2)


/* M  S  O  R  U  L  T  K  H */
/*----------------------------------------------------------------------------
    %%Structure: MSORULTKH
    %%Contact: daleg

    Rule/lexer-token history cache structure.
----------------------------------------------------------------------------*/

typedef struct _MSORULTKH
    {
    MSORULTK           *rgrultkCache;                   // History record list
    int                 irultkMac;                      // Lim of allocated
    int                 irultkMin;                      // User-defined marker
    int                 irultkLim;                      // Next cache index
    int                 irultkAbsBase;                  // Absolute irultk base
    } MSORULTKH;


/* M  S  O  C  A */
/*----------------------------------------------------------------------------
    %%Structure: MSOCA
    %%Contact: daleg

    Rule/lexer text range
----------------------------------------------------------------------------*/

typedef struct _MSOCA
    {
    void               *pObject;                        // Object, e.g. doc
    long                cpFirst;                        // First char pos
    long                cpLim;                          // Lim char pos
    } MSOCA;


// Define (D)elta of a (T)o(K)en cache index
typedef int DTK;

// Define (D)elta of a (T)o(K)en cache (I)nterval
typedef int DTKI;


// Token-history cache access
#define PrultkFromIrultk(irultk, prultk) \
            (&prultk[irultk])

// Move to next cache record, wrapping around if necessary
#define IncrPrultk(pprultk, pirultk, prultkHist, irultkMax) \
            if (++(*pirultk) >= (irultkMax)) \
                { \
                (*pirultk) = 0; \
                (*pprultk) = PrultkFromIrultk(0, prultkHist); \
                } \
            else \
                (*pprultk)++;

// Move to next cache record, wrapping around if necessary
#define DecrPrultk(pprultk, pirultk, prultkHist, irultkMax) \
            if (--(*pirultk) < 0) \
                { \
                (*pirultk) += (irultkMax); \
                (*pprultk) += (irultkMax) - 1; \
                } \
            else \
                (*pprultk)--;

// Move index to next cache record, wrapping around if necessary
#define IncrPirultk(pirultk, dirultk, irultkMax) \
            if (((*pirultk) += dirultk) >= (irultkMax)) \
                (*pirultk) -= (irultkMax);

// Move index to prev cache record, wrapping around if necessary
#define DecrPirultk(pirultk, dirultk, irultkMax) \
            if (((*pirultk) -= dirultk) < 0) \
                (*pirultk) += (irultkMax);

MSORULTK *PrultkExpand(                                 // Expand cache
    MSORULTK          **pprultkCache,
    int                *pirultkMax,
    int                 irultkMax,
    int                 irultkSplit
    );

// defines
#define msodtkNotFound      30000                       // arbitrarily lg. flag


MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* EMRULTK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emdyn.c ===
/*----------------------------------------------------------------------------
    %%File: EMDYN.C
    %%Unit: Event Monitor (mntr)
    %%Contact: daleg

    Event Monitor Sample Application, Main Program.

    The purpose of this application is to demonstrate how to process events
    using the Event Monitor's Rule Compiler and rule engine.
----------------------------------------------------------------------------*/

#include "mso.h"
#include "msoem.h"

#if FEATURE_NYI // include'er file will give name
DEBUGASSERTSZ
#endif

#include "emruloci.h"

#if FEATURE_DEAD
extern MSOKWTB vkwtbEmCHAR_KEYTABLE;
#endif


#include "emact.h"
#include "msolex.h"
#if 0
#include "emtest.h"
#include "emintf.c"
#include "emfn.c"
#endif


/* F  L O A D  D Y N  E M  R U L E S */
/*----------------------------------------------------------------------------
    %%Function: FLoadDynEmRules
    %%Contact: daleg

    Load rules dynamically from a file or a data structure, depending upon
    #ifdef
----------------------------------------------------------------------------*/

#ifdef DYN_RULES_FROM_STRUCT

#include "emruli.oci"

#endif /* DYN_RULES_FROM_STRUCT */



int FLoadDynEmRules(void)
{
    int                 docii;

#ifndef DYN_RULES_FROM_STRUCT

    /* Read opcodes from a disk file */
    if (!MsoFReadDynOciRules("em", &docii))
        return fFalse;

#else /* DYN_RULES_FROM_STRUCT */

    /* Get opcodes from a structure */
    vlpruls->pociiDynRules = (PV) vrgociiEm;
    docii = IMaxRg(vrgociiEm, MSOOCII);
    vlpruls->rgpchDynNames = _rgszEmRulNames;

#endif /* !DYN_RULES_FROM_STRUCT */

#define NON_CONST_OCI_VTABLE
#ifdef NON_CONST_OCI_VTABLE
    /* Insert Mso functions into OCI vtable */
    if (!MsoFCopyBaseRulRgpfnoci(vpfnociEm))
        return fFalse;
#endif /* NON_CONST_OCI_VTABLE */

    /* Generate rulebase nodes from opcode stream */
    return MsoFLoadDynRulesPocii(vlpruls->pociiDynRules, docii,
                                 vpfnociEm, vrgocadEm,
                                 vrgcbOciArgEm, IMaxRg(vpfnociEm, MSOPFNOCI),
                                 DebugElse(vlpruls->rgpchDynNames, pNil));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\mso.h ===
/*----------------------------------------------------------------------------
    %%File: mso.h
    %%Unit: Event Monitor
    %%Contact: daleg

    Typedef file for Rules Engine of Event Monitor.
----------------------------------------------------------------------------*/

#ifndef MSO_H
#define MSO_H

#ifndef MSOEXTERN_C_BEGIN
#if defined(__cplusplus)
    #define MSOEXTERN_C extern "C"
    #define MSOEXTERN_C_BEGIN extern "C" {
    #define MSOEXTERN_C_END }
#else
    #define MSOEXTERN_C
    #define MSOEXTERN_C_BEGIN
    #define MSOEXTERN_C_END
#endif
#endif // MSOEXTERN_C_BEGIN

#define FEWER_SEGS(sz)
#define VSZASSERT       static unsigned char    vszAssertFile[] = __FILE__;

typedef long IDS;                                       // emkwd.h
#define OFC_CALLBACK        MSOAPICALLTYPE
typedef unsigned short WCHAR;
typedef unsigned short WORD;
typedef unsigned int UINT;
#ifndef _WINDEF_    // windef.h makes uchar (same as mso.h w/ -J)
typedef char BYTE;
#endif
typedef int BOOL;
typedef unsigned long DWORD;

#ifndef cbXchar
#ifndef ANSI_XCHAR
typedef unsigned short XCHAR;
#define cbXchar    2

#else /* ANSI_XCHAR */

typedef unsigned char XCHAR;
#define cbXchar    1
#endif /* !ANSI_XCHAR */
#endif /* !cbXchar */

typedef WORD LID;
typedef DWORD LCID;

#define MSOAPICALLTYPE __stdcall
#define MSOCDECLCALLTYPE __cdecl

#ifndef MSOAPI_
#define MSOAPI_(t)              t MSOAPICALLTYPE
#endif /* !MSOAPI_ */

#ifndef MSOAPIX_
#define MSOAPIX_(t)             t MSOAPICALLTYPE
#endif /* !MSOAPIX_ */

#ifndef MSOCDECLAPI_
#define MSOCDECLAPI_(t)         t MSOCDECLCALLTYPE
#endif /* !MSOCDECLAPI_ */

#ifndef MSOMACAPI_
#define MSOMACAPI_(t)   t
#endif /* !MSOMACAPI_ */

#if !defined(WIN)  &&  defined(NT)
#define WIN
#endif /* !WIN  &&  NT */

#ifdef WIN
#define Win(foo) foo
#define WinMac(win,mac) win
#define WinElse(win,foo) win
#define Nt(foo) foo
#define NtElse(nt,notnt) nt
#else
#define Win(foo)
#define WinMac(win,mac) mac
#define WinElse(win,foo) foo
#define Nt(foo)
#define NtElse(nt,notnt) notnt
#endif

#ifdef MAC
#define Mac(foo) foo
#define MacElse(mac, notmac) mac
#define NotMac(foo)
#else
#define Mac(foo)
#define MacElse(mac, notmac) notmac
#define NotMac(foo) foo
#endif

#define _MAX_PATH   260 /* max. length of full pathname */
#define MsoStrcpy strcpy
#define MsoStrcat strcat
#define MsoStrlen strlen
#define MsoSzIndexRight strrchr
#define MsoMemcpy memcpy
#define MsoMemset memset
#define MsoMemcmp memcmp
#define MsoMemmove memmove

#define MsoCchSzLen(sz)         (strlen(sz))
#define MsoCchWzLen(xsz)        (wcslen(xsz))

#define MsoRgwchToRgch(rgchFrom, cchFrom, rgchTo, cchTo) \
            (PbCopyRgb((rgchFrom), (rgchTo), (cchFrom)), (cchFrom))


MSOAPI_(WCHAR) MsoWchToUpper(WCHAR wch);

#ifdef RULE_COMPILER
#define LANGIDFROMLCID(lcid)   ((WORD  )(lcid))
#define msoStrip 0x01                                   // REVIEW PREHASH
#endif /* RULE_COMPILER */

#define MsoWzToSz(p, rgch) (p)

#ifdef STANDALONE_WORD
#include "word.h"

#define TRUE    1
#define FALSE   0

#else /* !STANDALONE_WORD */

#include <windows.h>
#include <string.h>
///#include "sys.h"

#endif /* STANDALONE_WORD */

#include <ctype.h>

_inline ChUpper(unsigned char ch)
{
    return (islower(ch) ? toupper(ch) : ch);
}

void __cdecl Fail(const char *lsz, ...);                // Print failure msg

#ifndef FReportLszProc
#define FReportLszProc(lszExtra, lszFile, line)             TRUE
#endif /* !FReportLszProc */

/* Breaks into the debugger.  Works (more or less) on all supported
    systems. */
#ifndef MAC
    #define MsoDebugBreakInline() {__asm int 3}
#else /* MAC */
    #define MsoDebugBreakInline() Debugger()
#endif /* !MAC */
#endif /* !MSO_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emkwd.h ===
/*****************************************************************************
    emkwd.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    Keyword Table header file.

*****************************************************************************/

#ifndef KWD_H


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


// Limits
#define msoipkwdMax         997                         // Size of keywd hash



#ifndef KWD_HASH_ONLY

// Limits...
#define msoikwdAllocMax     100                         // Max num KWDs/batch
#define msoichKwdAllocMax   100                         // Max # kwd chs/batch



/*************************************************************************
    Types:

    kwdf        Keyword-table entry record fixed.
    kwd         Keyword-table entry record.
    kwtb        Keyword table.

 *************************************************************************/


#ifndef TK_DEFINED
// Definition of token type returned by lexer
typedef int TK;

#define TK_DEFINED
#endif /* !TK_DEFINED */


/* M  S  O  K  W  D */
/*----------------------------------------------------------------------------
    %%Structure: MSOKWD
    %%Contact: daleg

    Keyword-table entry record, and batch-allocation record.
----------------------------------------------------------------------------*/

// Look up as a string key value
typedef struct _MSOKWDSZ
    {
    const XCHAR        *pxch;                           // String key value
    short               cch;                            // Length of kwd string
    TK                  tk;                             // Token value
    } MSOKWDSZ;


// Hash-table look up as a string key value
typedef struct _MSOKWD
    {
    const XCHAR        *pxch;                           // String key value
    short               cch;                            // Length of kwd string
    TK                  tk;                             // Token value
    struct _MSOKWD     *pkwdNext;                       // Next key in hash row
    } MSOKWD;


// Batch allocation
typedef struct _MSOKWDBLK
    {
    struct _MSOKWDBLK  *pkwdblkNext;                    // Next in chain
    MSOKWD             *pkwdRg;                         // Rg of MSOKWDs
    } MSOKWDBLK;


// Look up as an integer key value
typedef struct _MSOKWDL
    {
    long                lValue;                         // Integer key value
    TK                  tk;                             // Token value
    } MSOKWDL;


// Hash-table look up as a integer key value
typedef struct _MSOKWDLH
    {
    long                lValue;                         // Integer key value
    TK                  tk;                             // Token value
    struct _MSOKWDLH   *pkwdlhNext;                     // Next key in hash row
    } MSOKWDLH;




/* M  S  O  K  W  T  B */
/*----------------------------------------------------------------------------
    %%Structure: MSOKWTB
    %%Contact: daleg

    Keyword table record, and batch-allocation record.
    The hash table is in rgpkwdHash.  It is an array of linked lists,
    of type MSOKWD.
    The string buffer pxchBuf contains the character strings, PLUS the
    MSOKWD records of the hash table at the end.

    REVIEW: rgpkwdHash, pxchBuf and pkwdStart should be moved to the end of
    this struct to avoid allocating excess space for non-hashed keytables.
    Mso*Lookup* routines should assert that input MSOKWTB* arguments are of
    suitable type.
----------------------------------------------------------------------------*/

typedef struct _MSOKWTB
    {
    // Table data
    int                 kwtbt;                          // Keytable type
    int                 ckwdMax;                        // Num of MSOKWD recs
    MSOKWD             *pkwdUnknown;                    // Returned when !found
    void               *pvTable;                        // Hash/Binary table

    // Allocation/Init info
    unsigned char       fStaticInit;                    // Static Init-ed?
    unsigned char       fDynAlloced : 1;                // MSOKWTB mem alloced?
    unsigned char       fHashTblAlloced : 1;            // pvTable mem alloced?
    unsigned char       fSpare : 1;

    // String support
    XCHAR              *pxchBuf;                        // String buffer
    MSOKWD             *pkwdStart;                      // First MSOKWD rec

    // Extensions
    int                 cxchKwdBufRemain;               // Num avail chars
    XCHAR              *pxchKwdNext;                    // Next avail string
    MSOKWD             *pkwdNextFree;                   // Next av MSOKWD rec
    struct _MSOKWDBLK  *pkwdblkNext;                    // List of extra KWDs
    struct _MSOKWSBLK  *pkwsblkNext;                    // List of extra bufs
    } MSOKWTB;


#define msokwtbtString          0x00
#define msokwtbtInteger         0x01
#define msokwtbtHashed          0x02
#define msokwtbtStringHashed    0x02
#define msokwtbtIntegerHashed   0x03


// String buffer batch allocation
typedef struct _MSOKWSBLK
    {
    struct _MSOKWSBLK  *pkwsblkNext;                    // Next in chain
    XCHAR              *pxchBuf;                        // String buffer
    } MSOKWSBLK;


/*************************************************************************
    STRING LOOKUP
 *************************************************************************/

// Lookup keyword
#define MsoTkLookupName(pxch, cchLen, pkwtb) \
            (MsoPkwdLookupName((pxch), (cchLen), (pkwtb))->tk)

MSOAPI_(MSOKWD *) MsoPkwdLookupName(                    // Lookup keyword
    const XCHAR        *pxchStr,
    int                 cchLen,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWD *) MsoPkwdAddTkLookupName(               // Add kwd to table
    const XCHAR        *pxchStr,
    int                 cchLen,
    TK                  tk,
    MSOKWTB            *pkwtb,
    int                 fCopyStr
    );

MSOAPI_(int) MsoFRemoveTkLookupName(                    // Remove kwd from tbl
    const XCHAR        *pxchStr,
    int                 cchLen,
    MSOKWTB            *pkwtb,
    TK                 *ptk                             // RETURN
    );

MSOAPI_(void) MsoInitHashKwtb(MSOKWTB *pkwtb);          // Init a kwd hash tbl

MSOAPI_(MSOKWD *) _MsoPkwdNew(                          // Batch-alloc MSOKWDs
    int                 ikwdMax,
    MSOKWTB            *pkwtb
    );

int _FAddKwdRgchBuf(int ixchMax, MSOKWTB *pkwtb);       // Batch-alloc kwd stzs

MSOAPI_(MSOKWTB *) MsoPkwtbNew(void);                   // Create new kwd tbl

#ifdef DEBUG
void _DumpKwds(MSOKWTB *pkwtb);                         // Print kwd table
#endif /* DEBUG */


// Get a new MSOKWD record from free list
_inline MSOKWD *MsoPkwdNew(MSOKWTB *pkwtb)
{
    MSOKWD             *pkwd;

    return ((pkwtb)->pkwdNextFree
                ? (pkwd = (pkwtb)->pkwdNextFree,
                        (pkwtb)->pkwdNextFree = pkwd->pkwdNext,
                        pkwd->pkwdNext = (MSOKWD *) NULL,
                        pkwd)
                : _MsoPkwdNew(msoikwdAllocMax, (pkwtb)));
}

// Put an existing MSOKWD record onto the free list
#define MsoDiscardPkwd(pkwd, pkwtb) \
            ((pkwd)->pkwdNext = (pkwtb)->pkwdNextFree, \
                (pkwtb)->pkwdNextFree = (pkwd))

// Return address of first MSOKWD record for hash value in keyword lookup table
#define MsoPpkwdGetHashAddr(pkwtb, ikwd) \
            (&(MsoRgpkwdHashFromKwtb(pkwtb)[ikwd]))

// Return hash table from keytable
#define MsoRgpkwdHashFromKwtb(pkwtb) \
            ((MSOKWD **) (pkwtb)->pvTable)

// Return integer binary table from keytable
#define MsoPkwdlFromKwtb(pkwtb) \
            ((MSOKWDL *) (pkwtb)->pvTable)






/*************************************************************************
    INTEGER LOOKUP
 *************************************************************************/

// REVIEW: references to this function should become references to
// MsoPkwdlLookupL with an MSOKWTB
MSOAPI_(int) MsoWLookupKwdl(                            // Binary search lookup
    long                lValue,
    MSOKWDL const      *pkwdlTbl,
    int                 ikwdlMac
    );

MSOAPI_(MSOKWDL *) MsoPkwdlLookupL(                     // Nohash-lookup a long
    long                lValue,
    MSOKWTB            *pkwtb
    );

#ifdef DEBUG
#define MsoAssertKwtb(pkwtb) \
    MsoAssertKwtbSz(pkwtb, #pkwtb)
MSOAPI_(void) MsoAssertKwtbSz(MSOKWTB *pkwtb, char *szName); // Ensure sorted
#else
#define MsoAssertKwtb(pkwtb)
#endif // DEBUG

MSOAPI_(MSOKWDLH *) MsoPkwdlhLookupL(                   // Hash-lookup a long
    long                lValue,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWDLH *) MsoPkwdlhAddTkLookupL(              // Add int hash lookup
    long                lValue,
    TK                  tk,
    MSOKWTB            *pkwtb
    );

MSOAPI_(MSOKWDLH *) _MsoPkwdlhNew(int ikwdMax, MSOKWTB *pkwtb);

// Return addr of first MSOKWDLH record for hash value in keyword lookup table
#define MsoPpkwdlhGetHashAddr(pkwtb, ikwd) \
            (&(MsoRgpkwdlhFromKwtb(pkwtb)[ikwd]))

// Return hash table from keytable
#define MsoRgpkwdlhFromKwtb(pkwtb) \
            ((MSOKWDLH **) (pkwtb)->pvTable)


// Get a new MSOKWDLH record from free list
_inline MSOKWDLH *MsoPkwdlhNew(MSOKWTB *pkwtb)
{
    MSOKWDLH           *pkwdlh;

    if (pkwtb->pkwdNextFree)
        {
        pkwdlh = (MSOKWDLH *) (pkwtb)->pkwdNextFree;
        pkwtb->pkwdNextFree = (MSOKWD *) pkwdlh->pkwdlhNext;
        pkwdlh->pkwdlhNext = (MSOKWDLH *) NULL;
        return pkwdlh;
        }
    else
        return _MsoPkwdlhNew(msoikwdAllocMax, pkwtb);
}

// Put an existing MSOKWDLH record onto the free list
#define MsoDiscardPkwdlh(pkwdlh, pkwtb) \
            ((pkwdlh)->pkwdlhNext = (MSOKWDLH *) (pkwtb)->pkwdNextFree, \
                (pkwtb)->pkwdNextFree = (MSOKWD *) (pkwdlh))


#endif /* !KWD_HASH_ONLY */


#ifndef ANSI_XCHAR
#define MsoIpkwdHashPxch(pch, cch)          MsoIpkwdHashPwch(pch, cch)
#define MsoXchUpper MsoWchToUpper
#else /* ANSI_XCHAR */
#define MsoIpkwdHashPxch(pch, cch)          MsoIpkwdHashPch(pch, cch)
#define MsoXchUpper MsoChToUpper
#endif /* !ANSI_XCHAR */



/* M S O  C H  T O  U P P E R */
/*----------------------------------------------------------------------------
    %%Function: MsoChToUpper
    %%Contact: daleg

    Convert ANSI character to uppercase.
----------------------------------------------------------------------------*/

_inline unsigned char MsoChToUpper(unsigned char ch)
{
    return (islower(ch) ? (unsigned char) toupper(ch) : ch);
}


/* M S O  I P K W D  H A S H  P C H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdHashPch
    %%Contact: daleg

    Return a hash index for the given string and length, case insensitive.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdHashPch(const unsigned char *pchStr, int cchLen)
{
    /* Hash on first and last character of string, ignoring case */
    return ((MsoChToUpper(*pchStr) * 419)
                + (MsoChToUpper(*(pchStr + (cchLen - 1)/2)) * 467)
                + (MsoChToUpper(*(pchStr + cchLen - 1)) * 359))
            % msoipkwdMax;
}


/* M S O  I P K W D  H A S H  P W C H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdHashPwch
    %%Contact: daleg

    Return a hash index for the given string and length, case insensitive.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdHashPwch(const WCHAR *pwchStr, int cchLen)
{
    /* Hash on first and last character of string, ignoring case */
    return ((MsoWchToUpper(*pwchStr) * 419)
                + (MsoWchToUpper(*(pwchStr + (cchLen - 1)/2)) * 467)
                + (MsoWchToUpper(*(pwchStr + cchLen - 1)) * 359))
            % msoipkwdMax;
}


/* M S O  I P K W D L H  H A S H */
/*----------------------------------------------------------------------------
    %%Function: MsoIpkwdlhHash
    %%Contact: daleg

    Return a hash index for the given integer value.
----------------------------------------------------------------------------*/

_inline int MsoIpkwdlhHash(long lValue)
{
    return (((lValue + (lValue >> 1)) & ~0x80000000) % msoipkwdMax);
}


MSOEXTERN_C_END     // ****************** End extern "C" *********************

#define KWD_H
#endif /* !KWD_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\msoemtyp.h ===
/*****************************************************************************
    msoemtyp.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Typedef file for Rules Engine of Event Monitor.

*****************************************************************************/

#ifndef MSOEMTYP_H
#define MSOEMTYP_H

#ifndef MSO_H
#pragma message ("MsoEMTyp.h file included before Mso.h.  Including Mso.h.")
#include "mso.h"
#endif

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef MSOCP_DEFINED
typedef long MSOCP;                                     // Character position
#define msocpNil ((MSOCP) -1)
#define msocp0 ((MSOCP) 0)
#define msocpMax ((MSOCP) 0x7FFFFFFF)
#define MSOCP_DEFINED
#endif /* !MSOCP_DEFINED */


// Define Bit Field type
typedef unsigned short MSOBF;


#if !defined(WORD_BUILD)  &&  !defined(WIN_CALLBACK)
#define WIN_CALLBACK    OFC_CALLBACK
#endif /* !WORD_BUILD */


// Character Byte Manipulators
#define MsoLowByteWch(w)      (unsigned char)((w) & 0x00ff)
#define MsoHighByteWch(w)     (unsigned char)(((WORD)(w) >> 8) & 0x00ff)

#ifndef cbXchar
#ifndef ANSI_XCHAR
typedef unsigned short XCHAR;
#define cbXchar    2

#else /* ANSI_XCHAR */

typedef unsigned char XCHAR;
#define cbXchar    1
#endif /* !ANSI_XCHAR */
#endif /* !cbXchar */

#ifndef ANSI_XCHAR

#define MsoLowByteXch(xch)      MsoLowByteWch(xch)
#define MsoHighByteXch(xch)     MsoHighByteWch(xch)
#define CchXsz(xsz)             MsoCchWzLen(xsz)
#define SzFromXsz(xszFrom, szTo) \
            MsoWzToSz(xszFrom, szTo)
#define CchCopyRgxchToRgch  MsoRgwchToRgch
#define CopyRgxchToRgch(pxchSrc, pchDest, pcch) \
            (*pcch = MsoRgwchToRgch(pxchSrc, *pcch, pchDest, 2 * (*pcch)))

#else /* ANSI_XCHAR */

#define MsoLowByteXch(xch)      (xch)
#define MsoHighByteXch(xch)     (0)
#define CchXsz(xsz)             MsoCchSzLen(xsz)
#define SzFromXsz(xszFrom, szTo) \
            strcpy(szTo, xszFrom)
#define CchCopyRgxchToRgch(rgchFrom, cchFrom, rgchTo, cchTo) \
            (PbCopyRgb((rgchFrom), (rgchTo), (cchFrom)), (cchFrom))
#define CopyRgxchToRgch(pxchSrc, pchDest, pcch) \
            memmove(pchDest, pxchSrc, *(pcch))

#endif /* !ANSI_XCHAR */

int FNeNcRgxch(const XCHAR *pxch1, const XCHAR *pxch2, int cch);


#if !WORD_BUILD  &&  !STANDALONE_WORD

typedef void *LPV;

// Split value struct. Overlays two shorts on long, byte-reversable indifferent
typedef struct _SV
    {
#ifndef MAC
    short                   wValue1;                    // Low, short
    short                   wValue2;                    // High, long
#else /* MAC */
    short                   wValue2;                    // High, long
    short                   wValue1;                    // Low, short
#endif /* !MAC */
    } SV;

// SV as seen as chars
typedef struct _SVC
    {
#ifndef MAC
    char                    ch1;                        // Low, 1st byte
    char                    ch2;                        // 2nd byte
    char                    ch3;                        // 3rd byte
    char                    ch4;                        // 4th byte
#else /* MAC */
    char                    ch3;                        // 3rd byte
    char                    ch4;                        // 4th byte
    char                    ch1;                        // Low, 1st byte
    char                    ch2;                        // 2nd byte
#endif /* !MAC */
    } SVC;

// SV unioned with long
typedef union _SVL
    {
    long                    lValue;                     // As long
    SV                      sv;                         // Split version
    SVC                     svc;                        // As chars
    } SVL;

#endif /* !WORD_BUILD  &&  !STANDALONE_WORD */


#ifndef NORULES
#include "emrule.h"
#include "emutil.h"
#include "emact.h"
#ifdef DYN_RULES
#include "emruloci.h"
#endif /* DYN_RULES */
#endif /* !NORULES */


#if defined(DEBUG)  &&  !defined(STANDALONE)

MSOAPI_(void) MsoInitEmMemMark(                         // Init EM Mem marking
    struct MSOINST     *hMsoInst,
    long                lparam,
    int                 bt
    );
MSOAPI_(void) MsoMarkEmPv(void *pv);                    // Mark EM Memory

#else /* !DEBUG  ||  STANDALONE */

#define MsoInitEmMemMark(hMsoInst, lparam, bt)
#define MsoMarkEmPv(pv)

#endif /* DEBUG  &&  !STANDALONE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !MSOEMTYP_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emact.h ===
/*****************************************************************************
    emact.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Delayed Action Interpreter mechanism, shared header file.

*****************************************************************************/

#ifndef _EMACT_H
#define _EMACT_H

#include "emrultk.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#define iactAllocMax        256


/* M  S  O  A  C  T */
/*----------------------------------------------------------------------------
    %%Structure: MSOACT
    %%Contact:   daleg

    Delayed-Action structure.  Used to pass argument values to functions
    delay-called from the rulebase.
----------------------------------------------------------------------------*/

typedef struct _MSOACT
    {
    union
        {
        struct
            {
            short           actt;                       // Action type
            MSOBF           fComposite : 1;             // Composite action?
            MSOBF           fValidate : 1;              // Check if act OK?
            MSOBF           fAdjust : 1;                // Adjusting CA?
            MSOBF           fDeferred : 1;              // Deferred eval?
            long            rgl[8];                     // Arg values, 1st rec
            struct _MSOACT *pactSublist;                // Child record
            } rec1;
        struct
            {
            long            hdrCA;                      // Shared rec1 header
            MSOCA           ca;                         // Edit range
            } rec1_ca;
        long                hdr;                        // Shared header
        long                rglSublist[10];             // Arg values, 2nd+ rec
        char               *rszSublist[10];             // Arg values, 2nd+ rec
        };
    struct _MSOACT         *pactNext;                   // Next record
    } MSOACT;


#define msoacttNil          (-1)                        // Out of range actt
#define msopactNULL         ((MSOACT *) (-1))           // End of list marker


// Return object pointer of (first record of) a pact
#define PObjectPact(pact) \
            ((pact)->rec1_ca.ca.pObject)

// Return cpFirst of (first record of) a pact
#define CpFirstPact(pact) \
            ((pact)->rec1_ca.ca.cpFirst)

// Return cpLim of (first record of) a pact
#define CpLimPact(pact) \
            ((pact)->rec1_ca.ca.cpLim)



/* M S O  A  C  T  B  L  K */
/*----------------------------------------------------------------------------
    %%Function: MSOACTBLK
    %%Contact: daleg

    Delayed-Action structure allocation block.
----------------------------------------------------------------------------*/

typedef struct _MSOACTBLK
    {
    struct _MSOACTBLK  *pactblkNext;                    // Next alloc block
    MSOACT              rgact[iactAllocMax];            // Array of MSOACTs
    } MSOACTBLK;



/* M  S  O  A  C  T  T  R  E  C */
/*----------------------------------------------------------------------------
    %%Function: MSOACTTREC
    %%Contact: daleg

    Action-type table record.  Holds flags associated with actt values.
----------------------------------------------------------------------------*/

typedef struct _MSOACTTREC
    {
    short               cargs;                          // Num of args to fn
    unsigned short      actf;                           // Action flags
    } MSOACTTREC;


// Base action flags
#define msoactfExclusiveEdit    0x0001                  // Truncates other acts
#define msoactfTruncatable      0x0002                  // Trucated by Excl act
#define msoactfNonExclPaired    0x0004                  // Trunc unless paired

// "User"-level action flags
#define msoactfNonEdit          0x0000                  // Not an edit
#define msoactfEdit             0x0003                  // e.g. Edits
#define msoactfProp             0x0002                  // e.g. Props
#define msoactfPairedProp       0x0004                  // Props paired w/edits
#define msoactfOverlapCalc      0x0007                  // Overlap calc necess
#define msoactfCond             0x0010                  // Cond exec next act
#define msoactfConposite        0x0020                  // Composite action

// Return whether the action is a composite, composed of multiple records
#define MsoFCompositeAct(actt, pacttbl) \
            MsoFActfActt(actt, msoactfConposite, pacttbl)

// Return whether ACT record has actf flag set
#define MsoFActfActt(actt, actfMask, pacttbl) \
            (MsoActfActt((actt), (pacttbl)) & (actfMask))

// Return whether ACT record has actf flag set
#define MsoFActfIs(actf, actfMask) \
            ((actf) & (actfMask))

// Return whether ACT record type has actf flag set
#define MsoFActfActtIs(actt, actfMatch, pacttbl) \
            (MsoActfActt((actt), (pacttbl)) == (actfMatch))

// Return whether ACT record type has actf flag set
#define MsoActfActt(actt, pacttbl) \
            (MsoPActtrec((actt), (pacttbl))->actf)

// Return action record (MSOACTTREC) associated with ACT record
#define MsoPActtrec(actt, pacttbl) \
            (&(pacttbl)->rgacttrec[actt])



/* M  S  O  A  C  T  T  B  L */
/*----------------------------------------------------------------------------
    %%Structure: MSOACTTBL
    %%Contact: daleg

    Action-type table.  Contains MSOACT state and action flags.
----------------------------------------------------------------------------*/

typedef struct _MSOACTTBL
    {
    const MSOACTTREC   *rgacttrec;                      // Per-action data
    MSOCP               cpFirstEditPrev;                // 1st CP of last edit
    MSOCP               dcpEditPrev;                    // dCP of last edit
    MSOCP               cpLimEdit;                      // cpLim, edit so far
    MSORULTKH          *prultkh;                        // Text Token cache
    MSOACT             *pactPending;                    // Pending actions
    MSOACT             *pactPendingPrev;                // Prev pending acts
    MSOACT             *pactFree;                       // Free list
    MSOACTBLK          *pactblkAlloc;                   // Allocation list
    } MSOACTTBL;



// Start a new MSOACT action list frame
#define MsoPushPactPending() \
            MsoBeginActSublist((_pacttbl), &(_pacttbl)->pactPendingPrev)


// End and close a new MSOACT sub-list, and return sublist
#define MsoPopPactPending(ppact) \
            (*(ppact) = (_pacttbl)->pactPending, \
             MsoEndActSublist((_pacttbl), &(_pacttbl)->pactPendingPrev))


// Start a new MSOACT action list frame
__inline void MsoBeginActSublist(MSOACTTBL *pacttbl, MSOACT **ppactPrev)
{
    *ppactPrev = pacttbl->pactPending;
    pacttbl->pactPending = (MSOACT *) NULL;
}


// End and close a new MSOACT sub-list
__inline void MsoEndActSublist(MSOACTTBL *pacttbl, MSOACT **ppactPrev)
{
    pacttbl->pactPending = *ppactPrev;
    *ppactPrev = (MSOACT *) NULL;
}



// Callback to evaluate the MSOACT
typedef long (WIN_CALLBACK * MSOPFNACT)(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,                           // IN, RETURN
    MSOCA              *pcaAdjusted,
    MSOACT           **ppactNext,                       // RETURN
    int                *pfDiscard                       // RETURN
    );


// Are there pending action records?
#define MsoPendingActions(pacttbl) \
            ((pacttbl)->pactPending)

// Return value for args 0-7
#define MsoLPact(pact, iarg) \
            ((pact)->rec1.rgl[iarg])

// Return value for args 8-17
#define MsoLPact2(pact, iarg) \
            ((pact)->rec1.pactSublist->rglSublist[(iarg) - 8])

// Return value for args 18-27
#define MsoLPact3(pact, iarg) \
            ((pact)->rec1.pactSublist-> \
            ((pact)->rec1.pactSublist->pactNext->rglSublist[(iarg) - 18])

// Return value for args 28-31
#define MsoLPact4(pact, iarg) \
            ((pact)->rec1.pactSublist->pactNext->pactNext \
                ->rglSublist[(iarg) - 28])


MSOCDECLAPI_(MSOACT *) MsoPact(                         // Build new MSOACT rec
    MSOACTTBL          *pacttbl,
    int actt,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactNq(                       // As above, not queued
    MSOACTTBL          *pacttbl,
    int actt,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactDtk(                      // Bld MSOACT rec w/tks
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactDtkNq(                    // As above, not queued
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactPca(                      // Bld MSOACT rec w/CPs
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    );
MSOCDECLAPI_(MSOACT *) MsoPactPcaNq(                    // As above, not queued
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    );
MSOAPI_(MSOACT *) MsoPactCompositeDtk(                  // Bld Composite action
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    MSOACT            **ppactPrev
    );
void SetPactCaFromSublist(MSOACT *pact);                // Set CA of Comp pact
#define MsoReversePactPending(pacttbl) \
            MsoReversePact(&pacttbl->pactPending)       // Reverse pending acts
MSOAPI_(void) MsoReversePact(MSOACT **ppact);           // Reverse ACT list
MSOAPI_(long) MsoDcpDoActs(                             // Execute ACT list
    MSOACT            **ppact,
    MSOACTTBL          *pacttbl,
    long                dcp,
    int                 fDiscardActs,
    int                 dactLim,
    MSOPFNACT           pfnact                          // MSOACT handler
    );
MSOAPI_(MSOACT *) MsoPactDtkAp(                         // Bld MSOACT tks & ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 dtkStart,
    int                 dtk,
    va_list             ap
    );
MSOAPI_(MSOACT *) MsoPactPcaAp(                         // Bld MSOACT CPs & ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA               *pca,
    va_list             ap
    );
MSOAPI_(MSOACT *) MsoPactAp(                            // Bld MSOACT rec ap
    MSOACTTBL          *pacttbl,
    int                 actt,
    int                 cargsOffset,
    va_list             ap
    );
MSOAPI_(void) MsoInsertPact(                            // Insert ACT by MSOCA
    MSOACT             *pact,
    MSOACT            **ppactHead
    );
MSOAPI_(int) MsoFEnsurePactFirst(                       // Sort ACT 1st in rng
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(MSOACT *) MsoFindPactOfActt(                    // Find rec by actt
    short               actt,
    MSOACT             *pact,
    MSOCP               cpFirst,
    MSOCP               cpLim
    );
MSOAPI_(void) MsoDeletePact(                            // Remove & free act
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(void) MsoSkipNextPact(                          // Skip over next ACT
    MSOACT            **ppactNext,
    MSOACTTBL          *pacttbl
    );
MSOAPI_(MSOACT *) _MsoPactNew(MSOACTTBL *pacttbl);      // Create blk of MSOACT

_inline MSOACT *MsoPactNew(MSOACTTBL *pacttbl)          // Return new MSOACT
{
    MSOACT             *pact;

    if ((pact = pacttbl->pactFree))
        {
        pacttbl->pactFree = pact->pactNext;
        return pact;
        }
    return _MsoPactNew(pacttbl);
}

void ClearPactPending(MSOACTTBL *pacttbl);              // Free pending acts
MSOAPI_(void) MsoFreePact(                              // Free MSOACT rec
    MSOACT             *pact,
    MSOACTTBL          *pacttbl
    );

_inline int MsoFAllocPact(MSOACTTBL *pacttbl)           // Pre-alloc ACT list
{
    MSOACT             *pact;

    if ((pact = MsoPactNew(pacttbl)) == NULL)
        return FALSE;
    MsoFreePact(pact, pacttbl);
    return TRUE;
}

MSOAPI_(void) MsoFreeActMem(MSOACTTBL *pacttbl);        // Free act mem used
#ifdef DEBUG
MSOAPI_(void) MsoMarkActMem(MSOACTTBL *pacttbl);        // Mark act mem used
#endif // DEBUG

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !_EMACT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emoci.h ===
/*****************************************************************************
    emoci.h

    Owner: DaleG
    Copyright (c) 1996-1997 Microsoft Corporation

    Op-Code Interpreter header file

*****************************************************************************/

#ifndef EMOCI_H
#define EMOCI_H

#include "emocii.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

//############################################################################
//
// PUBLIC Interfaces
//
//############################################################################


// System Limits
#define msoilOciStackMax    2000



/* M  S  O  O  C  I  S */
/*----------------------------------------------------------------------------
    %%Struct: MSOOCIS
    %%Contact: daleg

    Op-Code Interpreter State structure
----------------------------------------------------------------------------*/

// The Interpreter op-code fns must always be compatible with MSOAPICALLTYPE
//  so that MSO-exported and app-local functions have the same type
#define MSOOCVAPI MSOOCV MSOAPICALLTYPE

// Define normal function: all args are evaluated and received on the stack
typedef MSOOCV (MSOAPICALLTYPE *MSOPFNOCI)(MSOOCV *pocvSP);

// Define function to return address of variable data
typedef MSOOCV *(MSOAPICALLTYPE *MSOPFNPOCV)(MSOOCII);


typedef struct _MSOOCIS
    {
    MSOPFNOCI const    *rgpfn;                          // Function ptr array
    MSOOCAD const      *rgocadArgDesc;                  // #Args/Offset arg len
    MSOOCV             *pocvSP;                         // Stack pointer
    MSOOCV             *pocvFP;                         // Frame pointer
    MSOOCV              rglStack[msoilOciStackMax];     // Call/Return stack
    unsigned char const*rgcbImmedArg;                   // Immediate arg lens
    void               *rgocvVar;                       // Variable array
    MSOPFNPOCV          pfnPocvGetVar;                  // Get addr of var data
#ifdef DEBUG
    unsigned char     **rgszFnNames;                    // Function names
#endif /* DEBUG */
    } MSOOCIS;


// Define non-evaluating function: it must interpret instructions itself
typedef MSOOCV (MSOAPICALLTYPE *MSOPFNOCI_NE)
                    (MSOOCII **ppocii, MSOOCIS *pocis);



/*************************************************************************
    Prototypes and macros
 *************************************************************************/

MSOAPI_(MSOOCIS *) MsoPocisInit(                        // Init Interp Fn tbl
    MSOOCIS            *pocis,
    MSOPFNOCI const    *rgpfn,                          // Function table
    MSOOCAD const      *rgocadArgDesc,                  // Arg descript table
    unsigned char const*rgcbImmedArg,                   // Immed arg desc tbl
    int                 ipfnMax,                        // Num builtin fns
    void               *rgocvVar,                       // Variable array
    MSOPFNPOCV          pfnPocvGetVar                   // Get addr of var data
    );

MSOAPI_(MSOOCV) MsoOcvEvalPocii(                        // Interpret 1 instr
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );

MSOAPI_(MSOOCV *) MsoPocvPushVarArgs(                   // Push var args on stk
    int                 docvArgsFixed,
    MSOOCII           **ppocii,
    MSOOCIS            *pocis
    );


// NOTE:
// NOTE:  The macros below require the parent routine to declare pocvSP!!
// NOTE:

// Return the value of the iocv-th argment on the stack
#define MsoOcvArg(iocv) \
            (pocvSP[iocv])

// Return the value of the pointer in the iocv-th argment on the stack
#define MsoPvOcvArg(iocv) \
            ((void *) (pocvSP[iocv]))

// Convert the pointer value to a interpreter return type
#define MsoOcvFromPv(pv) \
            ((MSOOCV) (pv))

// Return the value of the char in the iocv-th argment on the stack
#define MsoChOcvArg(iocv) \
            ((char) (pocvSP[iocv]))

// Convert the char value to a interpreter return type
#define MsoOcvFromCh(ch) \
            ((MSOOCV) (ch))

// Return the value of the unsigned char in the iocv-th argment on the stack
#define MsoUchOcvArg(iocv) \
            ((unsigned char) (pocvSP[iocv]))

// Convert the unsigned char value to a interpreter return type
#define MsoOcvFromUch(uch) \
            ((MSOOCV) (uch))

// Return the value of the int in the iocv-th argment on the stack
#define MsoIntOcvArg(iocv) \
            ((int) (pocvSP[iocv]))

// Convert the integer value to a interpreter return type
#define MsoOcvFromInt(v) \
            ((MSOOCV) (v))

// Return the value of the unsigned int in the iocv-th argment on the stack
#define MsoUintOcvArg(iocv) \
            ((unsigned int) (pocvSP[iocv]))

// Convert the unsigned int value to a interpreter return type
#define MsoOcvFromUint(v) \
            ((MSOOCV) (v))

// Return the value of the short iocv-th argment on the stack
#define MsoWOcvArg(iocv) \
            ((short) (pocvSP[iocv]))

// Convert the short value to a interpreter return type
#define MsoOcvFromW(w) \
            ((MSOOCV) (w))

// Return the value of the unsigned short iocv-th argment on the stack
#define MsoUwOcvArg(iocv) \
            ((unsigned short) (pocvSP[iocv]))

// Convert the unsigned short value to a interpreter return type
#define MsoOcvFromWw(uw) \
            ((MSOOCV) (uw))

// Return the value of the long in the iocv-th argment on the stack
#define MsoLOcvArg(iocv) \
            ((long) (pocvSP[iocv]))

// Convert the long value to a interpreter return type
#define MsoOcvFromL(l) \
            ((MSOOCV) (l))

// Return the value of the unsigned long in the iocv-th argment on the stack
#define MsoUlOcvArg(iocv) \
            ((unsigned long) (pocvSP[iocv]))

// Convert the unsigned long value to a interpreter return type
#define MsoOcvFromUl(l) \
            ((MSOOCV) (l))

// Return the address of the event (var) of index iocv: Application callback
#define MsoOcvEventAddr(iocv, pocis) \
            ((*(pocis)->pfnPocvGetVar)(iocv))

// Return the address of the stack index
#define MsoOcvStackAddr(docv, pocis) \
            (&(pocis)->pocvFP[docv])

// Return the address of a global variable or function
#define MsoOciiGlobalAddr(ipv, pocis) \
            (&(pocis)->rgpfn[ipv])

// Return the value of iocv-th argment on the stack
#define MsoOcvStack(iocv) \
            ((long) (pocvSP[iocv]))

// Supply the rest of the calling arguments to a var-args function call
#define MsoOcv_varargs_0 \
          MsoOcvStack(0),  MsoOcvStack(1),  MsoOcvStack(2), MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_1 \
                           MsoOcvStack(1),  MsoOcvStack(2),  MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_2 \
                                            MsoOcvStack(2),  MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_3 \
                                                             MsoOcvStack(3), \
          MsoOcv_varargs_4

#define MsoOcv_varargs_4 \
          MsoOcvStack(5),  MsoOcvStack(5),  MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_5 \
                           MsoOcvStack(5),  MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_6 \
                                            MsoOcvStack(6),  MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_7 \
                                                             MsoOcvStack(7), \
          MsoOcv_varargs_8

#define MsoOcv_varargs_8 \
          MsoOcvStack(8),  MsoOcvStack(9),  MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_9 \
                           MsoOcvStack(9),  MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_10 \
                                            MsoOcvStack(10), MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_11 \
                                                             MsoOcvStack(11), \
          MsoOcv_varargs_12

#define MsoOcv_varargs_12 \
          MsoOcvStack(12), MsoOcvStack(13), MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_13 \
                           MsoOcvStack(13), MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_14 \
                                            MsoOcvStack(14), MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_15 \
                                                             MsoOcvStack(15), \
          MsoOcv_varargs_16

#define MsoOcv_varargs_16 \
          MsoOcvStack(16), MsoOcvStack(17), MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_17 \
                           MsoOcvStack(17), MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_18 \
                                            MsoOcvStack(18), MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_19 \
                                                             MsoOcvStack(19), \
          MsoOcv_varargs_20

#define MsoOcv_varargs_20 \
          MsoOcvStack(20), MsoOcvStack(21), MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_21 \
                           MsoOcvStack(21), MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_22 \
                                            MsoOcvStack(22), MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_23 \
                                                             MsoOcvStack(23), \
          MsoOcv_varargs_24

#define MsoOcv_varargs_24 \
          MsoOcvStack(24), MsoOcvStack(25), MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_25 \
                           MsoOcvStack(25), MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_26 \
                                            MsoOcvStack(26), MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_27 \
                                                             MsoOcvStack(27), \
          MsoOcv_varargs_28

#define MsoOcv_varargs_28 \
          MsoOcvStack(28), MsoOcvStack(29), MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_29 \
                           MsoOcvStack(29), MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_30 \
                                            MsoOcvStack(30), MsoOcvStack(31)

#define MsoOcv_varargs_31 \
                                                             MsoOcvStack(31)



/*----------------------------------------------------------------------------
    Interpreter function list.
    Should be list in same order as enum for clarity.
----------------------------------------------------------------------------*/

MSOAPI_(MSOOCV) MsoOcv_log_and(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_log_or(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_log_not(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_less_than(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_less_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_gtr_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_gtr_than(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_not_eql(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_assign(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_plus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_minus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_mult(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_divide(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_mod(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_increment(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_decrement(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_unary_plus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_unary_minus(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_not(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_and(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_or(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_bitwise_xor(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_shift_l(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_shift_r(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_dereference(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_addr_of(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_cast_as(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_if(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_inline_if(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_let(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_compound_stmt(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_progn(
    MSOOCII           **ppocii,
    struct _MSOOCIS    *pocis
    );
MSOAPI_(MSOOCV) MsoOcv_get_char(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_uchar(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_short(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ushort(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_int(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_uint(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_long(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ulong(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_float(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_double(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_get_ldouble(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_char(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_uchar(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_short(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ushort(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_int(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_uint(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_long(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ulong(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_float(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_double(MSOOCV *pocvSP);
MSOAPI_(MSOOCV) MsoOcv_set_ldouble(MSOOCV *pocvSP);




//############################################################################
//
// PRIVATE Interfaces
//
// To use, #define _OCI_PRIVATE
//
//############################################################################

#ifdef _OCI_PRIVATE


// Return the Argument descriptor associated with the function
#define OcadArgDecripOcii(ocii, pocis) \
            ((pocis)->rgocadArgDesc[ocii])

// Return the Argument descriptor list associated with the function
#define PcbArgFromOcad(ocad, pocis) \
            (&(pocis)->rgcbImmedArg[ocad])


#endif /* _OCI_PRIVATE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !EMOCI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\emrule.h ===
/*****************************************************************************
    emrule.h

    Owner: DaleG
    Copyright (c) 1992-1997 Microsoft Corporation

    General Rule-Network Propagation Engine functions and prototypes

----------------------------------------------------------------------------
    NOTE:

    1.  BAD CODE, but it works: FIsDelayFactor(),LpruldependFromCDelay() and
        CDelayFromLpruldepend() rely upon the fact (?) that pointers
        on the machines we support are never (?) small integers.  But if
        this should ever prove false, it would be bad.  We should rewrite
        this to either have a RULDEP structure (as does the rule compiler),
        or make the list of dependencies indexes to rules, rather than
        pointers.

*****************************************************************************/

#ifndef EMRULE_H

#include "msodbglg.h"
#include "emkwd.h"
#include "emrulini.h"
#include "emrultk.h"


MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

// REVIEW: configure this in makefile, so emtest (for example) can build
// debug without dynamic rules
#ifdef DEBUG
#ifndef YY_NODYNRULES
#define DYN_RULES 1
#endif
#endif


/*----------------------------------------------------------------------------
    System limits
----------------------------------------------------------------------------*/

#define wDelayMax           100                         // Maximum delay poss
#define irultkRuleMax       256                         // Max events cached
#define iruldepAllocMax     256                         // Max ruldeps alloced
#define ichRulNameMax       128                         // Max trace name len
#define ichRulNameAllocMax  1024                        // Max name alloc


/*************************************************************************
    Types:

    irul        Rule node ID.
    ruldep      Rule node dependency link.
    ruldepblk   Rule node dependency link allocation structure.
    sv          Split Value structure.
    rul         Rule node structure.
    ruls        Rule state structure.

 *************************************************************************/


/* I R U L */
/*----------------------------------------------------------------------------
    %%Structure: IRUL
    %%Contact: daleg

    Rule Index definition
----------------------------------------------------------------------------*/

typedef short IRUL;

#define IrulFromTk(tk)      ((IRUL) (tk))
#define TkFromIrul(irul)    (irul)

// Lexer tokens: hard-coded rule node IDs
#define irulERROR       tkERROR
#ifdef tkNil
#define irulNil         tkNil
#else /* !tkNil */
#define irulNil         0
#endif /* tkNil */

// Is rule ID valid (not irulNil and not irulERROR)
#define FValidIrul(irul) \
            ((irul) > 0)




/* R  U  L  D  E  P */
/*----------------------------------------------------------------------------
    %%Structure: RULDEP
    %%Contact: daleg

    Rule node dependency structure.
    This structure holds the dependency information that links a rule node
    to its dependents.
----------------------------------------------------------------------------*/

typedef struct _RULDEP
    {
    struct _MSORUL             *prul;                   // Node referenced
    struct _RULDEP             *pruldepNext;            // Next dependency
//  int                         cDelay;                 // Delay in eval
    } RULDEP;


MSOAPI_(RULDEP *) _MsoPruldepNew(                       // Alloc blk of deps
    int                 cruldep,
    int                 fOnFreeList
    );


// Return a new ruldep record from the free list (requires local var pruldep)
// Operates in either sequential mode (vlpruls->lpruldepNextFree) or free list
#define LpruldepNew() \
            (vlpruls->lpruldepNextFree != NULL \
                ? (vlpruls->fSeqentialFreeRuldeps \
                    ? vlpruls->lpruldepNextFree++ \
                    : (pruldep = vlpruls->lpruldepNextFree, \
                            vlpruls->lpruldepNextFree \
                                    = pruldep->pruldepNext, \
                            pruldep->pruldepNext = NULL, \
                            pruldep)) \
                : _MsoPruldepNew(iruldepAllocMax, TRUE))

// Push a ruldep record onto the free list
#define PushLpruldepOnFreeList(pruldep) \
            ((pruldep)->pruldepNext = vlpruls->lpruldepNextFree, \
             vlpruls->lpruldepNextFree = (pruldep))



/* R  U  L  D  E  P  B  L  K */
/*----------------------------------------------------------------------------
    %%Structure: RULDEPBLK
    %%Contact: daleg

    Rule node dependency allocation block structure.
    This structure allows us to batch-allocate RULDEP records.
----------------------------------------------------------------------------*/

typedef struct _RULDEPBLK
    {
    struct _RULDEPBLK      *lpruldepblkNext;            // Next block
    RULDEP                  rgruldep[1];                // Array of ruldeps
    } RULDEPBLK;


/* R  U  L  C  X  T */
/*----------------------------------------------------------------------------
    %%Structure: RULCXT
    %%Contact: daleg

    (Rul)e (C)onte(x)t-group (T)able structure.
    This structure allows the rule engine to support cheap sparse dependents
    lists for special contexts.
    The callback function allows us to perform any desired side effects
    during the propagation, as well as offering the chance to optimize
    the lookup algorithm.
----------------------------------------------------------------------------*/

typedef struct _RULCXT
    {
    struct _RULCXT         *lprulcxtNext;               // Next context
    LPFNRULCXT              lpfnrulcxt;                 // Callback fn
    int                     iruldepMax;                 // Size of array
    struct _RULCXL         *rglprulcxl[1];              // Hash table
    } RULCXT;



/* R  U  L  C  X  L */
/*----------------------------------------------------------------------------
    %%Structure: RULCXL
    %%Contact: daleg

    (Rul)e (C)onte(x)t-group (L)ist item structure.
    This is the item used in the hash table of the RULCXT above.
----------------------------------------------------------------------------*/

typedef struct _RULCXL
    {
    IRUL                    irul;                       // Rule ID
    struct _RULDEP         *pruldep;                    // Dependent list
    struct _RULCXL         *lprulcxlNext;               // Next in hash chain
    } RULCXL;


#ifdef DEBUG
/* R  U  L  N  B  L  K */
/*----------------------------------------------------------------------------
    %%Structure: RULNBLK
    %%Contact: daleg

    (Rul)e (N)ame block
    Store dynamically constructed rule names.
----------------------------------------------------------------------------*/

typedef struct _RULNBLK
    {
    struct _RULNBLK        *lprulnblkNext;              // Next block
    char                    rgch[1];                    // Block of text
    } RULNBLK;


char *LszGenNameForLprul(                               // Gen dyn rule name
    struct _MSORUL     *prul,
    int                 irulAssert
    );
char *SzSaveRulName(char *szName);                      // Save node name sz
char *LpchRulNameNew(int dichNeeded);                   // Get new name lpch

#endif /* DEBUG */





/* M  S  O  R  U  L */
/*----------------------------------------------------------------------------
    %%Structure: MSORUL
    %%Contact: daleg

    Rule node structure.
    This structure holds the state information for a rule within the
    propagation network.

    ASSUMPTIONS:

        1.  The wDelayMask field only applies to rules, but it is (currently)
            faster to not have to test for whether a node is a rule, by
            merely leaving the field empty for values.
----------------------------------------------------------------------------*/

typedef long RULV;
typedef struct _MSORUL *MSOPRUL;

#pragma pack(2)

typedef struct _MSORUL
    {
    IRUL                        irul;                   // Rule ID
    char                        rultType;               // Type: rule/event
    char                        ipfnrulscSeqCheck;      // Fn to ensure contig
    short                       rulevl;                 // Evaluation level
    short                       birulDependsOn;         // Depends on: nodes
    SVL                         svl;                    // 32-bit storage area
#ifdef DEBUG
    char const                 *lpchName;               // Name or rule text
#endif /* DEBUG */
    IRUL                        irulNextChanged;        // Next changed value
    union
        {
        short                   ipociiInstrs;           // Interp instrs
        short                   USEME_IN_EVENTS;        // Unsed slot
        };
    short                       wIntervalCount;         // Ensure contig seqs
    short                       wDelayMask;             // Delays as bit pos's
    struct _MSORUL             *prulNext;               // Next node in queue
#ifdef DEBUG
    IRUL                        irulNextTrace;          // Next traced rule
    short                       wDebugFlags;            // Random debug flags
#endif /* DEBUG */
    } MSORUL;

#pragma pack()



// Allocate new nodes
MSOAPI_(MSORUL *) MsoPrulNew(void);                     // Allocate new node
MSOAPI_(int) MsoFEnsureIrulAllocated(int irulMax);      // Pre-allocated nodes

// Discard an existing rul node
#define DiscardIrul(irul) \
            (vlpruls->irulLim--)



#define msoprulNil      ((MSORUL *) -1)                 // NIL value for MSORUL
#define msoprulInactive ((MSORUL *) -2)                 // Node is deactivated
#define wRulTrue        1000
#define wRulFalse       0

// Rule node type flags: shared with emrulini.h and rulc.h
#define rultNil             0
#define rultRule            0x00                        // Rule
#define rultEvent           0x01                        // Event/Variable
#define rultPrimaryRule     0x02                        // Rule auto-scheduled
#define rultImmediateRule   0x04                        // Rule executes immed
#define rultPersistentRule  0x20                        // Rule not cleared
#define rultAlwaysPersist   0x40                        // Rule never cleared
#define rultSpecialKwd      0x80                        // Node is generic type

// Debug check that rule is not marked as both NonTerminal and Seq
#define rultRuleMask        0x19

#ifdef NEVER
#define FRultRuleIs(rult, rultExpected) \
            (((rult) & rultRuleMask) == ((rultExpected)))
#endif /* NEVER */


#ifdef DEBUG
#define rultDynActionRule   0x04                        // Dyn DEBUG only
#define rultNonTermRule     0x08                        // Dyn DEBUG only
#define rultSeqRule         0x10                        // Dyn DEBUG only
#endif /* DEBUG */


/* R  U  L  S */
/*----------------------------------------------------------------------------
    %%Structure: RULS
    %%Contact: daleg

    Rule state structure.
    This structure holds the state information for the rule engine.
----------------------------------------------------------------------------*/

typedef int (WIN_CALLBACK *LPFNRul)(IRUL irul);         // Rule Eval function
typedef short (WIN_CALLBACK *PFNRULSC)(void);           // Interval seq chk fn
typedef int (*PFNRULVT)(IRUL irul);                     // Rule V-Table

typedef struct _RULS
    {
    // Rule base limits
    RULLIMS             rullims;                        // Rule base limits
    int                 irulMax;                        // Num nodes allocated
    int                 irulLim;                        // Num nodes used

    // Rule base state information
    RULDEP           ***rgrgpruldepDependents;          // List of Dep lists
    RULDEP            **rgpruldepDependents;            // Active Dep lists
    MSORUL            **lrglprulBlk;                    // Array of node arrays
    int                 ilprulNodesLim;                 // #arrays of arrays
#ifdef DEBUG
    MSORUL            **rgprulNodes;                    // Debug node array
#endif /* DEBUG */
    const short        *prulgAppendTo;                  // Group linkages
    const short        *prulgAppendedFrom;              // Group linkages
    short const        *rgrulevlRulevt;                 // Event_type eval lvls
    int                *rgrulevlRulevtLast;             // Highest Q of rulevts
    MSORUL            **rgprulActiveQueues;             // Active eval queues
    MSORUL            **rgprulDelayedQueues;            // Delayed eval queues
    MSORUL             *lprulQPersistent;               // Temp Q: persistent
    int                *rgirulRulevtChanged;            // Nodes changed in evt
    int                *rgrulevtEval;                   // Pending rulevt eval
    MSORULTKH          *prultkhRulevtHistory;           // Ev history for type
    long               *rgdtkiRulevt;                   // #times enter rulevt
    const int          *rgrulevtFromRulevl;             // Trans lvls to evts
    const short        *lpgrpirulDependBack;            // Back dependencies
    LPFNRul             lpfnEvalRule;                   // Evaluate rule code
    PFNRULSC const     *rgpfnrulscSeqCheck;             // Interval seq chk fns
    MSOKWTB           **rgpkwtbKeyTables;               // Keyword tables

    // Allocation information
    WORD                fDynamicInit : 1;               // Structs alloced?
    WORD                fDynAlloced : 1;                // vlpruls alloced?
    WORD                fDependBackDynAlloced : 1;      // Back deps alloced?
    WORD                fRgDependDynAlloced : 1;        // Dep lists alloced?
    WORD                fDynRulesAlloced : 1;           // Dyn rulebase alloc?
    WORD                fRgrulevlRulevtAlloced : 1;     // Last lvl tbl alloc?
    WORD                fRgprulQueuesAlloced : 1;       // Eval queues alloc?
    WORD                fRgrulevtFromRulevlAlloced : 1; // Lvl-evt tbl alloc?
    WORD                fRgprulNodesAlloced : 1;        // DEBUG nd arr alloc?

    int                 rulgCurr;                       // Current rule group
    IRUL                irulSelf;                       // irulSelf under eval
    MSORUL             *prulEvent;                      // Event causing eval
    IRUL                irulPrimaryEvent;               // Primary ev of intvl
    RULDEP             *lpruldepNextFree;               // Next free dep rec
    RULDEPBLK          *lpruldepblkDependBlocks;        // List of dep blocks
    RULCXT             *lprulcxtActive;                 // Active context list
    RULCXT            **lrglprulcxtContexts;            // List of cntx groups
    int                 rulevtCurr;                     // Current event_type
    int                *prulevtEvalLim;                 // Num Ev types to eval
    MSORUL             *lprulQueue;                     // Current queue
    int                 rulevlRultevtMin;               // 1st eval lvl in evt
    int                 rulevlRulevtLast;               // Last eval lvl in evt
    void               *pociiDynRules;                  // Dyn-loaded rulebase
#ifdef DEBUG
    char               *lpchNames;                      // Name/string buf
    char const * const *rgpchDynNames;                  // Interp: node names
    int                 irulQTrace;                     // Backtrace list
    int                 dichNameFree;                   // Num chars avail
    char               *lpchNameNextFree;               // Next free name rgch
    RULNBLK            *lprulnblkNames;                 // Dyn name list
#endif /* DEBUG */

    // Run-time flags
    WORD                fInited : 1;                    // Rule base inited?
    WORD                fNew : 1;                       // Rule base new?
    WORD                fSeqentialFreeRuldeps : 1;      // Free ruldeps are seq
    WORD                fEvaluatingDeferred : 1;        // Evaling deferred nd?
    WORD                fEvaluating: 1;                 // Eval recursion check

    // Multiple Rule base support
    struct _RULS       *lprulsNext;                     // Next struct LIFO

    // Allocation info
    WORD                fAllocedSpare1 : 1;
    WORD                fAllocedSpare2 : 1;
    WORD                fAllocedSpare3 : 1;
    WORD                fAllocedSpare4 : 1;
    WORD                fAllocedSpare5 : 1;
    WORD                fAllocedSpare6 : 1;
    WORD                fAllocedSpare7 : 1;
    WORD                fAllocedSpare8 : 1;
    WORD                fAllocedSpare9 : 1;
    WORD                fAllocedSpare10 : 1;
    WORD                fAllocedSpare11 : 1;
    int                 ilprulNodesAllocFirstLim;       // Start alloc'd nds +1
    long                lReturn;                        // Return value
    LPV                 lpvSpare3;
    LPV                 lpvSpare4;
    LPV                 lpvSpare5;
    LPV                 lpvSpare6;
    LPV                 lpvSpare7;
    LPV                 lpvSpare8;
    LPV                 lpvSpare9;
    LPV                 lpvSpare10;
    LPV                 lpvSpare11;

    // Debug logging
#ifdef DEBUG
    unsigned int        grfDebugLogFilter;              // DEBUG: how to log
#endif /* DEBUG */

#ifdef DYN_RULES
    // Dynamically-loaded rulebase support
    struct _MSOOCIS    *pocis;                          // Op-Code Interp State
    short               irulRuleInterpLim;              // #Interpreted rules
    short               irulRuleInterpMac;              // #Alloced inter ptrs
    void              **rgpociiRules;                   // Rule instructions
#endif /* DYN_RULES */
    } RULS;

extern RULS            *vlpruls;                        // Global rule state


//----------------------------------------------------
// If using debugger, an rulebase node's value is given by:
//      rulv_<irul> == vlpruls->rgprulNodes[irul]->svl.lValue
//
// Or if the rulebase is statically initialized,    and
// DEBUG_RULE_POINTERS is #defined              then
//      event FOO   can be accessed as *prulFOO     and
//      rule 126    can be accessed as *prul126
//----------------------------------------------------

// Return the number of rules in rule base
#define IrulMax()               (vlpruls->irulMax)

// Return the number of compiled rules in rule base
#define IrulCompiledMax()       (vlpruls->rullims.irulRulesMax)

// Return the number of event_types in rule base
#define RulevtMax()             RulevtMaxPruls(vlpruls)

// Return the number of event_types in rule base
#define RulevtMaxPruls(pruls) \
            ((pruls)->rullims.rulevtMax)

// Return the number of evaluation levels in rule base
#define RulevlMax()         RulevlMaxPruls(vlpruls)

// Return the number of evaluation levels in rule base
#define RulevlMaxPruls(pruls) \
            ((pruls)->rullims.rulevlMax)

#define irulMaxAlloc        128                         // Max nodes/array
#define cbfIrulShift        7                           // #bits irulMaxAlloc
#define wIrulMask           0x7F                        // Mask: irulMaxAlloc
#define ilprulMaxAlloc      256L                        // Max arrays of arrys

///#define irulMaxAlloc     2048                        // Max nodes/array
///#define cbfIrulShift     11                          // #bits irulMaxAlloc
///#define wIrulMask        0x7FF                       // Mask: irulMaxAlloc
///#define ilprulMaxAlloc   100L                        // Max arrays of arrys

///#define irulMaxAlloc     1024                        // Max nodes/array
///#define cbfIrulShift     10                          // #bits irulMaxAlloc
///#define wIrulMask        0x3FF                       // Mask: irulMaxAlloc
///#define ilprulMaxAlloc   100L                        // Max arrays of arrys

// Return the rule node structure pointer for the rule ID
#define LprulFromIrul(irul) \
            (&vlpruls->lrglprulBlk \
                [(irul) >> cbfIrulShift] [(irul) & wIrulMask])

// Return the rule ID of the rule node structure pointer
#define IrulFromLprul(prul)  \
            ((prul)->irul)

// Return the Lim irul value for iruls that are contiguous with the irul
#define IrulLimContig(irul) \
            ((((irul) >> cbfIrulShift) << cbfIrulShift) + irulMaxAlloc)

// Return whether rule node is a primary rule
#define FPrimaryRule(prul)      ((prul)->rultType & rultPrimaryRule)

#ifdef NEVER
// Return whether rule node is a action rule
#define FActionRule(prul)       ((prul)->wDebugFlags & rultActionRule)
#endif /* NEVER */

#ifdef DEBUG
// Return whether rule node is a non-terminal rule (then)
#define FNonTermRule(prul)      ((prul)->wDebugFlags & rultNonTermRule)

// Return whether rule node is a sequence rule (...)
#define FSeqRule(prul)          ((prul)->wDebugFlags & rultSeqRule)
#endif /* DEBUG */

// Return whether the node ID refers to an event node
#define FIsEventIrul(irul)          FIsEventPrul(LprulFromIrul(irul))

// Return whether the node is an event node
#define FIsEventPrul(prul)          ((prul)->rultType & rultEvent)

// Return whether the node is a rule node
#define FIsRulePrul(prul)           (!FIsEventPrul(prul))

#define IMMEDIATE_RULES
#ifdef IMMEDIATE_RULES
// Return whether rule node is a sequence rule (...)
#define FImmediateRulePrul(prul)    ((prul)->rultType & rultImmediateRule)
#endif /* IMMEDIATE_RULES */

// Return whether the node is an *undefined* event
#define FSpecialKwdIrul(irul) \
            FSpecialKwdLprul(LprulFromIrul(irul))

// Return whether the node is an *undefined* event
#define SetFSpecialKwdIrul(irul) \
            SetFSpecialKwdLprul(LprulFromIrul(irul))

// Return whether the node is an *undefined* event
#define FSpecialKwdLprul(prul)      ((prul)->rultType & rultSpecialKwd)

// Return whether the node is an *undefined* event
#define SetFSpecialKwdLprul(prul)  \
            ((prul)->rultType |= rultSpecialKwd)

// Return whether rule node can persist in delayed queue in soft resets
#define FPersistentLprul(prul) \
            ((prul)->rultType & rultPersistentRule)

// Mark that rule node can persist in delayed queue in soft resets
#define SetFPersistentIrul(irul) \
            SetFPersistentLprul(LprulFromIrul(irul))

// Mark that rule node can persist in delayed queue in soft resets
#define SetFPersistentLprul(prul) \
            ((prul)->rultType |= rultPersistentRule)

// Return whether rule node can persist in delayed queue in all resets
#define FAlwaysPersistLprul(prul) \
            ((prul)->rultType & rultAlwaysPersist)

// Mark that rule node can persist in delayed queue in all resets
#define SetFAlwaysPersistIrul(irul) \
            SetFAlwaysPersistLprul(LprulFromIrul(irul))

// Mark that rule node can persist in delayed queue in all resets
#define SetFAlwaysPersistLprul(prul) \
            ((prul)->rultType |= rultAlwaysPersist)

// Return whether rule node can persist in delayed queue
#define FPersistLprulGrf(prul, grf) \
            ((prul)->rultType & (grf))

// Return the value for the current rule
#define RulvSelf() \
            RulvOfIrul(irulSelf)

// Set the value for the current rule
#define SetRulvSelf(rulv) \
            SetRulvOfIrul(irulSelf, (rulv))

// Increment the value for the current rule
#define IncrRulvSelf(drulv) \
            IncrRulvOfIrul(irulSelf, (drulv))


// Return the value1 for the current rule
#define Rulv1Self() \
            Rulv1OfIrul(irulSelf)

// Set the value1 for the current rule
#define SetRulv1Self(rulv) \
            SetRulv1OfIrul(irulSelf, (rulv))

// Increment the value1 for the current rule
#define IncrRulv1Self(drulv) \
            IncrRulv1OfIrul(irulSelf, (drulv))


// Return the value2 for the current rule
#define Rulv2Self() \
            Rulv2OfIrul(irulSelf)

// Set the value2 for the current rule
#define SetRulv2Self(rulv) \
            SetRulv2OfIrul(irulSelf, (rulv))

// Increment the value2 for the current rule
#define IncrRulv2Self(drulv) \
            IncrRulv2OfIrul(irulSelf, (drulv))


// Return the value for the rule ID
#define RulvOfIrul(irul) \
            (LprulFromIrul(irul)->svl.lValue)

// Set the value for the rule ID
#define SetRulvOfIrul(irul, rulv) \
            (LprulFromIrul(irul)->svl.lValue = (rulv))

// Increment the value1 field for the rule ID
#define IncrRulvOfIrul(irul, drulv) \
            IncrRulvOfLprul(LprulFromIrul(irul), (drulv))


// Return the lValue field for a rule node
#define RulvOfLprul(prul)               ((prul)->svl.lValue)

// Set the lValue field for a rule node
#define SetRulvOfLprul(prul, w)         ((prul)->svl.lValue = (w))

// Increment the value1 field for a rule node
#define IncrRulvOfLprul(prul, drulv)    ((prul)->svl.lValue += (drulv))


// Set the value for the rule ID
#define PlValueOfIrul(irul) \
            (&LprulFromIrul(irul)->svl.lValue)

// Return the value1 field for the rule ID
#define Rulv1OfIrul(irul) \
            Rulv1OfLprul(LprulFromIrul(irul))

// Set the value1 field for the rule ID
#define SetRulv1OfIrul(irul, rulv) \
            SetRulv1OfLprul(LprulFromIrul(irul), (rulv))

// Increment the value1 field for the rule ID
#define IncrRulv1OfIrul(irul, drulv) \
            IncrRulv1OfLprul(LprulFromIrul(irul), (drulv))

// Return the value2 field for the rule ID
#define Rulv2OfIrul(irul) \
            Rulv2OfLprul(LprulFromIrul(irul))

// Set the value2 field for the rule ID
#define SetRulv2OfIrul(irul, rulv) \
            SetRulv2OfLprul(LprulFromIrul(irul), (rulv))

// Increment the value2 field for the rule ID
#define IncrRulv2OfIrul(irul, drulv) \
            IncrRulv2OfLprul(LprulFromIrul(irul), (drulv))

// Return the value1 field for a rule node
#define Rulv1OfLprul(prul)              W1OfPsv(PsvOfLprul(prul))

// Set the value1 field for a rule node
#define SetRulv1OfLprul(prul, w)        SetW1OfPsv(PsvOfLprul(prul), (w))

// Increment the value1 field for a rule node
#define IncrRulv1OfLprul(prul, dw)      IncrW1OfPsv(PsvOfLprul(prul), (dw))


// Return the value2 field for a rule node
#define Rulv2OfLprul(prul)              W2OfPsv(PsvOfLprul(prul))

// Set the value2 field for a rule node
#define SetRulv2OfLprul(prul, w)        SetW2OfPsv(PsvOfLprul(prul), (w))

// Increment the value2 field for a rule node
#define IncrRulv2OfLprul(prul, dw)      IncrW2OfPsv(PsvOfLprul(prul), (dw))


// Return the Split Value pointer of a node
#define PsvOfLprul(prul)                (&(prul)->svl.sv)


// Return the value1 field for an rule node
#define Rulv1(rulv)                     W1OfPsv((SV *) &(rulv))

// Set the value1 field for a node
#define SetRulv1(rulv, w)               SetW1OfPsv(((SV *) &(rulv)), (w))

// Return the value2 field
#define Rulv2(rulv)                     W2OfPsv((SV *) &(rulv))

// Set the value2 field for a node
#define SetRulv2(rulv, w)               SetW2OfPsv(((SV *) &(rulv)), (w))


// Return the confidence value of a node node
#define WConfidence(prul)               Rulv1OfLprul(prul)

// Set the confidence value of a node node
#define SetConfidence(prul, wValue)     SetRulv1OfLprul((prul), (wValue))

// Return the doubt value of a node node
#define WDoubt(prul)                    Rulv2OfLprul(prul)

// Set the doubt value of a node node
#define SetDoubt(prul, wValue)          SetRulv2OfLprul((prul), (wValue))


// OBSOLETE FORMS OF MACROS
#define WValueOfIrul(irul)              RulvOfIrul(irul)
#define SetWValueOfIrul(irul, rulv)     SetRulvOfIrul(irul, rulv)
#define WRulValue1(prul)                Rulv1OfLprul(prul)
#define SetWRulValue1(prul, w)          SetRulv1OfLprul((prul), (w))
#define WRulValue2(prul)                Rulv2OfLprul(prul)
#define SetWRulValue2(prul, w)          SetRulv2OfLprul((prul), (w))

// Return the rule node for the rule value
#define LprulOfWValue(lplValue) \
            ((MSORUL *) \
                (((char *) lplValue) - CchStructOffset(MSORUL, svl.lValue)))

#ifdef DEBUG
// Return the value name or rule text of the rule node structure pointer
#define LpchRulName(prul)   ((prul)->lpchName)

// Return the value name or rule text of the rule node structure pointer
#define LpchIrulName(irul)  LpchRulName(LprulFromIrul(irul))

// Return debug rule name for dynamic rule
#define PszNameDynLprul(prul) \
            (vlpruls->rgpchDynNames[(prul)->irul - IrulCompiledMax()])
#endif /* DEBUG */

// Return the node evaluation level for the node
#define RulevlOfPrul(prul) \
            (prul->rulevl)

// Return the event_type for the node
#define RulevtOfLprul(prul) \
            RulevtOfRulevl(RulevlOfPrul(prul))

// Return the event_type for the evaluation level
#define RulevtOfRulevl(rulevl) \
            (vlpruls->rgrulevtFromRulevl[rulevl])

// Return the rule queue of the rule level
#define LplprulQueueOf(rulevl)  (&vlpruls->rgprulActiveQueues[rulevl])

// Return the delayed-evaluation rule queue of the event_type
#define LplprulDelayedQueueOf(rulevt) \
            (&vlpruls->rgprulDelayedQueues[rulevt])

// Return the minimum evaluation level of the event_type
#define RulevlMinOfRulevt(rulevt) \
            (vlpruls->rgrulevlRulevt[(rulevt)])

// Return the maximum evaluation level of the event_type
#define RulevlMaxOfRulevt(rulevt) \
            (vlpruls->rgrulevlRulevt[(rulevt) + 1])

// Return the list of dependent node references of node ID
#define LpruldepFromIrul(irul) \
            (vlpruls->rgpruldepDependents[irul])

// Return the list of dependent node references of node
#define LpruldepGetDependents(prul) \
            LpruldepFromIrul(IrulFromLprul(prul))

// Set the list of dependent node references of node ID
#define SetLpruldepFromIrul(irul, pruldep) \
            (vlpruls->rgpruldepDependents[irul] = (pruldep))

// Set the list of dependent node references of node
#define LpruldepSetDependents(prul, pruldep) \
            SetLpruldepFromIrul(IrulFromLprul(prul), (pruldep))

// Return the list of dependent node references of node ID for specific group
#define LpruldepFromRulgIrul(rulg, irul) \
            (*LplpruldepForRulgIrul(rulg, irul))

// Set the list of dependent node references of node ID for specific group
#define SetLpruldepFromRulgIrul(rulg, irul, pruldep) \
            (*LplpruldepForRulgIrul(rulg, irul) = (pruldep))

// Return the address of the start of a ruldep list for the irul and group
#define LplpruldepForRulgIrul(rulg, irul) \
            (&(vlpruls->rgrgpruldepDependents[rulg][irul]))

// Return whether a dependent reference is in fact a delay specfication
#define FIsDelayFactor(lprulDepend) \
            ((unsigned long) (lprulDepend) < wDelayMax)

// Return the delay value associated with the dependency record
#define CDelayFromLpruldepend(lprulDepend) \
            ((int) ((unsigned long) lprulDepend))

// Return a dependency record to represent the delay factor
#define LpruldependFromCDelay(cDelay) \
            ((MSORUL *) (cDelay))

// Add a delay to the delay field of a delayed rule
#define AddCDelayToLprul(prul, cDelay) \
            ((prul)->wDelayMask |= (cDelay))

// Return whether a rule has any delay factor
#define FHaveCDelay(prul) \
            ((prul)->wDelayMask)

// Return whether a rule has a specific delay factor
#define FHaveCDelayOf(prul, cDelay) \
            ((prul)->wDelayMask & (cDelay))

// Decrement the node's delay counts (by shifting right)
#define DecrementCDelaysOfLprul(prul) \
            ((prul)->wDelayMask >>= 1)


// Return whether the (event) node is marked for history recording
#define FHistoryRecordLprul(prul) \
            (TRUE)                                      // First version
//          ((prul)->fRecordHistory)                    // Correct version


// Return whether node must check interval counts to detect seq discontinuities
#define FIntervalsSeqCheckedPrul(prul) \
            ((prul)->ipfnrulscSeqCheck)

// Return interval counts associated with node that has sequence checking
#define WIntervalsSeqCheckedPrul(prul) \
            ((*vlpruls->rgpfnrulscSeqCheck[(prul)->ipfnrulscSeqCheck])())


// Return whether the rule base is initialized
#define FRulesInited(lpruls)    (lpruls != NULL  &&  lpruls->fInited)


// Return the op-code instructions for an interpreted rule ID
#define PociiForIrul(irul) \
            PociiForPrul(LprulFromIrul(irul))

// Return the op-code instructions for an interpreted rule
#define PociiForPrul(prul) \
            ((MSOOCII *) vlpruls->rgpociiRules[((prul)->ipociiInstrs)])

// Return any group(s) that append(s) the current group
#define RulgAppendedFrom(rulg) \
            (vlpruls->prulgAppendedFrom[rulg])

// Return the list of groups that append from other groups
#define PrulgAppendedFrom() \
            (vlpruls->prulgAppendedFrom)

// Return the group (if any) that the current group appends to
#define RulgAppendTo(rulg) \
            (vlpruls->prulgAppendTo[rulg])

// Return the list of groups that append to other groups
#define PrulgAppendTo() \
            (vlpruls->prulgAppendTo)


#define rulgNil         (-1)                            // "No" rule group
#define rulevtNil       (-1)                            // "No" event type

#ifdef DEBUG
// Return whether node is marked for automatic backtracing */
#define FTraceLprul(prul) \
            ((prul)->irulNextTrace != 0)
#endif /* DEBUG */

// Return the list of nodes that current node depends upon
#define LpirulGetDependsOn(prul) \
            (&vlpruls->lpgrpirulDependBack[(prul)->birulDependsOn])



/*************************************************************************
    Prototypes and macros for rule.c
 *************************************************************************/

#ifndef max
#define max(a,b)    ((a) > (b) ? (a) : (b))
#endif /* !max */
#ifndef min
#define min(a,b)    ((a) < (b) ? (a) : (b))
#endif /* !max */


// Push the node onto the queue
#define PushLprul(prul, lplprulQ)  \
            ((prul)->prulNext = *(lplprulQ), \
             *(lplprulQ) = (prul))

// Pop the node from the queue into the variable
#define PopLprul(lplprul, lplprulQ)  \
            (*lplprul = *lplprulQ, \
             *lplprulQ = (*lplprul)->prulNext, \
             (*lplprul)->prulNext = 0)

// Push event node into Auto-Clear (Changed) list
#define PushLpRulChanged(prul) \
            if ((prul)->irulNextChanged == 0) \
                { \
                int     rulevt = RulevtOfLprul(prul); \
                \
                (prul)->irulNextChanged \
                    = vlpruls->rgirulRulevtChanged[rulevt]; \
                vlpruls->rgirulRulevtChanged[rulevt] = IrulFromLprul(prul); \
                }

// Mark event as never Auto-Clearing
#define SetNoAutoClearRulv(rulv) \
            (LprulFromRulv(rulv)->irulNextChanged = irulNoAutoClear)
#define SetNoAutoClearLprul(prul) \
            ((prul)->irulNextChanged = irulNoAutoClear)

#define irulChangedNil      -1
#define irulNoAutoClear     -2

// Return the offset of a field from the start of its typedef'd structure
// NOTE: THIS IS TRICKY CODE, BUT COMPLETELY LEGAL C!!
//       To understand it, remember that 0 is a valid pointer for ALL types!
#define CchStructOffset(type, field) \
            (((char *) (&((type *) 0)->field)) - ((char *) 0))


// Call Rule Evaluation function provided by Application
#define FEvalRule(irul) \
            (*vlpruls->lpfnEvalRule)(irul)


#ifndef STATIC_LINK_EM
MSOAPI_(RULS **) MsoPvlprulsMirror(RULS **pvlprulsApp); // Exchange &vlpruls
#else /* STATIC_LINK_EM */
#define MsoPvlprulsMirror(pvlprulsApp)  pvlprulsApp
#endif /* !STATIC_LINK_EM */
MSOAPI_(int) MsoFInitRules(                             // Init rule base
    LPFNRulinit         lpfnRulInit,
    RULS               *lpruls
    );
IRUL IrulDefineEvent(int rulevt, char *szName);         // Define simple event
MSOAPI_(MSOKWD *) MsoFDefineStringKwdEvent(             // Define str kwd event
    int                 rulevt,
    char               *szName,
    XCHAR              *pxch,
    int                 cch,
    int                 ikwtb
    );
MSOAPI_(MSOKWDLH *) MsoFDefineIntegerKwdEvent(          // Define int kwd event
    int                 rulevt,
    char               *szName,
    long                lValue,
    int                 ikwtb
    );
MSOAPI_(void) MsoClearRules(void);                      // Clear nodes & state
MSOAPI_(void) MsoClearEventsForRulevts(                 // Clr rg of ev types
    int                 rulevtFirst,
    int                 drulevtCount,
    int                 fSavePersistentDelayed,
    int                 fClearChanged,
    int                 fClearIntervalCounts
    );
MSOAPI_(void) MsoRestorePersistentDelayedRules(void);   // Restore delayed Q
MSOAPI_(int) MsoFAddPruldepDependent(                   // Add dependent link
    IRUL                irul,
    MSORUL             *prulDependent,
    int                 cDelay,
    int                 rulg
    );
MSOAPI_(void) MsoFixUpPruldeps(                         // Fix up after insert
    IRUL                irul,
    int                 rulg,
    int                 rulgBase,
    RULDEP             *lpruldepOldList,
    RULDEP             *lpruldepNewList
    );
MSOAPI_(int) MsoFDelPruldepDependent(                   // Del dependent link
    IRUL                irul,
    MSORUL             *prulDependent,
    int                 rulg,
    int                 fDiscard
    );
MSOAPI_(void) MsoSetActiveRuls(RULS *pruls);            // Set curr vlpruls
MSOAPI_(void) MsoFreeRuleMem(RULS *pruls);              // Free rule memory
#ifdef OFFICE_BUILD
MSOAPI_(void) MsoMarkRuleMem(RULS *pruls);              // Mark rule mem used
#endif /* OFFICE_BUILD */
MSOAPI_(void) MsoSetEventTypeRulevt(int rulevt);        // Change event_types
MSOAPI_(void) MsoClearChangedEventsForRulevt(int rulevt);// Clr event_type vals
void RemoveLprulChanged(MSORUL *prul);                  // Un-auto-clear event
MSOAPI_(int) MsoEvaluateEvents(int rulevt);             // Event evaluation
MSOAPI_(int) MsoFEvalIrul(IRUL irul);                   // Eval single node
MSOAPI_(void) MsoDelaySignalIrul(                       // Signal node w/delay
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
MSOAPI_(void) MsoDelaySignalIrulFrom(                   // Signal node w/delay
    IRUL                irul,
    IRUL                irulFrom,
    int                 cDelay
    );
MSOAPI_(void) MsoSignalIrul(IRUL irul, long lValue);    // Cond schedule irul
#define PushIrulToEval(irul, lValue) \
            MsoSignalIrul(irul, lValue)
MSOAPI_(void) MsoScheduleIrul(IRUL irul, long lValue);  // Schedule rule to run
#ifdef DEBUG
MSOAPI_(void) MsoScheduleIrulDebug(IRUL irul, long lValue);// Log and schedule
MSOAPI_(void) MsoScheduleIrulDebugMso(IRUL irul, long lValue);//Log &sched MSO
#else
#define MsoScheduleIrulDebug    MsoScheduleIrul
#define MsoScheduleIrulDebugMso MsoScheduleIrul
#endif /* DEBUG */

MSOAPI_(void) MsoDelayScheduleIrul(                     // Schedule after delay
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
#ifdef DEBUG
MSOAPI_(void) MsoDelayScheduleIrulDebug(                // Log and schedule
    IRUL                irul,
    long                lValue,
    int                 cDelay
    );
#else
#define MsoDelayScheduleIrulDebug   MsoDelayScheduleIrul
#endif /* DEBUG */
MSOAPI_(void) MsoDelayScheduleIrulFrom(                 // Sched, pass value
    IRUL                irul,
    IRUL                irulFrom,
    int                 cDelay
    );
MSOAPI_(int) MsoFEvalIrulImmediately(                   // Eval irul now
    IRUL                irul,
    long                lValue
    );
MSOAPI_(void) MsoPushLprulDependents(MSORUL *prul);     // Push dependents
MSOAPI_(void) MsoPushDelayedEvalForRulevt(int rulevt);  // Push delayed nodes
MSOAPI_(void) MsoAutoClearIrul(IRUL irul);              // Mark node for clear
MSOAPI_(int) MsoFAliasPrulPrul(                         // Ret if 2 are aliases
    MSORUL             *prul,
    MSORUL             *prulTarget
    );
void RecordLprulHistory(MSORUL *prul);                  // Push ev into hist
#ifdef NEVER
MSOAPI_(int) MsoFIrulHistoryValueWas(                   // Look 4 event in hist
    int                 dirultkBackwards,
    long               *lpwVar
    );
#endif // NEVER
#ifdef NEED_AS_FUNCTION
void SetCurrRulg(int rulgGroup);                        // Set rule group
#endif /* NEED_AS_FUNCTION */
MSOAPI_(void) MsoSignalEventIrul(IRUL irul, long lValue);// Signal an event
MSOAPI_(void) MsoSignalEventIrulFrom(                   // Signal ev from node
    IRUL                irul,
    IRUL                irulFrom
    );
#ifdef NEVER
MSOAPI_(void) MsoSetRuleConfid(IRUL irul, int wFactor); // Set confidence val
#endif // NEVER

// Schedule a node for deferred evaluation, based upon a decision rule
//  This macro gets invoked twice.  See _MsoFDeferIrul() for details.
#define FDeferIrul(irul) \
            (vlpruls->fEvaluatingDeferred ||  _MsoFDeferIrul(irul))

#define FDeferIrulExpr(irul, lExpr) \
            (vlpruls->fEvaluatingDeferred \
                ||  (((int) lExpr)  &&  _MsoFDeferIrul(irul)))

#define FDeferIrulExprL(irul, lExpr, lValue) \
            (vlpruls->fEvaluatingDeferred \
                ||  (((int) lExpr)  &&  _MsoFDeferIrulL((irul), (lValue))))

#define IrulPickDeferred(irulDecision) \
            MsoIrulPickDeferred(irulDecision)

MSOAPI_(int) _MsoFDeferIrul(IRUL irul);                 // Add to defer list
MSOAPI_(int) _MsoFDeferIrulL(IRUL irul, long lValue);   // Add to defer w/value
MSOAPI_(IRUL) MsoIrulPickDeferred(IRUL irulDecision);   // Pick from defer list


MSOAPI_(void) MsoSetRulNotify(                          // Set up notification
    long                lExprValue,                     // Really an int
    IRUL                irulDecision,
    IRUL                irulNotify
    );
MSOAPI_(int) MsoFRulNotify(long wNotify);               // Notify on next eval
MSOAPI_(int) MsoFRulNotifyImmediately(long wNotify);    // Notify immediately
MSOAPI_(long) MsoRulvElement(IRUL irulArray, IRUL iirul);// Get value of array
MSOAPI_(void) MsoSetElementRulv(                        // Set value of array
    IRUL                irulArray,
    IRUL                iirul,
    long                lValue
    );
MSOAPI_(void) MsoSetAllElementsToRulv(                  // Set all vals of arr
    IRUL                irulArray,
    IRUL                cirul,
    long                lValue
    );


/* M S O  F  A C T I V A T E  I R U L */
/*----------------------------------------------------------------------------
    %%Function: MsoFActivateIrul
    %%Contact: daleg

    Activate a node in the rulebase
----------------------------------------------------------------------------*/

_inline int MsoFActivateIrul(IRUL irul)                 // Activate a node
{
    MSOPRUL             prul = LprulFromIrul(irul);

    if (prul->prulNext == msoprulInactive)
        {
        prul->prulNext = (MSOPRUL) NULL;
        return TRUE;
        }
    else
        return FALSE;
}


/* M S O  F  D E A C T I V A T E  I R U L */
/*----------------------------------------------------------------------------
    %%Function: MsoFDeactivateIrul
    %%Contact: daleg

    Deactivate a node in the rulebase
----------------------------------------------------------------------------*/

MSOAPI_(int) _MsoFDeactivateIrul(IRUL irul);            // Deactivate a node

_inline int MsoFDeactivateIrul(IRUL irul)
{
    MSOPRUL             prul = LprulFromIrul(irul);

    if (prul->prulNext == NULL)
        {
        prul->prulNext = msoprulInactive;
        return TRUE;
        }
    else
        return _MsoFDeactivateIrul(irul);
}


MSOAPI_(int) MsoFDeleteIrul(IRUL irul, int rulg);       // Delete a node


/*************************************************************************
    Prototypes and macros for rultest.c and rulconcl.c.
    These prototypes "Hungarianize" the rule code so that the rule
    authors do not have to know Hungarian, but it is preserved within
    the application code.
 *************************************************************************/

// Return the current interval number for the event_type
#define CIntervalsRulevt(rulevt) \
            (vlpruls->rgdtkiRulevt[rulevt])

// OBSOLETE: Return the current interval number for the event_type
#define CIntervalsRsct(rulevt)              CIntervalsRulevt(rulevt)

// Increment the current interval number for the event_type
#define IncrIntervalsRsct(rulevt, dc) \
            (vlpruls->rgdtkiRulevt[rulevt] += (dc))

#ifdef NEVER
// Set long value of a node and force propagation
#define SetValue(wVar, lValue) \
            SignalEvent(wVar, lValue)
#endif /* NEVER */

// Convert a "variable" event reference to an node address
#define LprulFromRulv(rulvVar) \
            LprulOfWValue(&(rulvVar))

// Notify a node, on its next evaluation pass
#define FNotify(rgwVar) \
            MsoFRulNotify(rgwVar)

// Notify an action rule, immediately
#define FNotifyImmediately(rgwVar) \
            MsoFRulNotifyImmediately(rgwVar)

// Indicate the next event_type to enter when current event_type is exited
#define SetNextEventType(rulevt) \
            if (vlpruls->prulevtEvalLim \
                    < vlpruls->rgrulevtEval + RulevtMax()) \
                (*vlpruls->prulevtEvalLim++ = (rulevt)); \
            else \
                AssertSz0(FALSE, "Exceeded max number of rulevts to eval");

// Force delayed evaluation of rule of given ID: GENERATED BY RULE COMPILER
#define DelayEvalIrul(irul, cDelay) \
            MsoDelayScheduleIrulFrom((irul), (irul), (cDelay))

// Return whether the dirultkBackwards'th previous value was the given event
#define ValueWas(dirultkBackwards, wVar) \
            MsoFIrulHistoryValueWas(dirultkBackwards, &(wVar))

// Find the given value in its event_type history, and return the (neg) offset
#define FindPrevValueFrom(dirultkBackwards, wVar) \
            DirultkFindPrevValueFrom(dirultkBackwards, &(wVar))

// Mark event/rule for automatic clearing on event_type exit
#define AutoClear(irul) \
            MsoAutoClearIrul(irul)

// Mark expression as exempt from dependency linkage in rule if
#define Value(expr) (expr)

// Push all dependents of node of ID onto their evaluation queues
#define Propagate(irul) \
            MsoPushLprulDependents(LprulFromIrul((int) irul))

// Evaluate the rule at normal time
#define GoToRule(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 0 /* cDelay */)

// Evaluate the rule at normal time
#define GoToIrul(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 0 /* cDelay */)

// Evaluate the rule after delay of 1, incrementing value
#define GoToIrulNoValue(irul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irul), (IRUL) (irul), 1 /* cDelay */)

// Evaluate the rule at normal time
#define GoToDirul(dirul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irulSelf) + (dirul), (irulSelf), 0 /* cDelay */)

// Evaluate the rule after delay of 1
#define DelayGoToRule(irul) \
            DelayGoToIrulNoValue(irul)

// Signal the event with the given value
#define SignalIrul(irul, lValue) \
            MsoSignalIrul(irul, lValue)

// Signal the event with the given value
#define SignalEvent(wVar, lValue) \
            MsoSignalEventIrul(IrulFromLprul(LprulFromRulv(wVar)), (lValue))

// Signal the event with the given value
#define SignalEventIrul(irul, lValue) \
            MsoSignalEventIrul(irul, lValue)

// Signal the node with the value from the current rule
// REVIEW: THIS IS WRONG, NOT CONDITIONALLY SCHEDULING IF EVENT
#define SignalIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 0)

// Signal the event with the value from the current rule
#define SignalEventIrulSelf(irul) \
            MsoSignalEventIrulFrom((IRUL) (irul), (irulSelf))

// Evaluate the event after delay of 1
#define DelaySignalEventIrul(irul, lValue) \
            MsoDelayScheduleIrul((irul), (lValue), 1 /* cDelay */)

// Evaluate the event after specified delay
#define DelaySignalEventIrulAfter(irul, lValue, cDelay) \
            MsoDelayScheduleIrul((irul), (lValue), 1 << ((cDelay) - 1))

// Evaluate the node after delay of 1, getting value from rule
#define DelaySignalIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((irul), (irulSelf), 1 /* cDelay */)

// Evaluate the event after delay of 1, getting value from rule
#define DelaySignalEventIrulSelf(irul) \
            MsoDelayScheduleIrulFrom((irul), (irulSelf), 1 /* cDelay */)

// Evaluate the event after delay of 1
// REVIEW daleg: OBSOLETE: USE DelaySignalEventIrul or "then ... (<event>)"
#define DelaySignalIrul(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 1 /* cDelay */)

// Evaluate the event after delay of 1
#define DelaySignal(rulvVar) \
            DelaySignalRulv((rulvVar), TRUE)

// Evaluate the event after delay of 1
#define DelaySignalRulv(rulvVar, lValue) \
            CDelaySignalRulv((rulvVar), (lValue), 1 /* cDelay */)

// Evaluate the event after delay of 1
#define CDelaySignalRulv(rulvVar, lValue, cDelay) \
            MsoDelayScheduleIrul(LprulFromRulv(rulvVar)->irul, (lValue), \
                                 (cDelay))

// Evaluate the rule after delay of 1 passing TRUE as the value
#define DelayGoToIrul1(irul) \
            MsoDelayScheduleIrul((irul), TRUE, 1 /* cDelay */)

// Evaluate the rule after specified delay
#define DelayGoToIrulAfter(irul, cDelay) \
            MsoDelayScheduleIrul((irul), TRUE, 1 << ((cDelay) - 1))

// Evaluate the rule with value after specified delay
#define DelayGoToIrulWithRulvAfter(irul, lValue, cDelay) \
            MsoDelayScheduleIrul((irul), (lValue) - (cDelay) + 1, \
                                 1 << ((cDelay) - 1))

// Evaluate the rule after specified delay
#define DelayGoToDirulAfter(dirul, cDelay) \
            MsoDelayScheduleIrulFrom((IRUL) (irulSelf + (dirul)), (irulSelf), \
                                     1 << ((cDelay) - 1))

// Evaluate the rule after delay of 1, incrementing value
#define DelayGoToIrulNoValue(irul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irul), (IRUL) (irul), 1 /* cDelay */)

// Evaluate the rule after delay of 1, passing the value of the current node
#define DelayGoToIrul(irul) \
            MsoDelayScheduleIrulFrom((IRUL) (irul), (irulSelf), 1 /* cDelay */)

// Evaluate the rule (via relative offset) after delay of 1
#define DelayGoToDirul(dirul) \
            MsoDelayScheduleIrulFrom \
                ((IRUL) (irulSelf + (dirul)), (irulSelf), 1)

// Evaluate the rule (via relative offset) after delay of 1
#define DelayGoToDirulNoValue(dirul) \
            MsoDelayScheduleIrulFrom((IRUL) (irulSelf + (dirul)), \
                                     (IRUL) (irulSelf + (dirul)), 1)

// Evaluate the rule (via relative offset) after delay of 1, with value rulv
#define DelayGoToDirulWithRulv(dirul, rulv) \
            (SetRulvOfIrul(irulSelf + (dirul), (rulv)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with value rulv2
#define DelayGoToDirulWithRulv2(dirul, rulv2) \
            (SetRulv2OfIrul(irulSelf + (dirul), (short) (rulv2)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with value rulv2
#define DelayGoToDirulWithRulv1(dirul, rulv1) \
            (SetRulv1OfIrul(irulSelf + (dirul), (short) (rulv1)), \
             DelayGoToDirulNoValue(dirul))

// Evaluate the rule (via relative offset) after delay of 1, with values
#define DelayGoToDirulWithRulvs(dirul, rulv1, rulv2) \
            (SetRulv1OfIrul(irulSelf + (dirul), (short) (rulv1)), \
             SetRulv2OfIrul(irulSelf + (dirul), (short) (rulv2)), \
             DelayGoToDirulNoValue(dirul))

// Deactivate curr rule if the fTest value is FALSE: used in rule test clause
#define FAutoDeactivateSelf(fTest) \
            FAutoDeactivateIrul(irulSelf, (fTest))

// Deactivate the rule if the fTest value is FALSE: used in rule test clause
#define FAutoDeactivateIrul(irul, fTest) \
            ((fTest) ? FALSE : (_MsoFDeactivateIrul(irul), TRUE))

// Set the Rule Propagation Group to the given value
#define SetCurrRulg(rulgGroup) \
            (vlpruls->rgpruldepDependents \
                = vlpruls->rgrgpruldepDependents[vlpruls->rulgCurr \
                                                        = rulgGroup])

// Return the current main Rule Propagation Group
#define FCurrRulg(rulg) \
            (vlpruls->rulgCurr == (rulg))



/*************************************************************************
    Prototypes and macros for Debugging and Error Handling
 *************************************************************************/

#ifdef DEBUG
MSOAPI_(int) MsoFTraceIrul(IRUL irul, int fTraceOn);    // Trace a node
char *SzFromFixed3(long lValue, char *pchBuf);          // Fixed to sz conv

#define DebugDumpQueues(wTraceLvl, sz, lValue, wToLevel) \
            { \
            static const unsigned char      _szDump[] = sz; \
            \
            _DumpQueues(wTraceLvl, _szDump, lValue, wToLevel); \
            }
#define DebugDumpQueue(wTraceLvl, rulevl) \
            _DumpQueue(wTraceLvl, rulevl, LplprulQueueOf(rulevl))

#else /* !DEBUG */
#define DebugDumpQueues(wTraceLvl, sz, lValue, wToLevel)
#define DebugDumpQueue(wTraceLvl, rulevl)

#endif /* DEBUG */


MSOEXTERN_C_END     // ****************** End extern "C" *********************


#define EMRULE_H

#if !(defined(OFFICE_BUILD)  ||  defined(XL))

#ifdef DYN_RULES
int FLoadDynEmRules(void);                              // Load dyn rulebase
#include "emruloci.h"
#endif /* DYN_RULES */

#endif /* !OFFICE_BUILD */

#endif /* !EMRULE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\msodbglg.h ===
/*----------------------------------------------------------------------------
    %%File: msodbglg.h
    %%Unit: Debug
    %%Contact: daleg

    Debugging macros and functions.

    The debug log mechanism automatically creates and manages a log file
    "debug.log".  By controlling a single variable, vwDebugLogLvl, we
    can route printf()-style output to a log file, or to the Comm port
    AND the log file.

    The log is created and written to whenever the run-time log level,
    vwDebugLogLvl >= wTraceLvl.  wTraceLvl is the declared, or compile-
    time log level, passed as an argument to MsoDebugLog().  It will NOT print
    if vwDebugLogLvl is LESS than the declared trace level.  If
    vwDebugLogLvl is an ODD number, anything written to the log file
    will also appear on the port used by OutputDebugString().

    NOTE:
        THE SPRINTF STRING MUST NOT EXPAND BEYOND 256 CHARACTERS!

    USAGE:

        There are several macros, debugXX0() thru debugXX6(), etc.,
        that are the main interface to MsoDebugLog(), where "XX" is the
        subsystem mneumonic.  EACH SUBSYSTEM GROUP SHOULD HAVE ITS OWN SET
        OF MACROS.  Thus the Event Monitor group adds debugEM0 thru
        debugEM6() and the Hyperlink group might add debugHL0 thru
        debugHL6, etc.  EACH SUBSYSTEM GETS ITS OWN LOG FILTER BIT,
        DEFINED BELOW (see fDebugFilterEm), which allows developers to
        see their logging info without having to wade through other logging
        output.

        MsoDebugLog() has a variable number of arguments, and is
        similar to the standard C sprintf() routine, and in fact calls it.
        The macros remove the need to enclose calls to MsoDebugLog() with
        #ifdef's, but C does not allow variable numbers of arguments in
        macros.  To overcome this (and also due to problems with CsConst'ing
        the format strings), each debugxx() macro has a fixed number of
        arguments, where xx indicates the number of arguments past the format
        string.

        Examples:

            debugXX0((fTrace ? 0 : 6), "Value is NOT chosen\n");
            debugXX1(6, "NEW SECTION: %d\n", wSection);
            debugXX4(2, "Paragraph %d (CP %ld thru %ld) has style %d\n",
                     iaftag, lpaftag->cpFirst, (lpaftag + 1)->cpFirst, istd);

        The first argument to the macros is the wTraceLvl, the declared
        trace-level.  In the three examples above, we are saying: the first
        should not print unless vwDebugLogLvl >= (fTrace ? 0 : 6),
        the second unless vwDebugLogLvl >= 6, and the third unless
        vwDebugLogLvl >= 2.

    CHOICE OF DECLARED TRACE LEVELS:

        In general, low declared trace levels should be used within discrete
        subsystems that are *not* shared, and high levels should be used
        within shared code.  Note that only EVEN numbers are used.  The
        reason will be explained below.

        THE HIGHER THE LEVEL NUMBER, THE MORE GOO YOU ARE GOING TO OUTPUT.

            Level       Generally used when:
            ------------------------------------------------------
            -1          Warning messages.

            0           Messages to be seen by testers.
            2           Message to be seen by rigorous testers.

            4           Structural changes, such as dialog boxes appearing,
                        Windows created, features beginning.

            6           Normal logging of a subsystem.
            8           Detailed logging of a subsystem.

            10          Major subsystem I/O, such as scanning CHRs, or
                        reading buffers.
            12          Minor subsystem I/O, such as reading characters.

            ...

            20          Shared subsystem, such as FormatLine, CachePara
                        or something else that we would call frequently,
                        and be buried under detail.

    RUN-TIME USAGE:

        Set vwDebugLogLvl to an ODD number, if you wish output via
        OutputDebugString() as well as the log file.  Set vwDebugLogLvl to an
        EVEN number if you wish output only to the log file.

        Set vwDebugLogLvl to a low level using the dialog box.  For
        higher levels (e.g. to debug FormatLine()), you should set a
        breakpoint in the debugger, and set vwDebugLogLvl when in the
        targeted routine.

        Example (from Word):

            1.  We set vwDebugLogLvl to 2 from the dialog box in the
                "Preferences" memu.  We also set a breakpoint within
                TkLexText().
            2.  We run the AutoFormatter, and when we hit the breakpoint,
                we set vwDebugLogLvl from the watch window to 8,
                so we will get a lot of output.
            3.  When we approach the interesting point of a problem, we
                change the vwDebugLogLvl to 9, so it will appear on
                the OutputDebugStringA() terminal.

----------------------------------------------------------------------------*/

#ifndef MSODBGLG_H
#define MSODBGLG_H

#include <stdarg.h>

#if defined(STANDALONE)  &&  !defined(MSOEXTERN_C_BEGIN)
#define MSOEXTERN_C_BEGIN
#define MSOEXTERN_C_END
#endif // STANDALONE

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************

#ifndef UNIX
#if _MSC_VER <= 600
#ifndef __cdecl
#define __cdecl _cdecl
#endif /* !__cdecl */
#endif /* MSC_VER <= 600 */

#else
#define __cdecl
#define sprintf ansi_sprintf
#define vsprintf ansi_vsprintf
int ansi_sprintf(char *lpchBuf, const char *sz, ...);
int ansi_vsprintf(char *lpchBuf, const char *sz, va_list ap);
#define CommSz printf
#endif /* !UNIX */


// Define filters for MsoDebugLog()
// These values can overlap for different applications.
// However, Office reserves the lower 0x00FF bits.

#define fDebugFilterEm          0x0001U                 // App Event Monitor
#define fDebugFilterWc          0x0002U                 // Web Client
#define fDebugFilterAcb         0x0004U                 // Active ClipBoard
#define fDebugFilterEc          0x0008U                 // Exec Command (DOIT)
#define fDebugFilterMsoEm       0x0010U                 // MSO Event Monitor

#if defined(WORD_BUILD)
#define fDebugFilterPrint       0x0100U                 // Print
#define fDebugFilterReconcil    0x0200U                 // Reconcile
#define fDebugFilterHtmlIn      0x0400U                 // HTML in

#elif defined(EXCEL_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in Excel

#elif defined(PPT_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in PPT

#elif defined(ACCESS_BUILD)
#define fDebugFilterUnused1     0x0100U                 // Use me 1st in Access
#endif

#define fDebugFilterAll         0xFFFFU


#ifdef STANDALONE
#undef wsprintfA
#define wsprintfA sprintf
#undef wvsprintfA
#define wvsprintfA vsprintf
#include <stdio.h>
#endif /* STANDALONE */

#ifdef DEBUG
#ifndef WORD_BUILD
extern int vwDebugLogFilter;                            // Debug trace filter
extern int vwDebugLogLvl;                               // Debug trace level
#endif /* !WORD_BUILD */

#ifdef STANDALONE

#ifndef MSOAPI_
#define MSOAPI_(t)              t __stdcall
#endif /* !MSOAPI_ */

#ifndef MSOCDECLAPI_
#define MSOCDECLAPI_(t)         t __cdecl
#endif /* !MSOCDECLAPI_ */

#endif // STANDALONE

// Return the sz, or if null, return "(null)"
#define SzOrNull(sz) \
            ((sz) != NULL ? (sz) : "(null)")

MSOCDECLAPI_(void) MsoDebugLog(                         // Print debug msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    const unsigned char *sz,
    ...
    );
MSOCDECLAPI_(void) MsoAssertSzProcVar(                  // Assert with sprintf
    const char         *szFile,
    int                 line,
    const char         *sz,
    ...
    );
MSOCDECLAPI_(int) MsoFReportSzProcVar(                  // ReportSz w/ sprintf
    const char         *szFile,
    int                 line,
    const char         *sz,
    ...
    );
MSOCDECLAPI_(void) MsoCommSzVar(const char *sz, ...);   // CommSz with sprintf
MSOAPI_(void) MsoDebugLogAp(                            // Print debug msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    const unsigned char *sz,
    va_list             ap
    );
MSOAPI_(void) MsoDebugLogPch(                           // Print large msg
    int                 wTraceLvl,
    unsigned int        grfFilter,
    char               *pch,
    int                 cchLen,
    int                 fIsRgxch
    );
MSOAPI_(void) MsoAssertSzProcAp(                        // AssertSz using ap
    const char         *szFile,
    int                 line,
    const char         *sz,
    va_list             ap
    );
MSOAPI_(int) MsoFReportSzProcAp(                        // ReportSz using ap
    const char         *szFile,
    int                 line,
    const char         *sz,
    va_list             ap
    );
MSOAPI_(void) MsoCommSzAp(const char *sz, va_list ap);  // CommSz using ap
MSOAPI_(int) MsoFDebugLogCloseFile(void);               // Close log file
MSOAPI_(int *) MsoPwDebugLogLvl(int **ppwDebugLogFilter);// Return ptr to vars

// These *debug* routines are XCHAR (WCHAR on unicode builds and char on ANSI)
#ifndef ANSI_XCHAR
#ifdef cbXchar
MSOAPI_(XCHAR *) MsoXszFromRgxchDebug(                  // Convert pwch to wz
    XCHAR              *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromRgxchDebug(                    // Convert pwch to sz
    const XCHAR        *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromXszDebug(const XCHAR *xsz);    // Convert wz to sz
#endif /* cbXchar */
#else /* ANSI_XCHAR */
MSOAPI_(char *) MsoXszFromRgxchDebug(                   // Convert pwch to wz
    char               *rgxch,
    int                 cch
    );
MSOAPI_(char *) MsoSzFromRgxchDebug(                    // Convert pwch to sz
    const char         *rgxch,
    int                 cch
    );
#define MsoSzFromXszDebug(xsz) (xsz)
#endif /* !ANSI_XCHAR */



// NOTE: debugvar has to be called with 2 parenthesis...
#define debugvar(a)     MsoDebugLog a
#define Debug(e)        e
#define DebugElse(s, t) s
#define debuglog0(wLevel, grfFilter, sz) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug); \
            } while (0)
#define debuglog1(wLevel, grfFilter, sz, a) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a); \
            } while (0)
#define debuglog2(wLevel, grfFilter, sz, a, b) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b); \
            } while (0)
#define debuglog3(wLevel, grfFilter, sz, a, b, c) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c); \
            } while (0)
#define debuglog4(wLevel, grfFilter, sz, a, b, c, d) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d); \
            } while (0)
#define debuglog5(wLevel, grfFilter, sz, a, b, c, d, e) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d, e); \
            } while (0)
#define debuglog6(wLevel, grfFilter, sz, a, b, c, d, e, f) \
            do { \
            static const unsigned char      szDebug[] = sz; \
            MsoDebugLog(wLevel, grfFilter, szDebug, a, b, c, d, e, f); \
            } while (0)
#define debuglogPch(wLevel, grfFilter, pch, cch) \
            MsoDebugLogPch(wLevel, grfFilter, pch, cch, fFalse)
#define debuglogPwch(wLevel, grfFilter, pwch, cwch) \
            MsoDebugLogPch(wLevel, grfFilter, (char *)pwch, cwch, fTrue)

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ       VSZASSERT
#endif /* !DEBUGASSERTSZ */

#ifndef VSZASSERT
#define VSZASSERT           static unsigned char vszAssertFile[] = __FILE__;
#endif /* !VSZASSERT */

#ifndef Assert
#define Assert(f)       AssertSz0((f), #f)
#define AssertDo(f)     Assert((f) != 0)
#endif /* !Assert */

#ifndef AssertSz
#define AssertSz(f, sz)     AssertSz0(f, sz)
#endif /* !AssertSz */

#define AssertSz0(f, sz) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert); \
            } while (0)

#define AssertSz1(f, sz, a) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a); \
            } while (0)

#define AssertSz2(f, sz, a, b) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b); \
            } while (0)

#define AssertSz3(f, sz, a, b, c) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c); \
            } while (0)

#define AssertSz4(f, sz, a, b, c, d) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c, d); \
            } while (0)

#define AssertSz5(f, sz, a, b, c, d, e) \
            do { \
            static const char       szAssert[] = sz; \
            if (!(f)) \
                MsoAssertSzProcVar \
                    (vszAssertFile, __LINE__, szAssert, a, b, c, d, e); \
            } while (0)

#ifndef WORD_BUILD
#ifdef OFFICE_BUILD

#define AssertLszProc(szMsg, szFile, line) \
            do { \
            if (MsoFAssertsEnabled() && \
                    !MsoFAssert(szFile, line, (const CHAR*)(szMsg))) \
                MsoDebugBreakInline(); \
            } while (0)

#define FReportLszProc(szMsg, szFile, line) \
            MsoFReport(szFile, line, szMsg)

#else /* !OFFICE_BUILD */
int AssertLszProc(
    const char         *szExtra,
    const char         *szFile,
    int                 line
    );
#endif /* !OFFICE_BUILD */
#endif /* !WORD_BUILD */


#ifndef ReportSz
#define ReportSz(sz)    MsoReportSz(sz)
#endif /* !ReportSz */

#define MsoReportSz(sz) \
            do { \
            static const char szXXXXXXXFar[] = sz; \
            if (!MsoFReportSzProcVar(vszAssertFile, __LINE__, szXXXXXXXFar)) \
                MsoDebugBreakInline(); \
            } while (0)

#define ReportSz0If(f, sz) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz1If(f, sz, a) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz2If(f, sz, a, b) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a, b)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define ReportSz3If(f, sz, a, b, c) \
            if (!(f)) \
                { \
                static const char       szReport[] = sz; \
                if (!MsoFReportSzProcVar \
                    (vszAssertFile, __LINE__, szReport, a, b, c)) \
                        MsoDebugBreakInline(); \
                } \
            else

#define CommSz0(sz) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm); \
            } while (0)

#define CommSz1(sz, a) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a); \
            } while (0)

#define CommSz2(sz, a, b) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b); \
            } while (0)

#define CommSz3(sz, a, b, c) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c); \
            } while (0)

#define CommSz4(sz, a, b, c, d) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c, d); \
            } while (0)

#define CommSz5(sz, a, b, c, d, e) \
            do { \
            static const char       szComm[] = sz; \
            MsoCommSzVar(szComm, a, b, c, d, e); \
            } while (0)

#ifndef NotReached
#define NotReached()    AssertSz0(fFalse, "NotReached declaration was reached")
#endif /* !NotReached */

#else /* !DEBUG */

#define debugvar(a)
#define Debug(e)
#define DebugElse(s, t) t
#define debuglog0(wLevel, grfFilter, sz)
#define debuglog1(wLevel, grfFilter, sz, a)
#define debuglog2(wLevel, grfFilter, sz, a, b)
#define debuglog3(wLevel, grfFilter, sz, a, b, c)
#define debuglog4(wLevel, grfFilter, sz, a, b, c, d)
#define debuglog5(wLevel, grfFilter, sz, a, b, c, d, e)
#define debuglog6(wLevel, grfFilter, sz, a, b, c, d, e, f)
#define debuglogPch(wLevel, grfFilter, pch, cch)
#define debuglogPwch(wLevel, grfFilter, pwch, cwch)

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ
#endif /* !DEBUGASSERTSZ */

#ifndef VSZASSERT
#define VSZASSERT
#endif /* !VSZASSERT */

#ifndef Assert
#define Assert(f)
#define AssertDo(f)     (f)
#endif /* !Assert */

#ifndef AssertSz
#define AssertSz(f, sz)
#endif /* !AssertSz */

#define AssertSz0(f, sz)
#define AssertSz1(f, sz, a)
#define AssertSz2(f, sz, a, b)
#define AssertSz3(f, sz, a, b, c)
#define AssertSz4(f, sz, a, b, c, d)
#define AssertSz5(f, sz, a, b, c, d, e)

#define ReportSz(sz)
#define MsoReportSz(sz)
#define ReportSz0If(f, sz)
#define ReportSz1If(f, sz, a)
#define ReportSz2If(f, sz, a, b)
#define ReportSz3If(f, sz, a, b, c)

#define CommSz0(sz)
#define CommSz1(sz, a)
#define CommSz2(sz, a, b)
#define CommSz3(sz, a, b, c)
#define CommSz4(sz, a, b, c, d)
#define CommSz5(sz, a, b, c, d, e)

#ifndef NotReached
#define NotReached()
#endif /* !NotReached */

#endif /* DEBUG */

// Generic debug log macros - WARNING: THIS WILL BE SEEN BY EVERYONE
#define debug0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterAll, sz)
#define debug1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterAll, sz, a)
#define debug2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterAll, sz, a, b)
#define debug3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterAll, sz, a, b, c)
#define debug4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterAll, sz, a, b, c, d)
#define debug5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterAll, sz, a, b, c, d, e)
#define debug6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterAll, sz, a, b, c, d, e, f)
#define debugPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterAll, pch, cch)
#define debugPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterAll, pwch, cwch)

// Application Event Monitor debug log macros
#define debugEM0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterEm, sz)
#define debugEM1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterEm, sz, a)
#define debugEM2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterEm, sz, a, b)
#define debugEM3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterEm, sz, a, b, c)
#define debugEM4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterEm, sz, a, b, c, d)
#define debugEM5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterEm, sz, a, b, c, d, e)
#define debugEM6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterEm, sz, a, b, c, d, e, f)
#define debugEMPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterEm, pch, cch)
#define debugEMPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterEm, pwch, cwch)

// Application Rule Engine debug log macros
#define debugRL0(wLevel, sz) \
            debuglog0(wLevel, vlpruls->grfDebugLogFilter, sz)
#define debugRL1(wLevel, sz, a) \
            debuglog1(wLevel, vlpruls->grfDebugLogFilter, sz, a)
#define debugRL2(wLevel, sz, a, b) \
            debuglog2(wLevel, vlpruls->grfDebugLogFilter, sz, a, b)
#define debugRL3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c)
#define debugRL4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c, d)
#define debugRL5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, vlpruls->grfDebugLogFilter, sz, a, b, c, d, e)
#define debugRL6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel,vlpruls->grfDebugLogFilter, sz, a, b, c, d, e, f)
#define debugRLPch(wLevel, pch, cch)\
            debuglogPch(wLevel, vlpruls->grfDebugLogFilter, pch, cch)
#define debugRLPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, vlpruls->grfDebugLogFilter, pwch, cwch)

// Web Client debug log macros
#define debugWC0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterWc, sz)
#define debugWC1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterWc, sz, a)
#define debugWC2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterWc, sz, a, b)
#define debugWC3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterWc, sz, a, b, c)
#define debugWC4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterWc, sz, a, b, c, d)
#define debugWC5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterWc, sz, a, b, c, d, e)
#define debugWC6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterWc, sz, a, b, c, d, e, f)
#define debugWCPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterWc, pch, cch)
#define debugWCPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterWc, pwch, cwch)

// Active Clip Board (C & C) debug log macros
#define debugACB0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterAcb, sz)
#define debugACB1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterAcb, sz, a)
#define debugACB2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterAcb, sz, a, b)
#define debugACB3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterAcb, sz, a, b, c)
#define debugACB4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterAcb, sz, a, b, c, d)
#define debugACB5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterAcb, sz, a, b, c, d, e)
#define debugACB6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterAcb, sz, a, b, c, d, e, f)
#define debugACBPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterAcb, pch, cch)
#define debugACBPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterAcb, pwch, cwch)

// Toolbar debug log macros
#define debugEC0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterEc, sz)
#define debugEC1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterEc, sz, a)
#define debugEC2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterEc, sz, a, b)
#define debugEC3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterEc, sz, a, b, c)
#define debugEC4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterEc, sz, a, b, c, d)
#define debugEC5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterEc, sz, a, b, c, d, e)
#define debugEC6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterEc, sz, a, b, c, d, e, f)
#define debugECPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterEc, pch, cch)
#define debugECPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterEc, pwch, cwch)

// MSO Internal Event Monitor debug log macros
#define debugMsoEM0(wLevel, sz) \
            debuglog0(wLevel, fDebugFilterMsoEm, sz)
#define debugMsoEM1(wLevel, sz, a) \
            debuglog1(wLevel, fDebugFilterMsoEm, sz, a)
#define debugMsoEM2(wLevel, sz, a, b) \
            debuglog2(wLevel, fDebugFilterMsoEm, sz, a, b)
#define debugMsoEM3(wLevel, sz, a, b, c) \
            debuglog3(wLevel, fDebugFilterMsoEm, sz, a, b, c)
#define debugMsoEM4(wLevel, sz, a, b, c, d) \
            debuglog4(wLevel, fDebugFilterMsoEm, sz, a, b, c, d)
#define debugMsoEM5(wLevel, sz, a, b, c, d, e) \
            debuglog5(wLevel, fDebugFilterMsoEm, sz, a, b, c, d, e)
#define debugMsoEM6(wLevel, sz, a, b, c, d, e, f) \
            debuglog6(wLevel, fDebugFilterMsoEm, sz, a, b, c, d, e, f)
#define debugMsoEMPch(wLevel, pch, cch)\
            debuglogPch(wLevel, fDebugFilterMsoEm, pch, cch)
#define debugMsoEMPwch(wLevel, pwch, cwch)\
            debuglogPwch(wLevel, fDebugFilterMsoEm, pwch, cwch)

#if defined(DEBUG) ||  defined(STANDALONE)
#define DebugStandalone(e)      e
#else /* !(DEBUG ||  STANDALONE) */
#define DebugStandalone(e)
#endif /* DEBUG ||  STANDALONE */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif // !MSODBGLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\commctrl.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\commctrl.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/commctrl.h"
#endif /* UNIX */
#ifndef NO_PRIVATE_HEADERS
#include <comctrlp.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\commdlg.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\commdlg.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/commdlg.h"
#endif /* UNIX */
#include <commdlgp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\msoem.h ===
/*****************************************************************************
    msoem.h

    Owner: DaleG
    Copyright (c) 1997 Microsoft Corporation

    Typedef file for Rules Engine of Event Monitor.

*****************************************************************************/

#ifndef MSOEM_H
#define MSOEM_H

#ifndef MSO_H
#pragma message ("MsoEM.h file included before Mso.h.  Including Mso.h.")
#include "mso.h"
#endif

MSOEXTERN_C_BEGIN   // ***************** Begin extern "C" ********************


#include "msoemtyp.h"



//---------------------------------------------------------------------------
// Define useful macros (mostly stolen from Word)
// REVIEW daleg: these need to be Mso-ized
//---------------------------------------------------------------------------

#if !WORD_BUILD  &&  !STANDALONE_WORD

#ifndef DEBUGASSERTSZ
#define DEBUGASSERTSZ       VSZASSERT
#endif /* !DEBUGASSERTSZ */

///#define FNeNcLpxch(lpch1, lpch2, cch) FNeNcRgxch(lpch1, lpch2, cch)
#define SzFromStz(stz)          ((stz)+1)
#define XszFromXstz(xstz)       ((xstz)+1)
#if !ACCESS_BUILD
#define CchSz(sz)               MsoCchSzLen(sz)
#ifndef CchWz
#define CchWz(wz)               MsoCchWzLen(wz)
#endif /* !CchWz */
#endif /* !ACCESS_BUILD */
#define XszFromXstz(xstz)       ((xstz)+1)
#define RgxchFromXstz(xstz)     ((xstz)+1)
#define CchXstz(xstz)           CchXst(xstz)
#define CchXst(xst)             (*xst)
#define cbMaxSz     256
#define cbMaxStz    257
#define cchMaxSz    255
#define cbMaxSz     256
#ifndef WORD_BUILD
#ifndef fTrue
#define fTrue 1
#endif
#ifndef fFalse
#define fFalse 0
#endif
#define tYes    1      /* much like fTrue */
#define tNo     0      /* much like fFalse */
#define tMaybe  (-1)   /* the "different" state */
#define iNil (-1)
#endif /* !WORD_BUILD */
#undef wValue
#define STATIC

// Return "low" value of a split value
#define W1OfPsv(psv)            ((psv)->wValue1)

// Set "low" value of a split value
#define SetW1OfPsv(psv, w)      ((psv)->wValue1 = (w))

// Increment "low" value of a split value
#define IncrW1OfPsv(psv, w)     ((psv)->wValue1 += (w))

// Return "high" value of a split value
#define W2OfPsv(psv)            ((psv)->wValue2)

// Set "high" value of a split value
#define SetW2OfPsv(psv, w)      ((psv)->wValue2 = (w))

// Increment "high" value of a split value
#define IncrW2OfPsv(psv, w)     ((psv)->wValue2 += (w))

// Merge two shorts into a long, compatible with SVL
#define SvlFromWW(wValue2, wValue1) \
            (((long) (wValue2) << 16) + ((long) (wValue1)))


#define PbCopyRgb(pbFrom, pbTo, cb) \
            (((unsigned char *) memmove((pbTo), (pbFrom), (cb))) + (cb))
#define PbCopyRgbNo(pbFrom, pbTo, cb) \
            (memcpy((pbTo), (pbFrom), (cb)), (pbTo) + (cb))
#define CopyRgb(pbFrom, pbTo, cb)       memmove(pbTo, pbFrom, cb)
#define CopyRgbNo(pbFrom, pbTo, cb)     memcpy(pbTo, pbFrom, cb)
#define CopyRgxch(pxchFrom, pxchTo, cch) \
            CopyRgb(pxchFrom,pxchTo,(cch)*cbXchar)

#define ClearLp(lpv, type) \
            MsoMemset((lpv), '\0', sizeof(type))

#define ClearLprg(lpv, type, iMax) \
            MsoMemset((lpv), '\0', sizeof(type) * (iMax))

#define CopyLprg(lpvFrom, lpvTo, type, iMax) \
            CopyRgb((lpvFrom), (lpvTo), (unsigned int)(sizeof(type) * (iMax)))

#define IMaxRg(dcl, type) \
            (sizeof(dcl) / sizeof(type))


#define ClearLprgBlocked(lpv, type, iMax) \
            MsoMemset((lpv), '\0', (sizeof(type) * (iMax) + sizeof(void *)))

#define IMaxRgBlocked(dcl, type) \
            ((sizeof(dcl) / sizeof(type)) - sizeof(void *))


#endif /* !WORD_BUILD */

// Allocate storage for a given type, return pointer
#define MsoPNewEm(type) \
            ((type *) MsoPvAllocEmCb((unsigned int) sizeof(type)))

// Zero storage for a type, given pointer
#define MsoClearPv(pv, type) \
            MsoClearPvCb((pv), sizeof(type))

// Zero storage for number bytes given
#define MsoClearPvCb(pv, cb) \
            MsoMemset((pv), '\0', (cb))

// Allocate storage for an array of a given type, return pointer
#define MsoPNewEmRg(type, iMax) \
            ((type *) MsoPvAllocEmCb((unsigned int)(sizeof(type) * (iMax))))

// Zero storage for an array of a type, given pointer
#define MsoClearRg(pv, type, iMax) \
            MsoMemset((pv), '\0', sizeof(type) * (iMax))

// Copy storage for an array of a type, given pointers
#define MsoCopyRg(rgFrom, rgTo, type, iMax) \
            MsoMemmove((rgTo), (rgFrom), sizeof(type) * (iMax))

// Copy storage for an array of a type, given pointers, checking for overlaps
#define MsoCopyRgNo(rgFrom, rgTo, type, iMax) \
            MsoMemcpy((rgTo), (rgFrom), sizeof(type) * (iMax))

// Copy an array of Unicode characters
#define MsoCopyRgwch(rgFrom, rgTo, cch) \
            MsoCopyRg((rgFrom), (rgTo), WCHAR, (cch))

// Return maximum number of bytes used by array, given *definition*
#define MsoIMaxRg(rg) \
            (sizeof(rg) / sizeof(rg[0]))

// Allocate storage for a given type, but specifying size, return pointer
#define MsoPNewEmCb(type, cb) \
            ((type *) MsoPvAllocEmCb((unsigned int)(cb)))

// Allocate (far) LINKED BLOCK storage for an array of type, return ptr
// This is a rg of the type, but with a pointer linking it to next alloc
#define MsoPNewEmRgBlocked(type_blk, type, iMax) \
            ((type_blk *) MsoPvAllocEmCb \
                ((unsigned int) (sizeof(type) * (iMax) + sizeof(void *))))

#define MsoPReallocEm(pv, type, cb) \
            ((type *) MsoPvReallocEmPvCb((pv), (unsigned int) (cb)))

#define MsoPReallocEmRg(pv, type, iMax) \
            ((type *) \
                MsoPvReallocEmPvCb \
                    ((pv), (unsigned int) (sizeof(type) * (iMax))))

#define MsoPvReallocEmPvCb(pv, cb) \
            (void *)MsoPvRealloc(pv, cb)

#define MsoPvAllocEmCb(cb)      (void *)MsoPvAlloc((cb), msodgMisc )
#define MsoFreeEmPv(pv)     { if (pv) MsoFreePv(pv); }
#define MsoFreeEmPvClear(pv)    MsoFreeEmPpv(&(pv))

#define MsoFreeEmPpv(ppv)   {   \
                                MsoFreeEmPv(*(void **) (ppv));  \
                                *(void * UNALIGNED *) (ppv) = NULL; \
                                }


#define MsoPbCopyRgb(pbFrom, pbTo, cb)  \
            (((unsigned char *) MsoMemmove((pbTo), (pbFrom), (cb))) + (cb))
#define MsoPbCopyRgbNo(pbFrom, pbTo, cb) \
            (MsoMemcpy((pbTo), (pbFrom), (cb)), (pbTo) + (cb))

// Return whether x is between lo and hi values, inclusive.
#define MsoFBetween(x, lo, hi)      ((x) >= (lo)  &&  (x) <= (hi))
// REVIEW: consider the following minutely faster but more dangerous version
//#define MsoFBetween(x, lo, hi)        ((unsigned)((x) - (lo)) <= (hi) - (lo))


#include "msodbglg.h"

#ifdef STANDALONE

#define MsoPvAlloc(cb, dg)      malloc(cb)
#define MsoFreePv(pv)           free(pv)
#define MsoPvRealloc(pv, cb)    realloc((pv), (cb))

#endif /* STANDALONE */


#if !defined(WORD_BUILD)  &&  !defined(WORD_H)

#ifndef CommSz
#define CommSz(sz)          OutputDebugStringA(sz)
#endif /* !CommSz */

#ifndef ACCESS_BUILD
typedef void           *DOC;                            // Define object
#define docNil  ((DOC) NULL)
#else /* ACCESS_BUILD */
#define pdocNil     ((DOC *) NULL)
#endif /* !ACCESS_BUILD */

#define cpNil ((MSOCP) -1)
#define cp0 ((MSOCP) 0)
///typedef unsigned short BF;

typedef unsigned char uchar;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned long ulong;

#endif /* !WORD_BUILD  &&  !WORD_H */


#ifdef OFFICE_BUILD
MSOAPI_(BOOL) MsoFInitOfficeEm(struct MSOINST *pinst);  // Init MSO Em

// Query type in FEmNotifyAction(msoemssAppEm,..)
#define msonaAppEmUseMso        1                       // App needs MSO EM?
#endif /* !OFFICE_BUILD */

MSOAPI_(int) MsoLRuleParsePwch(                         // Parse string w/rules
    WCHAR              *pwch,
    int                 cch,
    int                 rulevt,
    int                 rulg
    );

#ifdef DEBUG
MSOAPI_(int) MsoLRuleParseFile(                         // Parse file w/rules
    char               *rgchPath,
    int                 rulevt,
    int                 rulg
    );
#ifdef OFFICE_BUILD
BOOL FWriteEmBe(LPARAM lParam, struct MSOINST *pinst);  // Mark MSO Em memory
#endif /* OFFICE_BUILD */
#endif /* DEBUG */

MSOEXTERN_C_END     // ****************** End extern "C" *********************

#endif /* !MSOEM_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\prsht.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\prsht.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/prsht.h"
#endif /* UNIX */
#include <prshtp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\msolex.h ===
/******************************************************************************
    MSOLEX.H

    Owner: smueller
    Copyright (c) 1997 Microsoft Corporation

    General Purpose Text Lexer definitions and prototypes

    There are currently multiple instances of this component in Office 9.
    Keep them in sync:
        %mso%\inc\msolex.h
        %otools%\src\em\emtest\msolex.h
        %ppt%\office\lexpp.h
        %word%\src\inc\lex.h

    FUTURE: some of these definitions don't need to be exported and could
    live in an msolex.i file.
******************************************************************************/

#ifndef MSOLEX_H
#define MSOLEX_H


/*----------------------------------------------------------------------------
    Enabled features
----------------------------------------------------------------------------*/

#define EM_MULT_DIM_SCAN


/*----------------------------------------------------------------------------
    System limits
----------------------------------------------------------------------------*/

#define ichTkLenMax         256                         // Max token str len
#define ichLexsCacheMax     (ichTkLenMax - 1)           // Mx num chars cached

#define dirultkNotFound     30000                       // arbitrarily lg. flag
#define dtkNotFound         dirultkNotFound             // alias


/*************************************************************************
    Types:

    tk          Token returned by the lexer.
    lexs        Lexer state structure.

 *************************************************************************/


// Define state tables used by lexer (use with plexs->isttbl)
#define isttblDefault   0                               // Default MUST be 0
#define isttblNoBlanks  1


/* T K */
/*----------------------------------------------------------------------------
    %%Structure: TK
    %%Contact: daleg

    Lexer token definitions.
----------------------------------------------------------------------------*/

#ifndef TK_DEFINED
// Definition of token type returned by lexer
typedef int TK;

#define TK_DEFINED
#endif /* !TK_DEFINED */


// Lexer tokens: Plain Text and Delimiters
#define tk_RESCAN_      (-2)                            // Dummy: force rescan
#define tkERROR         (-1)                            // Lexer error
#define tkNil           0                               // No token at all
#define tkEND_OBJ       1                               // End of object
#define tkPARA          2                               // 0xB6 (Para mark)
#define tkNEWLINE       3                               // \n
#define tkWSPC          4                               // Blanks, tabs
#define tkWSPCMULT      5                               // Multiple Blanks
#define tkTAB           6                               // Tab character
#define tkWORD          7                               // E.g. abc
#define tkINTEGER       8                               // E.g. 123
#define tkCOMMA         9                               // ,
#define tkPERIOD        10                              // .
#define tkEXCLAIM       11                              // !
#define tkPOUND         12                              // #
#define tkDOLLAR        13                              // $
#define tkPERCENT       14                              // %
#define tkAMPER         15                              // &
#define tkLPAREN        16                              // (
#define tkRPAREN        17                              // )
#define tkASTER         18                              // *
#define tkPLUS          19                              // +
#define tkMINUS         20                              // -
#define tkSLASH         21                              // /
#define tkCOLON         22                              // :
#define tkSEMI          23                              // ;
#define tkLESSTHAN      24                              // <
#define tkEQUAL         25                              // =
#define tkGREATER       26                              // >
#define tkQUEST         27                              // ?
#define tkATSIGN        28                              // @
#define tkLBRACK        29                              // [
#define tkRBRACK        30                              // ]
#define tkBSLASH        31                              // \ 
#define tkCARET         32                              // ^
#define tkUSCORE        33                              // _
#define tkBQUOTE        34                              // `
#define tkLBRACE        35                              // {
#define tkRBRACE        36                              // }
#define tkVBAR          37                              // |
#define tkTILDA         38                              // ~
#define tkDQUOTE        39                              // "
#define tkLDQUOTE       40                              // " left curly dbl
#define tkRDQUOTE       41                              // " right curly dbl
#define tkQUOTE         42                              // '
#define tkLQUOTE        43                              // ' left curly sgl
#define tkRQUOTE        44                              // ' right curly sgl
#define tkLCHEVRON      45                              // << French LDQuote
#define tkRCHEVRON      46                              // >> French RDQuote
#define tkENDASH        47                              // - en-dash
#define tkEMDASH        48                              // -- em-dash

// Lexer tokens: Plain-Text Symbol tokens
#define tkSYMBOL        49                              // Symbol char
#define tkBULLET        50                              // Std bullet char
#define tkFEWORD        51                              // FE word
#define tkFESYMBOL      52                              // FE symbol char
#define tkFESPACE       53                              // FE Space char

// Lexer tokens: Plain-text formatting info
#define tkSTARTCAP      54                              // Word is capitalized
#define tkALLCAPS       55                              // Word is all caps
#define tkHASCAPS       56                              // Word has 1+ CAPs


// Is TK valid (not tkNil and not tkERROR)
#define FValidTk(tk) \
            ((tk) > 0)



/* M  S  O  L  E  X  S */
/*----------------------------------------------------------------------------
    %%Structure: MSOLEXS
    %%Contact: daleg

    AutoFormat LEX State

    Contains information about the Event Monitor lexer's current position
    in the document.

    This information is initialized by LexReset(), and advanced by other
    lexer APIs.
----------------------------------------------------------------------------*/

// Callback typedefs
typedef XCHAR (OFC_CALLBACK *PFNLEXBUF)(MSOCP cpLim, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXRUN)(MSOCP cpLim, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXTXT)
    (MSORULTK *prultk, const XCHAR **ppxch, int *pcch, struct _MSOLEXS *plexs);
typedef void (OFC_CALLBACK *PFNLEXFMT)
    (int *pfForceTkBreak, struct _MSOLEXS *plexs);
typedef int (OFC_CALLBACK *PFNLEXCNT)(struct _MSOLEXS *plexs);


typedef struct _MSOLEXS
    {
    // --- values requiring initialization ---

    // Keyword lookup information
    struct _MSOKWTB    *pkwtb;                          // Keyword-lookup tbl

    // Token-history cache information
    MSORULTKH           rultkhToken;                    // Text Token cache

    // Formatting token-history cache information
    MSORULTKH           rultkhFormat;                   // Format Token cache

    // Init state
    MSOBF               fInited : 1;                    // Lexer inited?
    int                 isttbl;                         // Which STT?
    union
        {
        unsigned short  grpfLexFlags;
        struct
            {
            MSOBF       fNoReset : 1;                   // Reset leave alone
            MSOBF       fLookup : 1;                    // Lookup name as kwd?
            MSOBF       fLookupIntsAndSyms : 1;         // Lookup ints as kwd?
            MSOBF       fAllCapsAsFormat : 1;           // ALLCAPS as fmt tk?
            MSOBF       fRefetchOnOverscan : 1;         // Force fetch on OS?
            MSOBF       fSpare2 : 11;
            };
        };

    // Buffer management callback functions
    void               *hObjectNil;                     // Nil object
    PFNLEXBUF           pfnlexbuf;                      // Fetch next buffer
    PFNLEXRUN           pfnlexrun;                      // Fetch next run
    PFNLEXTXT           pfnlextxt;                      // Fetch token text
    PFNLEXFMT           pfnlexfmt;                      // Gen format tokens
    PFNLEXCNT           pfnlexrunDiscontig;             // Next run contiguous?
    PFNLEXRUN           pfnlexrunForceComplete;         // Force tk to complete

    // Run state information
    int                 ichRun;                         // Index to vfli.rgch
    int                 cchLookahead;                   // Num chars lookahead

    // --- values initially zero ---

    // Run state information
    int                 cchRemain;                      // Num chars unlexed
    MSOCP               cpRun;                          // CP of start of run
    MSOCP               ccpRun;                         // Num of CPs in run
    MSOCP               cpObject;                       // CP of start of obj
    int                 cchRun;                         // Num chars run

    // Token state information
    MSOCP               cpTokenFirst;                   // CP of first char
    MSOCP               dcpToken;                       // Num CPs in token
    MSOCP               cpTokenNext;                    // CP of next token
    int                 tkTokenIndirect;                // Indirect token
    int                 ichTokenFirst;                  // ich of first char
    const XCHAR        *pxchTkStart;                    // First char in token
    const XCHAR        *pxchNext;                       // Next char to lex
    const XCHAR        *pxchRun;                        // First char of run
    const XCHAR        *pxchBuffer;                     // Token string buffer
    const XCHAR        *pxchBufferIp;                   // Buffer of obj at IP
    union
        {
        unsigned short  grfCurTk;
        struct
            {
            MSOBF       fMustSyncLexDocBuffer : 1;      // Reset lexer?
            };
        };

    // Vanished/Created text handling
#ifdef EM_LEX_VANISHED
    MSOCP               cpFirstVanished;                // CP of vanished
    MSOCP               dcpVanished;                    // dcp of vanished txt
#endif /* EM_LEX_VANISHED */
    MSOCP               cpFirstCreated;                 // CP of created
    MSOCP               dcpCreated;                     // dcp of created txt
    union
        {
        unsigned short  grpfLineFlags;
        struct
            {
            MSOBF       fAdjustTokenCps : 1;            // Created/Vanished txt
            };
        };

    // Lexer state information
    int                 ichCache;                       // Num chars cached
    XCHAR               rgxchCache[ichTkLenMax];        // Cache leading chars
    XCHAR               rgxchHistToken[ichTkLenMax];    // Text of history tk
    void               *pObject;                        // Current object(cell)
    void               *pObjectIp;                      // Object at IP
#ifdef EM_MULT_DIM_SCAN
    long                iCol;                           // Column of cell
    long                iRow;                           // Row of cell
    long                iColIp;                         // Column of IP
    long                iRowIp;                         // Row of IP
    int                 dcellScanToIp;                  // #rows/cols 2 prescan
    int                 iScanDirection;                 // 0 == row, 1 == col
#endif /* EM_MULT_DIM_SCAN */
    MSOCP               cpFirst;                        // CP start of scan
    MSOCP               cpLim;                          // CP limit of scan
    MSOCP               cpFirstDoc;                     // CP limit of scan
    MSOCP               cpMacDoc;                       // CP limit of scan
    long                wInterval;                      // Count of intervals

    // Format lexer state information
    union
        {
        unsigned long   grpfFormatFlags;
        struct
            {
            MSOBF       fBold : 1;                      // Is text bold?
            MSOBF       fItalic : 1;                    // Is text italic?
            MSOBF       fUnderline : 1;                 // Is text underlined?
            MSOBF       fVanish : 1;                    // Is text hidden?
            MSOBF       ico : 5;                        // Is text colored?
            MSOBF       fSpareFmt : 7;
            };
        };
    union
        {
        unsigned short  grpfEndFlags;
        struct
            {
            MSOBF       fCreateEndObjCh : 1;            // Create EOO tk?
            MSOBF       fEOL : 1;                       // End of line?
            MSOBF       fEOP : 1;                       // End of paragraph?
            };
        };

    // Asynchronous lexer support
    unsigned short      iuState;                        // Async state
    MSOBF               fInvalLexer : 1;                // Lexer not synched?
    MSOBF               fBufferAlloced : 1;             // Obj buffer alloced?
    MSOBF               fAsyncSpare4 : 14;
    MSOCP               cpIp;                           // CP of IP if forced

    // Multiple lexical scan support
    MSOBF               fDynAlloced : 1;                // struct alloced?
    MSOBF               fTkCacheDynAlloced : 1;         // TK Cache alloced?
    MSOBF               fFmtTkCacheDynAlloced : 1;      // Format Che alloced?
    struct _MSOLEXS    *plexsNext;                      // Next struct LIFO

    // App-specific goo
    void               *pUserData;                      // Cast as desired
    } MSOLEXS;


// grpfLexFlags
#define MsoGrfLexFNoReset               (1 << 0)
#define MsoGrfLexFLookup                (1 << 1)
#define MsoGrfLexFLookupIntsAndSyms     (1 << 2)
#define MsoGrfLexFAllCapsAsFormat       (1 << 3)
#define MsoGrfLexFRefetchOnOverscan     (1 << 4)


extern unsigned short const **vppchtblCharTrans;        // Ptr to lexer ch tbl


#ifdef EM_MULT_DIM_SCAN
#define iScanVert       0
#define iScanHoriz      1
#endif /* EM_MULT_DIM_SCAN */

// Return the object the lexer is currently scanning
#define PobjectLexToken(plexs) \
            ((plexs)->pObject)

// Return the current lexer token starting CP value
#define CpLexTokenFirst(plexs) \
            ((plexs)->cpTokenFirst)

// Set the current lexer token starting CP value
#define SetCpLexTokenFirst(plexs, cp) \
            ((plexs)->cpTokenFirst = (cp))

// Return the next lexer token starting CP value
#define CpLexTokenNext(plexs) \
            ((plexs)->cpTokenNext)

// Set the next lexer token starting CP value
#define SetCpLexTokenNext(plexs, cp) \
            ((plexs)->cpTokenNext = (cp))

// Get the current lexer token dCP (length of CPs consumed)
#define DcpLexToken(plexs) \
            ((plexs)->dcpToken)

// Set the current lexer token dCP (length of CPs consumed)
#define SetDcpLexToken(plexs, dcp) \
            ((plexs)->dcpToken = (dcp))

// Update the current lexer token dCP (length of CPs consumed)
#define UpdateDcpLexToken(plexs, dcp) \
            IncrDcpLexToken(plexs, dcp)

// Update the current lexer token dCP (length of CPs consumed)
#define IncrDcpLexToken(plexs, dcp) \
            ((plexs)->dcpToken += (dcp))

#ifndef EM_LEX_VANISHED
// Update the current lexer token dCP (length of CPs consumed)
#define ClearDcpLexToken(plexs) \
            SetDcpLexToken(plexs, 0L)

#else /* EM_LEX_VANISHED */

// Update the current lexer token dCP (length of CPs consumed)
#define ClearDcpLexToken(plexs) \
            (SetDcpLexToken(plexs, 0L), \
             plexs->cpFirstVanished = 0L, \
             plexs->dcpVanished = 0L)
#endif /* !EM_LEX_VANISHED */


// Return the current lexer token *running* dCP (length of CPs consumed)
#define DcpLexCurr(plexs) \
            (DcpLexToken(plexs) + CchTokenLen(plexs))

// Return the current lexer CP value
#define CpLexCurr(plexs) \
            (CpLexTokenFirst(plexs) + DcpLexToken(plexs))

// Is this the last run, period?
#define FLexEndOfScan(plexs) \
            ((plexs)->cpRun + (plexs)->ccpRun >= (plexs)->cpLim)

#define CchTokenLen(plexs) \
            (CchTokenUncachedLen(plexs) + (plexs)->ichCache)
#define CchTokenUncachedLen(plexs) \
            ((plexs)->pxchNext - (plexs)->pxchTkStart)

// Return the index of the start of curr tk into line buffer (vfli.lrgxch)
#define IchLexTkFirst(plexs) \
            ((plexs)->pxchTkStart - (plexs)->pxchBuffer)

// Encode a relative TK index as an absolute number
#define _IrultkTokenAbsEncoded(plexs, dirultk) \
            ((plexs)->rultkhToken.irultkAbsBase \
                + (plexs)->irultkLim + (dirultk))

// Mark that the lexer must reset on next char typed
#define InvalLex(plexs) \
            ((plexs)->cchLookahead = -1)

// Return whether the lexer must reset on next char typed
#define FInvalLex(plexs) \
            ((plexs)->cchLookahead < 0)


// Mark lexer as probably out of synch with app buffer
#define InvalLexFetch(plexs) \
            ((plexs)->cchRemain = 0, \
             (plexs)->fInvalLexer = fTrue)

// Return whether lexer out of synch with app buffer
#define FInvalLexFetch(plexs) \
            ((plexs)->fInvalLexer)



/*************************************************************************
    Token History Cache
 *************************************************************************/

// Token-history cache access
#define PrultkFromTokenIrultk(plexs, irultk) \
            PrultkFromIrultk(irultk, (plexs)->rultkhToken.rgrultkCache)

// Increment pointer to token-history cache access
#define IncrTokenPrultk(plexs, pprultk, pirultkPrev) \
            IncrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhToken.rgrultkCache, \
                        (plexs)->rultkhToken.irultkMac)

// Decrement pointer to token-history cache access
#define DecrTokenPrultk(plexs, pprultk, pirultkPrev) \
            DecrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhToken.rgrultkCache, \
                        (plexs)->rultkhToken.irultkMac)

// Increment index to token-history cache access
#define IncrTokenPirultk(plexs, pirultk, dirultk) \
            IncrPirultk(pirultk, dirultk, (plexs)->rultkhToken.irultkMac)

// Increment index to token-history cache access
#define DecrTokenPirultk(plexs, pirultk, dirultk) \
            DecrPirultk(pirultk, dirultk, (plexs)->rultkhToken.irultkMac)

// Fill in next tk cache record even if incomplete.
#define _CacheTkTextNext(plexs) \
            { \
            MSORULTK   *prultk; \
            int         cchPartialTk = (plexs)->cchLookahead; \
             \
            prultk = PrultkFromTokenIrultk((plexs), \
                                           (plexs)->rultkhToken.irultkLim); \
            prultk->pObject = plexs->pObject; \
            prultk->cpFirst = CpLexTokenFirst(plexs); \
            prultk->dcp = DcpLexCurr(plexs) + cchPartialTk; \
            prultk->ich = (plexs)->pxchTkStart - (plexs)->pxchBuffer; \
            prultk->dich = CchTokenLen(plexs) + cchPartialTk; \
            prultk->wInterval = (plexs)->wInterval; \
            prultk->tk = tkNil; \
            }


/*************************************************************************
    Formatting Token History Cache
 *************************************************************************/

// Format token-history cache access
#define PrultkFormatFromIrultk(plexs, irultk) \
            PrultkFromIrultk(irultk, (plexs)->rultkhFormat.rgrultkCache)

// Increment pointer to Format token-history cache access
#define IncrFormatPrultk(plexs, pprultk, pirultkPrev) \
            IncrPrultk(pprultk, pirultkPrev, \
                       (plexs)->rultkhFormat.rgrultkCache, \
                       (plexs)->rultkhFormat.irultkMac)

// Increment pointer to Format token-history cache access
#define DecrFormatPrultk(plexs, pprultk, pirultkPrev) \
            DecrPrultk(pprultk, pirultkPrev, \
                        (plexs)->rultkhFormat.rgrultkCache, \
                        (plexs)->rultkhFormat.irultkMac)

// Increment index to Format token-history cache access
#define IncrFormatPirultk(pirultk, dirultk) \
            IncrPirultk(pirultk, dirultk, (plexs)->rultkhFormat.irultkMac)

// Increment index to Format token-history cache access
#define DecrFormatPirultk(pirultk, dirultk) \
            DecrPirultk(pirultk, dirultk, (plexs)->rultkhFormat.irultkMac)



/*************************************************************************
    Prototypes and macros for lex.c
 *************************************************************************/


// Get the next character from the input buffer
#define XchLexGetChar(plexs, cpLim) \
            ((plexs)->cchRemain-- > 0\
                ? *(plexs)->pxchNext++ \
                : XchLexGetNextBuffer(cpLim, plexs))

// Get the next input buffer
#define XchLexGetNextBuffer(cpLim, plexs) \
            ((*(plexs)->pfnlexbuf)(cpLim, plexs))

// Return last char to input buffer
#ifndef AS_FUNCTION
#define LexUngetChar(plexs, cch) \
            ((plexs)->pxchNext -= cch, (plexs)->cchRemain += cch)
#else
void LexUngetChar(MSOLEXS *plexs, int cch);
#endif /* !AS_FUNCTION */

// Peek at the next character from the input buffer
#define XchLexPeekChar(plexs) \
            ((plexs)->cchRemain > 0 \
                ? *(plexs)->pxchNext \
                : (XchLexGetNextBuffer(msocpMax, plexs), (plexs)->cchRemain++,\
                        *(--(plexs)->pxchNext)))

// Number of bytes to copy if we are "peeking" at next char via lexer
#define cbLexsPeek  (offset(MSOLEXS, ichCache))

// Define (CH)aracter Translation (T)a(BL)e
typedef unsigned short ISTT;                            // Col index to Lex STT
typedef ISTT const *CHTBL;                              // Char trans table
#ifndef VIEWER

// Definition of size of State Transition Table
#define WSttblNumRows       5                           // Num rows in Sttbl
#define WSttblNumCols       15                          // Num cols in Sttbl

typedef unsigned short const STTBL [WSttblNumCols];     // State trans table

extern unsigned short const rgsttblWsIndirect[WSttblNumRows][WSttblNumCols];
extern unsigned short const rgsttblWsDirect[WSttblNumRows][WSttblNumCols];

extern CHTBL _rgchtblNormal[256];                       // Normal ch trans tbl

// Based pointer to current Character Transition Table
extern CHTBL const *vpchtblCharTrans;                   // Curr ch trans table


// Translate a character into a column in the lexer STTBL
#define IsttFromXch(xch)    \
            vpchtblCharTrans[MsoHighByteXch(xch)][MsoLowByteXch(xch)]
#endif // !VIEWER


// Define Delimiter Lookup table
extern TK const * Win(const) vrgptkCharToken[256];

// Return delimiter token associated with character
#define TkDelimFromXch(xch) \
            vrgptkCharToken[MsoHighByteXch(xch)][MsoLowByteXch(xch)]


// Map a STT column index into a Character token value
extern TK vmpistttkCh[];



MSOAPI_(TK) MsoTkLexText(MSOLEXS *plexs);               // Get next token
MSOAPI_(TK) MsoTkLexTextCpLim(                          // Get next tk < CP
    MSOLEXS            *plexs,
    MSOCP               cpLim
    );
MSOAPI_(int) MsoFLexTokenCh(MSOLEXS *plexs, XCHAR xch); // Token ready?
void SetLexTokenLim(MSOLEXS *plexs);                    // Set token Lim
MSOCP DcpLexCurrAdjusted(MSOLEXS *plexs);               // Return dCP used
MSOAPI_(XCHAR) MsoWchLexGetNextBufferDoc(               // Reload char buf
    MSOCP               cpLim,
    MSOLEXS            *plexs
    );
void ForceLexEOF(void);                                 // FUTURE: Force EOF
MSOAPI_(MSOLEXS *) MsoPlexsLexInitDoc(                  // Init from doc
    MSOLEXS            *plexs,
    void               *hObjectNil,
    PFNLEXRUN           pfnlexrun,
    PFNLEXTXT           pfnlextxt,
    PFNLEXFMT           pfnlexfmt,
    PFNLEXCNT           pfnlexrunDiscontig,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
MSOAPI_(void) MsoAssertPlexsInitDoc(                    // Ensure doc init
    MSOLEXS            *plexs,
    void               *hObjectNil,
    PFNLEXRUN           pfnlexrun,
    PFNLEXTXT           pfnlextxt,
    PFNLEXFMT           pfnlexfmt,
    PFNLEXCNT           pfnlexrunDiscontig,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif // DEBUG
MSOAPI_(void) MsoLexSetPos(                             // Reposition in file
    MSOLEXS            *plexs,
    MSOCP               cpFirst,
    MSOCP               cpLim
    );
MSOAPI_(XCHAR) MsoWchLexGetNextBufferPxch(              // Gen EOF for rgch
    MSOCP               cpLim,
    MSOLEXS            *plexs
    );
MSOAPI_(MSOLEXS *) MsoPlexsLexInitPxch(                 // Init from rgch
    MSOLEXS            *plexs,
    XCHAR              *pxch,
    int                 cch,
    PFNLEXBUF           pfnlexbuf,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
MSOAPI_(void) MsoAssertPlexsInitPxch(                   // Ensure rgch init
    MSOLEXS            *plexs,
    XCHAR              *pxch,
    int                 cch,
    PFNLEXBUF           pfnlexbuf,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif // DEBUG
void LexFinishPch(void);                                // Complete rgch scan
STTBL *PsttblFromIsttbl(int isttbl);                    // table ptr from index
MSOLEXS *PlexsNew(void);                                // Alloc new MSOLEXS
MSOLEXS *PlexsInitLex(                                  // Init lexer memory
    MSOLEXS            *plexs,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#ifdef DEBUG
void AssertPlexsInit(                                   // Ensure lexer memory
    MSOLEXS            *plexs,
    int                 irultkTokenMac,
    int                 irultkFormatMac
    );
#endif
MSOAPI_(void) MsoResetLexState(                         // Reset lexer state
    MSOLEXS            *plexs,
    int                 fFullReset
    );
MSOAPI_(void) MsoFreeLexMem(MSOLEXS *plexs);            // Free lexer memory
#if defined(DEBUG)  &&  !defined(STANDALONE)
MSOAPI_(void) MsoMarkLexMem(MSOLEXS *plexs);            // Mark lexer mem used
#endif // DEBUG  &&  !STANDALONE
int FResetLexDocBuffer(                                 // Reset cpObject
    void               *pObject,
    MSOCP               cpObject,
    MSOCP               cpScan,
    MSOCP              *pcpObject                       // RETURN
    );

// Return token associated with string by looking up in keyword table
#define TkLookupNameLexs(pxchStr, cchLen, plexs) \
            MsoTkLookupName((pxchStr), (cchLen), (plexs)->pkwtb)

// Return token associated with string by looking up in keyword table
#define PkwdLookupNameLexs(pxchStr, cchLen, plexs) \
            MsoPkwdLookupName((pxchStr), (cchLen), (plexs)->pkwtb)

// Add a keyword to the lexer lookup table
#define PkwdAddTkLookupNameLexs(pxchStr, cchLen, tk, plexs, fCopyStr) \
            MsoPkwdAddTkLookupName((pxchStr), (cchLen), (tk), (plexs)->pkwtb,\
                                   (fCopyStr))

// Remove a keyword from the lexer lookup table
#define FRemoveTkLookupNameLexs(pxchStr, cchLen, plexs, ptk) \
            MsoFRemoveTkLookupName((pxchStr), (cchLen), (plexs)->pkwtb, (ptk))

void AppendRultkFormat(                                 // Append format token
    MSOLEXS            *plexs,
    TK                  tk,
    int                 dcp,
    long                lValue
    );
void InsertRultkFormat(                                 // Insert format token
    MSOLEXS            *plexs,
    TK                  tk,
    MSOCP               cp,
    long                lValue
    );
MSOAPI_(void) MsoCacheTkText(                           // Save text tokens
    MSOLEXS            *plexs,
    TK                  tk,
    long                lValue
    );
MSOAPI_(int) MsoCchTokenText(                           // Return token text
    MSOLEXS            *plexs,
    int                 dtk,
    const XCHAR       **ppxch                           // RETURN
    );
#define TokenLen(plexs, dtk) \
            MsoCchTokenText((plexs), (dtk), NULL)
MSOAPI_(MSOCA *) MsoPcaOfDtk(                           // Get CA of tk range
    MSOCA              *pca,
    int                 dtkStart,
    int                 dtk,
    MSOLEXS            *plexs
    );
MSOAPI_(MSOCA *) MsoPcaOfDtkExclusive(                  // Get CA inside tk rg
    MSOCA              *pca,
    int                 dtkStart,
    int                 dtk,
    MSOLEXS            *plexs
    );
#ifdef NEVER
int CchCopyTextOfDtk(                                   // Return mult tk text
    int                 dtkStart,
    int                 dtk,
    XCHAR              *rgxch,                          // IN, RETURN
    int                 cchMax,
    int                 fPartialTkOK
    );
#endif // NEVER
MSOAPI_(long) MsoLFromDtk(                              // Get integer value
    MSOLEXS            *plexs,
    int                 dtk,
    int                 fCheckForSign
    );
long LFromPxch(                                         // Convert str to long
    const XCHAR        *pxch,
    int                 cch,
    int                *pfOverflow
    );
int FUpperXch(XCHAR xch);                               // Char uppercase?
int FLowerXch(XCHAR xch);                               // Char lowercase?

#ifdef NEVER
int OFC_CALLBACK DxaOfDirultk(                          // Return tk coord,len
    int                 dtk,
    int                *pdxaLen                         // RETURN: optional
    );

TK TkFromXch(XCHAR xch);                                // Return tk from a ch
TK TkFromXchNoLookup(XCHAR xch);                        // Return tk from ch
XCHAR *PxchTkStartFromPxchReverse(XCHAR *, XCHAR *);
int FXchEndsTk(XCHAR);                                  // Does this xch end a tk?
TK TkFromChIsttbl(XCHAR xch, int isttbl);               // Return a tk from a char
int OFC_CALLBACK DtkCacheTkTextToCp(                    // Fill Text TK cache
    int                 dtk,
    MSOCP               cpLim,
    int                 fForce
    );
#endif // NEVER
void CopyTkTextToCache(MSOLEXS *plexs);                 // Flush pend lex text



#if defined(DEBUG)  ||  defined(STANDALONE)
char *SzFromPch(                                        // Temp make string
    const char         *pchStr,
    int                 cchLen,
    char               *rgchStrBuf
    );
XCHAR *XszFromPxch(                                     // Temp make string
    const XCHAR        *pxchStr,
    int                 cchLen,
    XCHAR              *rgxchStrBuf
    );
#ifndef STANDALONE
char *SzFromPxch(                                       // Temp make string
    const XCHAR        *pxchStr,
    int                 cchLen,
    char               *rgchStrBuf
    );
#else /* STANDALONE */
#define SzFromPxch(p1,p2,p3) SzFromPch(p1, p2, p3)
#endif /* !STANDALONE */
#endif // DEBUG  ||  STANDALONE


/*************************************************************************
    Utilities
 *************************************************************************/

#ifndef FAREAST
#define FWhitespaceXch(xch) \
            ((xch) == ' '  ||  (xch) == '\t'  ||  (xch) == xchColumnBreak)
#else /* FAREAST */
#define FWhitespaceXch(xch) \
            ((xch) == ' '  ||  (xch) == '\t'  ||  (xch) == xchColumnBreak \
                ||  (xch) == wchSpace)
#endif /* FAREAST */



/*************************************************************************
    Prototypes and macros for Debugging and Error Handling
 *************************************************************************/

const XCHAR *PxchLexTokenText(                          // Return tk text, len
    MSOLEXS            *plexs,
    int                *pwLen);
#ifdef DEBUG
MSOAPI_(XCHAR *) MsoLxszLexTokenText(MSOLEXS *plexs);   // Return token text
MSOAPI_(CHAR *) MsoSzLexTokenText(MSOLEXS *plexs);      // Return token sz
#endif // DEBUG

#endif // MSOLEX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\evtmon\genem.c ===
/*----------------------------------------------------------------------------
    %%File: EMTEST.C
    %%Unit: Event Monitor (mntr)
    %%Contact: daleg

    Event Monitor Sample Application, Main Program.

    The purpose of this application is to demonstrate how to process events
    using the Event Monitor's Rule Compiler and rule engine.
----------------------------------------------------------------------------*/

//***   genem.c -- 'generic' evtmon client-side stuff
// DESCRIPTION
//  the client-side of an evtmon app has two parts:
//      - evtmon generic code (client-side)
//      - application-specific rules
//  this file is reusable (and semi-frozen) generic code.  it should be
//  #include'ed from the app.
// NOTES
//  WARNING: do *not* put app-specific code here.  put it in the
//  client (emclient/libem.c).  in fact in general, think twice before
//  modifying this file at all.

//***   YY_* -- generic rules support
//
#define YY_BASE     1   // base features (always needed)
#ifdef YY_BASE
// rulc.exe doesn't create all files if a given feature isn't used,
// so we can't unconditionally include these guys.  plus, we don't
// want the helper code if we don't need it.
// turn on these features here if you use them
#ifndef YY_DELAYED
#define YY_DELAYED  0   // delayed actions
#endif
#ifndef YY_CTOR
#define YY_CTOR     0   // action ctors
#endif
#ifndef YY_SEQCHECK
#define YY_SEQCHECK 0   // seq_check
#endif
#define YY_OTHER    0   // not sure what emactr.h is for
//#define YY_BRKPT()
#endif

//***   FEATURE_* -- domain-specific rules support
// NOTES
//  untested! not sure if these #if's are done right
#define FEATURE_DEMO    0   // demo code (e.g. wndproc test app)
#define FEATURE_SAMPLE  0   // sample code (e.g. joe-event firer)
#define FEATURE_OFFICE  0   // base office stuff
#define FEATURE_TEXT    0   // text parser
#define FEATURE_WORD    0   // format parser
#define FEATURE_DEAD    0   // unused/dead code
#define FEATURE_NYI     0   // things i don't understand

#include "mso.h"
#include "msoem.h"

DEBUGASSERTSZ


#include "msolex.h"
#include "emrule.h"
#include "emkwd.h"
#include "emact.h"

#if FEATURE_DEMO
#include "emtest.h"
#include "emres.h"
#endif

// { Files generated by Rule Compiler
#include "emdef.h"          // rules (#defines)
#if YY_CTOR // {
#include "emacts.h"         // ctor macro wrappers
#endif // }
#define DEBUG_RULE_POINTERS // Want ptrs to nodes
#include "emruli.h"         // rulebase
#if YY_SEQCHECK // seq_check
#include "emsqck.c_"        // sequences
#endif
// }


#if FEATURE_TEXT // {
// Constants
#define cbEditText  1024

#ifdef STATIC_INIT

#define grfLexFlagsEm    (MsoGrfLexFNoReset \
                        | MsoGrfLexFLookup \
                        | MsoGrfLexFLookupIntsAndSyms \
                        | MsoGrfLexFAllCapsAsFormat)

// EM data structures
MSORULTK rgrultkEmToken[200];                           // Text Token cache
MSORULTK rgrultkEmFormat[100];                          // Format Token cache
MSOLEXS vlexs =
    {
    &vkwtbEmTOKEN_KEYTABLE,                             // pkwtb
    {rgrultkEmToken, 200, },                            // rultkhToken
    {rgrultkEmFormat, 100, },                           // rultkhFormat
    fTrue,                                              // fInited
    isttblDefault,                                      // isttbl
    grfLexFlagsEm,                                      // grpfLexFlags
    _hObjectNil,                                        // hObjectNil
    MsoWchLexGetNextBufferDoc,                          // pfnlexbuf
    FGetNextLexRun,                                     // pfnlexrun
    FGetTokenTextObject,                                // pfnlextxt
    NULL,                                               // pfnlexfmt
    NULL,                                               // pfnlexrunDiscontig
    NULL,                                               // pfnlexrunForceCompl
    iNil,                                               // ichRun
    -1,                                                 // cchLookahead
    };
MSOLEXS *vplexs = &vlexs;                               // Global lexer state

#else /* !STATIC_INIT */

MSOLEXS     vlexs;                                      // Global lexer state
MSOLEXS    *vplexs;                                     // Global lexer state

#endif /* STATIC_INIT */
#endif // }

#if YY_BASE // {
// Global variables
RULS       *vlpruls = &vrulsEm;
#ifndef STATIC_LINK_EM
RULS      **_pvlprulsDLL = &vlpruls;                    // App's Global state
#endif /* !STATIC_LINK_EM */
#endif // }

#if FEATURE_DEMO // {
char        vszAppName[20];                             // Application name
HWND        vhInst;                                     // Instance
HWND        vhWndMain;                                  // Main window
HWND        vhWndDlg;                                   // Dialog window
char        vszEditText[cbEditText];                    // Text of edit control
int         vcchEditText;                               // #chs in edit control
static int  vcchPrev = 0;                               // Prev edit box len
static int  vcpIpPrev = 0;                              // Prev edit box ip
int         vfSettingDlgItem = fFalse;                  // Avoid Win recursion
#endif // }

#if YY_BASE // {
#if YY_DELAYED
#include "emactr.h"         // data tables
MSOACTTBL   vacttbl = {vrgacttrecEm};                   // Global action table
MSOACTTBL  *_pacttbl = &vacttbl;                        // Glob action tbl ptr
#endif
#endif // }

#if FEATURE_OFFICE // {
EMS         vems;                                       // EM global state
EMS        *vpems = &vems;                              // Ptr to global state
#endif // }

#if YY_BASE // {
#ifdef DEBUG
#ifndef STATIC_LINK_EM
int vwDebugLogFilter = fDebugFilterAll;
int vwDebugLogLvl = -2;
#endif // !STATIC_LINK_EM
// Pointers to global debug logging vars in Mso DLL
int *pvwDebugLogFilter = &vwDebugLogFilter;
int *pvwDebugLogLvl = &vwDebugLogLvl;
#endif /* DEBUG */
#endif // }


#if YY_BASE // {
#ifdef STATIC_INIT // {
/* F  I N I T  E M */
/*----------------------------------------------------------------------------
    %%Function: FInitEm
    %%Contact: daleg

    Initialize the static (compiled) Event Monitor rules.
----------------------------------------------------------------------------*/

int FInitEm(void)
{
#ifndef STATIC_LINK_EM
    /* Mirror global debug pointers in Mso97.dll */
    Debug(pvwDebugLogLvl = MsoPwDebugLogLvl(&pvwDebugLogFilter);)
#endif /* !STATIC_LINK_EM */
    Debug(*pvwDebugLogLvl = 7);

#ifndef STATIC_LINK_EM
    /* Mirror global pointers (vlpruls, etc) in Mso97.dll */
    _pvlprulsDLL = MsoPvlprulsMirror(&vlpruls);
    *_pvlprulsDLL = &vrulsEm;
#endif /* !STATIC_LINK_EM */

#ifdef DYN_RULES
    /* Load dynamic rules */
    FLoadDynEmRules();
#endif /* DYN_RULES */

#if FEATURE_OFFICE
    /* For performance reasons, action table is global */
    vacttbl.prultkh = &vplexs->rultkhToken;
#endif

#if FEATURE_DEMO
    /* Allow Event Drivers to run */
    EnableEM();
#endif

    /* Propagate the values through the rule network */
    MsoScheduleIrul(irul_YYSTD_INIT, fTrue);
#ifdef DYN_RULES
    MsoScheduleIrul(irul_YYSTD_LOADING_RULEBASE, fTrue);
#endif /* DYN_RULES */
    MsoEvaluateEvents(rulevtEm_YYSTD);

    return fTrue;
}
#else /* }{ !STATIC_INIT */
/* F  I N I T  E M */
/*----------------------------------------------------------------------------
    %%Function: FInitEm
    %%Contact: daleg

    Initialize the static (compiled) Event Monitor rules.
----------------------------------------------------------------------------*/

int FInitEm(void)
{
#ifndef STATIC_LINK_EM
    /* Mirror global debug pointers in Mso97.dll */
    Debug(pvwDebugLogLvl = MsoPwDebugLogLvl(&pvwDebugLogFilter);)
#endif /* !STATIC_LINK_EM */
    Debug(*pvwDebugLogLvl = 7);

    /* Initialize rule base, for performance reasons, rulebase is global */
    if (!MsoFInitStaticRuls(&vrulsEm, &vrulsEm))
        return fFalse;

#ifndef STATIC_LINK_EM
    /* Mirror global pointers (vlpruls, etc) in Mso97.dll */
    _pvlprulsDLL = MsoPvlprulsMirror(&vlpruls);
    *_pvlprulsDLL = &vrulsEm;
#endif /* !STATIC_LINK_EM */

#ifdef DYN_RULES
    /* Load dynamic rules */
    FLoadDynEmRules();
#endif /* DYN_RULES */

#if FEATURE_OFFICE
    /* Initialize the lexer to scan the doc */
    if (!(vplexs = MsoPlexsLexInitDoc
                        (&vlexs, _hObjectNil, FGetNextLexRun,
                        FGetTokenTextObject, NULL, NULL, 200, 100)))
        return fFalse;
    vplexs->pkwtb = &vkwtbEmTOKEN_KEYTABLE;

    /* For performance reasons, action table is global */
    vacttbl.prultkh = &vplexs->rultkhToken;
#endif

#if FEATURE_DEMO
    /* Allow Event Drivers to run */
    EnableEM();
#endif

    /* Propagate the values through the rule network */
    MsoScheduleIrul(irul_YYSTD_INIT, fTrue);
#ifdef DYN_RULES
    MsoScheduleIrul(irul_YYSTD_LOADING_RULEBASE, fTrue);
#endif /* DYN_RULES */
    MsoEvaluateEvents(rulevtEm_YYSTD);

    return fTrue;
}
#endif /* } STATIC_INIT */
#endif // }


#if YY_BASE // {
/* F  E V A L  E M  R U L E */
/*----------------------------------------------------------------------------
    %%Function: FEvalEmRule
    %%Contact: daleg

    Evaluate the rule associated with the given rule ID number.
    Return a boolean value for whether its value was TRUE or FALSE.
----------------------------------------------------------------------------*/

#include "emeval.c"
#endif // }




#if FEATURE_DEMO // {
/* W I N  M A I N */
/*----------------------------------------------------------------------------
    %%Function: WinMain
    %%Contact: daleg

    Main routine.
----------------------------------------------------------------------------*/

int CALLBACK WinMain(
    HANDLE              hInstance,
    HANDLE              hPrevInstance,
    LPSTR               lpszCmdLine,
    int                 nCmdShow
    )
{
    MSG                 msg;
    int                 nRc;
    char                szString[256];

    GdiSetBatchLimit(1);
    strcpy(vszAppName, "EMTEST");
    vhInst = hInstance;

    if (!hPrevInstance)
        {
        /* Register window classes if first instance of application */
        if ((nRc = nCwRegisterClasses()) == -1)
            {
            /* Put up msg if registering one of the windows failed */
            LoadString(vhInst, IDS_ERR_REGISTER_CLASS, szString,
                       sizeof(szString));
            MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION);
            return nRc;
            }
        }

    /* Create application's Main window */
    vhWndMain = CreateWindow(vszAppName,
                             NULL,
                             WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX
                                | WS_MAXIMIZEBOX | WS_THICKFRAME
                                | WS_CLIPCHILDREN | WS_OVERLAPPED,
                             0, 0, 400, 400,
                             NULL, NULL, vhInst, NULL);

    /* If could not create main window, be nice before quitting */
    if (vhWndMain == NULL)
        {
        LoadString(vhInst, IDS_ERR_CREATE_WINDOW, szString, sizeof(szString));
        MessageBox(NULL, szString, NULL, MB_ICONEXCLAMATION);
        return IDS_ERR_CREATE_WINDOW;
        }

    /* Initialize the rulebase */
    if (!FInitEm())
        return 1;

    /* Display main window */
    ShowWindow(vhWndMain, nCmdShow);

    /* Until WM_QUIT message */
    while (GetMessage(&msg, NULL, 0, 0))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }

    /* Do clean up before exiting from the application */
    CwUnRegisterClasses();

    return msg.wParam;
}


/* W N D  P R O C */
/*----------------------------------------------------------------------------
    %%Function: WndProc
    %%Contact: daleg

    Windows proc for main window.
----------------------------------------------------------------------------*/

LONG CALLBACK WndProc(
    HWND                hWnd,
    UINT                Message,
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    HMENU               hMenu = 0;
    int                 nRc = 0;

    switch (Message)
        {
    case WM_COMMAND:
        FEmEvalDialog(wParam);

        switch (LOWORD(wParam))
            {
        case IDM_DIALOG:
            /* Respond to the menu item named "Dialog" */
            {
            FARPROC     lpfnDIALOGSMsgProc;

            lpfnDIALOGSMsgProc = MakeProcInstance((FARPROC) DIALOGSMsgProc,
                                                  vhInst);
            nRc = DialogBox(vhInst, MAKEINTRESOURCE(IDM_DIALOG), hWnd,
                            lpfnDIALOGSMsgProc);
            FreeProcInstance(lpfnDIALOGSMsgProc);
            }
            break;

        default:
            return DefWindowProc(hWnd, Message, wParam, lParam);
            }
        break;

    case WM_CLOSE:
        /* Destroy child windows, modeless dialogs, then, this window */
        DestroyWindow(hWnd);

        /* Quit the application */
        if (hWnd == vhWndMain)
            PostQuitMessage(0);
        break;

    default:
        return DefWindowProc(hWnd, Message, wParam, lParam);
        }
    return 0L;
}


/* D  I  A  L  O  G  S  M S G  P R O C */
/*----------------------------------------------------------------------------
    %%Function: DIALOGSMsgProc
    %%Contact: daleg

    Dialog proc for inner window.
----------------------------------------------------------------------------*/

BOOL CALLBACK DIALOGSMsgProc(
    HWND                hWndDlg,
    UINT                Message,
    WPARAM              wParam,
    LPARAM              lParam
    )
{
    switch (Message)
        {
    case WM_INITDIALOG:
        cwCenter(hWndDlg, 0);
        vcchPrev = 0;
        vcpIpPrev = 0;
        vhWndDlg = hWndDlg;
        break;

    case WM_CLOSE:
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
            {
        case IDC_EDIT1:
            switch (HIWORD(wParam))
                {
            case EN_CHANGE:
                vcchEditText = GetDlgItemText(hWndDlg, IDC_EDIT1, vszEditText,
                                              cbEditText);
                if (!vfSettingDlgItem)
                    {
                    MSOCP   cpIp;
                    XCHAR   wch;

                    /* Get IP (Insertion Point) position */
                    SendDlgItemMessage(hWndDlg, IDC_EDIT1, EM_GETSEL, 0,
                                       (LPARAM)&cpIp);

                    /* Get character typed */
                    wch = (vcchEditText > vcchPrev
                            ? vszEditText[cpIp - 1]     // Char typed
                            : xchBackspace);            // Backspace

                    /* Notify Event Monitor CHAR driver */
                    FEmEvalChar(wch, cpIp, vszEditText, vcchEditText);

                    /* Track prev text positions for invalidation detect */
                    vcchPrev = vcchEditText;
                    vcpIpPrev = cpIp;
                    }
                break;
                }
            break;
        case IDC_BUTTON1:
        case IDC_BUTTON2:
        case IDC_START:
        case IDC_STOP:
        default:
            FEmEvalDialog(wParam);
            break;
        case IDOK:
            FEmEvalDialog(wParam);
            EndDialog(hWndDlg, FALSE);
            break;
            }
        break;

    default:
        return FALSE;
        }
    return TRUE;
}
#endif // }


#if FEATURE_SAMPLE // { joe event firer
/* F  E M  E V A L  D I A L O G */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalDialog
    %%Contact: daleg

    Event Monitor Event Driver for DIALOG events.
----------------------------------------------------------------------------*/

int FEmEvalDialog(WPARAM wParam)
{
    short               idc = LOWORD(wParam);
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* Match the (sparse) dialog object to its associated (contig) event, if any */
    vlpruls->irulPrimaryEvent = irul
        = (IRUL) MsoPkwdlhLookupL(idc, &vkwtbEmIDC_KEYTABLE)->tk;

    debugEM1(2, "DIALOG EVENT: %-20.20s\n",
             LpchRulName(LprulFromIrul(irul)));

    /* Push event into appropriate queue (resets depth) */
    MsoScheduleIrul(irul, fTrue);
    MsoScheduleIrul(irulIDC_, idc);     // non-mapped event (autoclear global)

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmDIALOG);
    // n.b. IDC_ is now autocleared

    /* Evaluate any pending actions */
    if (_pacttbl->pactPending)
        DoPendingActions();
}

/* F  E M  E V A L  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalChar
    %%Contact: daleg

    Event Driver for CHAR events in Event Monitor.
    Evaluate CHAR (KEYBOARD) events within the Event Monitor rulebase.
    Return whether or not it was handled.
----------------------------------------------------------------------------*/

int FEmEvalChar(
    XCHAR               wch,
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* Primitive invalidation */
    if (FCheckIfMustReset(wch, ichMac, cpIp))
        InvalLex(vplexs);

    /* If our running state is still valid, adjust run variables */
    if (FInvalLex(vplexs))
        FResetEm((vplexs->cpIp = cpIp) - 1, wz, ichMac);

    /* Create a "lookahead" token to hold chars not yet scanned by lexer */
    vplexs->cchLookahead++;
    _CacheTkTextNext(vplexs);

    /* Look up character in keyword table */
    irul = (IRUL) MsoPkwdLookupName(&wch, 1, &vkwtbEmCHAR_KEYTABLE)->tk;

    debugEM3(2, "CHAR EVENT: %-20.20s for '%s' (0x%x)\n",
             LpchRulName(LprulFromIrul(irul)),
             MsoSzFromRgxchDebug(&wch, 1), wch);

    /* Push text token into appropriate queue (resets depth) */
    MsoScheduleIrul(irulCH_, wch);
    MsoScheduleIrul(vlpruls->irulPrimaryEvent = irul, fTrue);

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmCHAR);

    /* Call TOKEN event driver to process any token events */
    FEmEvalToken(cpIp, wz, ichMac);
}

/* E M  E V A L  T K  I R U L */
/*----------------------------------------------------------------------------
    %%Function: EmEvalTkIrul
    %%Contact: daleg

    Evaluate a TOKEN event irul.
----------------------------------------------------------------------------*/

void EmEvalTkIrul(IRUL irul)
{
    MSORULTK           *prultk;

    debugEM2(2, "TOKEN EVENT: %-20.20s \"%.100s\"\n",
             LpchIrulName(irul), MsoSzLexTokenText(vplexs));

    /* Push pending token events into appropriate queues */
    prultk = PrultkFromTokenIrultk(vplexs, vplexs->rultkhToken.irultkMin);
    while (vplexs->rultkhToken.irultkMin != vplexs->rultkhToken.irultkLim)
        {
#ifdef DEBUG
        if (prultk->tk != irul)
            {
            debugEM2(4, "EXTRA TOKEN EVENT: %-20.20s %d\n",
                     LpchIrulName(prultk->tk), prultk->lValue);
            debugEM1(8, "  at CP %ld\n", prultk->cpFirst);
            }
#endif /* DEBUG */

        /* Push text token into appropriate queue (resets depth) */
        MsoSignalEventIrul(IrulFromTk(prultk->tk), prultk->lValue);

        /* Move to next cache record, wrapping around if necessary */
        IncrTokenPrultk(vplexs, &prultk, &vplexs->rultkhToken.irultkMin);
        }

    /* Push any applicable format tokens into appropriate queues */
    if (vplexs->rultkhFormat.irultkMin != vplexs->rultkhFormat.irultkLim)
        PushIrultkFormatPending();

    /* Push text token into appropriate queue (resets depth) */
    MsoScheduleIrul(irulTOKEN_, vlpruls->irulPrimaryEvent = irul);

    /* Propagate the values through the rule network */
    MsoEvaluateEvents(rulevtEmTOKEN);
}
#endif // }


#if FEATURE_SAMPLE // {
/* F  E M  E V A L  T O K E N */
/*----------------------------------------------------------------------------
    %%Function: FEmEvalToken
    %%Contact: daleg

    Event Monitor Event Driver for TOKEN events.
----------------------------------------------------------------------------*/

int FEmEvalToken(
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    IRUL                irul;

#if FEATURE_DEMO
    /* Make sure we are enabled (e.g. macros not running) */
    if (FEmDisabled())
        return fFalse;
#endif

    /* If our running state is still valid, adjust run variables */
    if (!FInvalLex(vplexs))
        {
        long            dwz = wz - vplexs->pxchBuffer;

        vplexs->pxchTkStart += dwz;
        vplexs->pxchNext += dwz;
        vplexs->pxchRun += dwz;
        vplexs->pxchBuffer += dwz;
        vplexs->cpIp = cpIp;
        vplexs->cpLim = ichMac;
        vplexs->cchRemain = vplexs->pxchBuffer + vplexs->cpLim
                - vplexs->pxchNext;
        }

    /* Else rescan back up to IP */
    else if (!FResetEm((vplexs->cpIp = cpIp) - 1, wz, ichMac))
        return fFalse;

    /* Inject and eval any complete tokens up to IP */
    while (FValidIrul(irul = IrulFromTk(MsoTkLexTextCpLim(vplexs, cpIp))))
        EmEvalTkIrul(irul);

    /* Evaluate any pending actions */
    if (_pacttbl->pactPending)
        DoPendingActions();

    /* All typed characters must now have been seen by the lexer */
    if (vplexs->cchLookahead > 0)
        vplexs->cchLookahead = 0;
}
#endif // }


#if FEATURE_TEXT // {
/* P U S H  I R U L T K  F O R M A T  P E N D I N G */
/*----------------------------------------------------------------------------
    %%Function: PushIrultkFormatPending
    %%Contact: daleg

    Push any pending format tokens into appropriate queues.
----------------------------------------------------------------------------*/

void PushIrultkFormatPending(void)
{
    MSORULTK           *prultk;

    debugEM1(8, "Checking for formatting before CP %ld\n",
             CpLexTokenFirst(vplexs));

    prultk = PrultkFormatFromIrultk(vplexs, vplexs->rultkhFormat.irultkMin);

    while (vplexs->rultkhFormat.irultkMin != vplexs->rultkhFormat.irultkLim
            &&  (prultk->cpFirst
                        < CpLexTokenFirst(vplexs) + DcpLexToken(vplexs)
                 ||  (DcpLexToken(vplexs) == 0
                        &&  prultk->cpFirst <= CpLexTokenFirst(vplexs))))
        {
        debugEM2(2, "FORMAT   : %-20.20s %ld\n",
                 LpchIrulName(prultk->tk), prultk->lValue);
        debugEM1(6, "  at CP %ld\n", prultk->cpFirst);

        /* Push format token into appropriate queue (resets depth) */
        MsoSignalEventIrul(IrulFromTk(prultk->tk), prultk->lValue);

        /* Move to next cache record, wrapping around if necessary */
        IncrFormatPrultk(vplexs, &prultk, &vplexs->rultkhFormat.irultkMin);
        }
}
#endif // }



#if FEATURE_TEXT // {
/* F  R E S E T  E M */
/*----------------------------------------------------------------------------
    %%Function: FResetEm
    %%Contact: daleg

    Reset the Event Monitor rules and lexer due to an IP (cursor) change,
    or due to some form of invalidation.
----------------------------------------------------------------------------*/

int FResetEm(
    MSOCP               cpIp,
    XCHAR              *wz,
    int                 ichMac
    )
{
    MSOCP               cpObject = 0;
    IRUL                irul;

    /* Initialize lexer to point to start of buffer */
    vplexs->pObjectIp = PObjectCur();
    vplexs->pxchBuffer = vplexs->pxchBufferIp = vplexs->pxchRun = wz;
    MsoLexSetPos(vplexs, cpObject, 0);

    debugEM0(0, "====================================================\n");
    debugEM3(0, "   FResetEm: RESETTING: pObjectIp %x cpLine %ld cp %ld\n",
             vplexs->pObjectIp, cpObject, cpIp);
    debugEM0(0, "====================================================\n");

    /* Reset rule base TOKEN state variables */
    MsoClearEventsForRulevts(rulevtEmTOKEN, drulevtToken,
                             (vpems->fInternalReset
                                ? rultPersistentRule | rultAlwaysPersist
                                : rultAlwaysPersist),
                             fTrue, fFalse);

    vplexs->wInterval = CIntervalsRulevt(rulevtEmTOKEN);

    /* Reset lexer base state */
    MsoResetLexState(vplexs, fTrue/*fFullReset*/);
    vplexs->cpLim = 0;
    vplexs->fInvalLexer = fFalse;

    /* Mark start of scan */
    MsoCacheTkText(vplexs, irulSTART, fTrue);
    MsoScheduleIrul(irulSTART, fTrue);

    /* Mark start of token cache, but not as events */
    MsoCacheTkText(vplexs, irulEND_OBJ, fTrue);
    vplexs->rultkhToken.irultkMin = vplexs->rultkhToken.irultkLim;

    /* Run only rules not marked as INTERACTIVE_ONLY */
    SetCurrRulg(rulgEmALWAYS);

    /* Inject and eval any complete tokens up to IP */
    while (FValidIrul(irul = IrulFromTk(MsoTkLexTextCpLim(vplexs, cpIp))))
        EmEvalTkIrul(irul);

    /* Run only rules not marked as INTERACTIVE_ONLY */
    SetCurrRulg(rulgEmINTERACTIVE_ONLY);

    /* Mark that we are synchronized */
    vplexs->cchLookahead = 0;

    return fTrue;
}


/* F  G E T  T O K E N  T E X T  O B J E C T */
/*----------------------------------------------------------------------------
    FGetTokenTextObject
    %%Contact: smueller

    Determine whether the text of the requested token needs to be fetched
    from the document.  If so, do so, leaving the results in ppxch and pcch,
    and return fTrue.  Otherwise, return fFalse.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetTokenTextObject(
    MSORULTK           *prultk,
    const XCHAR       **ppxch,                          // RETURN
    int                *pcch,                           // RETURN
    struct _MSOLEXS    *plexs
    )
{
    if (plexs->pObject != NULL)
        {
        // NOT SUPPORTED YET
        return fTrue;
        }

    return fFalse;
}


/* F  G E T  N E X T  L E X  R U N */
/*----------------------------------------------------------------------------
    %%Function: FGetNextLexRun
    %%Contact: daleg

    Return next run of text within the current object , and set the lexer
    run-state variables.

    For this demo, there ain't any, but we will show a commented-out sample.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetNextLexRun(MSOCP cpLim, MSOLEXS *plexs)
{
    int                 fStatus = fTrue;
    const XCHAR        *pxchPrevEnd = plexs->pxchNext;

    /* If prev run at end of current object, move to next object */
    if (FLexEndOfScan(vplexs))
        {
        /* If still have a pending token, complete it first */
        if (DcpLexCurr(vplexs) > 0)
            return fFalse;

        /* Create exactly one inter-object "created" tkEND_OBJ character */
        if (plexs->fCreateEndObjCh)
            {
            /* Make this run "created" text, i.e. no dcp */
            fStatus = fFalse;
            plexs->cpRun += plexs->ccpRun;
            plexs->ichRun += plexs->cchRun;
            plexs->cchRun = 1;
            plexs->ccpRun = 0;

#ifdef READY
            /* Mark run as "created", so dcp calcs will work properly */
            plexs->fAdjustTokenCps = fTrue;
            plexs->dcpCreated += 1;
            if (plexs->cpFirstCreated == 0L)
                plexs->cpFirstCreated = plexs->cpRun;
#endif /* READY */
            }

        /* Else get next object's text */
        else
            {
            if (!FGetNextLexObject(cpLim, plexs))
                return fFalse;

            /* If in object of IP has passed upper lim of scan, block lexer */
            if (plexs->pObject == plexs->pObjectIp  &&  cpLim != msocpMax
                    &&  cpLim <= 0 /* plexs->cpRun */)
                fStatus = fFalse;
            }
        }

    /* Else move to next run */
    else
        {
        plexs->cpRun += plexs->ccpRun;
        plexs->ichRun += plexs->cchRun;

#ifdef PORT_THIS
        plexs->cchRun = vcchEditText - plexs->ichRun;
#endif /* PORT_THIS */
        plexs->ccpRun = plexs->cchRun;

        // Reset buffer pointer if run in a different buffer
#ifdef PORT_THIS
        plexs->pxchBuffer = vszEditText;
#endif /* PORT_THIS */
        }

    /* Set Run length and pointer */
    plexs->cchRemain = plexs->cchRun;
    plexs->pxchNext = (plexs->pxchRun = plexs->pxchBuffer + plexs->ichRun);

    AssertSz0(pxchPrevEnd == plexs->pxchNext
                ||  pxchPrevEnd == plexs->pxchTkStart,
              "Discontiguous runs!");

    /* If run starts new text (line), reset non-cached tk start pointer */
    if (pxchPrevEnd == plexs->pxchTkStart)
        plexs->pxchTkStart = plexs->pxchNext;

    return fStatus;
}


/* F  G E T  N E X T  L E X  O B J E C T */
/*----------------------------------------------------------------------------
    %%Function: FGetNextLexObject
    %%Contact: daleg

    Set the "run" state variables to the first run of a new object, including
    the text buffer, and the run lengths.
----------------------------------------------------------------------------*/

int WIN_CALLBACK FGetNextLexObject(MSOCP cpLim, MSOLEXS *plexs)
{
    // If this is the first time thru, do initialization stuff
    if (plexs->ichRun == iNil)
        {
        // YOUR INITS HERE
        }

    // Fetch new object text
    plexs->pObject = PObjectCur();

    // Fetch new text (in our case, it is globally static)
    plexs->pxchBuffer = vszEditText;
    plexs->cchRun = plexs->cpLim = vcchEditText;
    plexs->pxchRun = plexs->pxchBuffer;

    // Set up other state variables
    plexs->ichRun = 0;
    plexs->cpRun = 0;
    plexs->cpObject = 0;
    plexs->ccpRun = plexs->cchRun;
    SetCpLexTokenFirst(vplexs, SetCpLexTokenNext(vplexs, 0));

    return fTrue;
}


/* F  L E X  F O R C E  C O M P L E T E */
/*----------------------------------------------------------------------------
    %%Function: FLexForceComplete
    %%Contact: daleg

    Force the current token to complete within the lexer.  This is a callback
    function that gets called when we wish to cause the lexer to finish a
    token without peeking at the next character.  This is generally when we
    are moving the IP out of a cell in a table, and wish to perform automatic
    actions anyway.

    Once we have completed the token, we clear the callback flag, to resume
    normal operation.

----------------------------------------------------------------------------*/

int WIN_CALLBACK FLexForceComplete(MSOCP cpLim, MSOLEXS *plexs)
{
    XCHAR               wch;

    /* If in the middle of a token complete it if next is EOO or delim */
    // REVIEW daleg: This should check for more than just spaces after
    if (plexs->iuState > 0
            &&  (cpLim == vplexs->cpLim
                    ||  (wch = *vplexs->pxchNext) == xchSpace))
        return fTrue;

    /* Do not call this routine next time */
    plexs->pfnlexrunForceComplete = NULL;

    /* Force an END_OBJ token (event) if we are at the cell boundary */
    return (cpLim == vplexs->cpLim);
}

#endif // }


#if YY_BASE // {

/* P A C T  P C A */
/*----------------------------------------------------------------------------
    %%Function: PactPca
    %%Contact: daleg

    Create a Delayed-Action record, using a MSOCA to define the edit range.
----------------------------------------------------------------------------*/

MSOACT *PactPca(
    MSOACTTBL          *pacttbl,
    int                 actt,
    MSOCA              *pca,
    ...
    )
{
    va_list             ap;
    MSOACT             *pact;

    /* Safety first: make sure we have an action structure */
    if (!pacttbl)
        return NULL;

    /* Start varargs */
    va_start(ap, pca);

    /* Create a new Delayed Action record, and push arg list into it */
    pact = MsoPactAp(pacttbl, actt,
                     (sizeof(MSOCA) + sizeof(long) - 1)/sizeof(long), ap);

    /* End varargs */
    va_end(ap);

    /* Calculate starting CP */
    pact->rec1_ca.ca = *pca;

    /* Insert the MSOACT record into the edit queue in CP sorted order */
    MsoInsertPact(pact, &pacttbl->pactPending);

    return pact;
}


#if YY_DELAYED // {
long WIN_CALLBACK DcpDoAct(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,
    MSOCA              *pca,
    MSOACT           **ppactNext,
    int                *pfDiscard
    );

/* D O  P E N D I N G  A C T I O N S */
/*----------------------------------------------------------------------------
    %%Function: DoPendingActions
    %%Contact: daleg

    Execute pending actions in delay action queue.
----------------------------------------------------------------------------*/

void DoPendingActions(void)
{
    _pacttbl->cpFirstEditPrev = -1;
    _pacttbl->dcpEditPrev = 0;
    _pacttbl->cpLimEdit = 0;
    MsoReversePact(&_pacttbl->pactPending);
    MsoDcpDoActs(&_pacttbl->pactPending, _pacttbl, 0, fTrue, -1, DcpDoAct);
}


/* D C P  D O  A C T */
/*----------------------------------------------------------------------------
    %%Function: DcpDoAct
    %%Contact: daleg

    Execute the action given by the MSOACT record.
----------------------------------------------------------------------------*/

long WIN_CALLBACK DcpDoAct(
    MSOACT             *pact,
    MSOACTTBL          *pacttbl,
    long               *pdcp,
    MSOCA              *pca,
    MSOACT           **ppactNext,
    int                *pfDiscard
    )
{
    switch (pact->rec1.actt)
        {
#include "emact.c_"
        }
    return 0;
}

#endif // }

#endif // }


#if FEATURE_DEMO // {
/* D C P  R E P L A C E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: DcpReplaceText
    %%Contact: daleg

    Replace the text range given by the range of chars with the new string.
----------------------------------------------------------------------------*/

int DcpReplaceText(
    void               *pObject,
    int                 cpFirst,
    int                 cpLim,
    char               *sz
    )
{
    int                 cch = CchSz(sz);
    int                 dcp = cch - (cpLim - cpFirst);
    int                 cchOrig;
    char                rgch[cbEditText];
    MSOCP               cpIp;

    /* Get current edit control value */
    cchOrig = GetDlgItemText(vhWndDlg, IDC_EDIT1, rgch, cbEditText);

    /* Do not attempt to expand beyond control's capacity. */
    if (cchOrig + dcp >= cbEditText)
        return 0;

    /* Replace the string */
    CopyRgb(rgch + cpLim, rgch + cpLim + dcp, cchOrig - cpLim + 1);
    CopyRgbNo(sz, rgch + cpFirst, cch);

    /* Set the edit control value with the new string, preserving the IP */
    vfSettingDlgItem = fTrue;                           // Prevent recursion
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, EM_GETSEL, 0, (LPARAM)&cpIp);
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, WM_SETTEXT, 0, (LPARAM)&rgch[0]);
    SendDlgItemMessage(vhWndDlg, IDC_EDIT1, EM_SETSEL, cpIp + dcp, cpIp + dcp);
    vcchEditText += dcp;
    vfSettingDlgItem = fFalse;

    debugEM0(2, "Replaced text\n");

    return dcp;
}
#endif // }


#if FEATURE_TEXT // {
/* F  C H E C K  I F  M U S T  R E S E T */
/*----------------------------------------------------------------------------
    %%Function: FCheckIfMustReset
    %%Contact: daleg

    Do a primitive check to see if we should invalidate our running rulebase
    state, and do a full reset scan.

    THIS IS NOT A CANONICAL ROUTINE, but there should be something equivalent
    in each app.
----------------------------------------------------------------------------*/

int FCheckIfMustReset(XCHAR wch, int ichMac, MSOCP cpIp)
{
    if (wch == xchBackspace)
        return fTrue;

    /* If user typed a new character, emit character event */
    /* REVIEW: pasting will result in multiple new characters, of which we
       only notice the last */
    if (ichMac > vcchPrev)
        {
        Assert (cpIp > 0);

        /* Without notification of IP moves, there is no way to accurately
           identify when lexer needs invalidating; for safety, we could do so
           on every character.  For demonstrating the lexer, we'll do so only
           when the IP didn't move forward by exactly one character, which is
           a decent approximation of the right time. */
        /* REVIEW: find a more pleasant way to deal with this, like subclassing
           the edit control to get precise control over notifications. */

        if (cpIp != vcpIpPrev + 1)
            return fTrue;
        }

    return fFalse;
}
#endif // }


#if FEATURE_DEMO // {
/* N  C W  R E G I S T E R  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: nCwRegisterClasses
    %%Contact: daleg

    Register window classes
----------------------------------------------------------------------------*/

int nCwRegisterClasses(void)
{
    WNDCLASS            wndclass;

    memset(&wndclass, 0x00, sizeof(WNDCLASS));

    /* load WNDCLASS with window's characteristics */
    wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW;
    wndclass.lpfnWndProc = WndProc;

    /* Extra storage for Class and Window objects */
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = vhInst;
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);

    /* Create brush for erasing background */
    wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wndclass.lpszMenuName = vszAppName;   /* Menu Name is App Name */
    wndclass.lpszClassName = vszAppName; /* Class Name is App Name */
    if (!RegisterClass(&wndclass))
        return -1;

    return (0);
}


/* C W  C E N T E R */
/*----------------------------------------------------------------------------
    %%Function: cwCenter
    %%Contact: daleg

    Center the main window.
----------------------------------------------------------------------------*/

void cwCenter(hWnd, top)
HWND hWnd;
int top;
{
    POINT               pt;
    RECT                swp;
    RECT                rParent;
    int                 iwidth;
    int                 iheight;

    /* get the rectangles for the parent and the child */
    GetWindowRect(hWnd, &swp);
    GetClientRect(vhWndMain, &rParent);

    /* calculate the height and width for MoveWindow */
    iwidth = swp.right - swp.left;
    iheight = swp.bottom - swp.top;

    /* find the center point and convert to screen coordinates */
    pt.x = (rParent.right - rParent.left) / 2;
    pt.y = (rParent.bottom - rParent.top) / 2;
    ClientToScreen(vhWndMain, &pt);

    /* calculate the new x, y starting point */
    pt.x = pt.x - (iwidth / 2);
    pt.y = pt.y - (iheight / 2);

    /* top will adjust the window position, up or down */
    if (top)
        pt.y = pt.y + top;

    /* move the window */
    MoveWindow(hWnd, pt.x, pt.y, iwidth, iheight, FALSE);
}


/* C W  U N  R E G I S T E R  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: CwUnRegisterClasses
    %%Contact: daleg

    Un-register the windows classes.
----------------------------------------------------------------------------*/

void CwUnRegisterClasses(void)
{
    WNDCLASS            wndclass;

    memset(&wndclass, 0x00, sizeof(WNDCLASS));

    UnregisterClass(vszAppName, vhInst);
}
#endif // }


#if FEATURE_DEAD // {
/* A S S E R T  L S Z  P R O C */
/*----------------------------------------------------------------------------
    %%Function: AssertLszProc
    %%Contact: daleg

    Print assertion message, and prompt for whether to (f)ail, or (i)gnore.
----------------------------------------------------------------------------*/

int AssertLszProc(
    const char         *szExtra,
    const char         *szFile,
    int                 line
    )
{
    Fail("ASSERTION FAILED: %s IN %s line %d\n", szExtra, szFile, line);
    return 1;
}


/* F A I L */
/*----------------------------------------------------------------------------
    %%Function: Fail
    %%Contact: daleg

    Emit a failure message and exit.
----------------------------------------------------------------------------*/

void __cdecl Fail(const char *sz, ...)
{
    va_list             ap;
    char                szBuf[256];

    /* Start variable arglist */
    va_start(ap, sz);

    wvsprintf(szBuf, sz, ap);
    OutputDebugStringA("FATAL ERROR: ");
    OutputDebugStringA(szBuf);
    OutputDebugStringA("\n");

    /* End variable arglist */
    va_end(ap);

//  _asm int 3;
    exit(1);
}
#endif // }


#if FEATURE_DEAD // {
/* F  N E  N C  L P C H */
/*----------------------------------------------------------------------------
    %%Function: FNeNcLpch
    %%Contact: daleg

    Compare two strings, case insensitive.
----------------------------------------------------------------------------*/

BOOL FNeNcLpch(
    register const uchar       *pch1,
    register const uchar       *pch2,
    register int                cch
    )
{
    while (cch-- > 0)
        {
        if (ChUpper(*pch1++) != ChUpper(*pch2++))
            return fTrue;
        }
    return fFalse;
}
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\shellapi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shellapi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shellapi.h"
#endif /* UNIX */
#include <shlapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\shlguid.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlguid.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlguid.h"
#endif /* UNIX */
#include <shlguidp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\shlobj.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlobj.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlobj.h"
#endif /* UNIX */
#include <shlobjp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\shlwapi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\shlwapi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/shlwapi.h"
#endif /* UNIX */
#include <shlwapip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\wingdi.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\wingdi.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/wingdi.h"
#endif /* UNIX */
#include <wingdip.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\winbase.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winbase.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winbase.h"
#endif /* UNIX */
#include <winbasep.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\winspool.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winspool.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winspool.h"
#endif /* UNIX */
#include <winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\stubs\winuser.h ===
//
// This is a fake header that allows our shell code to refer to private
// (internal) header information without explicitly including the ?????p.h 
// file.  The Win95 header files don't split the public and private 
// information out into separate header files until much later when 
// producing the SDK files.  The Chicago shell source code uses the header 
// file before the separation process.
//
// BobDay
//
#ifndef UNIX
#include "..\..\..\..\public\sdk\inc\winuser.h"
#else
#include "/vobs/userx/userx/public/sdk/inc/winuser.h"
#endif /* UNIX */
#include <winuserp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\configmg.h ===
/*****************************************************************************
 *
 *	(C) Copyright MICROSOFT Corp., 1993-1998
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *	Date:		02-Feb-1993
 *
 *	Authors:	PYS & RAL
 *
 *------------------------------------------------------------------------------
 *
 *	Change log:
 *
 *	   DATE     REV DESCRIPTION
 *	----------- --- -----------------------------------------------------------
 *	02-Feb-1993 PYS Original
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

#ifdef	GOLDEN	
#ifdef	RETAIL
#define	CM_GOLDEN_RETAIL
#endif
#endif

/*XLATOFF*/
#pragma	pack(1)
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0003h		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_HARDWIRED		0x00001000
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	_far

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_INTERRUPTS_DISABLED	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_NO_MORE_HW_PROFILES	0x00000029
#define	NUM_CR_RESULTS		0x0000002A

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_INTERRUPTS_DISABLED", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_NO_MORE_HW_PROFILES", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	NUM_CM_PROB				0x0000001C

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_BITS				0x00000001

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_INVALID			0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_BITS				0x00000001	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process.
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.

#define	NUM_CONFIG_COMMANDS	0x00000010	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifdef	retail
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))

#define	CM_BUUGBUUG(d, id, msg)	message("BUUGBUUG: "##d##", "##id##": "##msg)

#if	DEBLEVEL==DEBLEVELRETAIL

#define	CM_WARN(strings)
#define	CM_ERROR(strings)

#else

#if	DEBLEVEL==DEBLEVELNORMAL

#define	CM_WARN(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\pwrioctl.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       PWRIOCTL.H
*
*  VERSION:     1.0
*
*  DATE:        01 Feb 1994
*
*  AUTHOR:      TCS
*
*  Definitions for the Virtual Power Management Device DeviceIoControl
*  interface.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  01 Feb 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PWRIOCTL
#define _INC_PWRIOCTL

#ifndef Not_VxD
#define Not_VxD
#endif

#ifndef IS_32
#define IS_32
#endif

#include <vpowerd.h>

//
//  The IOCTL codes match up exactly to the order of the services in the VPOWERD
//  service table (plus one).  The input buffer for each IOCTL code follows the
//  same structure as the corresponding VPOWERD service would expect.  The
//  output buffer is used to store the return value from the VPOWERD service.
//

//  VPOWERD_IOCTL_GET_VERSION
//      Gets the version of the installed VPOWERD device.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD version.
#define VPOWERD_IOCTL_GET_VERSION               0x00000001

//  VPOWERD_IOCTL_GET_APM_BIOS_VERSION
//      Gets the version of the APM BIOS that VPOWERD has detected.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the APM BIOS version.
#define VPOWERD_IOCTL_GET_APM_BIOS_VERSION      0x00000002

//  VPOWERD_IOCTL_GET_PM_LEVEL
//      Gets the level of power management interaction between VPOWERD and the
//      APM BIOS.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the current power management
//                  level.
#define VPOWERD_IOCTL_GET_PM_LEVEL              0x00000003

//  VPOWERD_IOCTL_SET_PM_LEVEL
//      Sets the level of power management interaction between VPOWERD and the
//      APM BIOS.
//
//  lpvInBuffer:    Pointer to VPOWERD_SET_PM_LEVEL_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_SET_PM_LEVEL              0x00000004

typedef struct _VPOWERD_SET_PM_LEVEL_PARAM {
    DWORD PowerManagementLevel;
}   VPOWERD_SET_PM_LEVEL_PARAM;

//  VPOWERD_IOCTL_SET_DEVICE_STATE
//      Sets the power state (e.g., OFF) of the specified device ID.  Not valid
//      for the system device (all devices power managed by the APM BIOS).
//
//  lpvInBuffer:    Pointer to VPOWERD_SET_DEVICE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_SET_DEVICE_STATE          0x00000005

typedef struct _VPOWERD_SET_DEVICE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    POWER_STATE PowerState;
}   VPOWERD_SET_DEVICE_PARAM;

//  VPOWERD_IOCTL_RESTORE_DEFAULTS
//      Reinitializes all APM BIOS power-on defaults.
//
//  lpvInBuffer:    Not used for this operation, set to NULL.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_RESTORE_DEFAULTS          0x00000007

//  VPOWERD_IOCTL_GET_STATUS
//      Gets the current power status of the specified device ID.
//
//  lpvInBuffer:    Pointer to VPOWERD_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_GET_STATUS                0x00000008

typedef struct _VPOWERD_GET_STATUS_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATUS lpPowerStatus;
}   VPOWERD_GET_STATUS_PARAM;

//  VPOWERD_IOCTL_GET_STATE
//      Gets the power state (e.g., OFF) of the specified device ID.
//
//  lpvInBuffer:    Pointer to VPOWERD_GET_STATE_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_GET_STATE                 0x00000009

typedef struct _VPOWERD_GET_STATE_PARAM {
    POWER_DEVICE_ID PowerDeviceID;
    LPPOWER_STATE lpPowerState;
}   GET_STATE_PARAM;

//  VPOWERD_IOCTL_OEM_APM_FUNCTION
//      Calls an OEM defined APM BIOS extension.
//
//  lpvInBuffer:    Pointer to VPOWERD_OEM_APM_FUNCTION_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the VPOWERD return code.
#define VPOWERD_IOCTL_OEM_APM_FUNCTION          0x0000000A

typedef struct _VPOWERD_OEM_APM_FUNCTION_PARAM {
    LPOEM_APM_REGS lpOemApmRegs;
}   VPOWERD_OEM_APM_FUNCTION_PARAM;

//  VPOWERD_IOCTL_W32_GET_SYSTEM_STATUS
//      Gets the current power status of the system.  Follows the Win32
//      GetSystemPowerStatus API convention.
//
//  lpvInBuffer:    Pointer to VPOWERD_W32_GET_SYSTEM_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_W32_GET_SYSTEM_STATUS     0x0000000D

typedef struct _VPOWERD_W32_GET_SYSTEM_STATUS_PARAM {
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   VPOWERD_W32_GET_SYSTEM_STATUS_PARAM;

//  VPOWERD_IOCTL_GET_CAPABILITIES
//		Gets the capabilities bitmask of an APM 1.2 machine.
//  lpvInBuffer:    Pointer to VPOWERD_GET_CAPABILITIES_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_GET_CAPABILITIES			0x000000F

typedef struct _VPOWERD_GET_CAPABILITIES_PARAM {
    PAPM_CAPABILITIES	pApmCaps;
}   VPOWERD_GET_CAPABILITIES_PARAM;

// VPOWERD_IOCTL_ENABLE_RING_RESUME
// 		Calls into the BIOS and attempts to enable the Resume on Ring capability.  This is only supported on APM 1.2 machines
//	lpvInBuffer: 	Not used for this operation, set to NULL
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code. (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.)
#define VPOWERD_IOCTL_ENABLE_RING_RESUME		0x00000010

// VPOWERD_IOCTL_DISABLE_RING_RESUME
// 		Calls into the BIOS and attempts to disable the Resume on Ring capability.  This is only supported on APM 1.2 machines
//	lpvInBuffer: 	Not used for this operation, set to NULL
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code. (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.)
#define VPOWERD_IOCTL_DISABLE_RING_RESUME		0x00000011

//  VPOWERD_IOCTL_W32_GET_STATUS
//      Gets the current power status of a particular battery on an APM 1.2 machine.
//		BatteryNumber is the battery device ID in which your interested.  
//		The device ID is formed by adding 0x8000 to the *1* based battery number.
//		e.g. if your interested in the first battery, BatteryNumber=0x8001
//  lpvInBuffer:    Pointer to VPOWERD_W32_GET_STATUS_PARAM structure.
//  lpvOutBuffer:   Pointer to DWORD to receive the boolean return code.
#define VPOWERD_IOCTL_W32_GET_STATUS     0x00000017

typedef struct _VPOWERD_W32_GET_STATUS_PARAM {
	DWORD	BatteryNumber;
    LPWIN32_SYSTEM_POWER_STATUS lpWin32SystemPowerStatus;
}   VPOWERD_W32_GET_STATUS_PARAM;

// VPOWERD_IOCTL_GET_RING_RESUME_STATUS
// 		Calls into the BIOS and attempts to determine whether Resume on Ring is enabled or disabled. 
//		This is only supported on APM 1.2 machines.  
//	lpvInBuffer: 	Pointer to VPOWERD_GET_RING_RESUME_STATUS_PARAM structure
//  lpvOutBuffer: 	pointer to dword to receive the VPOWERD return code.  (Expect PR_FUNC_NOT_SUPPORTED on APM 1.1 or lower machines.) 
#define VPOWERD_IOCTL_GET_RING_RESUME_STATUS	0x00000019

typedef struct	_VPOWERD_GET_RING_RESUME_STATUS_PARAM {
LPDWORD	pStatus;
} VPOWERD_GET_RING_RESUME_STATUS_PARAM;

#endif // _INC_PWRIOCTL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#define PBT_CAPABILITIESCHANGE			0x0010

// APM 1.2 hibernate

// #ifdef SUPPORT_HIBERNATE

#define PBT_APMQUERYHIBERNATE			0x000C
#define PBT_APMQUERYHIBERNATEFAILED		0x000D
#define PBT_APMHIBERNATE				0x000E
#define PBT_APMRESUMEHIBERNATE			0x000F

// #endif

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\frosting.h ===
/*****************************************************************************
 *
 * frosting.h -  COOL.DLL functions, types, and definitions
 *
 * Copyright (c) 1993-1994, Microsoft Corp.	All rights reserved
 *
 *****************************************************************************/

#ifndef _FROSTING_H
#define _FROSTING_H

#define ordCoolWEP		    1

DWORD WINAPI CoolEnable(DWORD param);
#define ordCoolEnable		    2

void WINAPI CoolGetDosBoxTtFonts(LPSTR pszFaceSbcs, LPSTR pszFaceDbcs);
#define ordCoolGetDosBoxTtFonts	    3

#endif /* _FROSTING_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\bios.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1994
 *
 *   Title:	BIOS.H - PnP BIOS Enumerator VxD
 *
 *   Version:	4.00
 *
 *   Date:	6-Feb-1994
 *
 *   Author:	MSq
 *
 *------------------------------------------------------------------------------
 *
 *   Change log:
 *
 *      DATE	REV		    DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *    6-Feb-1994 MSq Original
 *****************************************************************************/

/*XLATOFF*/
#define	BIOS_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(BIOS, VxD)
BIOS_Service	(_BIOSGetVersion, VxD_CODE)
BIOS_Service	(_BIOSSoftUndock, VxD_CODE)
BIOS_Service	(_BIOSGetCapabilities, VxD_CODE)
BIOS_Service	(_BIOSGetAPMTable, VxD_CODE)
End_Service_Table(BIOS, VxD)
/*ENDMACROS*/

/*
 * One can add a VxD to fix a broken BIOS. This VxD must have
 * BIOS_EXT_DEVICE_ID as device ID and must export three services, in that
 * order:
 *
 * GetVersion: must return in eax 0x00000100 for this release and carry
 * clear (ie standard version code).
 *
 * GetHeader: must return in eax the linear address to an installation
 * structure, this need not be in BIOS space, but need to have the correct
 * values for building BIOS selectors. The structure will be used instead of
 * the one found by the scan. Also, the BIOS EXT VxD must use this time to
 * initialize. If initialization failed, the value 0 must be return.
 *
 * CallBIOS: will be called instead of calling the BIOS entry point. The
 * stack will be the exact same as if we were calling the BIOS except that
 * the return address is a 32-bit ret to BIOS.VxD. Also CS=DS=ES=SS=Flat
 * segment. Thus the BIOS_EXT VxD can pop the return address in a local
 * variable (this API will never be reentered) and do stack munging before
 * calling its internal function or call BIOS even. All registers except
 * eax, which is the return value, must be preserved. The high word of eax
 * is discarded by BIOS.VxD.
 */

/*XLATOFF*/
#define	BIOS_EXT_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(BIOS_EXT, VxD)
BIOS_EXT_Service	(_BIOSEXTGetVersion, VxD_CODE)
BIOS_EXT_Service	(_BIOSEXTGetHeader, VxD_CODE)
BIOS_EXT_Service	(_BIOSEXTCallBIOS, VxD_CODE)
End_Service_Table(BIOS_EXT, VxD)
/*ENDMACROS*/

#define	PNPBIOS_SERVICE_GETVERSION		0x000
#define	PNPBIOS_SERVICE_SOFTUNDOCK		0x100
#define	PNPBIOS_SERVICE_GETDOCKCAPABILITIES	0x200
#define	PNPBIOS_SERVICE_GETAPMTABLE		0x300

struct BIOSPARAMSTAG {
	DWORD bp_ret;
	WORD *bp_pTableSize;
	char *bp_pTable;
};

typedef struct BIOSPARAMSTAG BIOSPARAMS;
typedef struct BIOSPARAMSTAG *PBIOSPARAMS;

#define	PNPBIOS_ERR_NONE			0x00
#define	PNPBIOS_ERR_SUCCESS			PNPBIOS_ERR_NONE
#define	PNPBIOS_WARN_NOT_SET_STATICALLY		0x7F
#define	PNPBIOS_ERR_UNKNOWN_FUNCTION		0x81
#define	PNPBIOS_ERR_FUNCTION_NOT_SUPPORTED	0x82
#define	PNPBIOS_ERR_INVALID_HANDLE		0x83
#define	PNPBIOS_ERR_BAD_PARAMETER		0x84
#define	PNPBIOS_ERR_SET_FAILED			0x85
#define	PNPBIOS_ERR_EVENTS_NOT_PENDING		0x86
#define	PNPBIOS_ERR_SYSTEM_NOT_DOCKED		0x87
#define	PNPBIOS_ERR_NO_ISA_PNP_CARDS		0x88
#define	PNPBIOS_ERR_CANT_DETERMINE_DOCKING	0x89
#define	PNPBIOS_ERR_CHANGE_FAILED_NO_BATTERY	0x8A
#define	PNPBIOS_ERR_CHANGE_FAILED_CONFLICT	0x8B
#define	PNPBIOS_ERR_BUFFER_TOO_SMALL		0x8C
#define	PNPBIOS_ERR_USE_ESCD_SUPPORT		0x8D
#define	PNPBIOS_ERR_MS_INTERNAL			0xFE

#define PNPBIOS_DOCK_CAPABILITY_VCR		0x0001
#define PNPBIOS_DOCK_CAPABILITY_TEMPERATURE	0x0006
#define PNPBIOS_DOCK_CAPABILITY_COLD		0x0000
#define PNPBIOS_DOCK_CAPABILITY_WARM		0x0002
#define PNPBIOS_DOCK_CAPABILITY_HOT		0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:	1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:	RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 *   17-Dec-1993     Adds Far East VxDs identifiers
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.	Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE	    0	    // False
#define VMM_TRUE    (~FALSE)	// The opposite of False!

#define DEBLEVELRETAIL	0
#define DEBLEVELNORMAL	1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#define WIN403SERVICES		/*OPK-3 Services*/
#endif

#ifndef WIN40COMPAT
#define WIN41SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef	NEWSTRUCTS	; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *	    EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID	    0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID	    0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID	    0x0000A
#define VSD_DEVICE_ID	    0x0000B
#define VMD_DEVICE_ID	    0x0000C
#define VKD_DEVICE_ID	    0x0000D
#define VCD_DEVICE_ID	    0x0000E
#define VPD_DEVICE_ID	    0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID	    0x0001B
#define VDD2_DEVICE_ID	    0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID	    0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID	    0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID	    0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID	0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID 	0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID	0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID	0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID	0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS	*/
/* #define VNB_DEVICE_ID	   0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID	   0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID	*/

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID	    0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID	   0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F	/* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID	    0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID	    0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */

#define AWREDIR_DEVICE_ID   0x00049 /* AtWork Network FSD */
#define DDS_DEVICE_ID	    0x0004A /* Device driver services */
#define NTKERN_DEVICE_ID    0x0004B /* NT kernel device id */
#define VDOSKEYD_DEVICE_ID  0x0004B /* DOSKEY device id */

/*
 *   Far East DOS support VxD ID
 */

#define ETEN_Device_ID	    0x00060 /* ETEN DOS (Taiwan) driver */
#define CHBIOS_Device_ID    0x00061 /* CHBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */
#define VIME_Device_ID	    0x00064 /* Virtual DOS IME */
#define VHBIOSD_Device_ID   0x00065 /* HBIOS (Korean) for HWin31 driver */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.	Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER	    0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER	0x000000000 /*	but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER		0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER	    0x014000000
#define VWIN32_INIT_ORDER   0x014100000
#define NTKERN_INIT_ORDER   0x015000000 /* Must be before VxDLdr (so that it is ready for devnodes) */
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER	0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER	    ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER	    0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER	    0x028000000
#define VSD_INIT_ORDER	    0x02C000000

#define VCD_INIT_ORDER	    0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER	    0x034000000
#define VKD_INIT_ORDER	    0x038000000
#define VPD_INIT_ORDER	    0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER	0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER	0x080000000
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order	    0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER	    0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;	    /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;		/* Client's EDI */
    ULONG Pushad_ESI;		/* Client's ESI */
    ULONG Pushad_EBP;		/* Client's EBP */
    ULONG Pushad_ESP;		/* ESP before pushad */
    ULONG Pushad_EBX;		/* Client's EBX */
    ULONG Pushad_EDX;		/* Client's EDX */
    ULONG Pushad_ECX;		/* Client's ECX */
    ULONG Pushad_EAX;		/* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)	// turn off redefinition warning

typedef unsigned char	UCHAR;
typedef unsigned short	USHORT;

#pragma warning (default:4209)	// turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)	__##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define Declare_SCService(service, args, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG	    code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG	    data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG	code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG	data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG	code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG	code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG	code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG	code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG	code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG	code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG	code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG	code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =	1
??_ICODE    =	2
??_PCODE    =	3
??_SCODE    =	4
??_DBOCODE  =	5
??_16ICODE  =	6
??_RCODE    =	7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE	equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF	MASM6
_FLAT	EQU FLAT
ELSE
_FLAT	EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT	    ENDS

_TEXT	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT	    ENDS

;*  32 bit pageable code
_PTEXT	    SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT	    ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB	<classname>
    segname	SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname	SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
	ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB	<grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM		;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***	DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***	DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name	LABEL	NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***	CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
	extrn	name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***	MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***	MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or	??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT	    ENDS

;*  32 bit locked data
_LDATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA	    ENDS

_DATA	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA	    ENDS

;*  32 bit pageable data
_PDATA	    SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA	    ENDS

;*  32 Bit initialization data
_IDATA	    SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA	    ENDS

;*  Created by C8
_BSS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS	    ENDS

CONST	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST	    ENDS

_TLS	    SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS	    ENDS

;*  32 Bit static code for DL-VxDs
_STEXT	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT	    ENDS

;*  32 Bit static data for DL-VxDs
_SDATA	    SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA	    ENDS

;*	dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*	32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*	32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

if DEBLEVEL
;*  Start of 32 bit path coverage data
_PATHSTART  SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHSTART  ENDS

;*  32 bit path coverage data
_PATHDATA   SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHDATA   ENDS

;*  End of 32 bit path coverage data
_PATHEND    SEGMENT DWORD PUBLIC  _FLAT 'LCODE'
_PATHEND    ENDS
endif

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE	    SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE	    ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
IF DEBLEVEL
_PGROUP   GROUP _PATHSTART, _PATHDATA, _PATHEND
ENDIF
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;	. . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table	VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1		; Only in module where table is
;   INCLUDE	VxD.INC 	; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF	Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID	= 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName	Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName	MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table


Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition, StdCallBytes, fastcall
LOCAL $$&Procedure, extrnproc, tableproc

  extrnproc MACRO
    IFNB <fastcall>
      IFB <StdCallBytes>
	.err	;StdCallBytes required
      ENDIF
      EXTRN @&&Procedure&&@&&StdCallBytes:NEAR
    ELSE
      IFNB <StdCallBytes>
	EXTRN _&&Procedure&&@&&StdCallBytes:NEAR
      ELSE
	EXTRN Procedure:NEAR
      ENDIF
    ENDIF
    ENDM

  tableproc MACRO
    IFNB <fastcall>
      dd  OFFSET32 @&&Procedure&&@&&StdCallBytes
    ELSE
      IFNB <StdCallBytes>
	dd  OFFSET32 _&&Procedure&&@&&StdCallBytes
      ELSE
	dd  OFFSET32 Procedure
      ENDIF
    ENDIF
    ENDM

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
	extrnproc
      ELSE
	tableproc
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     IFNB <fastcall>
    PUBLIC __&&Procedure
     __&&Procedure LABEL DWORD
     ENDIF
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
	IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
	ENDIF
	IFNB <Condition>
    $$&&Procedure extern
       ELSE
	extrnproc
	ENDIF
	IFNB <Local_Seg>
Local_Seg&&_ENDS
	ELSE
Def_Segment&_CODE_ENDS
	ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
	tableproc
      ENDIF

	  IFDEF Device_Name&_Name_Based
	@@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
	  ELSE
	@@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
	  ENDIF
  ELSE
    dd	0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    Purge extrnproc
    Purge tableproc
    ENDM

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4
    ??_standardccall&&_Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition, %Args*4, TRUE
    ??_fastcall&&_Procedure = Args
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF	Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM

ENDIF

  Device_Name&_StdCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_standardccall_&&Procedure = Args
    ENDM

  Device_Name&_FastCall_Service MACRO Procedure, Args, Local_Seg, Condition
    Device_Name&_Service Procedure, Local_Seg, Condition
    ??_fastcall_&&Procedure = Args
    ENDM

ENDIF

    ENDM


;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal	macro	reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress	macro	reg,service
    mov reg,OFFSET32 service
    endm


;***	Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.	If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName	- the name of the VxD; it is assumed
;		  that a corresponding Device_ID is
;		  also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;	accepts a service name as its only parameter.
;	This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd	csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
	.erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
	dd  OFFSET32 Name,cparm&&Name
    endif
	@32&&Name equ	((VxDName&_Device_ID SHL 16) + ??w32svcno)
	??w32svcno = ??w32svcno + 1
	ENDM
    ENDM


;***	End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName	- the same name passed to
;		  Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***	Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name	- the service name
;	cParms	    - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***	Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service	- the name of the service
;	CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)	service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp	VxDJmp

#define SERVICE 	__cdecl
#define ASYNC_SERVICE	__cdecl
#define WIN32_SERVICE	void __stdcall

#ifndef FASTCALL
#define FASTCALL	__fastcall
#endif
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
	ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status; 	/* VM status flags */
    ULONG CB_High_Linear;	/* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56	/* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT	0x00	/* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE	(1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT	0x01	/* VM runs in background */
#define VMSTAT_BACKGROUND	(1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING 	(1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT	0x03	/* VM not scheduled */
#define VMSTAT_SUSPENDED	(1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE	(1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC		(1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP		(1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32 	(1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC 	(1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09	/* High pri background */
#define VMSTAT_HIGH_PRI_BACK	(1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED		(1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT	0x0B	/* Woke up after blocked */
#define VMSTAT_AWAKENING	(1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT	0x0C	/* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT	VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86	(1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D	/* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED	(1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E	/* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT	(1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT 	0x0F	/* VM has released time slice */
#define VMSTAT_IDLE		(1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING		(1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11	/* VM suspended by */
#define VMSTAT_TS_SUSPENDED	(1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT	0x12	/* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI	(1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;		/* Thread status flags */
    ULONG   TCB_Reserved1;	/* Used internally by VMM */
    ULONG   TCB_Reserved2;	/* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;	/* Client registers of thread */
    ULONG   TCB_VMHandle;	/* VM that thread is part of */
    USHORT  TCB_ThreadId;	/* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;	    /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;	    /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;	/* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;		/* reusable; for dword align */
    UCHAR   TCB_pad2;		/* reusable; for dword align */
    UCHAR   TCB_extErrLocus;	    /* extended error Locus */
    USHORT  TCB_extErr; 	/* extended error Code */
    UCHAR   TCB_extErrAction;	    /*	    "   "   Action */
    UCHAR   TCB_extErrClass;	    /*	    "   "   Class */
    ULONG   TCB_extErrPtr;	/*	"   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD	    0x42434854	  // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT	    0x03   // Thread not scheduled
#define THFLAG_SUSPENDED		   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE		   (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION		   (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED		   (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_RING0_THREAD_BIT     0x1C   // thread runs only at ring 0
#define THFLAG_RING0_THREAD		   (1L << THFLAG_RING0_THREAD_BIT)
#define THFLAG_ASYNC_THREAD_BIT	    0x1F   // thread is asynchronous
#define THFLAG_ASYNC_THREAD	       	   (1L << THFLAG_ASYNC_THREAD_BIT)
#define THFLAG_CHARSET_BITS	0x10   // Default character set
#define THFLAG_CHARSET_MASK	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI	       (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM	       (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE		   (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED 	   (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES 	   (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13	 // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE		 (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;		// faulting EIP
    WORD  VMFI_CS;		// faulting CS
    WORD  VMFI_Ints;		// interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *		V M M	S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#define VMM_StdCall_Service Declare_SCService
#define VMM_FastCall_Service Declare_SCService
#pragma warning (disable:4003)	    // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)	// MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

//
// Flags affecting the returned block
//

#define HEAPZEROINIT        0x00000001
#define HEAPZEROREINIT      0x00000002
#define HEAPNOCOPY          0x00000004

//
// Alignment flags
//

#define HEAPALIGN_SHIFT     16
#define HEAPALIGN_MASK      0x000F0000

#define HEAPALIGN_4         0x00000000                // dword aligned
#define HEAPALIGN_8         0x00000000                // quadword aligned
#define HEAPALIGN_16        0x00000000                // paragraph aligned
#define HEAPALIGN_32        0x00010000                // etc.
#define HEAPALIGN_64        0x00020000
#define HEAPALIGN_128       0x00030000
#define HEAPALIGN_256       0x00040000
#define HEAPALIGN_512       0x00050000
#define HEAPALIGN_1K        0x00060000
#define HEAPALIGN_2K        0x00070000
#define HEAPALIGN_4K        0x00080000
#define HEAPALIGN_8K        0x00090000
#define HEAPALIGN_16K       0x000A0000
#define HEAPALIGN_32K       0x000B0000
#define HEAPALIGN_64K       0x000C0000
#define HEAPALIGN_128K      0x000D0000

//
// Flags indicating which system heap to use.  There are four bits reserved
// to identify the heap to use.  Four are currently defined by the system.
//

#define HEAPTYPESHIFT       8
#define HEAPTYPEMASK        0x00000700

#define HEAPLOCKEDHIGH      0x00000000
#define HEAPLOCKEDIFDP      0x00000100
#define HEAPSWAP            0x00000200
#define HEAPLOCKEDLOW       0x00000300
#define HEAPINIT            0x00000400  // will be automatically freed after
                                        // init complete
#define HEAPSYSVM           0x00000500

//
// other flags
//

#define HEAPCLEAN           0x00000800
#define HEAPCONTIG          0x00001000  // memory must be physically contiguous
#define HEAPFORGET          0x00002000  // this memory will never be freed

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT		0x00000001
#define PAGEUSEALIGN		0x00000002
#define PAGECONTIG		0x00000004
#define PAGEFIXED		0x00000008
#define PAGEDEBUGNULFAULT	0x00000010
#define PAGEZEROREINIT		0x00000020
#define PAGENOCOPY		0x00000040
#define PAGELOCKED		0x00000080
#define PAGELOCKEDIFDP		0x00000100
#define PAGESETV86PAGEABLE	0x00000200
#define PAGECLEARV86PAGEABLE	0x00000400
#define PAGESETV86INTSLOCKED	0x00000800
#define PAGECLEARV86INTSLOCKED	0x00001000
#define PAGEMARKPAGEOUT 	0x00002000
#define PAGEPDPSETBASE		0x00004000
#define PAGEPDPCLEARBASE	0x00008000
#define PAGEDISCARD		0x00010000
#define PAGEPDPQUERYDIRTY	0x00020000
#define PAGEMAPFREEPHYSREG	0x00040000
#define PAGEPHYSONLY		0x04000000
//efine PAGEDONTUSE		0x08000000  // ;Internal
#define PAGENOMOVE		0x10000000
#define PAGEMAPGLOBAL		0x40000000
#define PAGEMARKDIRTY		0x80000000

/****************************************************
 *
 *	Flags for _PhysIntoV86,
 *	_MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP	0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL	0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE	0x00000002
#define MMGRHMADISABLE	0x00000004
#define MMGRHMAQUERY	0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT	    0
#define LF_ASYNC	(1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP	(1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR	    (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP 	(LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign	    0x00000001
#define GVDADWordAlign	    0x00000002
#define GVDAParaAlign	    0x00000004
#define GVDAPageAlign	    0x00000008
#define GVDAInstance	    0x00000100
#define GVDAZeroInit	    0x00000200
#define GVDAReclaim	0x00000400
#define GVDAInquire	0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE	    260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT	0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT	0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT	0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT	0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT	0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *	    D E B U G G I N G	E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)	// Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)	// for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz	@@Test_DBCS_Lead_Byte - 100D1h	 ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT	 0x0001 // physical memory that must be swapped out
				// and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY	    0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS	 0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001	/* Privledged instruction */
#define GSDVME_INVALINST    0x00010002	/* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003	/* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004	/* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005	/* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006	/* User requested NUKE of VM */
#define GSDVME_DEVNUKE	    0x00010007	/* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008	/* Device specific problem:
			 *   invalid hardware fiddling
			 *   by VM (invalid I/O)
			 */
#define GSDVME_NUKENOMSG    0x00010009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */
#define GSDVME_OKNUKEMASK   0x80000000	/* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001	/* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002	/* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003	/* XMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004	/* EMS Kb Req	   - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005	/* Hi DOS V86 mem   - DOSMGR
			 *	     V86MMGR
			 */
#define GSDVME_INSMEMVID    0x00020006	/* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007	/* Base VM mem	   - VMM
			 *   CB, Inst Buffer
			 */
#define GSDVME_INSMEMDEV    0x00020008	/* Couldn't alloc base VM
			 * memory for device.
			 */
#define GSDVME_CRTNOMSG     0x00020009	/* Supress standard messages:
			 *   SHELL_Message used for
			 *   custom msg.
			 */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001	/* Page directory entry not-present */
#define IPF_V86PG   0x00000002	/* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004	/* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008	/* page has invalid not present type */
#define IPF_PGERR   0x00000010	/* pageswap device failure */
#define IPF_REFLT   0x00000020	/* re-entrant page fault */
#define IPF_VMM     0x00000040	/* Page fault caused by a VxD */
#define IPF_PM	    0x00000080	/* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100	/* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT	0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)	// Debugging only
VMM_Service (Disable_Touch_1st_Meg)	// Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz	 @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT	    0
#define DFS_LOG 	    (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT 	1
#define DFS_PROFILE	    (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT	2
#define DFS_TEST_CLD		(1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT	    3
#define DFS_NEVER_REENTER	(1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT	    4
#define DFS_TEST_REENTER	(1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT	    5
#define DFS_NOT_SWAPPING	(1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT	6
#define DFS_TEST_BLOCK		(1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES   0xFFFFFF80

#define DFS_EXIT_NOBLOCK	(DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK	(DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC  (DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service (Test_VM_Ints_Enabled)
VMM_Service (_BlockOnID)

VMM_Service (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define MUTEX_MUST_COMPLETE	1L
#define MUTEX_NO_CLEANUP_THREAD_STATE	2L

/*MACROS*/
VMM_Service (_CreateMutex)

VMM_Service (_DestroyMutex)
VMM_Service (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service (VMMCreateThread)
VMM_Service (_GetThreadExecTime)
VMM_Service (VMMTerminateThread)

VMM_Service (Get_Cur_Thread_Handle)
VMM_Service (Test_Cur_Thread_Handle)
VMM_Service (Get_Sys_Thread_Handle)
VMM_Service (Test_Sys_Thread_Handle)
VMM_Service (Validate_Thread_Handle)
VMM_Service (Get_Initial_Thread_Handle)
VMM_Service (Test_Initial_Thread_Handle)
VMM_Service (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service (Cancel_Call_When_Thread_Switched)
VMM_Service (Get_Next_Thread_Handle)
VMM_Service (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service (_EnterMutex)
VMM_Service (_LeaveMutex)
VMM_Service (Simulate_VM_IO)
VMM_Service (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service (_EnterMustComplete)
VMM_Service (_LeaveMustComplete)
VMM_Service (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND	    1L
#define THREAD_TERM_STATUS_NUKE_PEND	    2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service (_GetThreadTerminationStatus)
VMM_Service (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE	0	/* no data instanced in range */
#define INSTINFO_SOME	1	/* some data instanced in range */
#define INSTINFO_ALL	2	/* all data instanced in range */

/*MACROS*/
VMM_Service (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service (Call_Priority_Thread_Event)
VMM_Service (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ	    // define only if not there already

#define REG_SZ	    0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT	0x80000000
#define HKEY_CURRENT_USER	0x80000001
#define HKEY_LOCAL_MACHINE	0x80000002
#define HKEY_USERS		0x80000003
#define HKEY_PERFORMANCE_DATA	0x80000004
#define HKEY_CURRENT_CONFIG	0x80000005
#define HKEY_DYN_DATA		0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service (_LocalizeSprintf)
VMM_Service (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE	0	/* no pages in the specified range exist */
#define PHYSINFO_SOME	1	/* some pages in the specified range exist */
#define PHYSINFO_ALL	2	/* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service (Time_Slice_Sys_VM_Idle)
VMM_Service (Time_Slice_Sleep)
VMM_Service (Boost_With_Decay)
VMM_Service (Set_Inversion_Pri)
VMM_Service (Reset_Inversion_Pri)
VMM_Service (Release_Inversion_Pri)
VMM_Service (Get_Thread_Win32_Pri)
VMM_Service (Set_Thread_Win32_Pri)
VMM_Service (Set_Thread_Static_Boost)
VMM_Service (Set_VM_Static_Boost)
VMM_Service (Release_Inversion_Pri_ID)
VMM_Service (Attach_Thread_To_Group)
VMM_Service (Detach_Thread_From_Group)
VMM_Service (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM	0
#define REGTYPE_CLASS	1
#define REGTYPE_VXD	2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN		    0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD	    0x00000000
#define ASSERT_RANGE_NULL_OK	    0x00000001
#define ASSERT_RANGE_IS_ASCIIZ	    0x00000002
#define ASSERT_RANGE_IS_NOT_ASCIIZ  0x00000000
#define ASSERT_RANGE_NO_DEBUG	    0x80000000
#define ASSERT_RANGE_BITS	    0x80000003

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQueryMultipleValues)

// Additional timeslicer services
VMM_Service (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN		0x00000001
#define BOOT_DOSCLEAN		0x00000002
#define BOOT_NETCLEAN		0x00000004
#define BOOT_INTERACTIVE	0x00000008

/*MACROS*/
VMM_Service (Get_Boot_Flags)
VMM_Service (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service (_AddReclaimableItem)
VMM_Service (_SetReclaimableItem)
VMM_Service (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service (Time_Slice_Wake_Sys_VM)
VMM_Service (VMM_Replace_Global_Environment)
VMM_Service (Begin_Non_Serial_Nest_V86_Exec)
VMM_Service (Get_Nest_Exec_Status)
/*ENDMACROS*/

// Bootlogging services

/*MACROS*/
VMM_Service (Open_Boot_Log)
VMM_Service (Write_Boot_Log)
VMM_Service (Close_Boot_Log)
VMM_Service (EnableDisable_Boot_Log)
VMM_Service (_Call_On_My_Stack)
/*ENDMACROS*/

// Another instance data service

/*MACROS*/
VMM_Service (Get_Inst_V86_Int_Vec_Base)
/*ENDMACROS*/

// Case insensitive functions -- SEE WARNINGS IN DOCS BEFORE USING!
/*MACROS*/
VMM_Service (_lstrcmpi)
VMM_Service (_strupr)
/*ENDMACROS*/

/*MACROS*/
VMM_Service (Log_Fault_Call_Out)
VMM_Service (_AtEventTime)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

#ifdef WIN403SERVICES
//
// 4.03 Services
//

/*MACROS*/
VMM_Service (_PageOutPages)
/*ENDMACROS*/

// Flag definitions for _PageOutPages

#define PAGEOUT_PRIVATE 0x00000001
#define PAGEOUT_SHARED	0x00000002
#define PAGEOUT_SYSTEM	0x00000004
#define PAGEOUT_REGION	0x00000008
#define PAGEOUT_ALL	(PAGEOUT_PRIVATE | PAGEOUT_SHARED | PAGEOUT_SYSTEM)

/*MACROS*/
VMM_Service (_Call_On_My_Not_Flat_Stack)
VMM_Service (_LinRegionLock)
VMM_Service (_LinRegionUnLock)
VMM_Service (_AttemptingSomethingDangerous)
VMM_Service (_Vsprintf)
VMM_Service (_Vsprintfw)
VMM_Service (Load_FS_Service)
VMM_Service (Assert_FS_Service)
VMM_StdCall_Service (RtlUnwind, 4)
VMM_StdCall_Service (RtlRaiseException, 1)
VMM_StdCall_Service (RtlRaiseStatus, 1)

VMM_StdCall_Service (KeGetCurrentIrql, 0)
VMM_FastCall_Service (KfRaiseIrql, 1)
VMM_FastCall_Service (KfLowerIrql, 1)

VMM_Service (_Begin_Preemptable_Code)
VMM_Service (_End_Preemptable_Code)
VMM_FastCall_Service (Set_Preemptable_Count, 1)

VMM_StdCall_Service (KeInitializeDpc, 3)
VMM_StdCall_Service (KeInsertQueueDpc, 3)
VMM_StdCall_Service (KeRemoveQueueDpc, 1)

VMM_StdCall_Service (HeapAllocateEx, 4)
VMM_StdCall_Service (HeapReAllocateEx, 5)
VMM_StdCall_Service (HeapGetSizeEx, 2)
VMM_StdCall_Service (HeapFreeEx, 2)
//VMM_Service (_Get_CPUID_Flags)

/*ENDMACROS*/

#endif /* WIN403SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)		// turn on not enough params warning

#ifndef try
#define try				__try
#define except				__except
#define finally 			__finally
#define leave				__leave
#ifndef exception_code
#define exception_code			__exception_code
#endif  // exception_code
#endif  // try

#ifndef EXCEPTION_EXECUTE_HANDLER
#define EXCEPTION_EXECUTE_HANDLER	1
#define EXCEPTION_CONTINUE_SEARCH	0
#define EXCEPTION_CONTINUE_EXECUTION	-1
#endif
/*XLATON*/

#define COMNFS_FLAT	0xFFFFFFFF

#define ASD_MAX_REF_DATA    64	    // If bigger than this, a checksum is used

struct	_vmmguid {
unsigned long Data1;
unsigned short Data2;
unsigned short Data3;
unsigned char Data4[8];
};

typedef struct _vmmguid VMMGUID;
typedef VMMGUID     *VMMREFIID;

typedef DWORD		ASD_RESULT;

#define ASD_ERROR_NONE	    0x00000000
#define ASD_CHECK_FAIL	    0x00000001	// The flag is set that this failed before
#define ASD_CHECK_SUCCESS   0x00000002	// The flag is set that this succeeded before
#define ASD_CHECK_UNKNOWN   0x00000003	// No flag is set
#define ASD_ERROR_BAD_TIME  0x00000004	// Under cli
#define ASD_REGISTRY_ERROR  0x00000005	// Unknown registry error
#define ASD_CLEAN_BOOT	    0x00000006	// Clean booting fails everything
#define ASD_OUT_OF_MEMORY   0x00000007	// Ran out of memory (extremely rare)
#define ASD_FILE_ERROR	    0x00000008	// Int 21 to flush the info file failed
#define ASD_ALREADY_SET     0x00000009	// ASD_CHECK* done twice on same vgOperation/pRefData
#define ASD_MISSING_CHECK   0x0000000A	// ASD_DONE* on something not set
#define ASD_BAD_PARAMETER   0x0000000B	// Invalid operation, refiid or ref pointer

#define ASD_OP_CHECK_AND_WRITE_FAIL_IF_UNKNOWN	0x00000000
#define ASD_OP_CHECK_AND_ALWAYS_WRITE_FAIL	0x00000001
#define ASD_OP_CHECK				0x00000002
#define ASD_OP_DONE_AND_SET_SUCCESS		0x00000003
#define ASD_OP_SET_FAIL 			0x00000004
#define ASD_OP_SET_SUCCESS			0x00000005
#define ASD_OP_SET_UNKNOWN			0x00000006
#define ASD_OP_DONE				0x00000007

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM		0x00000001
#define RS_RESTORE		0x00000002
#define RS_DOSARENA		0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;			// low (< 1meg) address of item
    ULONG   RS_Bytes;			// size of item in bytes
    ULONG   RS_CallBack;		// callback, if any (zero if none)
    ULONG   RS_RefData; 		// reference data for callback, if any
    ULONG   RS_HookTable;		// real-mode hook table (zero if none)
    ULONG   RS_Flags;			// 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;	/* # pages in linear address space */
    ULONG DIPhys_Count; 	/* Count of phys pages */
    ULONG DIFree_Count; 	/* Count of free phys pages */
    ULONG DIUnlock_Count;	/* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;	/* Base of pageable address space */
    ULONG DILin_Total_Free;	/* Total Count of free linear pages */

    /*
     *	The following 5 fields are all running totals, kept from the time
     *	the system was started
     */
    ULONG DIPage_Faults;	/* total page faults */
    ULONG DIPage_Ins;		/* calls to pagers to page in a page */
    ULONG DIPage_Outs;		/* calls to pagers to page out a page*/
    ULONG DIPage_Discards;	/* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;	/* instance page faults */

    ULONG DIPagingFileMax;	/* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;	/* # of pages of paging file currently in use */

    ULONG DICommit_Count;	/* Total committed memory, in pages */

    ULONG DIReserved[2];	/* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;	    /* INIT <0> RESERVED */
    ULONG InstLinkB;	    /* INIT <0> RESERVED */
    ULONG InstLinAddr;	    /* Linear address of start of block */
    ULONG InstSize;	    /* Size of block in bytes */
    ULONG InstType;	    /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD	0x100	/* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD	0x200	/* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD	0x400	/* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;	    /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;	    /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400	/* anywhere in private arena */
#define PR_SHARED   0x80060000	/* anywhere in shared arena */
#define PR_SYSTEM   0x80080000	/* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008	/* don't move during PageReAllocate */
#define PR_4MEG     0x00000001	/* allocate on 4mb boundary */
#define PR_STATIC   0x00000010	/* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001	/* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002	/* swappable uninitialized pages */
#define PD_FIXEDZERO	0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004	/* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008	/* pages are permanently locked */
#define PC_LOCKED   0x00000080	/* pages are made present and locked*/
#define PC_LOCKEDIFDP	0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE	0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000	/* make the pages ring 3 accessible */
#define PC_INCR     0x40000000	/* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000	/* make pages initially present */
#define PC_STATIC   0x20000000	/* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000	/* make pages initially dirty */
#define PC_CACHEDIS 0x00100000  /* Allocate uncached pages - new for WDM */
#define PC_CACHEWT  0x00080000  /* Allocate write through cache pages - new for WDM */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT	0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000	/* don't map to any linear address */


/*MTRR type flags */
#define MTRR_UC 0
#define MTRR_WC 1
#define	MTRR_WT 4
#define	MTRR_WP 5
#define	MTRR_WB 6

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS	       0x01
#define PAGE_READONLY	       0x02
#define PAGE_READWRITE	       0x04
#define MEM_COMMIT	     0x1000
#define MEM_RESERVE	     0x2000
#define MEM_FREE	    0x10000
#define MEM_PRIVATE	    0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *	clean - page has not been written to since its last page out
 *	dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *	virgin - page has never been written to since it was committed
 *	tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *	For 32-bit EXE code or read-only data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = 0
 *	  pd_cleanout = 0
 *	  pd_dirtyout = 0
 *	  pd_virginfree = 0
 *    pd_taintedfree = 0
 *    pd_dirty = 0
 *	  pd_type = PD_PAGERONLY
 *
 *	For 32-bit EXE writeable data:
 *
 *	  pd_virginin = routine to load page from an exe file
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 *
 *	For zero-initialized swappable data:
 *
 *	  pd_virginin = routine to zero-fill a page
 *	  pd_taintedin = routine to load page from swap file
 *	  pd_cleanout = 0
 *	  pd_dirtyout = routine to write a page out to the swap file
 *	  pd_virginfree = 0
 *	  pd_taintedfree = routine to free page from the swap file
 *	  pd_dirty = routine to free page from the swap file
 *	  pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *	The following four fields are entry points in the pager which
     *	we call to page in or page out a page.	The following parameters
     *	are passed to the pager during these calls:
     *
     *	ppagerdata - pointer to the pager-specific dword of data
     *		 stored with the virtual page.	The pager is
     *		 free to modify the contents of this dword
     *		 DURING the page in or out, but not afterwards.
     *
     *	ppage - pointer to page going in or out (a ring 0 alias
     *	    to the physical page).  The pager should use this
     *	    address to access the contents of the page.
     *
     *	faultpage - faulting linear page number for page-ins, -1 for
     *		page-outs.  This address should not be accessed
     *		by the pager.  It is provided for information
     *		only.  Note that a single page can be mapped at
     *		more than one linear address because of the
     *		MapIntoV86 and LinMapIntoV86 services.
     *
     *	The pager should return non-0 if the page was successfully
     *	paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *	The pd_*free routines are used to inform the pager when the last
     *	reference to a virtual page controlled by the pager is
     *	decommitted.  A common use of this notification is to
     *	free space in a backing file, or write the page contents
     *	into the backing file.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions, but no return value is recognized.  The "ppage"
     *	and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *	The pd_dirty routine is used to inform the pager when the
     *	memory manager detects that a page has been written to.  The memory
     *	manager does not detect the write at the instant it occurs, so
     *	the pager should not depend upon prompt notification.  A common
     *	use of this notification might be to invalidate cached data.
     *	If the page was dirtied in more than one memory context,
     *	the pager's pd_dirty routine will be called once for each
     *	context.
     *
     *	These calls take the same parameters as the page-out and -in
     *	functions except that the "ppage" parameter isn't valid and
     *	no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *	The pd_type field gives the sytem information about the
     *	overcommit characteristics of pages controlled by this pager.
     *	The following are allowable values for the field:
     *
     *	PD_SWAPPER - under some conditions, pages of this type
     *	    may be paged out into the swap file
     *	PD_PAGERONLY - pages controlled by this pager will never
     *	    be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *	    functions perform nested excecution or block using the
     *	    BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *	    specified if the pager does any sort of file i/o to anything
     *	    other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER  0	/* pages need direct accounting in swap file */
#define PD_PAGERONLY	1   /* pages will never be swapped */
#define PD_NESTEXEC 2	/* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR	    ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR	    ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR	    ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR	    ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR	((ULONG) 0x003fffff)
#define MINDOSLADDR	((ULONG) 0x00000000)

#define MAXSYSTEMPAGE	    (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE	    (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE	    (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE	    (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE	    (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE	    (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE	(MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE	(MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE	(1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED	(1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM	(1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS		(1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE	(1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED	(1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM	(1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS		(1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC	(max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC	(max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar	EQU NEAR PTR
ELSE
DebFar	EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *	     EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.	Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000	/* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT	0x0001	    /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.	Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE	    0x0002	/* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT	0x0003	    /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004	/* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT	0x0005	    /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.	SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006	/* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM	0x0007

/*
 *  Second phase of Create_VM.	EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT 	0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE	    0x000A	/* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.	VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B	/* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.	EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM	0x000C	    /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00	/* VM was crashed */
#define VNE_CRASHED	(1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT	    0x01	/* VM was destroyed while active */
#define VNE_NUKED	(1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02	/* Some device failed Create_VM */
#define VNE_CREATEFAIL	    (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03	/* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL	    (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04	/* Some device failed VM_Init */
#define VNE_INITFAIL	    (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT	    0x05
#define VNE_CLOSED	(1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND	0x000D	    /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME	0x000E	    /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.	Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012	/* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY	    0x0013	/* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY	0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP	    0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT	0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP	0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY	0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *	  CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT	0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD	0x001D

/*
 *  Second phase of creating a thread.	EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT	0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 * FEATURE: need more doc here, describing the interface
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN	DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2	    0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2	    0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2	0x0029
#define VM_SUSPEND2	0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2	0x002C
#define DEVICE_REBOOT_NOTIFY2	0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER	0x0030

#define KERNEL32_INITIALIZED	0x0031

#define KERNEL32_SHUTDOWN	0x0032

#define CREATE_PROCESS		0x0033
#define DESTROY_PROCESS 	0x0034

#define MAX_SYSTEM_CONTROL	0x0034

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL 0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

		    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
		    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT	    0x10000000
		    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
		    /* INIT_COMPLETE is broadcast */
		    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
		    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
		    /* All initialization completed */
		    /* System running normally */
		    /* System shutdown initiated */
		    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
		    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
		    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT	    0xE0000000
		    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
		    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
		    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
		    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
		    /* Return to real mode */
		    /* Alternate path: CAD reboot */
#define SYSSTATE_PREDEVICEREBOOT    0xFFFF0000
		    /* DEVICE_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PRECRITREBOOT	    0xFFFFF000
		    /* CRIT_REBOOT_NOTIFY is broadcast */
#define SYSSTATE_PREREBOOTCPU	    0xFFFFFF00
		    /* REBOOT_PROCESSOR is broadcast */
		    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC		; Used outside this module (default)
;   LOCAL		; Local to this module
;   HIGH_FREQ		; DWORD align procedure
;   SERVICE		; Routine is called via VxDCall
;   ASYNC_SERVICE	    ; Same as "SERVICE" plus routine can
;		    ;	be called under interrupt.
;   HOOK_PROC		; Proc is a handler installed with
;		    ;	with a call to Hook_xxx_Fault
;		    ;	or Hook_Device_Service.  The
;		    ;	following parameter must be
;		    ;	the label of a DWORD location
;		    ;	which will hold the ptr to next
;		    ;	hook proc. e.g.
;
;		   ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG		; Disable Queue_Out call logging
;   NO_PROFILE		; Disable DynaLink profile counts
;   NO_TEST_CLD 	; Disable direction flag check
;
;   TEST_BLOCK		; Trap if in NOBLOCK state
;		    ;  (default if in pageable code seg)
;   TEST_REENTER	    ; Trap if Get_VMM_Reenter_Count != 0
;		    ;  (default for non-async services)
;   NEVER_REENTER	    ; Trap if VMM has been reentered
;   NOT_SWAPPING	    ; Trap if this thread is swapping
;
;   NO_PROLOG		; Disable all prolog tests
;
;   ESP 	    ; Use ESP instead of EBP for stack
;		    ;  frame base
;   PCALL		; pascal calling convention
;   SCALL		; stdcall calling convention
;   FASTCALL		; stdcall, but first 2 parameters are passed in ECX & EDX
;   CCALL		; "C" calling convention
;   ICALL		; default calling convention
;   W32SVC		; Win32 service
;
;   segment type	    ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type	    ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1	;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed	equ 2	    ;; ArgVars were used
??_pf_Entered	equ 4	    ;; EnterProc performed
??_pf_Left  equ 8	;; LeaveProc performed
??_pf_Returned	equ    16		;; Return performed

??_pushed	=	0		;; For WIN31COMPAT
??_align    =	0	;; For WIN31COMPAT
??_ends     equ <>	;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0	    ;; local frame base
    ??_aframe = 0	    ;; argument frame base
    ??_taframe = 0	    ;; true argument frame base
    ??_initaframe = 0	    ;; initial aframe value
    ??_numargs = 0	    ;; number of argvars
    ??_numlocals = 0	    ;; number of localvars
    ??_numlocalsymbols = 0	;; number of local symbols
    ??_procflags = 0	    ;; misc. Enter/LeaveProc flags
    ??_esp = 0		;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0	    ;; number of bytes pushed
    ??_align = 0	    ;; set if proc should be dword aligned
    ??_hook = 0 	;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG	    ;; logging on by default
    ??_profile = DFS_PROFILE	;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD	;; test that direction is clear
ELSE
    ??_log = 0		;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE	;; service profiling on by default
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
ELSE
    ??_profile = 0	    ;; service profiling off
ENDIF
    ??_test_cld = 0	    ;; test that direction is clear
ENDIF
    ??_might_block = 0	    ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0	;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0	;; use a prolog by default
    ??_public = 1	    ;; everything's public by default
    ??_cleanoff = 0	    ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_fastcall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0		;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
	if ??_hookarg
	??_hookarg = 0
	??_hookvar equ <arg>
	elseifdef ?&&arg&&_BeginProc
	    ?&&arg&&_BeginProc
	elseifdef VxD_&&arg&&_CODE_SEG
	??_ends textequ <VxD_&&arg&&_CODE_ENDS>
	VxD_&&arg&&_CODE_SEG
	else
	.err <Bad param "&arg" to BeginProc>
	endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
    ife ??_service
	ifndef profileall
	  ??_profile = 0      ;; only services can be profiled
	endif
	ifdef VMMSYS
	??_prolog_disabled = 1
	endif
    else
	??_test_cld = DFS_TEST_CLD
    endif	; ife ??_service

    ife ?_16ICODE
	??_prolog_disabled = 1
    else
    ife ?_RCODE 	    ;; if real-mode code segment
	??_prolog_disabled = 1	;; don't do anything bad
    else		;; else protected mode code segment
	ife ?_PCODE	;; if swappable code
	??_might_block = DFS_TEST_BLOCK
	endif
	if ??_service
	ife ??_async_service
	    ??_test_reenter = DFS_TEST_REENTER
	endif
	endif
    endif	; ife ?_RCODE
    endif	; ife ?_16ICODE
    endif   ; Not_VxD

    if ??_esp
    ;; just return address on stack
    ??_basereg equ <esp+??_pushed>
    ??_initaframe = 4
    else
    ;; ret addr and EBP on stack
    ??_basereg equ <ebp>
    ??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall or ??_fastcall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
	 ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
	??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

    if ??_hook
	if ??_align
	Dword_Align
	endif
	prelabeldata:
	ifndef ??_hookvar
	.err <HOOK_PROC requires next arg to be name of dword location>
	endif
	jmp short Name
	jmp [??_hookvar]
	ifdef DEBUG
	Profile_Data dd  0
	endif
	if ??_align
	.errnz ($ - prelabeldata) mod 4
	endif
    endif

    ifdef DEBUG
	?prolog_&Name label near
	if (??_service OR ??_profile) AND (??_hook EQ 0)
	jmp short Name
	if ??_align
	Dword_Align	; This also aligns the proc
	endif		;   since Profile_Data is a dd

	IF ?_ICODE
	ifdef profileall
	  ?ProfileHeader_BeginProc Profile_Data, %@filename
	else
	  Profile_Data dd 0
	endif
	ELSE
	  Profile_Data dd 0
	ENDIF

	endif
    endif

    if ??_align
	Dword_Align
    endif

    endif   ; Not_VxD

    Name proc near	;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;	     Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall or ??_fastcall    ;; if no munging
	if ??_public
	    public Name
	else
	    ifdef DEBUG
		% ?merge @FileName,$,Name,:
		% ?merge public,,,,,@FileName,$,Name
	    endif
	endif
    endif
    if ??_ccall
	if ??_public
	    _&Name equ Name
	ifdef Not_VxD
	 public C Name
	else
		 public _&Name
	endif
	endif
    endif
    if ??_pcall
	if ??_public
	    ?toupper Name
	    ?merge  public,,,,%?upper
	endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;	     DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service

    ife ??_scall or ??_fastcall
    ?_BeginProc_Debug_Prologue
    endif

    ;; Phase 7:  Post-label code
    ;;	     <none>
endm

?_BeginProc_Debug_Prologue MACRO
    ifndef Not_VxD
    ifdef DEBUG
	if ??_dfs EQ DFS_LOG
	VMMCall Log_Proc_Call	;; no test, just log
	else
	if ??_dfs EQ DFS_TEST_REENTER
	VMMCall Test_Reenter	;; no log, just reenter
	else
	if ??_dfs or ?_LOCKABLECODE eq 0
	ifdef WIN31COMPAT
	    if ??_dfs AND DFS_LOG
	    VMMCall Log_Proc_Call
	    endif
	    if ??_dfs AND DFS_TEST_REENTER
	    VMMCall Test_Reenter
	    endif
	else
	    ife ?_LOCKABLECODE
	    ifdef ??_debug_flags
	    push    ??_debug_flags
	    if ??_dfs
	    pushfd
	    or	dword ptr [esp+4],??_dfs
	    popfd
	    endif
	    VMMCall _Debug_Flags_Service
	    elseif ??_dfs
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	    else
	    push    ??_dfs
	    VMMCall _Debug_Flags_Service
	    endif
	endif
	else
	  ifdef profileall
	IncProfileCount
	  endif
	endif		;if ??_dfs
	endif		; if ??_dfs EQ DFS_TEST_REENTER
	endif		; if ??_dfs EQ DFS_LOG
    endif ; DEBUG
    endif ; Not_VxD
ENDM

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
    .erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
    .erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?FASTCALL_BeginProc macro
    ??_fastcall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
	inc dword ptr [??_name-4]
    else
	ifndef profileall
	.err <IncProfileCount can be used only in services.>
	endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***	ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;	 to indicate that the argument will not be used
;	 by the procedure.
;

ArgVar	macro	name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
	?mkarg	<name>, <length>, <used>, %??_numargs
    else
	?arg <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg	macro	name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
	?argvar <name>, <length>, <used>
	&endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro	name,length,used
    local   a
    a = ??_taframe
    ??_aframe =  ??_aframe + 4
    ??_taframe =  ??_taframe + 4
    ifidni  <length>,<BYTE>
	?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
	?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
	?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
	?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
	?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
	?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
	??_aframe =  ??_aframe - 4 + ((length + 3)/4)*4
	??_taframe =  ??_taframe - 4 + ((length + 3)/4)*4
	?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

?arg macro   name,length,used
  if ??_fastcall
    if ??_numargs le 2
      if length gt 4
	.err <First 2 parameters are dwords (ecx,edx) for fastcall functions>
      endif
      ??_aframe =  ??_aframe + 4
      if ??_numargs eq 1
	?merge ecx_,name,,,equ,ecx
      else
	?merge edx_,name,,,equ,edx
      endif
    else
      ?argvar name, length, used
    endif
  else
    ?argvar name, length, used
  endif
endm

;***	?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
	name equ _inaccessible_NOTUSED_
    else
	name equ value
	??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***	LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;	 of the argument.  The symbols BYTE, WORD, and DWORD
;	 are synonyms for 1, 2, and 4 respectively.
;	 NB!  All arguments sizes are rounded up to the nearest
;	 multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;	 to suppress the usual padding and aligning of variables
;	 PACK is typically used when declaring a bunch of
;	 byte or word variables.  Make sure that the total
;	 size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
	??_pad = 0
    endif
    ifidni  <length>,<BYTE>
	??_frame = ??_frame + 1 + 3 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
	??_frame =  ??_frame + 2 + 2 * ??_pad
	a = ??_frame
	?deflocal <name>
	name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
	??_frame = ??_frame + 4
	a = ??_frame
	?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
	name equ dword ptr [??_basereg-a]
	name&l equ word ptr [??_basereg-a]
	name&ll equ byte ptr [??_basereg-a]
	name&lh equ byte ptr [??_basereg-a+1]
	name&h equ word ptr [??_basereg-a+2]
	name&hl equ byte ptr [??_basereg-a+2]
	name&hh equ byte ptr [??_basereg-a+3]
    else
	??_frame =  ??_frame + ((length + 3)/4)*4
	a = ??_frame
	?deflocal <name>
	name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
	??_numlocalsymbols = ??_numlocalsymbols + 1
	?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
	name	equ <__inaccessible__NOTINSCOPE__>
	&endm
    endm
    .xcref  ?dodeflocal

;***	EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	_,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,_,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_fastcall
	if ??_public
	ifdef Not_VxD
		?merge	%??_name,@,%(??_aframe),,label,near
		?merge	public,,,,C,%??_name,@,%(??_aframe)
	else
		?merge	@,%??_name,@,%(??_aframe),label,near
		?merge	public,,,,,@,%??_name,@,%(??_aframe)
	endif
	endif
	?_BeginProc_Debug_Prologue
    endif
    if ??_pcall
	??_aframe = 0
	?count = ??_numargs
	rept	??_numargs
	    ?invprg <?MKA>,%?count
	    ?count = ?count - 1
	endm
    endif
    ??_fleave = FALSE
    if ??_esp
	if  ??_frame
	    sub esp, ??_frame
	    ??_pushed = ??_pushed + ??_frame
	    ??_fleave = VMM_TRUE
	endif
    else
	if  ??_frame eq 0
	    if (??_taframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
		ifdef DEBUG
		    push    ebp
		    mov ebp,esp
		    ??_fleave = VMM_TRUE
		endif
	    else
		push	ebp
		mov ebp,esp
		??_fleave = VMM_TRUE
	    endif
	else
	    enter   ??_frame, 0
	    ??_fleave = VMM_TRUE
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***	LeaveProc - removes stack frame on exit
;
;   NOTE:   If there are localvar and ESP kind of stack frame
;	LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;	flag is given.	PRESERVE_FLAGS generates bigger, slower
;	code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;	 the internal stack depth for the local frame.	This is
;	 to allow jumping around the LeaveProc/Return to code
;	 after the LeaveProc/Return to use args/local variables,
;	 but code that uses the stack frame executed after the
;	 LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
	if ??_esp
	    ifidni <flags>,<PRESERVE_FLAGS>
		lea esp,[esp + ??_frame]
	    else
		add esp,??_frame
	    endif
	else
	    leave
	endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***	Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return	macro
    if	??_cleanoff OR ??_w32svc
	if  ??_w32svc AND (??_taframe LT 8)
	    ret 8
	else
	    ret ??_taframe
	endif
    else
	ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***	EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp		;; Masm will provide error msg for us
if ??_w32svc
    if ??_taframe lt 8
	cparm&Name equ 0
    else
	cparm&Name equ (??_taframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi	<Flag>,<NOCHECK>
    if ??_pushed ne 0
	%out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
	ife ??_procflags AND ??_pf_Entered
	    %out Warning: ArgVar/LocalVar without EnterProc in Name
	endif
	ife ??_procflags AND ??_pf_Left
	    %out Warning: ArgVar/LocalVar without LeaveProc in Name
	endif
	ife ??_procflags AND ??_pf_Returned
	    %out Warning: ArgVar/LocalVar without Return in Name
	endif
    endif
endif
ifdifi	<Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
	?count = ?count + 1
	?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***	cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall	macro	name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    ifdef ??_nonstandardccall_&name
    PushCParams <arglst>, <FAST>
    else
    PushCParams <arglst>, <flags>
    endif
    call    name
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    endm
    .xcref  cCall

;***	pCall - pascal call
;
;   Arguments pushed in pascal order, callee cleans stack
;

pCall	macro	name, arglst
    local   ??saved
    ife .TYPE name
	?toupper name
    else
	?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
	push	x
	??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***	sCall - standard call
;
;   Arguments pushed in "C" order, callee cleans stack,
;   @argc appended to name
;

sCall	macro	name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  _, name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***	fCall - fastcall call
;
;   Arguments pushed in "C" order (except first two parms,
;   which are passed in ECX and EDX), callee cleans stack, and
;   @argc appended to name.
;
;   The only useful value for flags is PRESERVE_FLAGS,
;   which can also be achieved by simply declaring the function
;   as non-standard, like so:
;
;	DeclareNonstandardCcallService <functionname>
;

fCall	macro	name, arglst, flags
    local   ??saved
    ??saved = ??_pushed
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <FASTCALL>
    ?scall  @, name, %(??_argc * 4)
    ifdef ??_nonstandardccall_&name
    ClearCParams PRESERVE_FLAGS
    else
    ClearCParams <flags>
    endif
    ??_pushed = ??saved
    endm
    .xcref  fCall

;***	iCall - internal routine call
;
;   Set to whatever type we want to use as a default.

iCall	equ <sCall>

;***	PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;	the word FAST if we should prefer speed over size
;
;	The default flag is SMALL, unless the current procedure
;	is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF	STANDARD_CCALL
NONSTANDARD_CCALL = 1		;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    LOCAL ??_pushedargs

    ??_argc = 0 	;; number of dwords on stack (global)
IFDEF	NONSTANDARD_CCALL
    ??_popargs = 0		;; establish default
ELSE
    ??_popargs = ??_align EQ 0	;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
	??_popargs = 1		;; size, not speed
    elseifidni <flags>, <FAST>
	??_popargs = 0		;; speed, not size
    elseifidni <flags>, <FASTCALL>
	??_popargs = 0		;; speed, not size
    endif

    irp x,<arglst>
	??_argc = ??_argc + 1
	ifidni <flags>, <FASTCALL>
	  if ??_argc eq 1
	    ifdifi <x>, <ecx>
	      .err <first parameter must be ECX for fastcall functions>
	    endif
	  elseif ??_argc eq 2
	    ifdifi <x>, <edx>
	      .err <first parameter must be EDX for fastcall functions>
	    endif
	  else
	    ?marg   <x>,%??_argc
	  endif
	else
	  ?marg   <x>,%??_argc
	endif
    endm
    ?count = ??_argc
    ifidni <flags>, <FASTCALL>
      ??_pushedargs = ??_argc-2
    else
      ??_pushedargs = ??_argc
    endif
    if ??_pushedargs GT 0
      rept    ??_argc
	?invprg <?AM>,%?count
	?count = ?count - 1
      endm
    endif
    endm

;***	ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;   If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;   This will generate bigger, slower code, so use it only when
;   necessary.

ClearCParams macro fPreserveFlags
    if	??_argc ne 0
	if (??_popargs) AND (??_argc LE 2)
	  rept ??_argc
	  pop ecx
	  endm
	elseifidni <fPreserveFlags>, <PRESERVE_FLAGS>
	  lea esp, [esp][??_argc * 4]
	else
	  add esp,??_argc * 4
	endif
    endif
    ??_pushed = ??_pushed - (??_argc * 4)
    endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg	macro	name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
	push	name
	??_pushed = ??_pushed + 4
	&endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro	name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall	macro	prefix, name1, name2
    CondExtern prefix&name1&@&name2, near
    call    prefix&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge	macro	l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
	if '&x' GE 'a'
	  if '&x' LE 'z'
	?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
	?upper catstr ?upper,?t1
	  else
	?upper catstr ?upper,<&x>
	  endif
	else
	  ?upper catstr ?upper,<&x>
	endif
      endm
    endm
    .xcref

;***	CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
	ifndef name
	externdef name:dist
	endif
    else
	if2
	ifndef name
	    extrn name:dist
	endif
	endif
    endif
endm

;***	SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro	reglist 	;; push those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    pushfd
	    ??_pushed = ??_pushed + 4
	else
	ifidni <reg>, <ad>
	    pushad
	    ??_pushed = ??_pushed + SIZE Pushad_Struc
	else
	    push    reg
	    ??_pushed = ??_pushed + 4
	endif
	endif
    endm
endm

;***	RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist	;; pop those registers
    irp reg,<reglist>
	ifidni <reg>, <fd>
	    popfd
	    ??_pushed = ??_pushed - 4
	else
	ifidni <reg>, <ad>
	    popad
	    ??_pushed = ??_pushed - SIZE Pushad_Struc
	else
	    pop reg
	    ??_pushed = ??_pushed - 4
	endif
	endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.	Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db	'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd	OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd	0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *	   S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST	0x00000010
#define HIGH_PRI_DEVICE_BOOST	0x00001000
#define CRITICAL_SECTION_BOOST	0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S	 F O R	 C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT	    0
#define PEF_WAIT_FOR_STI	(1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT	    1
#define PEF_WAIT_NOT_CRIT	(1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT	    2
#define PEF_DONT_UNBOOST	(1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT	    3
#define PEF_ALWAYS_SCHED	(1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT	4
#define PEF_TIME_OUT		(1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT	(1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT	6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT	7
#define PEF_WAIT_IN_PM		(1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT	    8
#define PEF_THREAD_EVENT	(1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT	    10
#define PEF_RING0_EVENT 	(1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	11
#define PEF_WAIT_CRIT	    (1 << PEF_WAIT_CRIT_BIT)

#define PEF_WAIT_CRIT_VM_BIT	    12
#define PEF_WAIT_CRIT_VM    (1 << PEF_WAIT_CRIT_VM_BIT)

#define PEF_PROCESS_LAST_BIT	    13
#define PEF_PROCESS_LAST    (1 << PEF_PROCESS_LAST_BIT)

#define PEF_WAIT_PREEMPTABLE_BIT    14
#define PEF_WAIT_PREEMPTABLE (1 << PEF_WAIT_PREEMPTABLE_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT	     PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK	 PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *	 F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *			     E N T E R _ M U T E X
 *	       A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT	0
#define BLOCK_SVC_INTS		(1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT	1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT	    2
#define BLOCK_ENABLE_INTS	(1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT		3
#define BLOCK_POLL	    (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT		4
#define BLOCK_THREAD_IDLE		(1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT	5
#define BLOCK_FORCE_SVC_INTS	    (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;		/* Client's EDI */
    ULONG Client_ESI;		/* Client's ESI */
    ULONG Client_EBP;		/* Client's EBP */
    ULONG Client_res0;		/* ESP at pushall */
    ULONG Client_EBX;		/* Client's EBX */
    ULONG Client_EDX;		/* Client's EDX */
    ULONG Client_ECX;		/* Client's ECX */
    ULONG Client_EAX;		/* Client's EAX */
    ULONG Client_Error; 	/* Dword error code */
    ULONG Client_EIP;		/* EIP */
    USHORT Client_CS;		/* CS */
    USHORT Client_res1; 	/*   (padding) */
    ULONG Client_EFlags;	/* EFLAGS */
    ULONG Client_ESP;		/* ESP */
    USHORT Client_SS;		/* SS */
    USHORT Client_res2; 	/*   (padding) */
    USHORT Client_ES;		/* ES */
    USHORT Client_res3; 	/*   (padding) */
    USHORT Client_DS;		/* DS */
    USHORT Client_res4; 	/*   (padding) */
    USHORT Client_FS;		/* FS */
    USHORT Client_res5; 	/*   (padding) */
    USHORT Client_GS;		/* GS */
    USHORT Client_res6; 	/*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;		/* Client's DI */
    USHORT Client_res13;	/*   (padding) */
    USHORT Client_SI;		/* Client's SI */
    USHORT Client_res14;	/*   (padding) */
    USHORT Client_BP;		/* Client's BP */
    USHORT Client_res15;	/*   (padding) */
    ULONG Client_res16; 	/* ESP at pushall */
    USHORT Client_BX;		/* Client's BX */
    USHORT Client_res17;	/*   (padding) */
    USHORT Client_DX;		/* Client's DX */
    USHORT Client_res18;	/*   (padding) */
    USHORT Client_CX;		/* Client's CX */
    USHORT Client_res19;	/*   (padding) */
    USHORT Client_AX;		/* Client's AX */
    USHORT Client_res20;	/*   (padding) */
    ULONG Client_res21; 	/* Dword error code */
    USHORT Client_IP;		/* Client's IP */
    USHORT Client_res22;	/*   (padding) */
    ULONG Client_res23; 	/* CS */
    USHORT Client_Flags;	/* Client's flags (low) */
    USHORT Client_res24;	/*   (padding) */
    USHORT Client_SP;		/* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];	/* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;		/* Client's BL */
    UCHAR Client_BH;		/* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;		/* Client's DL */
    UCHAR Client_DH;		/* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;		/* Client's CL */
    UCHAR Client_CH;		/* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;		/* Client's AL */
    UCHAR Client_AH;		/* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc	  CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0	/* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT	0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;   Declare services as conforming to the C calling convention
;   for parameter-passing, but *not* conforming to the C calling
;   convention for register usage.
;
;   Services which do not use the C calling convention for
;   parameter-passing need not be declared as nonstandard.
;
;   arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
    irp x,<arglst>
	??_nonstandardccall_&&x = 1
    endm
endm

;
; The following VMM services are nonstandard:
;	_BlockOnID and _LocalizeSprintf modify no registers except flags.
;	_SetLastV86Page modifies no registers except EAX and flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints	; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd	OFFSET32 vt[sn+jf]
ENDM

GenDD	MACRO	P, vid, snum, jflag
    LOCAL   vtable
IFDEF	@@VxDName&vid
    Deftable	vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd	@@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)

    ifdef ??_standardccall_&P
      PushCParams <Param>, <FAST>
      .errnz ??_argc ne ??_standardccall_&P, <wrong # of parameters passed to &P&>
    else
      ifdef ??_fastcall_&P
	PushCParams <Param>, <FASTCALL>
	.errnz ??_argc ne (??_fastcall_&P), <wrong # of parameters passed to fastcall function &P&>
      else
	ifdef ??_nonstandardccall_&P
	  PushCParams <Param>, <flags>
	else
	  PushCParams <Param>, <FAST>
	endif
      endif
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifndef ??_standardccall_&P
      ifndef ??_fastcall_&P
	ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
	else
	ClearCParams
	endif
      else
	if(??_argc gt 2)
	    ??_pushed = ??_pushed - ((??_argc - 2) * 4)
	endif
      endif
    else
      ??_pushed = ??_pushed - (??_argc * 4)
    endif
    ENDM

VxDJmp	MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_fastcall_&P
      PushCParams <Param>, <FASTCALL>
      .errnz ??_argc gt 2, <More than 2 parameters may not be passed to fastcall functions thru VxDJmp>
    else
      .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG	 defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG	 defines start of always present code segment
;VxD_CODE_ENDS	 defines end of always present code segment
;VxD_DATA_SEG	 defines start of always present data segment
;VxD_DATA_ENDS	 defines end of always present data segment
;VxD_LOCKED_CODE_SEG	defines start of always present code segment
;VxD_LOCKED_CODE_ENDS	defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG	defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG	EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS	EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT	 ENDS
	ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT	 ENDS
	ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
	ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
	ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT	SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT	ENDS
	ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG	EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS	EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA	 ENDS
	ENDM


;   Protected mode initialization data

VxD_IDATA_SEG	MACRO
_IDATA	SEGMENT
	ENDM
VxD_IDATA_ENDS	MACRO
_IDATA	ENDS
	ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA	 ENDS
	ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT	 SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

	ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT	 ENDS
	ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA	 SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA	 ENDS
	ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
	ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
	ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
	  ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
	   ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
	  ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
	   ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A	    /* 3.10 */
#else  // WIN31COMPAT

#ifdef WIN40COMPAT
#define DDK_VERSION 0x400	    /* 4.00 */
#else  // WIN40COMPAT

#ifdef OPK3
#define DDK_VERSION 0x403	    /* 4.03 */
#else  // OPK3
#define DDK_VERSION 0x40A	    /*Memphis is 4.1 */
#endif // OPK3

#endif // WIN40COMPAT

#endif // WIN31COMPAT

#endif // DDK_VERSION

struct VxD_Desc_Block {
    ULONG DDB_Next;	    /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;	/* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;		/* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];		/* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;	/* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;	/* Offset of control procedure */
    ULONG DDB_V86_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;	/* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;	/* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;	    /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;	    /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Size;	/* INIT <SIZE(VxD_Desc_Block)> Reserved */
    ULONG DDB_Reserved1;	/* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;	/* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;	/* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block	    *PVMMDDB;
typedef PVMMDDB 	    *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE	    (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE	    (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT	    14
#define DDB_HAS_WIN32_SVCS	(1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT	15
#define DDB_DYNAMIC_VXD 	(1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED	    (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB	<Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
	Ref_Data_Offset EQU 0
ELSE
	Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db	0dh, 0ah, 'D_E_B_U_G===>'
	db	"&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
	     OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
	     ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,	 MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd	OFFSET32 ??_cd_&&num
ELSE
    dd	OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc 	    ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz	Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT	0x014

#define OUTPUT_BIT  2
#define OUTPUT	    (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT	4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT	5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO	    (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT	7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT	8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT	0x10		/* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je	Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb	In_Proc
ELSE
    je	Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw	Table_Name&_Entries
ELSE
    dw	?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw	Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6	; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw	Port
    dd	OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
	ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;	   If compiled with debugging then this will generate a call
;	   followed by a return.  If non-debugging version then the
;	   specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF	DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint	MACRO	Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if	(OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
	VMMCall _ExecVxDIntMustComplete
    ENDM

Load_FS 	macro
	VMMCall Load_FS_Service
endm
*/

/*XLATOFF*/
#define Load_FS VMMCall(Load_FS_Service)
/*XLATON*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0	/* loaded */
#define DUPLICATE_DEVICE_ID	(1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1	/* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F	    (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT	    2	/* in the INT 2F device list */
#define LOADING_FROM_INT2F	(1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK	    0	/* load protected mode portion */
#define ABORT_DEVICE_LOAD   1	/* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2	/* fatal-error: abort load of Win386 */
#define DEVICE_NOT_NEEDED   3	/* don't load protected mode portion */
				/* b/c the driver's presence is not needed */



#define NO_FAIL_MESSAGE_BIT 15	/* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0	/* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING	1   /* search for next string */
#define LDRSRV_RESERVED 	2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3	/* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT	4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5	/* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6	/* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO	    7	/* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey	0x100
#define LDRSRV_RegCreateKey	0x101
#define LDRSRV_RegCloseKey	0x102
#define LDRSRV_RegDeleteKey	0x103
#define LDRSRV_RegSetValue	0x104
#define LDRSRV_RegQueryValue	    0x105
#define LDRSRV_RegEnumKey	0x106
#define LDRSRV_RegDeleteValue	    0x107
#define LDRSRV_RegEnumValue	0x108
#define LDRSRV_RegQueryValueEx	    0x109
#define LDRSRV_RegSetValueEx	    0x10A
#define LDRSRV_RegFlushKey	0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT	1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED	2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE	    3	/* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*	    Also Init type objects should be added to the second part of the
*	    list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ	-1

#define LCODE_OBJ	0x01
#define LDATA_OBJ	0x02
#define PCODE_OBJ	0x03
#define PDATA_OBJ	0x04
#define SCODE_OBJ	0x05
#define SDATA_OBJ	0x06
#define CODE16_OBJ	0x07
#define LMSG_OBJ	0x08
#define PMSG_OBJ	0x09

#define DBOC_OBJ    0x0B
#define DBOD_OBJ    0x0C

#define PLCODE_OBJ	0x0D
#define PPCODE_OBJ	0x0F

#define ICODE_OBJ	0x11
#define IDATA_OBJ	0x12
#define ICODE16_OBJ	0x13
#define IMSG_OBJ	0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  25

/*****************************************************************************
 *
 *	Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT	    0	/* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT	    1	/* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT	    2	/* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT	    3	/* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT	    4	/* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT	    31	/* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT	    0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT	    2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT	    4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT	    6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT	    7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT	    8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT	    9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT	    10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT	    11	/* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT	    14	/* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT	    16	/* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT	    17	/* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT	    18	/* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19	/* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20	/* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *		PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE	    0x1000	/* page size */

/******************************************************************************
 *
 *		PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES	    (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER	    (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC	    (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM	    0
#define PG_SYS	    1
#define PG_RESERVED1	2
#define PG_PRIVATE  3
#define PG_RESERVED2	4
#define PG_RELOCK   5	    /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES	    0x080	/* present in memory */
#define D_NOTPRES   0	    /* not present in memory */

#define D_DPL0	    0	    /* Ring 0 */
#define D_DPL1	    0x020	/* Ring 1 */
#define D_DPL2	    0x040	/* Ring 2 */
#define D_DPL3	    0x060	/* Ring 3 */

#define D_SEG	    0x010	/* Segment descriptor */
#define D_CTRL	    0	    /* Control descriptor */

#define D_GRAN_BYTE 0x000	/* Segment length is byte granular */
#define D_GRAN_PAGE 0x080	/* Segment length is page granular */
#define D_DEF16     0x000	/* Default operation size is 16 bits */
#define D_DEF32     0x040	/* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE	    0x08	/* code */
#define D_DATA	    0	    /* data */

#define D_X	0	/* if code, exec only */
#define D_RX	    0x02	/* if code, readable */
#define D_C	0x04	    /* if code, conforming */

#define D_R	0	/* if data, read only */
#define D_W	0x02	    /* if data, writable */
#define D_ED	    0x04	/* if data, expand down */

#define D_ACCESSED  1	    /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE	(D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK	0xFFF8	    /* selector index */
#define SEL_LOW_MASK	0xF8	    /* mask for low byte of sel indx */
#define TABLE_MASK  0x04	/* table bit */
#define RPL_MASK    0x03	/* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()	{__asm cli}

#define SAVE_FLAGS(flags) {\
    {__asm pushfd}; \
    {__asm pop flags}}

#define RESTORE_FLAGS(flags) {\
    {__asm push flags}; \
    {__asm popfd}}

#define IO_Delay() {\
    {__asm _emit 0xeb}; \
    {__asm _emit 0x00}}

#define Touch_Register(Register) {_asm xor Register, Register}

typedef DWORD	HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)	// turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;	// count of milliseconds

#pragma warning (default:4209)	// turn on redefine warning (with basedef.h)

typedef DWORD	VMM_SEMAPHORE;


#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\vpowerd.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       VPOWERD.H
*
*  VERSION:     1.0
*
*  DATE:        01 Oct 1993
*
*  AUTHOR:      TCS
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  01 Oct 1993 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_VPOWERD
#define _INC_VPOWERD

#ifndef Not_VxD

//
//  Virtual Power Management Device service table.
//

/*XLATOFF*/
#define VPOWERD_Service                 Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VPOWERD, VxD)

    VPOWERD_Service     (_VPOWERD_Get_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_APM_BIOS_Version, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Power_Management_Level, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_Device_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Set_System_Power_State, VxD_LOCKED_CODE)
    VPOWERD_Service     (_VPOWERD_Restore_Power_On_Defaults, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_Status, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Get_Power_State, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_OEM_APM_Function, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Register_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_Deregister_Power_Handler, VxD_PAGEABLE_CODE)
    VPOWERD_Service     (_VPOWERD_W32_Get_System_Power_Status, VxD_PAGEABLE_CODE)	
	VPOWERD_Service     (_VPOWERD_W32_Set_System_Power_State, VxD_PAGEABLE_CODE)
	// APM 1.2 services
	VPOWERD_Service     (_VPOWERD_Get_Capabilities, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Enable_Resume_On_Ring, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Resume_On_Ring, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Set_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Get_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Resume_Timer, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Enable_Timer_Based_Requests, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_Disable_Timer_Based_Requests, VxD_PAGEABLE_CODE)
	VPOWERD_Service     (_VPOWERD_W32_Get_Power_Status, VxD_PAGEABLE_CODE)
	VPOWERD_Service		(_VPOWERD_Get_Timer_Based_Requests_Status, VxD_PAGEABLE_CODE)
	VPOWERD_Service		(_VPOWERD_Get_Ring_Resume_Status, VxD_PAGEABLE_CODE)

End_Service_Table(VPOWERD, VxD)
/*ENDMACROS*/


#endif

/*XLATOFF*/

#ifdef IS_32
#define POWERFAR
#else
#define POWERFAR                        _far
#endif

/*XLATON*/

//
//  Standard return type from VPOWERD services and handlers.
//
//  Error codes 0x00000001 through 0x000000FF are reserved for APM firmware
//  errors.
//
//  Error codes above 0x80000000 are reserved for definition by VPOWERD
//

typedef DWORD                           POWERRET;

#define PR_SUCCESS                      0x00000000

#define PR_PM_DISABLED                  0x00000001
#define PR_RM_CONNECT_EXISTS            0x00000002
#define PR_INTERFACE_NOT_CONNECTED      0x00000003
#define PR_16BIT_PM_CONNECT_EXISTS      0x00000005
#define PR_16BIT_PM_UNSUPPORTED         0x00000006
#define PR_32BIT_PM_CONNECT_EXISTS      0x00000007
#define PR_32BIT_PM_UNSUPPORTED         0x00000008
#define PR_UNRECOGNIZED_DEVICE_ID       0x00000009
#define PR_PARAMETER_OUT_OF_RANGE       0x0000000A
#define PR_INTERFACE_NOT_ENGAGED        0x0000000B
// 	APM 1.2 error codes
#define PR_FUNC_NOT_SUPPORTED			0x0000000C
#define PR_RESUME_TIMER_DISABLED		0x0000000D
//	end
#define PR_CANNOT_ENTER_STATE           0x00000060
#define PR_NO_PM_EVENTS_PENDING         0x00000080
#define PR_APM_NOT_PRESENT              0x00000086
#define PR_UNDEFINED_FUNCTION           0x000000FF

#define PR_DEFAULT                      0x80000000
#define PR_FAILURE                      0x80000001
#define PR_REQUEST_VETOED               0x80000002
#define PR_INVALID_POINTER              0x80000003
#define PR_INVALID_FLAG                 0x80000004
#define PR_INVALID_PMLEVEL              0x80000005
#define PR_INVALID_DEVICE_ID            0x80000006
#define PR_INVALID_POWER_STATE          0x80000007
#define PR_INVALID_REQUEST_TYPE         0x80000008
#define PR_OUT_OF_MEMORY                0x80000009
#define PR_DUPLICATE_POWER_HANDLER      0x8000000A
#define PR_POWER_HANDLER_NOT_FOUND      0x8000000B
#define PR_INVALID_FUNCTION             0x8000000C

//
//  Power device ID type and standard IDs as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_DEVICE_ID;

#define PDI_APM_BIOS                    0x0000
#define PDI_MANAGED_BY_APM_BIOS         0x0001
#define PDI_MANAGED_BY_APM_BIOS_OLD     0xFFFF
// 	APM 1.2
#define PDI_SPECIFIC_BATTERY			0x8000	// OR in the 1 based battery unit number
//	end

//
//  Power state type and standard power states as defined by the APM 1.1
//  specification.
//

typedef DWORD                           POWER_STATE;
typedef POWER_STATE POWERFAR*           LPPOWER_STATE;

#define PSTATE_APM_ENABLED              0x0000
#define PSTATE_STANDBY                  0x0001
#define PSTATE_SUSPEND                  0x0002
#define PSTATE_OFF                      0x0003
//	APM 1.2
#define PSTATE_HIBERNATE				0x0006
//  end

//
//  Valid power management levels.
//

#define PMLEVEL_ADVANCED                0
#define PMLEVEL_STANDARD                1
#define PMLEVEL_OFF                     2
#define PMLEVEL_MAXIMUM                 PMLEVEL_OFF

//
//  Valid request types.
//

#define REQTYPE_USER_INITIATED          0x00000000
#define REQTYPE_TIMER_INITIATED         0x00000001
#define REQTYPE_FORCED_REQUEST          0x00000002
#define REQTYPE_BIOS_CRITICAL_SUSPEND   0x00000003
#define REQTYPE_FROM_BIOS_FLAG          0x80000000                  // ;Internal

// valid values for Status returned by Get_Timer_Based_Requests_Status and Get_Ring_Resume_Status
#define CAPABILITY_ENABLED	0x00000001
#define CAPABILITY_DISABLED	0x00000000

//
//  Power status structures returned by _VPOWERD_Get_Power_Status and
//  _VPOWERD_W32_Get_Power_Status.
//

#ifndef NOPOWERSTATUSDEFINES

#define AC_LINE_OFFLINE                 0x00
#define AC_LINE_ONLINE                  0x01
#define AC_LINE_BACKUP_POWER            0x02
#define AC_LINE_UNKNOWN                 0xFF

#define BATTERY_STATUS_HIGH             0x00
#define BATTERY_STATUS_LOW              0x01
#define BATTERY_STATUS_CRITICAL         0x02
#define BATTERY_STATUS_CHARGING         0x03
#define BATTERY_STATUS_UNKNOWN          0xFF

#define BATTERY_FLAG_HIGH               0x01
#define BATTERY_FLAG_LOW                0x02
#define BATTERY_FLAG_CRITICAL           0x04
#define BATTERY_FLAG_CHARGING           0x08
//	APM 1.2 
#define BATTERY_NOT_PRESENT				0x10
//	end
#define BATTERY_FLAG_NO_BATTERY         0x80
#define BATTERY_FLAG_UNKNOWN            0xFF

#define BATTERY_PERCENTAGE_UNKNOWN      0xFF

#define BATTERY_LIFE_MINUTES_MASK       0x8000
#define BATTERY_LIFE_UNKNOWN            0xFFFF

#define BATTERY_LIFE_W32_UNKNOWN        0xFFFFFFFF

#endif  // NOPOWERSTATUSDEFINES

typedef struct _POWER_STATUS {
    BYTE PS_AC_Line_Status;
    BYTE PS_Battery_Status;
    BYTE PS_Battery_Flag;
    BYTE PS_Battery_Life_Percentage;
    WORD PS_Battery_Life_Time;	
}   POWER_STATUS;

typedef POWER_STATUS POWERFAR* LPPOWER_STATUS;

typedef struct _POWERTIME {  // st  
    WORD Year;
    WORD Month;
    WORD DayOfWeek;
    WORD Day;
    WORD Hour;
    WORD Minute;
    WORD Second;
    WORD Milliseconds;
} POWERTIME;

typedef POWERTIME POWERFAR* LPPOWERTIME;

typedef struct APM_CAPABILITIES_S	{
		WORD Capabilities;
		BYTE BatteryCount;
		BYTE Reserved;
}APM_CAPABILITIES, *PAPM_CAPABILITIES;

/*
Capability flags
Bit 0 = 1  System can enter global standby state. Indicates BIOS will post standby and standby-resume events.
Bit 1 = 1  System can enter global suspend state. Indicates BIOS will post suspend and suspend-resume events.
Bit 2 = 1  Resume timer will wake up from standby.
Bit 3 = 1  Resume timer will wake up from suspend.
Bit 4 = 1  Resume on ring indicator (internal COM or modem) will wake up from standby.
Bit 5 = 1  Resume on ring indicator (internal COM or modem) will wake up from suspend.
Bit 6 = 1  PCMCIA Ring indicator will wake up from standby.
Bit 7 = 1  PCMCIA Ring indicator will wake up from suspend.
Other bits  Reserved (must be set to 0)
*/

#define GLOBAL_STANDBY_SUPPORTED_BIT		0
#define GLOBAL_STANDBY_SUPPORTED			(1 << GLOBAL_STANDBY_SUPPORTED_BIT)

#define GLOBAL_SUSPEND_SUPPORTED_BIT  		1
#define GLOBAL_SUSPEND_SUPPORTED			(1 << GLOBAL_SUSPEND_SUPPORTED_BIT)

#define WAKE_ON_TIMER_STANDBY_BIT			2
#define WAKE_ON_TIMER_STANDBY				(1 << WAKE_ON_TIMER_STANDBY_BIT)
		
#define WAKE_ON_TIMER_SUSPEND_BIT			3
#define WAKE_ON_TIMER_SUSPEND				(1 << WAKE_ON_TIMER_SUSPEND_BIT)

#define RING_RESUME_INTERNAL_STANDBY_BIT	4
#define RING_RESUME_INTERNAL_STANDBY		(1 << RING_RESUME_INTERNAL_STANDBY_BIT)

#define RING_RESUME_INTERNAL_SUSPEND_BIT	5
#define RING_RESUME_INTERNAL_SUSPEND		(1 << RING_RESUME_INTERNAL_SUSPEND_BIT)

#define RING_RESUME_PCMCIA_STANDBY_BIT		6
#define RING_RESUME_PCMCIA_STANDBY			(1 << RING_RESUME_PCMCIA_STANDBY_BIT)

#define RING_RESUME_PCMCIA_SUSPEND_BIT		7
#define RING_RESUME_PCMCIA_SUSPEND			(1 << RING_RESUME_PCMCIA_SUSPEND_BIT)


typedef struct _WIN32_SYSTEM_POWER_STATUS {
    BYTE W32PS_AC_Line_Status;
    BYTE W32PS_Battery_Flag;
    BYTE W32PS_Battery_Life_Percent;
    BYTE W32PS_Reserved1;
    DWORD W32PS_Battery_Life_Time;
    DWORD W32PS_Battery_Full_Life_Time;
}   WIN32_SYSTEM_POWER_STATUS;

typedef WIN32_SYSTEM_POWER_STATUS POWERFAR* LPWIN32_SYSTEM_POWER_STATUS;

//
//  OEM APM Register Structure used by _VPOWERD_OEM_APM_Function.
//

struct _OEM_APM_BYTE_REGS {
    WORD OEMAPM_Reserved1[6];
    BYTE OEMAPM_BL;
    BYTE OEMAPM_BH;
    WORD OEMAPM_Reserved2;
    BYTE OEMAPM_DL;
    BYTE OEMAPM_DH;
    WORD OEMAPM_Reserved3;
    BYTE OEMAPM_CL;
    BYTE OEMAPM_CH;
    WORD OEMAPM_Reserved4;
    BYTE OEMAPM_AL;
    BYTE OEMAPM_AH;
    WORD OEMAPM_Reserved5;
    BYTE OEMAPM_Flags;
    BYTE OEMAPM_Reserved6[3];
};

struct _OEM_APM_WORD_REGS {
    WORD OEMAPM_DI;
    WORD OEMAPM_Reserved7;
    WORD OEMAPM_SI;
    WORD OEMAPM_Reserved8;
    WORD OEMAPM_BP;
    WORD OEMAPM_Reserved9;
    WORD OEMAPM_BX;
    WORD OEMAPM_Reserved10;
    WORD OEMAPM_DX;
    WORD OEMAPM_Reserved11;
    WORD OEMAPM_CX;
    WORD OEMAPM_Reserved12;
    WORD OEMAPM_AX;
    WORD OEMAPM_Reserved13[3];
};

struct _OEM_APM_DWORD_REGS {
    DWORD OEMAPM_EDI;
    DWORD OEMAPM_ESI;
    DWORD OEMAPM_EBP;
    DWORD OEMAPM_EBX;
    DWORD OEMAPM_EDX;
    DWORD OEMAPM_ECX;
    DWORD OEMAPM_EAX;
    DWORD OEMAPM_Reserved14;
};

typedef union _OEM_APM_REGS {
    struct _OEM_APM_BYTE_REGS ByteRegs;
    struct _OEM_APM_WORD_REGS WordRegs;
    struct _OEM_APM_DWORD_REGS DwordRegs;
}   OEM_APM_REGS;

typedef OEM_APM_REGS POWERFAR*          LPOEM_APM_REGS;

//
//  Possible power function codes that are sent to POWER_HANDLER callbacks.
//

typedef DWORD                           POWERFUNC;

#define PF_SUSPEND_PHASE1               0x00000000
#define PF_SUSPEND_PHASE2               0x00000001
#define PF_SUSPEND_INTS_OFF             0x00000002
#define PF_RESUME_INTS_OFF              0x00000003
#define PF_RESUME_PHASE2                0x00000004
#define PF_RESUME_PHASE1                0x00000005
#define PF_BATTERY_LOW                  0x00000006
#define PF_POWER_STATUS_CHANGE          0x00000007
#define PF_UPDATE_TIME                  0x00000008
#define PF_CAPABILITIES_CHANGE			0x00000009
#define PF_APMOEMEVENT_FIRST            0x00000200
#define PF_APMOEMEVENT_LAST             0x000002FF

//
//
//

#define PFG_UI_ALLOWED                  0x00000001
#define PFG_CANNOT_FAIL                 0x00000002
#define PFG_REQUEST_VETOED              0x00000004
#define PFG_REVERSE                     0x00000008
#define PFG_STANDBY                     0x00000010
#define PFG_CRITICAL                    0x00000020
#ifdef SUPPORT_HIBERNATE
#define PFG_HIBERNATE					0x00000040	// NEW for APM 1.2
#endif
#define PFG_KEPT_POWER					0x00000080

//
//  Standard POWER_HANDLER priority levels.
//

#define PHPL_PBT_BROADCAST              0x40000000
#define PHPL_UNKNOWN                    0x80000000
#define PHPL_CONFIGMG                   0xC0000000
#define PHPL_TIMER			0xE0000000

//
//
//

typedef POWERRET (*POWER_HANDLER)(POWERFUNC, DWORD);

//
//  VPOWERD BroadcastSystemMessage API parameter blocks.
//

typedef struct _VPOWERD_BSMAPI_HEADER {
    DWORD VBAPIH_Packet_Size;
    WORD VBAPIH_Function;
    DWORD VBAPIH_Return_Code;
}   VPOWERD_BSMAPI_HEADER;

#define VBAPIF_W32_SET_SYSTEM_STATE     0x000D

typedef struct _VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE {
    struct _VPOWERD_BSMAPI_HEADER VBWSSS_VBAPIH;
    DWORD VBWSSS_Force_Flag;
}   VPOWERD_BSMAPI_W32_SET_SYSTEM_STATE;

//
//  Virtual Power Management Device service prototypes.
//

/*XLATOFF*/

BOOL
POWERFAR CDECL
VPOWERD_Get_Entry_Point(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_APM_BIOS_Version(
    VOID
    );

DWORD
POWERFAR CDECL
_VPOWERD_Get_Power_Management_Level(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Power_Management_Level(
    DWORD Power_Management_Level
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Device_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    POWER_STATE Power_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Set_System_Power_State(
    POWER_STATE Power_State,
    DWORD Request_Type
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Restore_Power_On_Defaults(
    VOID
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_Status(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATUS lpPower_Status
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Power_State(
    POWER_DEVICE_ID Power_Device_ID,
    LPPOWER_STATE lpPower_State
    );

POWERRET
POWERFAR CDECL
_VPOWERD_OEM_APM_Function(
    LPOEM_APM_REGS lpOEM_APM_Regs
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Register_Power_Handler(
    POWER_HANDLER Power_Handler,
    DWORD Priority
    );

POWERRET
POWERFAR CDECL
_VPOWERD_Deregister_Power_Handler(
    POWER_HANDLER Power_Handler
    );

BOOL
POWERFAR CDECL
_VPOWERD_W32_Get_System_Power_Status(
    LPWIN32_SYSTEM_POWER_STATUS lpWin32_System_Power_Status
    );

DWORD
POWERFAR CDECL
_VPOWERD_W32_Set_System_Power_State(
    BOOL Suspend_Flag,
    BOOL Force_Flag
    );


POWERRET
POWERFAR CDECL
_VPOWERD_Get_Capabilities(
	PAPM_CAPABILITIES pAPMCaps
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Enable_Resume_On_Ring(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Resume_On_Ring(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Set_Resume_Timer(
	LPPOWERTIME pPowerTime
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Get_Resume_Timer(
	LPPOWERTIME pPowerTime
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Resume_Timer(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Enable_Timer_Based_Requests(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_Disable_Timer_Based_Requests(
	VOID
	);

POWERRET
POWERFAR CDECL
_VPOWERD_W32_Get_Power_Status(
	POWER_DEVICE_ID Power_Device_ID,
	LPWIN32_SYSTEM_POWER_STATUS lpWin32_System_Power_Status
	);

/*XLATON*/

#endif // _INC_VPOWERD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\wshioctl.h ===
/*****************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1994
 *
 *  Title:	WSHOICTL.H - IOCTL interface for Wshell
 *
 *  Version:    4.00
 *
 *  Date:       30-Nov-1988
 *
 *  Author:	RAL
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *  01-Aug-1994 RAL Original
 *
 *****************************************************************************/

#ifndef _WSHIOCTL_H
#define _WSHIOCTL_H


#define SHELLFILENAME "\\\\.\\SHELL"

//
// Flags for _SHELL_SuggestSingleMSDOSMode
//
// SSAMFLAG_KILLVM
//	A fatal application error has occurred.  Display a warning box
//	unconditionally.  Regardless of the answer, terminate the VM.
//	If this bit is set, the call does not return.
//
//  SSAMFLAG_TIMER
//	Not used.  Sorry.
//
//  SSAM_REQREALMODE
//	App requires *real* mode, not V86 mode, not EMM stuff, not
//	QEMM.  Just pure unadulterated real mode.  Also known as
//	SSAM_COMANCHE, because Comanche does an "lgdt" to enter
//	protected mode without checking if it is safe to do so.
//	This flag is inspected by AppWiz to decide how to set up
//	the config.sys and autoexec.bat.
//
//  SSAM_KILLUNLESSTOLD
//	Suggest Single MS-DOS mode (unless suppressed via PIF), and
//	if the answer is "Okay", then kill the VM.  If the user
//	says, "Keep running", then let it stay.
//
//  SSAM_FROMREGLIST
//	This app was run from a command prompt, triggered by registry
//	settings.  Just re-execute it in its own VM so that APPS.INF
//	settings will take effect.
//
//  SSAM_FAILEDAPI
//	This app just made an API call that was unsuccessful or
//	unsupported.  If the app terminates within 0.1 second,
//	then suggest single-app mode.  If the app continues
//	execution, then don't suggest.
//

#define SSAMFLAG_KILLVM 	0x0000001
#define SSAMFLAG_TIMER		0x0000002
#define SSAMFLAG_REQREALMODE	0x0000004
#define SSAMFLAG_KILLUNLESSTOLD 0x0000008
#define SSAMFLAG_FROMREGLIST	0x0000010
#define SSAMFLAG_FAILEDAPI	0x0000020

//
//  IOCTL codes
//
#define WSHIOCTL_GETVERSION	0
#define WSHIOCTL_BLUESCREEN	1
#define WSHIOCTL_GET1APPINFO	2
#define WSHIOCTL_SIGNALSEM	3
#define WSHIOCTL_MAX		4	/* Remember, _MAX = _LIMIT + 1 */

//
//  Result codes
//
#define SSR_CONTINUE	0
#define SSR_CLOSEVM	1
#define SSR_KILLAPP	2

//
//  Sizes for strings
//
#define MAXVMTITLESIZE	32
#define MAXVMPROGSIZE	64
#define MAXVMCMDSIZE	64
#define MAXVMDIRSIZE	64
#define MAXPIFPATHSIZE	260

typedef struct _SINGLEAPPSTRUC {    /* shex */

	DWORD	SSA_dwFlags;
	DWORD	SSA_VMHandle;
	DWORD	SSA_ResultPtr;
	DWORD	SSA_Semaphore;
	char	SSA_PIFPath[MAXPIFPATHSIZE];
	char	SSA_VMTitle[MAXVMTITLESIZE];
	char	SSA_ProgName[MAXVMPROGSIZE];
	char	SSA_CommandLine[MAXVMCMDSIZE];
	char	SSA_CurDir[MAXVMCMDSIZE];

} SINGLEAPPSTRUC;

//
// Structures for WSHIOCTL_BLUESCREEN.
//
// lpvInBuffer must point to a BLUESCREENINFO structure.
// lpvOutBuffer must point to a DWORD which receives the message box result.
// The message box result is an IDXX value, as defined in windows.h.
//

/* H2INCSWITCHES -t */
typedef struct _BLUESCREENINFO {    /* bsi */

	char *	pszText;	    /* Message text (OEM character set) */
	char *	pszTitle;	    /* Message title (OEM character set) */
				    /* NULL means "Windows" */
	DWORD	flStyle;	    /* Message box flags (see windows.h) */
				    /* Add'l flags defined in ddk\inc\shell.h */

} BLUESCREENINFO;
/* H2INCSWITCHES -t- */



#endif // _WSHIOCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\bindctx.cpp ===
#include "stock.h"
#pragma hdrstop

STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc)
{
    ASSERTMSG(ppbc != NULL, "Caller must pass valid ppbc");

    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        BIND_OPTS bo = {sizeof(bo), 0, grfMode, 0};
        hr = (*ppbc)->SetBindOptions(&bo);

        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }

    ASSERT(SUCCEEDED(hr) ? (*ppbc != NULL) : (*ppbc == NULL));
    return hr;
}

STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault)
{
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
            grfModeDefault = bo.grfMode;
    }
    return grfModeDefault;
}

STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR psz)
{
    BOOL bResult = FALSE;
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(psz, &punk)))
    {
        bResult = TRUE;
        punk->Release();
    }
    return bResult;
}

class CDummyUnknown : public IOleWindow
{
public:
    CDummyUnknown() : _cRef(1), _hwnd(NULL) {}
    CDummyUnknown(HWND hwnd) : _cRef(1), _hwnd(hwnd) {}
    
    //  IUnknown refcounting
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CDummyUnknown, IOleWindow ),
            { 0 },
        };
        return QISearch(this, qit, riid, ppv);
    }
    STDMETHODIMP_(ULONG) AddRef(void)
    {
       return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release(void)
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IOleWindow
    STDMETHODIMP GetWindow(HWND * lphwnd) { *lphwnd = _hwnd; return _hwnd ? S_OK : E_NOTIMPL; }
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

protected:
    LONG _cRef;
    HWND _hwnd;
};

STDAPI BindCtx_RegisterObjectParam(IBindCtx *pbcIn, LPCOLESTR pszRegister, IUnknown *punkRegister, IBindCtx **ppbcOut)
{
    HRESULT hr = S_OK;
    *ppbcOut = pbcIn;

    if (pbcIn)
        pbcIn->AddRef();
    else
        hr = CreateBindCtx(0, ppbcOut);
        
    if (SUCCEEDED(hr))
    {
        IUnknown *punkDummy = NULL;
        if (!punkRegister)
        {
            punkRegister = punkDummy = new CDummyUnknown();
            hr = punkDummy ? S_OK : E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            hr = (*ppbcOut)->RegisterObjectParam((LPOLESTR)pszRegister, punkRegister);

            if (punkDummy)
                punkDummy->Release();
        }
        
        if (FAILED(hr))
            ATOMICRELEASE(*ppbcOut);

    }

    return hr;
}

STDAPI BindCtx_RegisterObjectParams(IBindCtx *pbcIn, BINDCTX_PARAM *rgParams, UINT cParams, IBindCtx **ppbcOut)
{
    HRESULT hr = S_FALSE;
    //  require at least one param
    ASSERT(cParams);
    *ppbcOut = 0;
    for (UINT i = 0; SUCCEEDED(hr) && i < cParams; i++)
    {
        //  returns the in param if NON-NULL
        hr = BindCtx_RegisterObjectParam(pbcIn, rgParams[i].pszName, rgParams[i].pbcParam, &pbcIn);
            
        // we only keep the first addref()
        // and we return it
        if (SUCCEEDED(hr))
        {
            if (i == 0)
                *ppbcOut = pbcIn;
            else
                pbcIn->Release();
        }
    }

    if (FAILED(hr))
    {
        ATOMICRELEASE(*ppbcOut);
    }

    return hr;
}

STDAPI BindCtx_RegisterUIWindow(IBindCtx *pbcIn, HWND hwnd, IBindCtx **ppbcOut)
{
    IUnknown *punkDummy = new CDummyUnknown(hwnd);
    HRESULT hr = punkDummy ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        hr = BindCtx_RegisterObjectParam(pbcIn, STR_DISPLAY_UI_DURING_BINDING, punkDummy, ppbcOut);
        punkDummy->Release();
    }
    else
    {
        *ppbcOut = 0;
    }
    return hr;
}
        
STDAPI_(HWND) BindCtx_GetUIWindow(IBindCtx *pbc)
{
    HWND hwnd = NULL;
    IUnknown *punk;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_DISPLAY_UI_DURING_BINDING, &punk)))
    {
        IUnknown_GetWindow(punk, &hwnd);
        punk->Release();
    }
    return hwnd;
}
    
// dwTicksToAllow is time in msec relative to "now"

STDAPI BindCtx_CreateWithTimeoutDelta(DWORD dwTicksToAllow, IBindCtx **ppbc)
{
    HRESULT hr = CreateBindCtx(0, ppbc);
    if (SUCCEEDED(hr))
    {
        DWORD dwDeadline = GetTickCount() + dwTicksToAllow;
        if (0 == dwDeadline)
            dwDeadline = 1;

        BIND_OPTS bo = {sizeof(bo), 0, 0, dwDeadline};
        hr = (*ppbc)->SetBindOptions(&bo);
        if (FAILED(hr))
        {
            ATOMICRELEASE(*ppbc);
        }
    }

    ASSERT(SUCCEEDED(hr) ? (*ppbc != NULL) : (*ppbc == NULL));
    return hr;
}

// returns # of msec relative to "now" to allow the operation to take

STDAPI BindCtx_GetTimeoutDelta(IBindCtx *pbc, DWORD *pdwTicksToAllow)
{
    *pdwTicksToAllow = 0;

    HRESULT hr = E_FAIL;
    if (pbc)
    {
        BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
        if (SUCCEEDED(pbc->GetBindOptions(&bo)))
        {
            if (bo.dwTickCountDeadline)
            {
                DWORD dwNow = GetTickCount();
                if (dwNow > bo.dwTickCountDeadline)
                {
                    *pdwTicksToAllow = 0;   // we have already elappsed the timeout, return 0
                }
                else
                {
                    *pdwTicksToAllow = bo.dwTickCountDeadline - dwNow;  // positive delta in the future
                }
                hr = S_OK;
            }
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\autosecurity.cpp ===
/*****************************************************************************\
    FILE: autosecurity.cpp

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/20/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#include "stock.h"
#pragma hdrstop

#include <autosecurity.h>       // CAutomationSecurity
#include <ieguidp.h>            // IID_IBrowserService
#include "ccstock.h"            // LocalZoneCheck


/***************************************************************\
    DESCRIPTION:
        Some hosts are always safe.  Visual Basic is one example.

    PARAMETERS:
        RETURN: This function will return TRUE if the host is
                always safe.
        HRESULT: This is a more descriptive error so the caller
                can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsSafeHost(OUT OPTIONAL HRESULT * phr)
{
    BOOL fAlwaysSafe;

    // _dwSafetyOptions being zero means we are in a mode
    // that needs to assume the caller or data is from
    // an untrusted source.
    if (0 == _dwSafetyOptions)
    {
        fAlwaysSafe = TRUE;
        if (phr)
            *phr = S_OK;
    }
    else
    {
        fAlwaysSafe = FALSE;
        if (phr)
            *phr = E_ACCESSDENIED;
    }

    return fAlwaysSafe;
}


/***************************************************************\
    DESCRIPTION:
        The class that implements this can check if the host is
    from the Local zone.  This way, we can prevent a host that
    would try to call unsafe automation methods or misrepresent
    the consequence of the ActiveX Control's UI.

    PARAMETERS:
        RETURN: TRUE if the security check passed.  FALSE means
                the host isn't trusted so don't care out unsafe
                operations.
        dwFlags: What behaviors does the caller want?  Currently:
            CAS_REG_VALIDATION: This means the caller needs the
                host's HTML to be registered and the checksum to
                be valid.
        HRESULT: This is a more descriptive error so the caller
            can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsHostLocalZone(IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr)
{
    HRESULT hr;

    // See if the host is always safe.
    if (!IsSafeHost(&hr))
    {
        // It isn't, so let's see if this content is safe.
        // (Normally the immediate HTML FRAME)
        
        // Is it from the local zone?
        hr = LocalZoneCheck(_punkSite);

        // Does the caller also want to verify it's checksum?
        if ((S_OK == hr) && (CAS_REG_VALIDATION & dwFlags))
        {
            IBrowserService* pbs;
            WCHAR wszPath[MAX_PATH];

            wszPath[0] = 0;
            hr = E_ACCESSDENIED;

            // ask the browser, for example we are in a .HTM doc
            if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SShellBrowser, IID_PPV_ARG(IBrowserService, &pbs))))
            {
                LPITEMIDLIST pidl;

                if (SUCCEEDED(pbs->GetPidl(&pidl)))
                {
                    DWORD dwAttribs = SFGAO_FOLDER;

                    if (SUCCEEDED(SHGetNameAndFlagsW(pidl, SHGDN_FORPARSING, wszPath, ARRAYSIZE(wszPath), &dwAttribs))
                            && (dwAttribs & SFGAO_FOLDER))   // This is a folder. So, wszPath should be the path for it's webview template
                    {
                        IOleCommandTarget *pct;

                        // find the template path from webview, for example a .HTT file
                        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_DefView, IID_PPV_ARG(IOleCommandTarget, &pct))))
                        {
                            VARIANT vPath;

                            vPath.vt = VT_EMPTY;
                            if (pct->Exec(&CGID_DefView, DVCMDID_GETTEMPLATEDIRNAME, 0, NULL, &vPath) == S_OK)
                            {
                                if (vPath.vt == VT_BSTR && vPath.bstrVal)
                                {
                                    DWORD cchPath = ARRAYSIZE(wszPath);

                                    if (S_OK != PathCreateFromUrlW(vPath.bstrVal, wszPath, &cchPath, 0))
                                    {
                                        // it might not be an URL, in this case it is a file path
                                        StrCpyNW(wszPath, vPath.bstrVal, ARRAYSIZE(wszPath));
                                    }
                                }
                                VariantClear(&vPath);
                            }
                            pct->Release();
                        }
                    }
                    ILFree(pidl);
                }

                pbs->Release();
            }
            else
            {
                ASSERT(0);      // no browser, where are we?
            }

            if (wszPath[0])
            {
                DWORD dwRVTFlags = (SHRVT_VALIDATE | SHRVT_REGISTERIFPROMPTOK);

                if (CAS_PROMPT_USER & dwFlags)
                    dwRVTFlags |= SHRVT_PROMPTUSER;
                hr = SHRegisterValidateTemplate(wszPath, dwRVTFlags);
            }
        }
    }
    
    if (S_FALSE == hr)
        hr = E_ACCESSDENIED;    // The caller needs to soften the hr to S_OK if it's concerned for script.

    if (phr)
        *phr = hr;

    return ((S_OK == hr) ? TRUE : FALSE);
}


/***************************************************************\
    DESCRIPTION:
        The class that implements this can check if the host is
    from the Local zone.  This way, we can prevent a host that
    would try to call unsafe automation methods or misrepresent
    the consequence of the ActiveX Control's UI.

    PARAMETERS:
        RETURN: TRUE if the security check passed.  FALSE means
                the host isn't trusted so don't care out unsafe
                operations.
        dwFlags: What behaviors does the caller want?  Currently:
            CAS_REG_VALIDATION: This means the caller needs the
                host's HTML to be registered and the checksum to
                be valid.
        HRESULT: This is a more descriptive error so the caller
            can differenciate E_OUTOFMEMORY from E_INVALIDARG, etc.
\***************************************************************/
BOOL CAutomationSecurity::IsUrlActionAllowed(IN IInternetHostSecurityManager * pihsm, IN DWORD dwUrlAction, IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr)
{
    HRESULT hr;
    IInternetHostSecurityManager * pihsmTemp = NULL;

    if (!pihsm)
    {
        hr = IUnknown_QueryService(_punkSite, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsmTemp));
        pihsm= pihsmTemp;
    }

    hr = ZoneCheckHost(pihsm, dwUrlAction, dwFlags); 

    if (S_FALSE == hr)
        hr = E_ACCESSDENIED;    // The caller needs to soften the hr to S_OK if it's concerned for script.

    if (phr)
        *phr = hr;

    ATOMICRELEASE(pihsmTemp);
    return ((S_OK == hr) ? TRUE : FALSE);
}


HRESULT CAutomationSecurity::MakeObjectSafe(IN IUnknown ** ppunk)
{
    HRESULT hr;

    // See if the host is always safe.
    if (!IsSafeHost(&hr))
    {
        // It isn't, so let's ask the control if it's
        // going to be safe.
        hr = MakeSafeForScripting(ppunk);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\vmmreg.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 *   Date:	03-June-1993
 *
 *   Author:	Nagara
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already
#define REG_SZ		0x0001
#endif
#ifndef REG_BINARY	// define only if not there already
#define REG_BINARY	0x0003
#endif
#ifndef REG_DWORD	// define only if not there already
#define	REG_DWORD	0x0004
#endif


#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID pvKeyContext, PVALCONTEXT pvalcontextValues, DWORD cvalcontextValues, PVOID pbData, DWORD * pcbData, DWORD dwReserved);

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;		// Only PROVIDER_KEEPS_VALUE_LENGTH for now.
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID pvKeyContext, PVOID pprovHandlerInfo, PVOID ppvalueValueInfo, DWORD cpvalueValueInfo, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push cpvalueValueInfo
    _asm push ppvalueValueInfo
    _asm push pprovHandlerInfo
    _asm push pvKeyContext
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegQueryMultipleValues (VMMHKEY hKey, PVOID val_list, DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryMultipleValues);
    _asm add  esp, 5*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\cnctnpt.cpp ===
//
//  CConnectionPoint
//
//  Common implementation for CConnectionPoint.
//

//
//  Since EnumConnections is called so much, we have a custom
//  enumerator for it which is faster than CStandardEnum and which
//  performs fewer memory allocations.
//

#include "stock.h"
#pragma hdrstop

#include <olectl.h>
#include "ieguidp.h"
#include "cnctnpt.h"

class CConnectionPointEnum : public IEnumConnections
{
public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IEnumConnections methods
    //
    STDMETHOD(Next)(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched);
    STDMETHOD(Skip)(ULONG ccd) { return Next(ccd, NULL, NULL); }
    STDMETHOD(Reset)(void) { m_iPos = 0; return S_OK; }
    STDMETHOD(Clone)(IEnumConnections **ppecOut);

    friend HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **pecOut);

private:
    CConnectionPointEnum(CConnectionPoint *pcp, int iPos)
    : m_cRef(1), m_pcp(pcp), m_iPos(iPos) { m_pcp->AddRef(); }

    ~CConnectionPointEnum() { m_pcp->Release(); }

    int m_cRef;                         // refcount
    CConnectionPoint *m_pcp;            // my dad
    int m_iPos;                         // enumeration state
};


//
//  When we need to grow the sink array, we grow by this many.
//
#define GROWTH      8

//
//  OLE says that zero is never a valid cookie, so our cookies are
//  the array index biased by unity.
//
#define COOKIEFROMINDEX(i)      ((i) + 1)
#define INDEXFROMCOOKIE(dw)     ((dw) - 1)


//
//  LocalReAllocHelp behaves like IMalloc::Realloc, which
//  is slightly different from LocalRealloc.
//
//  IMalloc::Realloc(NULL, 0) = return NULL
//  IMalloc::Realloc(pv, 0) = IMalloc::Free(pv)
//  IMalloc::Realloc(NULL, cb) = IMalloc::Alloc(cb)
//  IMalloc::Realloc(pv, cb) = LocalRealloc()
//
void *LocalReAllocHelp(void *pv, ULONG cb)
{
    if (cb == 0)
    {
        if (pv)
        {
            LocalFree(pv);
        }
        return NULL;
    }
    else if (pv == NULL)
    {
        return LocalAlloc(LPTR, cb);
    }
    else
    {
        return LocalReAlloc(pv, cb, LMEM_MOVEABLE|LMEM_ZEROINIT);
    }
}

CConnectionPoint::~CConnectionPoint ()
{
    // clean up some memory stuff
    UnadviseAll();
    if (m_rgSinks)
        LocalFree(m_rgSinks);
}


HRESULT CConnectionPoint::UnadviseAll(void)
{
    if (m_rgSinks)
    {
        int x;

        for (x = 0; x < m_cSinksAlloc; x++)
        {
            ATOMICRELEASE(m_rgSinks[x]);
        }
    }

    return S_OK;
}

//
//  For backwards-compatibility with IE4, our superclass is
//  CIE4ConnectionPoint.
//
STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IConnectionPoint) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = SAFECAST(this, IConnectionPoint *);
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *piid)
{
    *piid = *m_piid;

    return S_OK;
}

STDMETHODIMP CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    return m_punk->QueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}

STDMETHODIMP CConnectionPoint::Advise(IUnknown *pUnk,DWORD *pdwCookie)
{
    HRESULT    hr;
    IUnknown **rgUnkNew;
    IUnknown  *punkTgt;
    int        i = 0;

    if (!pdwCookie)
        return E_POINTER;

    *pdwCookie = 0;

    // first, make sure everybody's got what they thinks they got

    hr = pUnk->QueryInterface(*m_piid, (LPVOID *)&punkTgt);
    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        //
        //  If we are not an IPropertyNotifySink, then we had better
        //  be derived from IDispatch.  Try to confirm.
        //
        if (m_piid != &IID_IPropertyNotifySink)
        {
            IDispatch *pdisp;
            if (SUCCEEDED(pUnk->QueryInterface(IID_IDispatch, (LPVOID *)&pdisp)))
            {
                pdisp->Release();
            }
            else
            {
                AssertMsg(0, TEXT("CConnectionPoint: IID %08x not derived from IDispatch"), m_piid->Data1);
            }
        }
#endif
    }
    else
    {
        if (m_piid != &IID_IPropertyNotifySink)
        {
            // This is against spec, but raymondc is guessing that this is done
            // for compatibility with VB or some other scripting language that
            // talks IDispatch but not necessarily the IDispatch-derived
            // thingie that we officially speak.  Since we really source
            // merely IDispatch::Invoke, we can satisfactorily accept any
            // IDispatch as a sink.
            hr = pUnk->QueryInterface(IID_IDispatch, (LPVOID*)&punkTgt);
        }
    }

    if (SUCCEEDED(hr))
    {

        // we no longer optimize the case where there is only one sink
        // because it's rarely the case any more.

        //
        //  If the table is full, then grow it.
        //
        if (m_cSinks >= m_cSinksAlloc)
        {
            //  LocalReAllocHelp is so smart.  If you realloc from NULL, it
            //  means Alloc.  What this means for us?  No special cases!

            rgUnkNew = (IUnknown **)LocalReAllocHelp(m_rgSinks, (m_cSinksAlloc + GROWTH) * sizeof(IUnknown *));
            if (!rgUnkNew)
            {
                punkTgt->Release();
                // GetLastError();
                return E_OUTOFMEMORY;
            }
            m_rgSinks = rgUnkNew;

            //
            //  OLE does not guarantee that the new memory is zero-initialized.
            //
            ZeroMemory(&m_rgSinks[m_cSinksAlloc], GROWTH * sizeof(IUnknown *));

            m_cSinksAlloc += GROWTH;
        }

        //
        //  Look for an empty slot.  There has to be one since we grew the
        //  table if we were full.
        //
        for (i = 0; m_rgSinks[i]; i++) {
            ASSERT(i < m_cSinksAlloc);
        }

        ASSERT(m_rgSinks[i] == NULL);   // Should've found a free slot
        m_rgSinks[i] = punkTgt;

        *pdwCookie = COOKIEFROMINDEX(i);
        m_cSinks++;

        // notify our owner that someone is connecting to us --
        // they may want to hook something up at the last minute
        //
        IConnectionPointCB* pcb;
        if (SUCCEEDED(m_punk->QueryInterface(IID_IConnectionPointCB, (LPVOID*)&pcb)))
        {
            pcb->OnAdvise(*m_piid, m_cSinks, *pdwCookie);
            pcb->Release();
        }
    }
    else
    {
        hr = CONNECT_E_CANNOTCONNECT;
    }

    return hr;
}

STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie)
{
    if (!dwCookie)
        return S_OK;

    int x = INDEXFROMCOOKIE(dwCookie);

    // Validate the cookie.
    if (x >= m_cSinksAlloc || m_rgSinks[x] == NULL)
        return CONNECT_E_NOCONNECTION;

    // notify our owner that someone is disconnecting from us --
    // they may want to clean up from the OnAdvise call
    // Perform the callback while the sink is still alive, in case
    // the callback wants to do some last-minute communication.
    //
    IConnectionPointCB* pcb;
    if (SUCCEEDED(m_punk->QueryInterface(IID_IConnectionPointCB, (LPVOID*)&pcb)))
    {
        pcb->OnUnadvise(*m_piid, m_cSinks - 1, dwCookie);
        pcb->Release();
    }

    // Free up the slot.  We cannot relocate any elements because that
    // would mess up the outstanding cookies.
    ATOMICRELEASE(m_rgSinks[x]);
    m_cSinks--;

    // Don't free the memory on the loss of the last sink; a new one
    // will probably show up soon.

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
STDMETHODIMP CConnectionPoint::EnumConnections(IEnumConnections **ppEnumOut)
{
#if 1
    return CConnectionPointEnum_Create(this, 0, ppEnumOut);
#else
    CONNECTDATA *rgConnectData = NULL;
    int i, cSinks;

    // CopyAndAddRefObject assumes that the IUnknown comes first
    // So does CStandardEnum
    COMPILETIME_ASSERT(FIELD_OFFSET(CONNECTDATA, pUnk) == 0);

    cSinks = 0;
    if (_HasSinks())
    {
        // allocate some memory big enough to hold all of the sinks.
        //
        // Must use GlobalAlloc because CStandardEnum uses GlobalFree.
        //
        rgConnectData = (CONNECTDATA *)GlobalAlloc(GMEM_FIXED, m_cSinks * sizeof(CONNECTDATA));
        if (!rgConnectData)
            return E_OUTOFMEMORY;

        // fill in the array
        //
        for (i = 0; i < m_cSinksAlloc; i++)
        {
            if (m_rgSinks[i])
            {
                rgConnectData[cSinks].pUnk = m_rgSinks[i];
                rgConnectData[cSinks].dwCookie = i + 1;
                cSinks++;

                // In case m_rgSinks gets out of sync with m_cSinks,
                // just stop when the array gets full.
                if (cSinks >= m_cSinks)
                {
                    break;
                }
            }
        }
        // Make sure we found all the items we should've found
        ASSERT(cSinks == m_cSinks);
    }

    // create a statndard  enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                       TRUE, cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut)
    {
        LocalFree(rgConnectData);
        return E_OUTOFMEMORY;
    }

    return S_OK;
#endif
}

//
// CConnectionPoint::DoInvokeIE4
//
// Calls all sinks' IDispatch::Invoke() with Cancel semantics.
HRESULT CConnectionPoint::DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams)
{
    return IConnectionPoint_InvokeWithCancel(this->CastToIConnectionPoint(),
                                    dispid, pdispparams, pf, ppv);
}

//
//  CConnectionPointEnum
//

HRESULT CConnectionPointEnum_Create(CConnectionPoint *pcp, int iPos, IEnumConnections **ppecOut)
{
    *ppecOut = new CConnectionPointEnum(pcp, iPos);
    return *ppecOut ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CConnectionPointEnum::QueryInterface(REFIID riid, void **ppvObjOut)
{
    if (IsEqualIID(riid, IID_IEnumConnections) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObjOut = (IUnknown *)this;
        AddRef();
        return S_OK;
    }

    *ppvObjOut = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CConnectionPointEnum::Release()
{
    ULONG cRef = --m_cRef;
    if (cRef == 0)
        delete this;

    return cRef;
}

//
//  Next also doubles as Skip.  If you pass a NULL output buffer, then
//  nothing gets copied (i.e., you're a Skip).
//
STDMETHODIMP CConnectionPointEnum::Next(ULONG ccd, LPCONNECTDATA rgcd, ULONG *pcdFetched)
{
    ULONG ccdFetched = 0;

    while (ccdFetched < ccd)
    {
        //
        //  Look for the next sink or the end of the array
        //
        while (m_iPos < m_pcp->m_cSinksAlloc && m_pcp->m_rgSinks[m_iPos] == NULL)
        {
            m_iPos++;
        }

        if (m_iPos >= m_pcp->m_cSinksAlloc)
            break;

        if (rgcd)
        {
            //
            //  Copy it to the output buffer
            //
            rgcd->pUnk = m_pcp->m_rgSinks[m_iPos];
            rgcd->dwCookie = COOKIEFROMINDEX(m_iPos);
            rgcd->pUnk->AddRef();
            rgcd++;
        }
        m_iPos++;
        ccdFetched++;
    }

    if (pcdFetched)
        *pcdFetched = ccdFetched;

    return (ccdFetched < ccd) ? S_FALSE : S_OK;
}

//
//  Our clone enumerates the same CConnectionPoint from the same position.
//
STDMETHODIMP CConnectionPointEnum::Clone(IEnumConnections **ppecOut)
{
    return CConnectionPointEnum_Create(m_pcp, m_iPos, ppecOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\inc\win95\vwin32.h ===
/******************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp.  All Rights Reserved, 1989-1995
 *
 *   Title: vwin32.h -
 *
 *   Version:   4.00
 *
 *   Date:  24-May-1993
 *
 ******************************************************************************/

/*INT32*/

#ifndef _VWIN32_H_
#define _VWIN32_H_

// ;BeginInternal
// Note that this ID has been reserved for us in VMM.H

#define VWIN32_DEVICE_ID    0x0002A

#define VWIN32_VER_MAJOR    1
#define VWIN32_VER_MINOR    4

#define THREAD_TYPE_WIN32 VWIN32_DEVICE_ID

// ;EndInternal

#ifndef Not_VxD

/*XLATOFF*/
#define VWIN32_Service  Declare_Service
#define VWIN32_StdCall_Service Declare_SCService
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VWIN32)

VWIN32_Service  (VWIN32_Get_Version, LOCAL)
VWIN32_Service  (VWIN32_DIOCCompletionRoutine, LOCAL)
VWIN32_Service  (_VWIN32_QueueUserApc)
VWIN32_Service  (_VWIN32_Get_Thread_Context)
VWIN32_Service  (_VWIN32_Set_Thread_Context)
VWIN32_Service  (_VWIN32_CopyMem, LOCAL)
VWIN32_Service  (_VWIN32_Npx_Exception)
VWIN32_Service  (_VWIN32_Emulate_Npx)
VWIN32_Service  (_VWIN32_CheckDelayedNpxTrap)
VWIN32_Service  (VWIN32_EnterCrstR0)
VWIN32_Service  (VWIN32_LeaveCrstR0)
VWIN32_Service  (_VWIN32_FaultPopup)
VWIN32_Service  (VWIN32_GetContextHandle)
VWIN32_Service  (VWIN32_GetCurrentProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_SetWin32Event)
VWIN32_Service  (_VWIN32_PulseWin32Event)
VWIN32_Service  (_VWIN32_ResetWin32Event)
VWIN32_Service  (_VWIN32_WaitSingleObject)
VWIN32_Service  (_VWIN32_WaitMultipleObjects)
VWIN32_Service  (_VWIN32_CreateRing0Thread)
VWIN32_Service  (_VWIN32_CloseVxDHandle)
VWIN32_Service  (VWIN32_ActiveTimeBiasSet, LOCAL)
VWIN32_Service  (VWIN32_GetCurrentDirectory, LOCAL)
VWIN32_Service  (VWIN32_BlueScreenPopup)
VWIN32_Service  (VWIN32_TerminateApp)
VWIN32_Service  (_VWIN32_QueueKernelAPC)
VWIN32_Service  (VWIN32_SysErrorBox)
VWIN32_Service  (_VWIN32_IsClientWin32)
VWIN32_Service  (VWIN32_IFSRIPWhenLev2Taken, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Event)
VWIN32_Service  (_VWIN32_InitWin32Mutex)
VWIN32_Service  (_VWIN32_ReleaseWin32Mutex)
VWIN32_Service  (_VWIN32_BlockThreadEx)
VWIN32_Service  (VWIN32_GetProcessHandle, LOCAL)
VWIN32_Service  (_VWIN32_InitWin32Semaphore)
VWIN32_Service  (_VWIN32_SignalWin32Sem)
VWIN32_Service  (_VWIN32_QueueUserApcEx)
VWIN32_Service	(_VWIN32_OpenVxDHandle)
VWIN32_Service	(_VWIN32_CloseWin32Handle)
VWIN32_Service	(_VWIN32_AllocExternalHandle)
VWIN32_Service	(_VWIN32_UseExternalHandle)
VWIN32_Service	(_VWIN32_UnuseExternalHandle)
VWIN32_StdCall_Service	(KeInitializeTimer, 1)
VWIN32_StdCall_Service	(KeSetTimer, 4)
VWIN32_StdCall_Service	(KeCancelTimer, 1)
VWIN32_StdCall_Service	(KeReadStateTimer, 1)
VWIN32_Service	(_VWIN32_ReferenceObject)
VWIN32_Service	(_VWIN32_GetExternalHandle)

End_Service_Table(VWIN32)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)      // turn on not enough params warning
/*XLATON*/

#endif // Not_VxD

// ;BeginInternal

// PM API list

#define VWIN32_GET_VER      0
#define VWIN32_THREAD_SWITCH    1   // ECX = wake param, EBX = ring 0 handle
#define VWIN32_DPMI_FAULT   2   // SS:BP = FAULTSTACKFRAME, AL = ignore
#define VWIN32_MMGR_FUNCTIONS   3
#define VWIN32_EVENT_CREATE 4
#define VWIN32_EVENT_DESTROY    5
#define VWIN32_EVENT_WAIT   6
#define VWIN32_EVENT_SET    7
#define VWIN32_RealNetx_Info    8
#define VWIN32_THREAD_BOOST_PRI 9
#define VWIN32_WAIT_CRST    10
#define VWIN32_WAKE_CRST    11
#define VWIN32_SET_FAULT_INFO   12
#define VWIN32_EXIT_TIME    13
#define VWIN32_BOOST_THREAD_GROUP 14
#define VWIN32_BOOST_THREAD_STATIC 15
#define VWIN32_WAKE_IDLE_SYS    16
#define VWIN32_MAKE_IDLE_SYS    17
#define VWIN32_DELIVER_PENDING_KERNEL_APCS 18
#define VWIN32_SYS_ERROR_BOX    19
#define VWIN32_GET_IFSMGR_XLAT_PTR 20
#define VWIN32_BOOST_THREAD_DECAY 21
#define VWIN32_LAST_CMD     21

#define VWIN32_MMGR_RESERVE ((VWIN32_MMGR_FUNCTIONS << 8) + 0)
#define VWIN32_MMGR_COMMIT  ((VWIN32_MMGR_FUNCTIONS << 8) + 1)
#define VWIN32_MMGR_DECOMMIT    ((VWIN32_MMGR_FUNCTIONS << 8) + 2)
#define VWIN32_MMGR_PAGEFREE    ((VWIN32_MMGR_FUNCTIONS << 8) + 3)

//
// Current Win32 thread/process handles.
//
// Updated every context switch.
//

typedef struct _K32CURRENT {
    DWORD   CurThreadHandle;    // win32 thread handle
    DWORD   CurProcessHandle;   // win32 process handle
    DWORD   CurTDBX;        // current TDBX
    DWORD   pCurK16Task;        // flat pointer to kernel 16 CurTDB
    DWORD   CurContextHandle;   // win32 memory context handle
} K32CURRENT;

//
// Flag values for CreateThread
//
#define VWIN32_CT_EMULATE_NPX   0x01    // set EM bit in CR0 for thread
#define VWIN32_CT_WIN32_NPX 0x02    // use Win32 FP exception model
#define VWIN32_CT_WIN32     0x04    // thread is Win32 (not Win16)

//
// Return values from VWIN32_CheckDelayedNpxTrap
//
#define CX_RAISE    0       // instruction raises exception
#define CX_IGNORE   1       // instruction ignores exception
#define CX_CLEAR    2       // instruction clears or masks exception

// flags to use for win32 blocking
#define WIN32_BLOCK_FLAGS (BLOCK_FORCE_SVC_INTS+BLOCK_SVC_INTS+BLOCK_THREAD_IDLE+BLOCK_ENABLE_INTS)

//
// Flags for VWIN32_BlueScreenPopup
//

#define VBSP_CANCEL     0x00000001
#define VBSP_DISPLAY_VXD_NAME   0x00000002

//
// Fault stack frame structure
//

typedef struct fsf_s {
    WORD fsf_GS;
    WORD fsf_FS;
    WORD fsf_ES;
    WORD fsf_DS;
    DWORD fsf_EDI;
    DWORD fsf_ESI;
    DWORD fsf_EBP;
    DWORD fsf_locked_ESP;
    DWORD fsf_EBX;
    DWORD fsf_EDX;
    DWORD fsf_ECX;
    DWORD fsf_EAX;
    WORD fsf_num;       // Fault number
    WORD fsf_prev_IP;   // IP of previous fault handler
    WORD fsf_prev_CS;   // CS of previous fault handler
    WORD fsf_ret_IP;    // DPMI fault handler frame follows
    WORD fsf_ret_CS;
    WORD fsf_err_code;
    WORD fsf_faulting_IP;
    WORD fsf_faulting_CS;
    WORD fsf_flags;
    WORD fsf_SP;
    WORD fsf_SS;
} FAULTSTACKFRAME;

typedef FAULTSTACKFRAME *PFAULTSTACKFRAME;

// ;EndInternal

//
// structure for VWIN32_SysErrorBox
//

typedef struct vseb_s {
    DWORD vseb_resp;
    WORD vseb_b3;
    WORD vseb_b2;
    WORD vseb_b1;
    DWORD vseb_pszCaption;
    DWORD vseb_pszText;
} VSEB;

typedef VSEB *PVSEB;

#define SEB_ANSI    0x4000      // ANSI strings if set on vseb_b1
#define SEB_TERMINATE   0x2000      // forces termination if button pressed

// VWIN32_QueueKernelAPC flags

#define KERNEL_APC_IGNORE_MC        0x00000001
#define KERNEL_APC_STATIC       0x00000002
#define KERNEL_APC_WAKE         0x00000004

// for DeviceIOControl support
// On a DeviceIOControl call vWin32 will pass following parameters to
// the Vxd that is specified by hDevice. hDevice is obtained thru an
// earlier call to hDevice = CreateFile("\\.\vxdname", ...);
// ESI = DIOCParams STRUCT (defined below)
typedef struct DIOCParams   {
    DWORD   Internal1;      // ptr to client regs
    DWORD   VMHandle;       // VM handle
    DWORD   Internal2;      // DDB
    DWORD   dwIoControlCode;
    DWORD   lpvInBuffer;
    DWORD   cbInBuffer;
    DWORD   lpvOutBuffer;
    DWORD   cbOutBuffer;
    DWORD   lpcbBytesReturned;
    DWORD   lpoOverlapped;
    DWORD   hDevice;
    DWORD   tagProcess;
} DIOCPARAMETERS;

typedef DIOCPARAMETERS *PDIOCPARAMETERS;

// dwIoControlCode values for vwin32's DeviceIOControl Interface
// all VWIN32_DIOC_DOS_ calls require lpvInBuffer abd lpvOutBuffer to be
// struct * DIOCRegs
#define VWIN32_DIOC_GETVERSION DIOC_GETVERSION
#define VWIN32_DIOC_DOS_IOCTL       1
#define VWIN32_DIOC_DOS_INT25       2
#define VWIN32_DIOC_DOS_INT26       3
#define VWIN32_DIOC_DOS_INT13       4
#define VWIN32_DIOC_SIMCTRLC        5
#define VWIN32_DIOC_DOS_DRIVEINFO   6
#define VWIN32_DIOC_CLOSEHANDLE DIOC_CLOSEHANDLE

// DIOCRegs
// Structure with i386 registers for making DOS_IOCTLS
// vwin32 DIOC handler interprets lpvInBuffer , lpvOutBuffer to be this struc.
// and does the int 21
// reg_flags is valid only for lpvOutBuffer->reg_Flags
typedef struct DIOCRegs {
    DWORD   reg_EBX;
    DWORD   reg_EDX;
    DWORD   reg_ECX;
    DWORD   reg_EAX;
    DWORD   reg_EDI;
    DWORD   reg_ESI;
    DWORD   reg_Flags;      
} DIOC_REGISTERS;

// if we are not included along with winbase.h
#ifndef FILE_FLAG_OVERLAPPED
  // OVERLAPPED structure for DeviceIOCtl VxDs
  typedef struct _OVERLAPPED {
          DWORD O_Internal;
          DWORD O_InternalHigh;
          DWORD O_Offset;
          DWORD O_OffsetHigh;
          HANDLE O_hEvent;
  } OVERLAPPED;
#endif

//  Parameters for _VWIN32_OpenVxDHandle to validate the Win32 handle type.
#define OPENVXD_TYPE_SEMAPHORE  0
#define OPENVXD_TYPE_EVENT      1
#define OPENVXD_TYPE_MUTEX      2
#define	OPENVXD_TYPE_ANY	3
  
// ;BeginInternal
#define OPENVXD_TYPE_MAXIMUM    3
// ;EndInternal

//
//  Object type table declaration for _VWIN32_AllocExternalHandle
//
/*XLATOFF*/
#define R0OBJCALLBACK           __stdcall
typedef VOID    (R0OBJCALLBACK *R0OBJFREE)(PVOID pR0ObjBody);
typedef PVOID   (R0OBJCALLBACK *R0OBJDUP)(PVOID pR0ObjBody, DWORD hDestProc);
/*XLATON*/
/* ASM
R0OBJFREE   TYPEDEF     DWORD
R0OBJDUP    TYPEDEF     DWORD
*/

typedef struct _R0OBJTYPETABLE {
    DWORD       ott_dwSize;             //  sizeof(R0OBJTYPETABLE)
    R0OBJFREE   ott_pfnFree;            //  called by Win32 CloseHandle
    R0OBJDUP    ott_pfnDup;             //  called by Win32 DuplicateHandle
} R0OBJTYPETABLE, *PR0OBJTYPETABLE;
/* ASM
R0OBJTYPETABLE  typedef _R0OBJTYPETABLE;
*/

#define R0EHF_INHERIT   0x00000001      //  Handle is inheritable
#define R0EHF_GLOBAL    0x00000002      //  Handle is valid in all contexts
// ;BeginInternal
#define R0EHF_ALL       (R0EHF_INHERIT | R0EHF_GLOBAL)
// ;EndInternal

// ;BeginInternal

/* ASM

FSF_CLEANUP_RETURN  EQU fsf_ret_IP - fsf_num
FSF_CLEANUP_CHAIN   EQU fsf_prev_IP - fsf_num

K32CURRENT typedef _K32CURRENT

;***LT  W32Fun - macro to make a function callable from Kernel32
;
;   This macro will create a stub of the format that the Ring0/Ring3
;   Win32 calling interface likes.
;   It plays around with the stack so that the arguments are set
;   up right and clean off right and it also sets the ring 3
;   registers to reflect the outcome of the operation.
;
;   This macro is taken from VMM's memory manager, file: mma.asm
;
;   ENTRY:  fun - function name
;       cargs - number of dword arguments it has
;       prefix - prefix for function
;   EXIT:   none
;
;   Note that when the function is called:
;       EBX is the VM handle
;       ESI points to client registers
;       EDI points to the return address
;   THESE REGISTERS MUST NOT BE TRASHED!
;
W32Fun  MACRO   fun, cbargs, prefix

BeginProc   VW32&fun, esp, W32SVC, public
    ArgVar  pcrs,dword
    ArgVar  hvm,dword
    x = 0
    REPT    cbargs
        x = x + 1
        ArgVar  arg&x,dword
    ENDM

    EnterProc
    pop edi     ;Save and remove return address
    pop esi     ;Save and remove client regs
    pop ebx     ;Save and remove hvm

    call    prefix&fun  ;Call function somewhere in VxD
                ;Note that this function may be a C function

    mov [esi].Client_EAX,eax    ;Put return values into client regs

    push    ebx     ;Put hvm back on stack
    push    esi     ;Put client regs back on stack
    push    edi     ;Restore return address

    LeaveProc
    Return
EndProc VW32&fun

ENDM
*/

// ;EndInternal

#endif  // _VWIN32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\caggunk.cpp ===
#include "stock.h"
#pragma hdrstop

#include "caggunk.h"


ULONG CAggregatedUnknown::AddRef()
{
    return _punkAgg->AddRef();
}

ULONG CAggregatedUnknown::Release()
{
    return _punkAgg->Release();
}


HRESULT CAggregatedUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    return _punkAgg->QueryInterface(riid, ppvObj);
}


HRESULT CAggregatedUnknown::CUnkInner::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
        InterlockedIncrement(&_cRef);
        return S_OK;
    }

    CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);
    return pparent->v_InternalQueryInterface(riid, ppvObj);
}

ULONG CAggregatedUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}


ULONG CAggregatedUnknown::CUnkInner::Release(void)
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    CAggregatedUnknown* pparent = IToClass(CAggregatedUnknown, _unkInner, this);

    if (!pparent->v_HandleDelete(&_cRef))
    {
        _cRef = 1000; // protect against cached pointers bumping us up then down

        delete pparent;
    }

    return 0;
}

CAggregatedUnknown::CAggregatedUnknown(IUnknown* punkAgg)
{
    _punkAgg = punkAgg ? punkAgg : &_unkInner;
}

CAggregatedUnknown::~CAggregatedUnknown()
{
}

//
//  Convert our controlling unknown to its canonical IUnknown *without*
//  altering the reference count on the outer object.
//
//  This is critical in order for QueryOuterInterface to work properly.
//
//  Returns NULL if something horrible went wrong.
//
//  OLE Magic:  Since objects are required also to return the canonical
//  IUnknown in response to any QI(IUnknown), it follows that the canonical
//  IUnknown remains valid so long as there are any outstanding references
//  to the object.  In other words, you can Release() the canonical IUnknown
//  and the pointer remains valid so long as you keep the object alive by
//  other means.
//
//  Believe it or not, this is a feature.  It's in the book!
//
IUnknown *CAggregatedUnknown::_GetCanonicalOuter(void)
{
    IUnknown *punkAggCanon;
    HRESULT hres = _punkAgg->QueryInterface(IID_IUnknown, (void **)&punkAggCanon);
    if (SUCCEEDED(hres)) 
    {
        punkAggCanon->Release(); // see "OLE Magic" comment above
        return punkAggCanon;
    } 
    else 
    {
        // The outer object is most likely some other shell component,
        // so let's ASSERT so whoever owns the outer component will fix it.
        ASSERT(!"The outer object's implementation of QI(IUnknown) is broken.");
        return NULL;
    }
}

void CAggregatedUnknown::_ReleaseOuterInterface(IUnknown** ppunk)
{
    ASSERT(IS_VALID_CODE_PTR(_punkAgg, IUnknown));

    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer

    //
    //  SHReleaseOuterInterface can handle punkAggCanon == NULL
    //
    SHReleaseOuterInterface(punkAggCanon, ppunk);
}

HRESULT CAggregatedUnknown::_QueryOuterInterface(REFIID riid, void ** ppvOut)
{
    IUnknown *punkAggCanon = _GetCanonicalOuter(); // non-refcounted pointer
    //
    //  SHQueryOuterInterface can handle punkAggCanon == NULL.
    //
    return SHQueryOuterInterface(punkAggCanon, riid, ppvOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\crst.cpp ===
#include "stock.h"
#pragma hdrstop

#include "dbutil.h"

///////
// Critical section helper stuff
//
#ifdef DEBUG
UINT g_CriticalSectionCount = 0;
DWORD g_CriticalSectionOwner = 0;
#ifdef STACKBACKTRACE
DBstkback g_CriticalSectionLastCall[4] = { 0 };
#endif


void Dll_EnterCriticalSection(CRITICAL_SECTION * pcsDll)
{
#ifdef STACKBACKTRACE
    int var0;       // *must* be 1st on frame
#endif

    EnterCriticalSection(pcsDll);
    if (g_CriticalSectionCount++ == 0)
    {
        g_CriticalSectionOwner = GetCurrentThreadId();
#ifdef STACKBACKTRACE
        int fp = (int) (1 + (int *)&var0);
        DBGetStackBack(&fp, g_CriticalSectionLastCall, ARRAYSIZE(g_CriticalSectionLastCall));
#endif
    }
}

void Dll_LeaveCriticalSection(CRITICAL_SECTION * pcsDll)
{
    if (--g_CriticalSectionCount == 0)
        g_CriticalSectionOwner = 0;
    LeaveCriticalSection(pcsDll);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\cowsite.cpp ===
#include "stock.h"
#pragma hdrstop

#include "cowsite.h"

HRESULT CObjectWithSite::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&_punkSite, punkSite);
    return S_OK;
}

HRESULT CObjectWithSite::GetSite(REFIID riid, void **ppvSite)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvSite);

    *ppvSite = NULL;
    return E_FAIL;
}

HRESULT CSafeServiceSite::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CSafeServiceSite, IServiceProvider),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CSafeServiceSite::AddRef()
{ 
    return InterlockedIncrement(&_cRef); 
}

ULONG CSafeServiceSite::Release()
{
    if (InterlockedDecrement(&_cRef)) 
        return _cRef;

    delete this;
    return 0;
}

HRESULT CSafeServiceSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (_psp)
        return _psp->QueryService(guidService, riid, ppvObj);

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

HRESULT CSafeServiceSite::SetProviderWeakRef(IServiceProvider *psp)
{
    _psp = psp;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\cobjsafe.cpp ===
#include "stock.h"
#pragma hdrstop

#include <comcat.h>
#include <hliface.h>
#include <mshtml.h>
#include <objsafe.h>
#include <perhist.h>
#include "cobjsafe.h"

// a default isafetyobject that we generally would use...  marks 
// deals with IDispatch 


HRESULT CObjectSafety::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    if (IsEqualIID(riid, IID_IDispatch))
    {
        if (pdwSupportedOptions)
            *pdwSupportedOptions = (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);

        *pdwEnabledOptions = _dwSafetyOptions;
    }
    else
    {
        ::DefaultGetSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    }

    return S_OK;
}


HRESULT CObjectSafety::SetInterfaceSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch))
    {
        _dwSafetyOptions = (_dwSafetyOptions & ~dwOptionSetMask) |
                           (dwEnabledOptions & dwOptionSetMask);
        return S_OK;
    }
    else
    {
        return ::DefaultSetSafetyOptions(riid, dwOptionSetMask, dwEnabledOptions);
    }
}



// *** IObjectSafety
//
// A couple static functions called by sitemap (and webbrowser).
// These are static so anyone else in this dll who has an OC
// that's always safe can just call them.
//
// These functions say we are safe for these three interfaces we implement
//  IID_IDispatch
//  IID_IPersistStream
//  IID_IPersistPropertyBag
//
// The WebBrowser OC handles IDispatch differently.
//
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
{
    *pdwSupportedOptions = 0;
    *pdwEnabledOptions = 0;

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistPropertyBag) ||
        IsEqualIID(riid, IID_IPersistHistory))
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
    }

    return S_OK;
}

HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
{
    if (dwOptionSetMask & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER |
                            INTERFACESAFE_FOR_UNTRUSTED_DATA))
    {
        return E_INVALIDARG;
    }

    if (IsEqualIID(riid, IID_IDispatch) ||
        IsEqualIID(riid, IID_IPersistStream) ||
        IsEqualIID(riid, IID_IPersistStreamInit) ||
        IsEqualIID(riid, IID_IPersistHistory) ||
        IsEqualIID(riid, IID_IPersistPropertyBag))
    {
        return S_OK;
    }

    return E_FAIL;
}


// When CWebBrowserOC is in the safe for scripting mode, we can't give out
// anyone else's IDispatch that is not also safe for scripting.
// This function encapsulates the basic functionality needed by both
// MakeSafeScripting and MakeSafeForInitializing (which we don't use)
BOOL MakeSafeFor(
IUnknown *punk,                 // object to test for safety
REFCATID catid,                 // category of safety
REFIID riid,                    // interface on which safety is desired
DWORD dwXSetMask,               // options to set
DWORD dwXOptions                // options to make safe for
                                    // (either INTERFACESAFE_FOR_UNTRUSTED_CALLER or
                                    //  INTERFACESAFE_FOR_UNTRUSTED_DATA)
)
{
    HRESULT hres;

    // first try IObjectSafety
    IObjectSafety *posafe;
    if (SUCCEEDED(punk->QueryInterface(IID_IObjectSafety, (LPVOID*) &posafe)))
    {
        hres = posafe->SetInterfaceSafetyOptions(riid, dwXSetMask, dwXOptions);
        posafe->Release();

        if (SUCCEEDED(hres))
            return TRUE;
    }

    // check the registry for "safe for scripting" component category

    // we need the classid -- get it thru IPersist
    CLSID clsid;
    IPersist *ppersist;
    hres = punk->QueryInterface(IID_IPersist, (LPVOID*) &ppersist);
    if (SUCCEEDED(hres))
    {
        hres = ppersist->GetClassID(&clsid);
        ppersist->Release();
    }
    if (FAILED(hres))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_WARNING, "MakeSafeForScripting - object doesn't have IPersist!");
        return FALSE;
    }

    // Create the category manager
    ICatInformation *pcatinfo;
    hres = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                            NULL, CLSCTX_INPROC_SERVER,
                            IID_ICatInformation, (LPVOID*) &pcatinfo);
    if (FAILED(hres))
        return FALSE;

    // Ask if the object belongs to the specified category
    CATID rgcatid[1];
    rgcatid[0] = catid;

    hres = pcatinfo->IsClassOfCategories(clsid, 1, rgcatid, 0, NULL);
    pcatinfo->Release();

    return (hres==S_OK) ? TRUE : FALSE;;	
}

HRESULT MakeSafeForScripting(IUnknown** ppDisp)
{
    HRESULT hres = S_OK;

    if (!MakeSafeFor(*ppDisp, CATID_SafeForScripting, IID_IDispatch,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER,
                       INTERFACESAFE_FOR_UNTRUSTED_CALLER))
    {
        // trace from shdocvw, was TF_SHDCONTROL
        TraceMsg(TF_WARNING, "MakeSafeForScripting - IDispatch not safe");

        (*ppDisp)->Release();
        *ppDisp = NULL;
        hres = E_FAIL;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\lib\debug.c ===
//
// Debug squirty functions
//
#include "stock.h"
#pragma hdrstop

#include "shellp.h"

#include <platform.h> // LINE_SEPARATOR_STR and friends
#include <winbase.h> // for GetModuleFileNameA


#define DM_DEBUG              0

#ifdef          DEBUG

//  --------------------------------------------------------------------------
//  AttachUserModeDebugger
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Attaches a user-mode debugger to the current process if one
//              is not already attached. This allows the ASSERT/RIP/TRACE to
//              be debugged in a user-mode debugger rather than ending up in
//              the kernel debugger which is sometimes limiting.
//
//  History:    2000-08-21  vtan        created
//  --------------------------------------------------------------------------

void    AttachUserModeDebugger (void)

{
    // Win95 does not support IsDebuggerPresent so we must
    // GetProcAddress for it below or we would fail to load.
    // In fact, we punt completely on Win9x
    if (GetVersion() & 0x80000000) return;

    __try
    {
        typedef BOOL (WINAPI *ISDEBUGGERPRESENT)();
        ISDEBUGGERPRESENT _IsDebuggerPresent = (ISDEBUGGERPRESENT)GetProcAddress(GetModuleHandleA("KERNEL32"), "IsDebuggerPresent");
        if (_IsDebuggerPresent && !_IsDebuggerPresent())
        {
            HKEY    hKeyAEDebug;
            TCHAR   szDebugger[MAX_PATH];

            szDebugger[0] = TEXT('\0');

            //  Read HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\AEDebug\Debugger

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AEDebug"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKeyAEDebug))
            {
                DWORD   dwDebuggerSize;

                dwDebuggerSize = sizeof(szDebugger);
                (LONG)RegQueryValueEx(hKeyAEDebug,
                                      TEXT("Debugger"),
                                      NULL,
                                      NULL,
                                      (LPBYTE)&szDebugger,
                                      &dwDebuggerSize);
                (LONG)RegCloseKey(hKeyAEDebug);
            }

            if (szDebugger[0] != TEXT('\0'))
            {
                static  const TCHAR     s_szDrWatsonImageName[]     =   TEXT("drwtsn32");

                // We cannot use wnsprintf (comctl32 cannot link to shlwapi)
                // so we need to make this buffer big enough that the wsprintf
                // cannot overflow.  We use a sprintf format string of size MAX_PATH
                // and insert two integers, so 64 should be plenty of space.
                TCHAR   szCommandLine[MAX_PATH + 64];

                //  Duplicate the string to szCommandLine and NULL terminate
                //  to compare directly for "drwtsn32" which we do NOT want
                //  attached to the process.

                lstrcpy(szCommandLine, szDebugger);
                szCommandLine[ARRAYSIZE(s_szDrWatsonImageName) - 1] = TEXT('\0');
                if (lstrcmpi(szCommandLine, s_szDrWatsonImageName) != 0)
                {
                    HANDLE                  hEvent;
                    SECURITY_ATTRIBUTES     securityAttributes;

                    //  Create an unnamed event which is passed to the debugger as an
                    //  inherited handle. It will signal this handle to release this
                    //  thread when the debugger is completely attached to the process.

                    securityAttributes.nLength = sizeof(securityAttributes);
                    securityAttributes.lpSecurityDescriptor = NULL;
                    securityAttributes.bInheritHandle = TRUE;
                    hEvent = CreateEvent(&securityAttributes, TRUE, FALSE, NULL);
                    if (hEvent != NULL)
                    {
                        STARTUPINFO             startupInfo;
                        PROCESS_INFORMATION     processInformation;

                        ZeroMemory(&startupInfo, sizeof(startupInfo));
                        ZeroMemory(&processInformation, sizeof(processInformation));
                        startupInfo.cb = sizeof(startupInfo);

                        //  Now formulate the command line to pass to the debugger.
                        //  It's in the form "cdb -p %ld -e %ld -gGx".

                        wsprintf(szCommandLine, szDebugger, GetCurrentProcessId(), hEvent);
                        if (CreateProcess(NULL,
                                          szCommandLine,
                                          NULL,
                                          NULL,
                                          TRUE,
                                          0,
                                          NULL,
                                          NULL,
                                          &startupInfo,
                                          &processInformation) != FALSE)
                        {

                            //  Now wait for the event. Give a generous 10 seconds
                            //  for the debugger to signal this event. If the debugger
                            //  doesn't then continue execution. Close all handles.

                            (DWORD)WaitForSingleObject(hEvent, INFINITE);
                            (BOOL)CloseHandle(processInformation.hProcess);
                            (BOOL)CloseHandle(processInformation.hThread);
                        }
                        (BOOL)CloseHandle(hEvent);
                    }
                }
                else
                {
                    OutputDebugStringA("drwtsn32 detected in AEDebug. Dropping to KD\r\n");
                }
            }
        }
    }
    __except (EXCEPTION_CONTINUE_EXECUTION)
    {
    }
}

#endif  /*  DEBUG   */

// UnicodeFromAnsi is used by shlwapi so it should not be inside the ifdef debug
//
/*----------------------------------------------------------
Purpose: This function converts a multi-byte string to a
         wide-char string.

         If pszBuf is non-NULL and the converted string can fit in
         pszBuf, then *ppszWide will point to the given buffer.
         Otherwise, this function will allocate a buffer that can
         hold the converted string.

         If pszAnsi is NULL, then *ppszWide will be freed.  Note
         that pszBuf must be the same pointer between the call
         that converted the string and the call that frees the
         string.

Returns: TRUE
         FALSE (if out of memory)

*/
BOOL
UnicodeFromAnsi(
    LPWSTR * ppwszWide,
    LPCSTR pszAnsi,           // NULL to clean up
    LPWSTR pwszBuf,
    int cchBuf)
    {
    BOOL bRet;

    // Convert the string?
    if (pszAnsi)
        {
        // Yes; determine the converted string length
        int cch;
        LPWSTR pwsz;
        int cchAnsi = lstrlenA(pszAnsi)+1;

        cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, NULL, 0);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pwszBuf)
            {
            // Yes; allocate space
            cchBuf = cch + 1;
            pwsz = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchBuf));
            }
        else
            {
            // No; use the provided buffer
            pwsz = pwszBuf;
            }

        if (pwsz)
            {
            // Convert the string
            cch = MultiByteToWideChar(CP_ACP, 0, pszAnsi, cchAnsi, pwsz, cchBuf);
            bRet = (0 < cch);
            }
        else
            {
            bRet = FALSE;
            }

        *ppwszWide = pwsz;
        }
    else
        {
        // No; was this buffer allocated?
        if (*ppwszWide && pwszBuf != *ppwszWide)
            {
            // Yes; clean up
            LocalFree((HLOCAL)*ppwszWide);
            *ppwszWide = NULL;
            }
        bRet = TRUE;
        }

    return bRet;
    }

#if 0 // nobody seems to use this one any more
/*----------------------------------------------------------
 Purpose: This function converts a wide-char string to a multi-byte
 string.

 If pszBuf is non-NULL and the converted string can fit in
 pszBuf, then *ppszAnsi will point to the given buffer.
 Otherwise, this function will allocate a buffer that can
 hold the converted string.

 If pszWide is NULL, then *ppszAnsi will be freed.  Note
 that pszBuf must be the same pointer between the call
 that converted the string and the call that frees the
 string.

 Returns: TRUE
 FALSE (if out of memory)

 Cond:    --
 */
BOOL
AnsiFromUnicode(
    LPSTR * ppszAnsi,
    LPCWSTR pwszWide,        // NULL to clean up
    LPSTR pszBuf,
    int cchBuf)
{
    BOOL bRet;

    // Convert the string?
    if (pwszWide)
    {
        // Yes; determine the converted string length
        int cch;
        LPSTR psz;

        cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, NULL, 0, NULL, NULL);

        // String too big, or is there no buffer?
        if (cch > cchBuf || NULL == pszBuf)
        {
            // Yes; allocate space
            cchBuf = cch + 1;
            psz = (LPSTR)LocalAlloc(LPTR, CbFromCchA(cchBuf));
        }
        else
        {
            // No; use the provided buffer
            ASSERT(pszBuf);
            psz = pszBuf;
        }

        if (psz)
        {
            // Convert the string
            cch = WideCharToMultiByte(CP_ACP, 0, pwszWide, -1, psz, cchBuf, NULL, NULL);
            bRet = (0 < cch);
        }
        else
        {
            bRet = FALSE;
        }

        *ppszAnsi = psz;
    }
    else
    {
        // No; was this buffer allocated?
        if (*ppszAnsi && pszBuf != *ppszAnsi)
        {
            // Yes; clean up
            LocalFree((HLOCAL)*ppszAnsi);
            *ppszAnsi = NULL;
        }
        bRet = TRUE;
    }

    return bRet;
}
#endif // 0


#if defined(DEBUG) || defined(PRODUCT_PROF)
// (c_szCcshellIniFile and c_szCcshellIniSecDebug are declared in debug.h)
extern CHAR const FAR c_szCcshellIniFile[];
extern CHAR const FAR c_szCcshellIniSecDebug[];
HANDLE g_hDebugOutputFile = INVALID_HANDLE_VALUE;


void ShellDebugAppendToDebugFileA(LPCSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbWrite = lstrlenA(pszOutputString);
        WriteFile(g_hDebugOutputFile, pszOutputString, cbWrite, &cbWrite, NULL);
    }
}

void ShellDebugAppendToDebugFileW(LPCWSTR pszOutputString)
{
    if (g_hDebugOutputFile != INVALID_HANDLE_VALUE)
    {
        char szBuf[500];

        DWORD cbWrite = WideCharToMultiByte(CP_ACP, 0, pszOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        WriteFile(g_hDebugOutputFile, szBuf, cbWrite, &cbWrite, NULL);
    }
}

//
// We cannot link to shlwapi, because comctl32 cannot link to shlwapi.
// Duplicate some functions here so unicode stuff can run on Win95 platforms.
//
VOID MyOutputDebugStringWrapW(LPCWSTR lpOutputString)
{
    if (staticIsOS(OS_NT))
    {
        OutputDebugStringW(lpOutputString);
        ShellDebugAppendToDebugFileW(lpOutputString);
    }
    else
    {
        char szBuf[500];

        WideCharToMultiByte(CP_ACP, 0, lpOutputString, -1, szBuf, ARRAYSIZE(szBuf), NULL, NULL);

        OutputDebugStringA(szBuf);
        ShellDebugAppendToDebugFileA(szBuf);
    }
}
#define OutputDebugStringW MyOutputDebugStringWrapW

VOID MyOutputDebugStringWrapA(LPCSTR lpOutputString)
{
    OutputDebugStringA(lpOutputString);
    ShellDebugAppendToDebugFileA(lpOutputString);
}

#define OutputDebugStringA MyOutputDebugStringWrapA

LPWSTR MyCharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
{
    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}
#define CharPrevW MyCharPrevWrapW

int MywvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist)
{
    if (staticIsOS(OS_NT))
    {
        return wvsprintfW(pwszOut, pwszFormat, arglist);
    }
    else
    {
        char szFormat[500];
        char szOut[1024+40]; // this is how big our ach buffers are
        int iRet;

        WideCharToMultiByte(CP_ACP, 0, pwszFormat, -1, szFormat, ARRAYSIZE(szFormat), NULL, NULL);

        iRet = wvsprintfA(szOut, szFormat, arglist);

        MultiByteToWideChar(CP_ACP, 0, szOut, -1, pwszOut, 1024+40);

        return iRet;
    }
}

#define wvsprintfW MywvsprintfWrapW

int MywsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    int iRet;
    
    va_list ArgList;
    va_start(ArgList, pwszFormat);

    iRet = MywvsprintfWrapW(pwszOut, pwszFormat, ArgList);

    va_end(ArgList);

    return iRet;
}
#define wsprintfW MywsprintfWrapW

LPWSTR lstrcpyWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    while((*pszDst++ = *pszSrc++));

    return pszDst;
}
#define lstrcpyW lstrcpyWrapW

LPWSTR lstrcatWrapW(LPWSTR pszDst, LPCWSTR pszSrc)
{
    return lstrcpyWrapW(pszDst + lstrlenW(pszDst), pszSrc);
}
#define lstrcatW lstrcatWrapW



/*----------------------------------------------------------
Purpose: Special verion of atoi.  Supports hexadecimal too.

         If this function returns FALSE, *piRet is set to 0.

Returns: TRUE if the string is a number, or contains a partial number
         FALSE if the string is not a number

Cond:    --
*/
static
BOOL
MyStrToIntExA(
    LPCSTR    pszString,
    DWORD     dwFlags,          // STIF_ bitfield
    LONGLONG FAR * piRet)
    {
    #define IS_DIGIT(ch)    InRange(ch, '0', '9')

    BOOL bRet;
    LONGLONG n;
    BOOL bNeg = FALSE;
    LPCSTR psz;
    LPCSTR pszAdj;

    // Skip leading whitespace
    //
    for (psz = pszString; *psz == ' ' || *psz == '\n' || *psz == '\t'; psz = CharNextA(psz))
        ;

    // Determine possible explicit signage
    //
    if (*psz == '+' || *psz == '-')
        {
        bNeg = (*psz == '+') ? FALSE : TRUE;
        psz++;
        }

    // Or is this hexadecimal?
    //
    pszAdj = CharNextA(psz);
    if ((STIF_SUPPORT_HEX & dwFlags) &&
        *psz == '0' && (*pszAdj == 'x' || *pszAdj == 'X'))
        {
        // Yes

        // (Never allow negative sign with hexadecimal numbers)
        bNeg = FALSE;
        psz = CharNextA(pszAdj);

        pszAdj = psz;

        // Do the conversion
        //
        for (n = 0; ; psz = CharNextA(psz))
            {
            if (IS_DIGIT(*psz))
                n = 0x10 * n + *psz - '0';
            else
                {
                CHAR ch = *psz;
                int n2;

                if (ch >= 'a')
                    ch -= 'a' - 'A';

                n2 = ch - 'A' + 0xA;
                if (n2 >= 0xA && n2 <= 0xF)
                    n = 0x10 * n + n2;
                else
                    break;
                }
            }

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }
    else
        {
        // No
        pszAdj = psz;

        // Do the conversion
        for (n = 0; IS_DIGIT(*psz); psz = CharNextA(psz))
            n = 10 * n + *psz - '0';

        // Return TRUE if there was at least one digit
        bRet = (psz != pszAdj);
        }

    *piRet = bNeg ? -n : n;

    return bRet;
    }

#endif

#ifdef DEBUG

EXTERN_C g_bUseNewLeakDetection = FALSE;

DWORD g_dwDumpFlags     = 0;        // DF_*

#ifdef FULL_DEBUG
ULONGLONG g_qwTraceFlags    = TF_ERROR | TF_WARNING;        // TF_*
DWORD g_dwBreakFlags        = BF_ASSERT | BF_ONERRORMSG;    // BF_*
#else
ULONGLONG g_qwTraceFlags    = TF_ERROR;     // TF_*
DWORD g_dwBreakFlags        = BF_ASSERT;    // BF_*
#endif

DWORD g_dwPrototype     = 0;        
DWORD g_dwFuncTraceFlags = 0;       // FTF_*

// TLS slot used to store depth for CcshellFuncMsg indentation

static DWORD g_tlsStackDepth = TLS_OUT_OF_INDEXES;

// Hack stack depth counter used when g_tlsStackDepth is not available

static DWORD g_dwHackStackDepth = 0;

static char g_szIndentLeader[] = "                                                                                ";

static WCHAR g_wszIndentLeader[] = L"                                                                                ";


static CHAR const FAR c_szNewline[] = LINE_SEPARATOR_STR;   // (Deliberately CHAR)
static WCHAR const FAR c_wszNewline[] = TEXTW(LINE_SEPARATOR_STR);

extern CHAR const FAR c_szTrace[];              // (Deliberately CHAR)
extern CHAR const FAR c_szErrorDbg[];           // (Deliberately CHAR)
extern CHAR const FAR c_szWarningDbg[];         // (Deliberately CHAR)
extern WCHAR const FAR c_wszTrace[];
extern WCHAR const FAR c_wszErrorDbg[]; 
extern WCHAR const FAR c_wszWarningDbg[];

extern const CHAR  FAR c_szAssertMsg[];
extern CHAR const FAR c_szAssertFailed[];
extern const WCHAR  FAR c_wszAssertMsg[];
extern WCHAR const FAR c_wszAssertFailed[];

extern CHAR const FAR c_szRip[];
extern CHAR const FAR c_szRipNoFn[];
extern CHAR const FAR c_szRipMsg[];
extern WCHAR const FAR c_wszRip[];
extern WCHAR const FAR c_wszRipNoFn[];


/*-------------------------------------------------------------------------
Purpose: Adds one of the following prefix strings to pszBuf:
           "t   MODULE  "
           "err MODULE  "
           "wrn MODULE  "

         Returns the count of characters written.
*/
int
SetPrefixStringA(
    OUT LPSTR pszBuf,
    IN  ULONGLONG qwFlags)
{
    if (TF_ALWAYS == qwFlags)
        lstrcpyA(pszBuf, c_szTrace);
    else if (IsFlagSet(qwFlags, TF_WARNING))
        lstrcpyA(pszBuf, c_szWarningDbg);
    else if (IsFlagSet(qwFlags, TF_ERROR))
        lstrcpyA(pszBuf, c_szErrorDbg);
    else
        lstrcpyA(pszBuf, c_szTrace);
    return lstrlenA(pszBuf);
}


int
SetPrefixStringW(
    OUT LPWSTR pszBuf,
    IN  ULONGLONG  qwFlags)
{
    if (TF_ALWAYS == qwFlags)
        lstrcpyW(pszBuf, c_wszTrace);
    else if (IsFlagSet(qwFlags, TF_WARNING))
        lstrcpyW(pszBuf, c_wszWarningDbg);
    else if (IsFlagSet(qwFlags, TF_ERROR))
        lstrcpyW(pszBuf, c_wszErrorDbg);
    else
        lstrcpyW(pszBuf, c_wszTrace);
    return lstrlenW(pszBuf);
}


static
LPCSTR
_PathFindFileNameA(
    LPCSTR pPath)
{
    LPCSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':' || pPath[0] == '/')
            && pPath[1] &&  pPath[1] != '\\'  &&   pPath[1] != '/')
            pT = pPath + 1;
    }

    return pT;
}


static
LPCWSTR
_PathFindFileNameW(
    LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; pPath++) {
        if ((pPath[0] == TEXTW('\\') || pPath[0] == TEXTW(':') || pPath[0] == TEXTW('/'))
            && pPath[1] &&  pPath[1] != TEXTW('\\')  &&   pPath[1] != TEXTW('/'))
            pT = pPath + 1;
    }

    return pT;
}


/*-------------------------------------------------------------------------
Purpose: Returns TRUE if this process is a shell-related process.
*/
BOOL _IsShellProcess()
{
    CHAR szModuleName[MAX_PATH];
    
    if (GetModuleFileNameA(NULL, szModuleName, sizeof(CHAR) * MAX_PATH) > 0 )
    {                      
        if (StrStrIA(szModuleName, "explorer.exe") || 
            StrStrIA(szModuleName, "iexplore.exe") ||
            StrStrIA(szModuleName, "rundll32.exe") || 
            StrStrIA(szModuleName, "mshtmpad.exe"))
        {
            // yes, the exe is a shell one
            return TRUE;
        }
    }

    // not a normal shell executable
    return FALSE;
}


// FEATURE (scotth): Use the Ccshell functions.  _AssertMsg and
// _DebugMsg are obsolete.  They will be removed once all the 
// components don't have TEXT() wrapping their debug strings anymore.


void 
WINCAPI 
_AssertMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyA(ach, c_szAssertMsg);
        cch = lstrlenA(ach);
        va_start(vArgs, pszMsg);

        wvsprintfA(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_AssertMsgW(
    BOOL f, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        int cch;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        wvsprintfW(&ach[cch], pszMsg, vArgs);

        va_end(vArgs);
        OutputDebugStringW(ach);

        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
_AssertStrLenW(
    LPCWSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenW(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
_AssertStrLenA(
    LPCSTR pszStr, 
    int iLen)
{
    if (pszStr && iLen < lstrlenA(pszStr))
    {                                           
        // MSDEV USERS:  This is not the real assert.  Hit 
        //               Shift-F11 to jump back to the caller.
        DEBUG_BREAK;                                                            // ASSERT
    }
}

void 
WINCAPI 
_DebugMsgA(
    ULONGLONG flag, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        cch = SetPrefixStringA(ach, flag);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfA(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringA(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringA(ach);
        OutputDebugStringA(c_szNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
}

void 
WINCAPI 
_DebugMsgW(
    ULONGLONG flag, 
    LPCWSTR pszMsg, ...)
{
    WCHAR ach[5*MAX_PATH+40];  // Handles 5*largest path + slop for message
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        try
        {
            wvsprintfW(&ach[cch], pszMsg, vArgs);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            OutputDebugString(TEXT("CCSHELL: DebugMsg exception: "));
            OutputDebugStringW(pszMsg);
        }
        __endexcept

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                        // ASSERT
        }
    }
}


//
//  Smart debug functions
//



/*----------------------------------------------------------
Purpose: Displays assertion string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellAssertFailedA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szAssertFailed, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays assertion string.

*/
BOOL
CcshellAssertFailedW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[1024];    // Some callers use more than 256

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  We can get this
    // if we get an assert in some of the W functions in shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellAssertFailedA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszAssertFailed, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
    {
        if (bBreakInside)
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

Returns: TRUE to debugbreak
*/
BOOL
CcshellRipA(
    LPCSTR pszFile,
    int line,
    LPCSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCSTR psz;
    CHAR ach[256];

    psz = _PathFindFileNameA(pszFile);
    wsprintfA(ach, c_szRipNoFn, psz, line, pszEval);
    OutputDebugStringA(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
            
            // MSDEV USERS:  This is not the real RIP.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}


/*----------------------------------------------------------
Purpose: Displays a RIP string.

*/
BOOL
CcshellRipW(
    LPCWSTR pszFile,
    int line,
    LPCWSTR pszEval,
    BOOL bBreakInside)
{
    BOOL bRet = FALSE;
    LPCWSTR psz;
    WCHAR ach[256];

    psz = _PathFindFileNameW(pszFile);

    // If psz == NULL, CharPrevW failed which implies we are running on Win95.  
    // We can get this if we get an assert in some of the W functions in 
    // shlwapi...  Call the A version of assert...
    if (!psz)
    {
        char szFile[MAX_PATH];
        char szEval[256];   // since the total output is thhis size should be enough...

        WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szFile, ARRAYSIZE(szFile), NULL, NULL);
        WideCharToMultiByte(CP_ACP, 0, pszEval, -1, szEval, ARRAYSIZE(szEval), NULL, NULL);
        return CcshellRipA(szFile, line, szEval, bBreakInside);
    }

    wsprintfW(ach, c_wszRipNoFn, psz, line, pszEval);
    OutputDebugStringW(ach);

    if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
    {
        if (bBreakInside)
        {
            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!

            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  RIP  !!!!  RIP  !!!!  RIP !!!
        }
        else
            bRet = TRUE;
    }

    return bRet;
}

BOOL
WINCAPI 
CcshellRipMsgA(
    BOOL f, 
    LPCSTR pszMsg, ...)
{
    CHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        OutputDebugStringA(c_szRipMsg);

        va_start(vArgs, pszMsg);
        wvsprintfA(ach, pszMsg, vArgs);
        va_end(vArgs);
        OutputDebugStringA(ach);

        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

BOOL
WINCAPI 
CcshellRipMsgW(
    BOOL f, 
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];
    va_list vArgs;

    if (!f)
    {
        LPWSTR pwsz;
        WCHAR wszBuf[128];
        OutputDebugStringA(c_szRipMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        ach[0] = L'\0';     // In case this fails
        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            va_start(vArgs, pszMsg);
            wvsprintfW(ach, pwsz, vArgs);
            va_end(vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        OutputDebugStringW(ach);
        OutputDebugStringA(c_szNewline);

        if (_IsShellProcess() || IsFlagSet(g_dwBreakFlags, BF_RIP))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                            // ASSERT
        }
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: Keep track of the stack depth for function call trace
         messages.

*/
void
CcshellStackEnter(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth + 1));
        }
    else
        {
        g_dwHackStackDepth++;
        }
    }


/*----------------------------------------------------------
Purpose: Keep track of the stack depth for functionc all trace
         messages.

*/
void
CcshellStackLeave(void)
    {
    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        DWORD dwDepth;

        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));

        if (EVAL(0 < dwDepth))
            {
            EVAL(TlsSetValue(g_tlsStackDepth, (LPVOID)(ULONG_PTR)(dwDepth - 1)));
            }
        }
    else
        {
        if (EVAL(0 < g_dwHackStackDepth))
            {
            g_dwHackStackDepth--;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Return the stack depth.

*/
static
DWORD
CcshellGetStackDepth(void)
    {
    DWORD dwDepth;

    if (TLS_OUT_OF_INDEXES != g_tlsStackDepth)
        {
        dwDepth = PtrToUlong(TlsGetValue(g_tlsStackDepth));
        }
    else
        {
        dwDepth = g_dwHackStackDepth;
        }

    return dwDepth;
    }


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellAssertMsgA
*/
void
CDECL
CcshellAssertMsgW(
    BOOL f,
    LPCSTR pszMsg, ...)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (!f)
        {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        lstrcpyW(ach, c_wszAssertMsg);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
            {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
            }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (IsFlagSet(g_dwBreakFlags, BF_ASSERT))
        {
            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
            
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT

            // !!!  ASSERT  !!!!  ASSERT  !!!!  ASSERT !!!
        }
    }
}


/*----------------------------------------------------------
Purpose: Wide-char version of CcshellDebugMsgA.  Note this
         function deliberately takes an ANSI format string
         so our trace messages don't all need to be wrapped
         in TEXT().

*/
void
CDECL
CcshellDebugMsgW(
    ULONGLONG flag,
    LPCSTR pszMsg, ...)         // (this is deliberately CHAR)
{
    WCHAR ach[1024+40];    // Largest path plus extra
    va_list vArgs;

    if (TF_ALWAYS == flag || (IsFlagSet(g_qwTraceFlags, flag) && flag))
    {
        int cch;
        WCHAR wszBuf[1024];
        LPWSTR pwsz;

        SetPrefixStringW(ach, flag);
        cch = lstrlenW(ach);
        va_start(vArgs, pszMsg);

        // (We convert the string, rather than simply input an
        // LPCWSTR parameter, so the caller doesn't have to wrap
        // all the string constants with the TEXT() macro.)

        if (UnicodeFromAnsi(&pwsz, pszMsg, wszBuf, SIZECHARS(wszBuf)))
        {
            wvsprintfW(&ach[cch], pwsz, vArgs);
            UnicodeFromAnsi(&pwsz, NULL, wszBuf, 0);
        }

        va_end(vArgs);
        OutputDebugStringW(ach);
        OutputDebugStringW(c_wszNewline);

        if (TF_ALWAYS != flag &&
            ((flag & TF_ERROR) && IsFlagSet(g_dwBreakFlags, BF_ONERRORMSG) ||
             (flag & TF_WARNING) && IsFlagSet(g_dwBreakFlags, BF_ONWARNMSG)))
        {
            // MSDEV USERS:  This is not the real assert.  Hit 
            //               Shift-F11 to jump back to the caller.
            DEBUG_BREAK;                                                // ASSERT
        }
    }
}


/*-------------------------------------------------------------------------
Purpose: Since the ATL code does not pass in a flag parameter,
         we'll hardcode and check for TF_ATL.
*/
void CDECL ShellAtlTraceW(L